<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/pci/pci.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n * PCI Bus Services, see include/linux/pci.h for further explanation.\n *\n * Copyright 1993 -- 1997 Drew Eckhardt, Frederic Potter,\n * David Mosberger-Tang\n *\n * Copyright 1997 -- 2000 Martin Mares <mj@ucw.cz>\n */\n\n#include <linux/acpi.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/init.h>\n#include <linux/msi.h>\n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/log2.h>\n#include <linux/logic_pio.h>\n#include <linux/pm_wakeup.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/pm_runtime.h>\n#include <linux/pci_hotplug.h>\n#include <linux/vmalloc.h>\n#include <asm/dma.h>\n#include <linux/aer.h>\n#include \"pci.h\"\n\nDEFINE_MUTEX(pci_slot_mutex);\n\nconst char *pci_power_names[] = {\n\t\"error\", \"D0\", \"D1\", \"D2\", \"D3hot\", \"D3cold\", \"unknown\",\n};\nEXPORT_SYMBOL_GPL(pci_power_names);\n\nint isa_dma_bridge_buggy;\nEXPORT_SYMBOL(isa_dma_bridge_buggy);\n\nint pci_pci_problems;\nEXPORT_SYMBOL(pci_pci_problems);\n\nunsigned int pci_pm_d3hot_delay;\n\nstatic void pci_pme_list_scan(struct work_struct *work);\n\nstatic LIST_HEAD(pci_pme_list);\nstatic DEFINE_MUTEX(pci_pme_list_mutex);\nstatic DECLARE_DELAYED_WORK(pci_pme_work, pci_pme_list_scan);\n\nstruct pci_pme_device {\n\tstruct list_head list;\n\tstruct pci_dev *dev;\n};\n\n#define PME_TIMEOUT 1000 /* How long between PME checks */\n\nstatic void pci_dev_d3_sleep(struct pci_dev *dev)\n{\n\tunsigned int delay = dev->d3hot_delay;\n\n\tif (delay < pci_pm_d3hot_delay)\n\t\tdelay = pci_pm_d3hot_delay;\n\n\tif (delay)\n\t\tmsleep(delay);\n}\n\n#ifdef CONFIG_PCI_DOMAINS\nint pci_domains_supported = 1;\n#endif\n\n#define DEFAULT_CARDBUS_IO_SIZE\t\t(256)\n#define DEFAULT_CARDBUS_MEM_SIZE\t(64*1024*1024)\n/* pci=cbmemsize=nnM,cbiosize=nn can override this */\nunsigned long pci_cardbus_io_size = DEFAULT_CARDBUS_IO_SIZE;\nunsigned long pci_cardbus_mem_size = DEFAULT_CARDBUS_MEM_SIZE;\n\n#define DEFAULT_HOTPLUG_IO_SIZE\t\t(256)\n#define DEFAULT_HOTPLUG_MMIO_SIZE\t(2*1024*1024)\n#define DEFAULT_HOTPLUG_MMIO_PREF_SIZE\t(2*1024*1024)\n/* hpiosize=nn can override this */\nunsigned long pci_hotplug_io_size  = DEFAULT_HOTPLUG_IO_SIZE;\n/*\n * pci=hpmmiosize=nnM overrides non-prefetchable MMIO size,\n * pci=hpmmioprefsize=nnM overrides prefetchable MMIO size;\n * pci=hpmemsize=nnM overrides both\n */\nunsigned long pci_hotplug_mmio_size = DEFAULT_HOTPLUG_MMIO_SIZE;\nunsigned long pci_hotplug_mmio_pref_size = DEFAULT_HOTPLUG_MMIO_PREF_SIZE;\n\n#define DEFAULT_HOTPLUG_BUS_SIZE\t1\nunsigned long pci_hotplug_bus_size = DEFAULT_HOTPLUG_BUS_SIZE;\n\n\n/* PCIe MPS/MRRS strategy; can be overridden by kernel command-line param */\n#ifdef CONFIG_PCIE_BUS_TUNE_OFF\nenum pcie_bus_config_types pcie_bus_config = PCIE_BUS_TUNE_OFF;\n#elif defined CONFIG_PCIE_BUS_SAFE\nenum pcie_bus_config_types pcie_bus_config = PCIE_BUS_SAFE;\n#elif defined CONFIG_PCIE_BUS_PERFORMANCE\nenum pcie_bus_config_types pcie_bus_config = PCIE_BUS_PERFORMANCE;\n#elif defined CONFIG_PCIE_BUS_PEER2PEER\nenum pcie_bus_config_types pcie_bus_config = PCIE_BUS_PEER2PEER;\n#else\nenum pcie_bus_config_types pcie_bus_config = PCIE_BUS_DEFAULT;\n#endif\n\n/*\n * The default CLS is used if arch didn't set CLS explicitly and not\n * all pci devices agree on the same value.  Arch can override either\n * the dfl or actual value as it sees fit.  Don't forget this is\n * measured in 32-bit words, not bytes.\n */\nu8 pci_dfl_cache_line_size = L1_CACHE_BYTES >> 2;\nu8 pci_cache_line_size;\n\n/*\n * If we set up a device for bus mastering, we need to check the latency\n * timer as certain BIOSes forget to set it properly.\n */\nunsigned int pcibios_max_latency = 255;\n\n/* If set, the PCIe ARI capability will not be used. */\nstatic bool pcie_ari_disabled;\n\n/* If set, the PCIe ATS capability will not be used. */\nstatic bool pcie_ats_disabled;\n\n/* If set, the PCI config space of each device is printed during boot. */\nbool pci_early_dump;\n\nbool pci_ats_disabled(void)\n{\n\treturn pcie_ats_disabled;\n}\nEXPORT_SYMBOL_GPL(pci_ats_disabled);\n\n/* Disable bridge_d3 for all PCIe ports */\nstatic bool pci_bridge_d3_disable;\n/* Force bridge_d3 for all PCIe ports */\nstatic bool pci_bridge_d3_force;\n\nstatic int __init pcie_port_pm_setup(char *str)\n{\n\tif (!strcmp(str, \"off\"))\n\t\tpci_bridge_d3_disable = true;\n\telse if (!strcmp(str, \"force\"))\n\t\tpci_bridge_d3_force = true;\n\treturn 1;\n}\n__setup(\"pcie_port_pm=\", pcie_port_pm_setup);\n\n/* Time to wait after a reset for device to become responsive */\n#define PCIE_RESET_READY_POLL_MS 60000\n\n/**\n * pci_bus_max_busnr - returns maximum PCI bus number of given bus' children\n * @bus: pointer to PCI bus structure to search\n *\n * Given a PCI bus, returns the highest PCI bus number present in the set\n * including the given PCI bus and its list of child PCI buses.\n */\nunsigned char pci_bus_max_busnr(struct pci_bus *bus)\n{\n\tstruct pci_bus *tmp;\n\tunsigned char max, n;\n\n\tmax = bus->busn_res.end;\n\tlist_for_each_entry(tmp, &bus->children, node) {\n\t\tn = pci_bus_max_busnr(tmp);\n\t\tif (n > max)\n\t\t\tmax = n;\n\t}\n\treturn max;\n}\nEXPORT_SYMBOL_GPL(pci_bus_max_busnr);\n\n/**\n * pci_status_get_and_clear_errors - return and clear error bits in PCI_STATUS\n * @pdev: the PCI device\n *\n * Returns error bits set in PCI_STATUS and clears them.\n */\nint pci_status_get_and_clear_errors(struct pci_dev *pdev)\n{\n\tu16 status;\n\tint ret;\n\n\tret = pci_read_config_word(pdev, PCI_STATUS, &status);\n\tif (ret != PCIBIOS_SUCCESSFUL)\n\t\treturn -EIO;\n\n\tstatus &= PCI_STATUS_ERROR_BITS;\n\tif (status)\n\t\tpci_write_config_word(pdev, PCI_STATUS, status);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(pci_status_get_and_clear_errors);\n\n#ifdef CONFIG_HAS_IOMEM\nvoid __iomem *pci_ioremap_bar(struct pci_dev *pdev, int bar)\n{\n\tstruct resource *res = &pdev->resource[bar];\n\n\t/*\n\t * Make sure the BAR is actually a memory resource, not an IO resource\n\t */\n\tif (res->flags & IORESOURCE_UNSET || !(res->flags & IORESOURCE_MEM)) {\n\t\tpci_warn(pdev, \"can't ioremap BAR %d: %pR\\n\", bar, res);\n\t\treturn NULL;\n\t}\n\treturn ioremap(res->start, resource_size(res));\n}\nEXPORT_SYMBOL_GPL(pci_ioremap_bar);\n\nvoid __iomem *pci_ioremap_wc_bar(struct pci_dev *pdev, int bar)\n{\n\t/*\n\t * Make sure the BAR is actually a memory resource, not an IO resource\n\t */\n\tif (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM)) {\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\treturn ioremap_wc(pci_resource_start(pdev, bar),\n\t\t\t  pci_resource_len(pdev, bar));\n}\nEXPORT_SYMBOL_GPL(pci_ioremap_wc_bar);\n#endif\n\n/**\n * pci_dev_str_match_path - test if a path string matches a device\n * @dev: the PCI device to test\n * @path: string to match the device against\n * @endptr: pointer to the string after the match\n *\n * Test if a string (typically from a kernel parameter) formatted as a\n * path of device/function addresses matches a PCI device. The string must\n * be of the form:\n *\n *   [<domain>:]<bus>:<device>.<func>[/<device>.<func>]*\n *\n * A path for a device can be obtained using 'lspci -t'.  Using a path\n * is more robust against bus renumbering than using only a single bus,\n * device and function address.\n *\n * Returns 1 if the string matches the device, 0 if it does not and\n * a negative error code if it fails to parse the string.\n */\nstatic int pci_dev_str_match_path(struct pci_dev *dev, const char *path,\n\t\t\t\t  const char **endptr)\n{\n\tint ret;\n\tint seg, bus, slot, func;\n\tchar *wpath, *p;\n\tchar end;\n\n\t*endptr = strchrnul(path, ';');\n\n\twpath = kmemdup_nul(path, *endptr - path, GFP_KERNEL);\n\tif (!wpath)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tp = strrchr(wpath, '/');\n\t\tif (!p)\n\t\t\tbreak;\n\t\tret = sscanf(p, \"/%x.%x%c\", &slot, &func, &end);\n\t\tif (ret != 2) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_and_exit;\n\t\t}\n\n\t\tif (dev->devfn != PCI_DEVFN(slot, func)) {\n\t\t\tret = 0;\n\t\t\tgoto free_and_exit;\n\t\t}\n\n\t\t/*\n\t\t * Note: we don't need to get a reference to the upstream\n\t\t * bridge because we hold a reference to the top level\n\t\t * device which should hold a reference to the bridge,\n\t\t * and so on.\n\t\t */\n\t\tdev = pci_upstream_bridge(dev);\n\t\tif (!dev) {\n\t\t\tret = 0;\n\t\t\tgoto free_and_exit;\n\t\t}\n\n\t\t*p = 0;\n\t}\n\n\tret = sscanf(wpath, \"%x:%x:%x.%x%c\", &seg, &bus, &slot,\n\t\t     &func, &end);\n\tif (ret != 4) {\n\t\tseg = 0;\n\t\tret = sscanf(wpath, \"%x:%x.%x%c\", &bus, &slot, &func, &end);\n\t\tif (ret != 3) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_and_exit;\n\t\t}\n\t}\n\n\tret = (seg == pci_domain_nr(dev->bus) &&\n\t       bus == dev->bus->number &&\n\t       dev->devfn == PCI_DEVFN(slot, func));\n\nfree_and_exit:\n\tkfree(wpath);\n\treturn ret;\n}\n\n/**\n * pci_dev_str_match - test if a string matches a device\n * @dev: the PCI device to test\n * @p: string to match the device against\n * @endptr: pointer to the string after the match\n *\n * Test if a string (typically from a kernel parameter) matches a specified\n * PCI device. The string may be of one of the following formats:\n *\n *   [<domain>:]<bus>:<device>.<func>[/<device>.<func>]*\n *   pci:<vendor>:<device>[:<subvendor>:<subdevice>]\n *\n * The first format specifies a PCI bus/device/function address which\n * may change if new hardware is inserted, if motherboard firmware changes,\n * or due to changes caused in kernel parameters. If the domain is\n * left unspecified, it is taken to be 0.  In order to be robust against\n * bus renumbering issues, a path of PCI device/function numbers may be used\n * to address the specific device.  The path for a device can be determined\n * through the use of 'lspci -t'.\n *\n * The second format matches devices using IDs in the configuration\n * space which may match multiple devices in the system. A value of 0\n * for any field will match all devices. (Note: this differs from\n * in-kernel code that uses PCI_ANY_ID which is ~0; this is for\n * legacy reasons and convenience so users don't have to specify\n * FFFFFFFFs on the command line.)\n *\n * Returns 1 if the string matches the device, 0 if it does not and\n * a negative error code if the string cannot be parsed.\n */\nstatic int pci_dev_str_match(struct pci_dev *dev, const char *p,\n\t\t\t     const char **endptr)\n{\n\tint ret;\n\tint count;\n\tunsigned short vendor, device, subsystem_vendor, subsystem_device;\n\n\tif (strncmp(p, \"pci:\", 4) == 0) {\n\t\t/* PCI vendor/device (subvendor/subdevice) IDs are specified */\n\t\tp += 4;\n\t\tret = sscanf(p, \"%hx:%hx:%hx:%hx%n\", &vendor, &device,\n\t\t\t     &subsystem_vendor, &subsystem_device, &count);\n\t\tif (ret != 4) {\n\t\t\tret = sscanf(p, \"%hx:%hx%n\", &vendor, &device, &count);\n\t\t\tif (ret != 2)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsubsystem_vendor = 0;\n\t\t\tsubsystem_device = 0;\n\t\t}\n\n\t\tp += count;\n\n\t\tif ((!vendor || vendor == dev->vendor) &&\n\t\t    (!device || device == dev->device) &&\n\t\t    (!subsystem_vendor ||\n\t\t\t    subsystem_vendor == dev->subsystem_vendor) &&\n\t\t    (!subsystem_device ||\n\t\t\t    subsystem_device == dev->subsystem_device))\n\t\t\tgoto found;\n\t} else {\n\t\t/*\n\t\t * PCI Bus, Device, Function IDs are specified\n\t\t * (optionally, may include a path of devfns following it)\n\t\t */\n\t\tret = pci_dev_str_match_path(dev, p, &p);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret)\n\t\t\tgoto found;\n\t}\n\n\t*endptr = p;\n\treturn 0;\n\nfound:\n\t*endptr = p;\n\treturn 1;\n}\n\nstatic int __pci_find_next_cap_ttl(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t   u8 pos, int cap, int *ttl)\n{\n\tu8 id;\n\tu16 ent;\n\n\tpci_bus_read_config_byte(bus, devfn, pos, &pos);\n\n\twhile ((*ttl)--) {\n\t\tif (pos < 0x40)\n\t\t\tbreak;\n\t\tpos &= ~3;\n\t\tpci_bus_read_config_word(bus, devfn, pos, &ent);\n\n\t\tid = ent & 0xff;\n\t\tif (id == 0xff)\n\t\t\tbreak;\n\t\tif (id == cap)\n\t\t\treturn pos;\n\t\tpos = (ent >> 8);\n\t}\n\treturn 0;\n}\n\nstatic int __pci_find_next_cap(struct pci_bus *bus, unsigned int devfn,\n\t\t\t       u8 pos, int cap)\n{\n\tint ttl = PCI_FIND_CAP_TTL;\n\n\treturn __pci_find_next_cap_ttl(bus, devfn, pos, cap, &ttl);\n}\n\nint pci_find_next_capability(struct pci_dev *dev, u8 pos, int cap)\n{\n\treturn __pci_find_next_cap(dev->bus, dev->devfn,\n\t\t\t\t   pos + PCI_CAP_LIST_NEXT, cap);\n}\nEXPORT_SYMBOL_GPL(pci_find_next_capability);\n\nstatic int __pci_bus_find_cap_start(struct pci_bus *bus,\n\t\t\t\t    unsigned int devfn, u8 hdr_type)\n{\n\tu16 status;\n\n\tpci_bus_read_config_word(bus, devfn, PCI_STATUS, &status);\n\tif (!(status & PCI_STATUS_CAP_LIST))\n\t\treturn 0;\n\n\tswitch (hdr_type) {\n\tcase PCI_HEADER_TYPE_NORMAL:\n\tcase PCI_HEADER_TYPE_BRIDGE:\n\t\treturn PCI_CAPABILITY_LIST;\n\tcase PCI_HEADER_TYPE_CARDBUS:\n\t\treturn PCI_CB_CAPABILITY_LIST;\n\t}\n\n\treturn 0;\n}\n\n/**\n * pci_find_capability - query for devices' capabilities\n * @dev: PCI device to query\n * @cap: capability code\n *\n * Tell if a device supports a given PCI capability.\n * Returns the address of the requested capability structure within the\n * device's PCI configuration space or 0 in case the device does not\n * support it.  Possible values for @cap include:\n *\n *  %PCI_CAP_ID_PM           Power Management\n *  %PCI_CAP_ID_AGP          Accelerated Graphics Port\n *  %PCI_CAP_ID_VPD          Vital Product Data\n *  %PCI_CAP_ID_SLOTID       Slot Identification\n *  %PCI_CAP_ID_MSI          Message Signalled Interrupts\n *  %PCI_CAP_ID_CHSWP        CompactPCI HotSwap\n *  %PCI_CAP_ID_PCIX         PCI-X\n *  %PCI_CAP_ID_EXP          PCI Express\n */\nint pci_find_capability(struct pci_dev *dev, int cap)\n{\n\tint pos;\n\n\tpos = __pci_bus_find_cap_start(dev->bus, dev->devfn, dev->hdr_type);\n\tif (pos)\n\t\tpos = __pci_find_next_cap(dev->bus, dev->devfn, pos, cap);\n\n\treturn pos;\n}\nEXPORT_SYMBOL(pci_find_capability);\n\n/**\n * pci_bus_find_capability - query for devices' capabilities\n * @bus: the PCI bus to query\n * @devfn: PCI device to query\n * @cap: capability code\n *\n * Like pci_find_capability() but works for PCI devices that do not have a\n * pci_dev structure set up yet.\n *\n * Returns the address of the requested capability structure within the\n * device's PCI configuration space or 0 in case the device does not\n * support it.\n */\nint pci_bus_find_capability(struct pci_bus *bus, unsigned int devfn, int cap)\n{\n\tint pos;\n\tu8 hdr_type;\n\n\tpci_bus_read_config_byte(bus, devfn, PCI_HEADER_TYPE, &hdr_type);\n\n\tpos = __pci_bus_find_cap_start(bus, devfn, hdr_type & 0x7f);\n\tif (pos)\n\t\tpos = __pci_find_next_cap(bus, devfn, pos, cap);\n\n\treturn pos;\n}\nEXPORT_SYMBOL(pci_bus_find_capability);\n\n/**\n * pci_find_next_ext_capability - Find an extended capability\n * @dev: PCI device to query\n * @start: address at which to start looking (0 to start at beginning of list)\n * @cap: capability code\n *\n * Returns the address of the next matching extended capability structure\n * within the device's PCI configuration space or 0 if the device does\n * not support it.  Some capabilities can occur several times, e.g., the\n * vendor-specific capability, and this provides a way to find them all.\n */\nint pci_find_next_ext_capability(struct pci_dev *dev, int start, int cap)\n{\n\tu32 header;\n\tint ttl;\n\tint pos = PCI_CFG_SPACE_SIZE;\n\n\t/* minimum 8 bytes per capability */\n\tttl = (PCI_CFG_SPACE_EXP_SIZE - PCI_CFG_SPACE_SIZE) / 8;\n\n\tif (dev->cfg_size <= PCI_CFG_SPACE_SIZE)\n\t\treturn 0;\n\n\tif (start)\n\t\tpos = start;\n\n\tif (pci_read_config_dword(dev, pos, &header) != PCIBIOS_SUCCESSFUL)\n\t\treturn 0;\n\n\t/*\n\t * If we have no capabilities, this is indicated by cap ID,\n\t * cap version and next pointer all being 0.\n\t */\n\tif (header == 0)\n\t\treturn 0;\n\n\twhile (ttl-- > 0) {\n\t\tif (PCI_EXT_CAP_ID(header) == cap && pos != start)\n\t\t\treturn pos;\n\n\t\tpos = PCI_EXT_CAP_NEXT(header);\n\t\tif (pos < PCI_CFG_SPACE_SIZE)\n\t\t\tbreak;\n\n\t\tif (pci_read_config_dword(dev, pos, &header) != PCIBIOS_SUCCESSFUL)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pci_find_next_ext_capability);\n\n/**\n * pci_find_ext_capability - Find an extended capability\n * @dev: PCI device to query\n * @cap: capability code\n *\n * Returns the address of the requested extended capability structure\n * within the device's PCI configuration space or 0 if the device does\n * not support it.  Possible values for @cap include:\n *\n *  %PCI_EXT_CAP_ID_ERR\t\tAdvanced Error Reporting\n *  %PCI_EXT_CAP_ID_VC\t\tVirtual Channel\n *  %PCI_EXT_CAP_ID_DSN\t\tDevice Serial Number\n *  %PCI_EXT_CAP_ID_PWR\t\tPower Budgeting\n */\nint pci_find_ext_capability(struct pci_dev *dev, int cap)\n{\n\treturn pci_find_next_ext_capability(dev, 0, cap);\n}\nEXPORT_SYMBOL_GPL(pci_find_ext_capability);\n\n/**\n * pci_get_dsn - Read and return the 8-byte Device Serial Number\n * @dev: PCI device to query\n *\n * Looks up the PCI_EXT_CAP_ID_DSN and reads the 8 bytes of the Device Serial\n * Number.\n *\n * Returns the DSN, or zero if the capability does not exist.\n */\nu64 pci_get_dsn(struct pci_dev *dev)\n{\n\tu32 dword;\n\tu64 dsn;\n\tint pos;\n\n\tpos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DSN);\n\tif (!pos)\n\t\treturn 0;\n\n\t/*\n\t * The Device Serial Number is two dwords offset 4 bytes from the\n\t * capability position. The specification says that the first dword is\n\t * the lower half, and the second dword is the upper half.\n\t */\n\tpos += 4;\n\tpci_read_config_dword(dev, pos, &dword);\n\tdsn = (u64)dword;\n\tpci_read_config_dword(dev, pos + 4, &dword);\n\tdsn |= ((u64)dword) << 32;\n\n\treturn dsn;\n}\nEXPORT_SYMBOL_GPL(pci_get_dsn);\n\nstatic int __pci_find_next_ht_cap(struct pci_dev *dev, int pos, int ht_cap)\n{\n\tint rc, ttl = PCI_FIND_CAP_TTL;\n\tu8 cap, mask;\n\n\tif (ht_cap == HT_CAPTYPE_SLAVE || ht_cap == HT_CAPTYPE_HOST)\n\t\tmask = HT_3BIT_CAP_MASK;\n\telse\n\t\tmask = HT_5BIT_CAP_MASK;\n\n\tpos = __pci_find_next_cap_ttl(dev->bus, dev->devfn, pos,\n\t\t\t\t      PCI_CAP_ID_HT, &ttl);\n\twhile (pos) {\n\t\trc = pci_read_config_byte(dev, pos + 3, &cap);\n\t\tif (rc != PCIBIOS_SUCCESSFUL)\n\t\t\treturn 0;\n\n\t\tif ((cap & mask) == ht_cap)\n\t\t\treturn pos;\n\n\t\tpos = __pci_find_next_cap_ttl(dev->bus, dev->devfn,\n\t\t\t\t\t      pos + PCI_CAP_LIST_NEXT,\n\t\t\t\t\t      PCI_CAP_ID_HT, &ttl);\n\t}\n\n\treturn 0;\n}\n/**\n * pci_find_next_ht_capability - query a device's Hypertransport capabilities\n * @dev: PCI device to query\n * @pos: Position from which to continue searching\n * @ht_cap: Hypertransport capability code\n *\n * To be used in conjunction with pci_find_ht_capability() to search for\n * all capabilities matching @ht_cap. @pos should always be a value returned\n * from pci_find_ht_capability().\n *\n * NB. To be 100% safe against broken PCI devices, the caller should take\n * steps to avoid an infinite loop.\n */\nint pci_find_next_ht_capability(struct pci_dev *dev, int pos, int ht_cap)\n{\n\treturn __pci_find_next_ht_cap(dev, pos + PCI_CAP_LIST_NEXT, ht_cap);\n}\nEXPORT_SYMBOL_GPL(pci_find_next_ht_capability);\n\n/**\n * pci_find_ht_capability - query a device's Hypertransport capabilities\n * @dev: PCI device to query\n * @ht_cap: Hypertransport capability code\n *\n * Tell if a device supports a given Hypertransport capability.\n * Returns an address within the device's PCI configuration space\n * or 0 in case the device does not support the request capability.\n * The address points to the PCI capability, of type PCI_CAP_ID_HT,\n * which has a Hypertransport capability matching @ht_cap.\n */\nint pci_find_ht_capability(struct pci_dev *dev, int ht_cap)\n{\n\tint pos;\n\n\tpos = __pci_bus_find_cap_start(dev->bus, dev->devfn, dev->hdr_type);\n\tif (pos)\n\t\tpos = __pci_find_next_ht_cap(dev, pos, ht_cap);\n\n\treturn pos;\n}\nEXPORT_SYMBOL_GPL(pci_find_ht_capability);\n\n/**\n * pci_find_parent_resource - return resource region of parent bus of given\n *\t\t\t      region\n * @dev: PCI device structure contains resources to be searched\n * @res: child resource record for which parent is sought\n *\n * For given resource region of given device, return the resource region of\n * parent bus the given region is contained in.\n */\nstruct resource *pci_find_parent_resource(const struct pci_dev *dev,\n\t\t\t\t\t  struct resource *res)\n{\n\tconst struct pci_bus *bus = dev->bus;\n\tstruct resource *r;\n\tint i;\n\n\tpci_bus_for_each_resource(bus, r, i) {\n\t\tif (!r)\n\t\t\tcontinue;\n\t\tif (resource_contains(r, res)) {\n\n\t\t\t/*\n\t\t\t * If the window is prefetchable but the BAR is\n\t\t\t * not, the allocator made a mistake.\n\t\t\t */\n\t\t\tif (r->flags & IORESOURCE_PREFETCH &&\n\t\t\t    !(res->flags & IORESOURCE_PREFETCH))\n\t\t\t\treturn NULL;\n\n\t\t\t/*\n\t\t\t * If we're below a transparent bridge, there may\n\t\t\t * be both a positively-decoded aperture and a\n\t\t\t * subtractively-decoded region that contain the BAR.\n\t\t\t * We want the positively-decoded one, so this depends\n\t\t\t * on pci_bus_for_each_resource() giving us those\n\t\t\t * first.\n\t\t\t */\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(pci_find_parent_resource);\n\n/**\n * pci_find_resource - Return matching PCI device resource\n * @dev: PCI device to query\n * @res: Resource to look for\n *\n * Goes over standard PCI resources (BARs) and checks if the given resource\n * is partially or fully contained in any of them. In that case the\n * matching resource is returned, %NULL otherwise.\n */\nstruct resource *pci_find_resource(struct pci_dev *dev, struct resource *res)\n{\n\tint i;\n\n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\n\t\tstruct resource *r = &dev->resource[i];\n\n\t\tif (r->start && resource_contains(r, res))\n\t\t\treturn r;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(pci_find_resource);\n\n/**\n * pci_wait_for_pending - wait for @mask bit(s) to clear in status word @pos\n * @dev: the PCI device to operate on\n * @pos: config space offset of status word\n * @mask: mask of bit(s) to care about in status word\n *\n * Return 1 when mask bit(s) in status word clear, 0 otherwise.\n */\nint pci_wait_for_pending(struct pci_dev *dev, int pos, u16 mask)\n{\n\tint i;\n\n\t/* Wait for Transaction Pending bit clean */\n\tfor (i = 0; i < 4; i++) {\n\t\tu16 status;\n\t\tif (i)\n\t\t\tmsleep((1 << (i - 1)) * 100);\n\n\t\tpci_read_config_word(dev, pos, &status);\n\t\tif (!(status & mask))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int pci_acs_enable;\n\n/**\n * pci_request_acs - ask for ACS to be enabled if supported\n */\nvoid pci_request_acs(void)\n{\n\tpci_acs_enable = 1;\n}\n\nstatic const char *disable_acs_redir_param;\n\n/**\n * pci_disable_acs_redir - disable ACS redirect capabilities\n * @dev: the PCI device\n *\n * For only devices specified in the disable_acs_redir parameter.\n */\nstatic void pci_disable_acs_redir(struct pci_dev *dev)\n{\n\tint ret = 0;\n\tconst char *p;\n\tint pos;\n\tu16 ctrl;\n\n\tif (!disable_acs_redir_param)\n\t\treturn;\n\n\tp = disable_acs_redir_param;\n\twhile (*p) {\n\t\tret = pci_dev_str_match(dev, p, &p);\n\t\tif (ret < 0) {\n\t\t\tpr_info_once(\"PCI: Can't parse disable_acs_redir parameter: %s\\n\",\n\t\t\t\t     disable_acs_redir_param);\n\n\t\t\tbreak;\n\t\t} else if (ret == 1) {\n\t\t\t/* Found a match */\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p != ';' && *p != ',') {\n\t\t\t/* End of param or invalid format */\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\n\tif (ret != 1)\n\t\treturn;\n\n\tif (!pci_dev_specific_disable_acs_redir(dev))\n\t\treturn;\n\n\tpos = dev->acs_cap;\n\tif (!pos) {\n\t\tpci_warn(dev, \"cannot disable ACS redirect for this hardware as it does not have ACS capabilities\\n\");\n\t\treturn;\n\t}\n\n\tpci_read_config_word(dev, pos + PCI_ACS_CTRL, &ctrl);\n\n\t/* P2P Request & Completion Redirect */\n\tctrl &= ~(PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_EC);\n\n\tpci_write_config_word(dev, pos + PCI_ACS_CTRL, ctrl);\n\n\tpci_info(dev, \"disabled ACS redirect\\n\");\n}\n\n/**\n * pci_std_enable_acs - enable ACS on devices using standard ACS capabilities\n * @dev: the PCI device\n */\nstatic void pci_std_enable_acs(struct pci_dev *dev)\n{\n\tint pos;\n\tu16 cap;\n\tu16 ctrl;\n\n\tpos = dev->acs_cap;\n\tif (!pos)\n\t\treturn;\n\n\tpci_read_config_word(dev, pos + PCI_ACS_CAP, &cap);\n\tpci_read_config_word(dev, pos + PCI_ACS_CTRL, &ctrl);\n\n\t/* Source Validation */\n\tctrl |= (cap & PCI_ACS_SV);\n\n\t/* P2P Request Redirect */\n\tctrl |= (cap & PCI_ACS_RR);\n\n\t/* P2P Completion Redirect */\n\tctrl |= (cap & PCI_ACS_CR);\n\n\t/* Upstream Forwarding */\n\tctrl |= (cap & PCI_ACS_UF);\n\n\t/* Enable Translation Blocking for external devices */\n\tif (dev->external_facing || dev->untrusted)\n\t\tctrl |= (cap & PCI_ACS_TB);\n\n\tpci_write_config_word(dev, pos + PCI_ACS_CTRL, ctrl);\n}\n\n/**\n * pci_enable_acs - enable ACS if hardware support it\n * @dev: the PCI device\n */\nstatic void pci_enable_acs(struct pci_dev *dev)\n{\n\tif (!pci_acs_enable)\n\t\tgoto disable_acs_redir;\n\n\tif (!pci_dev_specific_enable_acs(dev))\n\t\tgoto disable_acs_redir;\n\n\tpci_std_enable_acs(dev);\n\ndisable_acs_redir:\n\t/*\n\t * Note: pci_disable_acs_redir() must be called even if ACS was not\n\t * enabled by the kernel because it may have been enabled by\n\t * platform firmware.  So if we are told to disable it, we should\n\t * always disable it after setting the kernel's default\n\t * preferences.\n\t */\n\tpci_disable_acs_redir(dev);\n}\n\n/**\n * pci_restore_bars - restore a device's BAR values (e.g. after wake-up)\n * @dev: PCI device to have its BARs restored\n *\n * Restore the BAR values for a given device, so as to make it\n * accessible by its driver.\n */\nstatic void pci_restore_bars(struct pci_dev *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < PCI_BRIDGE_RESOURCES; i++)\n\t\tpci_update_resource(dev, i);\n}\n\nstatic const struct pci_platform_pm_ops *pci_platform_pm;\n\nint pci_set_platform_pm(const struct pci_platform_pm_ops *ops)\n{\n\tif (!ops->is_manageable || !ops->set_state  || !ops->get_state ||\n\t    !ops->choose_state  || !ops->set_wakeup || !ops->need_resume)\n\t\treturn -EINVAL;\n\tpci_platform_pm = ops;\n\treturn 0;\n}\n\nstatic inline bool platform_pci_power_manageable(struct pci_dev *dev)\n{\n\treturn pci_platform_pm ? pci_platform_pm->is_manageable(dev) : false;\n}\n\nstatic inline int platform_pci_set_power_state(struct pci_dev *dev,\n\t\t\t\t\t       pci_power_t t)\n{\n\treturn pci_platform_pm ? pci_platform_pm->set_state(dev, t) : -ENOSYS;\n}\n\nstatic inline pci_power_t platform_pci_get_power_state(struct pci_dev *dev)\n{\n\treturn pci_platform_pm ? pci_platform_pm->get_state(dev) : PCI_UNKNOWN;\n}\n\nstatic inline void platform_pci_refresh_power_state(struct pci_dev *dev)\n{\n\tif (pci_platform_pm && pci_platform_pm->refresh_state)\n\t\tpci_platform_pm->refresh_state(dev);\n}\n\nstatic inline pci_power_t platform_pci_choose_state(struct pci_dev *dev)\n{\n\treturn pci_platform_pm ?\n\t\t\tpci_platform_pm->choose_state(dev) : PCI_POWER_ERROR;\n}\n\nstatic inline int platform_pci_set_wakeup(struct pci_dev *dev, bool enable)\n{\n\treturn pci_platform_pm ?\n\t\t\tpci_platform_pm->set_wakeup(dev, enable) : -ENODEV;\n}\n\nstatic inline bool platform_pci_need_resume(struct pci_dev *dev)\n{\n\treturn pci_platform_pm ? pci_platform_pm->need_resume(dev) : false;\n}\n\nstatic inline bool platform_pci_bridge_d3(struct pci_dev *dev)\n{\n\tif (pci_platform_pm && pci_platform_pm->bridge_d3)\n\t\treturn pci_platform_pm->bridge_d3(dev);\n\treturn false;\n}\n\n/**\n * pci_raw_set_power_state - Use PCI PM registers to set the power state of\n *\t\t\t     given PCI device\n * @dev: PCI device to handle.\n * @state: PCI power state (D0, D1, D2, D3hot) to put the device into.\n *\n * RETURN VALUE:\n * -EINVAL if the requested state is invalid.\n * -EIO if device does not support PCI PM or its PM capabilities register has a\n * wrong version, or device doesn't support the requested state.\n * 0 if device already is in the requested state.\n * 0 if device's power state has been successfully changed.\n */\nstatic int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)\n{\n\tu16 pmcsr;\n\tbool need_restore = false;\n\n\t/* Check if we're already there */\n\tif (dev->current_state == state)\n\t\treturn 0;\n\n\tif (!dev->pm_cap)\n\t\treturn -EIO;\n\n\tif (state < PCI_D0 || state > PCI_D3hot)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Validate transition: We can enter D0 from any state, but if\n\t * we're already in a low-power state, we can only go deeper.  E.g.,\n\t * we can go from D1 to D3, but we can't go directly from D3 to D1;\n\t * we'd have to go from D3 to D0, then to D1.\n\t */\n\tif (state != PCI_D0 && dev->current_state <= PCI_D3cold\n\t    && dev->current_state > state) {\n\t\tpci_err(dev, \"invalid power transition (from %s to %s)\\n\",\n\t\t\tpci_power_name(dev->current_state),\n\t\t\tpci_power_name(state));\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if this device supports the desired state */\n\tif ((state == PCI_D1 && !dev->d1_support)\n\t   || (state == PCI_D2 && !dev->d2_support))\n\t\treturn -EIO;\n\n\tpci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);\n\tif (pmcsr == (u16) ~0) {\n\t\tpci_err(dev, \"can't change power state from %s to %s (config space inaccessible)\\n\",\n\t\t\tpci_power_name(dev->current_state),\n\t\t\tpci_power_name(state));\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * If we're (effectively) in D3, force entire word to 0.\n\t * This doesn't affect PME_Status, disables PME_En, and\n\t * sets PowerState to 0.\n\t */\n\tswitch (dev->current_state) {\n\tcase PCI_D0:\n\tcase PCI_D1:\n\tcase PCI_D2:\n\t\tpmcsr &= ~PCI_PM_CTRL_STATE_MASK;\n\t\tpmcsr |= state;\n\t\tbreak;\n\tcase PCI_D3hot:\n\tcase PCI_D3cold:\n\tcase PCI_UNKNOWN: /* Boot-up */\n\t\tif ((pmcsr & PCI_PM_CTRL_STATE_MASK) == PCI_D3hot\n\t\t && !(pmcsr & PCI_PM_CTRL_NO_SOFT_RESET))\n\t\t\tneed_restore = true;\n\t\tfallthrough;\t/* force to D0 */\n\tdefault:\n\t\tpmcsr = 0;\n\t\tbreak;\n\t}\n\n\t/* Enter specified state */\n\tpci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pmcsr);\n\n\t/*\n\t * Mandatory power management transition delays; see PCI PM 1.1\n\t * 5.6.1 table 18\n\t */\n\tif (state == PCI_D3hot || dev->current_state == PCI_D3hot)\n\t\tpci_dev_d3_sleep(dev);\n\telse if (state == PCI_D2 || dev->current_state == PCI_D2)\n\t\tudelay(PCI_PM_D2_DELAY);\n\n\tpci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);\n\tdev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);\n\tif (dev->current_state != state)\n\t\tpci_info_ratelimited(dev, \"refused to change power state from %s to %s\\n\",\n\t\t\t pci_power_name(dev->current_state),\n\t\t\t pci_power_name(state));\n\n\t/*\n\t * According to section 5.4.1 of the \"PCI BUS POWER MANAGEMENT\n\t * INTERFACE SPECIFICATION, REV. 1.2\", a device transitioning\n\t * from D3hot to D0 _may_ perform an internal reset, thereby\n\t * going to \"D0 Uninitialized\" rather than \"D0 Initialized\".\n\t * For example, at least some versions of the 3c905B and the\n\t * 3c556B exhibit this behaviour.\n\t *\n\t * At least some laptop BIOSen (e.g. the Thinkpad T21) leave\n\t * devices in a D3hot state at boot.  Consequently, we need to\n\t * restore at least the BARs so that the device will be\n\t * accessible to its driver.\n\t */\n\tif (need_restore)\n\t\tpci_restore_bars(dev);\n\n\tif (dev->bus->self)\n\t\tpcie_aspm_pm_state_change(dev->bus->self);\n\n\treturn 0;\n}\n\n/**\n * pci_update_current_state - Read power state of given device and cache it\n * @dev: PCI device to handle.\n * @state: State to cache in case the device doesn't have the PM capability\n *\n * The power state is read from the PMCSR register, which however is\n * inaccessible in D3cold.  The platform firmware is therefore queried first\n * to detect accessibility of the register.  In case the platform firmware\n * reports an incorrect state or the device isn't power manageable by the\n * platform at all, we try to detect D3cold by testing accessibility of the\n * vendor ID in config space.\n */\nvoid pci_update_current_state(struct pci_dev *dev, pci_power_t state)\n{\n\tif (platform_pci_get_power_state(dev) == PCI_D3cold ||\n\t    !pci_device_is_present(dev)) {\n\t\tdev->current_state = PCI_D3cold;\n\t} else if (dev->pm_cap) {\n\t\tu16 pmcsr;\n\n\t\tpci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);\n\t\tdev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);\n\t} else {\n\t\tdev->current_state = state;\n\t}\n}\n\n/**\n * pci_refresh_power_state - Refresh the given device's power state data\n * @dev: Target PCI device.\n *\n * Ask the platform to refresh the devices power state information and invoke\n * pci_update_current_state() to update its current PCI power state.\n */\nvoid pci_refresh_power_state(struct pci_dev *dev)\n{\n\tif (platform_pci_power_manageable(dev))\n\t\tplatform_pci_refresh_power_state(dev);\n\n\tpci_update_current_state(dev, dev->current_state);\n}\n\n/**\n * pci_platform_power_transition - Use platform to change device power state\n * @dev: PCI device to handle.\n * @state: State to put the device into.\n */\nint pci_platform_power_transition(struct pci_dev *dev, pci_power_t state)\n{\n\tint error;\n\n\tif (platform_pci_power_manageable(dev)) {\n\t\terror = platform_pci_set_power_state(dev, state);\n\t\tif (!error)\n\t\t\tpci_update_current_state(dev, state);\n\t} else\n\t\terror = -ENODEV;\n\n\tif (error && !dev->pm_cap) /* Fall back to PCI_D0 */\n\t\tdev->current_state = PCI_D0;\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(pci_platform_power_transition);\n\n/**\n * pci_wakeup - Wake up a PCI device\n * @pci_dev: Device to handle.\n * @ign: ignored parameter\n */\nstatic int pci_wakeup(struct pci_dev *pci_dev, void *ign)\n{\n\tpci_wakeup_event(pci_dev);\n\tpm_request_resume(&pci_dev->dev);\n\treturn 0;\n}\n\n/**\n * pci_wakeup_bus - Walk given bus and wake up devices on it\n * @bus: Top bus of the subtree to walk.\n */\nvoid pci_wakeup_bus(struct pci_bus *bus)\n{\n\tif (bus)\n\t\tpci_walk_bus(bus, pci_wakeup, NULL);\n}\n\nstatic int pci_dev_wait(struct pci_dev *dev, char *reset_type, int timeout)\n{\n\tint delay = 1;\n\tu32 id;\n\n\t/*\n\t * After reset, the device should not silently discard config\n\t * requests, but it may still indicate that it needs more time by\n\t * responding to them with CRS completions.  The Root Port will\n\t * generally synthesize ~0 data to complete the read (except when\n\t * CRS SV is enabled and the read was for the Vendor ID; in that\n\t * case it synthesizes 0x0001 data).\n\t *\n\t * Wait for the device to return a non-CRS completion.  Read the\n\t * Command register instead of Vendor ID so we don't have to\n\t * contend with the CRS SV value.\n\t */\n\tpci_read_config_dword(dev, PCI_COMMAND, &id);\n\twhile (id == ~0) {\n\t\tif (delay > timeout) {\n\t\t\tpci_warn(dev, \"not ready %dms after %s; giving up\\n\",\n\t\t\t\t delay - 1, reset_type);\n\t\t\treturn -ENOTTY;\n\t\t}\n\n\t\tif (delay > 1000)\n\t\t\tpci_info(dev, \"not ready %dms after %s; waiting\\n\",\n\t\t\t\t delay - 1, reset_type);\n\n\t\tmsleep(delay);\n\t\tdelay *= 2;\n\t\tpci_read_config_dword(dev, PCI_COMMAND, &id);\n\t}\n\n\tif (delay > 1000)\n\t\tpci_info(dev, \"ready %dms after %s\\n\", delay - 1,\n\t\t\t reset_type);\n\n\treturn 0;\n}\n\n/**\n * pci_power_up - Put the given device into D0\n * @dev: PCI device to power up\n */\nint pci_power_up(struct pci_dev *dev)\n{\n\tpci_platform_power_transition(dev, PCI_D0);\n\n\t/*\n\t * Mandatory power management transition delays are handled in\n\t * pci_pm_resume_noirq() and pci_pm_runtime_resume() of the\n\t * corresponding bridge.\n\t */\n\tif (dev->runtime_d3cold) {\n\t\t/*\n\t\t * When powering on a bridge from D3cold, the whole hierarchy\n\t\t * may be powered on into D0uninitialized state, resume them to\n\t\t * give them a chance to suspend again\n\t\t */\n\t\tpci_wakeup_bus(dev->subordinate);\n\t}\n\n\treturn pci_raw_set_power_state(dev, PCI_D0);\n}\n\n/**\n * __pci_dev_set_current_state - Set current state of a PCI device\n * @dev: Device to handle\n * @data: pointer to state to be set\n */\nstatic int __pci_dev_set_current_state(struct pci_dev *dev, void *data)\n{\n\tpci_power_t state = *(pci_power_t *)data;\n\n\tdev->current_state = state;\n\treturn 0;\n}\n\n/**\n * pci_bus_set_current_state - Walk given bus and set current state of devices\n * @bus: Top bus of the subtree to walk.\n * @state: state to be set\n */\nvoid pci_bus_set_current_state(struct pci_bus *bus, pci_power_t state)\n{\n\tif (bus)\n\t\tpci_walk_bus(bus, __pci_dev_set_current_state, &state);\n}\n\n/**\n * pci_set_power_state - Set the power state of a PCI device\n * @dev: PCI device to handle.\n * @state: PCI power state (D0, D1, D2, D3hot) to put the device into.\n *\n * Transition a device to a new power state, using the platform firmware and/or\n * the device's PCI PM registers.\n *\n * RETURN VALUE:\n * -EINVAL if the requested state is invalid.\n * -EIO if device does not support PCI PM or its PM capabilities register has a\n * wrong version, or device doesn't support the requested state.\n * 0 if the transition is to D1 or D2 but D1 and D2 are not supported.\n * 0 if device already is in the requested state.\n * 0 if the transition is to D3 but D3 is not supported.\n * 0 if device's power state has been successfully changed.\n */\nint pci_set_power_state(struct pci_dev *dev, pci_power_t state)\n{\n\tint error;\n\n\t/* Bound the state we're entering */\n\tif (state > PCI_D3cold)\n\t\tstate = PCI_D3cold;\n\telse if (state < PCI_D0)\n\t\tstate = PCI_D0;\n\telse if ((state == PCI_D1 || state == PCI_D2) && pci_no_d1d2(dev))\n\n\t\t/*\n\t\t * If the device or the parent bridge do not support PCI\n\t\t * PM, ignore the request if we're doing anything other\n\t\t * than putting it into D0 (which would only happen on\n\t\t * boot).\n\t\t */\n\t\treturn 0;\n\n\t/* Check if we're already there */\n\tif (dev->current_state == state)\n\t\treturn 0;\n\n\tif (state == PCI_D0)\n\t\treturn pci_power_up(dev);\n\n\t/*\n\t * This device is quirked not to be put into D3, so don't put it in\n\t * D3\n\t */\n\tif (state >= PCI_D3hot && (dev->dev_flags & PCI_DEV_FLAGS_NO_D3))\n\t\treturn 0;\n\n\t/*\n\t * To put device in D3cold, we put device into D3hot in native\n\t * way, then put device into D3cold with platform ops\n\t */\n\terror = pci_raw_set_power_state(dev, state > PCI_D3hot ?\n\t\t\t\t\tPCI_D3hot : state);\n\n\tif (pci_platform_power_transition(dev, state))\n\t\treturn error;\n\n\t/* Powering off a bridge may power off the whole hierarchy */\n\tif (state == PCI_D3cold)\n\t\tpci_bus_set_current_state(dev->subordinate, PCI_D3cold);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(pci_set_power_state);\n\n/**\n * pci_choose_state - Choose the power state of a PCI device\n * @dev: PCI device to be suspended\n * @state: target sleep state for the whole system. This is the value\n *\t   that is passed to suspend() function.\n *\n * Returns PCI power state suitable for given device and given system\n * message.\n */\npci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)\n{\n\tpci_power_t ret;\n\n\tif (!dev->pm_cap)\n\t\treturn PCI_D0;\n\n\tret = platform_pci_choose_state(dev);\n\tif (ret != PCI_POWER_ERROR)\n\t\treturn ret;\n\n\tswitch (state.event) {\n\tcase PM_EVENT_ON:\n\t\treturn PCI_D0;\n\tcase PM_EVENT_FREEZE:\n\tcase PM_EVENT_PRETHAW:\n\t\t/* REVISIT both freeze and pre-thaw \"should\" use D0 */\n\tcase PM_EVENT_SUSPEND:\n\tcase PM_EVENT_HIBERNATE:\n\t\treturn PCI_D3hot;\n\tdefault:\n\t\tpci_info(dev, \"unrecognized suspend event %d\\n\",\n\t\t\t state.event);\n\t\tBUG();\n\t}\n\treturn PCI_D0;\n}\nEXPORT_SYMBOL(pci_choose_state);\n\n#define PCI_EXP_SAVE_REGS\t7\n\nstatic struct pci_cap_saved_state *_pci_find_saved_cap(struct pci_dev *pci_dev,\n\t\t\t\t\t\t       u16 cap, bool extended)\n{\n\tstruct pci_cap_saved_state *tmp;\n\n\thlist_for_each_entry(tmp, &pci_dev->saved_cap_space, next) {\n\t\tif (tmp->cap.cap_extended == extended && tmp->cap.cap_nr == cap)\n\t\t\treturn tmp;\n\t}\n\treturn NULL;\n}\n\nstruct pci_cap_saved_state *pci_find_saved_cap(struct pci_dev *dev, char cap)\n{\n\treturn _pci_find_saved_cap(dev, cap, false);\n}\n\nstruct pci_cap_saved_state *pci_find_saved_ext_cap(struct pci_dev *dev, u16 cap)\n{\n\treturn _pci_find_saved_cap(dev, cap, true);\n}\n\nstatic int pci_save_pcie_state(struct pci_dev *dev)\n{\n\tint i = 0;\n\tstruct pci_cap_saved_state *save_state;\n\tu16 *cap;\n\n\tif (!pci_is_pcie(dev))\n\t\treturn 0;\n\n\tsave_state = pci_find_saved_cap(dev, PCI_CAP_ID_EXP);\n\tif (!save_state) {\n\t\tpci_err(dev, \"buffer not found in %s\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tcap = (u16 *)&save_state->cap.data[0];\n\tpcie_capability_read_word(dev, PCI_EXP_DEVCTL, &cap[i++]);\n\tpcie_capability_read_word(dev, PCI_EXP_LNKCTL, &cap[i++]);\n\tpcie_capability_read_word(dev, PCI_EXP_SLTCTL, &cap[i++]);\n\tpcie_capability_read_word(dev, PCI_EXP_RTCTL,  &cap[i++]);\n\tpcie_capability_read_word(dev, PCI_EXP_DEVCTL2, &cap[i++]);\n\tpcie_capability_read_word(dev, PCI_EXP_LNKCTL2, &cap[i++]);\n\tpcie_capability_read_word(dev, PCI_EXP_SLTCTL2, &cap[i++]);\n\n\treturn 0;\n}\n\nstatic void pci_restore_pcie_state(struct pci_dev *dev)\n{\n\tint i = 0;\n\tstruct pci_cap_saved_state *save_state;\n\tu16 *cap;\n\n\tsave_state = pci_find_saved_cap(dev, PCI_CAP_ID_EXP);\n\tif (!save_state)\n\t\treturn;\n\n\tcap = (u16 *)&save_state->cap.data[0];\n\tpcie_capability_write_word(dev, PCI_EXP_DEVCTL, cap[i++]);\n\tpcie_capability_write_word(dev, PCI_EXP_LNKCTL, cap[i++]);\n\tpcie_capability_write_word(dev, PCI_EXP_SLTCTL, cap[i++]);\n\tpcie_capability_write_word(dev, PCI_EXP_RTCTL, cap[i++]);\n\tpcie_capability_write_word(dev, PCI_EXP_DEVCTL2, cap[i++]);\n\tpcie_capability_write_word(dev, PCI_EXP_LNKCTL2, cap[i++]);\n\tpcie_capability_write_word(dev, PCI_EXP_SLTCTL2, cap[i++]);\n}\n\nstatic int pci_save_pcix_state(struct pci_dev *dev)\n{\n\tint pos;\n\tstruct pci_cap_saved_state *save_state;\n\n\tpos = pci_find_capability(dev, PCI_CAP_ID_PCIX);\n\tif (!pos)\n\t\treturn 0;\n\n\tsave_state = pci_find_saved_cap(dev, PCI_CAP_ID_PCIX);\n\tif (!save_state) {\n\t\tpci_err(dev, \"buffer not found in %s\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tpci_read_config_word(dev, pos + PCI_X_CMD,\n\t\t\t     (u16 *)save_state->cap.data);\n\n\treturn 0;\n}\n\nstatic void pci_restore_pcix_state(struct pci_dev *dev)\n{\n\tint i = 0, pos;\n\tstruct pci_cap_saved_state *save_state;\n\tu16 *cap;\n\n\tsave_state = pci_find_saved_cap(dev, PCI_CAP_ID_PCIX);\n\tpos = pci_find_capability(dev, PCI_CAP_ID_PCIX);\n\tif (!save_state || !pos)\n\t\treturn;\n\tcap = (u16 *)&save_state->cap.data[0];\n\n\tpci_write_config_word(dev, pos + PCI_X_CMD, cap[i++]);\n}\n\nstatic void pci_save_ltr_state(struct pci_dev *dev)\n{\n\tint ltr;\n\tstruct pci_cap_saved_state *save_state;\n\tu16 *cap;\n\n\tif (!pci_is_pcie(dev))\n\t\treturn;\n\n\tltr = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_LTR);\n\tif (!ltr)\n\t\treturn;\n\n\tsave_state = pci_find_saved_ext_cap(dev, PCI_EXT_CAP_ID_LTR);\n\tif (!save_state) {\n\t\tpci_err(dev, \"no suspend buffer for LTR; ASPM issues possible after resume\\n\");\n\t\treturn;\n\t}\n\n\tcap = (u16 *)&save_state->cap.data[0];\n\tpci_read_config_word(dev, ltr + PCI_LTR_MAX_SNOOP_LAT, cap++);\n\tpci_read_config_word(dev, ltr + PCI_LTR_MAX_NOSNOOP_LAT, cap++);\n}\n\nstatic void pci_restore_ltr_state(struct pci_dev *dev)\n{\n\tstruct pci_cap_saved_state *save_state;\n\tint ltr;\n\tu16 *cap;\n\n\tsave_state = pci_find_saved_ext_cap(dev, PCI_EXT_CAP_ID_LTR);\n\tltr = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_LTR);\n\tif (!save_state || !ltr)\n\t\treturn;\n\n\tcap = (u16 *)&save_state->cap.data[0];\n\tpci_write_config_word(dev, ltr + PCI_LTR_MAX_SNOOP_LAT, *cap++);\n\tpci_write_config_word(dev, ltr + PCI_LTR_MAX_NOSNOOP_LAT, *cap++);\n}\n\n/**\n * pci_save_state - save the PCI configuration space of a device before\n *\t\t    suspending\n * @dev: PCI device that we're dealing with\n */\nint pci_save_state(struct pci_dev *dev)\n{\n\tint i;\n\t/* XXX: 100% dword access ok here? */\n\tfor (i = 0; i < 16; i++) {\n\t\tpci_read_config_dword(dev, i * 4, &dev->saved_config_space[i]);\n\t\tpci_dbg(dev, \"saving config space at offset %#x (reading %#x)\\n\",\n\t\t\ti * 4, dev->saved_config_space[i]);\n\t}\n\tdev->state_saved = true;\n\n\ti = pci_save_pcie_state(dev);\n\tif (i != 0)\n\t\treturn i;\n\n\ti = pci_save_pcix_state(dev);\n\tif (i != 0)\n\t\treturn i;\n\n\tpci_save_ltr_state(dev);\n\tpci_save_dpc_state(dev);\n\tpci_save_aer_state(dev);\n\treturn pci_save_vc_state(dev);\n}\nEXPORT_SYMBOL(pci_save_state);\n\nstatic void pci_restore_config_dword(struct pci_dev *pdev, int offset,\n\t\t\t\t     u32 saved_val, int retry, bool force)\n{\n\tu32 val;\n\n\tpci_read_config_dword(pdev, offset, &val);\n\tif (!force && val == saved_val)\n\t\treturn;\n\n\tfor (;;) {\n\t\tpci_dbg(pdev, \"restoring config space at offset %#x (was %#x, writing %#x)\\n\",\n\t\t\toffset, val, saved_val);\n\t\tpci_write_config_dword(pdev, offset, saved_val);\n\t\tif (retry-- <= 0)\n\t\t\treturn;\n\n\t\tpci_read_config_dword(pdev, offset, &val);\n\t\tif (val == saved_val)\n\t\t\treturn;\n\n\t\tmdelay(1);\n\t}\n}\n\nstatic void pci_restore_config_space_range(struct pci_dev *pdev,\n\t\t\t\t\t   int start, int end, int retry,\n\t\t\t\t\t   bool force)\n{\n\tint index;\n\n\tfor (index = end; index >= start; index--)\n\t\tpci_restore_config_dword(pdev, 4 * index,\n\t\t\t\t\t pdev->saved_config_space[index],\n\t\t\t\t\t retry, force);\n}\n\nstatic void pci_restore_config_space(struct pci_dev *pdev)\n{\n\tif (pdev->hdr_type == PCI_HEADER_TYPE_NORMAL) {\n\t\tpci_restore_config_space_range(pdev, 10, 15, 0, false);\n\t\t/* Restore BARs before the command register. */\n\t\tpci_restore_config_space_range(pdev, 4, 9, 10, false);\n\t\tpci_restore_config_space_range(pdev, 0, 3, 0, false);\n\t} else if (pdev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\t\tpci_restore_config_space_range(pdev, 12, 15, 0, false);\n\n\t\t/*\n\t\t * Force rewriting of prefetch registers to avoid S3 resume\n\t\t * issues on Intel PCI bridges that occur when these\n\t\t * registers are not explicitly written.\n\t\t */\n\t\tpci_restore_config_space_range(pdev, 9, 11, 0, true);\n\t\tpci_restore_config_space_range(pdev, 0, 8, 0, false);\n\t} else {\n\t\tpci_restore_config_space_range(pdev, 0, 15, 0, false);\n\t}\n}\n\nstatic void pci_restore_rebar_state(struct pci_dev *pdev)\n{\n\tunsigned int pos, nbars, i;\n\tu32 ctrl;\n\n\tpos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_REBAR);\n\tif (!pos)\n\t\treturn;\n\n\tpci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);\n\tnbars = (ctrl & PCI_REBAR_CTRL_NBAR_MASK) >>\n\t\t    PCI_REBAR_CTRL_NBAR_SHIFT;\n\n\tfor (i = 0; i < nbars; i++, pos += 8) {\n\t\tstruct resource *res;\n\t\tint bar_idx, size;\n\n\t\tpci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);\n\t\tbar_idx = ctrl & PCI_REBAR_CTRL_BAR_IDX;\n\t\tres = pdev->resource + bar_idx;\n\t\tsize = ilog2(resource_size(res)) - 20;\n\t\tctrl &= ~PCI_REBAR_CTRL_BAR_SIZE;\n\t\tctrl |= size << PCI_REBAR_CTRL_BAR_SHIFT;\n\t\tpci_write_config_dword(pdev, pos + PCI_REBAR_CTRL, ctrl);\n\t}\n}\n\n/**\n * pci_restore_state - Restore the saved state of a PCI device\n * @dev: PCI device that we're dealing with\n */\nvoid pci_restore_state(struct pci_dev *dev)\n{\n\tif (!dev->state_saved)\n\t\treturn;\n\n\t/*\n\t * Restore max latencies (in the LTR capability) before enabling\n\t * LTR itself (in the PCIe capability).\n\t */\n\tpci_restore_ltr_state(dev);\n\n\tpci_restore_pcie_state(dev);\n\tpci_restore_pasid_state(dev);\n\tpci_restore_pri_state(dev);\n\tpci_restore_ats_state(dev);\n\tpci_restore_vc_state(dev);\n\tpci_restore_rebar_state(dev);\n\tpci_restore_dpc_state(dev);\n\n\tpci_aer_clear_status(dev);\n\tpci_restore_aer_state(dev);\n\n\tpci_restore_config_space(dev);\n\n\tpci_restore_pcix_state(dev);\n\tpci_restore_msi_state(dev);\n\n\t/* Restore ACS and IOV configuration state */\n\tpci_enable_acs(dev);\n\tpci_restore_iov_state(dev);\n\n\tdev->state_saved = false;\n}\nEXPORT_SYMBOL(pci_restore_state);\n\nstruct pci_saved_state {\n\tu32 config_space[16];\n\tstruct pci_cap_saved_data cap[];\n};\n\n/**\n * pci_store_saved_state - Allocate and return an opaque struct containing\n *\t\t\t   the device saved state.\n * @dev: PCI device that we're dealing with\n *\n * Return NULL if no state or error.\n */\nstruct pci_saved_state *pci_store_saved_state(struct pci_dev *dev)\n{\n\tstruct pci_saved_state *state;\n\tstruct pci_cap_saved_state *tmp;\n\tstruct pci_cap_saved_data *cap;\n\tsize_t size;\n\n\tif (!dev->state_saved)\n\t\treturn NULL;\n\n\tsize = sizeof(*state) + sizeof(struct pci_cap_saved_data);\n\n\thlist_for_each_entry(tmp, &dev->saved_cap_space, next)\n\t\tsize += sizeof(struct pci_cap_saved_data) + tmp->cap.size;\n\n\tstate = kzalloc(size, GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\tmemcpy(state->config_space, dev->saved_config_space,\n\t       sizeof(state->config_space));\n\n\tcap = state->cap;\n\thlist_for_each_entry(tmp, &dev->saved_cap_space, next) {\n\t\tsize_t len = sizeof(struct pci_cap_saved_data) + tmp->cap.size;\n\t\tmemcpy(cap, &tmp->cap, len);\n\t\tcap = (struct pci_cap_saved_data *)((u8 *)cap + len);\n\t}\n\t/* Empty cap_save terminates list */\n\n\treturn state;\n}\nEXPORT_SYMBOL_GPL(pci_store_saved_state);\n\n/**\n * pci_load_saved_state - Reload the provided save state into struct pci_dev.\n * @dev: PCI device that we're dealing with\n * @state: Saved state returned from pci_store_saved_state()\n */\nint pci_load_saved_state(struct pci_dev *dev,\n\t\t\t struct pci_saved_state *state)\n{\n\tstruct pci_cap_saved_data *cap;\n\n\tdev->state_saved = false;\n\n\tif (!state)\n\t\treturn 0;\n\n\tmemcpy(dev->saved_config_space, state->config_space,\n\t       sizeof(state->config_space));\n\n\tcap = state->cap;\n\twhile (cap->size) {\n\t\tstruct pci_cap_saved_state *tmp;\n\n\t\ttmp = _pci_find_saved_cap(dev, cap->cap_nr, cap->cap_extended);\n\t\tif (!tmp || tmp->cap.size != cap->size)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(tmp->cap.data, cap->data, tmp->cap.size);\n\t\tcap = (struct pci_cap_saved_data *)((u8 *)cap +\n\t\t       sizeof(struct pci_cap_saved_data) + cap->size);\n\t}\n\n\tdev->state_saved = true;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pci_load_saved_state);\n\n/**\n * pci_load_and_free_saved_state - Reload the save state pointed to by state,\n *\t\t\t\t   and free the memory allocated for it.\n * @dev: PCI device that we're dealing with\n * @state: Pointer to saved state returned from pci_store_saved_state()\n */\nint pci_load_and_free_saved_state(struct pci_dev *dev,\n\t\t\t\t  struct pci_saved_state **state)\n{\n\tint ret = pci_load_saved_state(dev, *state);\n\tkfree(*state);\n\t*state = NULL;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pci_load_and_free_saved_state);\n\nint __weak pcibios_enable_device(struct pci_dev *dev, int bars)\n{\n\treturn pci_enable_resources(dev, bars);\n}\n\nstatic int do_pci_enable_device(struct pci_dev *dev, int bars)\n{\n\tint err;\n\tstruct pci_dev *bridge;\n\tu16 cmd;\n\tu8 pin;\n\n\terr = pci_set_power_state(dev, PCI_D0);\n\tif (err < 0 && err != -EIO)\n\t\treturn err;\n\n\tbridge = pci_upstream_bridge(dev);\n\tif (bridge)\n\t\tpcie_aspm_powersave_config_link(bridge);\n\n\terr = pcibios_enable_device(dev, bars);\n\tif (err < 0)\n\t\treturn err;\n\tpci_fixup_device(pci_fixup_enable, dev);\n\n\tif (dev->msi_enabled || dev->msix_enabled)\n\t\treturn 0;\n\n\tpci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);\n\tif (pin) {\n\t\tpci_read_config_word(dev, PCI_COMMAND, &cmd);\n\t\tif (cmd & PCI_COMMAND_INTX_DISABLE)\n\t\t\tpci_write_config_word(dev, PCI_COMMAND,\n\t\t\t\t\t      cmd & ~PCI_COMMAND_INTX_DISABLE);\n\t}\n\n\treturn 0;\n}\n\n/**\n * pci_reenable_device - Resume abandoned device\n * @dev: PCI device to be resumed\n *\n * NOTE: This function is a backend of pci_default_resume() and is not supposed\n * to be called by normal code, write proper resume handler and use it instead.\n */\nint pci_reenable_device(struct pci_dev *dev)\n{\n\tif (pci_is_enabled(dev))\n\t\treturn do_pci_enable_device(dev, (1 << PCI_NUM_RESOURCES) - 1);\n\treturn 0;\n}\nEXPORT_SYMBOL(pci_reenable_device);\n\nstatic void pci_enable_bridge(struct pci_dev *dev)\n{\n\tstruct pci_dev *bridge;\n\tint retval;\n\n\tbridge = pci_upstream_bridge(dev);\n\tif (bridge)\n\t\tpci_enable_bridge(bridge);\n\n\tif (pci_is_enabled(dev)) {\n\t\tif (!dev->is_busmaster)\n\t\t\tpci_set_master(dev);\n\t\treturn;\n\t}\n\n\tretval = pci_enable_device(dev);\n\tif (retval)\n\t\tpci_err(dev, \"Error enabling bridge (%d), continuing\\n\",\n\t\t\tretval);\n\tpci_set_master(dev);\n}\n\nstatic int pci_enable_device_flags(struct pci_dev *dev, unsigned long flags)\n{\n\tstruct pci_dev *bridge;\n\tint err;\n\tint i, bars = 0;\n\n\t/*\n\t * Power state could be unknown at this point, either due to a fresh\n\t * boot or a device removal call.  So get the current power state\n\t * so that things like MSI message writing will behave as expected\n\t * (e.g. if the device really is in D0 at enable time).\n\t */\n\tif (dev->pm_cap) {\n\t\tu16 pmcsr;\n\t\tpci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);\n\t\tdev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);\n\t}\n\n\tif (atomic_inc_return(&dev->enable_cnt) > 1)\n\t\treturn 0;\t\t/* already enabled */\n\n\tbridge = pci_upstream_bridge(dev);\n\tif (bridge)\n\t\tpci_enable_bridge(bridge);\n\n\t/* only skip sriov related */\n\tfor (i = 0; i <= PCI_ROM_RESOURCE; i++)\n\t\tif (dev->resource[i].flags & flags)\n\t\t\tbars |= (1 << i);\n\tfor (i = PCI_BRIDGE_RESOURCES; i < DEVICE_COUNT_RESOURCE; i++)\n\t\tif (dev->resource[i].flags & flags)\n\t\t\tbars |= (1 << i);\n\n\terr = do_pci_enable_device(dev, bars);\n\tif (err < 0)\n\t\tatomic_dec(&dev->enable_cnt);\n\treturn err;\n}\n\n/**\n * pci_enable_device_io - Initialize a device for use with IO space\n * @dev: PCI device to be initialized\n *\n * Initialize device before it's used by a driver. Ask low-level code\n * to enable I/O resources. Wake up the device if it was suspended.\n * Beware, this function can fail.\n */\nint pci_enable_device_io(struct pci_dev *dev)\n{\n\treturn pci_enable_device_flags(dev, IORESOURCE_IO);\n}\nEXPORT_SYMBOL(pci_enable_device_io);\n\n/**\n * pci_enable_device_mem - Initialize a device for use with Memory space\n * @dev: PCI device to be initialized\n *\n * Initialize device before it's used by a driver. Ask low-level code\n * to enable Memory resources. Wake up the device if it was suspended.\n * Beware, this function can fail.\n */\nint pci_enable_device_mem(struct pci_dev *dev)\n{\n\treturn pci_enable_device_flags(dev, IORESOURCE_MEM);\n}\nEXPORT_SYMBOL(pci_enable_device_mem);\n\n/**\n * pci_enable_device - Initialize device before it's used by a driver.\n * @dev: PCI device to be initialized\n *\n * Initialize device before it's used by a driver. Ask low-level code\n * to enable I/O and memory. Wake up the device if it was suspended.\n * Beware, this function can fail.\n *\n * Note we don't actually enable the device many times if we call\n * this function repeatedly (we just increment the count).\n */\nint pci_enable_device(struct pci_dev *dev)\n{\n\treturn pci_enable_device_flags(dev, IORESOURCE_MEM | IORESOURCE_IO);\n}\nEXPORT_SYMBOL(pci_enable_device);\n\n/*\n * Managed PCI resources.  This manages device on/off, INTx/MSI/MSI-X\n * on/off and BAR regions.  pci_dev itself records MSI/MSI-X status, so\n * there's no need to track it separately.  pci_devres is initialized\n * when a device is enabled using managed PCI device enable interface.\n */\nstruct pci_devres {\n\tunsigned int enabled:1;\n\tunsigned int pinned:1;\n\tunsigned int orig_intx:1;\n\tunsigned int restore_intx:1;\n\tunsigned int mwi:1;\n\tu32 region_mask;\n};\n\nstatic void pcim_release(struct device *gendev, void *res)\n{\n\tstruct pci_dev *dev = to_pci_dev(gendev);\n\tstruct pci_devres *this = res;\n\tint i;\n\n\tif (dev->msi_enabled)\n\t\tpci_disable_msi(dev);\n\tif (dev->msix_enabled)\n\t\tpci_disable_msix(dev);\n\n\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++)\n\t\tif (this->region_mask & (1 << i))\n\t\t\tpci_release_region(dev, i);\n\n\tif (this->mwi)\n\t\tpci_clear_mwi(dev);\n\n\tif (this->restore_intx)\n\t\tpci_intx(dev, this->orig_intx);\n\n\tif (this->enabled && !this->pinned)\n\t\tpci_disable_device(dev);\n}\n\nstatic struct pci_devres *get_pci_dr(struct pci_dev *pdev)\n{\n\tstruct pci_devres *dr, *new_dr;\n\n\tdr = devres_find(&pdev->dev, pcim_release, NULL, NULL);\n\tif (dr)\n\t\treturn dr;\n\n\tnew_dr = devres_alloc(pcim_release, sizeof(*new_dr), GFP_KERNEL);\n\tif (!new_dr)\n\t\treturn NULL;\n\treturn devres_get(&pdev->dev, new_dr, NULL, NULL);\n}\n\nstatic struct pci_devres *find_pci_dr(struct pci_dev *pdev)\n{\n\tif (pci_is_managed(pdev))\n\t\treturn devres_find(&pdev->dev, pcim_release, NULL, NULL);\n\treturn NULL;\n}\n\n/**\n * pcim_enable_device - Managed pci_enable_device()\n * @pdev: PCI device to be initialized\n *\n * Managed pci_enable_device().\n */\nint pcim_enable_device(struct pci_dev *pdev)\n{\n\tstruct pci_devres *dr;\n\tint rc;\n\n\tdr = get_pci_dr(pdev);\n\tif (unlikely(!dr))\n\t\treturn -ENOMEM;\n\tif (dr->enabled)\n\t\treturn 0;\n\n\trc = pci_enable_device(pdev);\n\tif (!rc) {\n\t\tpdev->is_managed = 1;\n\t\tdr->enabled = 1;\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL(pcim_enable_device);\n\n/**\n * pcim_pin_device - Pin managed PCI device\n * @pdev: PCI device to pin\n *\n * Pin managed PCI device @pdev.  Pinned device won't be disabled on\n * driver detach.  @pdev must have been enabled with\n * pcim_enable_device().\n */\nvoid pcim_pin_device(struct pci_dev *pdev)\n{\n\tstruct pci_devres *dr;\n\n\tdr = find_pci_dr(pdev);\n\tWARN_ON(!dr || !dr->enabled);\n\tif (dr)\n\t\tdr->pinned = 1;\n}\nEXPORT_SYMBOL(pcim_pin_device);\n\n/*\n * pcibios_add_device - provide arch specific hooks when adding device dev\n * @dev: the PCI device being added\n *\n * Permits the platform to provide architecture specific functionality when\n * devices are added. This is the default implementation. Architecture\n * implementations can override this.\n */\nint __weak pcibios_add_device(struct pci_dev *dev)\n{\n\treturn 0;\n}\n\n/**\n * pcibios_release_device - provide arch specific hooks when releasing\n *\t\t\t    device dev\n * @dev: the PCI device being released\n *\n * Permits the platform to provide architecture specific functionality when\n * devices are released. This is the default implementation. Architecture\n * implementations can override this.\n */\nvoid __weak pcibios_release_device(struct pci_dev *dev) {}\n\n/**\n * pcibios_disable_device - disable arch specific PCI resources for device dev\n * @dev: the PCI device to disable\n *\n * Disables architecture specific PCI resources for the device. This\n * is the default implementation. Architecture implementations can\n * override this.\n */\nvoid __weak pcibios_disable_device(struct pci_dev *dev) {}\n\n/**\n * pcibios_penalize_isa_irq - penalize an ISA IRQ\n * @irq: ISA IRQ to penalize\n * @active: IRQ active or not\n *\n * Permits the platform to provide architecture-specific functionality when\n * penalizing ISA IRQs. This is the default implementation. Architecture\n * implementations can override this.\n */\nvoid __weak pcibios_penalize_isa_irq(int irq, int active) {}\n\nstatic void do_pci_disable_device(struct pci_dev *dev)\n{\n\tu16 pci_command;\n\n\tpci_read_config_word(dev, PCI_COMMAND, &pci_command);\n\tif (pci_command & PCI_COMMAND_MASTER) {\n\t\tpci_command &= ~PCI_COMMAND_MASTER;\n\t\tpci_write_config_word(dev, PCI_COMMAND, pci_command);\n\t}\n\n\tpcibios_disable_device(dev);\n}\n\n/**\n * pci_disable_enabled_device - Disable device without updating enable_cnt\n * @dev: PCI device to disable\n *\n * NOTE: This function is a backend of PCI power management routines and is\n * not supposed to be called drivers.\n */\nvoid pci_disable_enabled_device(struct pci_dev *dev)\n{\n\tif (pci_is_enabled(dev))\n\t\tdo_pci_disable_device(dev);\n}\n\n/**\n * pci_disable_device - Disable PCI device after use\n * @dev: PCI device to be disabled\n *\n * Signal to the system that the PCI device is not in use by the system\n * anymore.  This only involves disabling PCI bus-mastering, if active.\n *\n * Note we don't actually disable the device until all callers of\n * pci_enable_device() have called pci_disable_device().\n */\nvoid pci_disable_device(struct pci_dev *dev)\n{\n\tstruct pci_devres *dr;\n\n\tdr = find_pci_dr(dev);\n\tif (dr)\n\t\tdr->enabled = 0;\n\n\tdev_WARN_ONCE(&dev->dev, atomic_read(&dev->enable_cnt) <= 0,\n\t\t      \"disabling already-disabled device\");\n\n\tif (atomic_dec_return(&dev->enable_cnt) != 0)\n\t\treturn;\n\n\tdo_pci_disable_device(dev);\n\n\tdev->is_busmaster = 0;\n}\nEXPORT_SYMBOL(pci_disable_device);\n\n/**\n * pcibios_set_pcie_reset_state - set reset state for device dev\n * @dev: the PCIe device reset\n * @state: Reset state to enter into\n *\n * Set the PCIe reset state for the device. This is the default\n * implementation. Architecture implementations can override this.\n */\nint __weak pcibios_set_pcie_reset_state(struct pci_dev *dev,\n\t\t\t\t\tenum pcie_reset_state state)\n{\n\treturn -EINVAL;\n}\n\n/**\n * pci_set_pcie_reset_state - set reset state for device dev\n * @dev: the PCIe device reset\n * @state: Reset state to enter into\n *\n * Sets the PCI reset state for the device.\n */\nint pci_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)\n{\n\treturn pcibios_set_pcie_reset_state(dev, state);\n}\nEXPORT_SYMBOL_GPL(pci_set_pcie_reset_state);\n\nvoid pcie_clear_device_status(struct pci_dev *dev)\n{\n\tu16 sta;\n\n\tpcie_capability_read_word(dev, PCI_EXP_DEVSTA, &sta);\n\tpcie_capability_write_word(dev, PCI_EXP_DEVSTA, sta);\n}\n\n/**\n * pcie_clear_root_pme_status - Clear root port PME interrupt status.\n * @dev: PCIe root port or event collector.\n */\nvoid pcie_clear_root_pme_status(struct pci_dev *dev)\n{\n\tpcie_capability_set_dword(dev, PCI_EXP_RTSTA, PCI_EXP_RTSTA_PME);\n}\n\n/**\n * pci_check_pme_status - Check if given device has generated PME.\n * @dev: Device to check.\n *\n * Check the PME status of the device and if set, clear it and clear PME enable\n * (if set).  Return 'true' if PME status and PME enable were both set or\n * 'false' otherwise.\n */\nbool pci_check_pme_status(struct pci_dev *dev)\n{\n\tint pmcsr_pos;\n\tu16 pmcsr;\n\tbool ret = false;\n\n\tif (!dev->pm_cap)\n\t\treturn false;\n\n\tpmcsr_pos = dev->pm_cap + PCI_PM_CTRL;\n\tpci_read_config_word(dev, pmcsr_pos, &pmcsr);\n\tif (!(pmcsr & PCI_PM_CTRL_PME_STATUS))\n\t\treturn false;\n\n\t/* Clear PME status. */\n\tpmcsr |= PCI_PM_CTRL_PME_STATUS;\n\tif (pmcsr & PCI_PM_CTRL_PME_ENABLE) {\n\t\t/* Disable PME to avoid interrupt flood. */\n\t\tpmcsr &= ~PCI_PM_CTRL_PME_ENABLE;\n\t\tret = true;\n\t}\n\n\tpci_write_config_word(dev, pmcsr_pos, pmcsr);\n\n\treturn ret;\n}\n\n/**\n * pci_pme_wakeup - Wake up a PCI device if its PME Status bit is set.\n * @dev: Device to handle.\n * @pme_poll_reset: Whether or not to reset the device's pme_poll flag.\n *\n * Check if @dev has generated PME and queue a resume request for it in that\n * case.\n */\nstatic int pci_pme_wakeup(struct pci_dev *dev, void *pme_poll_reset)\n{\n\tif (pme_poll_reset && dev->pme_poll)\n\t\tdev->pme_poll = false;\n\n\tif (pci_check_pme_status(dev)) {\n\t\tpci_wakeup_event(dev);\n\t\tpm_request_resume(&dev->dev);\n\t}\n\treturn 0;\n}\n\n/**\n * pci_pme_wakeup_bus - Walk given bus and wake up devices on it, if necessary.\n * @bus: Top bus of the subtree to walk.\n */\nvoid pci_pme_wakeup_bus(struct pci_bus *bus)\n{\n\tif (bus)\n\t\tpci_walk_bus(bus, pci_pme_wakeup, (void *)true);\n}\n\n\n/**\n * pci_pme_capable - check the capability of PCI device to generate PME#\n * @dev: PCI device to handle.\n * @state: PCI state from which device will issue PME#.\n */\nbool pci_pme_capable(struct pci_dev *dev, pci_power_t state)\n{\n\tif (!dev->pm_cap)\n\t\treturn false;\n\n\treturn !!(dev->pme_support & (1 << state));\n}\nEXPORT_SYMBOL(pci_pme_capable);\n\nstatic void pci_pme_list_scan(struct work_struct *work)\n{\n\tstruct pci_pme_device *pme_dev, *n;\n\n\tmutex_lock(&pci_pme_list_mutex);\n\tlist_for_each_entry_safe(pme_dev, n, &pci_pme_list, list) {\n\t\tif (pme_dev->dev->pme_poll) {\n\t\t\tstruct pci_dev *bridge;\n\n\t\t\tbridge = pme_dev->dev->bus->self;\n\t\t\t/*\n\t\t\t * If bridge is in low power state, the\n\t\t\t * configuration space of subordinate devices\n\t\t\t * may be not accessible\n\t\t\t */\n\t\t\tif (bridge && bridge->current_state != PCI_D0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * If the device is in D3cold it should not be\n\t\t\t * polled either.\n\t\t\t */\n\t\t\tif (pme_dev->dev->current_state == PCI_D3cold)\n\t\t\t\tcontinue;\n\n\t\t\tpci_pme_wakeup(pme_dev->dev, NULL);\n\t\t} else {\n\t\t\tlist_del(&pme_dev->list);\n\t\t\tkfree(pme_dev);\n\t\t}\n\t}\n\tif (!list_empty(&pci_pme_list))\n\t\tqueue_delayed_work(system_freezable_wq, &pci_pme_work,\n\t\t\t\t   msecs_to_jiffies(PME_TIMEOUT));\n\tmutex_unlock(&pci_pme_list_mutex);\n}\n\nstatic void __pci_pme_active(struct pci_dev *dev, bool enable)\n{\n\tu16 pmcsr;\n\n\tif (!dev->pme_support)\n\t\treturn;\n\n\tpci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);\n\t/* Clear PME_Status by writing 1 to it and enable PME# */\n\tpmcsr |= PCI_PM_CTRL_PME_STATUS | PCI_PM_CTRL_PME_ENABLE;\n\tif (!enable)\n\t\tpmcsr &= ~PCI_PM_CTRL_PME_ENABLE;\n\n\tpci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pmcsr);\n}\n\n/**\n * pci_pme_restore - Restore PME configuration after config space restore.\n * @dev: PCI device to update.\n */\nvoid pci_pme_restore(struct pci_dev *dev)\n{\n\tu16 pmcsr;\n\n\tif (!dev->pme_support)\n\t\treturn;\n\n\tpci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);\n\tif (dev->wakeup_prepared) {\n\t\tpmcsr |= PCI_PM_CTRL_PME_ENABLE;\n\t\tpmcsr &= ~PCI_PM_CTRL_PME_STATUS;\n\t} else {\n\t\tpmcsr &= ~PCI_PM_CTRL_PME_ENABLE;\n\t\tpmcsr |= PCI_PM_CTRL_PME_STATUS;\n\t}\n\tpci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pmcsr);\n}\n\n/**\n * pci_pme_active - enable or disable PCI device's PME# function\n * @dev: PCI device to handle.\n * @enable: 'true' to enable PME# generation; 'false' to disable it.\n *\n * The caller must verify that the device is capable of generating PME# before\n * calling this function with @enable equal to 'true'.\n */\nvoid pci_pme_active(struct pci_dev *dev, bool enable)\n{\n\t__pci_pme_active(dev, enable);\n\n\t/*\n\t * PCI (as opposed to PCIe) PME requires that the device have\n\t * its PME# line hooked up correctly. Not all hardware vendors\n\t * do this, so the PME never gets delivered and the device\n\t * remains asleep. The easiest way around this is to\n\t * periodically walk the list of suspended devices and check\n\t * whether any have their PME flag set. The assumption is that\n\t * we'll wake up often enough anyway that this won't be a huge\n\t * hit, and the power savings from the devices will still be a\n\t * win.\n\t *\n\t * Although PCIe uses in-band PME message instead of PME# line\n\t * to report PME, PME does not work for some PCIe devices in\n\t * reality.  For example, there are devices that set their PME\n\t * status bits, but don't really bother to send a PME message;\n\t * there are PCI Express Root Ports that don't bother to\n\t * trigger interrupts when they receive PME messages from the\n\t * devices below.  So PME poll is used for PCIe devices too.\n\t */\n\n\tif (dev->pme_poll) {\n\t\tstruct pci_pme_device *pme_dev;\n\t\tif (enable) {\n\t\t\tpme_dev = kmalloc(sizeof(struct pci_pme_device),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!pme_dev) {\n\t\t\t\tpci_warn(dev, \"can't enable PME#\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpme_dev->dev = dev;\n\t\t\tmutex_lock(&pci_pme_list_mutex);\n\t\t\tlist_add(&pme_dev->list, &pci_pme_list);\n\t\t\tif (list_is_singular(&pci_pme_list))\n\t\t\t\tqueue_delayed_work(system_freezable_wq,\n\t\t\t\t\t\t   &pci_pme_work,\n\t\t\t\t\t\t   msecs_to_jiffies(PME_TIMEOUT));\n\t\t\tmutex_unlock(&pci_pme_list_mutex);\n\t\t} else {\n\t\t\tmutex_lock(&pci_pme_list_mutex);\n\t\t\tlist_for_each_entry(pme_dev, &pci_pme_list, list) {\n\t\t\t\tif (pme_dev->dev == dev) {\n\t\t\t\t\tlist_del(&pme_dev->list);\n\t\t\t\t\tkfree(pme_dev);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&pci_pme_list_mutex);\n\t\t}\n\t}\n\n\tpci_dbg(dev, \"PME# %s\\n\", enable ? \"enabled\" : \"disabled\");\n}\nEXPORT_SYMBOL(pci_pme_active);\n\n/**\n * __pci_enable_wake - enable PCI device as wakeup event source\n * @dev: PCI device affected\n * @state: PCI state from which device will issue wakeup events\n * @enable: True to enable event generation; false to disable\n *\n * This enables the device as a wakeup event source, or disables it.\n * When such events involves platform-specific hooks, those hooks are\n * called automatically by this routine.\n *\n * Devices with legacy power management (no standard PCI PM capabilities)\n * always require such platform hooks.\n *\n * RETURN VALUE:\n * 0 is returned on success\n * -EINVAL is returned if device is not supposed to wake up the system\n * Error code depending on the platform is returned if both the platform and\n * the native mechanism fail to enable the generation of wake-up events\n */\nstatic int __pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable)\n{\n\tint ret = 0;\n\n\t/*\n\t * Bridges that are not power-manageable directly only signal\n\t * wakeup on behalf of subordinate devices which is set up\n\t * elsewhere, so skip them. However, bridges that are\n\t * power-manageable may signal wakeup for themselves (for example,\n\t * on a hotplug event) and they need to be covered here.\n\t */\n\tif (!pci_power_manageable(dev))\n\t\treturn 0;\n\n\t/* Don't do the same thing twice in a row for one device. */\n\tif (!!enable == !!dev->wakeup_prepared)\n\t\treturn 0;\n\n\t/*\n\t * According to \"PCI System Architecture\" 4th ed. by Tom Shanley & Don\n\t * Anderson we should be doing PME# wake enable followed by ACPI wake\n\t * enable.  To disable wake-up we call the platform first, for symmetry.\n\t */\n\n\tif (enable) {\n\t\tint error;\n\n\t\tif (pci_pme_capable(dev, state))\n\t\t\tpci_pme_active(dev, true);\n\t\telse\n\t\t\tret = 1;\n\t\terror = platform_pci_set_wakeup(dev, true);\n\t\tif (ret)\n\t\t\tret = error;\n\t\tif (!ret)\n\t\t\tdev->wakeup_prepared = true;\n\t} else {\n\t\tplatform_pci_set_wakeup(dev, false);\n\t\tpci_pme_active(dev, false);\n\t\tdev->wakeup_prepared = false;\n\t}\n\n\treturn ret;\n}\n\n/**\n * pci_enable_wake - change wakeup settings for a PCI device\n * @pci_dev: Target device\n * @state: PCI state from which device will issue wakeup events\n * @enable: Whether or not to enable event generation\n *\n * If @enable is set, check device_may_wakeup() for the device before calling\n * __pci_enable_wake() for it.\n */\nint pci_enable_wake(struct pci_dev *pci_dev, pci_power_t state, bool enable)\n{\n\tif (enable && !device_may_wakeup(&pci_dev->dev))\n\t\treturn -EINVAL;\n\n\treturn __pci_enable_wake(pci_dev, state, enable);\n}\nEXPORT_SYMBOL(pci_enable_wake);\n\n/**\n * pci_wake_from_d3 - enable/disable device to wake up from D3_hot or D3_cold\n * @dev: PCI device to prepare\n * @enable: True to enable wake-up event generation; false to disable\n *\n * Many drivers want the device to wake up the system from D3_hot or D3_cold\n * and this function allows them to set that up cleanly - pci_enable_wake()\n * should not be called twice in a row to enable wake-up due to PCI PM vs ACPI\n * ordering constraints.\n *\n * This function only returns error code if the device is not allowed to wake\n * up the system from sleep or it is not capable of generating PME# from both\n * D3_hot and D3_cold and the platform is unable to enable wake-up power for it.\n */\nint pci_wake_from_d3(struct pci_dev *dev, bool enable)\n{\n\treturn pci_pme_capable(dev, PCI_D3cold) ?\n\t\t\tpci_enable_wake(dev, PCI_D3cold, enable) :\n\t\t\tpci_enable_wake(dev, PCI_D3hot, enable);\n}\nEXPORT_SYMBOL(pci_wake_from_d3);\n\n/**\n * pci_target_state - find an appropriate low power state for a given PCI dev\n * @dev: PCI device\n * @wakeup: Whether or not wakeup functionality will be enabled for the device.\n *\n * Use underlying platform code to find a supported low power state for @dev.\n * If the platform can't manage @dev, return the deepest state from which it\n * can generate wake events, based on any available PME info.\n */\nstatic pci_power_t pci_target_state(struct pci_dev *dev, bool wakeup)\n{\n\tpci_power_t target_state = PCI_D3hot;\n\n\tif (platform_pci_power_manageable(dev)) {\n\t\t/*\n\t\t * Call the platform to find the target state for the device.\n\t\t */\n\t\tpci_power_t state = platform_pci_choose_state(dev);\n\n\t\tswitch (state) {\n\t\tcase PCI_POWER_ERROR:\n\t\tcase PCI_UNKNOWN:\n\t\t\tbreak;\n\t\tcase PCI_D1:\n\t\tcase PCI_D2:\n\t\t\tif (pci_no_d1d2(dev))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\ttarget_state = state;\n\t\t}\n\n\t\treturn target_state;\n\t}\n\n\tif (!dev->pm_cap)\n\t\ttarget_state = PCI_D0;\n\n\t/*\n\t * If the device is in D3cold even though it's not power-manageable by\n\t * the platform, it may have been powered down by non-standard means.\n\t * Best to let it slumber.\n\t */\n\tif (dev->current_state == PCI_D3cold)\n\t\ttarget_state = PCI_D3cold;\n\n\tif (wakeup) {\n\t\t/*\n\t\t * Find the deepest state from which the device can generate\n\t\t * PME#.\n\t\t */\n\t\tif (dev->pme_support) {\n\t\t\twhile (target_state\n\t\t\t      && !(dev->pme_support & (1 << target_state)))\n\t\t\t\ttarget_state--;\n\t\t}\n\t}\n\n\treturn target_state;\n}\n\n/**\n * pci_prepare_to_sleep - prepare PCI device for system-wide transition\n *\t\t\t  into a sleep state\n * @dev: Device to handle.\n *\n * Choose the power state appropriate for the device depending on whether\n * it can wake up the system and/or is power manageable by the platform\n * (PCI_D3hot is the default) and put the device into that state.\n */\nint pci_prepare_to_sleep(struct pci_dev *dev)\n{\n\tbool wakeup = device_may_wakeup(&dev->dev);\n\tpci_power_t target_state = pci_target_state(dev, wakeup);\n\tint error;\n\n\tif (target_state == PCI_POWER_ERROR)\n\t\treturn -EIO;\n\n\tpci_enable_wake(dev, target_state, wakeup);\n\n\terror = pci_set_power_state(dev, target_state);\n\n\tif (error)\n\t\tpci_enable_wake(dev, target_state, false);\n\n\treturn error;\n}\nEXPORT_SYMBOL(pci_prepare_to_sleep);\n\n/**\n * pci_back_from_sleep - turn PCI device on during system-wide transition\n *\t\t\t into working state\n * @dev: Device to handle.\n *\n * Disable device's system wake-up capability and put it into D0.\n */\nint pci_back_from_sleep(struct pci_dev *dev)\n{\n\tpci_enable_wake(dev, PCI_D0, false);\n\treturn pci_set_power_state(dev, PCI_D0);\n}\nEXPORT_SYMBOL(pci_back_from_sleep);\n\n/**\n * pci_finish_runtime_suspend - Carry out PCI-specific part of runtime suspend.\n * @dev: PCI device being suspended.\n *\n * Prepare @dev to generate wake-up events at run time and put it into a low\n * power state.\n */\nint pci_finish_runtime_suspend(struct pci_dev *dev)\n{\n\tpci_power_t target_state;\n\tint error;\n\n\ttarget_state = pci_target_state(dev, device_can_wakeup(&dev->dev));\n\tif (target_state == PCI_POWER_ERROR)\n\t\treturn -EIO;\n\n\tdev->runtime_d3cold = target_state == PCI_D3cold;\n\n\t__pci_enable_wake(dev, target_state, pci_dev_run_wake(dev));\n\n\terror = pci_set_power_state(dev, target_state);\n\n\tif (error) {\n\t\tpci_enable_wake(dev, target_state, false);\n\t\tdev->runtime_d3cold = false;\n\t}\n\n\treturn error;\n}\n\n/**\n * pci_dev_run_wake - Check if device can generate run-time wake-up events.\n * @dev: Device to check.\n *\n * Return true if the device itself is capable of generating wake-up events\n * (through the platform or using the native PCIe PME) or if the device supports\n * PME and one of its upstream bridges can generate wake-up events.\n */\nbool pci_dev_run_wake(struct pci_dev *dev)\n{\n\tstruct pci_bus *bus = dev->bus;\n\n\tif (!dev->pme_support)\n\t\treturn false;\n\n\t/* PME-capable in principle, but not from the target power state */\n\tif (!pci_pme_capable(dev, pci_target_state(dev, true)))\n\t\treturn false;\n\n\tif (device_can_wakeup(&dev->dev))\n\t\treturn true;\n\n\twhile (bus->parent) {\n\t\tstruct pci_dev *bridge = bus->self;\n\n\t\tif (device_can_wakeup(&bridge->dev))\n\t\t\treturn true;\n\n\t\tbus = bus->parent;\n\t}\n\n\t/* We have reached the root bus. */\n\tif (bus->bridge)\n\t\treturn device_can_wakeup(bus->bridge);\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(pci_dev_run_wake);\n\n/**\n * pci_dev_need_resume - Check if it is necessary to resume the device.\n * @pci_dev: Device to check.\n *\n * Return 'true' if the device is not runtime-suspended or it has to be\n * reconfigured due to wakeup settings difference between system and runtime\n * suspend, or the current power state of it is not suitable for the upcoming\n * (system-wide) transition.\n */\nbool pci_dev_need_resume(struct pci_dev *pci_dev)\n{\n\tstruct device *dev = &pci_dev->dev;\n\tpci_power_t target_state;\n\n\tif (!pm_runtime_suspended(dev) || platform_pci_need_resume(pci_dev))\n\t\treturn true;\n\n\ttarget_state = pci_target_state(pci_dev, device_may_wakeup(dev));\n\n\t/*\n\t * If the earlier platform check has not triggered, D3cold is just power\n\t * removal on top of D3hot, so no need to resume the device in that\n\t * case.\n\t */\n\treturn target_state != pci_dev->current_state &&\n\t\ttarget_state != PCI_D3cold &&\n\t\tpci_dev->current_state != PCI_D3hot;\n}\n\n/**\n * pci_dev_adjust_pme - Adjust PME setting for a suspended device.\n * @pci_dev: Device to check.\n *\n * If the device is suspended and it is not configured for system wakeup,\n * disable PME for it to prevent it from waking up the system unnecessarily.\n *\n * Note that if the device's power state is D3cold and the platform check in\n * pci_dev_need_resume() has not triggered, the device's configuration need not\n * be changed.\n */\nvoid pci_dev_adjust_pme(struct pci_dev *pci_dev)\n{\n\tstruct device *dev = &pci_dev->dev;\n\n\tspin_lock_irq(&dev->power.lock);\n\n\tif (pm_runtime_suspended(dev) && !device_may_wakeup(dev) &&\n\t    pci_dev->current_state < PCI_D3cold)\n\t\t__pci_pme_active(pci_dev, false);\n\n\tspin_unlock_irq(&dev->power.lock);\n}\n\n/**\n * pci_dev_complete_resume - Finalize resume from system sleep for a device.\n * @pci_dev: Device to handle.\n *\n * If the device is runtime suspended and wakeup-capable, enable PME for it as\n * it might have been disabled during the prepare phase of system suspend if\n * the device was not configured for system wakeup.\n */\nvoid pci_dev_complete_resume(struct pci_dev *pci_dev)\n{\n\tstruct device *dev = &pci_dev->dev;\n\n\tif (!pci_dev_run_wake(pci_dev))\n\t\treturn;\n\n\tspin_lock_irq(&dev->power.lock);\n\n\tif (pm_runtime_suspended(dev) && pci_dev->current_state < PCI_D3cold)\n\t\t__pci_pme_active(pci_dev, true);\n\n\tspin_unlock_irq(&dev->power.lock);\n}\n\nvoid pci_config_pm_runtime_get(struct pci_dev *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device *parent = dev->parent;\n\n\tif (parent)\n\t\tpm_runtime_get_sync(parent);\n\tpm_runtime_get_noresume(dev);\n\t/*\n\t * pdev->current_state is set to PCI_D3cold during suspending,\n\t * so wait until suspending completes\n\t */\n\tpm_runtime_barrier(dev);\n\t/*\n\t * Only need to resume devices in D3cold, because config\n\t * registers are still accessible for devices suspended but\n\t * not in D3cold.\n\t */\n\tif (pdev->current_state == PCI_D3cold)\n\t\tpm_runtime_resume(dev);\n}\n\nvoid pci_config_pm_runtime_put(struct pci_dev *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device *parent = dev->parent;\n\n\tpm_runtime_put(dev);\n\tif (parent)\n\t\tpm_runtime_put_sync(parent);\n}\n\nstatic const struct dmi_system_id bridge_d3_blacklist[] = {\n#ifdef CONFIG_X86\n\t{\n\t\t/*\n\t\t * Gigabyte X299 root port is not marked as hotplug capable\n\t\t * which allows Linux to power manage it.  However, this\n\t\t * confuses the BIOS SMI handler so don't power manage root\n\t\t * ports on that system.\n\t\t */\n\t\t.ident = \"X299 DESIGNARE EX-CF\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Gigabyte Technology Co., Ltd.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"X299 DESIGNARE EX-CF\"),\n\t\t},\n\t},\n#endif\n\t{ }\n};\n\n/**\n * pci_bridge_d3_possible - Is it possible to put the bridge into D3\n * @bridge: Bridge to check\n *\n * This function checks if it is possible to move the bridge to D3.\n * Currently we only allow D3 for recent enough PCIe ports and Thunderbolt.\n */\nbool pci_bridge_d3_possible(struct pci_dev *bridge)\n{\n\tif (!pci_is_pcie(bridge))\n\t\treturn false;\n\n\tswitch (pci_pcie_type(bridge)) {\n\tcase PCI_EXP_TYPE_ROOT_PORT:\n\tcase PCI_EXP_TYPE_UPSTREAM:\n\tcase PCI_EXP_TYPE_DOWNSTREAM:\n\t\tif (pci_bridge_d3_disable)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Hotplug ports handled by firmware in System Management Mode\n\t\t * may not be put into D3 by the OS (Thunderbolt on non-Macs).\n\t\t */\n\t\tif (bridge->is_hotplug_bridge && !pciehp_is_native(bridge))\n\t\t\treturn false;\n\n\t\tif (pci_bridge_d3_force)\n\t\t\treturn true;\n\n\t\t/* Even the oldest 2010 Thunderbolt controller supports D3. */\n\t\tif (bridge->is_thunderbolt)\n\t\t\treturn true;\n\n\t\t/* Platform might know better if the bridge supports D3 */\n\t\tif (platform_pci_bridge_d3(bridge))\n\t\t\treturn true;\n\n\t\t/*\n\t\t * Hotplug ports handled natively by the OS were not validated\n\t\t * by vendors for runtime D3 at least until 2018 because there\n\t\t * was no OS support.\n\t\t */\n\t\tif (bridge->is_hotplug_bridge)\n\t\t\treturn false;\n\n\t\tif (dmi_check_system(bridge_d3_blacklist))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * It should be safe to put PCIe ports from 2015 or newer\n\t\t * to D3.\n\t\t */\n\t\tif (dmi_get_bios_year() >= 2015)\n\t\t\treturn true;\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic int pci_dev_check_d3cold(struct pci_dev *dev, void *data)\n{\n\tbool *d3cold_ok = data;\n\n\tif (/* The device needs to be allowed to go D3cold ... */\n\t    dev->no_d3cold || !dev->d3cold_allowed ||\n\n\t    /* ... and if it is wakeup capable to do so from D3cold. */\n\t    (device_may_wakeup(&dev->dev) &&\n\t     !pci_pme_capable(dev, PCI_D3cold)) ||\n\n\t    /* If it is a bridge it must be allowed to go to D3. */\n\t    !pci_power_manageable(dev))\n\n\t\t*d3cold_ok = false;\n\n\treturn !*d3cold_ok;\n}\n\n/*\n * pci_bridge_d3_update - Update bridge D3 capabilities\n * @dev: PCI device which is changed\n *\n * Update upstream bridge PM capabilities accordingly depending on if the\n * device PM configuration was changed or the device is being removed.  The\n * change is also propagated upstream.\n */\nvoid pci_bridge_d3_update(struct pci_dev *dev)\n{\n\tbool remove = !device_is_registered(&dev->dev);\n\tstruct pci_dev *bridge;\n\tbool d3cold_ok = true;\n\n\tbridge = pci_upstream_bridge(dev);\n\tif (!bridge || !pci_bridge_d3_possible(bridge))\n\t\treturn;\n\n\t/*\n\t * If D3 is currently allowed for the bridge, removing one of its\n\t * children won't change that.\n\t */\n\tif (remove && bridge->bridge_d3)\n\t\treturn;\n\n\t/*\n\t * If D3 is currently allowed for the bridge and a child is added or\n\t * changed, disallowance of D3 can only be caused by that child, so\n\t * we only need to check that single device, not any of its siblings.\n\t *\n\t * If D3 is currently not allowed for the bridge, checking the device\n\t * first may allow us to skip checking its siblings.\n\t */\n\tif (!remove)\n\t\tpci_dev_check_d3cold(dev, &d3cold_ok);\n\n\t/*\n\t * If D3 is currently not allowed for the bridge, this may be caused\n\t * either by the device being changed/removed or any of its siblings,\n\t * so we need to go through all children to find out if one of them\n\t * continues to block D3.\n\t */\n\tif (d3cold_ok && !bridge->bridge_d3)\n\t\tpci_walk_bus(bridge->subordinate, pci_dev_check_d3cold,\n\t\t\t     &d3cold_ok);\n\n\tif (bridge->bridge_d3 != d3cold_ok) {\n\t\tbridge->bridge_d3 = d3cold_ok;\n\t\t/* Propagate change to upstream bridges */\n\t\tpci_bridge_d3_update(bridge);\n\t}\n}\n\n/**\n * pci_d3cold_enable - Enable D3cold for device\n * @dev: PCI device to handle\n *\n * This function can be used in drivers to enable D3cold from the device\n * they handle.  It also updates upstream PCI bridge PM capabilities\n * accordingly.\n */\nvoid pci_d3cold_enable(struct pci_dev *dev)\n{\n\tif (dev->no_d3cold) {\n\t\tdev->no_d3cold = false;\n\t\tpci_bridge_d3_update(dev);\n\t}\n}\nEXPORT_SYMBOL_GPL(pci_d3cold_enable);\n\n/**\n * pci_d3cold_disable - Disable D3cold for device\n * @dev: PCI device to handle\n *\n * This function can be used in drivers to disable D3cold from the device\n * they handle.  It also updates upstream PCI bridge PM capabilities\n * accordingly.\n */\nvoid pci_d3cold_disable(struct pci_dev *dev)\n{\n\tif (!dev->no_d3cold) {\n\t\tdev->no_d3cold = true;\n\t\tpci_bridge_d3_update(dev);\n\t}\n}\nEXPORT_SYMBOL_GPL(pci_d3cold_disable);\n\n/**\n * pci_pm_init - Initialize PM functions of given PCI device\n * @dev: PCI device to handle.\n */\nvoid pci_pm_init(struct pci_dev *dev)\n{\n\tint pm;\n\tu16 status;\n\tu16 pmc;\n\n\tpm_runtime_forbid(&dev->dev);\n\tpm_runtime_set_active(&dev->dev);\n\tpm_runtime_enable(&dev->dev);\n\tdevice_enable_async_suspend(&dev->dev);\n\tdev->wakeup_prepared = false;\n\n\tdev->pm_cap = 0;\n\tdev->pme_support = 0;\n\n\t/* find PCI PM capability in list */\n\tpm = pci_find_capability(dev, PCI_CAP_ID_PM);\n\tif (!pm)\n\t\treturn;\n\t/* Check device's ability to generate PME# */\n\tpci_read_config_word(dev, pm + PCI_PM_PMC, &pmc);\n\n\tif ((pmc & PCI_PM_CAP_VER_MASK) > 3) {\n\t\tpci_err(dev, \"unsupported PM cap regs version (%u)\\n\",\n\t\t\tpmc & PCI_PM_CAP_VER_MASK);\n\t\treturn;\n\t}\n\n\tdev->pm_cap = pm;\n\tdev->d3hot_delay = PCI_PM_D3HOT_WAIT;\n\tdev->d3cold_delay = PCI_PM_D3COLD_WAIT;\n\tdev->bridge_d3 = pci_bridge_d3_possible(dev);\n\tdev->d3cold_allowed = true;\n\n\tdev->d1_support = false;\n\tdev->d2_support = false;\n\tif (!pci_no_d1d2(dev)) {\n\t\tif (pmc & PCI_PM_CAP_D1)\n\t\t\tdev->d1_support = true;\n\t\tif (pmc & PCI_PM_CAP_D2)\n\t\t\tdev->d2_support = true;\n\n\t\tif (dev->d1_support || dev->d2_support)\n\t\t\tpci_info(dev, \"supports%s%s\\n\",\n\t\t\t\t   dev->d1_support ? \" D1\" : \"\",\n\t\t\t\t   dev->d2_support ? \" D2\" : \"\");\n\t}\n\n\tpmc &= PCI_PM_CAP_PME_MASK;\n\tif (pmc) {\n\t\tpci_info(dev, \"PME# supported from%s%s%s%s%s\\n\",\n\t\t\t (pmc & PCI_PM_CAP_PME_D0) ? \" D0\" : \"\",\n\t\t\t (pmc & PCI_PM_CAP_PME_D1) ? \" D1\" : \"\",\n\t\t\t (pmc & PCI_PM_CAP_PME_D2) ? \" D2\" : \"\",\n\t\t\t (pmc & PCI_PM_CAP_PME_D3hot) ? \" D3hot\" : \"\",\n\t\t\t (pmc & PCI_PM_CAP_PME_D3cold) ? \" D3cold\" : \"\");\n\t\tdev->pme_support = pmc >> PCI_PM_CAP_PME_SHIFT;\n\t\tdev->pme_poll = true;\n\t\t/*\n\t\t * Make device's PM flags reflect the wake-up capability, but\n\t\t * let the user space enable it to wake up the system as needed.\n\t\t */\n\t\tdevice_set_wakeup_capable(&dev->dev, true);\n\t\t/* Disable the PME# generation functionality */\n\t\tpci_pme_active(dev, false);\n\t}\n\n\tpci_read_config_word(dev, PCI_STATUS, &status);\n\tif (status & PCI_STATUS_IMM_READY)\n\t\tdev->imm_ready = 1;\n}\n\nstatic unsigned long pci_ea_flags(struct pci_dev *dev, u8 prop)\n{\n\tunsigned long flags = IORESOURCE_PCI_FIXED | IORESOURCE_PCI_EA_BEI;\n\n\tswitch (prop) {\n\tcase PCI_EA_P_MEM:\n\tcase PCI_EA_P_VF_MEM:\n\t\tflags |= IORESOURCE_MEM;\n\t\tbreak;\n\tcase PCI_EA_P_MEM_PREFETCH:\n\tcase PCI_EA_P_VF_MEM_PREFETCH:\n\t\tflags |= IORESOURCE_MEM | IORESOURCE_PREFETCH;\n\t\tbreak;\n\tcase PCI_EA_P_IO:\n\t\tflags |= IORESOURCE_IO;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn flags;\n}\n\nstatic struct resource *pci_ea_get_resource(struct pci_dev *dev, u8 bei,\n\t\t\t\t\t    u8 prop)\n{\n\tif (bei <= PCI_EA_BEI_BAR5 && prop <= PCI_EA_P_IO)\n\t\treturn &dev->resource[bei];\n#ifdef CONFIG_PCI_IOV\n\telse if (bei >= PCI_EA_BEI_VF_BAR0 && bei <= PCI_EA_BEI_VF_BAR5 &&\n\t\t (prop == PCI_EA_P_VF_MEM || prop == PCI_EA_P_VF_MEM_PREFETCH))\n\t\treturn &dev->resource[PCI_IOV_RESOURCES +\n\t\t\t\t      bei - PCI_EA_BEI_VF_BAR0];\n#endif\n\telse if (bei == PCI_EA_BEI_ROM)\n\t\treturn &dev->resource[PCI_ROM_RESOURCE];\n\telse\n\t\treturn NULL;\n}\n\n/* Read an Enhanced Allocation (EA) entry */\nstatic int pci_ea_read(struct pci_dev *dev, int offset)\n{\n\tstruct resource *res;\n\tint ent_size, ent_offset = offset;\n\tresource_size_t start, end;\n\tunsigned long flags;\n\tu32 dw0, bei, base, max_offset;\n\tu8 prop;\n\tbool support_64 = (sizeof(resource_size_t) >= 8);\n\n\tpci_read_config_dword(dev, ent_offset, &dw0);\n\tent_offset += 4;\n\n\t/* Entry size field indicates DWORDs after 1st */\n\tent_size = ((dw0 & PCI_EA_ES) + 1) << 2;\n\n\tif (!(dw0 & PCI_EA_ENABLE)) /* Entry not enabled */\n\t\tgoto out;\n\n\tbei = (dw0 & PCI_EA_BEI) >> 4;\n\tprop = (dw0 & PCI_EA_PP) >> 8;\n\n\t/*\n\t * If the Property is in the reserved range, try the Secondary\n\t * Property instead.\n\t */\n\tif (prop > PCI_EA_P_BRIDGE_IO && prop < PCI_EA_P_MEM_RESERVED)\n\t\tprop = (dw0 & PCI_EA_SP) >> 16;\n\tif (prop > PCI_EA_P_BRIDGE_IO)\n\t\tgoto out;\n\n\tres = pci_ea_get_resource(dev, bei, prop);\n\tif (!res) {\n\t\tpci_err(dev, \"Unsupported EA entry BEI: %u\\n\", bei);\n\t\tgoto out;\n\t}\n\n\tflags = pci_ea_flags(dev, prop);\n\tif (!flags) {\n\t\tpci_err(dev, \"Unsupported EA properties: %#x\\n\", prop);\n\t\tgoto out;\n\t}\n\n\t/* Read Base */\n\tpci_read_config_dword(dev, ent_offset, &base);\n\tstart = (base & PCI_EA_FIELD_MASK);\n\tent_offset += 4;\n\n\t/* Read MaxOffset */\n\tpci_read_config_dword(dev, ent_offset, &max_offset);\n\tent_offset += 4;\n\n\t/* Read Base MSBs (if 64-bit entry) */\n\tif (base & PCI_EA_IS_64) {\n\t\tu32 base_upper;\n\n\t\tpci_read_config_dword(dev, ent_offset, &base_upper);\n\t\tent_offset += 4;\n\n\t\tflags |= IORESOURCE_MEM_64;\n\n\t\t/* entry starts above 32-bit boundary, can't use */\n\t\tif (!support_64 && base_upper)\n\t\t\tgoto out;\n\n\t\tif (support_64)\n\t\t\tstart |= ((u64)base_upper << 32);\n\t}\n\n\tend = start + (max_offset | 0x03);\n\n\t/* Read MaxOffset MSBs (if 64-bit entry) */\n\tif (max_offset & PCI_EA_IS_64) {\n\t\tu32 max_offset_upper;\n\n\t\tpci_read_config_dword(dev, ent_offset, &max_offset_upper);\n\t\tent_offset += 4;\n\n\t\tflags |= IORESOURCE_MEM_64;\n\n\t\t/* entry too big, can't use */\n\t\tif (!support_64 && max_offset_upper)\n\t\t\tgoto out;\n\n\t\tif (support_64)\n\t\t\tend += ((u64)max_offset_upper << 32);\n\t}\n\n\tif (end < start) {\n\t\tpci_err(dev, \"EA Entry crosses address boundary\\n\");\n\t\tgoto out;\n\t}\n\n\tif (ent_size != ent_offset - offset) {\n\t\tpci_err(dev, \"EA Entry Size (%d) does not match length read (%d)\\n\",\n\t\t\tent_size, ent_offset - offset);\n\t\tgoto out;\n\t}\n\n\tres->name = pci_name(dev);\n\tres->start = start;\n\tres->end = end;\n\tres->flags = flags;\n\n\tif (bei <= PCI_EA_BEI_BAR5)\n\t\tpci_info(dev, \"BAR %d: %pR (from Enhanced Allocation, properties %#02x)\\n\",\n\t\t\t   bei, res, prop);\n\telse if (bei == PCI_EA_BEI_ROM)\n\t\tpci_info(dev, \"ROM: %pR (from Enhanced Allocation, properties %#02x)\\n\",\n\t\t\t   res, prop);\n\telse if (bei >= PCI_EA_BEI_VF_BAR0 && bei <= PCI_EA_BEI_VF_BAR5)\n\t\tpci_info(dev, \"VF BAR %d: %pR (from Enhanced Allocation, properties %#02x)\\n\",\n\t\t\t   bei - PCI_EA_BEI_VF_BAR0, res, prop);\n\telse\n\t\tpci_info(dev, \"BEI %d res: %pR (from Enhanced Allocation, properties %#02x)\\n\",\n\t\t\t   bei, res, prop);\n\nout:\n\treturn offset + ent_size;\n}\n\n/* Enhanced Allocation Initialization */\nvoid pci_ea_init(struct pci_dev *dev)\n{\n\tint ea;\n\tu8 num_ent;\n\tint offset;\n\tint i;\n\n\t/* find PCI EA capability in list */\n\tea = pci_find_capability(dev, PCI_CAP_ID_EA);\n\tif (!ea)\n\t\treturn;\n\n\t/* determine the number of entries */\n\tpci_bus_read_config_byte(dev->bus, dev->devfn, ea + PCI_EA_NUM_ENT,\n\t\t\t\t\t&num_ent);\n\tnum_ent &= PCI_EA_NUM_ENT_MASK;\n\n\toffset = ea + PCI_EA_FIRST_ENT;\n\n\t/* Skip DWORD 2 for type 1 functions */\n\tif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE)\n\t\toffset += 4;\n\n\t/* parse each EA entry */\n\tfor (i = 0; i < num_ent; ++i)\n\t\toffset = pci_ea_read(dev, offset);\n}\n\nstatic void pci_add_saved_cap(struct pci_dev *pci_dev,\n\tstruct pci_cap_saved_state *new_cap)\n{\n\thlist_add_head(&new_cap->next, &pci_dev->saved_cap_space);\n}\n\n/**\n * _pci_add_cap_save_buffer - allocate buffer for saving given\n *\t\t\t      capability registers\n * @dev: the PCI device\n * @cap: the capability to allocate the buffer for\n * @extended: Standard or Extended capability ID\n * @size: requested size of the buffer\n */\nstatic int _pci_add_cap_save_buffer(struct pci_dev *dev, u16 cap,\n\t\t\t\t    bool extended, unsigned int size)\n{\n\tint pos;\n\tstruct pci_cap_saved_state *save_state;\n\n\tif (extended)\n\t\tpos = pci_find_ext_capability(dev, cap);\n\telse\n\t\tpos = pci_find_capability(dev, cap);\n\n\tif (!pos)\n\t\treturn 0;\n\n\tsave_state = kzalloc(sizeof(*save_state) + size, GFP_KERNEL);\n\tif (!save_state)\n\t\treturn -ENOMEM;\n\n\tsave_state->cap.cap_nr = cap;\n\tsave_state->cap.cap_extended = extended;\n\tsave_state->cap.size = size;\n\tpci_add_saved_cap(dev, save_state);\n\n\treturn 0;\n}\n\nint pci_add_cap_save_buffer(struct pci_dev *dev, char cap, unsigned int size)\n{\n\treturn _pci_add_cap_save_buffer(dev, cap, false, size);\n}\n\nint pci_add_ext_cap_save_buffer(struct pci_dev *dev, u16 cap, unsigned int size)\n{\n\treturn _pci_add_cap_save_buffer(dev, cap, true, size);\n}\n\n/**\n * pci_allocate_cap_save_buffers - allocate buffers for saving capabilities\n * @dev: the PCI device\n */\nvoid pci_allocate_cap_save_buffers(struct pci_dev *dev)\n{\n\tint error;\n\n\terror = pci_add_cap_save_buffer(dev, PCI_CAP_ID_EXP,\n\t\t\t\t\tPCI_EXP_SAVE_REGS * sizeof(u16));\n\tif (error)\n\t\tpci_err(dev, \"unable to preallocate PCI Express save buffer\\n\");\n\n\terror = pci_add_cap_save_buffer(dev, PCI_CAP_ID_PCIX, sizeof(u16));\n\tif (error)\n\t\tpci_err(dev, \"unable to preallocate PCI-X save buffer\\n\");\n\n\terror = pci_add_ext_cap_save_buffer(dev, PCI_EXT_CAP_ID_LTR,\n\t\t\t\t\t    2 * sizeof(u16));\n\tif (error)\n\t\tpci_err(dev, \"unable to allocate suspend buffer for LTR\\n\");\n\n\tpci_allocate_vc_save_buffers(dev);\n}\n\nvoid pci_free_cap_save_buffers(struct pci_dev *dev)\n{\n\tstruct pci_cap_saved_state *tmp;\n\tstruct hlist_node *n;\n\n\thlist_for_each_entry_safe(tmp, n, &dev->saved_cap_space, next)\n\t\tkfree(tmp);\n}\n\n/**\n * pci_configure_ari - enable or disable ARI forwarding\n * @dev: the PCI device\n *\n * If @dev and its upstream bridge both support ARI, enable ARI in the\n * bridge.  Otherwise, disable ARI in the bridge.\n */\nvoid pci_configure_ari(struct pci_dev *dev)\n{\n\tu32 cap;\n\tstruct pci_dev *bridge;\n\n\tif (pcie_ari_disabled || !pci_is_pcie(dev) || dev->devfn)\n\t\treturn;\n\n\tbridge = dev->bus->self;\n\tif (!bridge)\n\t\treturn;\n\n\tpcie_capability_read_dword(bridge, PCI_EXP_DEVCAP2, &cap);\n\tif (!(cap & PCI_EXP_DEVCAP2_ARI))\n\t\treturn;\n\n\tif (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ARI)) {\n\t\tpcie_capability_set_word(bridge, PCI_EXP_DEVCTL2,\n\t\t\t\t\t PCI_EXP_DEVCTL2_ARI);\n\t\tbridge->ari_enabled = 1;\n\t} else {\n\t\tpcie_capability_clear_word(bridge, PCI_EXP_DEVCTL2,\n\t\t\t\t\t   PCI_EXP_DEVCTL2_ARI);\n\t\tbridge->ari_enabled = 0;\n\t}\n}\n\nstatic bool pci_acs_flags_enabled(struct pci_dev *pdev, u16 acs_flags)\n{\n\tint pos;\n\tu16 cap, ctrl;\n\n\tpos = pdev->acs_cap;\n\tif (!pos)\n\t\treturn false;\n\n\t/*\n\t * Except for egress control, capabilities are either required\n\t * or only required if controllable.  Features missing from the\n\t * capability field can therefore be assumed as hard-wired enabled.\n\t */\n\tpci_read_config_word(pdev, pos + PCI_ACS_CAP, &cap);\n\tacs_flags &= (cap | PCI_ACS_EC);\n\n\tpci_read_config_word(pdev, pos + PCI_ACS_CTRL, &ctrl);\n\treturn (ctrl & acs_flags) == acs_flags;\n}\n\n/**\n * pci_acs_enabled - test ACS against required flags for a given device\n * @pdev: device to test\n * @acs_flags: required PCI ACS flags\n *\n * Return true if the device supports the provided flags.  Automatically\n * filters out flags that are not implemented on multifunction devices.\n *\n * Note that this interface checks the effective ACS capabilities of the\n * device rather than the actual capabilities.  For instance, most single\n * function endpoints are not required to support ACS because they have no\n * opportunity for peer-to-peer access.  We therefore return 'true'\n * regardless of whether the device exposes an ACS capability.  This makes\n * it much easier for callers of this function to ignore the actual type\n * or topology of the device when testing ACS support.\n */\nbool pci_acs_enabled(struct pci_dev *pdev, u16 acs_flags)\n{\n\tint ret;\n\n\tret = pci_dev_specific_acs_enabled(pdev, acs_flags);\n\tif (ret >= 0)\n\t\treturn ret > 0;\n\n\t/*\n\t * Conventional PCI and PCI-X devices never support ACS, either\n\t * effectively or actually.  The shared bus topology implies that\n\t * any device on the bus can receive or snoop DMA.\n\t */\n\tif (!pci_is_pcie(pdev))\n\t\treturn false;\n\n\tswitch (pci_pcie_type(pdev)) {\n\t/*\n\t * PCI/X-to-PCIe bridges are not specifically mentioned by the spec,\n\t * but since their primary interface is PCI/X, we conservatively\n\t * handle them as we would a non-PCIe device.\n\t */\n\tcase PCI_EXP_TYPE_PCIE_BRIDGE:\n\t/*\n\t * PCIe 3.0, 6.12.1 excludes ACS on these devices.  \"ACS is never\n\t * applicable... must never implement an ACS Extended Capability...\".\n\t * This seems arbitrary, but we take a conservative interpretation\n\t * of this statement.\n\t */\n\tcase PCI_EXP_TYPE_PCI_BRIDGE:\n\tcase PCI_EXP_TYPE_RC_EC:\n\t\treturn false;\n\t/*\n\t * PCIe 3.0, 6.12.1.1 specifies that downstream and root ports should\n\t * implement ACS in order to indicate their peer-to-peer capabilities,\n\t * regardless of whether they are single- or multi-function devices.\n\t */\n\tcase PCI_EXP_TYPE_DOWNSTREAM:\n\tcase PCI_EXP_TYPE_ROOT_PORT:\n\t\treturn pci_acs_flags_enabled(pdev, acs_flags);\n\t/*\n\t * PCIe 3.0, 6.12.1.2 specifies ACS capabilities that should be\n\t * implemented by the remaining PCIe types to indicate peer-to-peer\n\t * capabilities, but only when they are part of a multifunction\n\t * device.  The footnote for section 6.12 indicates the specific\n\t * PCIe types included here.\n\t */\n\tcase PCI_EXP_TYPE_ENDPOINT:\n\tcase PCI_EXP_TYPE_UPSTREAM:\n\tcase PCI_EXP_TYPE_LEG_END:\n\tcase PCI_EXP_TYPE_RC_END:\n\t\tif (!pdev->multifunction)\n\t\t\tbreak;\n\n\t\treturn pci_acs_flags_enabled(pdev, acs_flags);\n\t}\n\n\t/*\n\t * PCIe 3.0, 6.12.1.3 specifies no ACS capabilities are applicable\n\t * to single function devices with the exception of downstream ports.\n\t */\n\treturn true;\n}\n\n/**\n * pci_acs_path_enable - test ACS flags from start to end in a hierarchy\n * @start: starting downstream device\n * @end: ending upstream device or NULL to search to the root bus\n * @acs_flags: required flags\n *\n * Walk up a device tree from start to end testing PCI ACS support.  If\n * any step along the way does not support the required flags, return false.\n */\nbool pci_acs_path_enabled(struct pci_dev *start,\n\t\t\t  struct pci_dev *end, u16 acs_flags)\n{\n\tstruct pci_dev *pdev, *parent = start;\n\n\tdo {\n\t\tpdev = parent;\n\n\t\tif (!pci_acs_enabled(pdev, acs_flags))\n\t\t\treturn false;\n\n\t\tif (pci_is_root_bus(pdev->bus))\n\t\t\treturn (end == NULL);\n\n\t\tparent = pdev->bus->self;\n\t} while (pdev != end);\n\n\treturn true;\n}\n\n/**\n * pci_acs_init - Initialize ACS if hardware supports it\n * @dev: the PCI device\n */\nvoid pci_acs_init(struct pci_dev *dev)\n{\n\tdev->acs_cap = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ACS);\n\n\tif (dev->acs_cap)\n\t\tpci_enable_acs(dev);\n}\n\n/**\n * pci_rebar_find_pos - find position of resize ctrl reg for BAR\n * @pdev: PCI device\n * @bar: BAR to find\n *\n * Helper to find the position of the ctrl register for a BAR.\n * Returns -ENOTSUPP if resizable BARs are not supported at all.\n * Returns -ENOENT if no ctrl register for the BAR could be found.\n */\nstatic int pci_rebar_find_pos(struct pci_dev *pdev, int bar)\n{\n\tunsigned int pos, nbars, i;\n\tu32 ctrl;\n\n\tpos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_REBAR);\n\tif (!pos)\n\t\treturn -ENOTSUPP;\n\n\tpci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);\n\tnbars = (ctrl & PCI_REBAR_CTRL_NBAR_MASK) >>\n\t\t    PCI_REBAR_CTRL_NBAR_SHIFT;\n\n\tfor (i = 0; i < nbars; i++, pos += 8) {\n\t\tint bar_idx;\n\n\t\tpci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);\n\t\tbar_idx = ctrl & PCI_REBAR_CTRL_BAR_IDX;\n\t\tif (bar_idx == bar)\n\t\t\treturn pos;\n\t}\n\n\treturn -ENOENT;\n}\n\n/**\n * pci_rebar_get_possible_sizes - get possible sizes for BAR\n * @pdev: PCI device\n * @bar: BAR to query\n *\n * Get the possible sizes of a resizable BAR as bitmask defined in the spec\n * (bit 0=1MB, bit 19=512GB). Returns 0 if BAR isn't resizable.\n */\nu32 pci_rebar_get_possible_sizes(struct pci_dev *pdev, int bar)\n{\n\tint pos;\n\tu32 cap;\n\n\tpos = pci_rebar_find_pos(pdev, bar);\n\tif (pos < 0)\n\t\treturn 0;\n\n\tpci_read_config_dword(pdev, pos + PCI_REBAR_CAP, &cap);\n\treturn (cap & PCI_REBAR_CAP_SIZES) >> 4;\n}\n\n/**\n * pci_rebar_get_current_size - get the current size of a BAR\n * @pdev: PCI device\n * @bar: BAR to set size to\n *\n * Read the size of a BAR from the resizable BAR config.\n * Returns size if found or negative error code.\n */\nint pci_rebar_get_current_size(struct pci_dev *pdev, int bar)\n{\n\tint pos;\n\tu32 ctrl;\n\n\tpos = pci_rebar_find_pos(pdev, bar);\n\tif (pos < 0)\n\t\treturn pos;\n\n\tpci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);\n\treturn (ctrl & PCI_REBAR_CTRL_BAR_SIZE) >> PCI_REBAR_CTRL_BAR_SHIFT;\n}\n\n/**\n * pci_rebar_set_size - set a new size for a BAR\n * @pdev: PCI device\n * @bar: BAR to set size to\n * @size: new size as defined in the spec (0=1MB, 19=512GB)\n *\n * Set the new size of a BAR as defined in the spec.\n * Returns zero if resizing was successful, error code otherwise.\n */\nint pci_rebar_set_size(struct pci_dev *pdev, int bar, int size)\n{\n\tint pos;\n\tu32 ctrl;\n\n\tpos = pci_rebar_find_pos(pdev, bar);\n\tif (pos < 0)\n\t\treturn pos;\n\n\tpci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);\n\tctrl &= ~PCI_REBAR_CTRL_BAR_SIZE;\n\tctrl |= size << PCI_REBAR_CTRL_BAR_SHIFT;\n\tpci_write_config_dword(pdev, pos + PCI_REBAR_CTRL, ctrl);\n\treturn 0;\n}\n\n/**\n * pci_enable_atomic_ops_to_root - enable AtomicOp requests to root port\n * @dev: the PCI device\n * @cap_mask: mask of desired AtomicOp sizes, including one or more of:\n *\tPCI_EXP_DEVCAP2_ATOMIC_COMP32\n *\tPCI_EXP_DEVCAP2_ATOMIC_COMP64\n *\tPCI_EXP_DEVCAP2_ATOMIC_COMP128\n *\n * Return 0 if all upstream bridges support AtomicOp routing, egress\n * blocking is disabled on all upstream ports, and the root port supports\n * the requested completion capabilities (32-bit, 64-bit and/or 128-bit\n * AtomicOp completion), or negative otherwise.\n */\nint pci_enable_atomic_ops_to_root(struct pci_dev *dev, u32 cap_mask)\n{\n\tstruct pci_bus *bus = dev->bus;\n\tstruct pci_dev *bridge;\n\tu32 cap, ctl2;\n\n\tif (!pci_is_pcie(dev))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Per PCIe r4.0, sec 6.15, endpoints and root ports may be\n\t * AtomicOp requesters.  For now, we only support endpoints as\n\t * requesters and root ports as completers.  No endpoints as\n\t * completers, and no peer-to-peer.\n\t */\n\n\tswitch (pci_pcie_type(dev)) {\n\tcase PCI_EXP_TYPE_ENDPOINT:\n\tcase PCI_EXP_TYPE_LEG_END:\n\tcase PCI_EXP_TYPE_RC_END:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twhile (bus->parent) {\n\t\tbridge = bus->self;\n\n\t\tpcie_capability_read_dword(bridge, PCI_EXP_DEVCAP2, &cap);\n\n\t\tswitch (pci_pcie_type(bridge)) {\n\t\t/* Ensure switch ports support AtomicOp routing */\n\t\tcase PCI_EXP_TYPE_UPSTREAM:\n\t\tcase PCI_EXP_TYPE_DOWNSTREAM:\n\t\t\tif (!(cap & PCI_EXP_DEVCAP2_ATOMIC_ROUTE))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\t/* Ensure root port supports all the sizes we care about */\n\t\tcase PCI_EXP_TYPE_ROOT_PORT:\n\t\t\tif ((cap & cap_mask) != cap_mask)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Ensure upstream ports don't block AtomicOps on egress */\n\t\tif (pci_pcie_type(bridge) == PCI_EXP_TYPE_UPSTREAM) {\n\t\t\tpcie_capability_read_dword(bridge, PCI_EXP_DEVCTL2,\n\t\t\t\t\t\t   &ctl2);\n\t\t\tif (ctl2 & PCI_EXP_DEVCTL2_ATOMIC_EGRESS_BLOCK)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbus = bus->parent;\n\t}\n\n\tpcie_capability_set_word(dev, PCI_EXP_DEVCTL2,\n\t\t\t\t PCI_EXP_DEVCTL2_ATOMIC_REQ);\n\treturn 0;\n}\nEXPORT_SYMBOL(pci_enable_atomic_ops_to_root);\n\n/**\n * pci_swizzle_interrupt_pin - swizzle INTx for device behind bridge\n * @dev: the PCI device\n * @pin: the INTx pin (1=INTA, 2=INTB, 3=INTC, 4=INTD)\n *\n * Perform INTx swizzling for a device behind one level of bridge.  This is\n * required by section 9.1 of the PCI-to-PCI bridge specification for devices\n * behind bridges on add-in cards.  For devices with ARI enabled, the slot\n * number is always 0 (see the Implementation Note in section 2.2.8.1 of\n * the PCI Express Base Specification, Revision 2.1)\n */\nu8 pci_swizzle_interrupt_pin(const struct pci_dev *dev, u8 pin)\n{\n\tint slot;\n\n\tif (pci_ari_enabled(dev->bus))\n\t\tslot = 0;\n\telse\n\t\tslot = PCI_SLOT(dev->devfn);\n\n\treturn (((pin - 1) + slot) % 4) + 1;\n}\n\nint pci_get_interrupt_pin(struct pci_dev *dev, struct pci_dev **bridge)\n{\n\tu8 pin;\n\n\tpin = dev->pin;\n\tif (!pin)\n\t\treturn -1;\n\n\twhile (!pci_is_root_bus(dev->bus)) {\n\t\tpin = pci_swizzle_interrupt_pin(dev, pin);\n\t\tdev = dev->bus->self;\n\t}\n\t*bridge = dev;\n\treturn pin;\n}\n\n/**\n * pci_common_swizzle - swizzle INTx all the way to root bridge\n * @dev: the PCI device\n * @pinp: pointer to the INTx pin value (1=INTA, 2=INTB, 3=INTD, 4=INTD)\n *\n * Perform INTx swizzling for a device.  This traverses through all PCI-to-PCI\n * bridges all the way up to a PCI root bus.\n */\nu8 pci_common_swizzle(struct pci_dev *dev, u8 *pinp)\n{\n\tu8 pin = *pinp;\n\n\twhile (!pci_is_root_bus(dev->bus)) {\n\t\tpin = pci_swizzle_interrupt_pin(dev, pin);\n\t\tdev = dev->bus->self;\n\t}\n\t*pinp = pin;\n\treturn PCI_SLOT(dev->devfn);\n}\nEXPORT_SYMBOL_GPL(pci_common_swizzle);\n\n/**\n * pci_release_region - Release a PCI bar\n * @pdev: PCI device whose resources were previously reserved by\n *\t  pci_request_region()\n * @bar: BAR to release\n *\n * Releases the PCI I/O and memory resources previously reserved by a\n * successful call to pci_request_region().  Call this function only\n * after all use of the PCI regions has ceased.\n */\nvoid pci_release_region(struct pci_dev *pdev, int bar)\n{\n\tstruct pci_devres *dr;\n\n\tif (pci_resource_len(pdev, bar) == 0)\n\t\treturn;\n\tif (pci_resource_flags(pdev, bar) & IORESOURCE_IO)\n\t\trelease_region(pci_resource_start(pdev, bar),\n\t\t\t\tpci_resource_len(pdev, bar));\n\telse if (pci_resource_flags(pdev, bar) & IORESOURCE_MEM)\n\t\trelease_mem_region(pci_resource_start(pdev, bar),\n\t\t\t\tpci_resource_len(pdev, bar));\n\n\tdr = find_pci_dr(pdev);\n\tif (dr)\n\t\tdr->region_mask &= ~(1 << bar);\n}\nEXPORT_SYMBOL(pci_release_region);\n\n/**\n * __pci_request_region - Reserved PCI I/O and memory resource\n * @pdev: PCI device whose resources are to be reserved\n * @bar: BAR to be reserved\n * @res_name: Name to be associated with resource.\n * @exclusive: whether the region access is exclusive or not\n *\n * Mark the PCI region associated with PCI device @pdev BAR @bar as\n * being reserved by owner @res_name.  Do not access any\n * address inside the PCI regions unless this call returns\n * successfully.\n *\n * If @exclusive is set, then the region is marked so that userspace\n * is explicitly not allowed to map the resource via /dev/mem or\n * sysfs MMIO access.\n *\n * Returns 0 on success, or %EBUSY on error.  A warning\n * message is also printed on failure.\n */\nstatic int __pci_request_region(struct pci_dev *pdev, int bar,\n\t\t\t\tconst char *res_name, int exclusive)\n{\n\tstruct pci_devres *dr;\n\n\tif (pci_resource_len(pdev, bar) == 0)\n\t\treturn 0;\n\n\tif (pci_resource_flags(pdev, bar) & IORESOURCE_IO) {\n\t\tif (!request_region(pci_resource_start(pdev, bar),\n\t\t\t    pci_resource_len(pdev, bar), res_name))\n\t\t\tgoto err_out;\n\t} else if (pci_resource_flags(pdev, bar) & IORESOURCE_MEM) {\n\t\tif (!__request_mem_region(pci_resource_start(pdev, bar),\n\t\t\t\t\tpci_resource_len(pdev, bar), res_name,\n\t\t\t\t\texclusive))\n\t\t\tgoto err_out;\n\t}\n\n\tdr = find_pci_dr(pdev);\n\tif (dr)\n\t\tdr->region_mask |= 1 << bar;\n\n\treturn 0;\n\nerr_out:\n\tpci_warn(pdev, \"BAR %d: can't reserve %pR\\n\", bar,\n\t\t &pdev->resource[bar]);\n\treturn -EBUSY;\n}\n\n/**\n * pci_request_region - Reserve PCI I/O and memory resource\n * @pdev: PCI device whose resources are to be reserved\n * @bar: BAR to be reserved\n * @res_name: Name to be associated with resource\n *\n * Mark the PCI region associated with PCI device @pdev BAR @bar as\n * being reserved by owner @res_name.  Do not access any\n * address inside the PCI regions unless this call returns\n * successfully.\n *\n * Returns 0 on success, or %EBUSY on error.  A warning\n * message is also printed on failure.\n */\nint pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)\n{\n\treturn __pci_request_region(pdev, bar, res_name, 0);\n}\nEXPORT_SYMBOL(pci_request_region);\n\n/**\n * pci_release_selected_regions - Release selected PCI I/O and memory resources\n * @pdev: PCI device whose resources were previously reserved\n * @bars: Bitmask of BARs to be released\n *\n * Release selected PCI I/O and memory resources previously reserved.\n * Call this function only after all use of the PCI regions has ceased.\n */\nvoid pci_release_selected_regions(struct pci_dev *pdev, int bars)\n{\n\tint i;\n\n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++)\n\t\tif (bars & (1 << i))\n\t\t\tpci_release_region(pdev, i);\n}\nEXPORT_SYMBOL(pci_release_selected_regions);\n\nstatic int __pci_request_selected_regions(struct pci_dev *pdev, int bars,\n\t\t\t\t\t  const char *res_name, int excl)\n{\n\tint i;\n\n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++)\n\t\tif (bars & (1 << i))\n\t\t\tif (__pci_request_region(pdev, i, res_name, excl))\n\t\t\t\tgoto err_out;\n\treturn 0;\n\nerr_out:\n\twhile (--i >= 0)\n\t\tif (bars & (1 << i))\n\t\t\tpci_release_region(pdev, i);\n\n\treturn -EBUSY;\n}\n\n\n/**\n * pci_request_selected_regions - Reserve selected PCI I/O and memory resources\n * @pdev: PCI device whose resources are to be reserved\n * @bars: Bitmask of BARs to be requested\n * @res_name: Name to be associated with resource\n */\nint pci_request_selected_regions(struct pci_dev *pdev, int bars,\n\t\t\t\t const char *res_name)\n{\n\treturn __pci_request_selected_regions(pdev, bars, res_name, 0);\n}\nEXPORT_SYMBOL(pci_request_selected_regions);\n\nint pci_request_selected_regions_exclusive(struct pci_dev *pdev, int bars,\n\t\t\t\t\t   const char *res_name)\n{\n\treturn __pci_request_selected_regions(pdev, bars, res_name,\n\t\t\tIORESOURCE_EXCLUSIVE);\n}\nEXPORT_SYMBOL(pci_request_selected_regions_exclusive);\n\n/**\n * pci_release_regions - Release reserved PCI I/O and memory resources\n * @pdev: PCI device whose resources were previously reserved by\n *\t  pci_request_regions()\n *\n * Releases all PCI I/O and memory resources previously reserved by a\n * successful call to pci_request_regions().  Call this function only\n * after all use of the PCI regions has ceased.\n */\n\nvoid pci_release_regions(struct pci_dev *pdev)\n{\n\tpci_release_selected_regions(pdev, (1 << PCI_STD_NUM_BARS) - 1);\n}\nEXPORT_SYMBOL(pci_release_regions);\n\n/**\n * pci_request_regions - Reserve PCI I/O and memory resources\n * @pdev: PCI device whose resources are to be reserved\n * @res_name: Name to be associated with resource.\n *\n * Mark all PCI regions associated with PCI device @pdev as\n * being reserved by owner @res_name.  Do not access any\n * address inside the PCI regions unless this call returns\n * successfully.\n *\n * Returns 0 on success, or %EBUSY on error.  A warning\n * message is also printed on failure.\n */\nint pci_request_regions(struct pci_dev *pdev, const char *res_name)\n{\n\treturn pci_request_selected_regions(pdev,\n\t\t\t((1 << PCI_STD_NUM_BARS) - 1), res_name);\n}\nEXPORT_SYMBOL(pci_request_regions);\n\n/**\n * pci_request_regions_exclusive - Reserve PCI I/O and memory resources\n * @pdev: PCI device whose resources are to be reserved\n * @res_name: Name to be associated with resource.\n *\n * Mark all PCI regions associated with PCI device @pdev as being reserved\n * by owner @res_name.  Do not access any address inside the PCI regions\n * unless this call returns successfully.\n *\n * pci_request_regions_exclusive() will mark the region so that /dev/mem\n * and the sysfs MMIO access will not be allowed.\n *\n * Returns 0 on success, or %EBUSY on error.  A warning message is also\n * printed on failure.\n */\nint pci_request_regions_exclusive(struct pci_dev *pdev, const char *res_name)\n{\n\treturn pci_request_selected_regions_exclusive(pdev,\n\t\t\t\t((1 << PCI_STD_NUM_BARS) - 1), res_name);\n}\nEXPORT_SYMBOL(pci_request_regions_exclusive);\n\n/*\n * Record the PCI IO range (expressed as CPU physical address + size).\n * Return a negative value if an error has occurred, zero otherwise\n */\nint pci_register_io_range(struct fwnode_handle *fwnode, phys_addr_t addr,\n\t\t\tresource_size_t\tsize)\n{\n\tint ret = 0;\n#ifdef PCI_IOBASE\n\tstruct logic_pio_hwaddr *range;\n\n\tif (!size || addr + size < addr)\n\t\treturn -EINVAL;\n\n\trange = kzalloc(sizeof(*range), GFP_ATOMIC);\n\tif (!range)\n\t\treturn -ENOMEM;\n\n\trange->fwnode = fwnode;\n\trange->size = size;\n\trange->hw_start = addr;\n\trange->flags = LOGIC_PIO_CPU_MMIO;\n\n\tret = logic_pio_register_range(range);\n\tif (ret)\n\t\tkfree(range);\n#endif\n\n\treturn ret;\n}\n\nphys_addr_t pci_pio_to_address(unsigned long pio)\n{\n\tphys_addr_t address = (phys_addr_t)OF_BAD_ADDR;\n\n#ifdef PCI_IOBASE\n\tif (pio >= MMIO_UPPER_LIMIT)\n\t\treturn address;\n\n\taddress = logic_pio_to_hwaddr(pio);\n#endif\n\n\treturn address;\n}\n\nunsigned long __weak pci_address_to_pio(phys_addr_t address)\n{\n#ifdef PCI_IOBASE\n\treturn logic_pio_trans_cpuaddr(address);\n#else\n\tif (address > IO_SPACE_LIMIT)\n\t\treturn (unsigned long)-1;\n\n\treturn (unsigned long) address;\n#endif\n}\n\n/**\n * pci_remap_iospace - Remap the memory mapped I/O space\n * @res: Resource describing the I/O space\n * @phys_addr: physical address of range to be mapped\n *\n * Remap the memory mapped I/O space described by the @res and the CPU\n * physical address @phys_addr into virtual address space.  Only\n * architectures that have memory mapped IO functions defined (and the\n * PCI_IOBASE value defined) should call this function.\n */\nint pci_remap_iospace(const struct resource *res, phys_addr_t phys_addr)\n{\n#if defined(PCI_IOBASE) && defined(CONFIG_MMU)\n\tunsigned long vaddr = (unsigned long)PCI_IOBASE + res->start;\n\n\tif (!(res->flags & IORESOURCE_IO))\n\t\treturn -EINVAL;\n\n\tif (res->end > IO_SPACE_LIMIT)\n\t\treturn -EINVAL;\n\n\treturn ioremap_page_range(vaddr, vaddr + resource_size(res), phys_addr,\n\t\t\t\t  pgprot_device(PAGE_KERNEL));\n#else\n\t/*\n\t * This architecture does not have memory mapped I/O space,\n\t * so this function should never be called\n\t */\n\tWARN_ONCE(1, \"This architecture does not support memory mapped I/O\\n\");\n\treturn -ENODEV;\n#endif\n}\nEXPORT_SYMBOL(pci_remap_iospace);\n\n/**\n * pci_unmap_iospace - Unmap the memory mapped I/O space\n * @res: resource to be unmapped\n *\n * Unmap the CPU virtual address @res from virtual address space.  Only\n * architectures that have memory mapped IO functions defined (and the\n * PCI_IOBASE value defined) should call this function.\n */\nvoid pci_unmap_iospace(struct resource *res)\n{\n#if defined(PCI_IOBASE) && defined(CONFIG_MMU)\n\tunsigned long vaddr = (unsigned long)PCI_IOBASE + res->start;\n\n\tunmap_kernel_range(vaddr, resource_size(res));\n#endif\n}\nEXPORT_SYMBOL(pci_unmap_iospace);\n\nstatic void devm_pci_unmap_iospace(struct device *dev, void *ptr)\n{\n\tstruct resource **res = ptr;\n\n\tpci_unmap_iospace(*res);\n}\n\n/**\n * devm_pci_remap_iospace - Managed pci_remap_iospace()\n * @dev: Generic device to remap IO address for\n * @res: Resource describing the I/O space\n * @phys_addr: physical address of range to be mapped\n *\n * Managed pci_remap_iospace().  Map is automatically unmapped on driver\n * detach.\n */\nint devm_pci_remap_iospace(struct device *dev, const struct resource *res,\n\t\t\t   phys_addr_t phys_addr)\n{\n\tconst struct resource **ptr;\n\tint error;\n\n\tptr = devres_alloc(devm_pci_unmap_iospace, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\terror = pci_remap_iospace(res, phys_addr);\n\tif (error) {\n\t\tdevres_free(ptr);\n\t} else\t{\n\t\t*ptr = res;\n\t\tdevres_add(dev, ptr);\n\t}\n\n\treturn error;\n}\nEXPORT_SYMBOL(devm_pci_remap_iospace);\n\n/**\n * devm_pci_remap_cfgspace - Managed pci_remap_cfgspace()\n * @dev: Generic device to remap IO address for\n * @offset: Resource address to map\n * @size: Size of map\n *\n * Managed pci_remap_cfgspace().  Map is automatically unmapped on driver\n * detach.\n */\nvoid __iomem *devm_pci_remap_cfgspace(struct device *dev,\n\t\t\t\t      resource_size_t offset,\n\t\t\t\t      resource_size_t size)\n{\n\tvoid __iomem **ptr, *addr;\n\n\tptr = devres_alloc(devm_ioremap_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn NULL;\n\n\taddr = pci_remap_cfgspace(offset, size);\n\tif (addr) {\n\t\t*ptr = addr;\n\t\tdevres_add(dev, ptr);\n\t} else\n\t\tdevres_free(ptr);\n\n\treturn addr;\n}\nEXPORT_SYMBOL(devm_pci_remap_cfgspace);\n\n/**\n * devm_pci_remap_cfg_resource - check, request region and ioremap cfg resource\n * @dev: generic device to handle the resource for\n * @res: configuration space resource to be handled\n *\n * Checks that a resource is a valid memory region, requests the memory\n * region and ioremaps with pci_remap_cfgspace() API that ensures the\n * proper PCI configuration space memory attributes are guaranteed.\n *\n * All operations are managed and will be undone on driver detach.\n *\n * Returns a pointer to the remapped memory or an ERR_PTR() encoded error code\n * on failure. Usage example::\n *\n *\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n *\tbase = devm_pci_remap_cfg_resource(&pdev->dev, res);\n *\tif (IS_ERR(base))\n *\t\treturn PTR_ERR(base);\n */\nvoid __iomem *devm_pci_remap_cfg_resource(struct device *dev,\n\t\t\t\t\t  struct resource *res)\n{\n\tresource_size_t size;\n\tconst char *name;\n\tvoid __iomem *dest_ptr;\n\n\tBUG_ON(!dev);\n\n\tif (!res || resource_type(res) != IORESOURCE_MEM) {\n\t\tdev_err(dev, \"invalid resource\\n\");\n\t\treturn IOMEM_ERR_PTR(-EINVAL);\n\t}\n\n\tsize = resource_size(res);\n\tname = res->name ?: dev_name(dev);\n\n\tif (!devm_request_mem_region(dev, res->start, size, name)) {\n\t\tdev_err(dev, \"can't request region for resource %pR\\n\", res);\n\t\treturn IOMEM_ERR_PTR(-EBUSY);\n\t}\n\n\tdest_ptr = devm_pci_remap_cfgspace(dev, res->start, size);\n\tif (!dest_ptr) {\n\t\tdev_err(dev, \"ioremap failed for resource %pR\\n\", res);\n\t\tdevm_release_mem_region(dev, res->start, size);\n\t\tdest_ptr = IOMEM_ERR_PTR(-ENOMEM);\n\t}\n\n\treturn dest_ptr;\n}\nEXPORT_SYMBOL(devm_pci_remap_cfg_resource);\n\nstatic void __pci_set_master(struct pci_dev *dev, bool enable)\n{\n\tu16 old_cmd, cmd;\n\n\tpci_read_config_word(dev, PCI_COMMAND, &old_cmd);\n\tif (enable)\n\t\tcmd = old_cmd | PCI_COMMAND_MASTER;\n\telse\n\t\tcmd = old_cmd & ~PCI_COMMAND_MASTER;\n\tif (cmd != old_cmd) {\n\t\tpci_dbg(dev, \"%s bus mastering\\n\",\n\t\t\tenable ? \"enabling\" : \"disabling\");\n\t\tpci_write_config_word(dev, PCI_COMMAND, cmd);\n\t}\n\tdev->is_busmaster = enable;\n}\n\n/**\n * pcibios_setup - process \"pci=\" kernel boot arguments\n * @str: string used to pass in \"pci=\" kernel boot arguments\n *\n * Process kernel boot arguments.  This is the default implementation.\n * Architecture specific implementations can override this as necessary.\n */\nchar * __weak __init pcibios_setup(char *str)\n{\n\treturn str;\n}\n\n/**\n * pcibios_set_master - enable PCI bus-mastering for device dev\n * @dev: the PCI device to enable\n *\n * Enables PCI bus-mastering for the device.  This is the default\n * implementation.  Architecture specific implementations can override\n * this if necessary.\n */\nvoid __weak pcibios_set_master(struct pci_dev *dev)\n{\n\tu8 lat;\n\n\t/* The latency timer doesn't apply to PCIe (either Type 0 or Type 1) */\n\tif (pci_is_pcie(dev))\n\t\treturn;\n\n\tpci_read_config_byte(dev, PCI_LATENCY_TIMER, &lat);\n\tif (lat < 16)\n\t\tlat = (64 <= pcibios_max_latency) ? 64 : pcibios_max_latency;\n\telse if (lat > pcibios_max_latency)\n\t\tlat = pcibios_max_latency;\n\telse\n\t\treturn;\n\n\tpci_write_config_byte(dev, PCI_LATENCY_TIMER, lat);\n}\n\n/**\n * pci_set_master - enables bus-mastering for device dev\n * @dev: the PCI device to enable\n *\n * Enables bus-mastering on the device and calls pcibios_set_master()\n * to do the needed arch specific settings.\n */\nvoid pci_set_master(struct pci_dev *dev)\n{\n\t__pci_set_master(dev, true);\n\tpcibios_set_master(dev);\n}\nEXPORT_SYMBOL(pci_set_master);\n\n/**\n * pci_clear_master - disables bus-mastering for device dev\n * @dev: the PCI device to disable\n */\nvoid pci_clear_master(struct pci_dev *dev)\n{\n\t__pci_set_master(dev, false);\n}\nEXPORT_SYMBOL(pci_clear_master);\n\n/**\n * pci_set_cacheline_size - ensure the CACHE_LINE_SIZE register is programmed\n * @dev: the PCI device for which MWI is to be enabled\n *\n * Helper function for pci_set_mwi.\n * Originally copied from drivers/net/acenic.c.\n * Copyright 1998-2001 by Jes Sorensen, <jes@trained-monkey.org>.\n *\n * RETURNS: An appropriate -ERRNO error value on error, or zero for success.\n */\nint pci_set_cacheline_size(struct pci_dev *dev)\n{\n\tu8 cacheline_size;\n\n\tif (!pci_cache_line_size)\n\t\treturn -EINVAL;\n\n\t/* Validate current setting: the PCI_CACHE_LINE_SIZE must be\n\t   equal to or multiple of the right value. */\n\tpci_read_config_byte(dev, PCI_CACHE_LINE_SIZE, &cacheline_size);\n\tif (cacheline_size >= pci_cache_line_size &&\n\t    (cacheline_size % pci_cache_line_size) == 0)\n\t\treturn 0;\n\n\t/* Write the correct value. */\n\tpci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, pci_cache_line_size);\n\t/* Read it back. */\n\tpci_read_config_byte(dev, PCI_CACHE_LINE_SIZE, &cacheline_size);\n\tif (cacheline_size == pci_cache_line_size)\n\t\treturn 0;\n\n\tpci_info(dev, \"cache line size of %d is not supported\\n\",\n\t\t   pci_cache_line_size << 2);\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(pci_set_cacheline_size);\n\n/**\n * pci_set_mwi - enables memory-write-invalidate PCI transaction\n * @dev: the PCI device for which MWI is enabled\n *\n * Enables the Memory-Write-Invalidate transaction in %PCI_COMMAND.\n *\n * RETURNS: An appropriate -ERRNO error value on error, or zero for success.\n */\nint pci_set_mwi(struct pci_dev *dev)\n{\n#ifdef PCI_DISABLE_MWI\n\treturn 0;\n#else\n\tint rc;\n\tu16 cmd;\n\n\trc = pci_set_cacheline_size(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tpci_read_config_word(dev, PCI_COMMAND, &cmd);\n\tif (!(cmd & PCI_COMMAND_INVALIDATE)) {\n\t\tpci_dbg(dev, \"enabling Mem-Wr-Inval\\n\");\n\t\tcmd |= PCI_COMMAND_INVALIDATE;\n\t\tpci_write_config_word(dev, PCI_COMMAND, cmd);\n\t}\n\treturn 0;\n#endif\n}\nEXPORT_SYMBOL(pci_set_mwi);\n\n/**\n * pcim_set_mwi - a device-managed pci_set_mwi()\n * @dev: the PCI device for which MWI is enabled\n *\n * Managed pci_set_mwi().\n *\n * RETURNS: An appropriate -ERRNO error value on error, or zero for success.\n */\nint pcim_set_mwi(struct pci_dev *dev)\n{\n\tstruct pci_devres *dr;\n\n\tdr = find_pci_dr(dev);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tdr->mwi = 1;\n\treturn pci_set_mwi(dev);\n}\nEXPORT_SYMBOL(pcim_set_mwi);\n\n/**\n * pci_try_set_mwi - enables memory-write-invalidate PCI transaction\n * @dev: the PCI device for which MWI is enabled\n *\n * Enables the Memory-Write-Invalidate transaction in %PCI_COMMAND.\n * Callers are not required to check the return value.\n *\n * RETURNS: An appropriate -ERRNO error value on error, or zero for success.\n */\nint pci_try_set_mwi(struct pci_dev *dev)\n{\n#ifdef PCI_DISABLE_MWI\n\treturn 0;\n#else\n\treturn pci_set_mwi(dev);\n#endif\n}\nEXPORT_SYMBOL(pci_try_set_mwi);\n\n/**\n * pci_clear_mwi - disables Memory-Write-Invalidate for device dev\n * @dev: the PCI device to disable\n *\n * Disables PCI Memory-Write-Invalidate transaction on the device\n */\nvoid pci_clear_mwi(struct pci_dev *dev)\n{\n#ifndef PCI_DISABLE_MWI\n\tu16 cmd;\n\n\tpci_read_config_word(dev, PCI_COMMAND, &cmd);\n\tif (cmd & PCI_COMMAND_INVALIDATE) {\n\t\tcmd &= ~PCI_COMMAND_INVALIDATE;\n\t\tpci_write_config_word(dev, PCI_COMMAND, cmd);\n\t}\n#endif\n}\nEXPORT_SYMBOL(pci_clear_mwi);\n\n/**\n * pci_intx - enables/disables PCI INTx for device dev\n * @pdev: the PCI device to operate on\n * @enable: boolean: whether to enable or disable PCI INTx\n *\n * Enables/disables PCI INTx for device @pdev\n */\nvoid pci_intx(struct pci_dev *pdev, int enable)\n{\n\tu16 pci_command, new;\n\n\tpci_read_config_word(pdev, PCI_COMMAND, &pci_command);\n\n\tif (enable)\n\t\tnew = pci_command & ~PCI_COMMAND_INTX_DISABLE;\n\telse\n\t\tnew = pci_command | PCI_COMMAND_INTX_DISABLE;\n\n\tif (new != pci_command) {\n\t\tstruct pci_devres *dr;\n\n\t\tpci_write_config_word(pdev, PCI_COMMAND, new);\n\n\t\tdr = find_pci_dr(pdev);\n\t\tif (dr && !dr->restore_intx) {\n\t\t\tdr->restore_intx = 1;\n\t\t\tdr->orig_intx = !enable;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(pci_intx);\n\nstatic bool pci_check_and_set_intx_mask(struct pci_dev *dev, bool mask)\n{\n\tstruct pci_bus *bus = dev->bus;\n\tbool mask_updated = true;\n\tu32 cmd_status_dword;\n\tu16 origcmd, newcmd;\n\tunsigned long flags;\n\tbool irq_pending;\n\n\t/*\n\t * We do a single dword read to retrieve both command and status.\n\t * Document assumptions that make this possible.\n\t */\n\tBUILD_BUG_ON(PCI_COMMAND % 4);\n\tBUILD_BUG_ON(PCI_COMMAND + 2 != PCI_STATUS);\n\n\traw_spin_lock_irqsave(&pci_lock, flags);\n\n\tbus->ops->read(bus, dev->devfn, PCI_COMMAND, 4, &cmd_status_dword);\n\n\tirq_pending = (cmd_status_dword >> 16) & PCI_STATUS_INTERRUPT;\n\n\t/*\n\t * Check interrupt status register to see whether our device\n\t * triggered the interrupt (when masking) or the next IRQ is\n\t * already pending (when unmasking).\n\t */\n\tif (mask != irq_pending) {\n\t\tmask_updated = false;\n\t\tgoto done;\n\t}\n\n\torigcmd = cmd_status_dword;\n\tnewcmd = origcmd & ~PCI_COMMAND_INTX_DISABLE;\n\tif (mask)\n\t\tnewcmd |= PCI_COMMAND_INTX_DISABLE;\n\tif (newcmd != origcmd)\n\t\tbus->ops->write(bus, dev->devfn, PCI_COMMAND, 2, newcmd);\n\ndone:\n\traw_spin_unlock_irqrestore(&pci_lock, flags);\n\n\treturn mask_updated;\n}\n\n/**\n * pci_check_and_mask_intx - mask INTx on pending interrupt\n * @dev: the PCI device to operate on\n *\n * Check if the device dev has its INTx line asserted, mask it and return\n * true in that case. False is returned if no interrupt was pending.\n */\nbool pci_check_and_mask_intx(struct pci_dev *dev)\n{\n\treturn pci_check_and_set_intx_mask(dev, true);\n}\nEXPORT_SYMBOL_GPL(pci_check_and_mask_intx);\n\n/**\n * pci_check_and_unmask_intx - unmask INTx if no interrupt is pending\n * @dev: the PCI device to operate on\n *\n * Check if the device dev has its INTx line asserted, unmask it if not and\n * return true. False is returned and the mask remains active if there was\n * still an interrupt pending.\n */\nbool pci_check_and_unmask_intx(struct pci_dev *dev)\n{\n\treturn pci_check_and_set_intx_mask(dev, false);\n}\nEXPORT_SYMBOL_GPL(pci_check_and_unmask_intx);\n\n/**\n * pci_wait_for_pending_transaction - wait for pending transaction\n * @dev: the PCI device to operate on\n *\n * Return 0 if transaction is pending 1 otherwise.\n */\nint pci_wait_for_pending_transaction(struct pci_dev *dev)\n{\n\tif (!pci_is_pcie(dev))\n\t\treturn 1;\n\n\treturn pci_wait_for_pending(dev, pci_pcie_cap(dev) + PCI_EXP_DEVSTA,\n\t\t\t\t    PCI_EXP_DEVSTA_TRPND);\n}\nEXPORT_SYMBOL(pci_wait_for_pending_transaction);\n\n/**\n * pcie_has_flr - check if a device supports function level resets\n * @dev: device to check\n *\n * Returns true if the device advertises support for PCIe function level\n * resets.\n */\nbool pcie_has_flr(struct pci_dev *dev)\n{\n\tu32 cap;\n\n\tif (dev->dev_flags & PCI_DEV_FLAGS_NO_FLR_RESET)\n\t\treturn false;\n\n\tpcie_capability_read_dword(dev, PCI_EXP_DEVCAP, &cap);\n\treturn cap & PCI_EXP_DEVCAP_FLR;\n}\nEXPORT_SYMBOL_GPL(pcie_has_flr);\n\n/**\n * pcie_flr - initiate a PCIe function level reset\n * @dev: device to reset\n *\n * Initiate a function level reset on @dev.  The caller should ensure the\n * device supports FLR before calling this function, e.g. by using the\n * pcie_has_flr() helper.\n */\nint pcie_flr(struct pci_dev *dev)\n{\n\tif (!pci_wait_for_pending_transaction(dev))\n\t\tpci_err(dev, \"timed out waiting for pending transaction; performing function level reset anyway\\n\");\n\n\tpcie_capability_set_word(dev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_BCR_FLR);\n\n\tif (dev->imm_ready)\n\t\treturn 0;\n\n\t/*\n\t * Per PCIe r4.0, sec 6.6.2, a device must complete an FLR within\n\t * 100ms, but may silently discard requests while the FLR is in\n\t * progress.  Wait 100ms before trying to access the device.\n\t */\n\tmsleep(100);\n\n\treturn pci_dev_wait(dev, \"FLR\", PCIE_RESET_READY_POLL_MS);\n}\nEXPORT_SYMBOL_GPL(pcie_flr);\n\nstatic int pci_af_flr(struct pci_dev *dev, int probe)\n{\n\tint pos;\n\tu8 cap;\n\n\tpos = pci_find_capability(dev, PCI_CAP_ID_AF);\n\tif (!pos)\n\t\treturn -ENOTTY;\n\n\tif (dev->dev_flags & PCI_DEV_FLAGS_NO_FLR_RESET)\n\t\treturn -ENOTTY;\n\n\tpci_read_config_byte(dev, pos + PCI_AF_CAP, &cap);\n\tif (!(cap & PCI_AF_CAP_TP) || !(cap & PCI_AF_CAP_FLR))\n\t\treturn -ENOTTY;\n\n\tif (probe)\n\t\treturn 0;\n\n\t/*\n\t * Wait for Transaction Pending bit to clear.  A word-aligned test\n\t * is used, so we use the control offset rather than status and shift\n\t * the test bit to match.\n\t */\n\tif (!pci_wait_for_pending(dev, pos + PCI_AF_CTRL,\n\t\t\t\t PCI_AF_STATUS_TP << 8))\n\t\tpci_err(dev, \"timed out waiting for pending transaction; performing AF function level reset anyway\\n\");\n\n\tpci_write_config_byte(dev, pos + PCI_AF_CTRL, PCI_AF_CTRL_FLR);\n\n\tif (dev->imm_ready)\n\t\treturn 0;\n\n\t/*\n\t * Per Advanced Capabilities for Conventional PCI ECN, 13 April 2006,\n\t * updated 27 July 2006; a device must complete an FLR within\n\t * 100ms, but may silently discard requests while the FLR is in\n\t * progress.  Wait 100ms before trying to access the device.\n\t */\n\tmsleep(100);\n\n\treturn pci_dev_wait(dev, \"AF_FLR\", PCIE_RESET_READY_POLL_MS);\n}\n\n/**\n * pci_pm_reset - Put device into PCI_D3 and back into PCI_D0.\n * @dev: Device to reset.\n * @probe: If set, only check if the device can be reset this way.\n *\n * If @dev supports native PCI PM and its PCI_PM_CTRL_NO_SOFT_RESET flag is\n * unset, it will be reinitialized internally when going from PCI_D3hot to\n * PCI_D0.  If that's the case and the device is not in a low-power state\n * already, force it into PCI_D3hot and back to PCI_D0, causing it to be reset.\n *\n * NOTE: This causes the caller to sleep for twice the device power transition\n * cooldown period, which for the D0->D3hot and D3hot->D0 transitions is 10 ms\n * by default (i.e. unless the @dev's d3hot_delay field has a different value).\n * Moreover, only devices in D0 can be reset by this function.\n */\nstatic int pci_pm_reset(struct pci_dev *dev, int probe)\n{\n\tu16 csr;\n\n\tif (!dev->pm_cap || dev->dev_flags & PCI_DEV_FLAGS_NO_PM_RESET)\n\t\treturn -ENOTTY;\n\n\tpci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &csr);\n\tif (csr & PCI_PM_CTRL_NO_SOFT_RESET)\n\t\treturn -ENOTTY;\n\n\tif (probe)\n\t\treturn 0;\n\n\tif (dev->current_state != PCI_D0)\n\t\treturn -EINVAL;\n\n\tcsr &= ~PCI_PM_CTRL_STATE_MASK;\n\tcsr |= PCI_D3hot;\n\tpci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, csr);\n\tpci_dev_d3_sleep(dev);\n\n\tcsr &= ~PCI_PM_CTRL_STATE_MASK;\n\tcsr |= PCI_D0;\n\tpci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, csr);\n\tpci_dev_d3_sleep(dev);\n\n\treturn pci_dev_wait(dev, \"PM D3hot->D0\", PCIE_RESET_READY_POLL_MS);\n}\n\n/**\n * pcie_wait_for_link_delay - Wait until link is active or inactive\n * @pdev: Bridge device\n * @active: waiting for active or inactive?\n * @delay: Delay to wait after link has become active (in ms)\n *\n * Use this to wait till link becomes active or inactive.\n */\nstatic bool pcie_wait_for_link_delay(struct pci_dev *pdev, bool active,\n\t\t\t\t     int delay)\n{\n\tint timeout = 1000;\n\tbool ret;\n\tu16 lnk_status;\n\n\t/*\n\t * Some controllers might not implement link active reporting. In this\n\t * case, we wait for 1000 ms + any delay requested by the caller.\n\t */\n\tif (!pdev->link_active_reporting) {\n\t\tmsleep(timeout + delay);\n\t\treturn true;\n\t}\n\n\t/*\n\t * PCIe r4.0 sec 6.6.1, a component must enter LTSSM Detect within 20ms,\n\t * after which we should expect an link active if the reset was\n\t * successful. If so, software must wait a minimum 100ms before sending\n\t * configuration requests to devices downstream this port.\n\t *\n\t * If the link fails to activate, either the device was physically\n\t * removed or the link is permanently failed.\n\t */\n\tif (active)\n\t\tmsleep(20);\n\tfor (;;) {\n\t\tpcie_capability_read_word(pdev, PCI_EXP_LNKSTA, &lnk_status);\n\t\tret = !!(lnk_status & PCI_EXP_LNKSTA_DLLLA);\n\t\tif (ret == active)\n\t\t\tbreak;\n\t\tif (timeout <= 0)\n\t\t\tbreak;\n\t\tmsleep(10);\n\t\ttimeout -= 10;\n\t}\n\tif (active && ret)\n\t\tmsleep(delay);\n\n\treturn ret == active;\n}\n\n/**\n * pcie_wait_for_link - Wait until link is active or inactive\n * @pdev: Bridge device\n * @active: waiting for active or inactive?\n *\n * Use this to wait till link becomes active or inactive.\n */\nbool pcie_wait_for_link(struct pci_dev *pdev, bool active)\n{\n\treturn pcie_wait_for_link_delay(pdev, active, 100);\n}\n\n/*\n * Find maximum D3cold delay required by all the devices on the bus.  The\n * spec says 100 ms, but firmware can lower it and we allow drivers to\n * increase it as well.\n *\n * Called with @pci_bus_sem locked for reading.\n */\nstatic int pci_bus_max_d3cold_delay(const struct pci_bus *bus)\n{\n\tconst struct pci_dev *pdev;\n\tint min_delay = 100;\n\tint max_delay = 0;\n\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->d3cold_delay < min_delay)\n\t\t\tmin_delay = pdev->d3cold_delay;\n\t\tif (pdev->d3cold_delay > max_delay)\n\t\t\tmax_delay = pdev->d3cold_delay;\n\t}\n\n\treturn max(min_delay, max_delay);\n}\n\n/**\n * pci_bridge_wait_for_secondary_bus - Wait for secondary bus to be accessible\n * @dev: PCI bridge\n *\n * Handle necessary delays before access to the devices on the secondary\n * side of the bridge are permitted after D3cold to D0 transition.\n *\n * For PCIe this means the delays in PCIe 5.0 section 6.6.1. For\n * conventional PCI it means Tpvrh + Trhfa specified in PCI 3.0 section\n * 4.3.2.\n */\nvoid pci_bridge_wait_for_secondary_bus(struct pci_dev *dev)\n{\n\tstruct pci_dev *child;\n\tint delay;\n\n\tif (pci_dev_is_disconnected(dev))\n\t\treturn;\n\n\tif (!pci_is_bridge(dev) || !dev->bridge_d3)\n\t\treturn;\n\n\tdown_read(&pci_bus_sem);\n\n\t/*\n\t * We only deal with devices that are present currently on the bus.\n\t * For any hot-added devices the access delay is handled in pciehp\n\t * board_added(). In case of ACPI hotplug the firmware is expected\n\t * to configure the devices before OS is notified.\n\t */\n\tif (!dev->subordinate || list_empty(&dev->subordinate->devices)) {\n\t\tup_read(&pci_bus_sem);\n\t\treturn;\n\t}\n\n\t/* Take d3cold_delay requirements into account */\n\tdelay = pci_bus_max_d3cold_delay(dev->subordinate);\n\tif (!delay) {\n\t\tup_read(&pci_bus_sem);\n\t\treturn;\n\t}\n\n\tchild = list_first_entry(&dev->subordinate->devices, struct pci_dev,\n\t\t\t\t bus_list);\n\tup_read(&pci_bus_sem);\n\n\t/*\n\t * Conventional PCI and PCI-X we need to wait Tpvrh + Trhfa before\n\t * accessing the device after reset (that is 1000 ms + 100 ms). In\n\t * practice this should not be needed because we don't do power\n\t * management for them (see pci_bridge_d3_possible()).\n\t */\n\tif (!pci_is_pcie(dev)) {\n\t\tpci_dbg(dev, \"waiting %d ms for secondary bus\\n\", 1000 + delay);\n\t\tmsleep(1000 + delay);\n\t\treturn;\n\t}\n\n\t/*\n\t * For PCIe downstream and root ports that do not support speeds\n\t * greater than 5 GT/s need to wait minimum 100 ms. For higher\n\t * speeds (gen3) we need to wait first for the data link layer to\n\t * become active.\n\t *\n\t * However, 100 ms is the minimum and the PCIe spec says the\n\t * software must allow at least 1s before it can determine that the\n\t * device that did not respond is a broken device. There is\n\t * evidence that 100 ms is not always enough, for example certain\n\t * Titan Ridge xHCI controller does not always respond to\n\t * configuration requests if we only wait for 100 ms (see\n\t * https://bugzilla.kernel.org/show_bug.cgi?id=203885).\n\t *\n\t * Therefore we wait for 100 ms and check for the device presence.\n\t * If it is still not present give it an additional 100 ms.\n\t */\n\tif (!pcie_downstream_port(dev))\n\t\treturn;\n\n\tif (pcie_get_speed_cap(dev) <= PCIE_SPEED_5_0GT) {\n\t\tpci_dbg(dev, \"waiting %d ms for downstream link\\n\", delay);\n\t\tmsleep(delay);\n\t} else {\n\t\tpci_dbg(dev, \"waiting %d ms for downstream link, after activation\\n\",\n\t\t\tdelay);\n\t\tif (!pcie_wait_for_link_delay(dev, true, delay)) {\n\t\t\t/* Did not train, no need to wait any further */\n\t\t\tpci_info(dev, \"Data Link Layer Link Active not set in 1000 msec\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!pci_device_is_present(child)) {\n\t\tpci_dbg(child, \"waiting additional %d ms to become accessible\\n\", delay);\n\t\tmsleep(delay);\n\t}\n}\n\nvoid pci_reset_secondary_bus(struct pci_dev *dev)\n{\n\tu16 ctrl;\n\n\tpci_read_config_word(dev, PCI_BRIDGE_CONTROL, &ctrl);\n\tctrl |= PCI_BRIDGE_CTL_BUS_RESET;\n\tpci_write_config_word(dev, PCI_BRIDGE_CONTROL, ctrl);\n\n\t/*\n\t * PCI spec v3.0 7.6.4.2 requires minimum Trst of 1ms.  Double\n\t * this to 2ms to ensure that we meet the minimum requirement.\n\t */\n\tmsleep(2);\n\n\tctrl &= ~PCI_BRIDGE_CTL_BUS_RESET;\n\tpci_write_config_word(dev, PCI_BRIDGE_CONTROL, ctrl);\n\n\t/*\n\t * Trhfa for conventional PCI is 2^25 clock cycles.\n\t * Assuming a minimum 33MHz clock this results in a 1s\n\t * delay before we can consider subordinate devices to\n\t * be re-initialized.  PCIe has some ways to shorten this,\n\t * but we don't make use of them yet.\n\t */\n\tssleep(1);\n}\n\nvoid __weak pcibios_reset_secondary_bus(struct pci_dev *dev)\n{\n\tpci_reset_secondary_bus(dev);\n}\n\n/**\n * pci_bridge_secondary_bus_reset - Reset the secondary bus on a PCI bridge.\n * @dev: Bridge device\n *\n * Use the bridge control register to assert reset on the secondary bus.\n * Devices on the secondary bus are left in power-on state.\n */\nint pci_bridge_secondary_bus_reset(struct pci_dev *dev)\n{\n\tpcibios_reset_secondary_bus(dev);\n\n\treturn pci_dev_wait(dev, \"bus reset\", PCIE_RESET_READY_POLL_MS);\n}\nEXPORT_SYMBOL_GPL(pci_bridge_secondary_bus_reset);\n\nstatic int pci_parent_bus_reset(struct pci_dev *dev, int probe)\n{\n\tstruct pci_dev *pdev;\n\n\tif (pci_is_root_bus(dev->bus) || dev->subordinate ||\n\t    !dev->bus->self || dev->dev_flags & PCI_DEV_FLAGS_NO_BUS_RESET)\n\t\treturn -ENOTTY;\n\n\tlist_for_each_entry(pdev, &dev->bus->devices, bus_list)\n\t\tif (pdev != dev)\n\t\t\treturn -ENOTTY;\n\n\tif (probe)\n\t\treturn 0;\n\n\treturn pci_bridge_secondary_bus_reset(dev->bus->self);\n}\n\nstatic int pci_reset_hotplug_slot(struct hotplug_slot *hotplug, int probe)\n{\n\tint rc = -ENOTTY;\n\n\tif (!hotplug || !try_module_get(hotplug->owner))\n\t\treturn rc;\n\n\tif (hotplug->ops->reset_slot)\n\t\trc = hotplug->ops->reset_slot(hotplug, probe);\n\n\tmodule_put(hotplug->owner);\n\n\treturn rc;\n}\n\nstatic int pci_dev_reset_slot_function(struct pci_dev *dev, int probe)\n{\n\tif (dev->multifunction || dev->subordinate || !dev->slot ||\n\t    dev->dev_flags & PCI_DEV_FLAGS_NO_BUS_RESET)\n\t\treturn -ENOTTY;\n\n\treturn pci_reset_hotplug_slot(dev->slot->hotplug, probe);\n}\n\nstatic void pci_dev_lock(struct pci_dev *dev)\n{\n\tpci_cfg_access_lock(dev);\n\t/* block PM suspend, driver probe, etc. */\n\tdevice_lock(&dev->dev);\n}\n\n/* Return 1 on successful lock, 0 on contention */\nstatic int pci_dev_trylock(struct pci_dev *dev)\n{\n\tif (pci_cfg_access_trylock(dev)) {\n\t\tif (device_trylock(&dev->dev))\n\t\t\treturn 1;\n\t\tpci_cfg_access_unlock(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void pci_dev_unlock(struct pci_dev *dev)\n{\n\tdevice_unlock(&dev->dev);\n\tpci_cfg_access_unlock(dev);\n}\n\nstatic void pci_dev_save_and_disable(struct pci_dev *dev)\n{\n\tconst struct pci_error_handlers *err_handler =\n\t\t\tdev->driver ? dev->driver->err_handler : NULL;\n\n\t/*\n\t * dev->driver->err_handler->reset_prepare() is protected against\n\t * races with ->remove() by the device lock, which must be held by\n\t * the caller.\n\t */\n\tif (err_handler && err_handler->reset_prepare)\n\t\terr_handler->reset_prepare(dev);\n\n\t/*\n\t * Wake-up device prior to save.  PM registers default to D0 after\n\t * reset and a simple register restore doesn't reliably return\n\t * to a non-D0 state anyway.\n\t */\n\tpci_set_power_state(dev, PCI_D0);\n\n\tpci_save_state(dev);\n\t/*\n\t * Disable the device by clearing the Command register, except for\n\t * INTx-disable which is set.  This not only disables MMIO and I/O port\n\t * BARs, but also prevents the device from being Bus Master, preventing\n\t * DMA from the device including MSI/MSI-X interrupts.  For PCI 2.3\n\t * compliant devices, INTx-disable prevents legacy interrupts.\n\t */\n\tpci_write_config_word(dev, PCI_COMMAND, PCI_COMMAND_INTX_DISABLE);\n}\n\nstatic void pci_dev_restore(struct pci_dev *dev)\n{\n\tconst struct pci_error_handlers *err_handler =\n\t\t\tdev->driver ? dev->driver->err_handler : NULL;\n\n\tpci_restore_state(dev);\n\n\t/*\n\t * dev->driver->err_handler->reset_done() is protected against\n\t * races with ->remove() by the device lock, which must be held by\n\t * the caller.\n\t */\n\tif (err_handler && err_handler->reset_done)\n\t\terr_handler->reset_done(dev);\n}\n\n/**\n * __pci_reset_function_locked - reset a PCI device function while holding\n * the @dev mutex lock.\n * @dev: PCI device to reset\n *\n * Some devices allow an individual function to be reset without affecting\n * other functions in the same device.  The PCI device must be responsive\n * to PCI config space in order to use this function.\n *\n * The device function is presumed to be unused and the caller is holding\n * the device mutex lock when this function is called.\n *\n * Resetting the device will make the contents of PCI configuration space\n * random, so any caller of this must be prepared to reinitialise the\n * device including MSI, bus mastering, BARs, decoding IO and memory spaces,\n * etc.\n *\n * Returns 0 if the device function was successfully reset or negative if the\n * device doesn't support resetting a single function.\n */\nint __pci_reset_function_locked(struct pci_dev *dev)\n{\n\tint rc;\n\n\tmight_sleep();\n\n\t/*\n\t * A reset method returns -ENOTTY if it doesn't support this device\n\t * and we should try the next method.\n\t *\n\t * If it returns 0 (success), we're finished.  If it returns any\n\t * other error, we're also finished: this indicates that further\n\t * reset mechanisms might be broken on the device.\n\t */\n\trc = pci_dev_specific_reset(dev, 0);\n\tif (rc != -ENOTTY)\n\t\treturn rc;\n\tif (pcie_has_flr(dev)) {\n\t\trc = pcie_flr(dev);\n\t\tif (rc != -ENOTTY)\n\t\t\treturn rc;\n\t}\n\trc = pci_af_flr(dev, 0);\n\tif (rc != -ENOTTY)\n\t\treturn rc;\n\trc = pci_pm_reset(dev, 0);\n\tif (rc != -ENOTTY)\n\t\treturn rc;\n\trc = pci_dev_reset_slot_function(dev, 0);\n\tif (rc != -ENOTTY)\n\t\treturn rc;\n\treturn pci_parent_bus_reset(dev, 0);\n}\nEXPORT_SYMBOL_GPL(__pci_reset_function_locked);\n\n/**\n * pci_probe_reset_function - check whether the device can be safely reset\n * @dev: PCI device to reset\n *\n * Some devices allow an individual function to be reset without affecting\n * other functions in the same device.  The PCI device must be responsive\n * to PCI config space in order to use this function.\n *\n * Returns 0 if the device function can be reset or negative if the\n * device doesn't support resetting a single function.\n */\nint pci_probe_reset_function(struct pci_dev *dev)\n{\n\tint rc;\n\n\tmight_sleep();\n\n\trc = pci_dev_specific_reset(dev, 1);\n\tif (rc != -ENOTTY)\n\t\treturn rc;\n\tif (pcie_has_flr(dev))\n\t\treturn 0;\n\trc = pci_af_flr(dev, 1);\n\tif (rc != -ENOTTY)\n\t\treturn rc;\n\trc = pci_pm_reset(dev, 1);\n\tif (rc != -ENOTTY)\n\t\treturn rc;\n\trc = pci_dev_reset_slot_function(dev, 1);\n\tif (rc != -ENOTTY)\n\t\treturn rc;\n\n\treturn pci_parent_bus_reset(dev, 1);\n}\n\n/**\n * pci_reset_function - quiesce and reset a PCI device function\n * @dev: PCI device to reset\n *\n * Some devices allow an individual function to be reset without affecting\n * other functions in the same device.  The PCI device must be responsive\n * to PCI config space in order to use this function.\n *\n * This function does not just reset the PCI portion of a device, but\n * clears all the state associated with the device.  This function differs\n * from __pci_reset_function_locked() in that it saves and restores device state\n * over the reset and takes the PCI device lock.\n *\n * Returns 0 if the device function was successfully reset or negative if the\n * device doesn't support resetting a single function.\n */\nint pci_reset_function(struct pci_dev *dev)\n{\n\tint rc;\n\n\tif (!dev->reset_fn)\n\t\treturn -ENOTTY;\n\n\tpci_dev_lock(dev);\n\tpci_dev_save_and_disable(dev);\n\n\trc = __pci_reset_function_locked(dev);\n\n\tpci_dev_restore(dev);\n\tpci_dev_unlock(dev);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(pci_reset_function);\n\n/**\n * pci_reset_function_locked - quiesce and reset a PCI device function\n * @dev: PCI device to reset\n *\n * Some devices allow an individual function to be reset without affecting\n * other functions in the same device.  The PCI device must be responsive\n * to PCI config space in order to use this function.\n *\n * This function does not just reset the PCI portion of a device, but\n * clears all the state associated with the device.  This function differs\n * from __pci_reset_function_locked() in that it saves and restores device state\n * over the reset.  It also differs from pci_reset_function() in that it\n * requires the PCI device lock to be held.\n *\n * Returns 0 if the device function was successfully reset or negative if the\n * device doesn't support resetting a single function.\n */\nint pci_reset_function_locked(struct pci_dev *dev)\n{\n\tint rc;\n\n\tif (!dev->reset_fn)\n\t\treturn -ENOTTY;\n\n\tpci_dev_save_and_disable(dev);\n\n\trc = __pci_reset_function_locked(dev);\n\n\tpci_dev_restore(dev);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(pci_reset_function_locked);\n\n/**\n * pci_try_reset_function - quiesce and reset a PCI device function\n * @dev: PCI device to reset\n *\n * Same as above, except return -EAGAIN if unable to lock device.\n */\nint pci_try_reset_function(struct pci_dev *dev)\n{\n\tint rc;\n\n\tif (!dev->reset_fn)\n\t\treturn -ENOTTY;\n\n\tif (!pci_dev_trylock(dev))\n\t\treturn -EAGAIN;\n\n\tpci_dev_save_and_disable(dev);\n\trc = __pci_reset_function_locked(dev);\n\tpci_dev_restore(dev);\n\tpci_dev_unlock(dev);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(pci_try_reset_function);\n\n/* Do any devices on or below this bus prevent a bus reset? */\nstatic bool pci_bus_resetable(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\n\tif (bus->self && (bus->self->dev_flags & PCI_DEV_FLAGS_NO_BUS_RESET))\n\t\treturn false;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tif (dev->dev_flags & PCI_DEV_FLAGS_NO_BUS_RESET ||\n\t\t    (dev->subordinate && !pci_bus_resetable(dev->subordinate)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/* Lock devices from the top of the tree down */\nstatic void pci_bus_lock(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tpci_dev_lock(dev);\n\t\tif (dev->subordinate)\n\t\t\tpci_bus_lock(dev->subordinate);\n\t}\n}\n\n/* Unlock devices from the bottom of the tree up */\nstatic void pci_bus_unlock(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tif (dev->subordinate)\n\t\t\tpci_bus_unlock(dev->subordinate);\n\t\tpci_dev_unlock(dev);\n\t}\n}\n\n/* Return 1 on successful lock, 0 on contention */\nstatic int pci_bus_trylock(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tif (!pci_dev_trylock(dev))\n\t\t\tgoto unlock;\n\t\tif (dev->subordinate) {\n\t\t\tif (!pci_bus_trylock(dev->subordinate)) {\n\t\t\t\tpci_dev_unlock(dev);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n\nunlock:\n\tlist_for_each_entry_continue_reverse(dev, &bus->devices, bus_list) {\n\t\tif (dev->subordinate)\n\t\t\tpci_bus_unlock(dev->subordinate);\n\t\tpci_dev_unlock(dev);\n\t}\n\treturn 0;\n}\n\n/* Do any devices on or below this slot prevent a bus reset? */\nstatic bool pci_slot_resetable(struct pci_slot *slot)\n{\n\tstruct pci_dev *dev;\n\n\tif (slot->bus->self &&\n\t    (slot->bus->self->dev_flags & PCI_DEV_FLAGS_NO_BUS_RESET))\n\t\treturn false;\n\n\tlist_for_each_entry(dev, &slot->bus->devices, bus_list) {\n\t\tif (!dev->slot || dev->slot != slot)\n\t\t\tcontinue;\n\t\tif (dev->dev_flags & PCI_DEV_FLAGS_NO_BUS_RESET ||\n\t\t    (dev->subordinate && !pci_bus_resetable(dev->subordinate)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/* Lock devices from the top of the tree down */\nstatic void pci_slot_lock(struct pci_slot *slot)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &slot->bus->devices, bus_list) {\n\t\tif (!dev->slot || dev->slot != slot)\n\t\t\tcontinue;\n\t\tpci_dev_lock(dev);\n\t\tif (dev->subordinate)\n\t\t\tpci_bus_lock(dev->subordinate);\n\t}\n}\n\n/* Unlock devices from the bottom of the tree up */\nstatic void pci_slot_unlock(struct pci_slot *slot)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &slot->bus->devices, bus_list) {\n\t\tif (!dev->slot || dev->slot != slot)\n\t\t\tcontinue;\n\t\tif (dev->subordinate)\n\t\t\tpci_bus_unlock(dev->subordinate);\n\t\tpci_dev_unlock(dev);\n\t}\n}\n\n/* Return 1 on successful lock, 0 on contention */\nstatic int pci_slot_trylock(struct pci_slot *slot)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &slot->bus->devices, bus_list) {\n\t\tif (!dev->slot || dev->slot != slot)\n\t\t\tcontinue;\n\t\tif (!pci_dev_trylock(dev))\n\t\t\tgoto unlock;\n\t\tif (dev->subordinate) {\n\t\t\tif (!pci_bus_trylock(dev->subordinate)) {\n\t\t\t\tpci_dev_unlock(dev);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n\nunlock:\n\tlist_for_each_entry_continue_reverse(dev,\n\t\t\t\t\t     &slot->bus->devices, bus_list) {\n\t\tif (!dev->slot || dev->slot != slot)\n\t\t\tcontinue;\n\t\tif (dev->subordinate)\n\t\t\tpci_bus_unlock(dev->subordinate);\n\t\tpci_dev_unlock(dev);\n\t}\n\treturn 0;\n}\n\n/*\n * Save and disable devices from the top of the tree down while holding\n * the @dev mutex lock for the entire tree.\n */\nstatic void pci_bus_save_and_disable_locked(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tpci_dev_save_and_disable(dev);\n\t\tif (dev->subordinate)\n\t\t\tpci_bus_save_and_disable_locked(dev->subordinate);\n\t}\n}\n\n/*\n * Restore devices from top of the tree down while holding @dev mutex lock\n * for the entire tree.  Parent bridges need to be restored before we can\n * get to subordinate devices.\n */\nstatic void pci_bus_restore_locked(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tpci_dev_restore(dev);\n\t\tif (dev->subordinate)\n\t\t\tpci_bus_restore_locked(dev->subordinate);\n\t}\n}\n\n/*\n * Save and disable devices from the top of the tree down while holding\n * the @dev mutex lock for the entire tree.\n */\nstatic void pci_slot_save_and_disable_locked(struct pci_slot *slot)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &slot->bus->devices, bus_list) {\n\t\tif (!dev->slot || dev->slot != slot)\n\t\t\tcontinue;\n\t\tpci_dev_save_and_disable(dev);\n\t\tif (dev->subordinate)\n\t\t\tpci_bus_save_and_disable_locked(dev->subordinate);\n\t}\n}\n\n/*\n * Restore devices from top of the tree down while holding @dev mutex lock\n * for the entire tree.  Parent bridges need to be restored before we can\n * get to subordinate devices.\n */\nstatic void pci_slot_restore_locked(struct pci_slot *slot)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &slot->bus->devices, bus_list) {\n\t\tif (!dev->slot || dev->slot != slot)\n\t\t\tcontinue;\n\t\tpci_dev_restore(dev);\n\t\tif (dev->subordinate)\n\t\t\tpci_bus_restore_locked(dev->subordinate);\n\t}\n}\n\nstatic int pci_slot_reset(struct pci_slot *slot, int probe)\n{\n\tint rc;\n\n\tif (!slot || !pci_slot_resetable(slot))\n\t\treturn -ENOTTY;\n\n\tif (!probe)\n\t\tpci_slot_lock(slot);\n\n\tmight_sleep();\n\n\trc = pci_reset_hotplug_slot(slot->hotplug, probe);\n\n\tif (!probe)\n\t\tpci_slot_unlock(slot);\n\n\treturn rc;\n}\n\n/**\n * pci_probe_reset_slot - probe whether a PCI slot can be reset\n * @slot: PCI slot to probe\n *\n * Return 0 if slot can be reset, negative if a slot reset is not supported.\n */\nint pci_probe_reset_slot(struct pci_slot *slot)\n{\n\treturn pci_slot_reset(slot, 1);\n}\nEXPORT_SYMBOL_GPL(pci_probe_reset_slot);\n\n/**\n * __pci_reset_slot - Try to reset a PCI slot\n * @slot: PCI slot to reset\n *\n * A PCI bus may host multiple slots, each slot may support a reset mechanism\n * independent of other slots.  For instance, some slots may support slot power\n * control.  In the case of a 1:1 bus to slot architecture, this function may\n * wrap the bus reset to avoid spurious slot related events such as hotplug.\n * Generally a slot reset should be attempted before a bus reset.  All of the\n * function of the slot and any subordinate buses behind the slot are reset\n * through this function.  PCI config space of all devices in the slot and\n * behind the slot is saved before and restored after reset.\n *\n * Same as above except return -EAGAIN if the slot cannot be locked\n */\nstatic int __pci_reset_slot(struct pci_slot *slot)\n{\n\tint rc;\n\n\trc = pci_slot_reset(slot, 1);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pci_slot_trylock(slot)) {\n\t\tpci_slot_save_and_disable_locked(slot);\n\t\tmight_sleep();\n\t\trc = pci_reset_hotplug_slot(slot->hotplug, 0);\n\t\tpci_slot_restore_locked(slot);\n\t\tpci_slot_unlock(slot);\n\t} else\n\t\trc = -EAGAIN;\n\n\treturn rc;\n}\n\nstatic int pci_bus_reset(struct pci_bus *bus, int probe)\n{\n\tint ret;\n\n\tif (!bus->self || !pci_bus_resetable(bus))\n\t\treturn -ENOTTY;\n\n\tif (probe)\n\t\treturn 0;\n\n\tpci_bus_lock(bus);\n\n\tmight_sleep();\n\n\tret = pci_bridge_secondary_bus_reset(bus->self);\n\n\tpci_bus_unlock(bus);\n\n\treturn ret;\n}\n\n/**\n * pci_bus_error_reset - reset the bridge's subordinate bus\n * @bridge: The parent device that connects to the bus to reset\n *\n * This function will first try to reset the slots on this bus if the method is\n * available. If slot reset fails or is not available, this will fall back to a\n * secondary bus reset.\n */\nint pci_bus_error_reset(struct pci_dev *bridge)\n{\n\tstruct pci_bus *bus = bridge->subordinate;\n\tstruct pci_slot *slot;\n\n\tif (!bus)\n\t\treturn -ENOTTY;\n\n\tmutex_lock(&pci_slot_mutex);\n\tif (list_empty(&bus->slots))\n\t\tgoto bus_reset;\n\n\tlist_for_each_entry(slot, &bus->slots, list)\n\t\tif (pci_probe_reset_slot(slot))\n\t\t\tgoto bus_reset;\n\n\tlist_for_each_entry(slot, &bus->slots, list)\n\t\tif (pci_slot_reset(slot, 0))\n\t\t\tgoto bus_reset;\n\n\tmutex_unlock(&pci_slot_mutex);\n\treturn 0;\nbus_reset:\n\tmutex_unlock(&pci_slot_mutex);\n\treturn pci_bus_reset(bridge->subordinate, 0);\n}\n\n/**\n * pci_probe_reset_bus - probe whether a PCI bus can be reset\n * @bus: PCI bus to probe\n *\n * Return 0 if bus can be reset, negative if a bus reset is not supported.\n */\nint pci_probe_reset_bus(struct pci_bus *bus)\n{\n\treturn pci_bus_reset(bus, 1);\n}\nEXPORT_SYMBOL_GPL(pci_probe_reset_bus);\n\n/**\n * __pci_reset_bus - Try to reset a PCI bus\n * @bus: top level PCI bus to reset\n *\n * Same as above except return -EAGAIN if the bus cannot be locked\n */\nstatic int __pci_reset_bus(struct pci_bus *bus)\n{\n\tint rc;\n\n\trc = pci_bus_reset(bus, 1);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pci_bus_trylock(bus)) {\n\t\tpci_bus_save_and_disable_locked(bus);\n\t\tmight_sleep();\n\t\trc = pci_bridge_secondary_bus_reset(bus->self);\n\t\tpci_bus_restore_locked(bus);\n\t\tpci_bus_unlock(bus);\n\t} else\n\t\trc = -EAGAIN;\n\n\treturn rc;\n}\n\n/**\n * pci_reset_bus - Try to reset a PCI bus\n * @pdev: top level PCI device to reset via slot/bus\n *\n * Same as above except return -EAGAIN if the bus cannot be locked\n */\nint pci_reset_bus(struct pci_dev *pdev)\n{\n\treturn (!pci_probe_reset_slot(pdev->slot)) ?\n\t    __pci_reset_slot(pdev->slot) : __pci_reset_bus(pdev->bus);\n}\nEXPORT_SYMBOL_GPL(pci_reset_bus);\n\n/**\n * pcix_get_max_mmrbc - get PCI-X maximum designed memory read byte count\n * @dev: PCI device to query\n *\n * Returns mmrbc: maximum designed memory read count in bytes or\n * appropriate error value.\n */\nint pcix_get_max_mmrbc(struct pci_dev *dev)\n{\n\tint cap;\n\tu32 stat;\n\n\tcap = pci_find_capability(dev, PCI_CAP_ID_PCIX);\n\tif (!cap)\n\t\treturn -EINVAL;\n\n\tif (pci_read_config_dword(dev, cap + PCI_X_STATUS, &stat))\n\t\treturn -EINVAL;\n\n\treturn 512 << ((stat & PCI_X_STATUS_MAX_READ) >> 21);\n}\nEXPORT_SYMBOL(pcix_get_max_mmrbc);\n\n/**\n * pcix_get_mmrbc - get PCI-X maximum memory read byte count\n * @dev: PCI device to query\n *\n * Returns mmrbc: maximum memory read count in bytes or appropriate error\n * value.\n */\nint pcix_get_mmrbc(struct pci_dev *dev)\n{\n\tint cap;\n\tu16 cmd;\n\n\tcap = pci_find_capability(dev, PCI_CAP_ID_PCIX);\n\tif (!cap)\n\t\treturn -EINVAL;\n\n\tif (pci_read_config_word(dev, cap + PCI_X_CMD, &cmd))\n\t\treturn -EINVAL;\n\n\treturn 512 << ((cmd & PCI_X_CMD_MAX_READ) >> 2);\n}\nEXPORT_SYMBOL(pcix_get_mmrbc);\n\n/**\n * pcix_set_mmrbc - set PCI-X maximum memory read byte count\n * @dev: PCI device to query\n * @mmrbc: maximum memory read count in bytes\n *    valid values are 512, 1024, 2048, 4096\n *\n * If possible sets maximum memory read byte count, some bridges have errata\n * that prevent this.\n */\nint pcix_set_mmrbc(struct pci_dev *dev, int mmrbc)\n{\n\tint cap;\n\tu32 stat, v, o;\n\tu16 cmd;\n\n\tif (mmrbc < 512 || mmrbc > 4096 || !is_power_of_2(mmrbc))\n\t\treturn -EINVAL;\n\n\tv = ffs(mmrbc) - 10;\n\n\tcap = pci_find_capability(dev, PCI_CAP_ID_PCIX);\n\tif (!cap)\n\t\treturn -EINVAL;\n\n\tif (pci_read_config_dword(dev, cap + PCI_X_STATUS, &stat))\n\t\treturn -EINVAL;\n\n\tif (v > (stat & PCI_X_STATUS_MAX_READ) >> 21)\n\t\treturn -E2BIG;\n\n\tif (pci_read_config_word(dev, cap + PCI_X_CMD, &cmd))\n\t\treturn -EINVAL;\n\n\to = (cmd & PCI_X_CMD_MAX_READ) >> 2;\n\tif (o != v) {\n\t\tif (v > o && (dev->bus->bus_flags & PCI_BUS_FLAGS_NO_MMRBC))\n\t\t\treturn -EIO;\n\n\t\tcmd &= ~PCI_X_CMD_MAX_READ;\n\t\tcmd |= v << 2;\n\t\tif (pci_write_config_word(dev, cap + PCI_X_CMD, cmd))\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(pcix_set_mmrbc);\n\n/**\n * pcie_get_readrq - get PCI Express read request size\n * @dev: PCI device to query\n *\n * Returns maximum memory read request in bytes or appropriate error value.\n */\nint pcie_get_readrq(struct pci_dev *dev)\n{\n\tu16 ctl;\n\n\tpcie_capability_read_word(dev, PCI_EXP_DEVCTL, &ctl);\n\n\treturn 128 << ((ctl & PCI_EXP_DEVCTL_READRQ) >> 12);\n}\nEXPORT_SYMBOL(pcie_get_readrq);\n\n/**\n * pcie_set_readrq - set PCI Express maximum memory read request\n * @dev: PCI device to query\n * @rq: maximum memory read count in bytes\n *    valid values are 128, 256, 512, 1024, 2048, 4096\n *\n * If possible sets maximum memory read request in bytes\n */\nint pcie_set_readrq(struct pci_dev *dev, int rq)\n{\n\tu16 v;\n\tint ret;\n\n\tif (rq < 128 || rq > 4096 || !is_power_of_2(rq))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If using the \"performance\" PCIe config, we clamp the read rq\n\t * size to the max packet size to keep the host bridge from\n\t * generating requests larger than we can cope with.\n\t */\n\tif (pcie_bus_config == PCIE_BUS_PERFORMANCE) {\n\t\tint mps = pcie_get_mps(dev);\n\n\t\tif (mps < rq)\n\t\t\trq = mps;\n\t}\n\n\tv = (ffs(rq) - 8) << 12;\n\n\tret = pcie_capability_clear_and_set_word(dev, PCI_EXP_DEVCTL,\n\t\t\t\t\t\t  PCI_EXP_DEVCTL_READRQ, v);\n\n\treturn pcibios_err_to_errno(ret);\n}\nEXPORT_SYMBOL(pcie_set_readrq);\n\n/**\n * pcie_get_mps - get PCI Express maximum payload size\n * @dev: PCI device to query\n *\n * Returns maximum payload size in bytes\n */\nint pcie_get_mps(struct pci_dev *dev)\n{\n\tu16 ctl;\n\n\tpcie_capability_read_word(dev, PCI_EXP_DEVCTL, &ctl);\n\n\treturn 128 << ((ctl & PCI_EXP_DEVCTL_PAYLOAD) >> 5);\n}\nEXPORT_SYMBOL(pcie_get_mps);\n\n/**\n * pcie_set_mps - set PCI Express maximum payload size\n * @dev: PCI device to query\n * @mps: maximum payload size in bytes\n *    valid values are 128, 256, 512, 1024, 2048, 4096\n *\n * If possible sets maximum payload size\n */\nint pcie_set_mps(struct pci_dev *dev, int mps)\n{\n\tu16 v;\n\tint ret;\n\n\tif (mps < 128 || mps > 4096 || !is_power_of_2(mps))\n\t\treturn -EINVAL;\n\n\tv = ffs(mps) - 8;\n\tif (v > dev->pcie_mpss)\n\t\treturn -EINVAL;\n\tv <<= 5;\n\n\tret = pcie_capability_clear_and_set_word(dev, PCI_EXP_DEVCTL,\n\t\t\t\t\t\t  PCI_EXP_DEVCTL_PAYLOAD, v);\n\n\treturn pcibios_err_to_errno(ret);\n}\nEXPORT_SYMBOL(pcie_set_mps);\n\n/**\n * pcie_bandwidth_available - determine minimum link settings of a PCIe\n *\t\t\t      device and its bandwidth limitation\n * @dev: PCI device to query\n * @limiting_dev: storage for device causing the bandwidth limitation\n * @speed: storage for speed of limiting device\n * @width: storage for width of limiting device\n *\n * Walk up the PCI device chain and find the point where the minimum\n * bandwidth is available.  Return the bandwidth available there and (if\n * limiting_dev, speed, and width pointers are supplied) information about\n * that point.  The bandwidth returned is in Mb/s, i.e., megabits/second of\n * raw bandwidth.\n */\nu32 pcie_bandwidth_available(struct pci_dev *dev, struct pci_dev **limiting_dev,\n\t\t\t     enum pci_bus_speed *speed,\n\t\t\t     enum pcie_link_width *width)\n{\n\tu16 lnksta;\n\tenum pci_bus_speed next_speed;\n\tenum pcie_link_width next_width;\n\tu32 bw, next_bw;\n\n\tif (speed)\n\t\t*speed = PCI_SPEED_UNKNOWN;\n\tif (width)\n\t\t*width = PCIE_LNK_WIDTH_UNKNOWN;\n\n\tbw = 0;\n\n\twhile (dev) {\n\t\tpcie_capability_read_word(dev, PCI_EXP_LNKSTA, &lnksta);\n\n\t\tnext_speed = pcie_link_speed[lnksta & PCI_EXP_LNKSTA_CLS];\n\t\tnext_width = (lnksta & PCI_EXP_LNKSTA_NLW) >>\n\t\t\tPCI_EXP_LNKSTA_NLW_SHIFT;\n\n\t\tnext_bw = next_width * PCIE_SPEED2MBS_ENC(next_speed);\n\n\t\t/* Check if current device limits the total bandwidth */\n\t\tif (!bw || next_bw <= bw) {\n\t\t\tbw = next_bw;\n\n\t\t\tif (limiting_dev)\n\t\t\t\t*limiting_dev = dev;\n\t\t\tif (speed)\n\t\t\t\t*speed = next_speed;\n\t\t\tif (width)\n\t\t\t\t*width = next_width;\n\t\t}\n\n\t\tdev = pci_upstream_bridge(dev);\n\t}\n\n\treturn bw;\n}\nEXPORT_SYMBOL(pcie_bandwidth_available);\n\n/**\n * pcie_get_speed_cap - query for the PCI device's link speed capability\n * @dev: PCI device to query\n *\n * Query the PCI device speed capability.  Return the maximum link speed\n * supported by the device.\n */\nenum pci_bus_speed pcie_get_speed_cap(struct pci_dev *dev)\n{\n\tu32 lnkcap2, lnkcap;\n\n\t/*\n\t * Link Capabilities 2 was added in PCIe r3.0, sec 7.8.18.  The\n\t * implementation note there recommends using the Supported Link\n\t * Speeds Vector in Link Capabilities 2 when supported.\n\t *\n\t * Without Link Capabilities 2, i.e., prior to PCIe r3.0, software\n\t * should use the Supported Link Speeds field in Link Capabilities,\n\t * where only 2.5 GT/s and 5.0 GT/s speeds were defined.\n\t */\n\tpcie_capability_read_dword(dev, PCI_EXP_LNKCAP2, &lnkcap2);\n\n\t/* PCIe r3.0-compliant */\n\tif (lnkcap2)\n\t\treturn PCIE_LNKCAP2_SLS2SPEED(lnkcap2);\n\n\tpcie_capability_read_dword(dev, PCI_EXP_LNKCAP, &lnkcap);\n\tif ((lnkcap & PCI_EXP_LNKCAP_SLS) == PCI_EXP_LNKCAP_SLS_5_0GB)\n\t\treturn PCIE_SPEED_5_0GT;\n\telse if ((lnkcap & PCI_EXP_LNKCAP_SLS) == PCI_EXP_LNKCAP_SLS_2_5GB)\n\t\treturn PCIE_SPEED_2_5GT;\n\n\treturn PCI_SPEED_UNKNOWN;\n}\nEXPORT_SYMBOL(pcie_get_speed_cap);\n\n/**\n * pcie_get_width_cap - query for the PCI device's link width capability\n * @dev: PCI device to query\n *\n * Query the PCI device width capability.  Return the maximum link width\n * supported by the device.\n */\nenum pcie_link_width pcie_get_width_cap(struct pci_dev *dev)\n{\n\tu32 lnkcap;\n\n\tpcie_capability_read_dword(dev, PCI_EXP_LNKCAP, &lnkcap);\n\tif (lnkcap)\n\t\treturn (lnkcap & PCI_EXP_LNKCAP_MLW) >> 4;\n\n\treturn PCIE_LNK_WIDTH_UNKNOWN;\n}\nEXPORT_SYMBOL(pcie_get_width_cap);\n\n/**\n * pcie_bandwidth_capable - calculate a PCI device's link bandwidth capability\n * @dev: PCI device\n * @speed: storage for link speed\n * @width: storage for link width\n *\n * Calculate a PCI device's link bandwidth by querying for its link speed\n * and width, multiplying them, and applying encoding overhead.  The result\n * is in Mb/s, i.e., megabits/second of raw bandwidth.\n */\nu32 pcie_bandwidth_capable(struct pci_dev *dev, enum pci_bus_speed *speed,\n\t\t\t   enum pcie_link_width *width)\n{\n\t*speed = pcie_get_speed_cap(dev);\n\t*width = pcie_get_width_cap(dev);\n\n\tif (*speed == PCI_SPEED_UNKNOWN || *width == PCIE_LNK_WIDTH_UNKNOWN)\n\t\treturn 0;\n\n\treturn *width * PCIE_SPEED2MBS_ENC(*speed);\n}\n\n/**\n * __pcie_print_link_status - Report the PCI device's link speed and width\n * @dev: PCI device to query\n * @verbose: Print info even when enough bandwidth is available\n *\n * If the available bandwidth at the device is less than the device is\n * capable of, report the device's maximum possible bandwidth and the\n * upstream link that limits its performance.  If @verbose, always print\n * the available bandwidth, even if the device isn't constrained.\n */\nvoid __pcie_print_link_status(struct pci_dev *dev, bool verbose)\n{\n\tenum pcie_link_width width, width_cap;\n\tenum pci_bus_speed speed, speed_cap;\n\tstruct pci_dev *limiting_dev = NULL;\n\tu32 bw_avail, bw_cap;\n\n\tbw_cap = pcie_bandwidth_capable(dev, &speed_cap, &width_cap);\n\tbw_avail = pcie_bandwidth_available(dev, &limiting_dev, &speed, &width);\n\n\tif (bw_avail >= bw_cap && verbose)\n\t\tpci_info(dev, \"%u.%03u Gb/s available PCIe bandwidth (%s x%d link)\\n\",\n\t\t\t bw_cap / 1000, bw_cap % 1000,\n\t\t\t pci_speed_string(speed_cap), width_cap);\n\telse if (bw_avail < bw_cap)\n\t\tpci_info(dev, \"%u.%03u Gb/s available PCIe bandwidth, limited by %s x%d link at %s (capable of %u.%03u Gb/s with %s x%d link)\\n\",\n\t\t\t bw_avail / 1000, bw_avail % 1000,\n\t\t\t pci_speed_string(speed), width,\n\t\t\t limiting_dev ? pci_name(limiting_dev) : \"<unknown>\",\n\t\t\t bw_cap / 1000, bw_cap % 1000,\n\t\t\t pci_speed_string(speed_cap), width_cap);\n}\n\n/**\n * pcie_print_link_status - Report the PCI device's link speed and width\n * @dev: PCI device to query\n *\n * Report the available bandwidth at the device.\n */\nvoid pcie_print_link_status(struct pci_dev *dev)\n{\n\t__pcie_print_link_status(dev, true);\n}\nEXPORT_SYMBOL(pcie_print_link_status);\n\n/**\n * pci_select_bars - Make BAR mask from the type of resource\n * @dev: the PCI device for which BAR mask is made\n * @flags: resource type mask to be selected\n *\n * This helper routine makes bar mask from the type of resource.\n */\nint pci_select_bars(struct pci_dev *dev, unsigned long flags)\n{\n\tint i, bars = 0;\n\tfor (i = 0; i < PCI_NUM_RESOURCES; i++)\n\t\tif (pci_resource_flags(dev, i) & flags)\n\t\t\tbars |= (1 << i);\n\treturn bars;\n}\nEXPORT_SYMBOL(pci_select_bars);\n\n/* Some architectures require additional programming to enable VGA */\nstatic arch_set_vga_state_t arch_set_vga_state;\n\nvoid __init pci_register_set_vga_state(arch_set_vga_state_t func)\n{\n\tarch_set_vga_state = func;\t/* NULL disables */\n}\n\nstatic int pci_set_vga_state_arch(struct pci_dev *dev, bool decode,\n\t\t\t\t  unsigned int command_bits, u32 flags)\n{\n\tif (arch_set_vga_state)\n\t\treturn arch_set_vga_state(dev, decode, command_bits,\n\t\t\t\t\t\tflags);\n\treturn 0;\n}\n\n/**\n * pci_set_vga_state - set VGA decode state on device and parents if requested\n * @dev: the PCI device\n * @decode: true = enable decoding, false = disable decoding\n * @command_bits: PCI_COMMAND_IO and/or PCI_COMMAND_MEMORY\n * @flags: traverse ancestors and change bridges\n * CHANGE_BRIDGE_ONLY / CHANGE_BRIDGE\n */\nint pci_set_vga_state(struct pci_dev *dev, bool decode,\n\t\t      unsigned int command_bits, u32 flags)\n{\n\tstruct pci_bus *bus;\n\tstruct pci_dev *bridge;\n\tu16 cmd;\n\tint rc;\n\n\tWARN_ON((flags & PCI_VGA_STATE_CHANGE_DECODES) && (command_bits & ~(PCI_COMMAND_IO|PCI_COMMAND_MEMORY)));\n\n\t/* ARCH specific VGA enables */\n\trc = pci_set_vga_state_arch(dev, decode, command_bits, flags);\n\tif (rc)\n\t\treturn rc;\n\n\tif (flags & PCI_VGA_STATE_CHANGE_DECODES) {\n\t\tpci_read_config_word(dev, PCI_COMMAND, &cmd);\n\t\tif (decode)\n\t\t\tcmd |= command_bits;\n\t\telse\n\t\t\tcmd &= ~command_bits;\n\t\tpci_write_config_word(dev, PCI_COMMAND, cmd);\n\t}\n\n\tif (!(flags & PCI_VGA_STATE_CHANGE_BRIDGE))\n\t\treturn 0;\n\n\tbus = dev->bus;\n\twhile (bus) {\n\t\tbridge = bus->self;\n\t\tif (bridge) {\n\t\t\tpci_read_config_word(bridge, PCI_BRIDGE_CONTROL,\n\t\t\t\t\t     &cmd);\n\t\t\tif (decode)\n\t\t\t\tcmd |= PCI_BRIDGE_CTL_VGA;\n\t\t\telse\n\t\t\t\tcmd &= ~PCI_BRIDGE_CTL_VGA;\n\t\t\tpci_write_config_word(bridge, PCI_BRIDGE_CONTROL,\n\t\t\t\t\t      cmd);\n\t\t}\n\t\tbus = bus->parent;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nbool pci_pr3_present(struct pci_dev *pdev)\n{\n\tstruct acpi_device *adev;\n\n\tif (acpi_disabled)\n\t\treturn false;\n\n\tadev = ACPI_COMPANION(&pdev->dev);\n\tif (!adev)\n\t\treturn false;\n\n\treturn adev->power.flags.power_resources &&\n\t\tacpi_has_method(adev->handle, \"_PR3\");\n}\nEXPORT_SYMBOL_GPL(pci_pr3_present);\n#endif\n\n/**\n * pci_add_dma_alias - Add a DMA devfn alias for a device\n * @dev: the PCI device for which alias is added\n * @devfn_from: alias slot and function\n * @nr_devfns: number of subsequent devfns to alias\n *\n * This helper encodes an 8-bit devfn as a bit number in dma_alias_mask\n * which is used to program permissible bus-devfn source addresses for DMA\n * requests in an IOMMU.  These aliases factor into IOMMU group creation\n * and are useful for devices generating DMA requests beyond or different\n * from their logical bus-devfn.  Examples include device quirks where the\n * device simply uses the wrong devfn, as well as non-transparent bridges\n * where the alias may be a proxy for devices in another domain.\n *\n * IOMMU group creation is performed during device discovery or addition,\n * prior to any potential DMA mapping and therefore prior to driver probing\n * (especially for userspace assigned devices where IOMMU group definition\n * cannot be left as a userspace activity).  DMA aliases should therefore\n * be configured via quirks, such as the PCI fixup header quirk.\n */\nvoid pci_add_dma_alias(struct pci_dev *dev, u8 devfn_from, unsigned nr_devfns)\n{\n\tint devfn_to;\n\n\tnr_devfns = min(nr_devfns, (unsigned) MAX_NR_DEVFNS - devfn_from);\n\tdevfn_to = devfn_from + nr_devfns - 1;\n\n\tif (!dev->dma_alias_mask)\n\t\tdev->dma_alias_mask = bitmap_zalloc(MAX_NR_DEVFNS, GFP_KERNEL);\n\tif (!dev->dma_alias_mask) {\n\t\tpci_warn(dev, \"Unable to allocate DMA alias mask\\n\");\n\t\treturn;\n\t}\n\n\tbitmap_set(dev->dma_alias_mask, devfn_from, nr_devfns);\n\n\tif (nr_devfns == 1)\n\t\tpci_info(dev, \"Enabling fixed DMA alias to %02x.%d\\n\",\n\t\t\t\tPCI_SLOT(devfn_from), PCI_FUNC(devfn_from));\n\telse if (nr_devfns > 1)\n\t\tpci_info(dev, \"Enabling fixed DMA alias for devfn range from %02x.%d to %02x.%d\\n\",\n\t\t\t\tPCI_SLOT(devfn_from), PCI_FUNC(devfn_from),\n\t\t\t\tPCI_SLOT(devfn_to), PCI_FUNC(devfn_to));\n}\n\nbool pci_devs_are_dma_aliases(struct pci_dev *dev1, struct pci_dev *dev2)\n{\n\treturn (dev1->dma_alias_mask &&\n\t\ttest_bit(dev2->devfn, dev1->dma_alias_mask)) ||\n\t       (dev2->dma_alias_mask &&\n\t\ttest_bit(dev1->devfn, dev2->dma_alias_mask)) ||\n\t       pci_real_dma_dev(dev1) == dev2 ||\n\t       pci_real_dma_dev(dev2) == dev1;\n}\n\nbool pci_device_is_present(struct pci_dev *pdev)\n{\n\tu32 v;\n\n\tif (pci_dev_is_disconnected(pdev))\n\t\treturn false;\n\treturn pci_bus_read_dev_vendor_id(pdev->bus, pdev->devfn, &v, 0);\n}\nEXPORT_SYMBOL_GPL(pci_device_is_present);\n\nvoid pci_ignore_hotplug(struct pci_dev *dev)\n{\n\tstruct pci_dev *bridge = dev->bus->self;\n\n\tdev->ignore_hotplug = 1;\n\t/* Propagate the \"ignore hotplug\" setting to the parent bridge. */\n\tif (bridge)\n\t\tbridge->ignore_hotplug = 1;\n}\nEXPORT_SYMBOL_GPL(pci_ignore_hotplug);\n\n/**\n * pci_real_dma_dev - Get PCI DMA device for PCI device\n * @dev: the PCI device that may have a PCI DMA alias\n *\n * Permits the platform to provide architecture-specific functionality to\n * devices needing to alias DMA to another PCI device on another PCI bus. If\n * the PCI device is on the same bus, it is recommended to use\n * pci_add_dma_alias(). This is the default implementation. Architecture\n * implementations can override this.\n */\nstruct pci_dev __weak *pci_real_dma_dev(struct pci_dev *dev)\n{\n\treturn dev;\n}\n\nresource_size_t __weak pcibios_default_alignment(void)\n{\n\treturn 0;\n}\n\n/*\n * Arches that don't want to expose struct resource to userland as-is in\n * sysfs and /proc can implement their own pci_resource_to_user().\n */\nvoid __weak pci_resource_to_user(const struct pci_dev *dev, int bar,\n\t\t\t\t const struct resource *rsrc,\n\t\t\t\t resource_size_t *start, resource_size_t *end)\n{\n\t*start = rsrc->start;\n\t*end = rsrc->end;\n}\n\nstatic char *resource_alignment_param;\nstatic DEFINE_SPINLOCK(resource_alignment_lock);\n\n/**\n * pci_specified_resource_alignment - get resource alignment specified by user.\n * @dev: the PCI device to get\n * @resize: whether or not to change resources' size when reassigning alignment\n *\n * RETURNS: Resource alignment if it is specified.\n *          Zero if it is not specified.\n */\nstatic resource_size_t pci_specified_resource_alignment(struct pci_dev *dev,\n\t\t\t\t\t\t\tbool *resize)\n{\n\tint align_order, count;\n\tresource_size_t align = pcibios_default_alignment();\n\tconst char *p;\n\tint ret;\n\n\tspin_lock(&resource_alignment_lock);\n\tp = resource_alignment_param;\n\tif (!p || !*p)\n\t\tgoto out;\n\tif (pci_has_flag(PCI_PROBE_ONLY)) {\n\t\talign = 0;\n\t\tpr_info_once(\"PCI: Ignoring requested alignments (PCI_PROBE_ONLY)\\n\");\n\t\tgoto out;\n\t}\n\n\twhile (*p) {\n\t\tcount = 0;\n\t\tif (sscanf(p, \"%d%n\", &align_order, &count) == 1 &&\n\t\t\t\t\t\t\tp[count] == '@') {\n\t\t\tp += count + 1;\n\t\t} else {\n\t\t\talign_order = -1;\n\t\t}\n\n\t\tret = pci_dev_str_match(dev, p, &p);\n\t\tif (ret == 1) {\n\t\t\t*resize = true;\n\t\t\tif (align_order == -1)\n\t\t\t\talign = PAGE_SIZE;\n\t\t\telse\n\t\t\t\talign = 1 << align_order;\n\t\t\tbreak;\n\t\t} else if (ret < 0) {\n\t\t\tpr_err(\"PCI: Can't parse resource_alignment parameter: %s\\n\",\n\t\t\t       p);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p != ';' && *p != ',') {\n\t\t\t/* End of param or invalid format */\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\nout:\n\tspin_unlock(&resource_alignment_lock);\n\treturn align;\n}\n\nstatic void pci_request_resource_alignment(struct pci_dev *dev, int bar,\n\t\t\t\t\t   resource_size_t align, bool resize)\n{\n\tstruct resource *r = &dev->resource[bar];\n\tresource_size_t size;\n\n\tif (!(r->flags & IORESOURCE_MEM))\n\t\treturn;\n\n\tif (r->flags & IORESOURCE_PCI_FIXED) {\n\t\tpci_info(dev, \"BAR%d %pR: ignoring requested alignment %#llx\\n\",\n\t\t\t bar, r, (unsigned long long)align);\n\t\treturn;\n\t}\n\n\tsize = resource_size(r);\n\tif (size >= align)\n\t\treturn;\n\n\t/*\n\t * Increase the alignment of the resource.  There are two ways we\n\t * can do this:\n\t *\n\t * 1) Increase the size of the resource.  BARs are aligned on their\n\t *    size, so when we reallocate space for this resource, we'll\n\t *    allocate it with the larger alignment.  This also prevents\n\t *    assignment of any other BARs inside the alignment region, so\n\t *    if we're requesting page alignment, this means no other BARs\n\t *    will share the page.\n\t *\n\t *    The disadvantage is that this makes the resource larger than\n\t *    the hardware BAR, which may break drivers that compute things\n\t *    based on the resource size, e.g., to find registers at a\n\t *    fixed offset before the end of the BAR.\n\t *\n\t * 2) Retain the resource size, but use IORESOURCE_STARTALIGN and\n\t *    set r->start to the desired alignment.  By itself this\n\t *    doesn't prevent other BARs being put inside the alignment\n\t *    region, but if we realign *every* resource of every device in\n\t *    the system, none of them will share an alignment region.\n\t *\n\t * When the user has requested alignment for only some devices via\n\t * the \"pci=resource_alignment\" argument, \"resize\" is true and we\n\t * use the first method.  Otherwise we assume we're aligning all\n\t * devices and we use the second.\n\t */\n\n\tpci_info(dev, \"BAR%d %pR: requesting alignment to %#llx\\n\",\n\t\t bar, r, (unsigned long long)align);\n\n\tif (resize) {\n\t\tr->start = 0;\n\t\tr->end = align - 1;\n\t} else {\n\t\tr->flags &= ~IORESOURCE_SIZEALIGN;\n\t\tr->flags |= IORESOURCE_STARTALIGN;\n\t\tr->start = align;\n\t\tr->end = r->start + size - 1;\n\t}\n\tr->flags |= IORESOURCE_UNSET;\n}\n\n/*\n * This function disables memory decoding and releases memory resources\n * of the device specified by kernel's boot parameter 'pci=resource_alignment='.\n * It also rounds up size to specified alignment.\n * Later on, the kernel will assign page-aligned memory resource back\n * to the device.\n */\nvoid pci_reassigndev_resource_alignment(struct pci_dev *dev)\n{\n\tint i;\n\tstruct resource *r;\n\tresource_size_t align;\n\tu16 command;\n\tbool resize = false;\n\n\t/*\n\t * VF BARs are read-only zero according to SR-IOV spec r1.1, sec\n\t * 3.4.1.11.  Their resources are allocated from the space\n\t * described by the VF BARx register in the PF's SR-IOV capability.\n\t * We can't influence their alignment here.\n\t */\n\tif (dev->is_virtfn)\n\t\treturn;\n\n\t/* check if specified PCI is target device to reassign */\n\talign = pci_specified_resource_alignment(dev, &resize);\n\tif (!align)\n\t\treturn;\n\n\tif (dev->hdr_type == PCI_HEADER_TYPE_NORMAL &&\n\t    (dev->class >> 8) == PCI_CLASS_BRIDGE_HOST) {\n\t\tpci_warn(dev, \"Can't reassign resources to host bridge\\n\");\n\t\treturn;\n\t}\n\n\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\tcommand &= ~PCI_COMMAND_MEMORY;\n\tpci_write_config_word(dev, PCI_COMMAND, command);\n\n\tfor (i = 0; i <= PCI_ROM_RESOURCE; i++)\n\t\tpci_request_resource_alignment(dev, i, align, resize);\n\n\t/*\n\t * Need to disable bridge's resource window,\n\t * to enable the kernel to reassign new resource\n\t * window later on.\n\t */\n\tif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\t\tfor (i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++) {\n\t\t\tr = &dev->resource[i];\n\t\t\tif (!(r->flags & IORESOURCE_MEM))\n\t\t\t\tcontinue;\n\t\t\tr->flags |= IORESOURCE_UNSET;\n\t\t\tr->end = resource_size(r) - 1;\n\t\t\tr->start = 0;\n\t\t}\n\t\tpci_disable_bridge_window(dev);\n\t}\n}\n\nstatic ssize_t resource_alignment_show(struct bus_type *bus, char *buf)\n{\n\tsize_t count = 0;\n\n\tspin_lock(&resource_alignment_lock);\n\tif (resource_alignment_param)\n\t\tcount = scnprintf(buf, PAGE_SIZE, \"%s\", resource_alignment_param);\n\tspin_unlock(&resource_alignment_lock);\n\n\t/*\n\t * When set by the command line, resource_alignment_param will not\n\t * have a trailing line feed, which is ugly. So conditionally add\n\t * it here.\n\t */\n\tif (count >= 2 && buf[count - 2] != '\\n' && count < PAGE_SIZE - 1) {\n\t\tbuf[count - 1] = '\\n';\n\t\tbuf[count++] = 0;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t resource_alignment_store(struct bus_type *bus,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tchar *param = kstrndup(buf, count, GFP_KERNEL);\n\n\tif (!param)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&resource_alignment_lock);\n\tkfree(resource_alignment_param);\n\tresource_alignment_param = param;\n\tspin_unlock(&resource_alignment_lock);\n\treturn count;\n}\n\nstatic BUS_ATTR_RW(resource_alignment);\n\nstatic int __init pci_resource_alignment_sysfs_init(void)\n{\n\treturn bus_create_file(&pci_bus_type,\n\t\t\t\t\t&bus_attr_resource_alignment);\n}\nlate_initcall(pci_resource_alignment_sysfs_init);\n\nstatic void pci_no_domains(void)\n{\n#ifdef CONFIG_PCI_DOMAINS\n\tpci_domains_supported = 0;\n#endif\n}\n\n#ifdef CONFIG_PCI_DOMAINS_GENERIC\nstatic atomic_t __domain_nr = ATOMIC_INIT(-1);\n\nstatic int pci_get_new_domain_nr(void)\n{\n\treturn atomic_inc_return(&__domain_nr);\n}\n\nstatic int of_pci_bus_find_domain_nr(struct device *parent)\n{\n\tstatic int use_dt_domains = -1;\n\tint domain = -1;\n\n\tif (parent)\n\t\tdomain = of_get_pci_domain_nr(parent->of_node);\n\n\t/*\n\t * Check DT domain and use_dt_domains values.\n\t *\n\t * If DT domain property is valid (domain >= 0) and\n\t * use_dt_domains != 0, the DT assignment is valid since this means\n\t * we have not previously allocated a domain number by using\n\t * pci_get_new_domain_nr(); we should also update use_dt_domains to\n\t * 1, to indicate that we have just assigned a domain number from\n\t * DT.\n\t *\n\t * If DT domain property value is not valid (ie domain < 0), and we\n\t * have not previously assigned a domain number from DT\n\t * (use_dt_domains != 1) we should assign a domain number by\n\t * using the:\n\t *\n\t * pci_get_new_domain_nr()\n\t *\n\t * API and update the use_dt_domains value to keep track of method we\n\t * are using to assign domain numbers (use_dt_domains = 0).\n\t *\n\t * All other combinations imply we have a platform that is trying\n\t * to mix domain numbers obtained from DT and pci_get_new_domain_nr(),\n\t * which is a recipe for domain mishandling and it is prevented by\n\t * invalidating the domain value (domain = -1) and printing a\n\t * corresponding error.\n\t */\n\tif (domain >= 0 && use_dt_domains) {\n\t\tuse_dt_domains = 1;\n\t} else if (domain < 0 && use_dt_domains != 1) {\n\t\tuse_dt_domains = 0;\n\t\tdomain = pci_get_new_domain_nr();\n\t} else {\n\t\tif (parent)\n\t\t\tpr_err(\"Node %pOF has \", parent->of_node);\n\t\tpr_err(\"Inconsistent \\\"linux,pci-domain\\\" property in DT\\n\");\n\t\tdomain = -1;\n\t}\n\n\treturn domain;\n}\n\nint pci_bus_find_domain_nr(struct pci_bus *bus, struct device *parent)\n{\n\treturn acpi_disabled ? of_pci_bus_find_domain_nr(parent) :\n\t\t\t       acpi_pci_bus_find_domain_nr(bus);\n}\n#endif\n\n/**\n * pci_ext_cfg_avail - can we access extended PCI config space?\n *\n * Returns 1 if we can access PCI extended config space (offsets\n * greater than 0xff). This is the default implementation. Architecture\n * implementations can override this.\n */\nint __weak pci_ext_cfg_avail(void)\n{\n\treturn 1;\n}\n\nvoid __weak pci_fixup_cardbus(struct pci_bus *bus)\n{\n}\nEXPORT_SYMBOL(pci_fixup_cardbus);\n\nstatic int __init pci_setup(char *str)\n{\n\twhile (str) {\n\t\tchar *k = strchr(str, ',');\n\t\tif (k)\n\t\t\t*k++ = 0;\n\t\tif (*str && (str = pcibios_setup(str)) && *str) {\n\t\t\tif (!strcmp(str, \"nomsi\")) {\n\t\t\t\tpci_no_msi();\n\t\t\t} else if (!strncmp(str, \"noats\", 5)) {\n\t\t\t\tpr_info(\"PCIe: ATS is disabled\\n\");\n\t\t\t\tpcie_ats_disabled = true;\n\t\t\t} else if (!strcmp(str, \"noaer\")) {\n\t\t\t\tpci_no_aer();\n\t\t\t} else if (!strcmp(str, \"earlydump\")) {\n\t\t\t\tpci_early_dump = true;\n\t\t\t} else if (!strncmp(str, \"realloc=\", 8)) {\n\t\t\t\tpci_realloc_get_opt(str + 8);\n\t\t\t} else if (!strncmp(str, \"realloc\", 7)) {\n\t\t\t\tpci_realloc_get_opt(\"on\");\n\t\t\t} else if (!strcmp(str, \"nodomains\")) {\n\t\t\t\tpci_no_domains();\n\t\t\t} else if (!strncmp(str, \"noari\", 5)) {\n\t\t\t\tpcie_ari_disabled = true;\n\t\t\t} else if (!strncmp(str, \"cbiosize=\", 9)) {\n\t\t\t\tpci_cardbus_io_size = memparse(str + 9, &str);\n\t\t\t} else if (!strncmp(str, \"cbmemsize=\", 10)) {\n\t\t\t\tpci_cardbus_mem_size = memparse(str + 10, &str);\n\t\t\t} else if (!strncmp(str, \"resource_alignment=\", 19)) {\n\t\t\t\tresource_alignment_param = str + 19;\n\t\t\t} else if (!strncmp(str, \"ecrc=\", 5)) {\n\t\t\t\tpcie_ecrc_get_policy(str + 5);\n\t\t\t} else if (!strncmp(str, \"hpiosize=\", 9)) {\n\t\t\t\tpci_hotplug_io_size = memparse(str + 9, &str);\n\t\t\t} else if (!strncmp(str, \"hpmmiosize=\", 11)) {\n\t\t\t\tpci_hotplug_mmio_size = memparse(str + 11, &str);\n\t\t\t} else if (!strncmp(str, \"hpmmioprefsize=\", 15)) {\n\t\t\t\tpci_hotplug_mmio_pref_size = memparse(str + 15, &str);\n\t\t\t} else if (!strncmp(str, \"hpmemsize=\", 10)) {\n\t\t\t\tpci_hotplug_mmio_size = memparse(str + 10, &str);\n\t\t\t\tpci_hotplug_mmio_pref_size = pci_hotplug_mmio_size;\n\t\t\t} else if (!strncmp(str, \"hpbussize=\", 10)) {\n\t\t\t\tpci_hotplug_bus_size =\n\t\t\t\t\tsimple_strtoul(str + 10, &str, 0);\n\t\t\t\tif (pci_hotplug_bus_size > 0xff)\n\t\t\t\t\tpci_hotplug_bus_size = DEFAULT_HOTPLUG_BUS_SIZE;\n\t\t\t} else if (!strncmp(str, \"pcie_bus_tune_off\", 17)) {\n\t\t\t\tpcie_bus_config = PCIE_BUS_TUNE_OFF;\n\t\t\t} else if (!strncmp(str, \"pcie_bus_safe\", 13)) {\n\t\t\t\tpcie_bus_config = PCIE_BUS_SAFE;\n\t\t\t} else if (!strncmp(str, \"pcie_bus_perf\", 13)) {\n\t\t\t\tpcie_bus_config = PCIE_BUS_PERFORMANCE;\n\t\t\t} else if (!strncmp(str, \"pcie_bus_peer2peer\", 18)) {\n\t\t\t\tpcie_bus_config = PCIE_BUS_PEER2PEER;\n\t\t\t} else if (!strncmp(str, \"pcie_scan_all\", 13)) {\n\t\t\t\tpci_add_flags(PCI_SCAN_ALL_PCIE_DEVS);\n\t\t\t} else if (!strncmp(str, \"disable_acs_redir=\", 18)) {\n\t\t\t\tdisable_acs_redir_param = str + 18;\n\t\t\t} else {\n\t\t\t\tpr_err(\"PCI: Unknown option `%s'\\n\", str);\n\t\t\t}\n\t\t}\n\t\tstr = k;\n\t}\n\treturn 0;\n}\nearly_param(\"pci\", pci_setup);\n\n/*\n * 'resource_alignment_param' and 'disable_acs_redir_param' are initialized\n * in pci_setup(), above, to point to data in the __initdata section which\n * will be freed after the init sequence is complete. We can't allocate memory\n * in pci_setup() because some architectures do not have any memory allocation\n * service available during an early_param() call. So we allocate memory and\n * copy the variable here before the init section is freed.\n *\n */\nstatic int __init pci_realloc_setup_params(void)\n{\n\tresource_alignment_param = kstrdup(resource_alignment_param,\n\t\t\t\t\t   GFP_KERNEL);\n\tdisable_acs_redir_param = kstrdup(disable_acs_redir_param, GFP_KERNEL);\n\n\treturn 0;\n}\npure_initcall(pci_realloc_setup_params);\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 6212}, "message": "warn: should '1 << align_order' be a 64 bit type?"}], "macros": [], "notes": [], "path": "/src/drivers/pci/pci.c", "reportHash": "780958012125e36714b1e94722886add", "checkerName": "check_64bit_shift", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
