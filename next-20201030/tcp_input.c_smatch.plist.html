<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/net/ipv4/tcp_input.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tImplementation of the Transmission Control Protocol(TCP).\n *\n * Authors:\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\t\tMark Evans, <evansmp@uhura.aston.ac.uk>\n *\t\tCorey Minyard <wf-rch!minyard@relay.EU.net>\n *\t\tFlorian La Roche, <flla@stud.uni-sb.de>\n *\t\tCharles Hedrick, <hedrick@klinzhai.rutgers.edu>\n *\t\tLinus Torvalds, <torvalds@cs.helsinki.fi>\n *\t\tAlan Cox, <gw4pts@gw4pts.ampr.org>\n *\t\tMatthew Dillon, <dillon@apollo.west.oic.com>\n *\t\tArnt Gulbrandsen, <agulbra@nvg.unit.no>\n *\t\tJorge Cwik, <jorge@laser.satlink.net>\n */\n\n/*\n * Changes:\n *\t\tPedro Roque\t:\tFast Retransmit/Recovery.\n *\t\t\t\t\tTwo receive queues.\n *\t\t\t\t\tRetransmit queue handled by TCP.\n *\t\t\t\t\tBetter retransmit timer handling.\n *\t\t\t\t\tNew congestion avoidance.\n *\t\t\t\t\tHeader prediction.\n *\t\t\t\t\tVariable renaming.\n *\n *\t\tEric\t\t:\tFast Retransmit.\n *\t\tRandy Scott\t:\tMSS option defines.\n *\t\tEric Schenk\t:\tFixes to slow start algorithm.\n *\t\tEric Schenk\t:\tYet another double ACK bug.\n *\t\tEric Schenk\t:\tDelayed ACK bug fixes.\n *\t\tEric Schenk\t:\tFloyd style fast retrans war avoidance.\n *\t\tDavid S. Miller\t:\tDon't allow zero congestion window.\n *\t\tEric Schenk\t:\tFix retransmitter so that it sends\n *\t\t\t\t\tnext packet on ack of previous packet.\n *\t\tAndi Kleen\t:\tMoved open_request checking here\n *\t\t\t\t\tand process RSTs for open_requests.\n *\t\tAndi Kleen\t:\tBetter prune_queue, and other fixes.\n *\t\tAndrey Savochkin:\tFix RTT measurements in the presence of\n *\t\t\t\t\ttimestamps.\n *\t\tAndrey Savochkin:\tCheck sequence numbers correctly when\n *\t\t\t\t\tremoving SACKs due to in sequence incoming\n *\t\t\t\t\tdata segments.\n *\t\tAndi Kleen:\t\tMake sure we never ack data there is not\n *\t\t\t\t\tenough room for. Also make this condition\n *\t\t\t\t\ta fatal error if it might still happen.\n *\t\tAndi Kleen:\t\tAdd tcp_measure_rcv_mss to make\n *\t\t\t\t\tconnections with MSS<min(MTU,ann. MSS)\n *\t\t\t\t\twork without delayed acks.\n *\t\tAndi Kleen:\t\tProcess packets with PSH set in the\n *\t\t\t\t\tfast path.\n *\t\tJ Hadi Salim:\t\tECN support\n *\t \tAndrei Gurtov,\n *\t\tPasi Sarolahti,\n *\t\tPanu Kuhlberg:\t\tExperimental audit of TCP (re)transmission\n *\t\t\t\t\tengine. Lots of bugs are found.\n *\t\tPasi Sarolahti:\t\tF-RTO for dealing with spurious RTOs\n */\n\n#define pr_fmt(fmt) \"TCP: \" fmt\n\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/sysctl.h>\n#include <linux/kernel.h>\n#include <linux/prefetch.h>\n#include <net/dst.h>\n#include <net/tcp.h>\n#include <net/inet_common.h>\n#include <linux/ipsec.h>\n#include <asm/unaligned.h>\n#include <linux/errqueue.h>\n#include <trace/events/tcp.h>\n#include <linux/jump_label_ratelimit.h>\n#include <net/busy_poll.h>\n#include <net/mptcp.h>\n\nint sysctl_tcp_max_orphans __read_mostly = NR_FILE;\n\n#define FLAG_DATA\t\t0x01 /* Incoming frame contained data.\t\t*/\n#define FLAG_WIN_UPDATE\t\t0x02 /* Incoming ACK was a window update.\t*/\n#define FLAG_DATA_ACKED\t\t0x04 /* This ACK acknowledged new data.\t\t*/\n#define FLAG_RETRANS_DATA_ACKED\t0x08 /* \"\" \"\" some of which was retransmitted.\t*/\n#define FLAG_SYN_ACKED\t\t0x10 /* This ACK acknowledged SYN.\t\t*/\n#define FLAG_DATA_SACKED\t0x20 /* New SACK.\t\t\t\t*/\n#define FLAG_ECE\t\t0x40 /* ECE in this ACK\t\t\t\t*/\n#define FLAG_LOST_RETRANS\t0x80 /* This ACK marks some retransmission lost */\n#define FLAG_SLOWPATH\t\t0x100 /* Do not skip RFC checks for window update.*/\n#define FLAG_ORIG_SACK_ACKED\t0x200 /* Never retransmitted data are (s)acked\t*/\n#define FLAG_SND_UNA_ADVANCED\t0x400 /* Snd_una was changed (!= FLAG_DATA_ACKED) */\n#define FLAG_DSACKING_ACK\t0x800 /* SACK blocks contained D-SACK info */\n#define FLAG_SET_XMIT_TIMER\t0x1000 /* Set TLP or RTO timer */\n#define FLAG_SACK_RENEGING\t0x2000 /* snd_una advanced to a sacked seq */\n#define FLAG_UPDATE_TS_RECENT\t0x4000 /* tcp_replace_ts_recent() */\n#define FLAG_NO_CHALLENGE_ACK\t0x8000 /* do not call tcp_send_challenge_ack()\t*/\n#define FLAG_ACK_MAYBE_DELAYED\t0x10000 /* Likely a delayed ACK */\n\n#define FLAG_ACKED\t\t(FLAG_DATA_ACKED|FLAG_SYN_ACKED)\n#define FLAG_NOT_DUP\t\t(FLAG_DATA|FLAG_WIN_UPDATE|FLAG_ACKED)\n#define FLAG_CA_ALERT\t\t(FLAG_DATA_SACKED|FLAG_ECE|FLAG_DSACKING_ACK)\n#define FLAG_FORWARD_PROGRESS\t(FLAG_ACKED|FLAG_DATA_SACKED)\n\n#define TCP_REMNANT (TCP_FLAG_FIN|TCP_FLAG_URG|TCP_FLAG_SYN|TCP_FLAG_PSH)\n#define TCP_HP_BITS (~(TCP_RESERVED_BITS|TCP_FLAG_PSH))\n\n#define REXMIT_NONE\t0 /* no loss recovery to do */\n#define REXMIT_LOST\t1 /* retransmit packets marked lost */\n#define REXMIT_NEW\t2 /* FRTO-style transmit of unsent/new packets */\n\n#if IS_ENABLED(CONFIG_TLS_DEVICE)\nstatic DEFINE_STATIC_KEY_DEFERRED_FALSE(clean_acked_data_enabled, HZ);\n\nvoid clean_acked_data_enable(struct inet_connection_sock *icsk,\n\t\t\t     void (*cad)(struct sock *sk, u32 ack_seq))\n{\n\ticsk->icsk_clean_acked = cad;\n\tstatic_branch_deferred_inc(&clean_acked_data_enabled);\n}\nEXPORT_SYMBOL_GPL(clean_acked_data_enable);\n\nvoid clean_acked_data_disable(struct inet_connection_sock *icsk)\n{\n\tstatic_branch_slow_dec_deferred(&clean_acked_data_enabled);\n\ticsk->icsk_clean_acked = NULL;\n}\nEXPORT_SYMBOL_GPL(clean_acked_data_disable);\n\nvoid clean_acked_data_flush(void)\n{\n\tstatic_key_deferred_flush(&clean_acked_data_enabled);\n}\nEXPORT_SYMBOL_GPL(clean_acked_data_flush);\n#endif\n\n#ifdef CONFIG_CGROUP_BPF\nstatic void bpf_skops_parse_hdr(struct sock *sk, struct sk_buff *skb)\n{\n\tbool unknown_opt = tcp_sk(sk)->rx_opt.saw_unknown &&\n\t\tBPF_SOCK_OPS_TEST_FLAG(tcp_sk(sk),\n\t\t\t\t       BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG);\n\tbool parse_all_opt = BPF_SOCK_OPS_TEST_FLAG(tcp_sk(sk),\n\t\t\t\t\t\t    BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG);\n\tstruct bpf_sock_ops_kern sock_ops;\n\n\tif (likely(!unknown_opt && !parse_all_opt))\n\t\treturn;\n\n\t/* The skb will be handled in the\n\t * bpf_skops_established() or\n\t * bpf_skops_write_hdr_opt().\n\t */\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_RECV:\n\tcase TCP_SYN_SENT:\n\tcase TCP_LISTEN:\n\t\treturn;\n\t}\n\n\tsock_owned_by_me(sk);\n\n\tmemset(&sock_ops, 0, offsetof(struct bpf_sock_ops_kern, temp));\n\tsock_ops.op = BPF_SOCK_OPS_PARSE_HDR_OPT_CB;\n\tsock_ops.is_fullsock = 1;\n\tsock_ops.sk = sk;\n\tbpf_skops_init_skb(&sock_ops, skb, tcp_hdrlen(skb));\n\n\tBPF_CGROUP_RUN_PROG_SOCK_OPS(&sock_ops);\n}\n\nstatic void bpf_skops_established(struct sock *sk, int bpf_op,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct bpf_sock_ops_kern sock_ops;\n\n\tsock_owned_by_me(sk);\n\n\tmemset(&sock_ops, 0, offsetof(struct bpf_sock_ops_kern, temp));\n\tsock_ops.op = bpf_op;\n\tsock_ops.is_fullsock = 1;\n\tsock_ops.sk = sk;\n\t/* sk with TCP_REPAIR_ON does not have skb in tcp_finish_connect */\n\tif (skb)\n\t\tbpf_skops_init_skb(&sock_ops, skb, tcp_hdrlen(skb));\n\n\tBPF_CGROUP_RUN_PROG_SOCK_OPS(&sock_ops);\n}\n#else\nstatic void bpf_skops_parse_hdr(struct sock *sk, struct sk_buff *skb)\n{\n}\n\nstatic void bpf_skops_established(struct sock *sk, int bpf_op,\n\t\t\t\t  struct sk_buff *skb)\n{\n}\n#endif\n\nstatic void tcp_gro_dev_warn(struct sock *sk, const struct sk_buff *skb,\n\t\t\t     unsigned int len)\n{\n\tstatic bool __once __read_mostly;\n\n\tif (!__once) {\n\t\tstruct net_device *dev;\n\n\t\t__once = true;\n\n\t\trcu_read_lock();\n\t\tdev = dev_get_by_index_rcu(sock_net(sk), skb->skb_iif);\n\t\tif (!dev || len >= dev->mtu)\n\t\t\tpr_warn(\"%s: Driver has suspect GRO implementation, TCP performance may be compromised.\\n\",\n\t\t\t\tdev ? dev->name : \"Unknown driver\");\n\t\trcu_read_unlock();\n\t}\n}\n\n/* Adapt the MSS value used to make delayed ack decision to the\n * real world.\n */\nstatic void tcp_measure_rcv_mss(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tconst unsigned int lss = icsk->icsk_ack.last_seg_size;\n\tunsigned int len;\n\n\ticsk->icsk_ack.last_seg_size = 0;\n\n\t/* skb->len may jitter because of SACKs, even if peer\n\t * sends good full-sized frames.\n\t */\n\tlen = skb_shinfo(skb)->gso_size ? : skb->len;\n\tif (len >= icsk->icsk_ack.rcv_mss) {\n\t\ticsk->icsk_ack.rcv_mss = min_t(unsigned int, len,\n\t\t\t\t\t       tcp_sk(sk)->advmss);\n\t\t/* Account for possibly-removed options */\n\t\tif (unlikely(len > icsk->icsk_ack.rcv_mss +\n\t\t\t\t   MAX_TCP_OPTION_SPACE))\n\t\t\ttcp_gro_dev_warn(sk, skb, len);\n\t} else {\n\t\t/* Otherwise, we make more careful check taking into account,\n\t\t * that SACKs block is variable.\n\t\t *\n\t\t * \"len\" is invariant segment length, including TCP header.\n\t\t */\n\t\tlen += skb->data - skb_transport_header(skb);\n\t\tif (len >= TCP_MSS_DEFAULT + sizeof(struct tcphdr) ||\n\t\t    /* If PSH is not set, packet should be\n\t\t     * full sized, provided peer TCP is not badly broken.\n\t\t     * This observation (if it is correct 8)) allows\n\t\t     * to handle super-low mtu links fairly.\n\t\t     */\n\t\t    (len >= TCP_MIN_MSS + sizeof(struct tcphdr) &&\n\t\t     !(tcp_flag_word(tcp_hdr(skb)) & TCP_REMNANT))) {\n\t\t\t/* Subtract also invariant (if peer is RFC compliant),\n\t\t\t * tcp header plus fixed timestamp option length.\n\t\t\t * Resulting \"len\" is MSS free of SACK jitter.\n\t\t\t */\n\t\t\tlen -= tcp_sk(sk)->tcp_header_len;\n\t\t\ticsk->icsk_ack.last_seg_size = len;\n\t\t\tif (len == lss) {\n\t\t\t\ticsk->icsk_ack.rcv_mss = len;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (icsk->icsk_ack.pending & ICSK_ACK_PUSHED)\n\t\t\ticsk->icsk_ack.pending |= ICSK_ACK_PUSHED2;\n\t\ticsk->icsk_ack.pending |= ICSK_ACK_PUSHED;\n\t}\n}\n\nstatic void tcp_incr_quickack(struct sock *sk, unsigned int max_quickacks)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tunsigned int quickacks = tcp_sk(sk)->rcv_wnd / (2 * icsk->icsk_ack.rcv_mss);\n\n\tif (quickacks == 0)\n\t\tquickacks = 2;\n\tquickacks = min(quickacks, max_quickacks);\n\tif (quickacks > icsk->icsk_ack.quick)\n\t\ticsk->icsk_ack.quick = quickacks;\n}\n\nvoid tcp_enter_quickack_mode(struct sock *sk, unsigned int max_quickacks)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ttcp_incr_quickack(sk, max_quickacks);\n\tinet_csk_exit_pingpong_mode(sk);\n\ticsk->icsk_ack.ato = TCP_ATO_MIN;\n}\nEXPORT_SYMBOL(tcp_enter_quickack_mode);\n\n/* Send ACKs quickly, if \"quick\" count is not exhausted\n * and the session is not interactive.\n */\n\nstatic bool tcp_in_quickack_mode(struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tconst struct dst_entry *dst = __sk_dst_get(sk);\n\n\treturn (dst && dst_metric(dst, RTAX_QUICKACK)) ||\n\t\t(icsk->icsk_ack.quick && !inet_csk_in_pingpong_mode(sk));\n}\n\nstatic void tcp_ecn_queue_cwr(struct tcp_sock *tp)\n{\n\tif (tp->ecn_flags & TCP_ECN_OK)\n\t\ttp->ecn_flags |= TCP_ECN_QUEUE_CWR;\n}\n\nstatic void tcp_ecn_accept_cwr(struct sock *sk, const struct sk_buff *skb)\n{\n\tif (tcp_hdr(skb)->cwr) {\n\t\ttcp_sk(sk)->ecn_flags &= ~TCP_ECN_DEMAND_CWR;\n\n\t\t/* If the sender is telling us it has entered CWR, then its\n\t\t * cwnd may be very low (even just 1 packet), so we should ACK\n\t\t * immediately.\n\t\t */\n\t\tif (TCP_SKB_CB(skb)->seq != TCP_SKB_CB(skb)->end_seq)\n\t\t\tinet_csk(sk)->icsk_ack.pending |= ICSK_ACK_NOW;\n\t}\n}\n\nstatic void tcp_ecn_withdraw_cwr(struct tcp_sock *tp)\n{\n\ttp->ecn_flags &= ~TCP_ECN_QUEUE_CWR;\n}\n\nstatic void __tcp_ecn_check_ce(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tswitch (TCP_SKB_CB(skb)->ip_dsfield & INET_ECN_MASK) {\n\tcase INET_ECN_NOT_ECT:\n\t\t/* Funny extension: if ECT is not set on a segment,\n\t\t * and we already seen ECT on a previous segment,\n\t\t * it is probably a retransmit.\n\t\t */\n\t\tif (tp->ecn_flags & TCP_ECN_SEEN)\n\t\t\ttcp_enter_quickack_mode(sk, 2);\n\t\tbreak;\n\tcase INET_ECN_CE:\n\t\tif (tcp_ca_needs_ecn(sk))\n\t\t\ttcp_ca_event(sk, CA_EVENT_ECN_IS_CE);\n\n\t\tif (!(tp->ecn_flags & TCP_ECN_DEMAND_CWR)) {\n\t\t\t/* Better not delay acks, sender can have a very low cwnd */\n\t\t\ttcp_enter_quickack_mode(sk, 2);\n\t\t\ttp->ecn_flags |= TCP_ECN_DEMAND_CWR;\n\t\t}\n\t\ttp->ecn_flags |= TCP_ECN_SEEN;\n\t\tbreak;\n\tdefault:\n\t\tif (tcp_ca_needs_ecn(sk))\n\t\t\ttcp_ca_event(sk, CA_EVENT_ECN_NO_CE);\n\t\ttp->ecn_flags |= TCP_ECN_SEEN;\n\t\tbreak;\n\t}\n}\n\nstatic void tcp_ecn_check_ce(struct sock *sk, const struct sk_buff *skb)\n{\n\tif (tcp_sk(sk)->ecn_flags & TCP_ECN_OK)\n\t\t__tcp_ecn_check_ce(sk, skb);\n}\n\nstatic void tcp_ecn_rcv_synack(struct tcp_sock *tp, const struct tcphdr *th)\n{\n\tif ((tp->ecn_flags & TCP_ECN_OK) && (!th->ece || th->cwr))\n\t\ttp->ecn_flags &= ~TCP_ECN_OK;\n}\n\nstatic void tcp_ecn_rcv_syn(struct tcp_sock *tp, const struct tcphdr *th)\n{\n\tif ((tp->ecn_flags & TCP_ECN_OK) && (!th->ece || !th->cwr))\n\t\ttp->ecn_flags &= ~TCP_ECN_OK;\n}\n\nstatic bool tcp_ecn_rcv_ecn_echo(const struct tcp_sock *tp, const struct tcphdr *th)\n{\n\tif (th->ece && !th->syn && (tp->ecn_flags & TCP_ECN_OK))\n\t\treturn true;\n\treturn false;\n}\n\n/* Buffer size and advertised window tuning.\n *\n * 1. Tuning sk->sk_sndbuf, when connection enters established state.\n */\n\nstatic void tcp_sndbuf_expand(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcp_congestion_ops *ca_ops = inet_csk(sk)->icsk_ca_ops;\n\tint sndmem, per_mss;\n\tu32 nr_segs;\n\n\t/* Worst case is non GSO/TSO : each frame consumes one skb\n\t * and skb->head is kmalloced using power of two area of memory\n\t */\n\tper_mss = max_t(u32, tp->rx_opt.mss_clamp, tp->mss_cache) +\n\t\t  MAX_TCP_HEADER +\n\t\t  SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\n\tper_mss = roundup_pow_of_two(per_mss) +\n\t\t  SKB_DATA_ALIGN(sizeof(struct sk_buff));\n\n\tnr_segs = max_t(u32, TCP_INIT_CWND, tp->snd_cwnd);\n\tnr_segs = max_t(u32, nr_segs, tp->reordering + 1);\n\n\t/* Fast Recovery (RFC 5681 3.2) :\n\t * Cubic needs 1.7 factor, rounded to 2 to include\n\t * extra cushion (application might react slowly to EPOLLOUT)\n\t */\n\tsndmem = ca_ops->sndbuf_expand ? ca_ops->sndbuf_expand(sk) : 2;\n\tsndmem *= nr_segs * per_mss;\n\n\tif (sk->sk_sndbuf < sndmem)\n\t\tWRITE_ONCE(sk->sk_sndbuf,\n\t\t\t   min(sndmem, sock_net(sk)->ipv4.sysctl_tcp_wmem[2]));\n}\n\n/* 2. Tuning advertised window (window_clamp, rcv_ssthresh)\n *\n * All tcp_full_space() is split to two parts: \"network\" buffer, allocated\n * forward and advertised in receiver window (tp->rcv_wnd) and\n * \"application buffer\", required to isolate scheduling/application\n * latencies from network.\n * window_clamp is maximal advertised window. It can be less than\n * tcp_full_space(), in this case tcp_full_space() - window_clamp\n * is reserved for \"application\" buffer. The less window_clamp is\n * the smoother our behaviour from viewpoint of network, but the lower\n * throughput and the higher sensitivity of the connection to losses. 8)\n *\n * rcv_ssthresh is more strict window_clamp used at \"slow start\"\n * phase to predict further behaviour of this connection.\n * It is used for two goals:\n * - to enforce header prediction at sender, even when application\n *   requires some significant \"application buffer\". It is check #1.\n * - to prevent pruning of receive queue because of misprediction\n *   of receiver window. Check #2.\n *\n * The scheme does not work when sender sends good segments opening\n * window and then starts to feed us spaghetti. But it should work\n * in common situations. Otherwise, we have to rely on queue collapsing.\n */\n\n/* Slow part of check#2. */\nstatic int __tcp_grow_window(const struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t/* Optimize this! */\n\tint truesize = tcp_win_from_space(sk, skb->truesize) >> 1;\n\tint window = tcp_win_from_space(sk, sock_net(sk)->ipv4.sysctl_tcp_rmem[2]) >> 1;\n\n\twhile (tp->rcv_ssthresh <= window) {\n\t\tif (truesize <= skb->len)\n\t\t\treturn 2 * inet_csk(sk)->icsk_ack.rcv_mss;\n\n\t\ttruesize >>= 1;\n\t\twindow >>= 1;\n\t}\n\treturn 0;\n}\n\nstatic void tcp_grow_window(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint room;\n\n\troom = min_t(int, tp->window_clamp, tcp_space(sk)) - tp->rcv_ssthresh;\n\n\t/* Check #1 */\n\tif (room > 0 && !tcp_under_memory_pressure(sk)) {\n\t\tint incr;\n\n\t\t/* Check #2. Increase window, if skb with such overhead\n\t\t * will fit to rcvbuf in future.\n\t\t */\n\t\tif (tcp_win_from_space(sk, skb->truesize) <= skb->len)\n\t\t\tincr = 2 * tp->advmss;\n\t\telse\n\t\t\tincr = __tcp_grow_window(sk, skb);\n\n\t\tif (incr) {\n\t\t\tincr = max_t(int, incr, 2 * skb->len);\n\t\t\ttp->rcv_ssthresh += min(room, incr);\n\t\t\tinet_csk(sk)->icsk_ack.quick |= 1;\n\t\t}\n\t}\n}\n\n/* 3. Try to fixup all. It is made immediately after connection enters\n *    established state.\n */\nstatic void tcp_init_buffer_space(struct sock *sk)\n{\n\tint tcp_app_win = sock_net(sk)->ipv4.sysctl_tcp_app_win;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint maxwin;\n\n\tif (!(sk->sk_userlocks & SOCK_SNDBUF_LOCK))\n\t\ttcp_sndbuf_expand(sk);\n\n\ttp->rcvq_space.space = min_t(u32, tp->rcv_wnd, TCP_INIT_CWND * tp->advmss);\n\ttcp_mstamp_refresh(tp);\n\ttp->rcvq_space.time = tp->tcp_mstamp;\n\ttp->rcvq_space.seq = tp->copied_seq;\n\n\tmaxwin = tcp_full_space(sk);\n\n\tif (tp->window_clamp >= maxwin) {\n\t\ttp->window_clamp = maxwin;\n\n\t\tif (tcp_app_win && maxwin > 4 * tp->advmss)\n\t\t\ttp->window_clamp = max(maxwin -\n\t\t\t\t\t       (maxwin >> tcp_app_win),\n\t\t\t\t\t       4 * tp->advmss);\n\t}\n\n\t/* Force reservation of one segment. */\n\tif (tcp_app_win &&\n\t    tp->window_clamp > 2 * tp->advmss &&\n\t    tp->window_clamp + tp->advmss > maxwin)\n\t\ttp->window_clamp = max(2 * tp->advmss, maxwin - tp->advmss);\n\n\ttp->rcv_ssthresh = min(tp->rcv_ssthresh, tp->window_clamp);\n\ttp->snd_cwnd_stamp = tcp_jiffies32;\n}\n\n/* 4. Recalculate window clamp after socket hit its memory bounds. */\nstatic void tcp_clamp_window(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct net *net = sock_net(sk);\n\n\ticsk->icsk_ack.quick = 0;\n\n\tif (sk->sk_rcvbuf < net->ipv4.sysctl_tcp_rmem[2] &&\n\t    !(sk->sk_userlocks & SOCK_RCVBUF_LOCK) &&\n\t    !tcp_under_memory_pressure(sk) &&\n\t    sk_memory_allocated(sk) < sk_prot_mem_limits(sk, 0)) {\n\t\tWRITE_ONCE(sk->sk_rcvbuf,\n\t\t\t   min(atomic_read(&sk->sk_rmem_alloc),\n\t\t\t       net->ipv4.sysctl_tcp_rmem[2]));\n\t}\n\tif (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf)\n\t\ttp->rcv_ssthresh = min(tp->window_clamp, 2U * tp->advmss);\n}\n\n/* Initialize RCV_MSS value.\n * RCV_MSS is an our guess about MSS used by the peer.\n * We haven't any direct information about the MSS.\n * It's better to underestimate the RCV_MSS rather than overestimate.\n * Overestimations make us ACKing less frequently than needed.\n * Underestimations are more easy to detect and fix by tcp_measure_rcv_mss().\n */\nvoid tcp_initialize_rcv_mss(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tunsigned int hint = min_t(unsigned int, tp->advmss, tp->mss_cache);\n\n\thint = min(hint, tp->rcv_wnd / 2);\n\thint = min(hint, TCP_MSS_DEFAULT);\n\thint = max(hint, TCP_MIN_MSS);\n\n\tinet_csk(sk)->icsk_ack.rcv_mss = hint;\n}\nEXPORT_SYMBOL(tcp_initialize_rcv_mss);\n\n/* Receiver \"autotuning\" code.\n *\n * The algorithm for RTT estimation w/o timestamps is based on\n * Dynamic Right-Sizing (DRS) by Wu Feng and Mike Fisk of LANL.\n * <https://public.lanl.gov/radiant/pubs.html#DRS>\n *\n * More detail on this code can be found at\n * <http://staff.psc.edu/jheffner/>,\n * though this reference is out of date.  A new paper\n * is pending.\n */\nstatic void tcp_rcv_rtt_update(struct tcp_sock *tp, u32 sample, int win_dep)\n{\n\tu32 new_sample = tp->rcv_rtt_est.rtt_us;\n\tlong m = sample;\n\n\tif (new_sample != 0) {\n\t\t/* If we sample in larger samples in the non-timestamp\n\t\t * case, we could grossly overestimate the RTT especially\n\t\t * with chatty applications or bulk transfer apps which\n\t\t * are stalled on filesystem I/O.\n\t\t *\n\t\t * Also, since we are only going for a minimum in the\n\t\t * non-timestamp case, we do not smooth things out\n\t\t * else with timestamps disabled convergence takes too\n\t\t * long.\n\t\t */\n\t\tif (!win_dep) {\n\t\t\tm -= (new_sample >> 3);\n\t\t\tnew_sample += m;\n\t\t} else {\n\t\t\tm <<= 3;\n\t\t\tif (m < new_sample)\n\t\t\t\tnew_sample = m;\n\t\t}\n\t} else {\n\t\t/* No previous measure. */\n\t\tnew_sample = m << 3;\n\t}\n\n\ttp->rcv_rtt_est.rtt_us = new_sample;\n}\n\nstatic inline void tcp_rcv_rtt_measure(struct tcp_sock *tp)\n{\n\tu32 delta_us;\n\n\tif (tp->rcv_rtt_est.time == 0)\n\t\tgoto new_measure;\n\tif (before(tp->rcv_nxt, tp->rcv_rtt_est.seq))\n\t\treturn;\n\tdelta_us = tcp_stamp_us_delta(tp->tcp_mstamp, tp->rcv_rtt_est.time);\n\tif (!delta_us)\n\t\tdelta_us = 1;\n\ttcp_rcv_rtt_update(tp, delta_us, 1);\n\nnew_measure:\n\ttp->rcv_rtt_est.seq = tp->rcv_nxt + tp->rcv_wnd;\n\ttp->rcv_rtt_est.time = tp->tcp_mstamp;\n}\n\nstatic inline void tcp_rcv_rtt_measure_ts(struct sock *sk,\n\t\t\t\t\t  const struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tp->rx_opt.rcv_tsecr == tp->rcv_rtt_last_tsecr)\n\t\treturn;\n\ttp->rcv_rtt_last_tsecr = tp->rx_opt.rcv_tsecr;\n\n\tif (TCP_SKB_CB(skb)->end_seq -\n\t    TCP_SKB_CB(skb)->seq >= inet_csk(sk)->icsk_ack.rcv_mss) {\n\t\tu32 delta = tcp_time_stamp(tp) - tp->rx_opt.rcv_tsecr;\n\t\tu32 delta_us;\n\n\t\tif (likely(delta < INT_MAX / (USEC_PER_SEC / TCP_TS_HZ))) {\n\t\t\tif (!delta)\n\t\t\t\tdelta = 1;\n\t\t\tdelta_us = delta * (USEC_PER_SEC / TCP_TS_HZ);\n\t\t\ttcp_rcv_rtt_update(tp, delta_us, 0);\n\t\t}\n\t}\n}\n\n/*\n * This function should be called every time data is copied to user space.\n * It calculates the appropriate TCP receive buffer space.\n */\nvoid tcp_rcv_space_adjust(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 copied;\n\tint time;\n\n\ttrace_tcp_rcv_space_adjust(sk);\n\n\ttcp_mstamp_refresh(tp);\n\ttime = tcp_stamp_us_delta(tp->tcp_mstamp, tp->rcvq_space.time);\n\tif (time < (tp->rcv_rtt_est.rtt_us >> 3) || tp->rcv_rtt_est.rtt_us == 0)\n\t\treturn;\n\n\t/* Number of bytes copied to user in last RTT */\n\tcopied = tp->copied_seq - tp->rcvq_space.seq;\n\tif (copied <= tp->rcvq_space.space)\n\t\tgoto new_measure;\n\n\t/* A bit of theory :\n\t * copied = bytes received in previous RTT, our base window\n\t * To cope with packet losses, we need a 2x factor\n\t * To cope with slow start, and sender growing its cwin by 100 %\n\t * every RTT, we need a 4x factor, because the ACK we are sending\n\t * now is for the next RTT, not the current one :\n\t * <prev RTT . ><current RTT .. ><next RTT .... >\n\t */\n\n\tif (sock_net(sk)->ipv4.sysctl_tcp_moderate_rcvbuf &&\n\t    !(sk->sk_userlocks & SOCK_RCVBUF_LOCK)) {\n\t\tint rcvmem, rcvbuf;\n\t\tu64 rcvwin, grow;\n\n\t\t/* minimal window to cope with packet losses, assuming\n\t\t * steady state. Add some cushion because of small variations.\n\t\t */\n\t\trcvwin = ((u64)copied << 1) + 16 * tp->advmss;\n\n\t\t/* Accommodate for sender rate increase (eg. slow start) */\n\t\tgrow = rcvwin * (copied - tp->rcvq_space.space);\n\t\tdo_div(grow, tp->rcvq_space.space);\n\t\trcvwin += (grow << 1);\n\n\t\trcvmem = SKB_TRUESIZE(tp->advmss + MAX_TCP_HEADER);\n\t\twhile (tcp_win_from_space(sk, rcvmem) < tp->advmss)\n\t\t\trcvmem += 128;\n\n\t\tdo_div(rcvwin, tp->advmss);\n\t\trcvbuf = min_t(u64, rcvwin * rcvmem,\n\t\t\t       sock_net(sk)->ipv4.sysctl_tcp_rmem[2]);\n\t\tif (rcvbuf > sk->sk_rcvbuf) {\n\t\t\tWRITE_ONCE(sk->sk_rcvbuf, rcvbuf);\n\n\t\t\t/* Make the window clamp follow along.  */\n\t\t\ttp->window_clamp = tcp_win_from_space(sk, rcvbuf);\n\t\t}\n\t}\n\ttp->rcvq_space.space = copied;\n\nnew_measure:\n\ttp->rcvq_space.seq = tp->copied_seq;\n\ttp->rcvq_space.time = tp->tcp_mstamp;\n}\n\n/* There is something which you must keep in mind when you analyze the\n * behavior of the tp->ato delayed ack timeout interval.  When a\n * connection starts up, we want to ack as quickly as possible.  The\n * problem is that \"good\" TCP's do slow start at the beginning of data\n * transmission.  The means that until we send the first few ACK's the\n * sender will sit on his end and only queue most of his data, because\n * he can only send snd_cwnd unacked packets at any given time.  For\n * each ACK we send, he increments snd_cwnd and transmits more of his\n * queue.  -DaveM\n */\nstatic void tcp_event_data_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tu32 now;\n\n\tinet_csk_schedule_ack(sk);\n\n\ttcp_measure_rcv_mss(sk, skb);\n\n\ttcp_rcv_rtt_measure(tp);\n\n\tnow = tcp_jiffies32;\n\n\tif (!icsk->icsk_ack.ato) {\n\t\t/* The _first_ data packet received, initialize\n\t\t * delayed ACK engine.\n\t\t */\n\t\ttcp_incr_quickack(sk, TCP_MAX_QUICKACKS);\n\t\ticsk->icsk_ack.ato = TCP_ATO_MIN;\n\t} else {\n\t\tint m = now - icsk->icsk_ack.lrcvtime;\n\n\t\tif (m <= TCP_ATO_MIN / 2) {\n\t\t\t/* The fastest case is the first. */\n\t\t\ticsk->icsk_ack.ato = (icsk->icsk_ack.ato >> 1) + TCP_ATO_MIN / 2;\n\t\t} else if (m < icsk->icsk_ack.ato) {\n\t\t\ticsk->icsk_ack.ato = (icsk->icsk_ack.ato >> 1) + m;\n\t\t\tif (icsk->icsk_ack.ato > icsk->icsk_rto)\n\t\t\t\ticsk->icsk_ack.ato = icsk->icsk_rto;\n\t\t} else if (m > icsk->icsk_rto) {\n\t\t\t/* Too long gap. Apparently sender failed to\n\t\t\t * restart window, so that we send ACKs quickly.\n\t\t\t */\n\t\t\ttcp_incr_quickack(sk, TCP_MAX_QUICKACKS);\n\t\t\tsk_mem_reclaim(sk);\n\t\t}\n\t}\n\ticsk->icsk_ack.lrcvtime = now;\n\n\ttcp_ecn_check_ce(sk, skb);\n\n\tif (skb->len >= 128)\n\t\ttcp_grow_window(sk, skb);\n}\n\n/* Called to compute a smoothed rtt estimate. The data fed to this\n * routine either comes from timestamps, or from segments that were\n * known _not_ to have been retransmitted [see Karn/Partridge\n * Proceedings SIGCOMM 87]. The algorithm is from the SIGCOMM 88\n * piece by Van Jacobson.\n * NOTE: the next three routines used to be one big routine.\n * To save cycles in the RFC 1323 implementation it was better to break\n * it up into three procedures. -- erics\n */\nstatic void tcp_rtt_estimator(struct sock *sk, long mrtt_us)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tlong m = mrtt_us; /* RTT */\n\tu32 srtt = tp->srtt_us;\n\n\t/*\tThe following amusing code comes from Jacobson's\n\t *\tarticle in SIGCOMM '88.  Note that rtt and mdev\n\t *\tare scaled versions of rtt and mean deviation.\n\t *\tThis is designed to be as fast as possible\n\t *\tm stands for \"measurement\".\n\t *\n\t *\tOn a 1990 paper the rto value is changed to:\n\t *\tRTO = rtt + 4 * mdev\n\t *\n\t * Funny. This algorithm seems to be very broken.\n\t * These formulae increase RTO, when it should be decreased, increase\n\t * too slowly, when it should be increased quickly, decrease too quickly\n\t * etc. I guess in BSD RTO takes ONE value, so that it is absolutely\n\t * does not matter how to _calculate_ it. Seems, it was trap\n\t * that VJ failed to avoid. 8)\n\t */\n\tif (srtt != 0) {\n\t\tm -= (srtt >> 3);\t/* m is now error in rtt est */\n\t\tsrtt += m;\t\t/* rtt = 7/8 rtt + 1/8 new */\n\t\tif (m < 0) {\n\t\t\tm = -m;\t\t/* m is now abs(error) */\n\t\t\tm -= (tp->mdev_us >> 2);   /* similar update on mdev */\n\t\t\t/* This is similar to one of Eifel findings.\n\t\t\t * Eifel blocks mdev updates when rtt decreases.\n\t\t\t * This solution is a bit different: we use finer gain\n\t\t\t * for mdev in this case (alpha*beta).\n\t\t\t * Like Eifel it also prevents growth of rto,\n\t\t\t * but also it limits too fast rto decreases,\n\t\t\t * happening in pure Eifel.\n\t\t\t */\n\t\t\tif (m > 0)\n\t\t\t\tm >>= 3;\n\t\t} else {\n\t\t\tm -= (tp->mdev_us >> 2);   /* similar update on mdev */\n\t\t}\n\t\ttp->mdev_us += m;\t\t/* mdev = 3/4 mdev + 1/4 new */\n\t\tif (tp->mdev_us > tp->mdev_max_us) {\n\t\t\ttp->mdev_max_us = tp->mdev_us;\n\t\t\tif (tp->mdev_max_us > tp->rttvar_us)\n\t\t\t\ttp->rttvar_us = tp->mdev_max_us;\n\t\t}\n\t\tif (after(tp->snd_una, tp->rtt_seq)) {\n\t\t\tif (tp->mdev_max_us < tp->rttvar_us)\n\t\t\t\ttp->rttvar_us -= (tp->rttvar_us - tp->mdev_max_us) >> 2;\n\t\t\ttp->rtt_seq = tp->snd_nxt;\n\t\t\ttp->mdev_max_us = tcp_rto_min_us(sk);\n\n\t\t\ttcp_bpf_rtt(sk);\n\t\t}\n\t} else {\n\t\t/* no previous measure. */\n\t\tsrtt = m << 3;\t\t/* take the measured time to be rtt */\n\t\ttp->mdev_us = m << 1;\t/* make sure rto = 3*rtt */\n\t\ttp->rttvar_us = max(tp->mdev_us, tcp_rto_min_us(sk));\n\t\ttp->mdev_max_us = tp->rttvar_us;\n\t\ttp->rtt_seq = tp->snd_nxt;\n\n\t\ttcp_bpf_rtt(sk);\n\t}\n\ttp->srtt_us = max(1U, srtt);\n}\n\nstatic void tcp_update_pacing_rate(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tu64 rate;\n\n\t/* set sk_pacing_rate to 200 % of current rate (mss * cwnd / srtt) */\n\trate = (u64)tp->mss_cache * ((USEC_PER_SEC / 100) << 3);\n\n\t/* current rate is (cwnd * mss) / srtt\n\t * In Slow Start [1], set sk_pacing_rate to 200 % the current rate.\n\t * In Congestion Avoidance phase, set it to 120 % the current rate.\n\t *\n\t * [1] : Normal Slow Start condition is (tp->snd_cwnd < tp->snd_ssthresh)\n\t *\t If snd_cwnd >= (tp->snd_ssthresh / 2), we are approaching\n\t *\t end of slow start and should slow down.\n\t */\n\tif (tp->snd_cwnd < tp->snd_ssthresh / 2)\n\t\trate *= sock_net(sk)->ipv4.sysctl_tcp_pacing_ss_ratio;\n\telse\n\t\trate *= sock_net(sk)->ipv4.sysctl_tcp_pacing_ca_ratio;\n\n\trate *= max(tp->snd_cwnd, tp->packets_out);\n\n\tif (likely(tp->srtt_us))\n\t\tdo_div(rate, tp->srtt_us);\n\n\t/* WRITE_ONCE() is needed because sch_fq fetches sk_pacing_rate\n\t * without any lock. We want to make sure compiler wont store\n\t * intermediate values in this location.\n\t */\n\tWRITE_ONCE(sk->sk_pacing_rate, min_t(u64, rate,\n\t\t\t\t\t     sk->sk_max_pacing_rate));\n}\n\n/* Calculate rto without backoff.  This is the second half of Van Jacobson's\n * routine referred to above.\n */\nstatic void tcp_set_rto(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\t/* Old crap is replaced with new one. 8)\n\t *\n\t * More seriously:\n\t * 1. If rtt variance happened to be less 50msec, it is hallucination.\n\t *    It cannot be less due to utterly erratic ACK generation made\n\t *    at least by solaris and freebsd. \"Erratic ACKs\" has _nothing_\n\t *    to do with delayed acks, because at cwnd>2 true delack timeout\n\t *    is invisible. Actually, Linux-2.4 also generates erratic\n\t *    ACKs in some circumstances.\n\t */\n\tinet_csk(sk)->icsk_rto = __tcp_set_rto(tp);\n\n\t/* 2. Fixups made earlier cannot be right.\n\t *    If we do not estimate RTO correctly without them,\n\t *    all the algo is pure shit and should be replaced\n\t *    with correct one. It is exactly, which we pretend to do.\n\t */\n\n\t/* NOTE: clamping at TCP_RTO_MIN is not required, current algo\n\t * guarantees that rto is higher.\n\t */\n\ttcp_bound_rto(sk);\n}\n\n__u32 tcp_init_cwnd(const struct tcp_sock *tp, const struct dst_entry *dst)\n{\n\t__u32 cwnd = (dst ? dst_metric(dst, RTAX_INITCWND) : 0);\n\n\tif (!cwnd)\n\t\tcwnd = TCP_INIT_CWND;\n\treturn min_t(__u32, cwnd, tp->snd_cwnd_clamp);\n}\n\nstruct tcp_sacktag_state {\n\t/* Timestamps for earliest and latest never-retransmitted segment\n\t * that was SACKed. RTO needs the earliest RTT to stay conservative,\n\t * but congestion control should still get an accurate delay signal.\n\t */\n\tu64\tfirst_sackt;\n\tu64\tlast_sackt;\n\tu32\treord;\n\tu32\tsack_delivered;\n\tint\tflag;\n\tunsigned int mss_now;\n\tstruct rate_sample *rate;\n};\n\n/* Take a notice that peer is sending D-SACKs. Skip update of data delivery\n * and spurious retransmission information if this DSACK is unlikely caused by\n * sender's action:\n * - DSACKed sequence range is larger than maximum receiver's window.\n * - Total no. of DSACKed segments exceed the total no. of retransmitted segs.\n */\nstatic u32 tcp_dsack_seen(struct tcp_sock *tp, u32 start_seq,\n\t\t\t  u32 end_seq, struct tcp_sacktag_state *state)\n{\n\tu32 seq_len, dup_segs = 1;\n\n\tif (!before(start_seq, end_seq))\n\t\treturn 0;\n\n\tseq_len = end_seq - start_seq;\n\t/* Dubious DSACK: DSACKed range greater than maximum advertised rwnd */\n\tif (seq_len > tp->max_window)\n\t\treturn 0;\n\tif (seq_len > tp->mss_cache)\n\t\tdup_segs = DIV_ROUND_UP(seq_len, tp->mss_cache);\n\n\ttp->dsack_dups += dup_segs;\n\t/* Skip the DSACK if dup segs weren't retransmitted by sender */\n\tif (tp->dsack_dups > tp->total_retrans)\n\t\treturn 0;\n\n\ttp->rx_opt.sack_ok |= TCP_DSACK_SEEN;\n\ttp->rack.dsack_seen = 1;\n\n\tstate->flag |= FLAG_DSACKING_ACK;\n\t/* A spurious retransmission is delivered */\n\tstate->sack_delivered += dup_segs;\n\n\treturn dup_segs;\n}\n\n/* It's reordering when higher sequence was delivered (i.e. sacked) before\n * some lower never-retransmitted sequence (\"low_seq\"). The maximum reordering\n * distance is approximated in full-mss packet distance (\"reordering\").\n */\nstatic void tcp_check_sack_reordering(struct sock *sk, const u32 low_seq,\n\t\t\t\t      const int ts)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst u32 mss = tp->mss_cache;\n\tu32 fack, metric;\n\n\tfack = tcp_highest_sack_seq(tp);\n\tif (!before(low_seq, fack))\n\t\treturn;\n\n\tmetric = fack - low_seq;\n\tif ((metric > tp->reordering * mss) && mss) {\n#if FASTRETRANS_DEBUG > 1\n\t\tpr_debug(\"Disorder%d %d %u f%u s%u rr%d\\n\",\n\t\t\t tp->rx_opt.sack_ok, inet_csk(sk)->icsk_ca_state,\n\t\t\t tp->reordering,\n\t\t\t 0,\n\t\t\t tp->sacked_out,\n\t\t\t tp->undo_marker ? tp->undo_retrans : 0);\n#endif\n\t\ttp->reordering = min_t(u32, (metric + mss - 1) / mss,\n\t\t\t\t       sock_net(sk)->ipv4.sysctl_tcp_max_reordering);\n\t}\n\n\t/* This exciting event is worth to be remembered. 8) */\n\ttp->reord_seen++;\n\tNET_INC_STATS(sock_net(sk),\n\t\t      ts ? LINUX_MIB_TCPTSREORDER : LINUX_MIB_TCPSACKREORDER);\n}\n\n /* This must be called before lost_out or retrans_out are updated\n  * on a new loss, because we want to know if all skbs previously\n  * known to be lost have already been retransmitted, indicating\n  * that this newly lost skb is our next skb to retransmit.\n  */\nstatic void tcp_verify_retransmit_hint(struct tcp_sock *tp, struct sk_buff *skb)\n{\n\tif ((!tp->retransmit_skb_hint && tp->retrans_out >= tp->lost_out) ||\n\t    (tp->retransmit_skb_hint &&\n\t     before(TCP_SKB_CB(skb)->seq,\n\t\t    TCP_SKB_CB(tp->retransmit_skb_hint)->seq)))\n\t\ttp->retransmit_skb_hint = skb;\n}\n\n/* Sum the number of packets on the wire we have marked as lost, and\n * notify the congestion control module that the given skb was marked lost.\n */\nstatic void tcp_notify_skb_loss_event(struct tcp_sock *tp, const struct sk_buff *skb)\n{\n\ttp->lost += tcp_skb_pcount(skb);\n}\n\nvoid tcp_mark_skb_lost(struct sock *sk, struct sk_buff *skb)\n{\n\t__u8 sacked = TCP_SKB_CB(skb)->sacked;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (sacked & TCPCB_SACKED_ACKED)\n\t\treturn;\n\n\ttcp_verify_retransmit_hint(tp, skb);\n\tif (sacked & TCPCB_LOST) {\n\t\tif (sacked & TCPCB_SACKED_RETRANS) {\n\t\t\t/* Account for retransmits that are lost again */\n\t\t\tTCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_RETRANS;\n\t\t\ttp->retrans_out -= tcp_skb_pcount(skb);\n\t\t\tNET_ADD_STATS(sock_net(sk), LINUX_MIB_TCPLOSTRETRANSMIT,\n\t\t\t\t      tcp_skb_pcount(skb));\n\t\t\ttcp_notify_skb_loss_event(tp, skb);\n\t\t}\n\t} else {\n\t\ttp->lost_out += tcp_skb_pcount(skb);\n\t\tTCP_SKB_CB(skb)->sacked |= TCPCB_LOST;\n\t\ttcp_notify_skb_loss_event(tp, skb);\n\t}\n}\n\n/* Updates the delivered and delivered_ce counts */\nstatic void tcp_count_delivered(struct tcp_sock *tp, u32 delivered,\n\t\t\t\tbool ece_ack)\n{\n\ttp->delivered += delivered;\n\tif (ece_ack)\n\t\ttp->delivered_ce += delivered;\n}\n\n/* This procedure tags the retransmission queue when SACKs arrive.\n *\n * We have three tag bits: SACKED(S), RETRANS(R) and LOST(L).\n * Packets in queue with these bits set are counted in variables\n * sacked_out, retrans_out and lost_out, correspondingly.\n *\n * Valid combinations are:\n * Tag  InFlight\tDescription\n * 0\t1\t\t- orig segment is in flight.\n * S\t0\t\t- nothing flies, orig reached receiver.\n * L\t0\t\t- nothing flies, orig lost by net.\n * R\t2\t\t- both orig and retransmit are in flight.\n * L|R\t1\t\t- orig is lost, retransmit is in flight.\n * S|R  1\t\t- orig reached receiver, retrans is still in flight.\n * (L|S|R is logically valid, it could occur when L|R is sacked,\n *  but it is equivalent to plain S and code short-curcuits it to S.\n *  L|S is logically invalid, it would mean -1 packet in flight 8))\n *\n * These 6 states form finite state machine, controlled by the following events:\n * 1. New ACK (+SACK) arrives. (tcp_sacktag_write_queue())\n * 2. Retransmission. (tcp_retransmit_skb(), tcp_xmit_retransmit_queue())\n * 3. Loss detection event of two flavors:\n *\tA. Scoreboard estimator decided the packet is lost.\n *\t   A'. Reno \"three dupacks\" marks head of queue lost.\n *\tB. SACK arrives sacking SND.NXT at the moment, when the\n *\t   segment was retransmitted.\n * 4. D-SACK added new rule: D-SACK changes any tag to S.\n *\n * It is pleasant to note, that state diagram turns out to be commutative,\n * so that we are allowed not to be bothered by order of our actions,\n * when multiple events arrive simultaneously. (see the function below).\n *\n * Reordering detection.\n * --------------------\n * Reordering metric is maximal distance, which a packet can be displaced\n * in packet stream. With SACKs we can estimate it:\n *\n * 1. SACK fills old hole and the corresponding segment was not\n *    ever retransmitted -> reordering. Alas, we cannot use it\n *    when segment was retransmitted.\n * 2. The last flaw is solved with D-SACK. D-SACK arrives\n *    for retransmitted and already SACKed segment -> reordering..\n * Both of these heuristics are not used in Loss state, when we cannot\n * account for retransmits accurately.\n *\n * SACK block validation.\n * ----------------------\n *\n * SACK block range validation checks that the received SACK block fits to\n * the expected sequence limits, i.e., it is between SND.UNA and SND.NXT.\n * Note that SND.UNA is not included to the range though being valid because\n * it means that the receiver is rather inconsistent with itself reporting\n * SACK reneging when it should advance SND.UNA. Such SACK block this is\n * perfectly valid, however, in light of RFC2018 which explicitly states\n * that \"SACK block MUST reflect the newest segment.  Even if the newest\n * segment is going to be discarded ...\", not that it looks very clever\n * in case of head skb. Due to potentional receiver driven attacks, we\n * choose to avoid immediate execution of a walk in write queue due to\n * reneging and defer head skb's loss recovery to standard loss recovery\n * procedure that will eventually trigger (nothing forbids us doing this).\n *\n * Implements also blockage to start_seq wrap-around. Problem lies in the\n * fact that though start_seq (s) is before end_seq (i.e., not reversed),\n * there's no guarantee that it will be before snd_nxt (n). The problem\n * happens when start_seq resides between end_seq wrap (e_w) and snd_nxt\n * wrap (s_w):\n *\n *         <- outs wnd ->                          <- wrapzone ->\n *         u     e      n                         u_w   e_w  s n_w\n *         |     |      |                          |     |   |  |\n * |<------------+------+----- TCP seqno space --------------+---------->|\n * ...-- <2^31 ->|                                           |<--------...\n * ...---- >2^31 ------>|                                    |<--------...\n *\n * Current code wouldn't be vulnerable but it's better still to discard such\n * crazy SACK blocks. Doing this check for start_seq alone closes somewhat\n * similar case (end_seq after snd_nxt wrap) as earlier reversed check in\n * snd_nxt wrap -> snd_una region will then become \"well defined\", i.e.,\n * equal to the ideal case (infinite seqno space without wrap caused issues).\n *\n * With D-SACK the lower bound is extended to cover sequence space below\n * SND.UNA down to undo_marker, which is the last point of interest. Yet\n * again, D-SACK block must not to go across snd_una (for the same reason as\n * for the normal SACK blocks, explained above). But there all simplicity\n * ends, TCP might receive valid D-SACKs below that. As long as they reside\n * fully below undo_marker they do not affect behavior in anyway and can\n * therefore be safely ignored. In rare cases (which are more or less\n * theoretical ones), the D-SACK will nicely cross that boundary due to skb\n * fragmentation and packet reordering past skb's retransmission. To consider\n * them correctly, the acceptable range must be extended even more though\n * the exact amount is rather hard to quantify. However, tp->max_window can\n * be used as an exaggerated estimate.\n */\nstatic bool tcp_is_sackblock_valid(struct tcp_sock *tp, bool is_dsack,\n\t\t\t\t   u32 start_seq, u32 end_seq)\n{\n\t/* Too far in future, or reversed (interpretation is ambiguous) */\n\tif (after(end_seq, tp->snd_nxt) || !before(start_seq, end_seq))\n\t\treturn false;\n\n\t/* Nasty start_seq wrap-around check (see comments above) */\n\tif (!before(start_seq, tp->snd_nxt))\n\t\treturn false;\n\n\t/* In outstanding window? ...This is valid exit for D-SACKs too.\n\t * start_seq == snd_una is non-sensical (see comments above)\n\t */\n\tif (after(start_seq, tp->snd_una))\n\t\treturn true;\n\n\tif (!is_dsack || !tp->undo_marker)\n\t\treturn false;\n\n\t/* ...Then it's D-SACK, and must reside below snd_una completely */\n\tif (after(end_seq, tp->snd_una))\n\t\treturn false;\n\n\tif (!before(start_seq, tp->undo_marker))\n\t\treturn true;\n\n\t/* Too old */\n\tif (!after(end_seq, tp->undo_marker))\n\t\treturn false;\n\n\t/* Undo_marker boundary crossing (overestimates a lot). Known already:\n\t *   start_seq < undo_marker and end_seq >= undo_marker.\n\t */\n\treturn !before(start_seq, end_seq - tp->max_window);\n}\n\nstatic bool tcp_check_dsack(struct sock *sk, const struct sk_buff *ack_skb,\n\t\t\t    struct tcp_sack_block_wire *sp, int num_sacks,\n\t\t\t    u32 prior_snd_una, struct tcp_sacktag_state *state)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 start_seq_0 = get_unaligned_be32(&sp[0].start_seq);\n\tu32 end_seq_0 = get_unaligned_be32(&sp[0].end_seq);\n\tu32 dup_segs;\n\n\tif (before(start_seq_0, TCP_SKB_CB(ack_skb)->ack_seq)) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDSACKRECV);\n\t} else if (num_sacks > 1) {\n\t\tu32 end_seq_1 = get_unaligned_be32(&sp[1].end_seq);\n\t\tu32 start_seq_1 = get_unaligned_be32(&sp[1].start_seq);\n\n\t\tif (after(end_seq_0, end_seq_1) || before(start_seq_0, start_seq_1))\n\t\t\treturn false;\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDSACKOFORECV);\n\t} else {\n\t\treturn false;\n\t}\n\n\tdup_segs = tcp_dsack_seen(tp, start_seq_0, end_seq_0, state);\n\tif (!dup_segs) {\t/* Skip dubious DSACK */\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDSACKIGNOREDDUBIOUS);\n\t\treturn false;\n\t}\n\n\tNET_ADD_STATS(sock_net(sk), LINUX_MIB_TCPDSACKRECVSEGS, dup_segs);\n\n\t/* D-SACK for already forgotten data... Do dumb counting. */\n\tif (tp->undo_marker && tp->undo_retrans > 0 &&\n\t    !after(end_seq_0, prior_snd_una) &&\n\t    after(end_seq_0, tp->undo_marker))\n\t\ttp->undo_retrans = max_t(int, 0, tp->undo_retrans - dup_segs);\n\n\treturn true;\n}\n\n/* Check if skb is fully within the SACK block. In presence of GSO skbs,\n * the incoming SACK may not exactly match but we can find smaller MSS\n * aligned portion of it that matches. Therefore we might need to fragment\n * which may fail and creates some hassle (caller must handle error case\n * returns).\n *\n * FIXME: this could be merged to shift decision code\n */\nstatic int tcp_match_skb_to_sack(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  u32 start_seq, u32 end_seq)\n{\n\tint err;\n\tbool in_sack;\n\tunsigned int pkt_len;\n\tunsigned int mss;\n\n\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&\n\t\t  !before(end_seq, TCP_SKB_CB(skb)->end_seq);\n\n\tif (tcp_skb_pcount(skb) > 1 && !in_sack &&\n\t    after(TCP_SKB_CB(skb)->end_seq, start_seq)) {\n\t\tmss = tcp_skb_mss(skb);\n\t\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq);\n\n\t\tif (!in_sack) {\n\t\t\tpkt_len = start_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\tpkt_len = mss;\n\t\t} else {\n\t\t\tpkt_len = end_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Round if necessary so that SACKs cover only full MSSes\n\t\t * and/or the remaining small portion (if present)\n\t\t */\n\t\tif (pkt_len > mss) {\n\t\t\tunsigned int new_len = (pkt_len / mss) * mss;\n\t\t\tif (!in_sack && new_len < pkt_len)\n\t\t\t\tnew_len += mss;\n\t\t\tpkt_len = new_len;\n\t\t}\n\n\t\tif (pkt_len >= skb->len && !in_sack)\n\t\t\treturn 0;\n\n\t\terr = tcp_fragment(sk, TCP_FRAG_IN_RTX_QUEUE, skb,\n\t\t\t\t   pkt_len, mss, GFP_ATOMIC);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn in_sack;\n}\n\n/* Mark the given newly-SACKed range as such, adjusting counters and hints. */\nstatic u8 tcp_sacktag_one(struct sock *sk,\n\t\t\t  struct tcp_sacktag_state *state, u8 sacked,\n\t\t\t  u32 start_seq, u32 end_seq,\n\t\t\t  int dup_sack, int pcount,\n\t\t\t  u64 xmit_time)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t/* Account D-SACK for retransmitted packet. */\n\tif (dup_sack && (sacked & TCPCB_RETRANS)) {\n\t\tif (tp->undo_marker && tp->undo_retrans > 0 &&\n\t\t    after(end_seq, tp->undo_marker))\n\t\t\ttp->undo_retrans--;\n\t\tif ((sacked & TCPCB_SACKED_ACKED) &&\n\t\t    before(start_seq, state->reord))\n\t\t\t\tstate->reord = start_seq;\n\t}\n\n\t/* Nothing to do; acked frame is about to be dropped (was ACKed). */\n\tif (!after(end_seq, tp->snd_una))\n\t\treturn sacked;\n\n\tif (!(sacked & TCPCB_SACKED_ACKED)) {\n\t\ttcp_rack_advance(tp, sacked, end_seq, xmit_time);\n\n\t\tif (sacked & TCPCB_SACKED_RETRANS) {\n\t\t\t/* If the segment is not tagged as lost,\n\t\t\t * we do not clear RETRANS, believing\n\t\t\t * that retransmission is still in flight.\n\t\t\t */\n\t\t\tif (sacked & TCPCB_LOST) {\n\t\t\t\tsacked &= ~(TCPCB_LOST|TCPCB_SACKED_RETRANS);\n\t\t\t\ttp->lost_out -= pcount;\n\t\t\t\ttp->retrans_out -= pcount;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(sacked & TCPCB_RETRANS)) {\n\t\t\t\t/* New sack for not retransmitted frame,\n\t\t\t\t * which was in hole. It is reordering.\n\t\t\t\t */\n\t\t\t\tif (before(start_seq,\n\t\t\t\t\t   tcp_highest_sack_seq(tp)) &&\n\t\t\t\t    before(start_seq, state->reord))\n\t\t\t\t\tstate->reord = start_seq;\n\n\t\t\t\tif (!after(end_seq, tp->high_seq))\n\t\t\t\t\tstate->flag |= FLAG_ORIG_SACK_ACKED;\n\t\t\t\tif (state->first_sackt == 0)\n\t\t\t\t\tstate->first_sackt = xmit_time;\n\t\t\t\tstate->last_sackt = xmit_time;\n\t\t\t}\n\n\t\t\tif (sacked & TCPCB_LOST) {\n\t\t\t\tsacked &= ~TCPCB_LOST;\n\t\t\t\ttp->lost_out -= pcount;\n\t\t\t}\n\t\t}\n\n\t\tsacked |= TCPCB_SACKED_ACKED;\n\t\tstate->flag |= FLAG_DATA_SACKED;\n\t\ttp->sacked_out += pcount;\n\t\t/* Out-of-order packets delivered */\n\t\tstate->sack_delivered += pcount;\n\n\t\t/* Lost marker hint past SACKed? Tweak RFC3517 cnt */\n\t\tif (tp->lost_skb_hint &&\n\t\t    before(start_seq, TCP_SKB_CB(tp->lost_skb_hint)->seq))\n\t\t\ttp->lost_cnt_hint += pcount;\n\t}\n\n\t/* D-SACK. We can detect redundant retransmission in S|R and plain R\n\t * frames and clear it. undo_retrans is decreased above, L|R frames\n\t * are accounted above as well.\n\t */\n\tif (dup_sack && (sacked & TCPCB_SACKED_RETRANS)) {\n\t\tsacked &= ~TCPCB_SACKED_RETRANS;\n\t\ttp->retrans_out -= pcount;\n\t}\n\n\treturn sacked;\n}\n\n/* Shift newly-SACKed bytes from this skb to the immediately previous\n * already-SACKed sk_buff. Mark the newly-SACKed bytes as such.\n */\nstatic bool tcp_shifted_skb(struct sock *sk, struct sk_buff *prev,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct tcp_sacktag_state *state,\n\t\t\t    unsigned int pcount, int shifted, int mss,\n\t\t\t    bool dup_sack)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 start_seq = TCP_SKB_CB(skb)->seq;\t/* start of newly-SACKed */\n\tu32 end_seq = start_seq + shifted;\t/* end of newly-SACKed */\n\n\tBUG_ON(!pcount);\n\n\t/* Adjust counters and hints for the newly sacked sequence\n\t * range but discard the return value since prev is already\n\t * marked. We must tag the range first because the seq\n\t * advancement below implicitly advances\n\t * tcp_highest_sack_seq() when skb is highest_sack.\n\t */\n\ttcp_sacktag_one(sk, state, TCP_SKB_CB(skb)->sacked,\n\t\t\tstart_seq, end_seq, dup_sack, pcount,\n\t\t\ttcp_skb_timestamp_us(skb));\n\ttcp_rate_skb_delivered(sk, skb, state->rate);\n\n\tif (skb == tp->lost_skb_hint)\n\t\ttp->lost_cnt_hint += pcount;\n\n\tTCP_SKB_CB(prev)->end_seq += shifted;\n\tTCP_SKB_CB(skb)->seq += shifted;\n\n\ttcp_skb_pcount_add(prev, pcount);\n\tWARN_ON_ONCE(tcp_skb_pcount(skb) < pcount);\n\ttcp_skb_pcount_add(skb, -pcount);\n\n\t/* When we're adding to gso_segs == 1, gso_size will be zero,\n\t * in theory this shouldn't be necessary but as long as DSACK\n\t * code can come after this skb later on it's better to keep\n\t * setting gso_size to something.\n\t */\n\tif (!TCP_SKB_CB(prev)->tcp_gso_size)\n\t\tTCP_SKB_CB(prev)->tcp_gso_size = mss;\n\n\t/* CHECKME: To clear or not to clear? Mimics normal skb currently */\n\tif (tcp_skb_pcount(skb) <= 1)\n\t\tTCP_SKB_CB(skb)->tcp_gso_size = 0;\n\n\t/* Difference in this won't matter, both ACKed by the same cumul. ACK */\n\tTCP_SKB_CB(prev)->sacked |= (TCP_SKB_CB(skb)->sacked & TCPCB_EVER_RETRANS);\n\n\tif (skb->len > 0) {\n\t\tBUG_ON(!tcp_skb_pcount(skb));\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_SACKSHIFTED);\n\t\treturn false;\n\t}\n\n\t/* Whole SKB was eaten :-) */\n\n\tif (skb == tp->retransmit_skb_hint)\n\t\ttp->retransmit_skb_hint = prev;\n\tif (skb == tp->lost_skb_hint) {\n\t\ttp->lost_skb_hint = prev;\n\t\ttp->lost_cnt_hint -= tcp_skb_pcount(prev);\n\t}\n\n\tTCP_SKB_CB(prev)->tcp_flags |= TCP_SKB_CB(skb)->tcp_flags;\n\tTCP_SKB_CB(prev)->eor = TCP_SKB_CB(skb)->eor;\n\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)\n\t\tTCP_SKB_CB(prev)->end_seq++;\n\n\tif (skb == tcp_highest_sack(sk))\n\t\ttcp_advance_highest_sack(sk, skb);\n\n\ttcp_skb_collapse_tstamp(prev, skb);\n\tif (unlikely(TCP_SKB_CB(prev)->tx.delivered_mstamp))\n\t\tTCP_SKB_CB(prev)->tx.delivered_mstamp = 0;\n\n\ttcp_rtx_queue_unlink_and_free(skb, sk);\n\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_SACKMERGED);\n\n\treturn true;\n}\n\n/* I wish gso_size would have a bit more sane initialization than\n * something-or-zero which complicates things\n */\nstatic int tcp_skb_seglen(const struct sk_buff *skb)\n{\n\treturn tcp_skb_pcount(skb) == 1 ? skb->len : tcp_skb_mss(skb);\n}\n\n/* Shifting pages past head area doesn't work */\nstatic int skb_can_shift(const struct sk_buff *skb)\n{\n\treturn !skb_headlen(skb) && skb_is_nonlinear(skb);\n}\n\nint tcp_skb_shift(struct sk_buff *to, struct sk_buff *from,\n\t\t  int pcount, int shiftlen)\n{\n\t/* TCP min gso_size is 8 bytes (TCP_MIN_GSO_SIZE)\n\t * Since TCP_SKB_CB(skb)->tcp_gso_segs is 16 bits, we need\n\t * to make sure not storing more than 65535 * 8 bytes per skb,\n\t * even if current MSS is bigger.\n\t */\n\tif (unlikely(to->len + shiftlen >= 65535 * TCP_MIN_GSO_SIZE))\n\t\treturn 0;\n\tif (unlikely(tcp_skb_pcount(to) + pcount > 65535))\n\t\treturn 0;\n\treturn skb_shift(to, from, shiftlen);\n}\n\n/* Try collapsing SACK blocks spanning across multiple skbs to a single\n * skb.\n */\nstatic struct sk_buff *tcp_shift_skb_data(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t  struct tcp_sacktag_state *state,\n\t\t\t\t\t  u32 start_seq, u32 end_seq,\n\t\t\t\t\t  bool dup_sack)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *prev;\n\tint mss;\n\tint pcount = 0;\n\tint len;\n\tint in_sack;\n\n\t/* Normally R but no L won't result in plain S */\n\tif (!dup_sack &&\n\t    (TCP_SKB_CB(skb)->sacked & (TCPCB_LOST|TCPCB_SACKED_RETRANS)) == TCPCB_SACKED_RETRANS)\n\t\tgoto fallback;\n\tif (!skb_can_shift(skb))\n\t\tgoto fallback;\n\t/* This frame is about to be dropped (was ACKed). */\n\tif (!after(TCP_SKB_CB(skb)->end_seq, tp->snd_una))\n\t\tgoto fallback;\n\n\t/* Can only happen with delayed DSACK + discard craziness */\n\tprev = skb_rb_prev(skb);\n\tif (!prev)\n\t\tgoto fallback;\n\n\tif ((TCP_SKB_CB(prev)->sacked & TCPCB_TAGBITS) != TCPCB_SACKED_ACKED)\n\t\tgoto fallback;\n\n\tif (!tcp_skb_can_collapse(prev, skb))\n\t\tgoto fallback;\n\n\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&\n\t\t  !before(end_seq, TCP_SKB_CB(skb)->end_seq);\n\n\tif (in_sack) {\n\t\tlen = skb->len;\n\t\tpcount = tcp_skb_pcount(skb);\n\t\tmss = tcp_skb_seglen(skb);\n\n\t\t/* TODO: Fix DSACKs to not fragment already SACKed and we can\n\t\t * drop this restriction as unnecessary\n\t\t */\n\t\tif (mss != tcp_skb_seglen(prev))\n\t\t\tgoto fallback;\n\t} else {\n\t\tif (!after(TCP_SKB_CB(skb)->end_seq, start_seq))\n\t\t\tgoto noop;\n\t\t/* CHECKME: This is non-MSS split case only?, this will\n\t\t * cause skipped skbs due to advancing loop btw, original\n\t\t * has that feature too\n\t\t */\n\t\tif (tcp_skb_pcount(skb) <= 1)\n\t\t\tgoto noop;\n\n\t\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq);\n\t\tif (!in_sack) {\n\t\t\t/* TODO: head merge to next could be attempted here\n\t\t\t * if (!after(TCP_SKB_CB(skb)->end_seq, end_seq)),\n\t\t\t * though it might not be worth of the additional hassle\n\t\t\t *\n\t\t\t * ...we can probably just fallback to what was done\n\t\t\t * previously. We could try merging non-SACKed ones\n\t\t\t * as well but it probably isn't going to buy off\n\t\t\t * because later SACKs might again split them, and\n\t\t\t * it would make skb timestamp tracking considerably\n\t\t\t * harder problem.\n\t\t\t */\n\t\t\tgoto fallback;\n\t\t}\n\n\t\tlen = end_seq - TCP_SKB_CB(skb)->seq;\n\t\tBUG_ON(len < 0);\n\t\tBUG_ON(len > skb->len);\n\n\t\t/* MSS boundaries should be honoured or else pcount will\n\t\t * severely break even though it makes things bit trickier.\n\t\t * Optimize common case to avoid most of the divides\n\t\t */\n\t\tmss = tcp_skb_mss(skb);\n\n\t\t/* TODO: Fix DSACKs to not fragment already SACKed and we can\n\t\t * drop this restriction as unnecessary\n\t\t */\n\t\tif (mss != tcp_skb_seglen(prev))\n\t\t\tgoto fallback;\n\n\t\tif (len == mss) {\n\t\t\tpcount = 1;\n\t\t} else if (len < mss) {\n\t\t\tgoto noop;\n\t\t} else {\n\t\t\tpcount = len / mss;\n\t\t\tlen = pcount * mss;\n\t\t}\n\t}\n\n\t/* tcp_sacktag_one() won't SACK-tag ranges below snd_una */\n\tif (!after(TCP_SKB_CB(skb)->seq + len, tp->snd_una))\n\t\tgoto fallback;\n\n\tif (!tcp_skb_shift(prev, skb, pcount, len))\n\t\tgoto fallback;\n\tif (!tcp_shifted_skb(sk, prev, skb, state, pcount, len, mss, dup_sack))\n\t\tgoto out;\n\n\t/* Hole filled allows collapsing with the next as well, this is very\n\t * useful when hole on every nth skb pattern happens\n\t */\n\tskb = skb_rb_next(prev);\n\tif (!skb)\n\t\tgoto out;\n\n\tif (!skb_can_shift(skb) ||\n\t    ((TCP_SKB_CB(skb)->sacked & TCPCB_TAGBITS) != TCPCB_SACKED_ACKED) ||\n\t    (mss != tcp_skb_seglen(skb)))\n\t\tgoto out;\n\n\tlen = skb->len;\n\tpcount = tcp_skb_pcount(skb);\n\tif (tcp_skb_shift(prev, skb, pcount, len))\n\t\ttcp_shifted_skb(sk, prev, skb, state, pcount,\n\t\t\t\tlen, mss, 0);\n\nout:\n\treturn prev;\n\nnoop:\n\treturn skb;\n\nfallback:\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_SACKSHIFTFALLBACK);\n\treturn NULL;\n}\n\nstatic struct sk_buff *tcp_sacktag_walk(struct sk_buff *skb, struct sock *sk,\n\t\t\t\t\tstruct tcp_sack_block *next_dup,\n\t\t\t\t\tstruct tcp_sacktag_state *state,\n\t\t\t\t\tu32 start_seq, u32 end_seq,\n\t\t\t\t\tbool dup_sack_in)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *tmp;\n\n\tskb_rbtree_walk_from(skb) {\n\t\tint in_sack = 0;\n\t\tbool dup_sack = dup_sack_in;\n\n\t\t/* queue is in-order => we can short-circuit the walk early */\n\t\tif (!before(TCP_SKB_CB(skb)->seq, end_seq))\n\t\t\tbreak;\n\n\t\tif (next_dup  &&\n\t\t    before(TCP_SKB_CB(skb)->seq, next_dup->end_seq)) {\n\t\t\tin_sack = tcp_match_skb_to_sack(sk, skb,\n\t\t\t\t\t\t\tnext_dup->start_seq,\n\t\t\t\t\t\t\tnext_dup->end_seq);\n\t\t\tif (in_sack > 0)\n\t\t\t\tdup_sack = true;\n\t\t}\n\n\t\t/* skb reference here is a bit tricky to get right, since\n\t\t * shifting can eat and free both this skb and the next,\n\t\t * so not even _safe variant of the loop is enough.\n\t\t */\n\t\tif (in_sack <= 0) {\n\t\t\ttmp = tcp_shift_skb_data(sk, skb, state,\n\t\t\t\t\t\t start_seq, end_seq, dup_sack);\n\t\t\tif (tmp) {\n\t\t\t\tif (tmp != skb) {\n\t\t\t\t\tskb = tmp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tin_sack = 0;\n\t\t\t} else {\n\t\t\t\tin_sack = tcp_match_skb_to_sack(sk, skb,\n\t\t\t\t\t\t\t\tstart_seq,\n\t\t\t\t\t\t\t\tend_seq);\n\t\t\t}\n\t\t}\n\n\t\tif (unlikely(in_sack < 0))\n\t\t\tbreak;\n\n\t\tif (in_sack) {\n\t\t\tTCP_SKB_CB(skb)->sacked =\n\t\t\t\ttcp_sacktag_one(sk,\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tTCP_SKB_CB(skb)->sacked,\n\t\t\t\t\t\tTCP_SKB_CB(skb)->seq,\n\t\t\t\t\t\tTCP_SKB_CB(skb)->end_seq,\n\t\t\t\t\t\tdup_sack,\n\t\t\t\t\t\ttcp_skb_pcount(skb),\n\t\t\t\t\t\ttcp_skb_timestamp_us(skb));\n\t\t\ttcp_rate_skb_delivered(sk, skb, state->rate);\n\t\t\tif (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED)\n\t\t\t\tlist_del_init(&skb->tcp_tsorted_anchor);\n\n\t\t\tif (!before(TCP_SKB_CB(skb)->seq,\n\t\t\t\t    tcp_highest_sack_seq(tp)))\n\t\t\t\ttcp_advance_highest_sack(sk, skb);\n\t\t}\n\t}\n\treturn skb;\n}\n\nstatic struct sk_buff *tcp_sacktag_bsearch(struct sock *sk, u32 seq)\n{\n\tstruct rb_node *parent, **p = &sk->tcp_rtx_queue.rb_node;\n\tstruct sk_buff *skb;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tskb = rb_to_skb(parent);\n\t\tif (before(seq, TCP_SKB_CB(skb)->seq)) {\n\t\t\tp = &parent->rb_left;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!before(seq, TCP_SKB_CB(skb)->end_seq)) {\n\t\t\tp = &parent->rb_right;\n\t\t\tcontinue;\n\t\t}\n\t\treturn skb;\n\t}\n\treturn NULL;\n}\n\nstatic struct sk_buff *tcp_sacktag_skip(struct sk_buff *skb, struct sock *sk,\n\t\t\t\t\tu32 skip_to_seq)\n{\n\tif (skb && after(TCP_SKB_CB(skb)->seq, skip_to_seq))\n\t\treturn skb;\n\n\treturn tcp_sacktag_bsearch(sk, skip_to_seq);\n}\n\nstatic struct sk_buff *tcp_maybe_skipping_dsack(struct sk_buff *skb,\n\t\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\t\tstruct tcp_sack_block *next_dup,\n\t\t\t\t\t\tstruct tcp_sacktag_state *state,\n\t\t\t\t\t\tu32 skip_to_seq)\n{\n\tif (!next_dup)\n\t\treturn skb;\n\n\tif (before(next_dup->start_seq, skip_to_seq)) {\n\t\tskb = tcp_sacktag_skip(skb, sk, next_dup->start_seq);\n\t\tskb = tcp_sacktag_walk(skb, sk, NULL, state,\n\t\t\t\t       next_dup->start_seq, next_dup->end_seq,\n\t\t\t\t       1);\n\t}\n\n\treturn skb;\n}\n\nstatic int tcp_sack_cache_ok(const struct tcp_sock *tp, const struct tcp_sack_block *cache)\n{\n\treturn cache < tp->recv_sack_cache + ARRAY_SIZE(tp->recv_sack_cache);\n}\n\nstatic int\ntcp_sacktag_write_queue(struct sock *sk, const struct sk_buff *ack_skb,\n\t\t\tu32 prior_snd_una, struct tcp_sacktag_state *state)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst unsigned char *ptr = (skb_transport_header(ack_skb) +\n\t\t\t\t    TCP_SKB_CB(ack_skb)->sacked);\n\tstruct tcp_sack_block_wire *sp_wire = (struct tcp_sack_block_wire *)(ptr+2);\n\tstruct tcp_sack_block sp[TCP_NUM_SACKS];\n\tstruct tcp_sack_block *cache;\n\tstruct sk_buff *skb;\n\tint num_sacks = min(TCP_NUM_SACKS, (ptr[1] - TCPOLEN_SACK_BASE) >> 3);\n\tint used_sacks;\n\tbool found_dup_sack = false;\n\tint i, j;\n\tint first_sack_index;\n\n\tstate->flag = 0;\n\tstate->reord = tp->snd_nxt;\n\n\tif (!tp->sacked_out)\n\t\ttcp_highest_sack_reset(sk);\n\n\tfound_dup_sack = tcp_check_dsack(sk, ack_skb, sp_wire,\n\t\t\t\t\t num_sacks, prior_snd_una, state);\n\n\t/* Eliminate too old ACKs, but take into\n\t * account more or less fresh ones, they can\n\t * contain valid SACK info.\n\t */\n\tif (before(TCP_SKB_CB(ack_skb)->ack_seq, prior_snd_una - tp->max_window))\n\t\treturn 0;\n\n\tif (!tp->packets_out)\n\t\tgoto out;\n\n\tused_sacks = 0;\n\tfirst_sack_index = 0;\n\tfor (i = 0; i < num_sacks; i++) {\n\t\tbool dup_sack = !i && found_dup_sack;\n\n\t\tsp[used_sacks].start_seq = get_unaligned_be32(&sp_wire[i].start_seq);\n\t\tsp[used_sacks].end_seq = get_unaligned_be32(&sp_wire[i].end_seq);\n\n\t\tif (!tcp_is_sackblock_valid(tp, dup_sack,\n\t\t\t\t\t    sp[used_sacks].start_seq,\n\t\t\t\t\t    sp[used_sacks].end_seq)) {\n\t\t\tint mib_idx;\n\n\t\t\tif (dup_sack) {\n\t\t\t\tif (!tp->undo_marker)\n\t\t\t\t\tmib_idx = LINUX_MIB_TCPDSACKIGNOREDNOUNDO;\n\t\t\t\telse\n\t\t\t\t\tmib_idx = LINUX_MIB_TCPDSACKIGNOREDOLD;\n\t\t\t} else {\n\t\t\t\t/* Don't count olds caused by ACK reordering */\n\t\t\t\tif ((TCP_SKB_CB(ack_skb)->ack_seq != tp->snd_una) &&\n\t\t\t\t    !after(sp[used_sacks].end_seq, tp->snd_una))\n\t\t\t\t\tcontinue;\n\t\t\t\tmib_idx = LINUX_MIB_TCPSACKDISCARD;\n\t\t\t}\n\n\t\t\tNET_INC_STATS(sock_net(sk), mib_idx);\n\t\t\tif (i == 0)\n\t\t\t\tfirst_sack_index = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ignore very old stuff early */\n\t\tif (!after(sp[used_sacks].end_seq, prior_snd_una)) {\n\t\t\tif (i == 0)\n\t\t\t\tfirst_sack_index = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tused_sacks++;\n\t}\n\n\t/* order SACK blocks to allow in order walk of the retrans queue */\n\tfor (i = used_sacks - 1; i > 0; i--) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (after(sp[j].start_seq, sp[j + 1].start_seq)) {\n\t\t\t\tswap(sp[j], sp[j + 1]);\n\n\t\t\t\t/* Track where the first SACK block goes to */\n\t\t\t\tif (j == first_sack_index)\n\t\t\t\t\tfirst_sack_index = j + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tstate->mss_now = tcp_current_mss(sk);\n\tskb = NULL;\n\ti = 0;\n\n\tif (!tp->sacked_out) {\n\t\t/* It's already past, so skip checking against it */\n\t\tcache = tp->recv_sack_cache + ARRAY_SIZE(tp->recv_sack_cache);\n\t} else {\n\t\tcache = tp->recv_sack_cache;\n\t\t/* Skip empty blocks in at head of the cache */\n\t\twhile (tcp_sack_cache_ok(tp, cache) && !cache->start_seq &&\n\t\t       !cache->end_seq)\n\t\t\tcache++;\n\t}\n\n\twhile (i < used_sacks) {\n\t\tu32 start_seq = sp[i].start_seq;\n\t\tu32 end_seq = sp[i].end_seq;\n\t\tbool dup_sack = (found_dup_sack && (i == first_sack_index));\n\t\tstruct tcp_sack_block *next_dup = NULL;\n\n\t\tif (found_dup_sack && ((i + 1) == first_sack_index))\n\t\t\tnext_dup = &sp[i + 1];\n\n\t\t/* Skip too early cached blocks */\n\t\twhile (tcp_sack_cache_ok(tp, cache) &&\n\t\t       !before(start_seq, cache->end_seq))\n\t\t\tcache++;\n\n\t\t/* Can skip some work by looking recv_sack_cache? */\n\t\tif (tcp_sack_cache_ok(tp, cache) && !dup_sack &&\n\t\t    after(end_seq, cache->start_seq)) {\n\n\t\t\t/* Head todo? */\n\t\t\tif (before(start_seq, cache->start_seq)) {\n\t\t\t\tskb = tcp_sacktag_skip(skb, sk, start_seq);\n\t\t\t\tskb = tcp_sacktag_walk(skb, sk, next_dup,\n\t\t\t\t\t\t       state,\n\t\t\t\t\t\t       start_seq,\n\t\t\t\t\t\t       cache->start_seq,\n\t\t\t\t\t\t       dup_sack);\n\t\t\t}\n\n\t\t\t/* Rest of the block already fully processed? */\n\t\t\tif (!after(end_seq, cache->end_seq))\n\t\t\t\tgoto advance_sp;\n\n\t\t\tskb = tcp_maybe_skipping_dsack(skb, sk, next_dup,\n\t\t\t\t\t\t       state,\n\t\t\t\t\t\t       cache->end_seq);\n\n\t\t\t/* ...tail remains todo... */\n\t\t\tif (tcp_highest_sack_seq(tp) == cache->end_seq) {\n\t\t\t\t/* ...but better entrypoint exists! */\n\t\t\t\tskb = tcp_highest_sack(sk);\n\t\t\t\tif (!skb)\n\t\t\t\t\tbreak;\n\t\t\t\tcache++;\n\t\t\t\tgoto walk;\n\t\t\t}\n\n\t\t\tskb = tcp_sacktag_skip(skb, sk, cache->end_seq);\n\t\t\t/* Check overlap against next cached too (past this one already) */\n\t\t\tcache++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!before(start_seq, tcp_highest_sack_seq(tp))) {\n\t\t\tskb = tcp_highest_sack(sk);\n\t\t\tif (!skb)\n\t\t\t\tbreak;\n\t\t}\n\t\tskb = tcp_sacktag_skip(skb, sk, start_seq);\n\nwalk:\n\t\tskb = tcp_sacktag_walk(skb, sk, next_dup, state,\n\t\t\t\t       start_seq, end_seq, dup_sack);\n\nadvance_sp:\n\t\ti++;\n\t}\n\n\t/* Clear the head of the cache sack blocks so we can skip it next time */\n\tfor (i = 0; i < ARRAY_SIZE(tp->recv_sack_cache) - used_sacks; i++) {\n\t\ttp->recv_sack_cache[i].start_seq = 0;\n\t\ttp->recv_sack_cache[i].end_seq = 0;\n\t}\n\tfor (j = 0; j < used_sacks; j++)\n\t\ttp->recv_sack_cache[i++] = sp[j];\n\n\tif (inet_csk(sk)->icsk_ca_state != TCP_CA_Loss || tp->undo_marker)\n\t\ttcp_check_sack_reordering(sk, state->reord, 0);\n\n\ttcp_verify_left_out(tp);\nout:\n\n#if FASTRETRANS_DEBUG > 0\n\tWARN_ON((int)tp->sacked_out < 0);\n\tWARN_ON((int)tp->lost_out < 0);\n\tWARN_ON((int)tp->retrans_out < 0);\n\tWARN_ON((int)tcp_packets_in_flight(tp) < 0);\n#endif\n\treturn state->flag;\n}\n\n/* Limits sacked_out so that sum with lost_out isn't ever larger than\n * packets_out. Returns false if sacked_out adjustement wasn't necessary.\n */\nstatic bool tcp_limit_reno_sacked(struct tcp_sock *tp)\n{\n\tu32 holes;\n\n\tholes = max(tp->lost_out, 1U);\n\tholes = min(holes, tp->packets_out);\n\n\tif ((tp->sacked_out + holes) > tp->packets_out) {\n\t\ttp->sacked_out = tp->packets_out - holes;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* If we receive more dupacks than we expected counting segments\n * in assumption of absent reordering, interpret this as reordering.\n * The only another reason could be bug in receiver TCP.\n */\nstatic void tcp_check_reno_reordering(struct sock *sk, const int addend)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (!tcp_limit_reno_sacked(tp))\n\t\treturn;\n\n\ttp->reordering = min_t(u32, tp->packets_out + addend,\n\t\t\t       sock_net(sk)->ipv4.sysctl_tcp_max_reordering);\n\ttp->reord_seen++;\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRENOREORDER);\n}\n\n/* Emulate SACKs for SACKless connection: account for a new dupack. */\n\nstatic void tcp_add_reno_sack(struct sock *sk, int num_dupack, bool ece_ack)\n{\n\tif (num_dupack) {\n\t\tstruct tcp_sock *tp = tcp_sk(sk);\n\t\tu32 prior_sacked = tp->sacked_out;\n\t\ts32 delivered;\n\n\t\ttp->sacked_out += num_dupack;\n\t\ttcp_check_reno_reordering(sk, 0);\n\t\tdelivered = tp->sacked_out - prior_sacked;\n\t\tif (delivered > 0)\n\t\t\ttcp_count_delivered(tp, delivered, ece_ack);\n\t\ttcp_verify_left_out(tp);\n\t}\n}\n\n/* Account for ACK, ACKing some data in Reno Recovery phase. */\n\nstatic void tcp_remove_reno_sacks(struct sock *sk, int acked, bool ece_ack)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (acked > 0) {\n\t\t/* One ACK acked hole. The rest eat duplicate ACKs. */\n\t\ttcp_count_delivered(tp, max_t(int, acked - tp->sacked_out, 1),\n\t\t\t\t    ece_ack);\n\t\tif (acked - 1 >= tp->sacked_out)\n\t\t\ttp->sacked_out = 0;\n\t\telse\n\t\t\ttp->sacked_out -= acked - 1;\n\t}\n\ttcp_check_reno_reordering(sk, acked);\n\ttcp_verify_left_out(tp);\n}\n\nstatic inline void tcp_reset_reno_sack(struct tcp_sock *tp)\n{\n\ttp->sacked_out = 0;\n}\n\nvoid tcp_clear_retrans(struct tcp_sock *tp)\n{\n\ttp->retrans_out = 0;\n\ttp->lost_out = 0;\n\ttp->undo_marker = 0;\n\ttp->undo_retrans = -1;\n\ttp->sacked_out = 0;\n}\n\nstatic inline void tcp_init_undo(struct tcp_sock *tp)\n{\n\ttp->undo_marker = tp->snd_una;\n\t/* Retransmission still in flight may cause DSACKs later. */\n\ttp->undo_retrans = tp->retrans_out ? : -1;\n}\n\nstatic bool tcp_is_rack(const struct sock *sk)\n{\n\treturn sock_net(sk)->ipv4.sysctl_tcp_recovery & TCP_RACK_LOSS_DETECTION;\n}\n\n/* If we detect SACK reneging, forget all SACK information\n * and reset tags completely, otherwise preserve SACKs. If receiver\n * dropped its ofo queue, we will know this due to reneging detection.\n */\nstatic void tcp_timeout_mark_lost(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb, *head;\n\tbool is_reneg;\t\t\t/* is receiver reneging on SACKs? */\n\n\thead = tcp_rtx_queue_head(sk);\n\tis_reneg = head && (TCP_SKB_CB(head)->sacked & TCPCB_SACKED_ACKED);\n\tif (is_reneg) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPSACKRENEGING);\n\t\ttp->sacked_out = 0;\n\t\t/* Mark SACK reneging until we recover from this loss event. */\n\t\ttp->is_sack_reneg = 1;\n\t} else if (tcp_is_reno(tp)) {\n\t\ttcp_reset_reno_sack(tp);\n\t}\n\n\tskb = head;\n\tskb_rbtree_walk_from(skb) {\n\t\tif (is_reneg)\n\t\t\tTCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_ACKED;\n\t\telse if (tcp_is_rack(sk) && skb != head &&\n\t\t\t tcp_rack_skb_timeout(tp, skb, 0) > 0)\n\t\t\tcontinue; /* Don't mark recently sent ones lost yet */\n\t\ttcp_mark_skb_lost(sk, skb);\n\t}\n\ttcp_verify_left_out(tp);\n\ttcp_clear_all_retrans_hints(tp);\n}\n\n/* Enter Loss state. */\nvoid tcp_enter_loss(struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tbool new_recovery = icsk->icsk_ca_state < TCP_CA_Recovery;\n\n\ttcp_timeout_mark_lost(sk);\n\n\t/* Reduce ssthresh if it has not yet been made inside this window. */\n\tif (icsk->icsk_ca_state <= TCP_CA_Disorder ||\n\t    !after(tp->high_seq, tp->snd_una) ||\n\t    (icsk->icsk_ca_state == TCP_CA_Loss && !icsk->icsk_retransmits)) {\n\t\ttp->prior_ssthresh = tcp_current_ssthresh(sk);\n\t\ttp->prior_cwnd = tp->snd_cwnd;\n\t\ttp->snd_ssthresh = icsk->icsk_ca_ops->ssthresh(sk);\n\t\ttcp_ca_event(sk, CA_EVENT_LOSS);\n\t\ttcp_init_undo(tp);\n\t}\n\ttp->snd_cwnd\t   = tcp_packets_in_flight(tp) + 1;\n\ttp->snd_cwnd_cnt   = 0;\n\ttp->snd_cwnd_stamp = tcp_jiffies32;\n\n\t/* Timeout in disordered state after receiving substantial DUPACKs\n\t * suggests that the degree of reordering is over-estimated.\n\t */\n\tif (icsk->icsk_ca_state <= TCP_CA_Disorder &&\n\t    tp->sacked_out >= net->ipv4.sysctl_tcp_reordering)\n\t\ttp->reordering = min_t(unsigned int, tp->reordering,\n\t\t\t\t       net->ipv4.sysctl_tcp_reordering);\n\ttcp_set_ca_state(sk, TCP_CA_Loss);\n\ttp->high_seq = tp->snd_nxt;\n\ttcp_ecn_queue_cwr(tp);\n\n\t/* F-RTO RFC5682 sec 3.1 step 1: retransmit SND.UNA if no previous\n\t * loss recovery is underway except recurring timeout(s) on\n\t * the same SND.UNA (sec 3.2). Disable F-RTO on path MTU probing\n\t */\n\ttp->frto = net->ipv4.sysctl_tcp_frto &&\n\t\t   (new_recovery || icsk->icsk_retransmits) &&\n\t\t   !inet_csk(sk)->icsk_mtup.probe_size;\n}\n\n/* If ACK arrived pointing to a remembered SACK, it means that our\n * remembered SACKs do not reflect real state of receiver i.e.\n * receiver _host_ is heavily congested (or buggy).\n *\n * To avoid big spurious retransmission bursts due to transient SACK\n * scoreboard oddities that look like reneging, we give the receiver a\n * little time (max(RTT/2, 10ms)) to send us some more ACKs that will\n * restore sanity to the SACK scoreboard. If the apparent reneging\n * persists until this RTO then we'll clear the SACK scoreboard.\n */\nstatic bool tcp_check_sack_reneging(struct sock *sk, int flag)\n{\n\tif (flag & FLAG_SACK_RENEGING) {\n\t\tstruct tcp_sock *tp = tcp_sk(sk);\n\t\tunsigned long delay = max(usecs_to_jiffies(tp->srtt_us >> 4),\n\t\t\t\t\t  msecs_to_jiffies(10));\n\n\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,\n\t\t\t\t\t  delay, TCP_RTO_MAX);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* Heurestics to calculate number of duplicate ACKs. There's no dupACKs\n * counter when SACK is enabled (without SACK, sacked_out is used for\n * that purpose).\n *\n * With reordering, holes may still be in flight, so RFC3517 recovery\n * uses pure sacked_out (total number of SACKed segments) even though\n * it violates the RFC that uses duplicate ACKs, often these are equal\n * but when e.g. out-of-window ACKs or packet duplication occurs,\n * they differ. Since neither occurs due to loss, TCP should really\n * ignore them.\n */\nstatic inline int tcp_dupack_heuristics(const struct tcp_sock *tp)\n{\n\treturn tp->sacked_out + 1;\n}\n\n/* Linux NewReno/SACK/ECN state machine.\n * --------------------------------------\n *\n * \"Open\"\tNormal state, no dubious events, fast path.\n * \"Disorder\"   In all the respects it is \"Open\",\n *\t\tbut requires a bit more attention. It is entered when\n *\t\twe see some SACKs or dupacks. It is split of \"Open\"\n *\t\tmainly to move some processing from fast path to slow one.\n * \"CWR\"\tCWND was reduced due to some Congestion Notification event.\n *\t\tIt can be ECN, ICMP source quench, local device congestion.\n * \"Recovery\"\tCWND was reduced, we are fast-retransmitting.\n * \"Loss\"\tCWND was reduced due to RTO timeout or SACK reneging.\n *\n * tcp_fastretrans_alert() is entered:\n * - each incoming ACK, if state is not \"Open\"\n * - when arrived ACK is unusual, namely:\n *\t* SACK\n *\t* Duplicate ACK.\n *\t* ECN ECE.\n *\n * Counting packets in flight is pretty simple.\n *\n *\tin_flight = packets_out - left_out + retrans_out\n *\n *\tpackets_out is SND.NXT-SND.UNA counted in packets.\n *\n *\tretrans_out is number of retransmitted segments.\n *\n *\tleft_out is number of segments left network, but not ACKed yet.\n *\n *\t\tleft_out = sacked_out + lost_out\n *\n *     sacked_out: Packets, which arrived to receiver out of order\n *\t\t   and hence not ACKed. With SACKs this number is simply\n *\t\t   amount of SACKed data. Even without SACKs\n *\t\t   it is easy to give pretty reliable estimate of this number,\n *\t\t   counting duplicate ACKs.\n *\n *       lost_out: Packets lost by network. TCP has no explicit\n *\t\t   \"loss notification\" feedback from network (for now).\n *\t\t   It means that this number can be only _guessed_.\n *\t\t   Actually, it is the heuristics to predict lossage that\n *\t\t   distinguishes different algorithms.\n *\n *\tF.e. after RTO, when all the queue is considered as lost,\n *\tlost_out = packets_out and in_flight = retrans_out.\n *\n *\t\tEssentially, we have now a few algorithms detecting\n *\t\tlost packets.\n *\n *\t\tIf the receiver supports SACK:\n *\n *\t\tRFC6675/3517: It is the conventional algorithm. A packet is\n *\t\tconsidered lost if the number of higher sequence packets\n *\t\tSACKed is greater than or equal the DUPACK thoreshold\n *\t\t(reordering). This is implemented in tcp_mark_head_lost and\n *\t\ttcp_update_scoreboard.\n *\n *\t\tRACK (draft-ietf-tcpm-rack-01): it is a newer algorithm\n *\t\t(2017-) that checks timing instead of counting DUPACKs.\n *\t\tEssentially a packet is considered lost if it's not S/ACKed\n *\t\tafter RTT + reordering_window, where both metrics are\n *\t\tdynamically measured and adjusted. This is implemented in\n *\t\ttcp_rack_mark_lost.\n *\n *\t\tIf the receiver does not support SACK:\n *\n *\t\tNewReno (RFC6582): in Recovery we assume that one segment\n *\t\tis lost (classic Reno). While we are in Recovery and\n *\t\ta partial ACK arrives, we assume that one more packet\n *\t\tis lost (NewReno). This heuristics are the same in NewReno\n *\t\tand SACK.\n *\n * Really tricky (and requiring careful tuning) part of algorithm\n * is hidden in functions tcp_time_to_recover() and tcp_xmit_retransmit_queue().\n * The first determines the moment _when_ we should reduce CWND and,\n * hence, slow down forward transmission. In fact, it determines the moment\n * when we decide that hole is caused by loss, rather than by a reorder.\n *\n * tcp_xmit_retransmit_queue() decides, _what_ we should retransmit to fill\n * holes, caused by lost packets.\n *\n * And the most logically complicated part of algorithm is undo\n * heuristics. We detect false retransmits due to both too early\n * fast retransmit (reordering) and underestimated RTO, analyzing\n * timestamps and D-SACKs. When we detect that some segments were\n * retransmitted by mistake and CWND reduction was wrong, we undo\n * window reduction and abort recovery phase. This logic is hidden\n * inside several functions named tcp_try_undo_<something>.\n */\n\n/* This function decides, when we should leave Disordered state\n * and enter Recovery phase, reducing congestion window.\n *\n * Main question: may we further continue forward transmission\n * with the same cwnd?\n */\nstatic bool tcp_time_to_recover(struct sock *sk, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t/* Trick#1: The loss is proven. */\n\tif (tp->lost_out)\n\t\treturn true;\n\n\t/* Not-A-Trick#2 : Classic rule... */\n\tif (!tcp_is_rack(sk) && tcp_dupack_heuristics(tp) > tp->reordering)\n\t\treturn true;\n\n\treturn false;\n}\n\n/* Detect loss in event \"A\" above by marking head of queue up as lost.\n * For RFC3517 SACK, a segment is considered lost if it\n * has at least tp->reordering SACKed seqments above it; \"packets\" refers to\n * the maximum SACKed segments to pass before reaching this limit.\n */\nstatic void tcp_mark_head_lost(struct sock *sk, int packets, int mark_head)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb;\n\tint cnt;\n\t/* Use SACK to deduce losses of new sequences sent during recovery */\n\tconst u32 loss_high = tp->snd_nxt;\n\n\tWARN_ON(packets > tp->packets_out);\n\tskb = tp->lost_skb_hint;\n\tif (skb) {\n\t\t/* Head already handled? */\n\t\tif (mark_head && after(TCP_SKB_CB(skb)->seq, tp->snd_una))\n\t\t\treturn;\n\t\tcnt = tp->lost_cnt_hint;\n\t} else {\n\t\tskb = tcp_rtx_queue_head(sk);\n\t\tcnt = 0;\n\t}\n\n\tskb_rbtree_walk_from(skb) {\n\t\t/* TODO: do this better */\n\t\t/* this is not the most efficient way to do this... */\n\t\ttp->lost_skb_hint = skb;\n\t\ttp->lost_cnt_hint = cnt;\n\n\t\tif (after(TCP_SKB_CB(skb)->end_seq, loss_high))\n\t\t\tbreak;\n\n\t\tif (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED)\n\t\t\tcnt += tcp_skb_pcount(skb);\n\n\t\tif (cnt > packets)\n\t\t\tbreak;\n\n\t\tif (!(TCP_SKB_CB(skb)->sacked & TCPCB_LOST))\n\t\t\ttcp_mark_skb_lost(sk, skb);\n\n\t\tif (mark_head)\n\t\t\tbreak;\n\t}\n\ttcp_verify_left_out(tp);\n}\n\n/* Account newly detected lost packet(s) */\n\nstatic void tcp_update_scoreboard(struct sock *sk, int fast_rexmit)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_is_sack(tp)) {\n\t\tint sacked_upto = tp->sacked_out - tp->reordering;\n\t\tif (sacked_upto >= 0)\n\t\t\ttcp_mark_head_lost(sk, sacked_upto, 0);\n\t\telse if (fast_rexmit)\n\t\t\ttcp_mark_head_lost(sk, 1, 1);\n\t}\n}\n\nstatic bool tcp_tsopt_ecr_before(const struct tcp_sock *tp, u32 when)\n{\n\treturn tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr &&\n\t       before(tp->rx_opt.rcv_tsecr, when);\n}\n\n/* skb is spurious retransmitted if the returned timestamp echo\n * reply is prior to the skb transmission time\n */\nstatic bool tcp_skb_spurious_retrans(const struct tcp_sock *tp,\n\t\t\t\t     const struct sk_buff *skb)\n{\n\treturn (TCP_SKB_CB(skb)->sacked & TCPCB_RETRANS) &&\n\t       tcp_tsopt_ecr_before(tp, tcp_skb_timestamp(skb));\n}\n\n/* Nothing was retransmitted or returned timestamp is less\n * than timestamp of the first retransmission.\n */\nstatic inline bool tcp_packet_delayed(const struct tcp_sock *tp)\n{\n\treturn tp->retrans_stamp &&\n\t       tcp_tsopt_ecr_before(tp, tp->retrans_stamp);\n}\n\n/* Undo procedures. */\n\n/* We can clear retrans_stamp when there are no retransmissions in the\n * window. It would seem that it is trivially available for us in\n * tp->retrans_out, however, that kind of assumptions doesn't consider\n * what will happen if errors occur when sending retransmission for the\n * second time. ...It could the that such segment has only\n * TCPCB_EVER_RETRANS set at the present time. It seems that checking\n * the head skb is enough except for some reneging corner cases that\n * are not worth the effort.\n *\n * Main reason for all this complexity is the fact that connection dying\n * time now depends on the validity of the retrans_stamp, in particular,\n * that successive retransmissions of a segment must not advance\n * retrans_stamp under any conditions.\n */\nstatic bool tcp_any_retrans_done(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb;\n\n\tif (tp->retrans_out)\n\t\treturn true;\n\n\tskb = tcp_rtx_queue_head(sk);\n\tif (unlikely(skb && TCP_SKB_CB(skb)->sacked & TCPCB_EVER_RETRANS))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void DBGUNDO(struct sock *sk, const char *msg)\n{\n#if FASTRETRANS_DEBUG > 1\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\tif (sk->sk_family == AF_INET) {\n\t\tpr_debug(\"Undo %s %pI4/%u c%u l%u ss%u/%u p%u\\n\",\n\t\t\t msg,\n\t\t\t &inet->inet_daddr, ntohs(inet->inet_dport),\n\t\t\t tp->snd_cwnd, tcp_left_out(tp),\n\t\t\t tp->snd_ssthresh, tp->prior_ssthresh,\n\t\t\t tp->packets_out);\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\telse if (sk->sk_family == AF_INET6) {\n\t\tpr_debug(\"Undo %s %pI6/%u c%u l%u ss%u/%u p%u\\n\",\n\t\t\t msg,\n\t\t\t &sk->sk_v6_daddr, ntohs(inet->inet_dport),\n\t\t\t tp->snd_cwnd, tcp_left_out(tp),\n\t\t\t tp->snd_ssthresh, tp->prior_ssthresh,\n\t\t\t tp->packets_out);\n\t}\n#endif\n#endif\n}\n\nstatic void tcp_undo_cwnd_reduction(struct sock *sk, bool unmark_loss)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (unmark_loss) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb_rbtree_walk(skb, &sk->tcp_rtx_queue) {\n\t\t\tTCP_SKB_CB(skb)->sacked &= ~TCPCB_LOST;\n\t\t}\n\t\ttp->lost_out = 0;\n\t\ttcp_clear_all_retrans_hints(tp);\n\t}\n\n\tif (tp->prior_ssthresh) {\n\t\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\t\ttp->snd_cwnd = icsk->icsk_ca_ops->undo_cwnd(sk);\n\n\t\tif (tp->prior_ssthresh > tp->snd_ssthresh) {\n\t\t\ttp->snd_ssthresh = tp->prior_ssthresh;\n\t\t\ttcp_ecn_withdraw_cwr(tp);\n\t\t}\n\t}\n\ttp->snd_cwnd_stamp = tcp_jiffies32;\n\ttp->undo_marker = 0;\n\ttp->rack.advanced = 1; /* Force RACK to re-exam losses */\n}\n\nstatic inline bool tcp_may_undo(const struct tcp_sock *tp)\n{\n\treturn tp->undo_marker && (!tp->undo_retrans || tcp_packet_delayed(tp));\n}\n\n/* People celebrate: \"We love our President!\" */\nstatic bool tcp_try_undo_recovery(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_may_undo(tp)) {\n\t\tint mib_idx;\n\n\t\t/* Happy end! We did not retransmit anything\n\t\t * or our original transmission succeeded.\n\t\t */\n\t\tDBGUNDO(sk, inet_csk(sk)->icsk_ca_state == TCP_CA_Loss ? \"loss\" : \"retrans\");\n\t\ttcp_undo_cwnd_reduction(sk, false);\n\t\tif (inet_csk(sk)->icsk_ca_state == TCP_CA_Loss)\n\t\t\tmib_idx = LINUX_MIB_TCPLOSSUNDO;\n\t\telse\n\t\t\tmib_idx = LINUX_MIB_TCPFULLUNDO;\n\n\t\tNET_INC_STATS(sock_net(sk), mib_idx);\n\t} else if (tp->rack.reo_wnd_persist) {\n\t\ttp->rack.reo_wnd_persist--;\n\t}\n\tif (tp->snd_una == tp->high_seq && tcp_is_reno(tp)) {\n\t\t/* Hold old state until something *above* high_seq\n\t\t * is ACKed. For Reno it is MUST to prevent false\n\t\t * fast retransmits (RFC2582). SACK TCP is safe. */\n\t\tif (!tcp_any_retrans_done(sk))\n\t\t\ttp->retrans_stamp = 0;\n\t\treturn true;\n\t}\n\ttcp_set_ca_state(sk, TCP_CA_Open);\n\ttp->is_sack_reneg = 0;\n\treturn false;\n}\n\n/* Try to undo cwnd reduction, because D-SACKs acked all retransmitted data */\nstatic bool tcp_try_undo_dsack(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tp->undo_marker && !tp->undo_retrans) {\n\t\ttp->rack.reo_wnd_persist = min(TCP_RACK_RECOVERY_THRESH,\n\t\t\t\t\t       tp->rack.reo_wnd_persist + 1);\n\t\tDBGUNDO(sk, \"D-SACK\");\n\t\ttcp_undo_cwnd_reduction(sk, false);\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDSACKUNDO);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* Undo during loss recovery after partial ACK or using F-RTO. */\nstatic bool tcp_try_undo_loss(struct sock *sk, bool frto_undo)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (frto_undo || tcp_may_undo(tp)) {\n\t\ttcp_undo_cwnd_reduction(sk, true);\n\n\t\tDBGUNDO(sk, \"partial loss\");\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPLOSSUNDO);\n\t\tif (frto_undo)\n\t\t\tNET_INC_STATS(sock_net(sk),\n\t\t\t\t\tLINUX_MIB_TCPSPURIOUSRTOS);\n\t\tinet_csk(sk)->icsk_retransmits = 0;\n\t\tif (frto_undo || tcp_is_sack(tp)) {\n\t\t\ttcp_set_ca_state(sk, TCP_CA_Open);\n\t\t\ttp->is_sack_reneg = 0;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* The cwnd reduction in CWR and Recovery uses the PRR algorithm in RFC 6937.\n * It computes the number of packets to send (sndcnt) based on packets newly\n * delivered:\n *   1) If the packets in flight is larger than ssthresh, PRR spreads the\n *\tcwnd reductions across a full RTT.\n *   2) Otherwise PRR uses packet conservation to send as much as delivered.\n *      But when the retransmits are acked without further losses, PRR\n *      slow starts cwnd up to ssthresh to speed up the recovery.\n */\nstatic void tcp_init_cwnd_reduction(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\ttp->high_seq = tp->snd_nxt;\n\ttp->tlp_high_seq = 0;\n\ttp->snd_cwnd_cnt = 0;\n\ttp->prior_cwnd = tp->snd_cwnd;\n\ttp->prr_delivered = 0;\n\ttp->prr_out = 0;\n\ttp->snd_ssthresh = inet_csk(sk)->icsk_ca_ops->ssthresh(sk);\n\ttcp_ecn_queue_cwr(tp);\n}\n\nvoid tcp_cwnd_reduction(struct sock *sk, int newly_acked_sacked, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint sndcnt = 0;\n\tint delta = tp->snd_ssthresh - tcp_packets_in_flight(tp);\n\n\tif (newly_acked_sacked <= 0 || WARN_ON_ONCE(!tp->prior_cwnd))\n\t\treturn;\n\n\ttp->prr_delivered += newly_acked_sacked;\n\tif (delta < 0) {\n\t\tu64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +\n\t\t\t       tp->prior_cwnd - 1;\n\t\tsndcnt = div_u64(dividend, tp->prior_cwnd) - tp->prr_out;\n\t} else if ((flag & (FLAG_RETRANS_DATA_ACKED | FLAG_LOST_RETRANS)) ==\n\t\t   FLAG_RETRANS_DATA_ACKED) {\n\t\tsndcnt = min_t(int, delta,\n\t\t\t       max_t(int, tp->prr_delivered - tp->prr_out,\n\t\t\t\t     newly_acked_sacked) + 1);\n\t} else {\n\t\tsndcnt = min(delta, newly_acked_sacked);\n\t}\n\t/* Force a fast retransmit upon entering fast recovery */\n\tsndcnt = max(sndcnt, (tp->prr_out ? 0 : 1));\n\ttp->snd_cwnd = tcp_packets_in_flight(tp) + sndcnt;\n}\n\nstatic inline void tcp_end_cwnd_reduction(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (inet_csk(sk)->icsk_ca_ops->cong_control)\n\t\treturn;\n\n\t/* Reset cwnd to ssthresh in CWR or Recovery (unless it's undone) */\n\tif (tp->snd_ssthresh < TCP_INFINITE_SSTHRESH &&\n\t    (inet_csk(sk)->icsk_ca_state == TCP_CA_CWR || tp->undo_marker)) {\n\t\ttp->snd_cwnd = tp->snd_ssthresh;\n\t\ttp->snd_cwnd_stamp = tcp_jiffies32;\n\t}\n\ttcp_ca_event(sk, CA_EVENT_COMPLETE_CWR);\n}\n\n/* Enter CWR state. Disable cwnd undo since congestion is proven with ECN */\nvoid tcp_enter_cwr(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\ttp->prior_ssthresh = 0;\n\tif (inet_csk(sk)->icsk_ca_state < TCP_CA_CWR) {\n\t\ttp->undo_marker = 0;\n\t\ttcp_init_cwnd_reduction(sk);\n\t\ttcp_set_ca_state(sk, TCP_CA_CWR);\n\t}\n}\nEXPORT_SYMBOL(tcp_enter_cwr);\n\nstatic void tcp_try_keep_open(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint state = TCP_CA_Open;\n\n\tif (tcp_left_out(tp) || tcp_any_retrans_done(sk))\n\t\tstate = TCP_CA_Disorder;\n\n\tif (inet_csk(sk)->icsk_ca_state != state) {\n\t\ttcp_set_ca_state(sk, state);\n\t\ttp->high_seq = tp->snd_nxt;\n\t}\n}\n\nstatic void tcp_try_to_open(struct sock *sk, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\ttcp_verify_left_out(tp);\n\n\tif (!tcp_any_retrans_done(sk))\n\t\ttp->retrans_stamp = 0;\n\n\tif (flag & FLAG_ECE)\n\t\ttcp_enter_cwr(sk);\n\n\tif (inet_csk(sk)->icsk_ca_state != TCP_CA_CWR) {\n\t\ttcp_try_keep_open(sk);\n\t}\n}\n\nstatic void tcp_mtup_probe_failed(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ticsk->icsk_mtup.search_high = icsk->icsk_mtup.probe_size - 1;\n\ticsk->icsk_mtup.probe_size = 0;\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMTUPFAIL);\n}\n\nstatic void tcp_mtup_probe_success(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\t/* FIXME: breaks with very large cwnd */\n\ttp->prior_ssthresh = tcp_current_ssthresh(sk);\n\ttp->snd_cwnd = tp->snd_cwnd *\n\t\t       tcp_mss_to_mtu(sk, tp->mss_cache) /\n\t\t       icsk->icsk_mtup.probe_size;\n\ttp->snd_cwnd_cnt = 0;\n\ttp->snd_cwnd_stamp = tcp_jiffies32;\n\ttp->snd_ssthresh = tcp_current_ssthresh(sk);\n\n\ticsk->icsk_mtup.search_low = icsk->icsk_mtup.probe_size;\n\ticsk->icsk_mtup.probe_size = 0;\n\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMTUPSUCCESS);\n}\n\n/* Do a simple retransmit without using the backoff mechanisms in\n * tcp_timer. This is used for path mtu discovery.\n * The socket is already locked here.\n */\nvoid tcp_simple_retransmit(struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb;\n\tunsigned int mss = tcp_current_mss(sk);\n\n\tskb_rbtree_walk(skb, &sk->tcp_rtx_queue) {\n\t\tif (tcp_skb_seglen(skb) > mss)\n\t\t\ttcp_mark_skb_lost(sk, skb);\n\t}\n\n\ttcp_clear_retrans_hints_partial(tp);\n\n\tif (!tp->lost_out)\n\t\treturn;\n\n\tif (tcp_is_reno(tp))\n\t\ttcp_limit_reno_sacked(tp);\n\n\ttcp_verify_left_out(tp);\n\n\t/* Don't muck with the congestion window here.\n\t * Reason is that we do not increase amount of _data_\n\t * in network, but units changed and effective\n\t * cwnd/ssthresh really reduced now.\n\t */\n\tif (icsk->icsk_ca_state != TCP_CA_Loss) {\n\t\ttp->high_seq = tp->snd_nxt;\n\t\ttp->snd_ssthresh = tcp_current_ssthresh(sk);\n\t\ttp->prior_ssthresh = 0;\n\t\ttp->undo_marker = 0;\n\t\ttcp_set_ca_state(sk, TCP_CA_Loss);\n\t}\n\ttcp_xmit_retransmit_queue(sk);\n}\nEXPORT_SYMBOL(tcp_simple_retransmit);\n\nvoid tcp_enter_recovery(struct sock *sk, bool ece_ack)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint mib_idx;\n\n\tif (tcp_is_reno(tp))\n\t\tmib_idx = LINUX_MIB_TCPRENORECOVERY;\n\telse\n\t\tmib_idx = LINUX_MIB_TCPSACKRECOVERY;\n\n\tNET_INC_STATS(sock_net(sk), mib_idx);\n\n\ttp->prior_ssthresh = 0;\n\ttcp_init_undo(tp);\n\n\tif (!tcp_in_cwnd_reduction(sk)) {\n\t\tif (!ece_ack)\n\t\t\ttp->prior_ssthresh = tcp_current_ssthresh(sk);\n\t\ttcp_init_cwnd_reduction(sk);\n\t}\n\ttcp_set_ca_state(sk, TCP_CA_Recovery);\n}\n\n/* Process an ACK in CA_Loss state. Move to CA_Open if lost data are\n * recovered or spurious. Otherwise retransmits more on partial ACKs.\n */\nstatic void tcp_process_loss(struct sock *sk, int flag, int num_dupack,\n\t\t\t     int *rexmit)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tbool recovered = !before(tp->snd_una, tp->high_seq);\n\n\tif ((flag & FLAG_SND_UNA_ADVANCED || rcu_access_pointer(tp->fastopen_rsk)) &&\n\t    tcp_try_undo_loss(sk, false))\n\t\treturn;\n\n\tif (tp->frto) { /* F-RTO RFC5682 sec 3.1 (sack enhanced version). */\n\t\t/* Step 3.b. A timeout is spurious if not all data are\n\t\t * lost, i.e., never-retransmitted data are (s)acked.\n\t\t */\n\t\tif ((flag & FLAG_ORIG_SACK_ACKED) &&\n\t\t    tcp_try_undo_loss(sk, true))\n\t\t\treturn;\n\n\t\tif (after(tp->snd_nxt, tp->high_seq)) {\n\t\t\tif (flag & FLAG_DATA_SACKED || num_dupack)\n\t\t\t\ttp->frto = 0; /* Step 3.a. loss was real */\n\t\t} else if (flag & FLAG_SND_UNA_ADVANCED && !recovered) {\n\t\t\ttp->high_seq = tp->snd_nxt;\n\t\t\t/* Step 2.b. Try send new data (but deferred until cwnd\n\t\t\t * is updated in tcp_ack()). Otherwise fall back to\n\t\t\t * the conventional recovery.\n\t\t\t */\n\t\t\tif (!tcp_write_queue_empty(sk) &&\n\t\t\t    after(tcp_wnd_end(tp), tp->snd_nxt)) {\n\t\t\t\t*rexmit = REXMIT_NEW;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttp->frto = 0;\n\t\t}\n\t}\n\n\tif (recovered) {\n\t\t/* F-RTO RFC5682 sec 3.1 step 2.a and 1st part of step 3.a */\n\t\ttcp_try_undo_recovery(sk);\n\t\treturn;\n\t}\n\tif (tcp_is_reno(tp)) {\n\t\t/* A Reno DUPACK means new data in F-RTO step 2.b above are\n\t\t * delivered. Lower inflight to clock out (re)tranmissions.\n\t\t */\n\t\tif (after(tp->snd_nxt, tp->high_seq) && num_dupack)\n\t\t\ttcp_add_reno_sack(sk, num_dupack, flag & FLAG_ECE);\n\t\telse if (flag & FLAG_SND_UNA_ADVANCED)\n\t\t\ttcp_reset_reno_sack(tp);\n\t}\n\t*rexmit = REXMIT_LOST;\n}\n\n/* Undo during fast recovery after partial ACK. */\nstatic bool tcp_try_undo_partial(struct sock *sk, u32 prior_snd_una)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tp->undo_marker && tcp_packet_delayed(tp)) {\n\t\t/* Plain luck! Hole if filled with delayed\n\t\t * packet, rather than with a retransmit. Check reordering.\n\t\t */\n\t\ttcp_check_sack_reordering(sk, prior_snd_una, 1);\n\n\t\t/* We are getting evidence that the reordering degree is higher\n\t\t * than we realized. If there are no retransmits out then we\n\t\t * can undo. Otherwise we clock out new packets but do not\n\t\t * mark more packets lost or retransmit more.\n\t\t */\n\t\tif (tp->retrans_out)\n\t\t\treturn true;\n\n\t\tif (!tcp_any_retrans_done(sk))\n\t\t\ttp->retrans_stamp = 0;\n\n\t\tDBGUNDO(sk, \"partial recovery\");\n\t\ttcp_undo_cwnd_reduction(sk, true);\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPPARTIALUNDO);\n\t\ttcp_try_keep_open(sk);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void tcp_identify_packet_loss(struct sock *sk, int *ack_flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_rtx_queue_empty(sk))\n\t\treturn;\n\n\tif (unlikely(tcp_is_reno(tp))) {\n\t\ttcp_newreno_mark_lost(sk, *ack_flag & FLAG_SND_UNA_ADVANCED);\n\t} else if (tcp_is_rack(sk)) {\n\t\tu32 prior_retrans = tp->retrans_out;\n\n\t\ttcp_rack_mark_lost(sk);\n\t\tif (prior_retrans > tp->retrans_out)\n\t\t\t*ack_flag |= FLAG_LOST_RETRANS;\n\t}\n}\n\nstatic bool tcp_force_fast_retransmit(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\treturn after(tcp_highest_sack_seq(tp),\n\t\t     tp->snd_una + tp->reordering * tp->mss_cache);\n}\n\n/* Process an event, which can update packets-in-flight not trivially.\n * Main goal of this function is to calculate new estimate for left_out,\n * taking into account both packets sitting in receiver's buffer and\n * packets lost by network.\n *\n * Besides that it updates the congestion state when packet loss or ECN\n * is detected. But it does not reduce the cwnd, it is done by the\n * congestion control later.\n *\n * It does _not_ decide what to send, it is made in function\n * tcp_xmit_retransmit_queue().\n */\nstatic void tcp_fastretrans_alert(struct sock *sk, const u32 prior_snd_una,\n\t\t\t\t  int num_dupack, int *ack_flag, int *rexmit)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint fast_rexmit = 0, flag = *ack_flag;\n\tbool ece_ack = flag & FLAG_ECE;\n\tbool do_lost = num_dupack || ((flag & FLAG_DATA_SACKED) &&\n\t\t\t\t      tcp_force_fast_retransmit(sk));\n\n\tif (!tp->packets_out && tp->sacked_out)\n\t\ttp->sacked_out = 0;\n\n\t/* Now state machine starts.\n\t * A. ECE, hence prohibit cwnd undoing, the reduction is required. */\n\tif (ece_ack)\n\t\ttp->prior_ssthresh = 0;\n\n\t/* B. In all the states check for reneging SACKs. */\n\tif (tcp_check_sack_reneging(sk, flag))\n\t\treturn;\n\n\t/* C. Check consistency of the current state. */\n\ttcp_verify_left_out(tp);\n\n\t/* D. Check state exit conditions. State can be terminated\n\t *    when high_seq is ACKed. */\n\tif (icsk->icsk_ca_state == TCP_CA_Open) {\n\t\tWARN_ON(tp->retrans_out != 0);\n\t\ttp->retrans_stamp = 0;\n\t} else if (!before(tp->snd_una, tp->high_seq)) {\n\t\tswitch (icsk->icsk_ca_state) {\n\t\tcase TCP_CA_CWR:\n\t\t\t/* CWR is to be held something *above* high_seq\n\t\t\t * is ACKed for CWR bit to reach receiver. */\n\t\t\tif (tp->snd_una != tp->high_seq) {\n\t\t\t\ttcp_end_cwnd_reduction(sk);\n\t\t\t\ttcp_set_ca_state(sk, TCP_CA_Open);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TCP_CA_Recovery:\n\t\t\tif (tcp_is_reno(tp))\n\t\t\t\ttcp_reset_reno_sack(tp);\n\t\t\tif (tcp_try_undo_recovery(sk))\n\t\t\t\treturn;\n\t\t\ttcp_end_cwnd_reduction(sk);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* E. Process state. */\n\tswitch (icsk->icsk_ca_state) {\n\tcase TCP_CA_Recovery:\n\t\tif (!(flag & FLAG_SND_UNA_ADVANCED)) {\n\t\t\tif (tcp_is_reno(tp))\n\t\t\t\ttcp_add_reno_sack(sk, num_dupack, ece_ack);\n\t\t} else {\n\t\t\tif (tcp_try_undo_partial(sk, prior_snd_una))\n\t\t\t\treturn;\n\t\t\t/* Partial ACK arrived. Force fast retransmit. */\n\t\t\tdo_lost = tcp_force_fast_retransmit(sk);\n\t\t}\n\t\tif (tcp_try_undo_dsack(sk)) {\n\t\t\ttcp_try_keep_open(sk);\n\t\t\treturn;\n\t\t}\n\t\ttcp_identify_packet_loss(sk, ack_flag);\n\t\tbreak;\n\tcase TCP_CA_Loss:\n\t\ttcp_process_loss(sk, flag, num_dupack, rexmit);\n\t\ttcp_identify_packet_loss(sk, ack_flag);\n\t\tif (!(icsk->icsk_ca_state == TCP_CA_Open ||\n\t\t      (*ack_flag & FLAG_LOST_RETRANS)))\n\t\t\treturn;\n\t\t/* Change state if cwnd is undone or retransmits are lost */\n\t\tfallthrough;\n\tdefault:\n\t\tif (tcp_is_reno(tp)) {\n\t\t\tif (flag & FLAG_SND_UNA_ADVANCED)\n\t\t\t\ttcp_reset_reno_sack(tp);\n\t\t\ttcp_add_reno_sack(sk, num_dupack, ece_ack);\n\t\t}\n\n\t\tif (icsk->icsk_ca_state <= TCP_CA_Disorder)\n\t\t\ttcp_try_undo_dsack(sk);\n\n\t\ttcp_identify_packet_loss(sk, ack_flag);\n\t\tif (!tcp_time_to_recover(sk, flag)) {\n\t\t\ttcp_try_to_open(sk, flag);\n\t\t\treturn;\n\t\t}\n\n\t\t/* MTU probe failure: don't reduce cwnd */\n\t\tif (icsk->icsk_ca_state < TCP_CA_CWR &&\n\t\t    icsk->icsk_mtup.probe_size &&\n\t\t    tp->snd_una == tp->mtu_probe.probe_seq_start) {\n\t\t\ttcp_mtup_probe_failed(sk);\n\t\t\t/* Restores the reduction we did in tcp_mtup_probe() */\n\t\t\ttp->snd_cwnd++;\n\t\t\ttcp_simple_retransmit(sk);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Otherwise enter Recovery state */\n\t\ttcp_enter_recovery(sk, ece_ack);\n\t\tfast_rexmit = 1;\n\t}\n\n\tif (!tcp_is_rack(sk) && do_lost)\n\t\ttcp_update_scoreboard(sk, fast_rexmit);\n\t*rexmit = REXMIT_LOST;\n}\n\nstatic void tcp_update_rtt_min(struct sock *sk, u32 rtt_us, const int flag)\n{\n\tu32 wlen = sock_net(sk)->ipv4.sysctl_tcp_min_rtt_wlen * HZ;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif ((flag & FLAG_ACK_MAYBE_DELAYED) && rtt_us > tcp_min_rtt(tp)) {\n\t\t/* If the remote keeps returning delayed ACKs, eventually\n\t\t * the min filter would pick it up and overestimate the\n\t\t * prop. delay when it expires. Skip suspected delayed ACKs.\n\t\t */\n\t\treturn;\n\t}\n\tminmax_running_min(&tp->rtt_min, wlen, tcp_jiffies32,\n\t\t\t   rtt_us ? : jiffies_to_usecs(1));\n}\n\nstatic bool tcp_ack_update_rtt(struct sock *sk, const int flag,\n\t\t\t       long seq_rtt_us, long sack_rtt_us,\n\t\t\t       long ca_rtt_us, struct rate_sample *rs)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\t/* Prefer RTT measured from ACK's timing to TS-ECR. This is because\n\t * broken middle-boxes or peers may corrupt TS-ECR fields. But\n\t * Karn's algorithm forbids taking RTT if some retransmitted data\n\t * is acked (RFC6298).\n\t */\n\tif (seq_rtt_us < 0)\n\t\tseq_rtt_us = sack_rtt_us;\n\n\t/* RTTM Rule: A TSecr value received in a segment is used to\n\t * update the averaged RTT measurement only if the segment\n\t * acknowledges some new data, i.e., only if it advances the\n\t * left edge of the send window.\n\t * See draft-ietf-tcplw-high-performance-00, section 3.3.\n\t */\n\tif (seq_rtt_us < 0 && tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr &&\n\t    flag & FLAG_ACKED) {\n\t\tu32 delta = tcp_time_stamp(tp) - tp->rx_opt.rcv_tsecr;\n\n\t\tif (likely(delta < INT_MAX / (USEC_PER_SEC / TCP_TS_HZ))) {\n\t\t\tif (!delta)\n\t\t\t\tdelta = 1;\n\t\t\tseq_rtt_us = delta * (USEC_PER_SEC / TCP_TS_HZ);\n\t\t\tca_rtt_us = seq_rtt_us;\n\t\t}\n\t}\n\trs->rtt_us = ca_rtt_us; /* RTT of last (S)ACKed packet (or -1) */\n\tif (seq_rtt_us < 0)\n\t\treturn false;\n\n\t/* ca_rtt_us >= 0 is counting on the invariant that ca_rtt_us is\n\t * always taken together with ACK, SACK, or TS-opts. Any negative\n\t * values will be skipped with the seq_rtt_us < 0 check above.\n\t */\n\ttcp_update_rtt_min(sk, ca_rtt_us, flag);\n\ttcp_rtt_estimator(sk, seq_rtt_us);\n\ttcp_set_rto(sk);\n\n\t/* RFC6298: only reset backoff on valid RTT measurement. */\n\tinet_csk(sk)->icsk_backoff = 0;\n\treturn true;\n}\n\n/* Compute time elapsed between (last) SYNACK and the ACK completing 3WHS. */\nvoid tcp_synack_rtt_meas(struct sock *sk, struct request_sock *req)\n{\n\tstruct rate_sample rs;\n\tlong rtt_us = -1L;\n\n\tif (req && !req->num_retrans && tcp_rsk(req)->snt_synack)\n\t\trtt_us = tcp_stamp_us_delta(tcp_clock_us(), tcp_rsk(req)->snt_synack);\n\n\ttcp_ack_update_rtt(sk, FLAG_SYN_ACKED, rtt_us, -1L, rtt_us, &rs);\n}\n\n\nstatic void tcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\ticsk->icsk_ca_ops->cong_avoid(sk, ack, acked);\n\ttcp_sk(sk)->snd_cwnd_stamp = tcp_jiffies32;\n}\n\n/* Restart timer after forward progress on connection.\n * RFC2988 recommends to restart timer to now+rto.\n */\nvoid tcp_rearm_rto(struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t/* If the retrans timer is currently being used by Fast Open\n\t * for SYN-ACK retrans purpose, stay put.\n\t */\n\tif (rcu_access_pointer(tp->fastopen_rsk))\n\t\treturn;\n\n\tif (!tp->packets_out) {\n\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_RETRANS);\n\t} else {\n\t\tu32 rto = inet_csk(sk)->icsk_rto;\n\t\t/* Offset the time elapsed after installing regular RTO */\n\t\tif (icsk->icsk_pending == ICSK_TIME_REO_TIMEOUT ||\n\t\t    icsk->icsk_pending == ICSK_TIME_LOSS_PROBE) {\n\t\t\ts64 delta_us = tcp_rto_delta_us(sk);\n\t\t\t/* delta_us may not be positive if the socket is locked\n\t\t\t * when the retrans timer fires and is rescheduled.\n\t\t\t */\n\t\t\trto = usecs_to_jiffies(max_t(int, delta_us, 1));\n\t\t}\n\t\ttcp_reset_xmit_timer(sk, ICSK_TIME_RETRANS, rto,\n\t\t\t\t     TCP_RTO_MAX);\n\t}\n}\n\n/* Try to schedule a loss probe; if that doesn't work, then schedule an RTO. */\nstatic void tcp_set_xmit_timer(struct sock *sk)\n{\n\tif (!tcp_schedule_loss_probe(sk, true))\n\t\ttcp_rearm_rto(sk);\n}\n\n/* If we get here, the whole TSO packet has not been acked. */\nstatic u32 tcp_tso_acked(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 packets_acked;\n\n\tBUG_ON(!after(TCP_SKB_CB(skb)->end_seq, tp->snd_una));\n\n\tpackets_acked = tcp_skb_pcount(skb);\n\tif (tcp_trim_head(sk, skb, tp->snd_una - TCP_SKB_CB(skb)->seq))\n\t\treturn 0;\n\tpackets_acked -= tcp_skb_pcount(skb);\n\n\tif (packets_acked) {\n\t\tBUG_ON(tcp_skb_pcount(skb) == 0);\n\t\tBUG_ON(!before(TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq));\n\t}\n\n\treturn packets_acked;\n}\n\nstatic void tcp_ack_tstamp(struct sock *sk, struct sk_buff *skb,\n\t\t\t   u32 prior_snd_una)\n{\n\tconst struct skb_shared_info *shinfo;\n\n\t/* Avoid cache line misses to get skb_shinfo() and shinfo->tx_flags */\n\tif (likely(!TCP_SKB_CB(skb)->txstamp_ack))\n\t\treturn;\n\n\tshinfo = skb_shinfo(skb);\n\tif (!before(shinfo->tskey, prior_snd_una) &&\n\t    before(shinfo->tskey, tcp_sk(sk)->snd_una)) {\n\t\ttcp_skb_tsorted_save(skb) {\n\t\t\t__skb_tstamp_tx(skb, NULL, sk, SCM_TSTAMP_ACK);\n\t\t} tcp_skb_tsorted_restore(skb);\n\t}\n}\n\n/* Remove acknowledged frames from the retransmission queue. If our packet\n * is before the ack sequence we can discard it as it's confirmed to have\n * arrived at the other end.\n */\nstatic int tcp_clean_rtx_queue(struct sock *sk, u32 prior_fack,\n\t\t\t       u32 prior_snd_una,\n\t\t\t       struct tcp_sacktag_state *sack, bool ece_ack)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tu64 first_ackt, last_ackt;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 prior_sacked = tp->sacked_out;\n\tu32 reord = tp->snd_nxt; /* lowest acked un-retx un-sacked seq */\n\tstruct sk_buff *skb, *next;\n\tbool fully_acked = true;\n\tlong sack_rtt_us = -1L;\n\tlong seq_rtt_us = -1L;\n\tlong ca_rtt_us = -1L;\n\tu32 pkts_acked = 0;\n\tu32 last_in_flight = 0;\n\tbool rtt_update;\n\tint flag = 0;\n\n\tfirst_ackt = 0;\n\n\tfor (skb = skb_rb_first(&sk->tcp_rtx_queue); skb; skb = next) {\n\t\tstruct tcp_skb_cb *scb = TCP_SKB_CB(skb);\n\t\tconst u32 start_seq = scb->seq;\n\t\tu8 sacked = scb->sacked;\n\t\tu32 acked_pcount;\n\n\t\t/* Determine how many packets and what bytes were acked, tso and else */\n\t\tif (after(scb->end_seq, tp->snd_una)) {\n\t\t\tif (tcp_skb_pcount(skb) == 1 ||\n\t\t\t    !after(tp->snd_una, scb->seq))\n\t\t\t\tbreak;\n\n\t\t\tacked_pcount = tcp_tso_acked(sk, skb);\n\t\t\tif (!acked_pcount)\n\t\t\t\tbreak;\n\t\t\tfully_acked = false;\n\t\t} else {\n\t\t\tacked_pcount = tcp_skb_pcount(skb);\n\t\t}\n\n\t\tif (unlikely(sacked & TCPCB_RETRANS)) {\n\t\t\tif (sacked & TCPCB_SACKED_RETRANS)\n\t\t\t\ttp->retrans_out -= acked_pcount;\n\t\t\tflag |= FLAG_RETRANS_DATA_ACKED;\n\t\t} else if (!(sacked & TCPCB_SACKED_ACKED)) {\n\t\t\tlast_ackt = tcp_skb_timestamp_us(skb);\n\t\t\tWARN_ON_ONCE(last_ackt == 0);\n\t\t\tif (!first_ackt)\n\t\t\t\tfirst_ackt = last_ackt;\n\n\t\t\tlast_in_flight = TCP_SKB_CB(skb)->tx.in_flight;\n\t\t\tif (before(start_seq, reord))\n\t\t\t\treord = start_seq;\n\t\t\tif (!after(scb->end_seq, tp->high_seq))\n\t\t\t\tflag |= FLAG_ORIG_SACK_ACKED;\n\t\t}\n\n\t\tif (sacked & TCPCB_SACKED_ACKED) {\n\t\t\ttp->sacked_out -= acked_pcount;\n\t\t} else if (tcp_is_sack(tp)) {\n\t\t\ttcp_count_delivered(tp, acked_pcount, ece_ack);\n\t\t\tif (!tcp_skb_spurious_retrans(tp, skb))\n\t\t\t\ttcp_rack_advance(tp, sacked, scb->end_seq,\n\t\t\t\t\t\t tcp_skb_timestamp_us(skb));\n\t\t}\n\t\tif (sacked & TCPCB_LOST)\n\t\t\ttp->lost_out -= acked_pcount;\n\n\t\ttp->packets_out -= acked_pcount;\n\t\tpkts_acked += acked_pcount;\n\t\ttcp_rate_skb_delivered(sk, skb, sack->rate);\n\n\t\t/* Initial outgoing SYN's get put onto the write_queue\n\t\t * just like anything else we transmit.  It is not\n\t\t * true data, and if we misinform our callers that\n\t\t * this ACK acks real data, we will erroneously exit\n\t\t * connection startup slow start one packet too\n\t\t * quickly.  This is severely frowned upon behavior.\n\t\t */\n\t\tif (likely(!(scb->tcp_flags & TCPHDR_SYN))) {\n\t\t\tflag |= FLAG_DATA_ACKED;\n\t\t} else {\n\t\t\tflag |= FLAG_SYN_ACKED;\n\t\t\ttp->retrans_stamp = 0;\n\t\t}\n\n\t\tif (!fully_acked)\n\t\t\tbreak;\n\n\t\ttcp_ack_tstamp(sk, skb, prior_snd_una);\n\n\t\tnext = skb_rb_next(skb);\n\t\tif (unlikely(skb == tp->retransmit_skb_hint))\n\t\t\ttp->retransmit_skb_hint = NULL;\n\t\tif (unlikely(skb == tp->lost_skb_hint))\n\t\t\ttp->lost_skb_hint = NULL;\n\t\ttcp_highest_sack_replace(sk, skb, next);\n\t\ttcp_rtx_queue_unlink_and_free(skb, sk);\n\t}\n\n\tif (!skb)\n\t\ttcp_chrono_stop(sk, TCP_CHRONO_BUSY);\n\n\tif (likely(between(tp->snd_up, prior_snd_una, tp->snd_una)))\n\t\ttp->snd_up = tp->snd_una;\n\n\tif (skb) {\n\t\ttcp_ack_tstamp(sk, skb, prior_snd_una);\n\t\tif (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED)\n\t\t\tflag |= FLAG_SACK_RENEGING;\n\t}\n\n\tif (likely(first_ackt) && !(flag & FLAG_RETRANS_DATA_ACKED)) {\n\t\tseq_rtt_us = tcp_stamp_us_delta(tp->tcp_mstamp, first_ackt);\n\t\tca_rtt_us = tcp_stamp_us_delta(tp->tcp_mstamp, last_ackt);\n\n\t\tif (pkts_acked == 1 && last_in_flight < tp->mss_cache &&\n\t\t    last_in_flight && !prior_sacked && fully_acked &&\n\t\t    sack->rate->prior_delivered + 1 == tp->delivered &&\n\t\t    !(flag & (FLAG_CA_ALERT | FLAG_SYN_ACKED))) {\n\t\t\t/* Conservatively mark a delayed ACK. It's typically\n\t\t\t * from a lone runt packet over the round trip to\n\t\t\t * a receiver w/o out-of-order or CE events.\n\t\t\t */\n\t\t\tflag |= FLAG_ACK_MAYBE_DELAYED;\n\t\t}\n\t}\n\tif (sack->first_sackt) {\n\t\tsack_rtt_us = tcp_stamp_us_delta(tp->tcp_mstamp, sack->first_sackt);\n\t\tca_rtt_us = tcp_stamp_us_delta(tp->tcp_mstamp, sack->last_sackt);\n\t}\n\trtt_update = tcp_ack_update_rtt(sk, flag, seq_rtt_us, sack_rtt_us,\n\t\t\t\t\tca_rtt_us, sack->rate);\n\n\tif (flag & FLAG_ACKED) {\n\t\tflag |= FLAG_SET_XMIT_TIMER;  /* set TLP or RTO timer */\n\t\tif (unlikely(icsk->icsk_mtup.probe_size &&\n\t\t\t     !after(tp->mtu_probe.probe_seq_end, tp->snd_una))) {\n\t\t\ttcp_mtup_probe_success(sk);\n\t\t}\n\n\t\tif (tcp_is_reno(tp)) {\n\t\t\ttcp_remove_reno_sacks(sk, pkts_acked, ece_ack);\n\n\t\t\t/* If any of the cumulatively ACKed segments was\n\t\t\t * retransmitted, non-SACK case cannot confirm that\n\t\t\t * progress was due to original transmission due to\n\t\t\t * lack of TCPCB_SACKED_ACKED bits even if some of\n\t\t\t * the packets may have been never retransmitted.\n\t\t\t */\n\t\t\tif (flag & FLAG_RETRANS_DATA_ACKED)\n\t\t\t\tflag &= ~FLAG_ORIG_SACK_ACKED;\n\t\t} else {\n\t\t\tint delta;\n\n\t\t\t/* Non-retransmitted hole got filled? That's reordering */\n\t\t\tif (before(reord, prior_fack))\n\t\t\t\ttcp_check_sack_reordering(sk, reord, 0);\n\n\t\t\tdelta = prior_sacked - tp->sacked_out;\n\t\t\ttp->lost_cnt_hint -= min(tp->lost_cnt_hint, delta);\n\t\t}\n\t} else if (skb && rtt_update && sack_rtt_us >= 0 &&\n\t\t   sack_rtt_us > tcp_stamp_us_delta(tp->tcp_mstamp,\n\t\t\t\t\t\t    tcp_skb_timestamp_us(skb))) {\n\t\t/* Do not re-arm RTO if the sack RTT is measured from data sent\n\t\t * after when the head was last (re)transmitted. Otherwise the\n\t\t * timeout may continue to extend in loss recovery.\n\t\t */\n\t\tflag |= FLAG_SET_XMIT_TIMER;  /* set TLP or RTO timer */\n\t}\n\n\tif (icsk->icsk_ca_ops->pkts_acked) {\n\t\tstruct ack_sample sample = { .pkts_acked = pkts_acked,\n\t\t\t\t\t     .rtt_us = sack->rate->rtt_us,\n\t\t\t\t\t     .in_flight = last_in_flight };\n\n\t\ticsk->icsk_ca_ops->pkts_acked(sk, &sample);\n\t}\n\n#if FASTRETRANS_DEBUG > 0\n\tWARN_ON((int)tp->sacked_out < 0);\n\tWARN_ON((int)tp->lost_out < 0);\n\tWARN_ON((int)tp->retrans_out < 0);\n\tif (!tp->packets_out && tcp_is_sack(tp)) {\n\t\ticsk = inet_csk(sk);\n\t\tif (tp->lost_out) {\n\t\t\tpr_debug(\"Leak l=%u %d\\n\",\n\t\t\t\t tp->lost_out, icsk->icsk_ca_state);\n\t\t\ttp->lost_out = 0;\n\t\t}\n\t\tif (tp->sacked_out) {\n\t\t\tpr_debug(\"Leak s=%u %d\\n\",\n\t\t\t\t tp->sacked_out, icsk->icsk_ca_state);\n\t\t\ttp->sacked_out = 0;\n\t\t}\n\t\tif (tp->retrans_out) {\n\t\t\tpr_debug(\"Leak r=%u %d\\n\",\n\t\t\t\t tp->retrans_out, icsk->icsk_ca_state);\n\t\t\ttp->retrans_out = 0;\n\t\t}\n\t}\n#endif\n\treturn flag;\n}\n\nstatic void tcp_ack_probe(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct sk_buff *head = tcp_send_head(sk);\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\t/* Was it a usable window open? */\n\tif (!head)\n\t\treturn;\n\tif (!after(TCP_SKB_CB(head)->end_seq, tcp_wnd_end(tp))) {\n\t\ticsk->icsk_backoff = 0;\n\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_PROBE0);\n\t\t/* Socket must be waked up by subsequent tcp_data_snd_check().\n\t\t * This function is not for random using!\n\t\t */\n\t} else {\n\t\tunsigned long when = tcp_probe0_when(sk, TCP_RTO_MAX);\n\n\t\ttcp_reset_xmit_timer(sk, ICSK_TIME_PROBE0,\n\t\t\t\t     when, TCP_RTO_MAX);\n\t}\n}\n\nstatic inline bool tcp_ack_is_dubious(const struct sock *sk, const int flag)\n{\n\treturn !(flag & FLAG_NOT_DUP) || (flag & FLAG_CA_ALERT) ||\n\t\tinet_csk(sk)->icsk_ca_state != TCP_CA_Open;\n}\n\n/* Decide wheather to run the increase function of congestion control. */\nstatic inline bool tcp_may_raise_cwnd(const struct sock *sk, const int flag)\n{\n\t/* If reordering is high then always grow cwnd whenever data is\n\t * delivered regardless of its ordering. Otherwise stay conservative\n\t * and only grow cwnd on in-order delivery (RFC5681). A stretched ACK w/\n\t * new SACK or ECE mark may first advance cwnd here and later reduce\n\t * cwnd in tcp_fastretrans_alert() based on more states.\n\t */\n\tif (tcp_sk(sk)->reordering > sock_net(sk)->ipv4.sysctl_tcp_reordering)\n\t\treturn flag & FLAG_FORWARD_PROGRESS;\n\n\treturn flag & FLAG_DATA_ACKED;\n}\n\n/* The \"ultimate\" congestion control function that aims to replace the rigid\n * cwnd increase and decrease control (tcp_cong_avoid,tcp_*cwnd_reduction).\n * It's called toward the end of processing an ACK with precise rate\n * information. All transmission or retransmission are delayed afterwards.\n */\nstatic void tcp_cong_control(struct sock *sk, u32 ack, u32 acked_sacked,\n\t\t\t     int flag, const struct rate_sample *rs)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ca_ops->cong_control) {\n\t\ticsk->icsk_ca_ops->cong_control(sk, rs);\n\t\treturn;\n\t}\n\n\tif (tcp_in_cwnd_reduction(sk)) {\n\t\t/* Reduce cwnd if state mandates */\n\t\ttcp_cwnd_reduction(sk, acked_sacked, flag);\n\t} else if (tcp_may_raise_cwnd(sk, flag)) {\n\t\t/* Advance cwnd if state allows */\n\t\ttcp_cong_avoid(sk, ack, acked_sacked);\n\t}\n\ttcp_update_pacing_rate(sk);\n}\n\n/* Check that window update is acceptable.\n * The function assumes that snd_una<=ack<=snd_next.\n */\nstatic inline bool tcp_may_update_window(const struct tcp_sock *tp,\n\t\t\t\t\tconst u32 ack, const u32 ack_seq,\n\t\t\t\t\tconst u32 nwin)\n{\n\treturn\tafter(ack, tp->snd_una) ||\n\t\tafter(ack_seq, tp->snd_wl1) ||\n\t\t(ack_seq == tp->snd_wl1 && nwin > tp->snd_wnd);\n}\n\n/* If we update tp->snd_una, also update tp->bytes_acked */\nstatic void tcp_snd_una_update(struct tcp_sock *tp, u32 ack)\n{\n\tu32 delta = ack - tp->snd_una;\n\n\tsock_owned_by_me((struct sock *)tp);\n\ttp->bytes_acked += delta;\n\ttp->snd_una = ack;\n}\n\n/* If we update tp->rcv_nxt, also update tp->bytes_received */\nstatic void tcp_rcv_nxt_update(struct tcp_sock *tp, u32 seq)\n{\n\tu32 delta = seq - tp->rcv_nxt;\n\n\tsock_owned_by_me((struct sock *)tp);\n\ttp->bytes_received += delta;\n\tWRITE_ONCE(tp->rcv_nxt, seq);\n}\n\n/* Update our send window.\n *\n * Window update algorithm, described in RFC793/RFC1122 (used in linux-2.2\n * and in FreeBSD. NetBSD's one is even worse.) is wrong.\n */\nstatic int tcp_ack_update_window(struct sock *sk, const struct sk_buff *skb, u32 ack,\n\t\t\t\t u32 ack_seq)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint flag = 0;\n\tu32 nwin = ntohs(tcp_hdr(skb)->window);\n\n\tif (likely(!tcp_hdr(skb)->syn))\n\t\tnwin <<= tp->rx_opt.snd_wscale;\n\n\tif (tcp_may_update_window(tp, ack, ack_seq, nwin)) {\n\t\tflag |= FLAG_WIN_UPDATE;\n\t\ttcp_update_wl(tp, ack_seq);\n\n\t\tif (tp->snd_wnd != nwin) {\n\t\t\ttp->snd_wnd = nwin;\n\n\t\t\t/* Note, it is the only place, where\n\t\t\t * fast path is recovered for sending TCP.\n\t\t\t */\n\t\t\ttp->pred_flags = 0;\n\t\t\ttcp_fast_path_check(sk);\n\n\t\t\tif (!tcp_write_queue_empty(sk))\n\t\t\t\ttcp_slow_start_after_idle_check(sk);\n\n\t\t\tif (nwin > tp->max_window) {\n\t\t\t\ttp->max_window = nwin;\n\t\t\t\ttcp_sync_mss(sk, inet_csk(sk)->icsk_pmtu_cookie);\n\t\t\t}\n\t\t}\n\t}\n\n\ttcp_snd_una_update(tp, ack);\n\n\treturn flag;\n}\n\nstatic bool __tcp_oow_rate_limited(struct net *net, int mib_idx,\n\t\t\t\t   u32 *last_oow_ack_time)\n{\n\tif (*last_oow_ack_time) {\n\t\ts32 elapsed = (s32)(tcp_jiffies32 - *last_oow_ack_time);\n\n\t\tif (0 <= elapsed && elapsed < net->ipv4.sysctl_tcp_invalid_ratelimit) {\n\t\t\tNET_INC_STATS(net, mib_idx);\n\t\t\treturn true;\t/* rate-limited: don't send yet! */\n\t\t}\n\t}\n\n\t*last_oow_ack_time = tcp_jiffies32;\n\n\treturn false;\t/* not rate-limited: go ahead, send dupack now! */\n}\n\n/* Return true if we're currently rate-limiting out-of-window ACKs and\n * thus shouldn't send a dupack right now. We rate-limit dupacks in\n * response to out-of-window SYNs or ACKs to mitigate ACK loops or DoS\n * attacks that send repeated SYNs or ACKs for the same connection. To\n * do this, we do not send a duplicate SYNACK or ACK if the remote\n * endpoint is sending out-of-window SYNs or pure ACKs at a high rate.\n */\nbool tcp_oow_rate_limited(struct net *net, const struct sk_buff *skb,\n\t\t\t  int mib_idx, u32 *last_oow_ack_time)\n{\n\t/* Data packets without SYNs are not likely part of an ACK loop. */\n\tif ((TCP_SKB_CB(skb)->seq != TCP_SKB_CB(skb)->end_seq) &&\n\t    !tcp_hdr(skb)->syn)\n\t\treturn false;\n\n\treturn __tcp_oow_rate_limited(net, mib_idx, last_oow_ack_time);\n}\n\n/* RFC 5961 7 [ACK Throttling] */\nstatic void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\t/* unprotected vars, we dont care of overwrites */\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tu32 count, now;\n\n\t/* First check our per-socket dupack rate limit. */\n\tif (__tcp_oow_rate_limited(net,\n\t\t\t\t   LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t   &tp->last_oow_ack_time))\n\t\treturn;\n\n\t/* Then check host-wide RFC 5961 rate limit. */\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tu32 ack_limit = net->ipv4.sysctl_tcp_challenge_ack_limit;\n\t\tu32 half = (ack_limit + 1) >> 1;\n\n\t\tchallenge_timestamp = now;\n\t\tWRITE_ONCE(challenge_count, half + prandom_u32_max(ack_limit));\n\t}\n\tcount = READ_ONCE(challenge_count);\n\tif (count > 0) {\n\t\tWRITE_ONCE(challenge_count, count - 1);\n\t\tNET_INC_STATS(net, LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}\n\nstatic void tcp_store_ts_recent(struct tcp_sock *tp)\n{\n\ttp->rx_opt.ts_recent = tp->rx_opt.rcv_tsval;\n\ttp->rx_opt.ts_recent_stamp = ktime_get_seconds();\n}\n\nstatic void tcp_replace_ts_recent(struct tcp_sock *tp, u32 seq)\n{\n\tif (tp->rx_opt.saw_tstamp && !after(seq, tp->rcv_wup)) {\n\t\t/* PAWS bug workaround wrt. ACK frames, the PAWS discard\n\t\t * extra check below makes sure this can only happen\n\t\t * for pure ACK frames.  -DaveM\n\t\t *\n\t\t * Not only, also it occurs for expired timestamps.\n\t\t */\n\n\t\tif (tcp_paws_check(&tp->rx_opt, 0))\n\t\t\ttcp_store_ts_recent(tp);\n\t}\n}\n\n/* This routine deals with acks during a TLP episode and ends an episode by\n * resetting tlp_high_seq. Ref: TLP algorithm in draft-ietf-tcpm-rack\n */\nstatic void tcp_process_tlp_ack(struct sock *sk, u32 ack, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (before(ack, tp->tlp_high_seq))\n\t\treturn;\n\n\tif (!tp->tlp_retrans) {\n\t\t/* TLP of new data has been acknowledged */\n\t\ttp->tlp_high_seq = 0;\n\t} else if (flag & FLAG_DSACKING_ACK) {\n\t\t/* This DSACK means original and TLP probe arrived; no loss */\n\t\ttp->tlp_high_seq = 0;\n\t} else if (after(ack, tp->tlp_high_seq)) {\n\t\t/* ACK advances: there was a loss, so reduce cwnd. Reset\n\t\t * tlp_high_seq in tcp_init_cwnd_reduction()\n\t\t */\n\t\ttcp_init_cwnd_reduction(sk);\n\t\ttcp_set_ca_state(sk, TCP_CA_CWR);\n\t\ttcp_end_cwnd_reduction(sk);\n\t\ttcp_try_keep_open(sk);\n\t\tNET_INC_STATS(sock_net(sk),\n\t\t\t\tLINUX_MIB_TCPLOSSPROBERECOVERY);\n\t} else if (!(flag & (FLAG_SND_UNA_ADVANCED |\n\t\t\t     FLAG_NOT_DUP | FLAG_DATA_SACKED))) {\n\t\t/* Pure dupack: original and TLP probe arrived; no loss */\n\t\ttp->tlp_high_seq = 0;\n\t}\n}\n\nstatic inline void tcp_in_ack_event(struct sock *sk, u32 flags)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ca_ops->in_ack_event)\n\t\ticsk->icsk_ca_ops->in_ack_event(sk, flags);\n}\n\n/* Congestion control has updated the cwnd already. So if we're in\n * loss recovery then now we do any new sends (for FRTO) or\n * retransmits (for CA_Loss or CA_recovery) that make sense.\n */\nstatic void tcp_xmit_recovery(struct sock *sk, int rexmit)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (rexmit == REXMIT_NONE || sk->sk_state == TCP_SYN_SENT)\n\t\treturn;\n\n\tif (unlikely(rexmit == REXMIT_NEW)) {\n\t\t__tcp_push_pending_frames(sk, tcp_current_mss(sk),\n\t\t\t\t\t  TCP_NAGLE_OFF);\n\t\tif (after(tp->snd_nxt, tp->high_seq))\n\t\t\treturn;\n\t\ttp->frto = 0;\n\t}\n\ttcp_xmit_retransmit_queue(sk);\n}\n\n/* Returns the number of packets newly acked or sacked by the current ACK */\nstatic u32 tcp_newly_delivered(struct sock *sk, u32 prior_delivered, int flag)\n{\n\tconst struct net *net = sock_net(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 delivered;\n\n\tdelivered = tp->delivered - prior_delivered;\n\tNET_ADD_STATS(net, LINUX_MIB_TCPDELIVERED, delivered);\n\tif (flag & FLAG_ECE)\n\t\tNET_ADD_STATS(net, LINUX_MIB_TCPDELIVEREDCE, delivered);\n\n\treturn delivered;\n}\n\n/* This routine deals with incoming acks, but not outgoing ones. */\nstatic int tcp_ack(struct sock *sk, const struct sk_buff *skb, int flag)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp_sacktag_state sack_state;\n\tstruct rate_sample rs = { .prior_delivered = 0 };\n\tu32 prior_snd_una = tp->snd_una;\n\tbool is_sack_reneg = tp->is_sack_reneg;\n\tu32 ack_seq = TCP_SKB_CB(skb)->seq;\n\tu32 ack = TCP_SKB_CB(skb)->ack_seq;\n\tint num_dupack = 0;\n\tint prior_packets = tp->packets_out;\n\tu32 delivered = tp->delivered;\n\tu32 lost = tp->lost;\n\tint rexmit = REXMIT_NONE; /* Flag to (re)transmit to recover losses */\n\tu32 prior_fack;\n\n\tsack_state.first_sackt = 0;\n\tsack_state.rate = &rs;\n\tsack_state.sack_delivered = 0;\n\n\t/* We very likely will need to access rtx queue. */\n\tprefetch(sk->tcp_rtx_queue.rb_node);\n\n\t/* If the ack is older than previous acks\n\t * then we can probably ignore it.\n\t */\n\tif (before(ack, prior_snd_una)) {\n\t\t/* RFC 5961 5.2 [Blind Data Injection Attack].[Mitigation] */\n\t\tif (before(ack, prior_snd_una - tp->max_window)) {\n\t\t\tif (!(flag & FLAG_NO_CHALLENGE_ACK))\n\t\t\t\ttcp_send_challenge_ack(sk, skb);\n\t\t\treturn -1;\n\t\t}\n\t\tgoto old_ack;\n\t}\n\n\t/* If the ack includes data we haven't sent yet, discard\n\t * this segment (RFC793 Section 3.9).\n\t */\n\tif (after(ack, tp->snd_nxt))\n\t\treturn -1;\n\n\tif (after(ack, prior_snd_una)) {\n\t\tflag |= FLAG_SND_UNA_ADVANCED;\n\t\ticsk->icsk_retransmits = 0;\n\n#if IS_ENABLED(CONFIG_TLS_DEVICE)\n\t\tif (static_branch_unlikely(&clean_acked_data_enabled.key))\n\t\t\tif (icsk->icsk_clean_acked)\n\t\t\t\ticsk->icsk_clean_acked(sk, ack);\n#endif\n\t}\n\n\tprior_fack = tcp_is_sack(tp) ? tcp_highest_sack_seq(tp) : tp->snd_una;\n\trs.prior_in_flight = tcp_packets_in_flight(tp);\n\n\t/* ts_recent update must be made after we are sure that the packet\n\t * is in window.\n\t */\n\tif (flag & FLAG_UPDATE_TS_RECENT)\n\t\ttcp_replace_ts_recent(tp, TCP_SKB_CB(skb)->seq);\n\n\tif ((flag & (FLAG_SLOWPATH | FLAG_SND_UNA_ADVANCED)) ==\n\t    FLAG_SND_UNA_ADVANCED) {\n\t\t/* Window is constant, pure forward advance.\n\t\t * No more checks are required.\n\t\t * Note, we use the fact that SND.UNA>=SND.WL2.\n\t\t */\n\t\ttcp_update_wl(tp, ack_seq);\n\t\ttcp_snd_una_update(tp, ack);\n\t\tflag |= FLAG_WIN_UPDATE;\n\n\t\ttcp_in_ack_event(sk, CA_ACK_WIN_UPDATE);\n\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPHPACKS);\n\t} else {\n\t\tu32 ack_ev_flags = CA_ACK_SLOWPATH;\n\n\t\tif (ack_seq != TCP_SKB_CB(skb)->end_seq)\n\t\t\tflag |= FLAG_DATA;\n\t\telse\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPPUREACKS);\n\n\t\tflag |= tcp_ack_update_window(sk, skb, ack, ack_seq);\n\n\t\tif (TCP_SKB_CB(skb)->sacked)\n\t\t\tflag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una,\n\t\t\t\t\t\t\t&sack_state);\n\n\t\tif (tcp_ecn_rcv_ecn_echo(tp, tcp_hdr(skb))) {\n\t\t\tflag |= FLAG_ECE;\n\t\t\tack_ev_flags |= CA_ACK_ECE;\n\t\t}\n\n\t\tif (sack_state.sack_delivered)\n\t\t\ttcp_count_delivered(tp, sack_state.sack_delivered,\n\t\t\t\t\t    flag & FLAG_ECE);\n\n\t\tif (flag & FLAG_WIN_UPDATE)\n\t\t\tack_ev_flags |= CA_ACK_WIN_UPDATE;\n\n\t\ttcp_in_ack_event(sk, ack_ev_flags);\n\t}\n\n\t/* This is a deviation from RFC3168 since it states that:\n\t * \"When the TCP data sender is ready to set the CWR bit after reducing\n\t * the congestion window, it SHOULD set the CWR bit only on the first\n\t * new data packet that it transmits.\"\n\t * We accept CWR on pure ACKs to be more robust\n\t * with widely-deployed TCP implementations that do this.\n\t */\n\ttcp_ecn_accept_cwr(sk, skb);\n\n\t/* We passed data and got it acked, remove any soft error\n\t * log. Something worked...\n\t */\n\tsk->sk_err_soft = 0;\n\ticsk->icsk_probes_out = 0;\n\ttp->rcv_tstamp = tcp_jiffies32;\n\tif (!prior_packets)\n\t\tgoto no_queue;\n\n\t/* See if we can take anything off of the retransmit queue. */\n\tflag |= tcp_clean_rtx_queue(sk, prior_fack, prior_snd_una, &sack_state,\n\t\t\t\t    flag & FLAG_ECE);\n\n\ttcp_rack_update_reo_wnd(sk, &rs);\n\n\tif (tp->tlp_high_seq)\n\t\ttcp_process_tlp_ack(sk, ack, flag);\n\t/* If needed, reset TLP/RTO timer; RACK may later override this. */\n\tif (flag & FLAG_SET_XMIT_TIMER)\n\t\ttcp_set_xmit_timer(sk);\n\n\tif (tcp_ack_is_dubious(sk, flag)) {\n\t\tif (!(flag & (FLAG_SND_UNA_ADVANCED | FLAG_NOT_DUP))) {\n\t\t\tnum_dupack = 1;\n\t\t\t/* Consider if pure acks were aggregated in tcp_add_backlog() */\n\t\t\tif (!(flag & FLAG_DATA))\n\t\t\t\tnum_dupack = max_t(u16, 1, skb_shinfo(skb)->gso_segs);\n\t\t}\n\t\ttcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &flag,\n\t\t\t\t      &rexmit);\n\t}\n\n\tif ((flag & FLAG_FORWARD_PROGRESS) || !(flag & FLAG_NOT_DUP))\n\t\tsk_dst_confirm(sk);\n\n\tdelivered = tcp_newly_delivered(sk, delivered, flag);\n\tlost = tp->lost - lost;\t\t\t/* freshly marked lost */\n\trs.is_ack_delayed = !!(flag & FLAG_ACK_MAYBE_DELAYED);\n\ttcp_rate_gen(sk, delivered, lost, is_sack_reneg, sack_state.rate);\n\ttcp_cong_control(sk, ack, delivered, flag, sack_state.rate);\n\ttcp_xmit_recovery(sk, rexmit);\n\treturn 1;\n\nno_queue:\n\t/* If data was DSACKed, see if we can undo a cwnd reduction. */\n\tif (flag & FLAG_DSACKING_ACK) {\n\t\ttcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &flag,\n\t\t\t\t      &rexmit);\n\t\ttcp_newly_delivered(sk, delivered, flag);\n\t}\n\t/* If this ack opens up a zero window, clear backoff.  It was\n\t * being used to time the probes, and is probably far higher than\n\t * it needs to be for normal retransmission.\n\t */\n\ttcp_ack_probe(sk);\n\n\tif (tp->tlp_high_seq)\n\t\ttcp_process_tlp_ack(sk, ack, flag);\n\treturn 1;\n\nold_ack:\n\t/* If data was SACKed, tag it and see if we should send more data.\n\t * If data was DSACKed, see if we can undo a cwnd reduction.\n\t */\n\tif (TCP_SKB_CB(skb)->sacked) {\n\t\tflag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una,\n\t\t\t\t\t\t&sack_state);\n\t\ttcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &flag,\n\t\t\t\t      &rexmit);\n\t\ttcp_newly_delivered(sk, delivered, flag);\n\t\ttcp_xmit_recovery(sk, rexmit);\n\t}\n\n\treturn 0;\n}\n\nstatic void tcp_parse_fastopen_option(int len, const unsigned char *cookie,\n\t\t\t\t      bool syn, struct tcp_fastopen_cookie *foc,\n\t\t\t\t      bool exp_opt)\n{\n\t/* Valid only in SYN or SYN-ACK with an even length.  */\n\tif (!foc || !syn || len < 0 || (len & 1))\n\t\treturn;\n\n\tif (len >= TCP_FASTOPEN_COOKIE_MIN &&\n\t    len <= TCP_FASTOPEN_COOKIE_MAX)\n\t\tmemcpy(foc->val, cookie, len);\n\telse if (len != 0)\n\t\tlen = -1;\n\tfoc->len = len;\n\tfoc->exp = exp_opt;\n}\n\nstatic bool smc_parse_options(const struct tcphdr *th,\n\t\t\t      struct tcp_options_received *opt_rx,\n\t\t\t      const unsigned char *ptr,\n\t\t\t      int opsize)\n{\n#if IS_ENABLED(CONFIG_SMC)\n\tif (static_branch_unlikely(&tcp_have_smc)) {\n\t\tif (th->syn && !(opsize & 1) &&\n\t\t    opsize >= TCPOLEN_EXP_SMC_BASE &&\n\t\t    get_unaligned_be32(ptr) == TCPOPT_SMC_MAGIC) {\n\t\t\topt_rx->smc_ok = 1;\n\t\t\treturn true;\n\t\t}\n\t}\n#endif\n\treturn false;\n}\n\n/* Try to parse the MSS option from the TCP header. Return 0 on failure, clamped\n * value on success.\n */\nstatic u16 tcp_parse_mss_option(const struct tcphdr *th, u16 user_mss)\n{\n\tconst unsigned char *ptr = (const unsigned char *)(th + 1);\n\tint length = (th->doff * 4) - sizeof(struct tcphdr);\n\tu16 mss = 0;\n\n\twhile (length > 0) {\n\t\tint opcode = *ptr++;\n\t\tint opsize;\n\n\t\tswitch (opcode) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn mss;\n\t\tcase TCPOPT_NOP:\t/* Ref: RFC 793 section 3.1 */\n\t\t\tlength--;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (length < 2)\n\t\t\t\treturn mss;\n\t\t\topsize = *ptr++;\n\t\t\tif (opsize < 2) /* \"silly options\" */\n\t\t\t\treturn mss;\n\t\t\tif (opsize > length)\n\t\t\t\treturn mss;\t/* fail on partial options */\n\t\t\tif (opcode == TCPOPT_MSS && opsize == TCPOLEN_MSS) {\n\t\t\t\tu16 in_mss = get_unaligned_be16(ptr);\n\n\t\t\t\tif (in_mss) {\n\t\t\t\t\tif (user_mss && user_mss < in_mss)\n\t\t\t\t\t\tin_mss = user_mss;\n\t\t\t\t\tmss = in_mss;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr += opsize - 2;\n\t\t\tlength -= opsize;\n\t\t}\n\t}\n\treturn mss;\n}\n\n/* Look for tcp options. Normally only called on SYN and SYNACK packets.\n * But, this can also be called on packets in the established flow when\n * the fast version below fails.\n */\nvoid tcp_parse_options(const struct net *net,\n\t\t       const struct sk_buff *skb,\n\t\t       struct tcp_options_received *opt_rx, int estab,\n\t\t       struct tcp_fastopen_cookie *foc)\n{\n\tconst unsigned char *ptr;\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tint length = (th->doff * 4) - sizeof(struct tcphdr);\n\n\tptr = (const unsigned char *)(th + 1);\n\topt_rx->saw_tstamp = 0;\n\topt_rx->saw_unknown = 0;\n\n\twhile (length > 0) {\n\t\tint opcode = *ptr++;\n\t\tint opsize;\n\n\t\tswitch (opcode) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn;\n\t\tcase TCPOPT_NOP:\t/* Ref: RFC 793 section 3.1 */\n\t\t\tlength--;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (length < 2)\n\t\t\t\treturn;\n\t\t\topsize = *ptr++;\n\t\t\tif (opsize < 2) /* \"silly options\" */\n\t\t\t\treturn;\n\t\t\tif (opsize > length)\n\t\t\t\treturn;\t/* don't parse partial options */\n\t\t\tswitch (opcode) {\n\t\t\tcase TCPOPT_MSS:\n\t\t\t\tif (opsize == TCPOLEN_MSS && th->syn && !estab) {\n\t\t\t\t\tu16 in_mss = get_unaligned_be16(ptr);\n\t\t\t\t\tif (in_mss) {\n\t\t\t\t\t\tif (opt_rx->user_mss &&\n\t\t\t\t\t\t    opt_rx->user_mss < in_mss)\n\t\t\t\t\t\t\tin_mss = opt_rx->user_mss;\n\t\t\t\t\t\topt_rx->mss_clamp = in_mss;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TCPOPT_WINDOW:\n\t\t\t\tif (opsize == TCPOLEN_WINDOW && th->syn &&\n\t\t\t\t    !estab && net->ipv4.sysctl_tcp_window_scaling) {\n\t\t\t\t\t__u8 snd_wscale = *(__u8 *)ptr;\n\t\t\t\t\topt_rx->wscale_ok = 1;\n\t\t\t\t\tif (snd_wscale > TCP_MAX_WSCALE) {\n\t\t\t\t\t\tnet_info_ratelimited(\"%s: Illegal window scaling value %d > %u received\\n\",\n\t\t\t\t\t\t\t\t     __func__,\n\t\t\t\t\t\t\t\t     snd_wscale,\n\t\t\t\t\t\t\t\t     TCP_MAX_WSCALE);\n\t\t\t\t\t\tsnd_wscale = TCP_MAX_WSCALE;\n\t\t\t\t\t}\n\t\t\t\t\topt_rx->snd_wscale = snd_wscale;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TCPOPT_TIMESTAMP:\n\t\t\t\tif ((opsize == TCPOLEN_TIMESTAMP) &&\n\t\t\t\t    ((estab && opt_rx->tstamp_ok) ||\n\t\t\t\t     (!estab && net->ipv4.sysctl_tcp_timestamps))) {\n\t\t\t\t\topt_rx->saw_tstamp = 1;\n\t\t\t\t\topt_rx->rcv_tsval = get_unaligned_be32(ptr);\n\t\t\t\t\topt_rx->rcv_tsecr = get_unaligned_be32(ptr + 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TCPOPT_SACK_PERM:\n\t\t\t\tif (opsize == TCPOLEN_SACK_PERM && th->syn &&\n\t\t\t\t    !estab && net->ipv4.sysctl_tcp_sack) {\n\t\t\t\t\topt_rx->sack_ok = TCP_SACK_SEEN;\n\t\t\t\t\ttcp_sack_reset(opt_rx);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TCPOPT_SACK:\n\t\t\t\tif ((opsize >= (TCPOLEN_SACK_BASE + TCPOLEN_SACK_PERBLOCK)) &&\n\t\t\t\t   !((opsize - TCPOLEN_SACK_BASE) % TCPOLEN_SACK_PERBLOCK) &&\n\t\t\t\t   opt_rx->sack_ok) {\n\t\t\t\t\tTCP_SKB_CB(skb)->sacked = (ptr - 2) - (unsigned char *)th;\n\t\t\t\t}\n\t\t\t\tbreak;\n#ifdef CONFIG_TCP_MD5SIG\n\t\t\tcase TCPOPT_MD5SIG:\n\t\t\t\t/*\n\t\t\t\t * The MD5 Hash has already been\n\t\t\t\t * checked (see tcp_v{4,6}_do_rcv()).\n\t\t\t\t */\n\t\t\t\tbreak;\n#endif\n\t\t\tcase TCPOPT_FASTOPEN:\n\t\t\t\ttcp_parse_fastopen_option(\n\t\t\t\t\topsize - TCPOLEN_FASTOPEN_BASE,\n\t\t\t\t\tptr, th->syn, foc, false);\n\t\t\t\tbreak;\n\n\t\t\tcase TCPOPT_EXP:\n\t\t\t\t/* Fast Open option shares code 254 using a\n\t\t\t\t * 16 bits magic number.\n\t\t\t\t */\n\t\t\t\tif (opsize >= TCPOLEN_EXP_FASTOPEN_BASE &&\n\t\t\t\t    get_unaligned_be16(ptr) ==\n\t\t\t\t    TCPOPT_FASTOPEN_MAGIC) {\n\t\t\t\t\ttcp_parse_fastopen_option(opsize -\n\t\t\t\t\t\tTCPOLEN_EXP_FASTOPEN_BASE,\n\t\t\t\t\t\tptr + 2, th->syn, foc, true);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (smc_parse_options(th, opt_rx, ptr, opsize))\n\t\t\t\t\tbreak;\n\n\t\t\t\topt_rx->saw_unknown = 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\topt_rx->saw_unknown = 1;\n\t\t\t}\n\t\t\tptr += opsize-2;\n\t\t\tlength -= opsize;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(tcp_parse_options);\n\nstatic bool tcp_parse_aligned_timestamp(struct tcp_sock *tp, const struct tcphdr *th)\n{\n\tconst __be32 *ptr = (const __be32 *)(th + 1);\n\n\tif (*ptr == htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16)\n\t\t\t  | (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP)) {\n\t\ttp->rx_opt.saw_tstamp = 1;\n\t\t++ptr;\n\t\ttp->rx_opt.rcv_tsval = ntohl(*ptr);\n\t\t++ptr;\n\t\tif (*ptr)\n\t\t\ttp->rx_opt.rcv_tsecr = ntohl(*ptr) - tp->tsoffset;\n\t\telse\n\t\t\ttp->rx_opt.rcv_tsecr = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* Fast parse options. This hopes to only see timestamps.\n * If it is wrong it falls back on tcp_parse_options().\n */\nstatic bool tcp_fast_parse_options(const struct net *net,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   const struct tcphdr *th, struct tcp_sock *tp)\n{\n\t/* In the spirit of fast parsing, compare doff directly to constant\n\t * values.  Because equality is used, short doff can be ignored here.\n\t */\n\tif (th->doff == (sizeof(*th) / 4)) {\n\t\ttp->rx_opt.saw_tstamp = 0;\n\t\treturn false;\n\t} else if (tp->rx_opt.tstamp_ok &&\n\t\t   th->doff == ((sizeof(*th) + TCPOLEN_TSTAMP_ALIGNED) / 4)) {\n\t\tif (tcp_parse_aligned_timestamp(tp, th))\n\t\t\treturn true;\n\t}\n\n\ttcp_parse_options(net, skb, &tp->rx_opt, 1, NULL);\n\tif (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr)\n\t\ttp->rx_opt.rcv_tsecr -= tp->tsoffset;\n\n\treturn true;\n}\n\n#ifdef CONFIG_TCP_MD5SIG\n/*\n * Parse MD5 Signature option\n */\nconst u8 *tcp_parse_md5sig_option(const struct tcphdr *th)\n{\n\tint length = (th->doff << 2) - sizeof(*th);\n\tconst u8 *ptr = (const u8 *)(th + 1);\n\n\t/* If not enough data remaining, we can short cut */\n\twhile (length >= TCPOLEN_MD5SIG) {\n\t\tint opcode = *ptr++;\n\t\tint opsize;\n\n\t\tswitch (opcode) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn NULL;\n\t\tcase TCPOPT_NOP:\n\t\t\tlength--;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\topsize = *ptr++;\n\t\t\tif (opsize < 2 || opsize > length)\n\t\t\t\treturn NULL;\n\t\t\tif (opcode == TCPOPT_MD5SIG)\n\t\t\t\treturn opsize == TCPOLEN_MD5SIG ? ptr : NULL;\n\t\t}\n\t\tptr += opsize - 2;\n\t\tlength -= opsize;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(tcp_parse_md5sig_option);\n#endif\n\n/* Sorry, PAWS as specified is broken wrt. pure-ACKs -DaveM\n *\n * It is not fatal. If this ACK does _not_ change critical state (seqs, window)\n * it can pass through stack. So, the following predicate verifies that\n * this segment is not used for anything but congestion avoidance or\n * fast retransmit. Moreover, we even are able to eliminate most of such\n * second order effects, if we apply some small \"replay\" window (~RTO)\n * to timestamp space.\n *\n * All these measures still do not guarantee that we reject wrapped ACKs\n * on networks with high bandwidth, when sequence space is recycled fastly,\n * but it guarantees that such events will be very rare and do not affect\n * connection seriously. This doesn't look nice, but alas, PAWS is really\n * buggy extension.\n *\n * [ Later note. Even worse! It is buggy for segments _with_ data. RFC\n * states that events when retransmit arrives after original data are rare.\n * It is a blatant lie. VJ forgot about fast retransmit! 8)8) It is\n * the biggest problem on large power networks even with minor reordering.\n * OK, let's give it small replay window. If peer clock is even 1hz, it is safe\n * up to bandwidth of 18Gigabit/sec. 8) ]\n */\n\nstatic int tcp_disordered_ack(const struct sock *sk, const struct sk_buff *skb)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tu32 seq = TCP_SKB_CB(skb)->seq;\n\tu32 ack = TCP_SKB_CB(skb)->ack_seq;\n\n\treturn (/* 1. Pure ACK with correct sequence number. */\n\t\t(th->ack && seq == TCP_SKB_CB(skb)->end_seq && seq == tp->rcv_nxt) &&\n\n\t\t/* 2. ... and duplicate ACK. */\n\t\tack == tp->snd_una &&\n\n\t\t/* 3. ... and does not update window. */\n\t\t!tcp_may_update_window(tp, ack, seq, ntohs(th->window) << tp->rx_opt.snd_wscale) &&\n\n\t\t/* 4. ... and sits in replay window. */\n\t\t(s32)(tp->rx_opt.ts_recent - tp->rx_opt.rcv_tsval) <= (inet_csk(sk)->icsk_rto * 1024) / HZ);\n}\n\nstatic inline bool tcp_paws_discard(const struct sock *sk,\n\t\t\t\t   const struct sk_buff *skb)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\treturn !tcp_paws_check(&tp->rx_opt, TCP_PAWS_WINDOW) &&\n\t       !tcp_disordered_ack(sk, skb);\n}\n\n/* Check segment sequence number for validity.\n *\n * Segment controls are considered valid, if the segment\n * fits to the window after truncation to the window. Acceptability\n * of data (and SYN, FIN, of course) is checked separately.\n * See tcp_data_queue(), for example.\n *\n * Also, controls (RST is main one) are accepted using RCV.WUP instead\n * of RCV.NXT. Peer still did not advance his SND.UNA when we\n * delayed ACK, so that hisSND.UNA<=ourRCV.WUP.\n * (borrowed from freebsd)\n */\n\nstatic inline bool tcp_sequence(const struct tcp_sock *tp, u32 seq, u32 end_seq)\n{\n\treturn\t!before(end_seq, tp->rcv_wup) &&\n\t\t!after(seq, tp->rcv_nxt + tcp_receive_window(tp));\n}\n\n/* When we get a reset we do this. */\nvoid tcp_reset(struct sock *sk)\n{\n\ttrace_tcp_receive_reset(sk);\n\n\t/* We want the right error as BSD sees it (and indeed as we do). */\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_SENT:\n\t\tsk->sk_err = ECONNREFUSED;\n\t\tbreak;\n\tcase TCP_CLOSE_WAIT:\n\t\tsk->sk_err = EPIPE;\n\t\tbreak;\n\tcase TCP_CLOSE:\n\t\treturn;\n\tdefault:\n\t\tsk->sk_err = ECONNRESET;\n\t}\n\t/* This barrier is coupled with smp_rmb() in tcp_poll() */\n\tsmp_wmb();\n\n\ttcp_write_queue_purge(sk);\n\ttcp_done(sk);\n\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_error_report(sk);\n}\n\n/*\n * \tProcess the FIN bit. This now behaves as it is supposed to work\n *\tand the FIN takes effect when it is validly part of sequence\n *\tspace. Not before when we get holes.\n *\n *\tIf we are ESTABLISHED, a received fin moves us to CLOSE-WAIT\n *\t(and thence onto LAST-ACK and finally, CLOSE, we never enter\n *\tTIME-WAIT)\n *\n *\tIf we are in FINWAIT-1, a received FIN indicates simultaneous\n *\tclose and we go into CLOSING (and later onto TIME-WAIT)\n *\n *\tIf we are in FINWAIT-2, a received FIN moves us to TIME-WAIT.\n */\nvoid tcp_fin(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tinet_csk_schedule_ack(sk);\n\n\tsk->sk_shutdown |= RCV_SHUTDOWN;\n\tsock_set_flag(sk, SOCK_DONE);\n\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_RECV:\n\tcase TCP_ESTABLISHED:\n\t\t/* Move to CLOSE_WAIT */\n\t\ttcp_set_state(sk, TCP_CLOSE_WAIT);\n\t\tinet_csk_enter_pingpong_mode(sk);\n\t\tbreak;\n\n\tcase TCP_CLOSE_WAIT:\n\tcase TCP_CLOSING:\n\t\t/* Received a retransmission of the FIN, do\n\t\t * nothing.\n\t\t */\n\t\tbreak;\n\tcase TCP_LAST_ACK:\n\t\t/* RFC793: Remain in the LAST-ACK state. */\n\t\tbreak;\n\n\tcase TCP_FIN_WAIT1:\n\t\t/* This case occurs when a simultaneous close\n\t\t * happens, we must ack the received FIN and\n\t\t * enter the CLOSING state.\n\t\t */\n\t\ttcp_send_ack(sk);\n\t\ttcp_set_state(sk, TCP_CLOSING);\n\t\tbreak;\n\tcase TCP_FIN_WAIT2:\n\t\t/* Received a FIN -- send ACK and enter TIME_WAIT. */\n\t\ttcp_send_ack(sk);\n\t\ttcp_time_wait(sk, TCP_TIME_WAIT, 0);\n\t\tbreak;\n\tdefault:\n\t\t/* Only TCP_LISTEN and TCP_CLOSE are left, in these\n\t\t * cases we should never reach this piece of code.\n\t\t */\n\t\tpr_err(\"%s: Impossible, sk->sk_state=%d\\n\",\n\t\t       __func__, sk->sk_state);\n\t\tbreak;\n\t}\n\n\t/* It _is_ possible, that we have something out-of-order _after_ FIN.\n\t * Probably, we should reset in this case. For now drop them.\n\t */\n\tskb_rbtree_purge(&tp->out_of_order_queue);\n\tif (tcp_is_sack(tp))\n\t\ttcp_sack_reset(&tp->rx_opt);\n\tsk_mem_reclaim(sk);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\n\t\t/* Do not send POLL_HUP for half duplex close. */\n\t\tif (sk->sk_shutdown == SHUTDOWN_MASK ||\n\t\t    sk->sk_state == TCP_CLOSE)\n\t\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);\n\t\telse\n\t\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\t}\n}\n\nstatic inline bool tcp_sack_extend(struct tcp_sack_block *sp, u32 seq,\n\t\t\t\t  u32 end_seq)\n{\n\tif (!after(seq, sp->end_seq) && !after(sp->start_seq, end_seq)) {\n\t\tif (before(seq, sp->start_seq))\n\t\t\tsp->start_seq = seq;\n\t\tif (after(end_seq, sp->end_seq))\n\t\t\tsp->end_seq = end_seq;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void tcp_dsack_set(struct sock *sk, u32 seq, u32 end_seq)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_is_sack(tp) && sock_net(sk)->ipv4.sysctl_tcp_dsack) {\n\t\tint mib_idx;\n\n\t\tif (before(seq, tp->rcv_nxt))\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOLDSENT;\n\t\telse\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOFOSENT;\n\n\t\tNET_INC_STATS(sock_net(sk), mib_idx);\n\n\t\ttp->rx_opt.dsack = 1;\n\t\ttp->duplicate_sack[0].start_seq = seq;\n\t\ttp->duplicate_sack[0].end_seq = end_seq;\n\t}\n}\n\nstatic void tcp_dsack_extend(struct sock *sk, u32 seq, u32 end_seq)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (!tp->rx_opt.dsack)\n\t\ttcp_dsack_set(sk, seq, end_seq);\n\telse\n\t\ttcp_sack_extend(tp->duplicate_sack, seq, end_seq);\n}\n\nstatic void tcp_rcv_spurious_retrans(struct sock *sk, const struct sk_buff *skb)\n{\n\t/* When the ACK path fails or drops most ACKs, the sender would\n\t * timeout and spuriously retransmit the same segment repeatedly.\n\t * The receiver remembers and reflects via DSACKs. Leverage the\n\t * DSACK state and change the txhash to re-route speculatively.\n\t */\n\tif (TCP_SKB_CB(skb)->seq == tcp_sk(sk)->duplicate_sack[0].start_seq) {\n\t\tsk_rethink_txhash(sk);\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDUPLICATEDATAREHASH);\n\t}\n}\n\nstatic void tcp_send_dupack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\n\t    before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_DELAYEDACKLOST);\n\t\ttcp_enter_quickack_mode(sk, TCP_MAX_QUICKACKS);\n\n\t\tif (tcp_is_sack(tp) && sock_net(sk)->ipv4.sysctl_tcp_dsack) {\n\t\t\tu32 end_seq = TCP_SKB_CB(skb)->end_seq;\n\n\t\t\ttcp_rcv_spurious_retrans(sk, skb);\n\t\t\tif (after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt))\n\t\t\t\tend_seq = tp->rcv_nxt;\n\t\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)->seq, end_seq);\n\t\t}\n\t}\n\n\ttcp_send_ack(sk);\n}\n\n/* These routines update the SACK block as out-of-order packets arrive or\n * in-order packets close up the sequence space.\n */\nstatic void tcp_sack_maybe_coalesce(struct tcp_sock *tp)\n{\n\tint this_sack;\n\tstruct tcp_sack_block *sp = &tp->selective_acks[0];\n\tstruct tcp_sack_block *swalk = sp + 1;\n\n\t/* See if the recent change to the first SACK eats into\n\t * or hits the sequence space of other SACK blocks, if so coalesce.\n\t */\n\tfor (this_sack = 1; this_sack < tp->rx_opt.num_sacks;) {\n\t\tif (tcp_sack_extend(sp, swalk->start_seq, swalk->end_seq)) {\n\t\t\tint i;\n\n\t\t\t/* Zap SWALK, by moving every further SACK up by one slot.\n\t\t\t * Decrease num_sacks.\n\t\t\t */\n\t\t\ttp->rx_opt.num_sacks--;\n\t\t\tfor (i = this_sack; i < tp->rx_opt.num_sacks; i++)\n\t\t\t\tsp[i] = sp[i + 1];\n\t\t\tcontinue;\n\t\t}\n\t\tthis_sack++;\n\t\tswalk++;\n\t}\n}\n\nstatic void tcp_sack_compress_send_ack(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (!tp->compressed_ack)\n\t\treturn;\n\n\tif (hrtimer_try_to_cancel(&tp->compressed_ack_timer) == 1)\n\t\t__sock_put(sk);\n\n\t/* Since we have to send one ack finally,\n\t * substract one from tp->compressed_ack to keep\n\t * LINUX_MIB_TCPACKCOMPRESSED accurate.\n\t */\n\tNET_ADD_STATS(sock_net(sk), LINUX_MIB_TCPACKCOMPRESSED,\n\t\t      tp->compressed_ack - 1);\n\n\ttp->compressed_ack = 0;\n\ttcp_send_ack(sk);\n}\n\n/* Reasonable amount of sack blocks included in TCP SACK option\n * The max is 4, but this becomes 3 if TCP timestamps are there.\n * Given that SACK packets might be lost, be conservative and use 2.\n */\n#define TCP_SACK_BLOCKS_EXPECTED 2\n\nstatic void tcp_sack_new_ofo_skb(struct sock *sk, u32 seq, u32 end_seq)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp_sack_block *sp = &tp->selective_acks[0];\n\tint cur_sacks = tp->rx_opt.num_sacks;\n\tint this_sack;\n\n\tif (!cur_sacks)\n\t\tgoto new_sack;\n\n\tfor (this_sack = 0; this_sack < cur_sacks; this_sack++, sp++) {\n\t\tif (tcp_sack_extend(sp, seq, end_seq)) {\n\t\t\tif (this_sack >= TCP_SACK_BLOCKS_EXPECTED)\n\t\t\t\ttcp_sack_compress_send_ack(sk);\n\t\t\t/* Rotate this_sack to the first one. */\n\t\t\tfor (; this_sack > 0; this_sack--, sp--)\n\t\t\t\tswap(*sp, *(sp - 1));\n\t\t\tif (cur_sacks > 1)\n\t\t\t\ttcp_sack_maybe_coalesce(tp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (this_sack >= TCP_SACK_BLOCKS_EXPECTED)\n\t\ttcp_sack_compress_send_ack(sk);\n\n\t/* Could not find an adjacent existing SACK, build a new one,\n\t * put it at the front, and shift everyone else down.  We\n\t * always know there is at least one SACK present already here.\n\t *\n\t * If the sack array is full, forget about the last one.\n\t */\n\tif (this_sack >= TCP_NUM_SACKS) {\n\t\tthis_sack--;\n\t\ttp->rx_opt.num_sacks--;\n\t\tsp--;\n\t}\n\tfor (; this_sack > 0; this_sack--, sp--)\n\t\t*sp = *(sp - 1);\n\nnew_sack:\n\t/* Build the new head SACK, and we're done. */\n\tsp->start_seq = seq;\n\tsp->end_seq = end_seq;\n\ttp->rx_opt.num_sacks++;\n}\n\n/* RCV.NXT advances, some SACKs should be eaten. */\n\nstatic void tcp_sack_remove(struct tcp_sock *tp)\n{\n\tstruct tcp_sack_block *sp = &tp->selective_acks[0];\n\tint num_sacks = tp->rx_opt.num_sacks;\n\tint this_sack;\n\n\t/* Empty ofo queue, hence, all the SACKs are eaten. Clear. */\n\tif (RB_EMPTY_ROOT(&tp->out_of_order_queue)) {\n\t\ttp->rx_opt.num_sacks = 0;\n\t\treturn;\n\t}\n\n\tfor (this_sack = 0; this_sack < num_sacks;) {\n\t\t/* Check if the start of the sack is covered by RCV.NXT. */\n\t\tif (!before(tp->rcv_nxt, sp->start_seq)) {\n\t\t\tint i;\n\n\t\t\t/* RCV.NXT must cover all the block! */\n\t\t\tWARN_ON(before(tp->rcv_nxt, sp->end_seq));\n\n\t\t\t/* Zap this SACK, by moving forward any other SACKS. */\n\t\t\tfor (i = this_sack+1; i < num_sacks; i++)\n\t\t\t\ttp->selective_acks[i-1] = tp->selective_acks[i];\n\t\t\tnum_sacks--;\n\t\t\tcontinue;\n\t\t}\n\t\tthis_sack++;\n\t\tsp++;\n\t}\n\ttp->rx_opt.num_sacks = num_sacks;\n}\n\n/**\n * tcp_try_coalesce - try to merge skb to prior one\n * @sk: socket\n * @to: prior buffer\n * @from: buffer to add in queue\n * @fragstolen: pointer to boolean\n *\n * Before queueing skb @from after @to, try to merge them\n * to reduce overall memory use and queue lengths, if cost is small.\n * Packets in ofo or receive queues can stay a long time.\n * Better try to coalesce them right now to avoid future collapses.\n * Returns true if caller should free @from instead of queueing it\n */\nstatic bool tcp_try_coalesce(struct sock *sk,\n\t\t\t     struct sk_buff *to,\n\t\t\t     struct sk_buff *from,\n\t\t\t     bool *fragstolen)\n{\n\tint delta;\n\n\t*fragstolen = false;\n\n\t/* Its possible this segment overlaps with prior segment in queue */\n\tif (TCP_SKB_CB(from)->seq != TCP_SKB_CB(to)->end_seq)\n\t\treturn false;\n\n\tif (!mptcp_skb_can_collapse(to, from))\n\t\treturn false;\n\n#ifdef CONFIG_TLS_DEVICE\n\tif (from->decrypted != to->decrypted)\n\t\treturn false;\n#endif\n\n\tif (!skb_try_coalesce(to, from, fragstolen, &delta))\n\t\treturn false;\n\n\tatomic_add(delta, &sk->sk_rmem_alloc);\n\tsk_mem_charge(sk, delta);\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRCVCOALESCE);\n\tTCP_SKB_CB(to)->end_seq = TCP_SKB_CB(from)->end_seq;\n\tTCP_SKB_CB(to)->ack_seq = TCP_SKB_CB(from)->ack_seq;\n\tTCP_SKB_CB(to)->tcp_flags |= TCP_SKB_CB(from)->tcp_flags;\n\n\tif (TCP_SKB_CB(from)->has_rxtstamp) {\n\t\tTCP_SKB_CB(to)->has_rxtstamp = true;\n\t\tto->tstamp = from->tstamp;\n\t\tskb_hwtstamps(to)->hwtstamp = skb_hwtstamps(from)->hwtstamp;\n\t}\n\n\treturn true;\n}\n\nstatic bool tcp_ooo_try_coalesce(struct sock *sk,\n\t\t\t     struct sk_buff *to,\n\t\t\t     struct sk_buff *from,\n\t\t\t     bool *fragstolen)\n{\n\tbool res = tcp_try_coalesce(sk, to, from, fragstolen);\n\n\t/* In case tcp_drop() is called later, update to->gso_segs */\n\tif (res) {\n\t\tu32 gso_segs = max_t(u16, 1, skb_shinfo(to)->gso_segs) +\n\t\t\t       max_t(u16, 1, skb_shinfo(from)->gso_segs);\n\n\t\tskb_shinfo(to)->gso_segs = min_t(u32, gso_segs, 0xFFFF);\n\t}\n\treturn res;\n}\n\nstatic void tcp_drop(struct sock *sk, struct sk_buff *skb)\n{\n\tsk_drops_add(sk, skb);\n\t__kfree_skb(skb);\n}\n\n/* This one checks to see if we can put data from the\n * out_of_order queue into the receive_queue.\n */\nstatic void tcp_ofo_queue(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t__u32 dsack_high = tp->rcv_nxt;\n\tbool fin, fragstolen, eaten;\n\tstruct sk_buff *skb, *tail;\n\tstruct rb_node *p;\n\n\tp = rb_first(&tp->out_of_order_queue);\n\twhile (p) {\n\t\tskb = rb_to_skb(p);\n\t\tif (after(TCP_SKB_CB(skb)->seq, tp->rcv_nxt))\n\t\t\tbreak;\n\n\t\tif (before(TCP_SKB_CB(skb)->seq, dsack_high)) {\n\t\t\t__u32 dsack = dsack_high;\n\t\t\tif (before(TCP_SKB_CB(skb)->end_seq, dsack_high))\n\t\t\t\tdsack_high = TCP_SKB_CB(skb)->end_seq;\n\t\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb)->seq, dsack);\n\t\t}\n\t\tp = rb_next(p);\n\t\trb_erase(&skb->rbnode, &tp->out_of_order_queue);\n\n\t\tif (unlikely(!after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt))) {\n\t\t\ttcp_drop(sk, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttail = skb_peek_tail(&sk->sk_receive_queue);\n\t\teaten = tail && tcp_try_coalesce(sk, tail, skb, &fragstolen);\n\t\ttcp_rcv_nxt_update(tp, TCP_SKB_CB(skb)->end_seq);\n\t\tfin = TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN;\n\t\tif (!eaten)\n\t\t\t__skb_queue_tail(&sk->sk_receive_queue, skb);\n\t\telse\n\t\t\tkfree_skb_partial(skb, fragstolen);\n\n\t\tif (unlikely(fin)) {\n\t\t\ttcp_fin(sk);\n\t\t\t/* tcp_fin() purges tp->out_of_order_queue,\n\t\t\t * so we must end this loop right now.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic bool tcp_prune_ofo_queue(struct sock *sk);\nstatic int tcp_prune_queue(struct sock *sk);\n\nstatic int tcp_try_rmem_schedule(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t unsigned int size)\n{\n\tif (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf ||\n\t    !sk_rmem_schedule(sk, skb, size)) {\n\n\t\tif (tcp_prune_queue(sk) < 0)\n\t\t\treturn -1;\n\n\t\twhile (!sk_rmem_schedule(sk, skb, size)) {\n\t\t\tif (!tcp_prune_ofo_queue(sk))\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void tcp_data_queue_ofo(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct rb_node **p, *parent;\n\tstruct sk_buff *skb1;\n\tu32 seq, end_seq;\n\tbool fragstolen;\n\n\ttcp_ecn_check_ce(sk, skb);\n\n\tif (unlikely(tcp_try_rmem_schedule(sk, skb, skb->truesize))) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFODROP);\n\t\tsk->sk_data_ready(sk);\n\t\ttcp_drop(sk, skb);\n\t\treturn;\n\t}\n\n\t/* Disable header prediction. */\n\ttp->pred_flags = 0;\n\tinet_csk_schedule_ack(sk);\n\n\ttp->rcv_ooopack += max_t(u16, 1, skb_shinfo(skb)->gso_segs);\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOQUEUE);\n\tseq = TCP_SKB_CB(skb)->seq;\n\tend_seq = TCP_SKB_CB(skb)->end_seq;\n\n\tp = &tp->out_of_order_queue.rb_node;\n\tif (RB_EMPTY_ROOT(&tp->out_of_order_queue)) {\n\t\t/* Initial out of order segment, build 1 SACK. */\n\t\tif (tcp_is_sack(tp)) {\n\t\t\ttp->rx_opt.num_sacks = 1;\n\t\t\ttp->selective_acks[0].start_seq = seq;\n\t\t\ttp->selective_acks[0].end_seq = end_seq;\n\t\t}\n\t\trb_link_node(&skb->rbnode, NULL, p);\n\t\trb_insert_color(&skb->rbnode, &tp->out_of_order_queue);\n\t\ttp->ooo_last_skb = skb;\n\t\tgoto end;\n\t}\n\n\t/* In the typical case, we are adding an skb to the end of the list.\n\t * Use of ooo_last_skb avoids the O(Log(N)) rbtree lookup.\n\t */\n\tif (tcp_ooo_try_coalesce(sk, tp->ooo_last_skb,\n\t\t\t\t skb, &fragstolen)) {\ncoalesce_done:\n\t\t/* For non sack flows, do not grow window to force DUPACK\n\t\t * and trigger fast retransmit.\n\t\t */\n\t\tif (tcp_is_sack(tp))\n\t\t\ttcp_grow_window(sk, skb);\n\t\tkfree_skb_partial(skb, fragstolen);\n\t\tskb = NULL;\n\t\tgoto add_sack;\n\t}\n\t/* Can avoid an rbtree lookup if we are adding skb after ooo_last_skb */\n\tif (!before(seq, TCP_SKB_CB(tp->ooo_last_skb)->end_seq)) {\n\t\tparent = &tp->ooo_last_skb->rbnode;\n\t\tp = &parent->rb_right;\n\t\tgoto insert;\n\t}\n\n\t/* Find place to insert this segment. Handle overlaps on the way. */\n\tparent = NULL;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tskb1 = rb_to_skb(parent);\n\t\tif (before(seq, TCP_SKB_CB(skb1)->seq)) {\n\t\t\tp = &parent->rb_left;\n\t\t\tcontinue;\n\t\t}\n\t\tif (before(seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\t\tif (!after(end_seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\t\t\t/* All the bits are present. Drop. */\n\t\t\t\tNET_INC_STATS(sock_net(sk),\n\t\t\t\t\t      LINUX_MIB_TCPOFOMERGE);\n\t\t\t\ttcp_drop(sk, skb);\n\t\t\t\tskb = NULL;\n\t\t\t\ttcp_dsack_set(sk, seq, end_seq);\n\t\t\t\tgoto add_sack;\n\t\t\t}\n\t\t\tif (after(seq, TCP_SKB_CB(skb1)->seq)) {\n\t\t\t\t/* Partial overlap. */\n\t\t\t\ttcp_dsack_set(sk, seq, TCP_SKB_CB(skb1)->end_seq);\n\t\t\t} else {\n\t\t\t\t/* skb's seq == skb1's seq and skb covers skb1.\n\t\t\t\t * Replace skb1 with skb.\n\t\t\t\t */\n\t\t\t\trb_replace_node(&skb1->rbnode, &skb->rbnode,\n\t\t\t\t\t\t&tp->out_of_order_queue);\n\t\t\t\ttcp_dsack_extend(sk,\n\t\t\t\t\t\t TCP_SKB_CB(skb1)->seq,\n\t\t\t\t\t\t TCP_SKB_CB(skb1)->end_seq);\n\t\t\t\tNET_INC_STATS(sock_net(sk),\n\t\t\t\t\t      LINUX_MIB_TCPOFOMERGE);\n\t\t\t\ttcp_drop(sk, skb1);\n\t\t\t\tgoto merge_right;\n\t\t\t}\n\t\t} else if (tcp_ooo_try_coalesce(sk, skb1,\n\t\t\t\t\t\tskb, &fragstolen)) {\n\t\t\tgoto coalesce_done;\n\t\t}\n\t\tp = &parent->rb_right;\n\t}\ninsert:\n\t/* Insert segment into RB tree. */\n\trb_link_node(&skb->rbnode, parent, p);\n\trb_insert_color(&skb->rbnode, &tp->out_of_order_queue);\n\nmerge_right:\n\t/* Remove other segments covered by skb. */\n\twhile ((skb1 = skb_rb_next(skb)) != NULL) {\n\t\tif (!after(end_seq, TCP_SKB_CB(skb1)->seq))\n\t\t\tbreak;\n\t\tif (before(end_seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq,\n\t\t\t\t\t end_seq);\n\t\t\tbreak;\n\t\t}\n\t\trb_erase(&skb1->rbnode, &tp->out_of_order_queue);\n\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq,\n\t\t\t\t TCP_SKB_CB(skb1)->end_seq);\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOMERGE);\n\t\ttcp_drop(sk, skb1);\n\t}\n\t/* If there is no skb after us, we are the last_skb ! */\n\tif (!skb1)\n\t\ttp->ooo_last_skb = skb;\n\nadd_sack:\n\tif (tcp_is_sack(tp))\n\t\ttcp_sack_new_ofo_skb(sk, seq, end_seq);\nend:\n\tif (skb) {\n\t\t/* For non sack flows, do not grow window to force DUPACK\n\t\t * and trigger fast retransmit.\n\t\t */\n\t\tif (tcp_is_sack(tp))\n\t\t\ttcp_grow_window(sk, skb);\n\t\tskb_condense(skb);\n\t\tskb_set_owner_r(skb, sk);\n\t}\n}\n\nstatic int __must_check tcp_queue_rcv(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t      bool *fragstolen)\n{\n\tint eaten;\n\tstruct sk_buff *tail = skb_peek_tail(&sk->sk_receive_queue);\n\n\teaten = (tail &&\n\t\t tcp_try_coalesce(sk, tail,\n\t\t\t\t  skb, fragstolen)) ? 1 : 0;\n\ttcp_rcv_nxt_update(tcp_sk(sk), TCP_SKB_CB(skb)->end_seq);\n\tif (!eaten) {\n\t\t__skb_queue_tail(&sk->sk_receive_queue, skb);\n\t\tskb_set_owner_r(skb, sk);\n\t}\n\treturn eaten;\n}\n\nint tcp_send_rcvq(struct sock *sk, struct msghdr *msg, size_t size)\n{\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\tint data_len = 0;\n\tbool fragstolen;\n\n\tif (size == 0)\n\t\treturn 0;\n\n\tif (size > PAGE_SIZE) {\n\t\tint npages = min_t(size_t, size >> PAGE_SHIFT, MAX_SKB_FRAGS);\n\n\t\tdata_len = npages << PAGE_SHIFT;\n\t\tsize = data_len + (size & ~PAGE_MASK);\n\t}\n\tskb = alloc_skb_with_frags(size - data_len, data_len,\n\t\t\t\t   PAGE_ALLOC_COSTLY_ORDER,\n\t\t\t\t   &err, sk->sk_allocation);\n\tif (!skb)\n\t\tgoto err;\n\n\tskb_put(skb, size - data_len);\n\tskb->data_len = data_len;\n\tskb->len = size;\n\n\tif (tcp_try_rmem_schedule(sk, skb, skb->truesize)) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRCVQDROP);\n\t\tgoto err_free;\n\t}\n\n\terr = skb_copy_datagram_from_iter(skb, 0, &msg->msg_iter, size);\n\tif (err)\n\t\tgoto err_free;\n\n\tTCP_SKB_CB(skb)->seq = tcp_sk(sk)->rcv_nxt;\n\tTCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq + size;\n\tTCP_SKB_CB(skb)->ack_seq = tcp_sk(sk)->snd_una - 1;\n\n\tif (tcp_queue_rcv(sk, skb, &fragstolen)) {\n\t\tWARN_ON_ONCE(fragstolen); /* should not happen */\n\t\t__kfree_skb(skb);\n\t}\n\treturn size;\n\nerr_free:\n\tkfree_skb(skb);\nerr:\n\treturn err;\n\n}\n\nvoid tcp_data_ready(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tint avail = tp->rcv_nxt - tp->copied_seq;\n\n\tif (avail < sk->sk_rcvlowat && !tcp_rmem_pressure(sk) &&\n\t    !sock_flag(sk, SOCK_DONE) &&\n\t    tcp_receive_window(tp) > inet_csk(sk)->icsk_ack.rcv_mss)\n\t\treturn;\n\n\tsk->sk_data_ready(sk);\n}\n\nstatic void tcp_data_queue(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tbool fragstolen;\n\tint eaten;\n\n\tif (sk_is_mptcp(sk))\n\t\tmptcp_incoming_options(sk, skb);\n\n\tif (TCP_SKB_CB(skb)->seq == TCP_SKB_CB(skb)->end_seq) {\n\t\t__kfree_skb(skb);\n\t\treturn;\n\t}\n\tskb_dst_drop(skb);\n\t__skb_pull(skb, tcp_hdr(skb)->doff * 4);\n\n\ttp->rx_opt.dsack = 0;\n\n\t/*  Queue data for delivery to the user.\n\t *  Packets in sequence go to the receive queue.\n\t *  Out of sequence packets to the out_of_order_queue.\n\t */\n\tif (TCP_SKB_CB(skb)->seq == tp->rcv_nxt) {\n\t\tif (tcp_receive_window(tp) == 0) {\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPZEROWINDOWDROP);\n\t\t\tgoto out_of_window;\n\t\t}\n\n\t\t/* Ok. In sequence. In window. */\nqueue_and_out:\n\t\tif (skb_queue_len(&sk->sk_receive_queue) == 0)\n\t\t\tsk_forced_mem_schedule(sk, skb->truesize);\n\t\telse if (tcp_try_rmem_schedule(sk, skb, skb->truesize)) {\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRCVQDROP);\n\t\t\tsk->sk_data_ready(sk);\n\t\t\tgoto drop;\n\t\t}\n\n\t\teaten = tcp_queue_rcv(sk, skb, &fragstolen);\n\t\tif (skb->len)\n\t\t\ttcp_event_data_recv(sk, skb);\n\t\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)\n\t\t\ttcp_fin(sk);\n\n\t\tif (!RB_EMPTY_ROOT(&tp->out_of_order_queue)) {\n\t\t\ttcp_ofo_queue(sk);\n\n\t\t\t/* RFC5681. 4.2. SHOULD send immediate ACK, when\n\t\t\t * gap in queue is filled.\n\t\t\t */\n\t\t\tif (RB_EMPTY_ROOT(&tp->out_of_order_queue))\n\t\t\t\tinet_csk(sk)->icsk_ack.pending |= ICSK_ACK_NOW;\n\t\t}\n\n\t\tif (tp->rx_opt.num_sacks)\n\t\t\ttcp_sack_remove(tp);\n\n\t\ttcp_fast_path_check(sk);\n\n\t\tif (eaten > 0)\n\t\t\tkfree_skb_partial(skb, fragstolen);\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\ttcp_data_ready(sk);\n\t\treturn;\n\t}\n\n\tif (!after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt)) {\n\t\ttcp_rcv_spurious_retrans(sk, skb);\n\t\t/* A retransmit, 2nd most common case.  Force an immediate ack. */\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_DELAYEDACKLOST);\n\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);\n\nout_of_window:\n\t\ttcp_enter_quickack_mode(sk, TCP_MAX_QUICKACKS);\n\t\tinet_csk_schedule_ack(sk);\ndrop:\n\t\ttcp_drop(sk, skb);\n\t\treturn;\n\t}\n\n\t/* Out of window. F.e. zero window probe. */\n\tif (!before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt + tcp_receive_window(tp)))\n\t\tgoto out_of_window;\n\n\tif (before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {\n\t\t/* Partial packet, seq < rcv_next < end_seq */\n\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)->seq, tp->rcv_nxt);\n\n\t\t/* If window is closed, drop tail of packet. But after\n\t\t * remembering D-SACK for its head made in previous line.\n\t\t */\n\t\tif (!tcp_receive_window(tp)) {\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPZEROWINDOWDROP);\n\t\t\tgoto out_of_window;\n\t\t}\n\t\tgoto queue_and_out;\n\t}\n\n\ttcp_data_queue_ofo(sk, skb);\n}\n\nstatic struct sk_buff *tcp_skb_next(struct sk_buff *skb, struct sk_buff_head *list)\n{\n\tif (list)\n\t\treturn !skb_queue_is_last(list, skb) ? skb->next : NULL;\n\n\treturn skb_rb_next(skb);\n}\n\nstatic struct sk_buff *tcp_collapse_one(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\tstruct sk_buff_head *list,\n\t\t\t\t\tstruct rb_root *root)\n{\n\tstruct sk_buff *next = tcp_skb_next(skb, list);\n\n\tif (list)\n\t\t__skb_unlink(skb, list);\n\telse\n\t\trb_erase(&skb->rbnode, root);\n\n\t__kfree_skb(skb);\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRCVCOLLAPSED);\n\n\treturn next;\n}\n\n/* Insert skb into rb tree, ordered by TCP_SKB_CB(skb)->seq */\nvoid tcp_rbtree_insert(struct rb_root *root, struct sk_buff *skb)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct sk_buff *skb1;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tskb1 = rb_to_skb(parent);\n\t\tif (before(TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb1)->seq))\n\t\t\tp = &parent->rb_left;\n\t\telse\n\t\t\tp = &parent->rb_right;\n\t}\n\trb_link_node(&skb->rbnode, parent, p);\n\trb_insert_color(&skb->rbnode, root);\n}\n\n/* Collapse contiguous sequence of skbs head..tail with\n * sequence numbers start..end.\n *\n * If tail is NULL, this means until the end of the queue.\n *\n * Segments with FIN/SYN are not collapsed (only because this\n * simplifies code)\n */\nstatic void\ntcp_collapse(struct sock *sk, struct sk_buff_head *list, struct rb_root *root,\n\t     struct sk_buff *head, struct sk_buff *tail, u32 start, u32 end)\n{\n\tstruct sk_buff *skb = head, *n;\n\tstruct sk_buff_head tmp;\n\tbool end_of_skbs;\n\n\t/* First, check that queue is collapsible and find\n\t * the point where collapsing can be useful.\n\t */\nrestart:\n\tfor (end_of_skbs = true; skb != NULL && skb != tail; skb = n) {\n\t\tn = tcp_skb_next(skb, list);\n\n\t\t/* No new bits? It is possible on ofo queue. */\n\t\tif (!before(start, TCP_SKB_CB(skb)->end_seq)) {\n\t\t\tskb = tcp_collapse_one(sk, skb, list, root);\n\t\t\tif (!skb)\n\t\t\t\tbreak;\n\t\t\tgoto restart;\n\t\t}\n\n\t\t/* The first skb to collapse is:\n\t\t * - not SYN/FIN and\n\t\t * - bloated or contains data before \"start\" or\n\t\t *   overlaps to the next one and mptcp allow collapsing.\n\t\t */\n\t\tif (!(TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)) &&\n\t\t    (tcp_win_from_space(sk, skb->truesize) > skb->len ||\n\t\t     before(TCP_SKB_CB(skb)->seq, start))) {\n\t\t\tend_of_skbs = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (n && n != tail && mptcp_skb_can_collapse(skb, n) &&\n\t\t    TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(n)->seq) {\n\t\t\tend_of_skbs = false;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Decided to skip this, advance start seq. */\n\t\tstart = TCP_SKB_CB(skb)->end_seq;\n\t}\n\tif (end_of_skbs ||\n\t    (TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)))\n\t\treturn;\n\n\t__skb_queue_head_init(&tmp);\n\n\twhile (before(start, end)) {\n\t\tint copy = min_t(int, SKB_MAX_ORDER(0, 0), end - start);\n\t\tstruct sk_buff *nskb;\n\n\t\tnskb = alloc_skb(copy, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\tbreak;\n\n\t\tmemcpy(nskb->cb, skb->cb, sizeof(skb->cb));\n#ifdef CONFIG_TLS_DEVICE\n\t\tnskb->decrypted = skb->decrypted;\n#endif\n\t\tTCP_SKB_CB(nskb)->seq = TCP_SKB_CB(nskb)->end_seq = start;\n\t\tif (list)\n\t\t\t__skb_queue_before(list, skb, nskb);\n\t\telse\n\t\t\t__skb_queue_tail(&tmp, nskb); /* defer rbtree insertion */\n\t\tskb_set_owner_r(nskb, sk);\n\t\tmptcp_skb_ext_move(nskb, skb);\n\n\t\t/* Copy data, releasing collapsed skbs. */\n\t\twhile (copy > 0) {\n\t\t\tint offset = start - TCP_SKB_CB(skb)->seq;\n\t\t\tint size = TCP_SKB_CB(skb)->end_seq - start;\n\n\t\t\tBUG_ON(offset < 0);\n\t\t\tif (size > 0) {\n\t\t\t\tsize = min(copy, size);\n\t\t\t\tif (skb_copy_bits(skb, offset, skb_put(nskb, size), size))\n\t\t\t\t\tBUG();\n\t\t\t\tTCP_SKB_CB(nskb)->end_seq += size;\n\t\t\t\tcopy -= size;\n\t\t\t\tstart += size;\n\t\t\t}\n\t\t\tif (!before(start, TCP_SKB_CB(skb)->end_seq)) {\n\t\t\t\tskb = tcp_collapse_one(sk, skb, list, root);\n\t\t\t\tif (!skb ||\n\t\t\t\t    skb == tail ||\n\t\t\t\t    !mptcp_skb_can_collapse(nskb, skb) ||\n\t\t\t\t    (TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)))\n\t\t\t\t\tgoto end;\n#ifdef CONFIG_TLS_DEVICE\n\t\t\t\tif (skb->decrypted != nskb->decrypted)\n\t\t\t\t\tgoto end;\n#endif\n\t\t\t}\n\t\t}\n\t}\nend:\n\tskb_queue_walk_safe(&tmp, skb, n)\n\t\ttcp_rbtree_insert(root, skb);\n}\n\n/* Collapse ofo queue. Algorithm: select contiguous sequence of skbs\n * and tcp_collapse() them until all the queue is collapsed.\n */\nstatic void tcp_collapse_ofo_queue(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 range_truesize, sum_tiny = 0;\n\tstruct sk_buff *skb, *head;\n\tu32 start, end;\n\n\tskb = skb_rb_first(&tp->out_of_order_queue);\nnew_range:\n\tif (!skb) {\n\t\ttp->ooo_last_skb = skb_rb_last(&tp->out_of_order_queue);\n\t\treturn;\n\t}\n\tstart = TCP_SKB_CB(skb)->seq;\n\tend = TCP_SKB_CB(skb)->end_seq;\n\trange_truesize = skb->truesize;\n\n\tfor (head = skb;;) {\n\t\tskb = skb_rb_next(skb);\n\n\t\t/* Range is terminated when we see a gap or when\n\t\t * we are at the queue end.\n\t\t */\n\t\tif (!skb ||\n\t\t    after(TCP_SKB_CB(skb)->seq, end) ||\n\t\t    before(TCP_SKB_CB(skb)->end_seq, start)) {\n\t\t\t/* Do not attempt collapsing tiny skbs */\n\t\t\tif (range_truesize != head->truesize ||\n\t\t\t    end - start >= SKB_WITH_OVERHEAD(SK_MEM_QUANTUM)) {\n\t\t\t\ttcp_collapse(sk, NULL, &tp->out_of_order_queue,\n\t\t\t\t\t     head, skb, start, end);\n\t\t\t} else {\n\t\t\t\tsum_tiny += range_truesize;\n\t\t\t\tif (sum_tiny > sk->sk_rcvbuf >> 3)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tgoto new_range;\n\t\t}\n\n\t\trange_truesize += skb->truesize;\n\t\tif (unlikely(before(TCP_SKB_CB(skb)->seq, start)))\n\t\t\tstart = TCP_SKB_CB(skb)->seq;\n\t\tif (after(TCP_SKB_CB(skb)->end_seq, end))\n\t\t\tend = TCP_SKB_CB(skb)->end_seq;\n\t}\n}\n\n/*\n * Clean the out-of-order queue to make room.\n * We drop high sequences packets to :\n * 1) Let a chance for holes to be filled.\n * 2) not add too big latencies if thousands of packets sit there.\n *    (But if application shrinks SO_RCVBUF, we could still end up\n *     freeing whole queue here)\n * 3) Drop at least 12.5 % of sk_rcvbuf to avoid malicious attacks.\n *\n * Return true if queue has shrunk.\n */\nstatic bool tcp_prune_ofo_queue(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct rb_node *node, *prev;\n\tint goal;\n\n\tif (RB_EMPTY_ROOT(&tp->out_of_order_queue))\n\t\treturn false;\n\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_OFOPRUNED);\n\tgoal = sk->sk_rcvbuf >> 3;\n\tnode = &tp->ooo_last_skb->rbnode;\n\tdo {\n\t\tprev = rb_prev(node);\n\t\trb_erase(node, &tp->out_of_order_queue);\n\t\tgoal -= rb_to_skb(node)->truesize;\n\t\ttcp_drop(sk, rb_to_skb(node));\n\t\tif (!prev || goal <= 0) {\n\t\t\tsk_mem_reclaim(sk);\n\t\t\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf &&\n\t\t\t    !tcp_under_memory_pressure(sk))\n\t\t\t\tbreak;\n\t\t\tgoal = sk->sk_rcvbuf >> 3;\n\t\t}\n\t\tnode = prev;\n\t} while (node);\n\ttp->ooo_last_skb = rb_to_skb(prev);\n\n\t/* Reset SACK state.  A conforming SACK implementation will\n\t * do the same at a timeout based retransmit.  When a connection\n\t * is in a sad state like this, we care only about integrity\n\t * of the connection not performance.\n\t */\n\tif (tp->rx_opt.sack_ok)\n\t\ttcp_sack_reset(&tp->rx_opt);\n\treturn true;\n}\n\n/* Reduce allocated memory if we can, trying to get\n * the socket within its memory limits again.\n *\n * Return less than zero if we should start dropping frames\n * until the socket owning process reads some of the data\n * to stabilize the situation.\n */\nstatic int tcp_prune_queue(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_PRUNECALLED);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\ttcp_clamp_window(sk);\n\telse if (tcp_under_memory_pressure(sk))\n\t\ttp->rcv_ssthresh = min(tp->rcv_ssthresh, 4U * tp->advmss);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\treturn 0;\n\n\ttcp_collapse_ofo_queue(sk);\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\ttcp_collapse(sk, &sk->sk_receive_queue, NULL,\n\t\t\t     skb_peek(&sk->sk_receive_queue),\n\t\t\t     NULL,\n\t\t\t     tp->copied_seq, tp->rcv_nxt);\n\tsk_mem_reclaim(sk);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\treturn 0;\n\n\t/* Collapsing did not help, destructive actions follow.\n\t * This must not ever occur. */\n\n\ttcp_prune_ofo_queue(sk);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\treturn 0;\n\n\t/* If we are really being abused, tell the caller to silently\n\t * drop receive data on the floor.  It will get retransmitted\n\t * and hopefully then we'll have sufficient space.\n\t */\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_RCVPRUNED);\n\n\t/* Massive buffer overcommit. */\n\ttp->pred_flags = 0;\n\treturn -1;\n}\n\nstatic bool tcp_should_expand_sndbuf(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\t/* If the user specified a specific send buffer setting, do\n\t * not modify it.\n\t */\n\tif (sk->sk_userlocks & SOCK_SNDBUF_LOCK)\n\t\treturn false;\n\n\t/* If we are under global TCP memory pressure, do not expand.  */\n\tif (tcp_under_memory_pressure(sk))\n\t\treturn false;\n\n\t/* If we are under soft global TCP memory pressure, do not expand.  */\n\tif (sk_memory_allocated(sk) >= sk_prot_mem_limits(sk, 0))\n\t\treturn false;\n\n\t/* If we filled the congestion window, do not expand.  */\n\tif (tcp_packets_in_flight(tp) >= tp->snd_cwnd)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void tcp_new_space(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_should_expand_sndbuf(sk)) {\n\t\ttcp_sndbuf_expand(sk);\n\t\ttp->snd_cwnd_stamp = tcp_jiffies32;\n\t}\n\n\tsk->sk_write_space(sk);\n}\n\nstatic void tcp_check_space(struct sock *sk)\n{\n\t/* pairs with tcp_poll() */\n\tsmp_mb();\n\tif (sk->sk_socket &&\n\t    test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\ttcp_new_space(sk);\n\t\tif (!test_bit(SOCK_NOSPACE, &sk->sk_socket->flags))\n\t\t\ttcp_chrono_stop(sk, TCP_CHRONO_SNDBUF_LIMITED);\n\t}\n}\n\nstatic inline void tcp_data_snd_check(struct sock *sk)\n{\n\ttcp_push_pending_frames(sk);\n\ttcp_check_space(sk);\n}\n\n/*\n * Check if sending an ack is needed.\n */\nstatic void __tcp_ack_snd_check(struct sock *sk, int ofo_possible)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tunsigned long rtt, delay;\n\n\t    /* More than one full frame received... */\n\tif (((tp->rcv_nxt - tp->rcv_wup) > inet_csk(sk)->icsk_ack.rcv_mss &&\n\t     /* ... and right edge of window advances far enough.\n\t      * (tcp_recvmsg() will send ACK otherwise).\n\t      * If application uses SO_RCVLOWAT, we want send ack now if\n\t      * we have not received enough bytes to satisfy the condition.\n\t      */\n\t    (tp->rcv_nxt - tp->copied_seq < sk->sk_rcvlowat ||\n\t     __tcp_select_window(sk) >= tp->rcv_wnd)) ||\n\t    /* We ACK each frame or... */\n\t    tcp_in_quickack_mode(sk) ||\n\t    /* Protocol state mandates a one-time immediate ACK */\n\t    inet_csk(sk)->icsk_ack.pending & ICSK_ACK_NOW) {\nsend_now:\n\t\ttcp_send_ack(sk);\n\t\treturn;\n\t}\n\n\tif (!ofo_possible || RB_EMPTY_ROOT(&tp->out_of_order_queue)) {\n\t\ttcp_send_delayed_ack(sk);\n\t\treturn;\n\t}\n\n\tif (!tcp_is_sack(tp) ||\n\t    tp->compressed_ack >= sock_net(sk)->ipv4.sysctl_tcp_comp_sack_nr)\n\t\tgoto send_now;\n\n\tif (tp->compressed_ack_rcv_nxt != tp->rcv_nxt) {\n\t\ttp->compressed_ack_rcv_nxt = tp->rcv_nxt;\n\t\ttp->dup_ack_counter = 0;\n\t}\n\tif (tp->dup_ack_counter < TCP_FASTRETRANS_THRESH) {\n\t\ttp->dup_ack_counter++;\n\t\tgoto send_now;\n\t}\n\ttp->compressed_ack++;\n\tif (hrtimer_is_queued(&tp->compressed_ack_timer))\n\t\treturn;\n\n\t/* compress ack timer : 5 % of rtt, but no more than tcp_comp_sack_delay_ns */\n\n\trtt = tp->rcv_rtt_est.rtt_us;\n\tif (tp->srtt_us && tp->srtt_us < rtt)\n\t\trtt = tp->srtt_us;\n\n\tdelay = min_t(unsigned long, sock_net(sk)->ipv4.sysctl_tcp_comp_sack_delay_ns,\n\t\t      rtt * (NSEC_PER_USEC >> 3)/20);\n\tsock_hold(sk);\n\thrtimer_start_range_ns(&tp->compressed_ack_timer, ns_to_ktime(delay),\n\t\t\t       sock_net(sk)->ipv4.sysctl_tcp_comp_sack_slack_ns,\n\t\t\t       HRTIMER_MODE_REL_PINNED_SOFT);\n}\n\nstatic inline void tcp_ack_snd_check(struct sock *sk)\n{\n\tif (!inet_csk_ack_scheduled(sk)) {\n\t\t/* We sent a data segment already. */\n\t\treturn;\n\t}\n\t__tcp_ack_snd_check(sk, 1);\n}\n\n/*\n *\tThis routine is only called when we have urgent data\n *\tsignaled. Its the 'slow' part of tcp_urg. It could be\n *\tmoved inline now as tcp_urg is only called from one\n *\tplace. We handle URGent data wrong. We have to - as\n *\tBSD still doesn't use the correction from RFC961.\n *\tFor 1003.1g we should support a new option TCP_STDURG to permit\n *\teither form (or just set the sysctl tcp_stdurg).\n */\n\nstatic void tcp_check_urg(struct sock *sk, const struct tcphdr *th)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 ptr = ntohs(th->urg_ptr);\n\n\tif (ptr && !sock_net(sk)->ipv4.sysctl_tcp_stdurg)\n\t\tptr--;\n\tptr += ntohl(th->seq);\n\n\t/* Ignore urgent data that we've already seen and read. */\n\tif (after(tp->copied_seq, ptr))\n\t\treturn;\n\n\t/* Do not replay urg ptr.\n\t *\n\t * NOTE: interesting situation not covered by specs.\n\t * Misbehaving sender may send urg ptr, pointing to segment,\n\t * which we already have in ofo queue. We are not able to fetch\n\t * such data and will stay in TCP_URG_NOTYET until will be eaten\n\t * by recvmsg(). Seems, we are not obliged to handle such wicked\n\t * situations. But it is worth to think about possibility of some\n\t * DoSes using some hypothetical application level deadlock.\n\t */\n\tif (before(ptr, tp->rcv_nxt))\n\t\treturn;\n\n\t/* Do we already have a newer (or duplicate) urgent pointer? */\n\tif (tp->urg_data && !after(ptr, tp->urg_seq))\n\t\treturn;\n\n\t/* Tell the world about our new urgent pointer. */\n\tsk_send_sigurg(sk);\n\n\t/* We may be adding urgent data when the last byte read was\n\t * urgent. To do this requires some care. We cannot just ignore\n\t * tp->copied_seq since we would read the last urgent byte again\n\t * as data, nor can we alter copied_seq until this data arrives\n\t * or we break the semantics of SIOCATMARK (and thus sockatmark())\n\t *\n\t * NOTE. Double Dutch. Rendering to plain English: author of comment\n\t * above did something sort of \tsend(\"A\", MSG_OOB); send(\"B\", MSG_OOB);\n\t * and expect that both A and B disappear from stream. This is _wrong_.\n\t * Though this happens in BSD with high probability, this is occasional.\n\t * Any application relying on this is buggy. Note also, that fix \"works\"\n\t * only in this artificial test. Insert some normal data between A and B and we will\n\t * decline of BSD again. Verdict: it is better to remove to trap\n\t * buggy users.\n\t */\n\tif (tp->urg_seq == tp->copied_seq && tp->urg_data &&\n\t    !sock_flag(sk, SOCK_URGINLINE) && tp->copied_seq != tp->rcv_nxt) {\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\t\ttp->copied_seq++;\n\t\tif (skb && !before(tp->copied_seq, TCP_SKB_CB(skb)->end_seq)) {\n\t\t\t__skb_unlink(skb, &sk->sk_receive_queue);\n\t\t\t__kfree_skb(skb);\n\t\t}\n\t}\n\n\ttp->urg_data = TCP_URG_NOTYET;\n\tWRITE_ONCE(tp->urg_seq, ptr);\n\n\t/* Disable header prediction. */\n\ttp->pred_flags = 0;\n}\n\n/* This is the 'fast' part of urgent handling. */\nstatic void tcp_urg(struct sock *sk, struct sk_buff *skb, const struct tcphdr *th)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t/* Check if we get a new urgent pointer - normally not. */\n\tif (th->urg)\n\t\ttcp_check_urg(sk, th);\n\n\t/* Do we wait for any urgent data? - normally not... */\n\tif (tp->urg_data == TCP_URG_NOTYET) {\n\t\tu32 ptr = tp->urg_seq - ntohl(th->seq) + (th->doff * 4) -\n\t\t\t  th->syn;\n\n\t\t/* Is the urgent pointer pointing into this packet? */\n\t\tif (ptr < skb->len) {\n\t\t\tu8 tmp;\n\t\t\tif (skb_copy_bits(skb, ptr, &tmp, 1))\n\t\t\t\tBUG();\n\t\t\ttp->urg_data = TCP_URG_VALID | tmp;\n\t\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\t\tsk->sk_data_ready(sk);\n\t\t}\n\t}\n}\n\n/* Accept RST for rcv_nxt - 1 after a FIN.\n * When tcp connections are abruptly terminated from Mac OSX (via ^C), a\n * FIN is sent followed by a RST packet. The RST is sent with the same\n * sequence number as the FIN, and thus according to RFC 5961 a challenge\n * ACK should be sent. However, Mac OSX rate limits replies to challenge\n * ACKs on the closed socket. In addition middleboxes can drop either the\n * challenge ACK or a subsequent RST.\n */\nstatic bool tcp_reset_check(const struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\treturn unlikely(TCP_SKB_CB(skb)->seq == (tp->rcv_nxt - 1) &&\n\t\t\t(1 << sk->sk_state) & (TCPF_CLOSE_WAIT | TCPF_LAST_ACK |\n\t\t\t\t\t       TCPF_CLOSING));\n}\n\n/* Does PAWS and seqno based validation of an incoming segment, flags will\n * play significant role here.\n */\nstatic bool tcp_validate_incoming(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  const struct tcphdr *th, int syn_inerr)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tbool rst_seq_match = false;\n\n\t/* RFC1323: H1. Apply PAWS check first. */\n\tif (tcp_fast_parse_options(sock_net(sk), skb, th, tp) &&\n\t    tp->rx_opt.saw_tstamp &&\n\t    tcp_paws_discard(sk, skb)) {\n\t\tif (!th->rst) {\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_PAWSESTABREJECTED);\n\t\t\tif (!tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t\t\t  LINUX_MIB_TCPACKSKIPPEDPAWS,\n\t\t\t\t\t\t  &tp->last_oow_ack_time))\n\t\t\t\ttcp_send_dupack(sk, skb);\n\t\t\tgoto discard;\n\t\t}\n\t\t/* Reset is accepted even if it did not pass PAWS. */\n\t}\n\n\t/* Step 1: check sequence number */\n\tif (!tcp_sequence(tp, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq)) {\n\t\t/* RFC793, page 37: \"In all states except SYN-SENT, all reset\n\t\t * (RST) segments are validated by checking their SEQ-fields.\"\n\t\t * And page 69: \"If an incoming segment is not acceptable,\n\t\t * an acknowledgment should be sent in reply (unless the RST\n\t\t * bit is set, if so drop the segment and return)\".\n\t\t */\n\t\tif (!th->rst) {\n\t\t\tif (th->syn)\n\t\t\t\tgoto syn_challenge;\n\t\t\tif (!tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t\t\t  LINUX_MIB_TCPACKSKIPPEDSEQ,\n\t\t\t\t\t\t  &tp->last_oow_ack_time))\n\t\t\t\ttcp_send_dupack(sk, skb);\n\t\t} else if (tcp_reset_check(sk, skb)) {\n\t\t\ttcp_reset(sk);\n\t\t}\n\t\tgoto discard;\n\t}\n\n\t/* Step 2: check RST bit */\n\tif (th->rst) {\n\t\t/* RFC 5961 3.2 (extend to match against (RCV.NXT - 1) after a\n\t\t * FIN and SACK too if available):\n\t\t * If seq num matches RCV.NXT or (RCV.NXT - 1) after a FIN, or\n\t\t * the right-most SACK block,\n\t\t * then\n\t\t *     RESET the connection\n\t\t * else\n\t\t *     Send a challenge ACK\n\t\t */\n\t\tif (TCP_SKB_CB(skb)->seq == tp->rcv_nxt ||\n\t\t    tcp_reset_check(sk, skb)) {\n\t\t\trst_seq_match = true;\n\t\t} else if (tcp_is_sack(tp) && tp->rx_opt.num_sacks > 0) {\n\t\t\tstruct tcp_sack_block *sp = &tp->selective_acks[0];\n\t\t\tint max_sack = sp[0].end_seq;\n\t\t\tint this_sack;\n\n\t\t\tfor (this_sack = 1; this_sack < tp->rx_opt.num_sacks;\n\t\t\t     ++this_sack) {\n\t\t\t\tmax_sack = after(sp[this_sack].end_seq,\n\t\t\t\t\t\t max_sack) ?\n\t\t\t\t\tsp[this_sack].end_seq : max_sack;\n\t\t\t}\n\n\t\t\tif (TCP_SKB_CB(skb)->seq == max_sack)\n\t\t\t\trst_seq_match = true;\n\t\t}\n\n\t\tif (rst_seq_match)\n\t\t\ttcp_reset(sk);\n\t\telse {\n\t\t\t/* Disable TFO if RST is out-of-order\n\t\t\t * and no data has been received\n\t\t\t * for current active TFO socket\n\t\t\t */\n\t\t\tif (tp->syn_fastopen && !tp->data_segs_in &&\n\t\t\t    sk->sk_state == TCP_ESTABLISHED)\n\t\t\t\ttcp_fastopen_active_disable(sk);\n\t\t\ttcp_send_challenge_ack(sk, skb);\n\t\t}\n\t\tgoto discard;\n\t}\n\n\t/* step 3: check security and precedence [ignored] */\n\n\t/* step 4: Check for a SYN\n\t * RFC 5961 4.2 : Send a challenge ack\n\t */\n\tif (th->syn) {\nsyn_challenge:\n\t\tif (syn_inerr)\n\t\t\tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPSYNCHALLENGE);\n\t\ttcp_send_challenge_ack(sk, skb);\n\t\tgoto discard;\n\t}\n\n\tbpf_skops_parse_hdr(sk, skb);\n\n\treturn true;\n\ndiscard:\n\ttcp_drop(sk, skb);\n\treturn false;\n}\n\n/*\n *\tTCP receive function for the ESTABLISHED state.\n *\n *\tIt is split into a fast path and a slow path. The fast path is\n * \tdisabled when:\n *\t- A zero window was announced from us - zero window probing\n *        is only handled properly in the slow path.\n *\t- Out of order segments arrived.\n *\t- Urgent data is expected.\n *\t- There is no buffer space left\n *\t- Unexpected TCP flags/window values/header lengths are received\n *\t  (detected by checking the TCP header against pred_flags)\n *\t- Data is sent in both directions. Fast path only supports pure senders\n *\t  or pure receivers (this means either the sequence number or the ack\n *\t  value must stay constant)\n *\t- Unexpected TCP option.\n *\n *\tWhen these conditions are not satisfied it drops into a standard\n *\treceive procedure patterned after RFC793 to handle all cases.\n *\tThe first three cases are guaranteed by proper pred_flags setting,\n *\tthe rest is checked inline. Fast processing is turned on in\n *\ttcp_data_queue when everything is OK.\n */\nvoid tcp_rcv_established(struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct tcphdr *th = (const struct tcphdr *)skb->data;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tunsigned int len = skb->len;\n\n\t/* TCP congestion window tracking */\n\ttrace_tcp_probe(sk, skb);\n\n\ttcp_mstamp_refresh(tp);\n\tif (unlikely(!sk->sk_rx_dst))\n\t\tinet_csk(sk)->icsk_af_ops->sk_rx_dst_set(sk, skb);\n\t/*\n\t *\tHeader prediction.\n\t *\tThe code loosely follows the one in the famous\n\t *\t\"30 instruction TCP receive\" Van Jacobson mail.\n\t *\n\t *\tVan's trick is to deposit buffers into socket queue\n\t *\ton a device interrupt, to call tcp_recv function\n\t *\ton the receive process context and checksum and copy\n\t *\tthe buffer to user space. smart...\n\t *\n\t *\tOur current scheme is not silly either but we take the\n\t *\textra cost of the net_bh soft interrupt processing...\n\t *\tWe do checksum and copy also but from device to kernel.\n\t */\n\n\ttp->rx_opt.saw_tstamp = 0;\n\n\t/*\tpred_flags is 0xS?10 << 16 + snd_wnd\n\t *\tif header_prediction is to be made\n\t *\t'S' will always be tp->tcp_header_len >> 2\n\t *\t'?' will be 0 for the fast path, otherwise pred_flags is 0 to\n\t *  turn it off\t(when there are holes in the receive\n\t *\t space for instance)\n\t *\tPSH flag is ignored.\n\t */\n\n\tif ((tcp_flag_word(th) & TCP_HP_BITS) == tp->pred_flags &&\n\t    TCP_SKB_CB(skb)->seq == tp->rcv_nxt &&\n\t    !after(TCP_SKB_CB(skb)->ack_seq, tp->snd_nxt)) {\n\t\tint tcp_header_len = tp->tcp_header_len;\n\n\t\t/* Timestamp header prediction: tcp_header_len\n\t\t * is automatically equal to th->doff*4 due to pred_flags\n\t\t * match.\n\t\t */\n\n\t\t/* Check timestamp */\n\t\tif (tcp_header_len == sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED) {\n\t\t\t/* No? Slow path! */\n\t\t\tif (!tcp_parse_aligned_timestamp(tp, th))\n\t\t\t\tgoto slow_path;\n\n\t\t\t/* If PAWS failed, check it more carefully in slow path */\n\t\t\tif ((s32)(tp->rx_opt.rcv_tsval - tp->rx_opt.ts_recent) < 0)\n\t\t\t\tgoto slow_path;\n\n\t\t\t/* DO NOT update ts_recent here, if checksum fails\n\t\t\t * and timestamp was corrupted part, it will result\n\t\t\t * in a hung connection since we will drop all\n\t\t\t * future packets due to the PAWS test.\n\t\t\t */\n\t\t}\n\n\t\tif (len <= tcp_header_len) {\n\t\t\t/* Bulk data transfer: sender */\n\t\t\tif (len == tcp_header_len) {\n\t\t\t\t/* Predicted packet is in window by definition.\n\t\t\t\t * seq == rcv_nxt and rcv_wup <= rcv_nxt.\n\t\t\t\t * Hence, check seq<=rcv_wup reduces to:\n\t\t\t\t */\n\t\t\t\tif (tcp_header_len ==\n\t\t\t\t    (sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED) &&\n\t\t\t\t    tp->rcv_nxt == tp->rcv_wup)\n\t\t\t\t\ttcp_store_ts_recent(tp);\n\n\t\t\t\t/* We know that such packets are checksummed\n\t\t\t\t * on entry.\n\t\t\t\t */\n\t\t\t\ttcp_ack(sk, skb, 0);\n\t\t\t\t__kfree_skb(skb);\n\t\t\t\ttcp_data_snd_check(sk);\n\t\t\t\t/* When receiving pure ack in fast path, update\n\t\t\t\t * last ts ecr directly instead of calling\n\t\t\t\t * tcp_rcv_rtt_measure_ts()\n\t\t\t\t */\n\t\t\t\ttp->rcv_rtt_last_tsecr = tp->rx_opt.rcv_tsecr;\n\t\t\t\treturn;\n\t\t\t} else { /* Header too small */\n\t\t\t\tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);\n\t\t\t\tgoto discard;\n\t\t\t}\n\t\t} else {\n\t\t\tint eaten = 0;\n\t\t\tbool fragstolen = false;\n\n\t\t\tif (tcp_checksum_complete(skb))\n\t\t\t\tgoto csum_error;\n\n\t\t\tif ((int)skb->truesize > sk->sk_forward_alloc)\n\t\t\t\tgoto step5;\n\n\t\t\t/* Predicted packet is in window by definition.\n\t\t\t * seq == rcv_nxt and rcv_wup <= rcv_nxt.\n\t\t\t * Hence, check seq<=rcv_wup reduces to:\n\t\t\t */\n\t\t\tif (tcp_header_len ==\n\t\t\t    (sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED) &&\n\t\t\t    tp->rcv_nxt == tp->rcv_wup)\n\t\t\t\ttcp_store_ts_recent(tp);\n\n\t\t\ttcp_rcv_rtt_measure_ts(sk, skb);\n\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPHPHITS);\n\n\t\t\t/* Bulk data transfer: receiver */\n\t\t\t__skb_pull(skb, tcp_header_len);\n\t\t\teaten = tcp_queue_rcv(sk, skb, &fragstolen);\n\n\t\t\ttcp_event_data_recv(sk, skb);\n\n\t\t\tif (TCP_SKB_CB(skb)->ack_seq != tp->snd_una) {\n\t\t\t\t/* Well, only one small jumplet in fast path... */\n\t\t\t\ttcp_ack(sk, skb, FLAG_DATA);\n\t\t\t\ttcp_data_snd_check(sk);\n\t\t\t\tif (!inet_csk_ack_scheduled(sk))\n\t\t\t\t\tgoto no_ack;\n\t\t\t} else {\n\t\t\t\ttcp_update_wl(tp, TCP_SKB_CB(skb)->seq);\n\t\t\t}\n\n\t\t\t__tcp_ack_snd_check(sk, 0);\nno_ack:\n\t\t\tif (eaten)\n\t\t\t\tkfree_skb_partial(skb, fragstolen);\n\t\t\ttcp_data_ready(sk);\n\t\t\treturn;\n\t\t}\n\t}\n\nslow_path:\n\tif (len < (th->doff << 2) || tcp_checksum_complete(skb))\n\t\tgoto csum_error;\n\n\tif (!th->ack && !th->rst && !th->syn)\n\t\tgoto discard;\n\n\t/*\n\t *\tStandard slow path.\n\t */\n\n\tif (!tcp_validate_incoming(sk, skb, th, 1))\n\t\treturn;\n\nstep5:\n\tif (tcp_ack(sk, skb, FLAG_SLOWPATH | FLAG_UPDATE_TS_RECENT) < 0)\n\t\tgoto discard;\n\n\ttcp_rcv_rtt_measure_ts(sk, skb);\n\n\t/* Process urgent data. */\n\ttcp_urg(sk, skb, th);\n\n\t/* step 7: process the segment text */\n\ttcp_data_queue(sk, skb);\n\n\ttcp_data_snd_check(sk);\n\ttcp_ack_snd_check(sk);\n\treturn;\n\ncsum_error:\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);\n\ndiscard:\n\ttcp_drop(sk, skb);\n}\nEXPORT_SYMBOL(tcp_rcv_established);\n\nvoid tcp_init_transfer(struct sock *sk, int bpf_op, struct sk_buff *skb)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\ttcp_mtup_init(sk);\n\ticsk->icsk_af_ops->rebuild_header(sk);\n\ttcp_init_metrics(sk);\n\n\t/* Initialize the congestion window to start the transfer.\n\t * Cut cwnd down to 1 per RFC5681 if SYN or SYN-ACK has been\n\t * retransmitted. In light of RFC6298 more aggressive 1sec\n\t * initRTO, we only reset cwnd when more than 1 SYN/SYN-ACK\n\t * retransmission has occurred.\n\t */\n\tif (tp->total_retrans > 1 && tp->undo_marker)\n\t\ttp->snd_cwnd = 1;\n\telse\n\t\ttp->snd_cwnd = tcp_init_cwnd(tp, __sk_dst_get(sk));\n\ttp->snd_cwnd_stamp = tcp_jiffies32;\n\n\ticsk->icsk_ca_initialized = 0;\n\tbpf_skops_established(sk, bpf_op, skb);\n\tif (!icsk->icsk_ca_initialized)\n\t\ttcp_init_congestion_control(sk);\n\ttcp_init_buffer_space(sk);\n}\n\nvoid tcp_finish_connect(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ttcp_set_state(sk, TCP_ESTABLISHED);\n\ticsk->icsk_ack.lrcvtime = tcp_jiffies32;\n\n\tif (skb) {\n\t\ticsk->icsk_af_ops->sk_rx_dst_set(sk, skb);\n\t\tsecurity_inet_conn_established(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t}\n\n\ttcp_init_transfer(sk, BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB, skb);\n\n\t/* Prevent spurious tcp_cwnd_restart() on first data\n\t * packet.\n\t */\n\ttp->lsndtime = tcp_jiffies32;\n\n\tif (sock_flag(sk, SOCK_KEEPOPEN))\n\t\tinet_csk_reset_keepalive_timer(sk, keepalive_time_when(tp));\n\n\tif (!tp->rx_opt.snd_wscale)\n\t\t__tcp_fast_path_on(tp, tp->snd_wnd);\n\telse\n\t\ttp->pred_flags = 0;\n}\n\nstatic bool tcp_rcv_fastopen_synack(struct sock *sk, struct sk_buff *synack,\n\t\t\t\t    struct tcp_fastopen_cookie *cookie)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *data = tp->syn_data ? tcp_rtx_queue_head(sk) : NULL;\n\tu16 mss = tp->rx_opt.mss_clamp, try_exp = 0;\n\tbool syn_drop = false;\n\n\tif (mss == tp->rx_opt.user_mss) {\n\t\tstruct tcp_options_received opt;\n\n\t\t/* Get original SYNACK MSS value if user MSS sets mss_clamp */\n\t\ttcp_clear_options(&opt);\n\t\topt.user_mss = opt.mss_clamp = 0;\n\t\ttcp_parse_options(sock_net(sk), synack, &opt, 0, NULL);\n\t\tmss = opt.mss_clamp;\n\t}\n\n\tif (!tp->syn_fastopen) {\n\t\t/* Ignore an unsolicited cookie */\n\t\tcookie->len = -1;\n\t} else if (tp->total_retrans) {\n\t\t/* SYN timed out and the SYN-ACK neither has a cookie nor\n\t\t * acknowledges data. Presumably the remote received only\n\t\t * the retransmitted (regular) SYNs: either the original\n\t\t * SYN-data or the corresponding SYN-ACK was dropped.\n\t\t */\n\t\tsyn_drop = (cookie->len < 0 && data);\n\t} else if (cookie->len < 0 && !tp->syn_data) {\n\t\t/* We requested a cookie but didn't get it. If we did not use\n\t\t * the (old) exp opt format then try so next time (try_exp=1).\n\t\t * Otherwise we go back to use the RFC7413 opt (try_exp=2).\n\t\t */\n\t\ttry_exp = tp->syn_fastopen_exp ? 2 : 1;\n\t}\n\n\ttcp_fastopen_cache_set(sk, mss, cookie, syn_drop, try_exp);\n\n\tif (data) { /* Retransmit unacked data in SYN */\n\t\tif (tp->total_retrans)\n\t\t\ttp->fastopen_client_fail = TFO_SYN_RETRANSMITTED;\n\t\telse\n\t\t\ttp->fastopen_client_fail = TFO_DATA_NOT_ACKED;\n\t\tskb_rbtree_walk_from(data) {\n\t\t\tif (__tcp_retransmit_skb(sk, data, 1))\n\t\t\t\tbreak;\n\t\t}\n\t\ttcp_rearm_rto(sk);\n\t\tNET_INC_STATS(sock_net(sk),\n\t\t\t\tLINUX_MIB_TCPFASTOPENACTIVEFAIL);\n\t\treturn true;\n\t}\n\ttp->syn_data_acked = tp->syn_data;\n\tif (tp->syn_data_acked) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPFASTOPENACTIVE);\n\t\t/* SYN-data is counted as two separate packets in tcp_ack() */\n\t\tif (tp->delivered > 1)\n\t\t\t--tp->delivered;\n\t}\n\n\ttcp_fastopen_add_skb(sk, synack);\n\n\treturn false;\n}\n\nstatic void smc_check_reset_syn(struct tcp_sock *tp)\n{\n#if IS_ENABLED(CONFIG_SMC)\n\tif (static_branch_unlikely(&tcp_have_smc)) {\n\t\tif (tp->syn_smc && !tp->rx_opt.smc_ok)\n\t\t\ttp->syn_smc = 0;\n\t}\n#endif\n}\n\nstatic void tcp_try_undo_spurious_syn(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 syn_stamp;\n\n\t/* undo_marker is set when SYN or SYNACK times out. The timeout is\n\t * spurious if the ACK's timestamp option echo value matches the\n\t * original SYN timestamp.\n\t */\n\tsyn_stamp = tp->retrans_stamp;\n\tif (tp->undo_marker && syn_stamp && tp->rx_opt.saw_tstamp &&\n\t    syn_stamp == tp->rx_opt.rcv_tsecr)\n\t\ttp->undo_marker = 0;\n}\n\nstatic int tcp_rcv_synsent_state_process(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t const struct tcphdr *th)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp_fastopen_cookie foc = { .len = -1 };\n\tint saved_clamp = tp->rx_opt.mss_clamp;\n\tbool fastopen_fail;\n\n\ttcp_parse_options(sock_net(sk), skb, &tp->rx_opt, 0, &foc);\n\tif (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr)\n\t\ttp->rx_opt.rcv_tsecr -= tp->tsoffset;\n\n\tif (th->ack) {\n\t\t/* rfc793:\n\t\t * \"If the state is SYN-SENT then\n\t\t *    first check the ACK bit\n\t\t *      If the ACK bit is set\n\t\t *\t  If SEG.ACK =< ISS, or SEG.ACK > SND.NXT, send\n\t\t *        a reset (unless the RST bit is set, if so drop\n\t\t *        the segment and return)\"\n\t\t */\n\t\tif (!after(TCP_SKB_CB(skb)->ack_seq, tp->snd_una) ||\n\t\t    after(TCP_SKB_CB(skb)->ack_seq, tp->snd_nxt)) {\n\t\t\t/* Previous FIN/ACK or RST/ACK might be ignored. */\n\t\t\tif (icsk->icsk_retransmits == 0)\n\t\t\t\tinet_csk_reset_xmit_timer(sk,\n\t\t\t\t\t\tICSK_TIME_RETRANS,\n\t\t\t\t\t\tTCP_TIMEOUT_MIN, TCP_RTO_MAX);\n\t\t\tgoto reset_and_undo;\n\t\t}\n\n\t\tif (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr &&\n\t\t    !between(tp->rx_opt.rcv_tsecr, tp->retrans_stamp,\n\t\t\t     tcp_time_stamp(tp))) {\n\t\t\tNET_INC_STATS(sock_net(sk),\n\t\t\t\t\tLINUX_MIB_PAWSACTIVEREJECTED);\n\t\t\tgoto reset_and_undo;\n\t\t}\n\n\t\t/* Now ACK is acceptable.\n\t\t *\n\t\t * \"If the RST bit is set\n\t\t *    If the ACK was acceptable then signal the user \"error:\n\t\t *    connection reset\", drop the segment, enter CLOSED state,\n\t\t *    delete TCB, and return.\"\n\t\t */\n\n\t\tif (th->rst) {\n\t\t\ttcp_reset(sk);\n\t\t\tgoto discard;\n\t\t}\n\n\t\t/* rfc793:\n\t\t *   \"fifth, if neither of the SYN or RST bits is set then\n\t\t *    drop the segment and return.\"\n\t\t *\n\t\t *    See note below!\n\t\t *                                        --ANK(990513)\n\t\t */\n\t\tif (!th->syn)\n\t\t\tgoto discard_and_undo;\n\n\t\t/* rfc793:\n\t\t *   \"If the SYN bit is on ...\n\t\t *    are acceptable then ...\n\t\t *    (our SYN has been ACKed), change the connection\n\t\t *    state to ESTABLISHED...\"\n\t\t */\n\n\t\ttcp_ecn_rcv_synack(tp, th);\n\n\t\ttcp_init_wl(tp, TCP_SKB_CB(skb)->seq);\n\t\ttcp_try_undo_spurious_syn(sk);\n\t\ttcp_ack(sk, skb, FLAG_SLOWPATH);\n\n\t\t/* Ok.. it's good. Set up sequence numbers and\n\t\t * move to established.\n\t\t */\n\t\tWRITE_ONCE(tp->rcv_nxt, TCP_SKB_CB(skb)->seq + 1);\n\t\ttp->rcv_wup = TCP_SKB_CB(skb)->seq + 1;\n\n\t\t/* RFC1323: The window in SYN & SYN/ACK segments is\n\t\t * never scaled.\n\t\t */\n\t\ttp->snd_wnd = ntohs(th->window);\n\n\t\tif (!tp->rx_opt.wscale_ok) {\n\t\t\ttp->rx_opt.snd_wscale = tp->rx_opt.rcv_wscale = 0;\n\t\t\ttp->window_clamp = min(tp->window_clamp, 65535U);\n\t\t}\n\n\t\tif (tp->rx_opt.saw_tstamp) {\n\t\t\ttp->rx_opt.tstamp_ok\t   = 1;\n\t\t\ttp->tcp_header_len =\n\t\t\t\tsizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED;\n\t\t\ttp->advmss\t    -= TCPOLEN_TSTAMP_ALIGNED;\n\t\t\ttcp_store_ts_recent(tp);\n\t\t} else {\n\t\t\ttp->tcp_header_len = sizeof(struct tcphdr);\n\t\t}\n\n\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\ttcp_initialize_rcv_mss(sk);\n\n\t\t/* Remember, tcp_poll() does not lock socket!\n\t\t * Change state from SYN-SENT only after copied_seq\n\t\t * is initialized. */\n\t\tWRITE_ONCE(tp->copied_seq, tp->rcv_nxt);\n\n\t\tsmc_check_reset_syn(tp);\n\n\t\tsmp_mb();\n\n\t\ttcp_finish_connect(sk, skb);\n\n\t\tfastopen_fail = (tp->syn_fastopen || tp->syn_data) &&\n\t\t\t\ttcp_rcv_fastopen_synack(sk, skb, &foc);\n\n\t\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t\t}\n\t\tif (fastopen_fail)\n\t\t\treturn -1;\n\t\tif (sk->sk_write_pending ||\n\t\t    icsk->icsk_accept_queue.rskq_defer_accept ||\n\t\t    inet_csk_in_pingpong_mode(sk)) {\n\t\t\t/* Save one ACK. Data will be ready after\n\t\t\t * several ticks, if write_pending is set.\n\t\t\t *\n\t\t\t * It may be deleted, but with this feature tcpdumps\n\t\t\t * look so _wonderfully_ clever, that I was not able\n\t\t\t * to stand against the temptation 8)     --ANK\n\t\t\t */\n\t\t\tinet_csk_schedule_ack(sk);\n\t\t\ttcp_enter_quickack_mode(sk, TCP_MAX_QUICKACKS);\n\t\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_DACK,\n\t\t\t\t\t\t  TCP_DELACK_MAX, TCP_RTO_MAX);\n\ndiscard:\n\t\t\ttcp_drop(sk, skb);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\ttcp_send_ack(sk);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* No ACK in the segment */\n\n\tif (th->rst) {\n\t\t/* rfc793:\n\t\t * \"If the RST bit is set\n\t\t *\n\t\t *      Otherwise (no ACK) drop the segment and return.\"\n\t\t */\n\n\t\tgoto discard_and_undo;\n\t}\n\n\t/* PAWS check. */\n\tif (tp->rx_opt.ts_recent_stamp && tp->rx_opt.saw_tstamp &&\n\t    tcp_paws_reject(&tp->rx_opt, 0))\n\t\tgoto discard_and_undo;\n\n\tif (th->syn) {\n\t\t/* We see SYN without ACK. It is attempt of\n\t\t * simultaneous connect with crossed SYNs.\n\t\t * Particularly, it can be connect to self.\n\t\t */\n\t\ttcp_set_state(sk, TCP_SYN_RECV);\n\n\t\tif (tp->rx_opt.saw_tstamp) {\n\t\t\ttp->rx_opt.tstamp_ok = 1;\n\t\t\ttcp_store_ts_recent(tp);\n\t\t\ttp->tcp_header_len =\n\t\t\t\tsizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED;\n\t\t} else {\n\t\t\ttp->tcp_header_len = sizeof(struct tcphdr);\n\t\t}\n\n\t\tWRITE_ONCE(tp->rcv_nxt, TCP_SKB_CB(skb)->seq + 1);\n\t\tWRITE_ONCE(tp->copied_seq, tp->rcv_nxt);\n\t\ttp->rcv_wup = TCP_SKB_CB(skb)->seq + 1;\n\n\t\t/* RFC1323: The window in SYN & SYN/ACK segments is\n\t\t * never scaled.\n\t\t */\n\t\ttp->snd_wnd    = ntohs(th->window);\n\t\ttp->snd_wl1    = TCP_SKB_CB(skb)->seq;\n\t\ttp->max_window = tp->snd_wnd;\n\n\t\ttcp_ecn_rcv_syn(tp, th);\n\n\t\ttcp_mtup_init(sk);\n\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\ttcp_initialize_rcv_mss(sk);\n\n\t\ttcp_send_synack(sk);\n#if 0\n\t\t/* Note, we could accept data and URG from this segment.\n\t\t * There are no obstacles to make this (except that we must\n\t\t * either change tcp_recvmsg() to prevent it from returning data\n\t\t * before 3WHS completes per RFC793, or employ TCP Fast Open).\n\t\t *\n\t\t * However, if we ignore data in ACKless segments sometimes,\n\t\t * we have no reasons to accept it sometimes.\n\t\t * Also, seems the code doing it in step6 of tcp_rcv_state_process\n\t\t * is not flawless. So, discard packet for sanity.\n\t\t * Uncomment this return to process the data.\n\t\t */\n\t\treturn -1;\n#else\n\t\tgoto discard;\n#endif\n\t}\n\t/* \"fifth, if neither of the SYN or RST bits is set then\n\t * drop the segment and return.\"\n\t */\n\ndiscard_and_undo:\n\ttcp_clear_options(&tp->rx_opt);\n\ttp->rx_opt.mss_clamp = saved_clamp;\n\tgoto discard;\n\nreset_and_undo:\n\ttcp_clear_options(&tp->rx_opt);\n\ttp->rx_opt.mss_clamp = saved_clamp;\n\treturn 1;\n}\n\nstatic void tcp_rcv_synrecv_state_fastopen(struct sock *sk)\n{\n\tstruct request_sock *req;\n\n\t/* If we are still handling the SYNACK RTO, see if timestamp ECR allows\n\t * undo. If peer SACKs triggered fast recovery, we can't undo here.\n\t */\n\tif (inet_csk(sk)->icsk_ca_state == TCP_CA_Loss)\n\t\ttcp_try_undo_loss(sk, false);\n\n\t/* Reset rtx states to prevent spurious retransmits_timed_out() */\n\ttcp_sk(sk)->retrans_stamp = 0;\n\tinet_csk(sk)->icsk_retransmits = 0;\n\n\t/* Once we leave TCP_SYN_RECV or TCP_FIN_WAIT_1,\n\t * we no longer need req so release it.\n\t */\n\treq = rcu_dereference_protected(tcp_sk(sk)->fastopen_rsk,\n\t\t\t\t\tlockdep_sock_is_held(sk));\n\treqsk_fastopen_remove(sk, req, false);\n\n\t/* Re-arm the timer because data may have been sent out.\n\t * This is similar to the regular data transmission case\n\t * when new data has just been ack'ed.\n\t *\n\t * (TFO) - we could try to be more aggressive and\n\t * retransmitting any data sooner based on when they\n\t * are sent out.\n\t */\n\ttcp_rearm_rto(sk);\n}\n\n/*\n *\tThis function implements the receiving procedure of RFC 793 for\n *\tall states except ESTABLISHED and TIME_WAIT.\n *\tIt's called from both tcp_v4_rcv and tcp_v6_rcv and should be\n *\taddress independent.\n */\n\nint tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tstruct request_sock *req;\n\tint queued = 0;\n\tbool acceptable;\n\n\tswitch (sk->sk_state) {\n\tcase TCP_CLOSE:\n\t\tgoto discard;\n\n\tcase TCP_LISTEN:\n\t\tif (th->ack)\n\t\t\treturn 1;\n\n\t\tif (th->rst)\n\t\t\tgoto discard;\n\n\t\tif (th->syn) {\n\t\t\tif (th->fin)\n\t\t\t\tgoto discard;\n\t\t\t/* It is possible that we process SYN packets from backlog,\n\t\t\t * so we need to make sure to disable BH and RCU right there.\n\t\t\t */\n\t\t\trcu_read_lock();\n\t\t\tlocal_bh_disable();\n\t\t\tacceptable = icsk->icsk_af_ops->conn_request(sk, skb) >= 0;\n\t\t\tlocal_bh_enable();\n\t\t\trcu_read_unlock();\n\n\t\t\tif (!acceptable)\n\t\t\t\treturn 1;\n\t\t\tconsume_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tgoto discard;\n\n\tcase TCP_SYN_SENT:\n\t\ttp->rx_opt.saw_tstamp = 0;\n\t\ttcp_mstamp_refresh(tp);\n\t\tqueued = tcp_rcv_synsent_state_process(sk, skb, th);\n\t\tif (queued >= 0)\n\t\t\treturn queued;\n\n\t\t/* Do step6 onward by hand. */\n\t\ttcp_urg(sk, skb, th);\n\t\t__kfree_skb(skb);\n\t\ttcp_data_snd_check(sk);\n\t\treturn 0;\n\t}\n\n\ttcp_mstamp_refresh(tp);\n\ttp->rx_opt.saw_tstamp = 0;\n\treq = rcu_dereference_protected(tp->fastopen_rsk,\n\t\t\t\t\tlockdep_sock_is_held(sk));\n\tif (req) {\n\t\tbool req_stolen;\n\n\t\tWARN_ON_ONCE(sk->sk_state != TCP_SYN_RECV &&\n\t\t    sk->sk_state != TCP_FIN_WAIT1);\n\n\t\tif (!tcp_check_req(sk, skb, req, true, &req_stolen))\n\t\t\tgoto discard;\n\t}\n\n\tif (!th->ack && !th->rst && !th->syn)\n\t\tgoto discard;\n\n\tif (!tcp_validate_incoming(sk, skb, th, 0))\n\t\treturn 0;\n\n\t/* step 5: check the ACK field */\n\tacceptable = tcp_ack(sk, skb, FLAG_SLOWPATH |\n\t\t\t\t      FLAG_UPDATE_TS_RECENT |\n\t\t\t\t      FLAG_NO_CHALLENGE_ACK) > 0;\n\n\tif (!acceptable) {\n\t\tif (sk->sk_state == TCP_SYN_RECV)\n\t\t\treturn 1;\t/* send one RST */\n\t\ttcp_send_challenge_ack(sk, skb);\n\t\tgoto discard;\n\t}\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_RECV:\n\t\ttp->delivered++; /* SYN-ACK delivery isn't tracked in tcp_ack */\n\t\tif (!tp->srtt_us)\n\t\t\ttcp_synack_rtt_meas(sk, req);\n\n\t\tif (req) {\n\t\t\ttcp_rcv_synrecv_state_fastopen(sk);\n\t\t} else {\n\t\t\ttcp_try_undo_spurious_syn(sk);\n\t\t\ttp->retrans_stamp = 0;\n\t\t\ttcp_init_transfer(sk, BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB,\n\t\t\t\t\t  skb);\n\t\t\tWRITE_ONCE(tp->copied_seq, tp->rcv_nxt);\n\t\t}\n\t\tsmp_mb();\n\t\ttcp_set_state(sk, TCP_ESTABLISHED);\n\t\tsk->sk_state_change(sk);\n\n\t\t/* Note, that this wakeup is only for marginal crossed SYN case.\n\t\t * Passively open sockets are not waked up, because\n\t\t * sk->sk_sleep == NULL and sk->sk_socket == NULL.\n\t\t */\n\t\tif (sk->sk_socket)\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\n\t\ttp->snd_una = TCP_SKB_CB(skb)->ack_seq;\n\t\ttp->snd_wnd = ntohs(th->window) << tp->rx_opt.snd_wscale;\n\t\ttcp_init_wl(tp, TCP_SKB_CB(skb)->seq);\n\n\t\tif (tp->rx_opt.tstamp_ok)\n\t\t\ttp->advmss -= TCPOLEN_TSTAMP_ALIGNED;\n\n\t\tif (!inet_csk(sk)->icsk_ca_ops->cong_control)\n\t\t\ttcp_update_pacing_rate(sk);\n\n\t\t/* Prevent spurious tcp_cwnd_restart() on first data packet */\n\t\ttp->lsndtime = tcp_jiffies32;\n\n\t\ttcp_initialize_rcv_mss(sk);\n\t\ttcp_fast_path_on(tp);\n\t\tbreak;\n\n\tcase TCP_FIN_WAIT1: {\n\t\tint tmo;\n\n\t\tif (req)\n\t\t\ttcp_rcv_synrecv_state_fastopen(sk);\n\n\t\tif (tp->snd_una != tp->write_seq)\n\t\t\tbreak;\n\n\t\ttcp_set_state(sk, TCP_FIN_WAIT2);\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\n\t\tsk_dst_confirm(sk);\n\n\t\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\t\t/* Wake up lingering close() */\n\t\t\tsk->sk_state_change(sk);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tp->linger2 < 0) {\n\t\t\ttcp_done(sk);\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);\n\t\t\treturn 1;\n\t\t}\n\t\tif (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\n\t\t    after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt)) {\n\t\t\t/* Receive out of order FIN after close() */\n\t\t\tif (tp->syn_fastopen && th->fin)\n\t\t\t\ttcp_fastopen_active_disable(sk);\n\t\t\ttcp_done(sk);\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);\n\t\t\treturn 1;\n\t\t}\n\n\t\ttmo = tcp_fin_time(sk);\n\t\tif (tmo > TCP_TIMEWAIT_LEN) {\n\t\t\tinet_csk_reset_keepalive_timer(sk, tmo - TCP_TIMEWAIT_LEN);\n\t\t} else if (th->fin || sock_owned_by_user(sk)) {\n\t\t\t/* Bad case. We could lose such FIN otherwise.\n\t\t\t * It is not a big problem, but it looks confusing\n\t\t\t * and not so rare event. We still can lose it now,\n\t\t\t * if it spins in bh_lock_sock(), but it is really\n\t\t\t * marginal case.\n\t\t\t */\n\t\t\tinet_csk_reset_keepalive_timer(sk, tmo);\n\t\t} else {\n\t\t\ttcp_time_wait(sk, TCP_FIN_WAIT2, tmo);\n\t\t\tgoto discard;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase TCP_CLOSING:\n\t\tif (tp->snd_una == tp->write_seq) {\n\t\t\ttcp_time_wait(sk, TCP_TIME_WAIT, 0);\n\t\t\tgoto discard;\n\t\t}\n\t\tbreak;\n\n\tcase TCP_LAST_ACK:\n\t\tif (tp->snd_una == tp->write_seq) {\n\t\t\ttcp_update_metrics(sk);\n\t\t\ttcp_done(sk);\n\t\t\tgoto discard;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* step 6: check the URG bit */\n\ttcp_urg(sk, skb, th);\n\n\t/* step 7: process the segment text */\n\tswitch (sk->sk_state) {\n\tcase TCP_CLOSE_WAIT:\n\tcase TCP_CLOSING:\n\tcase TCP_LAST_ACK:\n\t\tif (!before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {\n\t\t\tif (sk_is_mptcp(sk))\n\t\t\t\tmptcp_incoming_options(sk, skb);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase TCP_FIN_WAIT1:\n\tcase TCP_FIN_WAIT2:\n\t\t/* RFC 793 says to queue data in these states,\n\t\t * RFC 1122 says we MUST send a reset.\n\t\t * BSD 4.4 also does reset.\n\t\t */\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\t\tif (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\n\t\t\t    after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt)) {\n\t\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);\n\t\t\t\ttcp_reset(sk);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tfallthrough;\n\tcase TCP_ESTABLISHED:\n\t\ttcp_data_queue(sk, skb);\n\t\tqueued = 1;\n\t\tbreak;\n\t}\n\n\t/* tcp_data could move socket to TIME-WAIT */\n\tif (sk->sk_state != TCP_CLOSE) {\n\t\ttcp_data_snd_check(sk);\n\t\ttcp_ack_snd_check(sk);\n\t}\n\n\tif (!queued) {\ndiscard:\n\t\ttcp_drop(sk, skb);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(tcp_rcv_state_process);\n\nstatic inline void pr_drop_req(struct request_sock *req, __u16 port, int family)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\n\tif (family == AF_INET)\n\t\tnet_dbg_ratelimited(\"drop open request from %pI4/%u\\n\",\n\t\t\t\t    &ireq->ir_rmt_addr, port);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse if (family == AF_INET6)\n\t\tnet_dbg_ratelimited(\"drop open request from %pI6/%u\\n\",\n\t\t\t\t    &ireq->ir_v6_rmt_addr, port);\n#endif\n}\n\n/* RFC3168 : 6.1.1 SYN packets must not have ECT/ECN bits set\n *\n * If we receive a SYN packet with these bits set, it means a\n * network is playing bad games with TOS bits. In order to\n * avoid possible false congestion notifications, we disable\n * TCP ECN negotiation.\n *\n * Exception: tcp_ca wants ECN. This is required for DCTCP\n * congestion control: Linux DCTCP asserts ECT on all packets,\n * including SYN, which is most optimal solution; however,\n * others, such as FreeBSD do not.\n *\n * Exception: At least one of the reserved bits of the TCP header (th->res1) is\n * set, indicating the use of a future TCP extension (such as AccECN). See\n * RFC8311 \u00a74.3 which updates RFC3168 to allow the development of such\n * extensions.\n */\nstatic void tcp_ecn_create_request(struct request_sock *req,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   const struct sock *listen_sk,\n\t\t\t\t   const struct dst_entry *dst)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tconst struct net *net = sock_net(listen_sk);\n\tbool th_ecn = th->ece && th->cwr;\n\tbool ect, ecn_ok;\n\tu32 ecn_ok_dst;\n\n\tif (!th_ecn)\n\t\treturn;\n\n\tect = !INET_ECN_is_not_ect(TCP_SKB_CB(skb)->ip_dsfield);\n\tecn_ok_dst = dst_feature(dst, DST_FEATURE_ECN_MASK);\n\tecn_ok = net->ipv4.sysctl_tcp_ecn || ecn_ok_dst;\n\n\tif (((!ect || th->res1) && ecn_ok) || tcp_ca_needs_ecn(listen_sk) ||\n\t    (ecn_ok_dst & DST_FEATURE_ECN_CA) ||\n\t    tcp_bpf_ca_needs_ecn((struct sock *)req))\n\t\tinet_rsk(req)->ecn_ok = 1;\n}\n\nstatic void tcp_openreq_init(struct request_sock *req,\n\t\t\t     const struct tcp_options_received *rx_opt,\n\t\t\t     struct sk_buff *skb, const struct sock *sk)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\n\treq->rsk_rcv_wnd = 0;\t\t/* So that tcp_send_synack() knows! */\n\ttcp_rsk(req)->rcv_isn = TCP_SKB_CB(skb)->seq;\n\ttcp_rsk(req)->rcv_nxt = TCP_SKB_CB(skb)->seq + 1;\n\ttcp_rsk(req)->snt_synack = 0;\n\ttcp_rsk(req)->last_oow_ack_time = 0;\n\treq->mss = rx_opt->mss_clamp;\n\treq->ts_recent = rx_opt->saw_tstamp ? rx_opt->rcv_tsval : 0;\n\tireq->tstamp_ok = rx_opt->tstamp_ok;\n\tireq->sack_ok = rx_opt->sack_ok;\n\tireq->snd_wscale = rx_opt->snd_wscale;\n\tireq->wscale_ok = rx_opt->wscale_ok;\n\tireq->acked = 0;\n\tireq->ecn_ok = 0;\n\tireq->ir_rmt_port = tcp_hdr(skb)->source;\n\tireq->ir_num = ntohs(tcp_hdr(skb)->dest);\n\tireq->ir_mark = inet_request_mark(sk, skb);\n#if IS_ENABLED(CONFIG_SMC)\n\tireq->smc_ok = rx_opt->smc_ok;\n#endif\n}\n\nstruct request_sock *inet_reqsk_alloc(const struct request_sock_ops *ops,\n\t\t\t\t      struct sock *sk_listener,\n\t\t\t\t      bool attach_listener)\n{\n\tstruct request_sock *req = reqsk_alloc(ops, sk_listener,\n\t\t\t\t\t       attach_listener);\n\n\tif (req) {\n\t\tstruct inet_request_sock *ireq = inet_rsk(req);\n\n\t\tireq->ireq_opt = NULL;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tireq->pktopts = NULL;\n#endif\n\t\tatomic64_set(&ireq->ir_cookie, 0);\n\t\tireq->ireq_state = TCP_NEW_SYN_RECV;\n\t\twrite_pnet(&ireq->ireq_net, sock_net(sk_listener));\n\t\tireq->ireq_family = sk_listener->sk_family;\n\t}\n\n\treturn req;\n}\nEXPORT_SYMBOL(inet_reqsk_alloc);\n\n/*\n * Return true if a syncookie should be sent\n */\nstatic bool tcp_syn_flood_action(const struct sock *sk, const char *proto)\n{\n\tstruct request_sock_queue *queue = &inet_csk(sk)->icsk_accept_queue;\n\tconst char *msg = \"Dropping request\";\n\tbool want_cookie = false;\n\tstruct net *net = sock_net(sk);\n\n#ifdef CONFIG_SYN_COOKIES\n\tif (net->ipv4.sysctl_tcp_syncookies) {\n\t\tmsg = \"Sending cookies\";\n\t\twant_cookie = true;\n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPREQQFULLDOCOOKIES);\n\t} else\n#endif\n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPREQQFULLDROP);\n\n\tif (!queue->synflood_warned &&\n\t    net->ipv4.sysctl_tcp_syncookies != 2 &&\n\t    xchg(&queue->synflood_warned, 1) == 0)\n\t\tnet_info_ratelimited(\"%s: Possible SYN flooding on port %d. %s.  Check SNMP counters.\\n\",\n\t\t\t\t     proto, sk->sk_num, msg);\n\n\treturn want_cookie;\n}\n\nstatic void tcp_reqsk_record_syn(const struct sock *sk,\n\t\t\t\t struct request_sock *req,\n\t\t\t\t const struct sk_buff *skb)\n{\n\tif (tcp_sk(sk)->save_syn) {\n\t\tu32 len = skb_network_header_len(skb) + tcp_hdrlen(skb);\n\t\tstruct saved_syn *saved_syn;\n\t\tu32 mac_hdrlen;\n\t\tvoid *base;\n\n\t\tif (tcp_sk(sk)->save_syn == 2) {  /* Save full header. */\n\t\t\tbase = skb_mac_header(skb);\n\t\t\tmac_hdrlen = skb_mac_header_len(skb);\n\t\t\tlen += mac_hdrlen;\n\t\t} else {\n\t\t\tbase = skb_network_header(skb);\n\t\t\tmac_hdrlen = 0;\n\t\t}\n\n\t\tsaved_syn = kmalloc(struct_size(saved_syn, data, len),\n\t\t\t\t    GFP_ATOMIC);\n\t\tif (saved_syn) {\n\t\t\tsaved_syn->mac_hdrlen = mac_hdrlen;\n\t\t\tsaved_syn->network_hdrlen = skb_network_header_len(skb);\n\t\t\tsaved_syn->tcp_hdrlen = tcp_hdrlen(skb);\n\t\t\tmemcpy(saved_syn->data, base, len);\n\t\t\treq->saved_syn = saved_syn;\n\t\t}\n\t}\n}\n\n/* If a SYN cookie is required and supported, returns a clamped MSS value to be\n * used for SYN cookie generation.\n */\nu16 tcp_get_syncookie_mss(struct request_sock_ops *rsk_ops,\n\t\t\t  const struct tcp_request_sock_ops *af_ops,\n\t\t\t  struct sock *sk, struct tcphdr *th)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu16 mss;\n\n\tif (sock_net(sk)->ipv4.sysctl_tcp_syncookies != 2 &&\n\t    !inet_csk_reqsk_queue_is_full(sk))\n\t\treturn 0;\n\n\tif (!tcp_syn_flood_action(sk, rsk_ops->slab_name))\n\t\treturn 0;\n\n\tif (sk_acceptq_is_full(sk)) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\n\t\treturn 0;\n\t}\n\n\tmss = tcp_parse_mss_option(th, tp->rx_opt.user_mss);\n\tif (!mss)\n\t\tmss = af_ops->mss_clamp;\n\n\treturn mss;\n}\nEXPORT_SYMBOL_GPL(tcp_get_syncookie_mss);\n\nint tcp_conn_request(struct request_sock_ops *rsk_ops,\n\t\t     const struct tcp_request_sock_ops *af_ops,\n\t\t     struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_fastopen_cookie foc = { .len = -1 };\n\t__u32 isn = TCP_SKB_CB(skb)->tcp_tw_isn;\n\tstruct tcp_options_received tmp_opt;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct sock *fastopen_sk = NULL;\n\tstruct request_sock *req;\n\tbool want_cookie = false;\n\tstruct dst_entry *dst;\n\tstruct flowi fl;\n\n\t/* TW buckets are converted to open requests without\n\t * limitations, they conserve resources and peer is\n\t * evidently real one.\n\t */\n\tif ((net->ipv4.sysctl_tcp_syncookies == 2 ||\n\t     inet_csk_reqsk_queue_is_full(sk)) && !isn) {\n\t\twant_cookie = tcp_syn_flood_action(sk, rsk_ops->slab_name);\n\t\tif (!want_cookie)\n\t\t\tgoto drop;\n\t}\n\n\tif (sk_acceptq_is_full(sk)) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\n\t\tgoto drop;\n\t}\n\n\treq = inet_reqsk_alloc(rsk_ops, sk, !want_cookie);\n\tif (!req)\n\t\tgoto drop;\n\n\treq->syncookie = want_cookie;\n\ttcp_rsk(req)->af_specific = af_ops;\n\ttcp_rsk(req)->ts_off = 0;\n#if IS_ENABLED(CONFIG_MPTCP)\n\ttcp_rsk(req)->is_mptcp = 0;\n#endif\n\n\ttcp_clear_options(&tmp_opt);\n\ttmp_opt.mss_clamp = af_ops->mss_clamp;\n\ttmp_opt.user_mss  = tp->rx_opt.user_mss;\n\ttcp_parse_options(sock_net(sk), skb, &tmp_opt, 0,\n\t\t\t  want_cookie ? NULL : &foc);\n\n\tif (want_cookie && !tmp_opt.saw_tstamp)\n\t\ttcp_clear_options(&tmp_opt);\n\n\tif (IS_ENABLED(CONFIG_SMC) && want_cookie)\n\t\ttmp_opt.smc_ok = 0;\n\n\ttmp_opt.tstamp_ok = tmp_opt.saw_tstamp;\n\ttcp_openreq_init(req, &tmp_opt, skb, sk);\n\tinet_rsk(req)->no_srccheck = inet_sk(sk)->transparent;\n\n\t/* Note: tcp_v6_init_req() might override ir_iif for link locals */\n\tinet_rsk(req)->ir_iif = inet_request_bound_dev_if(sk, skb);\n\n\taf_ops->init_req(req, sk, skb);\n\n\tif (security_inet_conn_request(sk, skb, req))\n\t\tgoto drop_and_free;\n\n\tif (tmp_opt.tstamp_ok)\n\t\ttcp_rsk(req)->ts_off = af_ops->init_ts_off(net, skb);\n\n\tdst = af_ops->route_req(sk, &fl, req);\n\tif (!dst)\n\t\tgoto drop_and_free;\n\n\tif (!want_cookie && !isn) {\n\t\t/* Kill the following clause, if you dislike this way. */\n\t\tif (!net->ipv4.sysctl_tcp_syncookies &&\n\t\t    (net->ipv4.sysctl_max_syn_backlog - inet_csk_reqsk_queue_len(sk) <\n\t\t     (net->ipv4.sysctl_max_syn_backlog >> 2)) &&\n\t\t    !tcp_peer_is_proven(req, dst)) {\n\t\t\t/* Without syncookies last quarter of\n\t\t\t * backlog is filled with destinations,\n\t\t\t * proven to be alive.\n\t\t\t * It means that we continue to communicate\n\t\t\t * to destinations, already remembered\n\t\t\t * to the moment of synflood.\n\t\t\t */\n\t\t\tpr_drop_req(req, ntohs(tcp_hdr(skb)->source),\n\t\t\t\t    rsk_ops->family);\n\t\t\tgoto drop_and_release;\n\t\t}\n\n\t\tisn = af_ops->init_seq(skb);\n\t}\n\n\ttcp_ecn_create_request(req, skb, sk, dst);\n\n\tif (want_cookie) {\n\t\tisn = cookie_init_sequence(af_ops, sk, skb, &req->mss);\n\t\tif (!tmp_opt.tstamp_ok)\n\t\t\tinet_rsk(req)->ecn_ok = 0;\n\t}\n\n\ttcp_rsk(req)->snt_isn = isn;\n\ttcp_rsk(req)->txhash = net_tx_rndhash();\n\ttcp_rsk(req)->syn_tos = TCP_SKB_CB(skb)->ip_dsfield;\n\ttcp_openreq_init_rwin(req, sk, dst);\n\tsk_rx_queue_set(req_to_sk(req), skb);\n\tif (!want_cookie) {\n\t\ttcp_reqsk_record_syn(sk, req, skb);\n\t\tfastopen_sk = tcp_try_fastopen(sk, skb, req, &foc, dst);\n\t}\n\tif (fastopen_sk) {\n\t\taf_ops->send_synack(fastopen_sk, dst, &fl, req,\n\t\t\t\t    &foc, TCP_SYNACK_FASTOPEN, skb);\n\t\t/* Add the child socket directly into the accept queue */\n\t\tif (!inet_csk_reqsk_queue_add(sk, req, fastopen_sk)) {\n\t\t\treqsk_fastopen_remove(fastopen_sk, req, false);\n\t\t\tbh_unlock_sock(fastopen_sk);\n\t\t\tsock_put(fastopen_sk);\n\t\t\tgoto drop_and_free;\n\t\t}\n\t\tsk->sk_data_ready(sk);\n\t\tbh_unlock_sock(fastopen_sk);\n\t\tsock_put(fastopen_sk);\n\t} else {\n\t\ttcp_rsk(req)->tfo_listener = false;\n\t\tif (!want_cookie)\n\t\t\tinet_csk_reqsk_queue_hash_add(sk, req,\n\t\t\t\ttcp_timeout_init((struct sock *)req));\n\t\taf_ops->send_synack(sk, dst, &fl, req, &foc,\n\t\t\t\t    !want_cookie ? TCP_SYNACK_NORMAL :\n\t\t\t\t\t\t   TCP_SYNACK_COOKIE,\n\t\t\t\t    skb);\n\t\tif (want_cookie) {\n\t\t\treqsk_free(req);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treqsk_put(req);\n\treturn 0;\n\ndrop_and_release:\n\tdst_release(dst);\ndrop_and_free:\n\t__reqsk_free(req);\ndrop:\n\ttcp_listendrop(sk);\n\treturn 0;\n}\nEXPORT_SYMBOL(tcp_conn_request);\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "da3c38ae19208bca9ce78fbb4df282b1", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "fd82c0ac56bf25585de712838a95e0e2", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c3e24ef67e85a8ad7a73b1714ed9b61f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "94e1c3a43b3f64a80a428bacaf362ddb", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "74808b5b3b88dd9ba1ae9297191f81d9", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "402772000767cf3c442a3543b67bb0f0", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e9b608df1c1b17de223228aa91605789", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8a04cabf0531f5b0ec4642e8cb089fd8", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b664e1b1ba0d3272dd8447aa294fcecc", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a2d73e78cf15668e67dcb753b9cd687b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3b9381e60e684050e637c94177dc5a5d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e558fad70dfa901ac0fcff97b78b771b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a0369800facc9b8154d970e8611b23c3", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b6b6144eff0a076644e18e14115700c9", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8c1b444066e11dad88a9ce68e490332e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "cb606e44be3ca0e7b9d7f1211f902037", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->sk_timer.expires'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b281bd484709601414689e749578aaa1", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b0c586a022d5086c82190a318ecf2fdc", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 312}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c08913e8f63c8e357d01dd166d2035c5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 332}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ecb73ebd20a6f2661e2a89a5060e943e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 332}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "324d397458589a65f6aa0c4b8519379a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 332}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "89700e2c2778d5de49d62e3c01a96237", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 332}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5103f633cd61c016d0a3f95efe904c16", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 332}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d9cad10976d25900e1f9c22010ee4618", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 332}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "868a339085ff35610e5190b6c98ae8cd", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 332}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "001fb2e45a285f3a4200584490dd4d38", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 332}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e6dc518d0caec46cc10922fc3422b32e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 332}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "1e116c5680aef7c37a6181d4bfecf07c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 332}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "72f3f2a5d52c192a463d665584bb5a9a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 332}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "684e86d6d85dcaef24c349d0e1699e07", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 332}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2068a50c4524238babb34257e525110a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 332}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "bcc03956b21a2c5390ea4f3aa2c64c78", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 332}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "86c6a7ec4946b8b34dbcd9813b0fdfa1", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 332}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4363952a6ac2a9211b204bf1ff4470cd", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 332}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b28ff27bea6154ea9df8307478a46343", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "885bb18a198a760551d76aab0c0a1a41", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e4cf3f9980d254a72df00a418b8aff9a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e05da8ba3d817995c027f4dd53e1a06c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b61e14a5f51b052811ca29ac52dc721b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ded0cff0677ce811b7384a599b1fa42c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7fc4f197ab3b43a4ff63c651813cfc6d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f6888920c20c54b1b78fe5ea7ffeb8bc", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "aff708a90e12246d2d71d2a2c8363a0b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c9f4448bc009018dd34f3cca2587f36f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8449cf9497c70f4bb158b3df9a9a8b67", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "19c6ad32c9ce8237f2b204ec0a1b238f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e4cb5b9696cbab4ade18676a66b20b95", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "41fd731f637cf6b0156517b354acab85", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "40a1879696ab9831b2de6be7b59225ed", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a49f2a5317f8343f5f7f10c732632fe4", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "eee1ed37a5987c0f013f8a5b0b207535", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ca5b2a9376d619d0f230d8ef1225f06e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 375}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "23497db605f3a31ad49dbc01ff2f747c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8e7071672cc325f9de18462ff0d16229", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f6f80d323f1032daeea4cb7b95784b0e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "9a977af3f3aa3d8ff656f69526e84981", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "31bf6c5422cf904a4b13aeba9bc479df", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "93c1a268b65739a777fa49e40006aaf1", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4c1d0a106932039980601043034e9133", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b5c7bce2faee0298e280d449385599da", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "285a7148924713f3ac4d2103f179304b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "74edbee4f06e3588ccc1aa409e2692d2", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5e62143074cb6be6b4585c4147ac36d7", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3bcf95f089d723170045b95dc7fc4289", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "39ad936414e355a48f95924ddecbaac5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5677de2174891d0d08164dba0794a793", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "1e3b548a816b5901528fd156eb001bcb", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "452a0d931c34ea30ef1b06c861a186bc", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "27247a29007dc14461483a121360161a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "717b5cec834a6edc841aea0ed790daa1", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 381}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "0438144464db88e2d60985767323a8fc", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "6adc0152e579e6c515296c57fada57d8", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ef66406241324654392350d020a0fdfb", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "91c21ea56ee7903e356de1341df5090d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d7bb4237baa9d229801f108ba89e3e2a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "098ad0ca2e868576dcf2be03dd31afe6", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3fd18484460d9415145d66b6c1f0f4a1", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d517b6e8fd0fe217ebab85275c59e131", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e75294f8711ef5b51d732c7f8f2ea275", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "6711f958c97669bd24d09f86694b4e4a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "34c9e60d9bf5b2cbf525987e38edc336", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "adf426820be1b2b08cb68428a79d681f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "567bb83a5e1a7596af531bccfa4310c6", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "28d0bd1b64b0e02e229165e5d5742123", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f67444f7e63d71a898e78eb138acf94c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ed4720c370b4d00a4ea45de424e9544d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a3e438a47b2ec825a9d0fe028feacebe", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7907c59bcd1033c774bb4e38125d304a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 387}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e728a3a6925b2ef27b4bc5a9c540965a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2b3252e00e6c472c329732a640c780bc", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e4095ae19261a537534336e99d8b237e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ee25fea4146a578c8349f3a281e2dc02", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b0e2a504f9ca931c3530565a95fb25e7", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c7c90b814e6dc1ed176187c735b062ba", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3c86317675fc164619ac0f4d9c1145e5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "9621401051262a707c116aa94f276020", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b42fbb655e22d06ef2a031fd0e1b6a8c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2eff2e9f2871ed11155e140c5ac2d66f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "6ca048a76018f7641b0c0b16be32100e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "599228258198b7c4082e6436dc3b4314", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "742e5c848a311292fbaa7feaff1ed039", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f910937ad9a3b0e2f073cf395433e64b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "9dae56916ed4aa3b395f97ccdd677036", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "46732d9899c23b50d6dfef7f5b090240", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "85338035ec68d5b408d5ff08d3e219b8", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "84b32927a6aa09227bc666768f0f2526", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 591}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "30800349d40570958e96dce497620f4e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b2edddebc7efa0eb4f6b713e2ee0fdaa", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2eadc24f1892f258940865a9325504b0", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b654a50f9f59fdf8757f5ae2478b95ad", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5ff256c13c86a31a30bd4dc2f95f2c05", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b7f4c7edbed3dfddaf13cb4b659115eb", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "12425c05aaab3b163880877ae62ae409", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e830337c0069cfca6fe4687ea4895aae", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5a7d608d9f578c2f2ff53d109511b743", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "54bcfd06d569e5766dfab29986f955f9", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8335169521b67dbe60f2b4c7b1e8b332", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "81c0aded02300ac05e75d1f51e98ac33", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2376e62980f93ddcd3fdf7a71daaf78a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5c4b05c474d461be01d33cf2b7c0dde2", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2d74a2b5ba92069bd0383aca61a36295", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8bcbbd5d8a885da0880815688e6cb8fa", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "000b039d938020ff45ae98f927bb1cec", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->sk_timer.expires'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "12b595943291a376474b0f6fb190bf74", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->sk_timer.flags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "699516d5e9b556c76f6b1a848ddc58b9", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b9ee9cd0ec7905ca887b53f87c8e3c1b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 623}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "acd5855d84faa9630a42616704cdc3b8", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f2948133f4d3287827c9b462dfe7af8e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "782071152251fe043e5d17837859ded1", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b6ecf46767444d1a28f2fd585b84eb25", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3552ec437d719e96dc474a16da6b2563", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8ac0c2e8d771937d544d8f2c88010739", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "6027b15ace15173e77f56db8def9e801", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "37f252153c74e6ed310c9ffad939e11e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e09e5d7877298468dbbab9706f40ff87", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7cf989e0e4cb2d48813e01adc16eb7b2", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "eb1c44a65a5456feb5b347d552dfda8b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "114d3e854582fea066299379998e7647", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "835135f9bfec39d3fc9f1d5ac9987c97", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "94f2588487f4b4bbc020a60d7930250a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "137bdf8fdd0e2f489c3f039bafc546c7", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "cd0a447fcb0165b1301535d863b7e460", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "416aae431c2a21586a9df40f5d3f2965", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e90d78ae46c85cd8c54995a9e7586db9", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->sk_timer.expires'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "eef1b836c18a629c88bc736e72a258e8", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 928}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "101497ecc52f84b7b8adda02e3afa45c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 957}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4eebf8f91827eb0e83e76fb166960c81", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 957}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "75a8ba7b34cc3e367ca3aebb67df875c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 957}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e03e3bcbeac623fb483bebdc1ae44524", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 957}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d2a665268082f51b980f358f56c6400a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 957}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "bdc6bda59c6c44263c256c482bd55572", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 957}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a712577a57089cc646c8a8b2938c89af", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 957}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "9b562b3820dba08aaabdad4ab901f51d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 957}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "9925eae48185ed9861e458a870682ab8", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 957}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "37d71d8774acd169b79e3ce8a0b4f07f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 957}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e9571242d5df43e3c3da207d720fedbc", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 957}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d8775d99981884c83a3bcfc4edbf6b7c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 957}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b9683bcb683a9d50551a4c5cc6c1a450", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 957}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8fb1f68ffb37d5099596144e16f8c2cc", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 957}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ea8469ff2b077a355c1de60302085562", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 957}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c2f0d0937e5f0b739348a3ab613c457c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 957}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8be98272da1070b152a16364cbb1af40", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4fb7d90afad3d79162aa47159fb9bcad", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "639457a460da3848b714508a198db381", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c0a0245a2dbbf8d87bae6bb5a89f94bb", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "68f8a24a61d6807ca93c3e4cb92f1f01", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5e351ec61bb08e1b9dbae1fa44d1d13f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "0ef2dbaac73bc3cb3119eaa3faefdd44", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "481cce94932cbb017b61bbafae91e5cf", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a62bb0aba244348f059de53ed435695f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "87b3f58c51dcdc926653cd3c9d343231", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "10881215b5697e8bd917bbb50ed8e44c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "bdba88a934bbe01ae2ebcfeb550c002d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "9e1f42b8eb218b5ebaf3ed456cae0198", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c1c3efd050b60ee6aacb6b88b2ec6672", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7d714d106957bb268b9d63c4c9c2a9e3", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "177a4b976305955a7f288da174302c9b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "1a34fa7f2e1eac27803bb056706e261d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->sk_timer.expires'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "1c6cff4285ec4bbcdb29fec1615652d3", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "1af4c64cf3365ae9da3e727cc74d8b5e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1027}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b1af3a27e993603b7d28dd8b718cdc69", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "bf43f7295f8bd53846e922e32fe36693", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a6c370333c7cbab5739ec42d24e4eee3", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7750e2e59f6ae1a694d39581f1ea84b4", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "6316315732cd7e6c87f4d5558c8a5a6c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f75796d284f3da304fd98e9e08cbd525", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3189a36b29f3853bd18d5c3014d5e97e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7811d8955c74eb70da1e0e56f5ed4b58", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "0175c8b5e2bfa33ab0c10329c0b4241f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "58631782a21259c739db5ab8a32a05c4", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ef7a4bd84b7c36b153785c8b0db7427c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c3de0691562bc7c95556a69c9ffac423", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "733aeb132eddb28578c63598be765fdd", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e6029f8ab2d5208cea626e68a49d93c9", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3e5708d2dec8beca918494fa19b1ad77", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3950d3436a1e397b71c95d904623126e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a95f5c98d0bd4f266c66ff06a8fb9127", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->sk_timer.expires'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2c7892f60fa83fc5bef801fa45a9ed71", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a56d1ba89e2da5d9560dd6e96686849f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1039}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a2a0862a5ebe82875817d9f6edb2b30c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "9d18958d18aac412263077a764abb578", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "da842f18688e41abc73ad5273f14f4ca", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d847e6dae2f2531d39a5749efda603f2", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f2833f09cca760af8361038e8246ed32", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "fa45abd7870a224c25526d4ca3e41930", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5e6d9bc466372fc3ec27ddc7e7d733f3", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3c05e4462d0af997ddda92224e04a469", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8a7ca7db50e18e9a9c1d314ad0ff9f1c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "47e62b1f563044225f4e7e7a13a8e202", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "55f004d4ba7bc2b65788db12d32af1a0", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f38ed6acba6885be287bd21e88d96149", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "69a4a964b61a55a0a04f6c30d4e704db", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4f219efe0dc297b84ea08485ef14e30e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "432498102e42630115ab3b319f742f1d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d3b320e885c8cf34b2fe8ced15da3d2e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "0970bd35f31bc87f9dfded269fdeb305", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2851ae3a9557415c8b67bf7b9a2f210c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1070}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4489dc8cce418db748d537f0857823e6", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1171}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "44b1365729eb54b09e9a73b36b5542eb", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1171}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5e593e4cd221126ccdd54e06f5bb647a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1171}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "bf24206087d9828bf78dc68a566ae1c0", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1171}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "26169cae62056010bf8d87746f2ce14b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1171}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "45c57d5445c50d7953204994a3e5240a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1171}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "0c6bae2f605009cd57849f20305b9000", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1171}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e8f10cd7444309bfdfaabbedd8c2a98b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1171}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "17acb9ad57c6196eee6dbe550d772d38", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1171}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c6c6e489f317314a5fb9da41a5f95dc8", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1171}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3c39269334bc743da45e52b13b9b1abb", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1171}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a7de631a23abb538b1abf3925b284602", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1171}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "713929380bfa58cdef03872788be8a63", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1171}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "74cf93604d31d6faf661571f288d3ebb", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1171}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "117449461c0d40667d6c57a0dd1e9f07", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1171}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "954747c86bede59dc1fda00f24be7fa2", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1171}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5a510a3ea55a6287f173abcb0a4170a6", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1760}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "514c34637819dce57d4a361f740b08aa", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1760}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3f3de44cc5a6017583a0624de2415818", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1760}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ba1770535bd42fd033ca6743bb9aeaff", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1760}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ef6e01f7d7d2178c73e65d583c4e9c23", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1760}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5706f00169335bff5bc42962e174dcca", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1760}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8f8040a65c9e3f9221308d28548fd0c6", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1760}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "bb8291a44bbf2a25f9ed27c3c047b2c1", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1760}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "30c8ecbf2e17ca9d5d044e9879f88d5e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1760}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8aaa8ac52d5815938434cbe378ae345d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1760}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c2daaff376258eb9f0ee144970fe4779", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1760}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "0287283654f168be9159911dfbf2d251", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1760}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "56593e4103db3121391e1c5e7c5fc45f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1760}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "10bbc98cb29d3d8545bb9e28c21e28ba", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1760}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "fe7359e9dda12ca0bac33f5fbc79e103", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1760}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "74995826bdaae04d2519fff0dca4abfe", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1760}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e1bba3ed7c048b113d50dea8ef3d28ad", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a1fe666c0661308be2fb0e15f38227aa", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5d07b96ebaeec03c8e835ed54cb83b4a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "943864ae26079ce416d59ec8a7b6a357", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "38bf06bd1579c2ea25964f12cba6334a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c81a7c075af7e55997e26f6c7a68a1fc", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "14f180ce2b247989ec8a305092ec622b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "fce3da3f7556c5ad69171c414f97f454", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3f1303096ef32ee8fad6810162799b7e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "68110383985dde0568afbb7b03664f57", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2a26249e57fc502f2652334177817e9b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4d3474d8c2bd5541215bf9ebcc19d793", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4e142ea6f24bb6dc19ee59e37e2c4a83", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d972506f93d0ad3660ba765210043728", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "21abac3bf9f71b2baf8ef9df861bdd7a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a78cd9358b7b10e4add9da04832d8e3b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_hash'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5a35febe396809a8acdbfe9882e6a2ff", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "70ca3c515d6d67da9021e3467e3fccb2", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c4ce407e6012df25f17bef6eab44dd84", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->sk_timer.expires'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f94500c8fcca81446d6ae46965399170", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->sk_timer.flags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "1e2cfb87044114665ca320193a987304", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1964}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "0d4b1341be767f254790ae7e962bd41d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "6609b8d66aae8e5f5eeb4edc94c651f3", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f9e2d3892312332169c4ac81dab78061", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2ac0c20758f0937b9b78bafef327bb9a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d74ffb918c3ea5e695fcfee49cdb0002", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "1e68953f5b93d5e19e19fc0802616462", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "90fdcda1ab0cd4fc80d81b36004c423c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "04510d73ece7479df6b5d6f285bf788e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d3e818b8a9f6285f025ca994811e726b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "94a1a52d36eb561342cdf8a24318ac27", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "0ef6c139bd9441aa6fbcae193f7c4bf5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e114084ac2b2a91a34cf997d16ed76a7", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7bfe3383dca5e8e9db19dbc6fe0574f2", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "fbf1a02764a73f49924a4a8eb73e3774", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "0b7f0e09d0a0f33aab877d040c414a31", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "93473563162c519d40640d3d8d5376c3", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a7b7c1ea27ca0c516ecedb1bbb9563f5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->sk_timer.expires'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "acd79e29e6534f4d826c1520bf4d34dd", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "825e94ae375cd19acdaf76e5b94ce575", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2032}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "eef34f72f82a14c27f9d04dc47673bb0", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3f35b6e4d049423aa07e3c094f79d38b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "242efdfae554d4dd7f955c8aa1c5011a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b22ddd8cf3f254d8e3017d67004f2510", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4cd7c6ff1319b05d3dd4427b869c6843", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ebca8be3908003942606eb2a282105d5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "19336098969b3217b6d0b80dd52869aa", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "168552f2d5400fba495ed1b6c303c8c0", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7b9e154747cbb5564d69b6d2afad162b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "33e20b96d7b287df426d6a4e712ddccf", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4c3b5a8ec463a0f402ceafe76ba9e1c8", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f6ca02e4d1b0b50c0327f4adf20bf27e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "057488390ee546481596394d073a3ca5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "fc464334d65e055755ea935bbf7e6cef", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "12173e7833d1824ff008ceb976d03186", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c349b1760d04e9b9fe8b333b3f77743b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "9a5e84677ed1d7c59cac4eef565b2598", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->sk_timer.expires'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a29cf9571bd8ab7c3181b2582042d712", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "11dc8ad28b611a22593cd3514b9331d3", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2046}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "72280dd6b63358ed69cef98a41500527", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2171}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ea1391a9a06f8d86d1946c52015faf0c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2171}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f7cf2fc30579d46fa5d66e80a1672d0c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2171}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "52b639bc362b7853fbf46da0026803b7", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2171}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7be4fb373ab454216bda99edefffdc3d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2171}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7583bd042356e63fd6be02997f4bc772", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2171}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "216cb3c91c171355eb82f6247e886b37", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2171}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "393ade79e6b46f6b173d5d26894588c7", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2171}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4bfed592263abb2400cceac4f919655f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2171}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "196b38823c0ed79ed04812763a25d4eb", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2171}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7069c2b74a9ddaa35846edce37fc324a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2171}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "99d3199c23aa47f65d075c240756d38b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2171}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "1a56717dd40b4c999a0614104469834a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2171}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d823a3a04c6efbbdd2a1e47217181778", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2171}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "73a8db644c379a6c0f3b4d32c66f4a11", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2171}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3a4a5a58da175cd05cb77d840d5de53f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2171}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4cdc228f55ddccc8032accc1e0bda697", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2361}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d4cf4239ed34eeb9a8f6022abf5c71d4", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2361}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2d1c6402d087b2c8938a8cdba8f2b91d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2361}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "78304f6fa703808635f94833097d72d8", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2361}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3a9b2f4fb32bd36d46c4d813c5d39866", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2361}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "981ef789eedad96d4ad9665f0bc2601d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2361}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "0584a80fcb6dfc2c3be1c32ddbd1f8e6", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2361}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "84e83031aedacb30824515163e959dc5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2361}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a38f5304cde528280afd14dbdb1c107c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2361}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "734586bfed9b986014fb46bf0b106c4b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2361}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "fa9977fd2b6e1bafb5ab34513ded6eca", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2361}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a885415cc2178d79bab9cc243445a288", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2361}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ad3893981b62d54d8dd492a441c2f42f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2361}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e9c905518a941bc5ef76d73313ba4205", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2361}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "415daec812cee0ba6ef1930f6968b910", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2361}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "03743d3bb3edd1810782b14c991c7abf", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2361}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "dcc3840fc0cd98e4ae47984f9556ec76", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2464}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "1bc7a835336997614d7a042eac9239df", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2464}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4501fbfa34b5b199c806ddf0bcb641de", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2464}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e4b7113bc09a1bb5dde7d61770247463", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2464}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e58b669ce8acef93fba7f0d99d8c75da", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2464}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "fbb5ad703413d334cc3402a9502d7f00", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2464}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c8c0c5e22ce5408fa6da314d3779d9a4", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2464}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ce2cf97af17e8187dca095b8fdb750e0", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2464}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7908ca077798825b8d0b5c8025173682", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2464}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "168eafc65fdb37cecb0462e841441da3", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2464}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d09474ce18632925f6fae5d442537437", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2464}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8704e1a024cf4fccd592dc9f127d9b8a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2464}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a445585940f5cd7455279f52a02966fd", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2464}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e4e60dab3936b0fc215924f89ee7a5db", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2464}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2388c4ea91e971db660662dc81eee103", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2464}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ff46d9c2f69cf60157abe1f0466adf59", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2464}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c53ce4ba7efd9cc03150b720fe53cb63", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2371}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "95b3926de4b5732985f954340e86439c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2371}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "cd5059b8e30ea47200e0fdb15e21fc42", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2371}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "9972f60ab065131fe9df326a2bf58613", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2371}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "1a99a7d3a29d19b672f95e9e84fc1ed6", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2371}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "59cbe6763ae697ca2bffcfc6c90c91f8", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2371}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "9701d472af1cf83518c24e5b01cc97a0", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2371}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "dca784f5037b2433b5484580310b9c32", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2371}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8b456e8b26a9ad82cb0348ae3407cc97", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2371}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "9335f163cb8abc6fde3e7a17e817674a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2371}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5a7f7c9a6459b434841f0c2aa3064474", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2371}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ba3a142054d726860fed08f3ebbab027", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2371}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "cb8da429111dc828ab63b0e87d6a3ae0", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2371}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "dae12ff410654d75abf9e3bd672ae4a2", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2371}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "6207f2230f530514fb430166bbb4cb4a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2371}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8234a8adc7e2688afbcb3229f2afba50", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2371}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "888b16a7b06311238c9f6e9b23c67e00", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "0c8c6fdb6d9cb63527fe5775dc2e085a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "73e8213e401fc09cd180e891fa02aac5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8456021e243513cdad9b4ee1e5839a8d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "1baa4ea8ec810ccc9821ccadd552a87e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7662b93a46f15946f32277ac5d3c07b1", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b8d128e060da8beaac22a72712f4e1ec", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4bd68b2efc9bbfa01009c1de521760d7", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4d4aa0d6906471e8cd9572349778a4d5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "20fdf4bbb474c5af62135f0b6dd64e6d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4023252b04b7906e680c36950dcdac17", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "cf8886a562d06e35784f255626697dfa", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3f7ebe511b12a153e854fab4a4eb6802", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "333bd7e88d1e7c87aeeb04205d9ce82d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a37bd80468afedf040608c3a5aef7228", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7b8d9ed6f17fbb4d0623c9bd7a5f2e09", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f7cacc9a2ad3a499a11441086921b5b8", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "eda497e869d89aa3f6477310b9061c38", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3443}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f136a9a9898c8f7db9dfb00d4213665d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "159bda011a50af306ff0885fe9f8e2f4", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2f7fe3a407d9c51f82097f4ee4b3e716", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "29dcbc69448788a16cb11178b58abeed", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "17be51b2ab03014b09c67447e93af001", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "29697c892d3826fed98b882dabd13fc3", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "98f54d5ba56b0e1f5367fc79287dc67d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "21fc4b4fe3fbca3f18120f948d8cb8b9", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b52017f71575ea46331a7517e2d0e4f8", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a58acfe075127c19ec9b6959c1dd7934", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a27270d0efd6f263308b064e341faf65", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "04cd2ca9d92e1612864dd2f514e2f063", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "07b77e352ac57c511f966d3ace763aac", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c930b1f662f75c88043c2c5aa7a2f2db", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "11a6242010db19f5b51175f624d19aef", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c14229625be20ba15d641a3589e7e973", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->sk_timer.expires'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e9936994e3f7c1546f9cd33a4a34fabb", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->sk_timer.flags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "22395502258f6d5ae11f3940d24a2554", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "96f440f1daddb5ed0bb0b1eb454b5b0d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "44b28587affd4a25eb041b79a8e2d350", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3453}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "188f78fe389c29c87ad319248187d722", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3433}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a796e7343c391de9e2e062e92e6e75c5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3433}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "39bd94b03a7ed8d30a928b3ed7dba905", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3433}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3e9173faa4600aab3476dbc767eebfc5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3433}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "acf0168671a0868c9362b5c9a127f4d9", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3433}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "9dc5070d2b669411a6f70d3ff03c5bc5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3433}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b537ea75f67292e96d044c27c057983c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3433}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b7eac5e54643bfd1be7d9d9468029bfc", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3433}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "67003d57f82eb38b6935b86990d41ccb", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3433}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "799b77d476c41ad72c2e5e11ab565d20", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3433}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8db0f68346c815ad1dfaf2f4b1041eac", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3433}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "68465c400ff2789c41b306dd7edef9a5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3433}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "6dee517c7e6479d7091067c033c22dca", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3433}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "db24deb098da9920ab3dd16eeefbf96a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3433}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ec5df49bc224ebcea722da2cfb291b65", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3433}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "16d5008c88332860820536f7474f62d4", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3433}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "123bc6eabed858162ba00f5202d8d1f3", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8579d156054e430ab4889965de5117fe", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "6dd5443c05f0b7039ed84ef5177b4c2e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f988dd61eb40ce30e2111d0ca5513904", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ea17cff677af80b40664037fe1a8af5e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3bbe3fe2da6cfaba6e806358dbbe656d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "aea5bc132ce55a282fe496843257c61a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "9f6a3a90bddae78eed2589b3f5218a56", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "64ef965036bc6e0917b1434a7df1b671", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "1f1fb1e9d84b6a0e428a44c144065f7a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "dc503df0c64c9891cc2ba3a7a89d204f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c7d3fe526b928b1d1e9119f9305e6665", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "937bafd5d8134dd7adb1d33f12a7a0d7", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3904481a3af3b2bf04fccc9d433c1f1a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a2293200755158aeeb80af9717145927", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "bd58eb58d8783a9f9fb3d20c274e4245", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "34b56fedc56c5025887e81c904dca8f2", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "11d510821230a9c2ff9289234ab0daa6", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3573}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8ce35b5596df9ec6ce0fe68041290e9e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c76b8765cd1764cc60cdd22aad992bd9", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d41d4614a0dd77d344bc3d0f773ed95e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3eba14e9ed1acbef418b34d449c2875d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "57b2b70fa7aa2d7c25b89b72e3075b0c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "68f056b385ec0aa1810f2ff5c859aeb1", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d4d508a9cd66b8793f75603c27c0195d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "0d8ebb920c435ff3783fd30ea1495b1e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2aecb45f89b9f2a6d3624004a7625b8a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "eb97c424c57ea325db2e6fe7a7c4f49a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "1188c053b706a7fc13e78adf2fa427b9", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "aedad48ca0c18393f17b2aaaffbb6b7e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "fd9d72f5336784e35e3adaee33a167e5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7ac973ed3ef5e8a05c4b357c46583258", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7cac888cdd6e9d4728877d4528165aa8", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8d122bbd6c87bb5ef5ad403048276353", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f057162297c1300af82761bf6057d4a8", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "561ddbaebbffd48d5ce40408c6950faa", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3579}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2277b8395da6ede834d669b9e1c31f8a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "cd2c2edcfe135174450dbbfcebeaece9", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c93db573e8bde1f0a6fc206ec1923823", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "79ab4b1d2b328c23e37b4889e0a0b634", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5e4a56b8512369e9802ed00a42ef0552", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "af409b19c62449545c0cf224d3cf9209", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a0af079d2e2e3ae246e173afe57425d9", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3bb0d8f95b17374d0277feead96d350f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ed32e74e1cd68b72898fd35cbad26761", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ca5e601f1478de822ef0cb9b4da0c26e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "90521edbf780e7f53e6545d16ff85079", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "1c3af6932c50f03398f1e3882a7aa85e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "6f8e85ec474e08273b95545a791168d7", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "9f653d5f41b8f553c70dcf8db18ecc71", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "eadd9ff1d41301bb328769eb85a97b78", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "642d3730e6968ea0ed70b08fb5c95a74", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d563b425508be7bd625afa673cf47d3c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4a4655d00d15dd39e55d2ab004706999", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4069}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "daae575fbd3448f6a3233926f6299803", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "cf75fe8f3f29b25e637ed0e43d247964", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "fe0da33ca0dfda93476af39ae3e766db", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e800e514b736d94d5fb0d7b170079fd1", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2d9193b53b8403ae4f3e9048c9862413", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3a0330906a65f10bc9c942019576368e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f4d8106efc1ba6ea9d9b68fbcac7c1d0", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d30bc3d4ec8c6e69fae4656aabd5019e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "6a0da6acdade6018f14008bef0b81237", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "314bea9dc24e6764d0267320c2462d6a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c4bd5ce975a5ae257acc37e9524757ff", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "bfa4a717ab65e481eb92032fc73cb02c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7823b59e7a534972321e23e762f82253", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "bc8e7d261c815435a9fd6354e620fee5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5243fcfeb2a48c8ac87c871c6e2e1b34", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "0006071d04742b06ee242e48e91941a9", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "0160bc7a72217861ce966cedc1c98462", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "bde807b814f70073bd957ab9e56a655d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4091}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "55b62840fdef21f954741b9ff8e28a8c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "271dffca53abf8d746f81f3c13969142", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8cdb2e4dc413b7c64c4f5c171b29bd85", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "12395e544428a29490c753ccc1b3af87", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a9ef0f0b3bea983a2d21cb69965048c3", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "579e05d76ed529b1cce9f58d2b96f0bc", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "f0c4cab39a5119bd430e4c65e77f5637", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5c326ac888abddf0f76920a71c572faf", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a68e5fa75a827a053e22ce4e8ac56ff5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "77ab696ba7d622a7c405edc78c9aa46b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "6b6f6accf23f3e8af44597648e8a1740", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4b109958b0896cc4f5001206c6e76f5b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "959ed80a7718cf183ac5f44466d2ab6b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "08c5414e0b45a0e47743e0bd34cb7089", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e2d3b4e7ca3406bca99b994fa5ee091a", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "43dbf8f1bc62575f12d9c0752fcce77f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->sk_timer.expires'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "06be552db066e8397680650a6775437f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->sk_timer.flags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "39ab89262d5c4f182f3496d8fd387612", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4412}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "9abd4a728a8b633b7c0be3060699959b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "55c35e627435ba48f531e3a2c701b3b9", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "fec99e5bf850b59246836da2be2e7a56", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2067765375f5c5e891c7a37d6bf521af", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "939091f48bbed62d111ddaf9e3976df0", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "8cfc0fba877e274f4803e10f08bef4a2", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "d6bbce4cca402b19324ae0deb8e582ca", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5f979d1f1686a33d4d17c9b1024c7d1e", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "626edc2006660c436e0ef0e872dbcdf5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "12e8701a35a06b30bbd879ec2bcabcc8", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "fd50a26b282abd73aefe1ac6ad139c30", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "38bfe221c2f466e486c24a7ae29f2ef8", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "36632a7c2499b836c182732076dedc26", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "fa5ea1be56be40a44f87e939323d1bad", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "62f05c638f73d398514e5e1c084cd974", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "daf1987f71e4ae1e0bd44518230ed20f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c952f7e76e875e547009be27ee0bf7ac", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->sk_timer.expires'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "6d8fe37658224e2b395462fdd6773ffb", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->sk_timer.flags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "7183bb961bab04146c53c32ea04c1b3d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a3785eb72bb6088037f272a298e94c79", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4514}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "5356f2c309f2477b572dd6cd4224c4f6", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "6614b62ce1769d4e4efd9a3a7da2cb6c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "91621361af972ccd039cefa769e30a75", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "99979e888359f0dbff98fd91eec2929d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4124f13159e04656fa0e6ab6d18df45f", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "1d514d78cd071d12b1be0278c1a35c48", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e852ddb0be4647cee3618d2cff21a3ed", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "3fd993f0c283ddb03b24949066e916fc", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "dbb19025422f40ba262a6045162fb1ad", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "10fc3b1f9cf7a69f8e9dd6a611009c77", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "658228d11917bf2439e9082461897608", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "9eed6c95116684b2c11e6b73caa240c3", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2724620f9809dcf7b9a766986c4caf5b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "6a7a870a8c3fd1cb80cbd72626ccce5b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "575d713d32ece6d34ce5c8cc4d2b146c", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "01978f04f37f13535c1c3726221db41d", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "25f383033cbbeb67ab806a3b8f743207", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "4babbc222c781b9dd359f274ab08beba", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4214}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "345c71dcc7cbb5b1e11ec37204ded8a5", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_bound_dev_if'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "c8efbccc345825d98998f55362b536cd", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_incoming_cpu'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "0ea2cbdeb31b2ec715ff718feed691c1", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->__sk_common.skc_ipv6only'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "b0fc0bfa608cc165fdfbefcf20f4cb03", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->sk_ll_usec'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "6575e6d4a89e20a737a3a77639e3583b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->sk_mark'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "0cd76b9d8ce338f194445d7428158e72", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->sk_max_ack_backlog'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "a4743cd59af407fab5f83dc3ca47a7ef", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->sk_max_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "71f1d95d3cbdd1b55ea1457d017876fa", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->sk_pacing_rate'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "e836fac837ebc4bb81f7fbdd0378cfc9", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->sk_peek_off'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "ad5d087dca7855b3fb7442e490278689", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->sk_priority'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "08d5eee2e8b69bee71bc56e7fff31960", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->sk_protocol'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "940385fd162b3bea4189c692c63ccce6", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->sk_rcvbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "fea4b0a730da5403b9244bc897949bce", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->sk_rcvlowat'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "514410405f253aad7ca2a3f513b88ea1", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->sk_shutdown'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2391cfc15ec370bcde5f5094653fc509", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->sk_sndbuf'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "2bb930c70a1a8894113ea484aa27eba8", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->sk_socket->type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "240f9ab76d6e77749f0719255c972a34", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->sk_tsflags'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "95cf8cb8c02986e945c8ee0ae42a8deb", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6006}, "message": "set_param_user_data: no type for 'tp->sk_type'"}], "macros": [], "notes": [], "path": "/src/net/ipv4/tcp_input.c", "reportHash": "9e9a90fd49cb717c4c835324b44b155b", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
