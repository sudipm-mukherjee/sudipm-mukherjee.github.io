<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/src/net/packet/af_packet.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tPACKET - implements raw packet sockets.\n *\n * Authors:\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\t\tAlan Cox, <gw4pts@gw4pts.ampr.org>\n *\n * Fixes:\n *\t\tAlan Cox\t:\tverify_area() now used correctly\n *\t\tAlan Cox\t:\tnew skbuff lists, look ma no backlogs!\n *\t\tAlan Cox\t:\ttidied skbuff lists.\n *\t\tAlan Cox\t:\tNow uses generic datagram routines I\n *\t\t\t\t\tadded. Also fixed the peek/read crash\n *\t\t\t\t\tfrom all old Linux datagram code.\n *\t\tAlan Cox\t:\tUses the improved datagram code.\n *\t\tAlan Cox\t:\tAdded NULL's for socket options.\n *\t\tAlan Cox\t:\tRe-commented the code.\n *\t\tAlan Cox\t:\tUse new kernel side addressing\n *\t\tRob Janssen\t:\tCorrect MTU usage.\n *\t\tDave Platt\t:\tCounter leaks caused by incorrect\n *\t\t\t\t\tinterrupt locking and some slightly\n *\t\t\t\t\tdubious gcc output. Can you read\n *\t\t\t\t\tcompiler: it said _VOLATILE_\n *\tRichard Kooijman\t:\tTimestamp fixes.\n *\t\tAlan Cox\t:\tNew buffers. Use sk->mac.raw.\n *\t\tAlan Cox\t:\tsendmsg/recvmsg support.\n *\t\tAlan Cox\t:\tProtocol setting support\n *\tAlexey Kuznetsov\t:\tUntied from IPv4 stack.\n *\tCyrus Durgin\t\t:\tFixed kerneld for kmod.\n *\tMichal Ostrowski        :       Module initialization cleanup.\n *         Ulises Alonso        :       Frame number limit removal and\n *                                      packet_set_ring memory leak.\n *\t\tEric Biederman\t:\tAllow for > 8 byte hardware addresses.\n *\t\t\t\t\tThe convention is that longer addresses\n *\t\t\t\t\twill simply extend the hardware address\n *\t\t\t\t\tbyte arrays at the end of sockaddr_ll\n *\t\t\t\t\tand packet_mreq.\n *\t\tJohann Baudy\t:\tAdded TX RING.\n *\t\tChetan Loke\t:\tImplemented TPACKET_V3 block abstraction\n *\t\t\t\t\tlayer.\n *\t\t\t\t\tCopyright (C) 2011, <lokec@ccs.neu.edu>\n */\n\n#include <linux/ethtool.h>\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/if_packet.h>\n#include <linux/wireless.h>\n#include <linux/kernel.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <net/net_namespace.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/uaccess.h>\n#include <asm/ioctls.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/io.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/if_vlan.h>\n#include <linux/virtio_net.h>\n#include <linux/errqueue.h>\n#include <linux/net_tstamp.h>\n#include <linux/percpu.h>\n#ifdef CONFIG_INET\n#include <net/inet_common.h>\n#endif\n#include <linux/bpf.h>\n#include <net/compat.h>\n\n#include \"internal.h\"\n\n/*\n   Assumptions:\n   - If the device has no dev->header_ops->create, there is no LL header\n     visible above the device. In this case, its hard_header_len should be 0.\n     The device may prepend its own header internally. In this case, its\n     needed_headroom should be set to the space needed for it to add its\n     internal header.\n     For example, a WiFi driver pretending to be an Ethernet driver should\n     set its hard_header_len to be the Ethernet header length, and set its\n     needed_headroom to be (the real WiFi header length - the fake Ethernet\n     header length).\n   - packet socket receives packets with pulled ll header,\n     so that SOCK_RAW should push it back.\n\nOn receive:\n-----------\n\nIncoming, dev_has_header(dev) == true\n   mac_header -> ll header\n   data       -> data\n\nOutgoing, dev_has_header(dev) == true\n   mac_header -> ll header\n   data       -> ll header\n\nIncoming, dev_has_header(dev) == false\n   mac_header -> data\n     However drivers often make it point to the ll header.\n     This is incorrect because the ll header should be invisible to us.\n   data       -> data\n\nOutgoing, dev_has_header(dev) == false\n   mac_header -> data. ll header is invisible to us.\n   data       -> data\n\nResume\n  If dev_has_header(dev) == false we are unable to restore the ll header,\n    because it is invisible to us.\n\n\nOn transmit:\n------------\n\ndev->header_ops != NULL\n   mac_header -> ll header\n   data       -> ll header\n\ndev->header_ops == NULL (ll header is invisible to us)\n   mac_header -> data\n   data       -> data\n\n   We should set network_header on output to the correct position,\n   packet classifier depends on it.\n */\n\n/* Private packet socket structures. */\n\n/* identical to struct packet_mreq except it has\n * a longer address field.\n */\nstruct packet_mreq_max {\n\tint\t\tmr_ifindex;\n\tunsigned short\tmr_type;\n\tunsigned short\tmr_alen;\n\tunsigned char\tmr_address[MAX_ADDR_LEN];\n};\n\nunion tpacket_uhdr {\n\tstruct tpacket_hdr  *h1;\n\tstruct tpacket2_hdr *h2;\n\tstruct tpacket3_hdr *h3;\n\tvoid *raw;\n};\n\nstatic int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,\n\t\tint closing, int tx_ring);\n\n#define V3_ALIGNMENT\t(8)\n\n#define BLK_HDR_LEN\t(ALIGN(sizeof(struct tpacket_block_desc), V3_ALIGNMENT))\n\n#define BLK_PLUS_PRIV(sz_of_priv) \\\n\t(BLK_HDR_LEN + ALIGN((sz_of_priv), V3_ALIGNMENT))\n\n#define BLOCK_STATUS(x)\t((x)->hdr.bh1.block_status)\n#define BLOCK_NUM_PKTS(x)\t((x)->hdr.bh1.num_pkts)\n#define BLOCK_O2FP(x)\t\t((x)->hdr.bh1.offset_to_first_pkt)\n#define BLOCK_LEN(x)\t\t((x)->hdr.bh1.blk_len)\n#define BLOCK_SNUM(x)\t\t((x)->hdr.bh1.seq_num)\n#define BLOCK_O2PRIV(x)\t((x)->offset_to_priv)\n\nstruct packet_sock;\nstatic int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t       struct packet_type *pt, struct net_device *orig_dev);\n\nstatic void *packet_previous_frame(struct packet_sock *po,\n\t\tstruct packet_ring_buffer *rb,\n\t\tint status);\nstatic void packet_increment_head(struct packet_ring_buffer *buff);\nstatic int prb_curr_blk_in_use(struct tpacket_block_desc *);\nstatic void *prb_dispatch_next_block(struct tpacket_kbdq_core *,\n\t\t\tstruct packet_sock *);\nstatic void prb_retire_current_block(struct tpacket_kbdq_core *,\n\t\tstruct packet_sock *, unsigned int status);\nstatic int prb_queue_frozen(struct tpacket_kbdq_core *);\nstatic void prb_open_block(struct tpacket_kbdq_core *,\n\t\tstruct tpacket_block_desc *);\nstatic void prb_retire_rx_blk_timer_expired(struct timer_list *);\nstatic void _prb_refresh_rx_retire_blk_timer(struct tpacket_kbdq_core *);\nstatic void prb_fill_rxhash(struct tpacket_kbdq_core *, struct tpacket3_hdr *);\nstatic void prb_clear_rxhash(struct tpacket_kbdq_core *,\n\t\tstruct tpacket3_hdr *);\nstatic void prb_fill_vlan_info(struct tpacket_kbdq_core *,\n\t\tstruct tpacket3_hdr *);\nstatic void packet_flush_mclist(struct sock *sk);\nstatic u16 packet_pick_tx_queue(struct sk_buff *skb);\n\nstruct packet_skb_cb {\n\tunion {\n\t\tstruct sockaddr_pkt pkt;\n\t\tunion {\n\t\t\t/* Trick: alias skb original length with\n\t\t\t * ll.sll_family and ll.protocol in order\n\t\t\t * to save room.\n\t\t\t */\n\t\t\tunsigned int origlen;\n\t\t\tstruct sockaddr_ll ll;\n\t\t};\n\t} sa;\n};\n\n#define vio_le() virtio_legacy_is_little_endian()\n\n#define PACKET_SKB_CB(__skb)\t((struct packet_skb_cb *)((__skb)->cb))\n\n#define GET_PBDQC_FROM_RB(x)\t((struct tpacket_kbdq_core *)(&(x)->prb_bdqc))\n#define GET_PBLOCK_DESC(x, bid)\t\\\n\t((struct tpacket_block_desc *)((x)->pkbdq[(bid)].buffer))\n#define GET_CURR_PBLOCK_DESC_FROM_CORE(x)\t\\\n\t((struct tpacket_block_desc *)((x)->pkbdq[(x)->kactive_blk_num].buffer))\n#define GET_NEXT_PRB_BLK_NUM(x) \\\n\t(((x)->kactive_blk_num < ((x)->knum_blocks-1)) ? \\\n\t((x)->kactive_blk_num+1) : 0)\n\nstatic void __fanout_unlink(struct sock *sk, struct packet_sock *po);\nstatic void __fanout_link(struct sock *sk, struct packet_sock *po);\n\nstatic int packet_direct_xmit(struct sk_buff *skb)\n{\n\treturn dev_direct_xmit(skb, packet_pick_tx_queue(skb));\n}\n\nstatic struct net_device *packet_cached_dev_get(struct packet_sock *po)\n{\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tdev = rcu_dereference(po->cached_dev);\n\tif (likely(dev))\n\t\tdev_hold(dev);\n\trcu_read_unlock();\n\n\treturn dev;\n}\n\nstatic void packet_cached_dev_assign(struct packet_sock *po,\n\t\t\t\t     struct net_device *dev)\n{\n\trcu_assign_pointer(po->cached_dev, dev);\n}\n\nstatic void packet_cached_dev_reset(struct packet_sock *po)\n{\n\tRCU_INIT_POINTER(po->cached_dev, NULL);\n}\n\nstatic bool packet_use_direct_xmit(const struct packet_sock *po)\n{\n\treturn po->xmit == packet_direct_xmit;\n}\n\nstatic u16 packet_pick_tx_queue(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\tint cpu = raw_smp_processor_id();\n\tu16 queue_index;\n\n#ifdef CONFIG_XPS\n\tskb->sender_cpu = cpu + 1;\n#endif\n\tskb_record_rx_queue(skb, cpu % dev->real_num_tx_queues);\n\tif (ops->ndo_select_queue) {\n\t\tqueue_index = ops->ndo_select_queue(dev, skb, NULL);\n\t\tqueue_index = netdev_cap_txqueue(dev, queue_index);\n\t} else {\n\t\tqueue_index = netdev_pick_tx(dev, skb, NULL);\n\t}\n\n\treturn queue_index;\n}\n\n/* __register_prot_hook must be invoked through register_prot_hook\n * or from a context in which asynchronous accesses to the packet\n * socket is not possible (packet_create()).\n */\nstatic void __register_prot_hook(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\n\tif (!po->running) {\n\t\tif (po->fanout)\n\t\t\t__fanout_link(sk, po);\n\t\telse\n\t\t\tdev_add_pack(&po->prot_hook);\n\n\t\tsock_hold(sk);\n\t\tpo->running = 1;\n\t}\n}\n\nstatic void register_prot_hook(struct sock *sk)\n{\n\tlockdep_assert_held_once(&pkt_sk(sk)->bind_lock);\n\t__register_prot_hook(sk);\n}\n\n/* If the sync parameter is true, we will temporarily drop\n * the po->bind_lock and do a synchronize_net to make sure no\n * asynchronous packet processing paths still refer to the elements\n * of po->prot_hook.  If the sync parameter is false, it is the\n * callers responsibility to take care of this.\n */\nstatic void __unregister_prot_hook(struct sock *sk, bool sync)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\n\tlockdep_assert_held_once(&po->bind_lock);\n\n\tpo->running = 0;\n\n\tif (po->fanout)\n\t\t__fanout_unlink(sk, po);\n\telse\n\t\t__dev_remove_pack(&po->prot_hook);\n\n\t__sock_put(sk);\n\n\tif (sync) {\n\t\tspin_unlock(&po->bind_lock);\n\t\tsynchronize_net();\n\t\tspin_lock(&po->bind_lock);\n\t}\n}\n\nstatic void unregister_prot_hook(struct sock *sk, bool sync)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\n\tif (po->running)\n\t\t__unregister_prot_hook(sk, sync);\n}\n\nstatic inline struct page * __pure pgv_to_page(void *addr)\n{\n\tif (is_vmalloc_addr(addr))\n\t\treturn vmalloc_to_page(addr);\n\treturn virt_to_page(addr);\n}\n\nstatic void __packet_set_status(struct packet_sock *po, void *frame, int status)\n{\n\tunion tpacket_uhdr h;\n\n\th.raw = frame;\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\t\th.h1->tp_status = status;\n\t\tflush_dcache_page(pgv_to_page(&h.h1->tp_status));\n\t\tbreak;\n\tcase TPACKET_V2:\n\t\th.h2->tp_status = status;\n\t\tflush_dcache_page(pgv_to_page(&h.h2->tp_status));\n\t\tbreak;\n\tcase TPACKET_V3:\n\t\th.h3->tp_status = status;\n\t\tflush_dcache_page(pgv_to_page(&h.h3->tp_status));\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"TPACKET version not supported.\\n\");\n\t\tBUG();\n\t}\n\n\tsmp_wmb();\n}\n\nstatic int __packet_get_status(const struct packet_sock *po, void *frame)\n{\n\tunion tpacket_uhdr h;\n\n\tsmp_rmb();\n\n\th.raw = frame;\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\t\tflush_dcache_page(pgv_to_page(&h.h1->tp_status));\n\t\treturn h.h1->tp_status;\n\tcase TPACKET_V2:\n\t\tflush_dcache_page(pgv_to_page(&h.h2->tp_status));\n\t\treturn h.h2->tp_status;\n\tcase TPACKET_V3:\n\t\tflush_dcache_page(pgv_to_page(&h.h3->tp_status));\n\t\treturn h.h3->tp_status;\n\tdefault:\n\t\tWARN(1, \"TPACKET version not supported.\\n\");\n\t\tBUG();\n\t\treturn 0;\n\t}\n}\n\nstatic __u32 tpacket_get_timestamp(struct sk_buff *skb, struct timespec64 *ts,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct skb_shared_hwtstamps *shhwtstamps = skb_hwtstamps(skb);\n\n\tif (shhwtstamps &&\n\t    (flags & SOF_TIMESTAMPING_RAW_HARDWARE) &&\n\t    ktime_to_timespec64_cond(shhwtstamps->hwtstamp, ts))\n\t\treturn TP_STATUS_TS_RAW_HARDWARE;\n\n\tif (ktime_to_timespec64_cond(skb->tstamp, ts))\n\t\treturn TP_STATUS_TS_SOFTWARE;\n\n\treturn 0;\n}\n\nstatic __u32 __packet_set_timestamp(struct packet_sock *po, void *frame,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tunion tpacket_uhdr h;\n\tstruct timespec64 ts;\n\t__u32 ts_status;\n\n\tif (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))\n\t\treturn 0;\n\n\th.raw = frame;\n\t/*\n\t * versions 1 through 3 overflow the timestamps in y2106, since they\n\t * all store the seconds in a 32-bit unsigned integer.\n\t * If we create a version 4, that should have a 64-bit timestamp,\n\t * either 64-bit seconds + 32-bit nanoseconds, or just 64-bit\n\t * nanoseconds.\n\t */\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\t\th.h1->tp_sec = ts.tv_sec;\n\t\th.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;\n\t\tbreak;\n\tcase TPACKET_V2:\n\t\th.h2->tp_sec = ts.tv_sec;\n\t\th.h2->tp_nsec = ts.tv_nsec;\n\t\tbreak;\n\tcase TPACKET_V3:\n\t\th.h3->tp_sec = ts.tv_sec;\n\t\th.h3->tp_nsec = ts.tv_nsec;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"TPACKET version not supported.\\n\");\n\t\tBUG();\n\t}\n\n\t/* one flush is safe, as both fields always lie on the same cacheline */\n\tflush_dcache_page(pgv_to_page(&h.h1->tp_sec));\n\tsmp_wmb();\n\n\treturn ts_status;\n}\n\nstatic void *packet_lookup_frame(const struct packet_sock *po,\n\t\t\t\t const struct packet_ring_buffer *rb,\n\t\t\t\t unsigned int position,\n\t\t\t\t int status)\n{\n\tunsigned int pg_vec_pos, frame_offset;\n\tunion tpacket_uhdr h;\n\n\tpg_vec_pos = position / rb->frames_per_block;\n\tframe_offset = position % rb->frames_per_block;\n\n\th.raw = rb->pg_vec[pg_vec_pos].buffer +\n\t\t(frame_offset * rb->frame_size);\n\n\tif (status != __packet_get_status(po, h.raw))\n\t\treturn NULL;\n\n\treturn h.raw;\n}\n\nstatic void *packet_current_frame(struct packet_sock *po,\n\t\tstruct packet_ring_buffer *rb,\n\t\tint status)\n{\n\treturn packet_lookup_frame(po, rb, rb->head, status);\n}\n\nstatic void prb_del_retire_blk_timer(struct tpacket_kbdq_core *pkc)\n{\n\tdel_timer_sync(&pkc->retire_blk_timer);\n}\n\nstatic void prb_shutdown_retire_blk_timer(struct packet_sock *po,\n\t\tstruct sk_buff_head *rb_queue)\n{\n\tstruct tpacket_kbdq_core *pkc;\n\n\tpkc = GET_PBDQC_FROM_RB(&po->rx_ring);\n\n\tspin_lock_bh(&rb_queue->lock);\n\tpkc->delete_blk_timer = 1;\n\tspin_unlock_bh(&rb_queue->lock);\n\n\tprb_del_retire_blk_timer(pkc);\n}\n\nstatic void prb_setup_retire_blk_timer(struct packet_sock *po)\n{\n\tstruct tpacket_kbdq_core *pkc;\n\n\tpkc = GET_PBDQC_FROM_RB(&po->rx_ring);\n\ttimer_setup(&pkc->retire_blk_timer, prb_retire_rx_blk_timer_expired,\n\t\t    0);\n\tpkc->retire_blk_timer.expires = jiffies;\n}\n\nstatic int prb_calc_retire_blk_tmo(struct packet_sock *po,\n\t\t\t\tint blk_size_in_bytes)\n{\n\tstruct net_device *dev;\n\tunsigned int mbits, div;\n\tstruct ethtool_link_ksettings ecmd;\n\tint err;\n\n\trtnl_lock();\n\tdev = __dev_get_by_index(sock_net(&po->sk), po->ifindex);\n\tif (unlikely(!dev)) {\n\t\trtnl_unlock();\n\t\treturn DEFAULT_PRB_RETIRE_TOV;\n\t}\n\terr = __ethtool_get_link_ksettings(dev, &ecmd);\n\trtnl_unlock();\n\tif (err)\n\t\treturn DEFAULT_PRB_RETIRE_TOV;\n\n\t/* If the link speed is so slow you don't really\n\t * need to worry about perf anyways\n\t */\n\tif (ecmd.base.speed < SPEED_1000 ||\n\t    ecmd.base.speed == SPEED_UNKNOWN)\n\t\treturn DEFAULT_PRB_RETIRE_TOV;\n\n\tdiv = ecmd.base.speed / 1000;\n\tmbits = (blk_size_in_bytes * 8) / (1024 * 1024);\n\n\tif (div)\n\t\tmbits /= div;\n\n\tif (div)\n\t\treturn mbits + 1;\n\treturn mbits;\n}\n\nstatic void prb_init_ft_ops(struct tpacket_kbdq_core *p1,\n\t\t\tunion tpacket_req_u *req_u)\n{\n\tp1->feature_req_word = req_u->req3.tp_feature_req_word;\n}\n\nstatic void init_prb_bdqc(struct packet_sock *po,\n\t\t\tstruct packet_ring_buffer *rb,\n\t\t\tstruct pgv *pg_vec,\n\t\t\tunion tpacket_req_u *req_u)\n{\n\tstruct tpacket_kbdq_core *p1 = GET_PBDQC_FROM_RB(rb);\n\tstruct tpacket_block_desc *pbd;\n\n\tmemset(p1, 0x0, sizeof(*p1));\n\n\tp1->knxt_seq_num = 1;\n\tp1->pkbdq = pg_vec;\n\tpbd = (struct tpacket_block_desc *)pg_vec[0].buffer;\n\tp1->pkblk_start\t= pg_vec[0].buffer;\n\tp1->kblk_size = req_u->req3.tp_block_size;\n\tp1->knum_blocks\t= req_u->req3.tp_block_nr;\n\tp1->hdrlen = po->tp_hdrlen;\n\tp1->version = po->tp_version;\n\tp1->last_kactive_blk_num = 0;\n\tpo->stats.stats3.tp_freeze_q_cnt = 0;\n\tif (req_u->req3.tp_retire_blk_tov)\n\t\tp1->retire_blk_tov = req_u->req3.tp_retire_blk_tov;\n\telse\n\t\tp1->retire_blk_tov = prb_calc_retire_blk_tmo(po,\n\t\t\t\t\t\treq_u->req3.tp_block_size);\n\tp1->tov_in_jiffies = msecs_to_jiffies(p1->retire_blk_tov);\n\tp1->blk_sizeof_priv = req_u->req3.tp_sizeof_priv;\n\trwlock_init(&p1->blk_fill_in_prog_lock);\n\n\tp1->max_frame_len = p1->kblk_size - BLK_PLUS_PRIV(p1->blk_sizeof_priv);\n\tprb_init_ft_ops(p1, req_u);\n\tprb_setup_retire_blk_timer(po);\n\tprb_open_block(p1, pbd);\n}\n\n/*  Do NOT update the last_blk_num first.\n *  Assumes sk_buff_head lock is held.\n */\nstatic void _prb_refresh_rx_retire_blk_timer(struct tpacket_kbdq_core *pkc)\n{\n\tmod_timer(&pkc->retire_blk_timer,\n\t\t\tjiffies + pkc->tov_in_jiffies);\n\tpkc->last_kactive_blk_num = pkc->kactive_blk_num;\n}\n\n/*\n * Timer logic:\n * 1) We refresh the timer only when we open a block.\n *    By doing this we don't waste cycles refreshing the timer\n *\t  on packet-by-packet basis.\n *\n * With a 1MB block-size, on a 1Gbps line, it will take\n * i) ~8 ms to fill a block + ii) memcpy etc.\n * In this cut we are not accounting for the memcpy time.\n *\n * So, if the user sets the 'tmo' to 10ms then the timer\n * will never fire while the block is still getting filled\n * (which is what we want). However, the user could choose\n * to close a block early and that's fine.\n *\n * But when the timer does fire, we check whether or not to refresh it.\n * Since the tmo granularity is in msecs, it is not too expensive\n * to refresh the timer, lets say every '8' msecs.\n * Either the user can set the 'tmo' or we can derive it based on\n * a) line-speed and b) block-size.\n * prb_calc_retire_blk_tmo() calculates the tmo.\n *\n */\nstatic void prb_retire_rx_blk_timer_expired(struct timer_list *t)\n{\n\tstruct packet_sock *po =\n\t\tfrom_timer(po, t, rx_ring.prb_bdqc.retire_blk_timer);\n\tstruct tpacket_kbdq_core *pkc = GET_PBDQC_FROM_RB(&po->rx_ring);\n\tunsigned int frozen;\n\tstruct tpacket_block_desc *pbd;\n\n\tspin_lock(&po->sk.sk_receive_queue.lock);\n\n\tfrozen = prb_queue_frozen(pkc);\n\tpbd = GET_CURR_PBLOCK_DESC_FROM_CORE(pkc);\n\n\tif (unlikely(pkc->delete_blk_timer))\n\t\tgoto out;\n\n\t/* We only need to plug the race when the block is partially filled.\n\t * tpacket_rcv:\n\t *\t\tlock(); increment BLOCK_NUM_PKTS; unlock()\n\t *\t\tcopy_bits() is in progress ...\n\t *\t\ttimer fires on other cpu:\n\t *\t\twe can't retire the current block because copy_bits\n\t *\t\tis in progress.\n\t *\n\t */\n\tif (BLOCK_NUM_PKTS(pbd)) {\n\t\t/* Waiting for skb_copy_bits to finish... */\n\t\twrite_lock(&pkc->blk_fill_in_prog_lock);\n\t\twrite_unlock(&pkc->blk_fill_in_prog_lock);\n\t}\n\n\tif (pkc->last_kactive_blk_num == pkc->kactive_blk_num) {\n\t\tif (!frozen) {\n\t\t\tif (!BLOCK_NUM_PKTS(pbd)) {\n\t\t\t\t/* An empty block. Just refresh the timer. */\n\t\t\t\tgoto refresh_timer;\n\t\t\t}\n\t\t\tprb_retire_current_block(pkc, po, TP_STATUS_BLK_TMO);\n\t\t\tif (!prb_dispatch_next_block(pkc, po))\n\t\t\t\tgoto refresh_timer;\n\t\t\telse\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t/* Case 1. Queue was frozen because user-space was\n\t\t\t *\t   lagging behind.\n\t\t\t */\n\t\t\tif (prb_curr_blk_in_use(pbd)) {\n\t\t\t\t/*\n\t\t\t\t * Ok, user-space is still behind.\n\t\t\t\t * So just refresh the timer.\n\t\t\t\t */\n\t\t\t\tgoto refresh_timer;\n\t\t\t} else {\n\t\t\t       /* Case 2. queue was frozen,user-space caught up,\n\t\t\t\t* now the link went idle && the timer fired.\n\t\t\t\t* We don't have a block to close.So we open this\n\t\t\t\t* block and restart the timer.\n\t\t\t\t* opening a block thaws the queue,restarts timer\n\t\t\t\t* Thawing/timer-refresh is a side effect.\n\t\t\t\t*/\n\t\t\t\tprb_open_block(pkc, pbd);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\nrefresh_timer:\n\t_prb_refresh_rx_retire_blk_timer(pkc);\n\nout:\n\tspin_unlock(&po->sk.sk_receive_queue.lock);\n}\n\nstatic void prb_flush_block(struct tpacket_kbdq_core *pkc1,\n\t\tstruct tpacket_block_desc *pbd1, __u32 status)\n{\n\t/* Flush everything minus the block header */\n\n#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1\n\tu8 *start, *end;\n\n\tstart = (u8 *)pbd1;\n\n\t/* Skip the block header(we know header WILL fit in 4K) */\n\tstart += PAGE_SIZE;\n\n\tend = (u8 *)PAGE_ALIGN((unsigned long)pkc1->pkblk_end);\n\tfor (; start < end; start += PAGE_SIZE)\n\t\tflush_dcache_page(pgv_to_page(start));\n\n\tsmp_wmb();\n#endif\n\n\t/* Now update the block status. */\n\n\tBLOCK_STATUS(pbd1) = status;\n\n\t/* Flush the block header */\n\n#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1\n\tstart = (u8 *)pbd1;\n\tflush_dcache_page(pgv_to_page(start));\n\n\tsmp_wmb();\n#endif\n}\n\n/*\n * Side effect:\n *\n * 1) flush the block\n * 2) Increment active_blk_num\n *\n * Note:We DONT refresh the timer on purpose.\n *\tBecause almost always the next block will be opened.\n */\nstatic void prb_close_block(struct tpacket_kbdq_core *pkc1,\n\t\tstruct tpacket_block_desc *pbd1,\n\t\tstruct packet_sock *po, unsigned int stat)\n{\n\t__u32 status = TP_STATUS_USER | stat;\n\n\tstruct tpacket3_hdr *last_pkt;\n\tstruct tpacket_hdr_v1 *h1 = &pbd1->hdr.bh1;\n\tstruct sock *sk = &po->sk;\n\n\tif (atomic_read(&po->tp_drops))\n\t\tstatus |= TP_STATUS_LOSING;\n\n\tlast_pkt = (struct tpacket3_hdr *)pkc1->prev;\n\tlast_pkt->tp_next_offset = 0;\n\n\t/* Get the ts of the last pkt */\n\tif (BLOCK_NUM_PKTS(pbd1)) {\n\t\th1->ts_last_pkt.ts_sec = last_pkt->tp_sec;\n\t\th1->ts_last_pkt.ts_nsec\t= last_pkt->tp_nsec;\n\t} else {\n\t\t/* Ok, we tmo'd - so get the current time.\n\t\t *\n\t\t * It shouldn't really happen as we don't close empty\n\t\t * blocks. See prb_retire_rx_blk_timer_expired().\n\t\t */\n\t\tstruct timespec64 ts;\n\t\tktime_get_real_ts64(&ts);\n\t\th1->ts_last_pkt.ts_sec = ts.tv_sec;\n\t\th1->ts_last_pkt.ts_nsec\t= ts.tv_nsec;\n\t}\n\n\tsmp_wmb();\n\n\t/* Flush the block */\n\tprb_flush_block(pkc1, pbd1, status);\n\n\tsk->sk_data_ready(sk);\n\n\tpkc1->kactive_blk_num = GET_NEXT_PRB_BLK_NUM(pkc1);\n}\n\nstatic void prb_thaw_queue(struct tpacket_kbdq_core *pkc)\n{\n\tpkc->reset_pending_on_curr_blk = 0;\n}\n\n/*\n * Side effect of opening a block:\n *\n * 1) prb_queue is thawed.\n * 2) retire_blk_timer is refreshed.\n *\n */\nstatic void prb_open_block(struct tpacket_kbdq_core *pkc1,\n\tstruct tpacket_block_desc *pbd1)\n{\n\tstruct timespec64 ts;\n\tstruct tpacket_hdr_v1 *h1 = &pbd1->hdr.bh1;\n\n\tsmp_rmb();\n\n\t/* We could have just memset this but we will lose the\n\t * flexibility of making the priv area sticky\n\t */\n\n\tBLOCK_SNUM(pbd1) = pkc1->knxt_seq_num++;\n\tBLOCK_NUM_PKTS(pbd1) = 0;\n\tBLOCK_LEN(pbd1) = BLK_PLUS_PRIV(pkc1->blk_sizeof_priv);\n\n\tktime_get_real_ts64(&ts);\n\n\th1->ts_first_pkt.ts_sec = ts.tv_sec;\n\th1->ts_first_pkt.ts_nsec = ts.tv_nsec;\n\n\tpkc1->pkblk_start = (char *)pbd1;\n\tpkc1->nxt_offset = pkc1->pkblk_start + BLK_PLUS_PRIV(pkc1->blk_sizeof_priv);\n\n\tBLOCK_O2FP(pbd1) = (__u32)BLK_PLUS_PRIV(pkc1->blk_sizeof_priv);\n\tBLOCK_O2PRIV(pbd1) = BLK_HDR_LEN;\n\n\tpbd1->version = pkc1->version;\n\tpkc1->prev = pkc1->nxt_offset;\n\tpkc1->pkblk_end = pkc1->pkblk_start + pkc1->kblk_size;\n\n\tprb_thaw_queue(pkc1);\n\t_prb_refresh_rx_retire_blk_timer(pkc1);\n\n\tsmp_wmb();\n}\n\n/*\n * Queue freeze logic:\n * 1) Assume tp_block_nr = 8 blocks.\n * 2) At time 't0', user opens Rx ring.\n * 3) Some time past 't0', kernel starts filling blocks starting from 0 .. 7\n * 4) user-space is either sleeping or processing block '0'.\n * 5) tpacket_rcv is currently filling block '7', since there is no space left,\n *    it will close block-7,loop around and try to fill block '0'.\n *    call-flow:\n *    __packet_lookup_frame_in_block\n *      prb_retire_current_block()\n *      prb_dispatch_next_block()\n *        |->(BLOCK_STATUS == USER) evaluates to true\n *    5.1) Since block-0 is currently in-use, we just freeze the queue.\n * 6) Now there are two cases:\n *    6.1) Link goes idle right after the queue is frozen.\n *         But remember, the last open_block() refreshed the timer.\n *         When this timer expires,it will refresh itself so that we can\n *         re-open block-0 in near future.\n *    6.2) Link is busy and keeps on receiving packets. This is a simple\n *         case and __packet_lookup_frame_in_block will check if block-0\n *         is free and can now be re-used.\n */\nstatic void prb_freeze_queue(struct tpacket_kbdq_core *pkc,\n\t\t\t\t  struct packet_sock *po)\n{\n\tpkc->reset_pending_on_curr_blk = 1;\n\tpo->stats.stats3.tp_freeze_q_cnt++;\n}\n\n#define TOTAL_PKT_LEN_INCL_ALIGN(length) (ALIGN((length), V3_ALIGNMENT))\n\n/*\n * If the next block is free then we will dispatch it\n * and return a good offset.\n * Else, we will freeze the queue.\n * So, caller must check the return value.\n */\nstatic void *prb_dispatch_next_block(struct tpacket_kbdq_core *pkc,\n\t\tstruct packet_sock *po)\n{\n\tstruct tpacket_block_desc *pbd;\n\n\tsmp_rmb();\n\n\t/* 1. Get current block num */\n\tpbd = GET_CURR_PBLOCK_DESC_FROM_CORE(pkc);\n\n\t/* 2. If this block is currently in_use then freeze the queue */\n\tif (TP_STATUS_USER & BLOCK_STATUS(pbd)) {\n\t\tprb_freeze_queue(pkc, po);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * 3.\n\t * open this block and return the offset where the first packet\n\t * needs to get stored.\n\t */\n\tprb_open_block(pkc, pbd);\n\treturn (void *)pkc->nxt_offset;\n}\n\nstatic void prb_retire_current_block(struct tpacket_kbdq_core *pkc,\n\t\tstruct packet_sock *po, unsigned int status)\n{\n\tstruct tpacket_block_desc *pbd = GET_CURR_PBLOCK_DESC_FROM_CORE(pkc);\n\n\t/* retire/close the current block */\n\tif (likely(TP_STATUS_KERNEL == BLOCK_STATUS(pbd))) {\n\t\t/*\n\t\t * Plug the case where copy_bits() is in progress on\n\t\t * cpu-0 and tpacket_rcv() got invoked on cpu-1, didn't\n\t\t * have space to copy the pkt in the current block and\n\t\t * called prb_retire_current_block()\n\t\t *\n\t\t * We don't need to worry about the TMO case because\n\t\t * the timer-handler already handled this case.\n\t\t */\n\t\tif (!(status & TP_STATUS_BLK_TMO)) {\n\t\t\t/* Waiting for skb_copy_bits to finish... */\n\t\t\twrite_lock(&pkc->blk_fill_in_prog_lock);\n\t\t\twrite_unlock(&pkc->blk_fill_in_prog_lock);\n\t\t}\n\t\tprb_close_block(pkc, pbd, po, status);\n\t\treturn;\n\t}\n}\n\nstatic int prb_curr_blk_in_use(struct tpacket_block_desc *pbd)\n{\n\treturn TP_STATUS_USER & BLOCK_STATUS(pbd);\n}\n\nstatic int prb_queue_frozen(struct tpacket_kbdq_core *pkc)\n{\n\treturn pkc->reset_pending_on_curr_blk;\n}\n\nstatic void prb_clear_blk_fill_status(struct packet_ring_buffer *rb)\n\t__releases(&pkc->blk_fill_in_prog_lock)\n{\n\tstruct tpacket_kbdq_core *pkc  = GET_PBDQC_FROM_RB(rb);\n\n\tread_unlock(&pkc->blk_fill_in_prog_lock);\n}\n\nstatic void prb_fill_rxhash(struct tpacket_kbdq_core *pkc,\n\t\t\tstruct tpacket3_hdr *ppd)\n{\n\tppd->hv1.tp_rxhash = skb_get_hash(pkc->skb);\n}\n\nstatic void prb_clear_rxhash(struct tpacket_kbdq_core *pkc,\n\t\t\tstruct tpacket3_hdr *ppd)\n{\n\tppd->hv1.tp_rxhash = 0;\n}\n\nstatic void prb_fill_vlan_info(struct tpacket_kbdq_core *pkc,\n\t\t\tstruct tpacket3_hdr *ppd)\n{\n\tif (skb_vlan_tag_present(pkc->skb)) {\n\t\tppd->hv1.tp_vlan_tci = skb_vlan_tag_get(pkc->skb);\n\t\tppd->hv1.tp_vlan_tpid = ntohs(pkc->skb->vlan_proto);\n\t\tppd->tp_status = TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;\n\t} else {\n\t\tppd->hv1.tp_vlan_tci = 0;\n\t\tppd->hv1.tp_vlan_tpid = 0;\n\t\tppd->tp_status = TP_STATUS_AVAILABLE;\n\t}\n}\n\nstatic void prb_run_all_ft_ops(struct tpacket_kbdq_core *pkc,\n\t\t\tstruct tpacket3_hdr *ppd)\n{\n\tppd->hv1.tp_padding = 0;\n\tprb_fill_vlan_info(pkc, ppd);\n\n\tif (pkc->feature_req_word & TP_FT_REQ_FILL_RXHASH)\n\t\tprb_fill_rxhash(pkc, ppd);\n\telse\n\t\tprb_clear_rxhash(pkc, ppd);\n}\n\nstatic void prb_fill_curr_block(char *curr,\n\t\t\t\tstruct tpacket_kbdq_core *pkc,\n\t\t\t\tstruct tpacket_block_desc *pbd,\n\t\t\t\tunsigned int len)\n\t__acquires(&pkc->blk_fill_in_prog_lock)\n{\n\tstruct tpacket3_hdr *ppd;\n\n\tppd  = (struct tpacket3_hdr *)curr;\n\tppd->tp_next_offset = TOTAL_PKT_LEN_INCL_ALIGN(len);\n\tpkc->prev = curr;\n\tpkc->nxt_offset += TOTAL_PKT_LEN_INCL_ALIGN(len);\n\tBLOCK_LEN(pbd) += TOTAL_PKT_LEN_INCL_ALIGN(len);\n\tBLOCK_NUM_PKTS(pbd) += 1;\n\tread_lock(&pkc->blk_fill_in_prog_lock);\n\tprb_run_all_ft_ops(pkc, ppd);\n}\n\n/* Assumes caller has the sk->rx_queue.lock */\nstatic void *__packet_lookup_frame_in_block(struct packet_sock *po,\n\t\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t\t    unsigned int len\n\t\t\t\t\t    )\n{\n\tstruct tpacket_kbdq_core *pkc;\n\tstruct tpacket_block_desc *pbd;\n\tchar *curr, *end;\n\n\tpkc = GET_PBDQC_FROM_RB(&po->rx_ring);\n\tpbd = GET_CURR_PBLOCK_DESC_FROM_CORE(pkc);\n\n\t/* Queue is frozen when user space is lagging behind */\n\tif (prb_queue_frozen(pkc)) {\n\t\t/*\n\t\t * Check if that last block which caused the queue to freeze,\n\t\t * is still in_use by user-space.\n\t\t */\n\t\tif (prb_curr_blk_in_use(pbd)) {\n\t\t\t/* Can't record this packet */\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Ok, the block was released by user-space.\n\t\t\t * Now let's open that block.\n\t\t\t * opening a block also thaws the queue.\n\t\t\t * Thawing is a side effect.\n\t\t\t */\n\t\t\tprb_open_block(pkc, pbd);\n\t\t}\n\t}\n\n\tsmp_mb();\n\tcurr = pkc->nxt_offset;\n\tpkc->skb = skb;\n\tend = (char *)pbd + pkc->kblk_size;\n\n\t/* first try the current block */\n\tif (curr+TOTAL_PKT_LEN_INCL_ALIGN(len) < end) {\n\t\tprb_fill_curr_block(curr, pkc, pbd, len);\n\t\treturn (void *)curr;\n\t}\n\n\t/* Ok, close the current block */\n\tprb_retire_current_block(pkc, po, 0);\n\n\t/* Now, try to dispatch the next block */\n\tcurr = (char *)prb_dispatch_next_block(pkc, po);\n\tif (curr) {\n\t\tpbd = GET_CURR_PBLOCK_DESC_FROM_CORE(pkc);\n\t\tprb_fill_curr_block(curr, pkc, pbd, len);\n\t\treturn (void *)curr;\n\t}\n\n\t/*\n\t * No free blocks are available.user_space hasn't caught up yet.\n\t * Queue was just frozen and now this packet will get dropped.\n\t */\n\treturn NULL;\n}\n\nstatic void *packet_current_rx_frame(struct packet_sock *po,\n\t\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t\t    int status, unsigned int len)\n{\n\tchar *curr = NULL;\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\tcase TPACKET_V2:\n\t\tcurr = packet_lookup_frame(po, &po->rx_ring,\n\t\t\t\t\tpo->rx_ring.head, status);\n\t\treturn curr;\n\tcase TPACKET_V3:\n\t\treturn __packet_lookup_frame_in_block(po, skb, len);\n\tdefault:\n\t\tWARN(1, \"TPACKET version not supported\\n\");\n\t\tBUG();\n\t\treturn NULL;\n\t}\n}\n\nstatic void *prb_lookup_block(const struct packet_sock *po,\n\t\t\t      const struct packet_ring_buffer *rb,\n\t\t\t      unsigned int idx,\n\t\t\t      int status)\n{\n\tstruct tpacket_kbdq_core *pkc  = GET_PBDQC_FROM_RB(rb);\n\tstruct tpacket_block_desc *pbd = GET_PBLOCK_DESC(pkc, idx);\n\n\tif (status != BLOCK_STATUS(pbd))\n\t\treturn NULL;\n\treturn pbd;\n}\n\nstatic int prb_previous_blk_num(struct packet_ring_buffer *rb)\n{\n\tunsigned int prev;\n\tif (rb->prb_bdqc.kactive_blk_num)\n\t\tprev = rb->prb_bdqc.kactive_blk_num-1;\n\telse\n\t\tprev = rb->prb_bdqc.knum_blocks-1;\n\treturn prev;\n}\n\n/* Assumes caller has held the rx_queue.lock */\nstatic void *__prb_previous_block(struct packet_sock *po,\n\t\t\t\t\t struct packet_ring_buffer *rb,\n\t\t\t\t\t int status)\n{\n\tunsigned int previous = prb_previous_blk_num(rb);\n\treturn prb_lookup_block(po, rb, previous, status);\n}\n\nstatic void *packet_previous_rx_frame(struct packet_sock *po,\n\t\t\t\t\t     struct packet_ring_buffer *rb,\n\t\t\t\t\t     int status)\n{\n\tif (po->tp_version <= TPACKET_V2)\n\t\treturn packet_previous_frame(po, rb, status);\n\n\treturn __prb_previous_block(po, rb, status);\n}\n\nstatic void packet_increment_rx_head(struct packet_sock *po,\n\t\t\t\t\t    struct packet_ring_buffer *rb)\n{\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\tcase TPACKET_V2:\n\t\treturn packet_increment_head(rb);\n\tcase TPACKET_V3:\n\tdefault:\n\t\tWARN(1, \"TPACKET version not supported.\\n\");\n\t\tBUG();\n\t\treturn;\n\t}\n}\n\nstatic void *packet_previous_frame(struct packet_sock *po,\n\t\tstruct packet_ring_buffer *rb,\n\t\tint status)\n{\n\tunsigned int previous = rb->head ? rb->head - 1 : rb->frame_max;\n\treturn packet_lookup_frame(po, rb, previous, status);\n}\n\nstatic void packet_increment_head(struct packet_ring_buffer *buff)\n{\n\tbuff->head = buff->head != buff->frame_max ? buff->head+1 : 0;\n}\n\nstatic void packet_inc_pending(struct packet_ring_buffer *rb)\n{\n\tthis_cpu_inc(*rb->pending_refcnt);\n}\n\nstatic void packet_dec_pending(struct packet_ring_buffer *rb)\n{\n\tthis_cpu_dec(*rb->pending_refcnt);\n}\n\nstatic unsigned int packet_read_pending(const struct packet_ring_buffer *rb)\n{\n\tunsigned int refcnt = 0;\n\tint cpu;\n\n\t/* We don't use pending refcount in rx_ring. */\n\tif (rb->pending_refcnt == NULL)\n\t\treturn 0;\n\n\tfor_each_possible_cpu(cpu)\n\t\trefcnt += *per_cpu_ptr(rb->pending_refcnt, cpu);\n\n\treturn refcnt;\n}\n\nstatic int packet_alloc_pending(struct packet_sock *po)\n{\n\tpo->rx_ring.pending_refcnt = NULL;\n\n\tpo->tx_ring.pending_refcnt = alloc_percpu(unsigned int);\n\tif (unlikely(po->tx_ring.pending_refcnt == NULL))\n\t\treturn -ENOBUFS;\n\n\treturn 0;\n}\n\nstatic void packet_free_pending(struct packet_sock *po)\n{\n\tfree_percpu(po->tx_ring.pending_refcnt);\n}\n\n#define ROOM_POW_OFF\t2\n#define ROOM_NONE\t0x0\n#define ROOM_LOW\t0x1\n#define ROOM_NORMAL\t0x2\n\nstatic bool __tpacket_has_room(const struct packet_sock *po, int pow_off)\n{\n\tint idx, len;\n\n\tlen = READ_ONCE(po->rx_ring.frame_max) + 1;\n\tidx = READ_ONCE(po->rx_ring.head);\n\tif (pow_off)\n\t\tidx += len >> pow_off;\n\tif (idx >= len)\n\t\tidx -= len;\n\treturn packet_lookup_frame(po, &po->rx_ring, idx, TP_STATUS_KERNEL);\n}\n\nstatic bool __tpacket_v3_has_room(const struct packet_sock *po, int pow_off)\n{\n\tint idx, len;\n\n\tlen = READ_ONCE(po->rx_ring.prb_bdqc.knum_blocks);\n\tidx = READ_ONCE(po->rx_ring.prb_bdqc.kactive_blk_num);\n\tif (pow_off)\n\t\tidx += len >> pow_off;\n\tif (idx >= len)\n\t\tidx -= len;\n\treturn prb_lookup_block(po, &po->rx_ring, idx, TP_STATUS_KERNEL);\n}\n\nstatic int __packet_rcv_has_room(const struct packet_sock *po,\n\t\t\t\t const struct sk_buff *skb)\n{\n\tconst struct sock *sk = &po->sk;\n\tint ret = ROOM_NONE;\n\n\tif (po->prot_hook.func != tpacket_rcv) {\n\t\tint rcvbuf = READ_ONCE(sk->sk_rcvbuf);\n\t\tint avail = rcvbuf - atomic_read(&sk->sk_rmem_alloc)\n\t\t\t\t   - (skb ? skb->truesize : 0);\n\n\t\tif (avail > (rcvbuf >> ROOM_POW_OFF))\n\t\t\treturn ROOM_NORMAL;\n\t\telse if (avail > 0)\n\t\t\treturn ROOM_LOW;\n\t\telse\n\t\t\treturn ROOM_NONE;\n\t}\n\n\tif (po->tp_version == TPACKET_V3) {\n\t\tif (__tpacket_v3_has_room(po, ROOM_POW_OFF))\n\t\t\tret = ROOM_NORMAL;\n\t\telse if (__tpacket_v3_has_room(po, 0))\n\t\t\tret = ROOM_LOW;\n\t} else {\n\t\tif (__tpacket_has_room(po, ROOM_POW_OFF))\n\t\t\tret = ROOM_NORMAL;\n\t\telse if (__tpacket_has_room(po, 0))\n\t\t\tret = ROOM_LOW;\n\t}\n\n\treturn ret;\n}\n\nstatic int packet_rcv_has_room(struct packet_sock *po, struct sk_buff *skb)\n{\n\tint pressure, ret;\n\n\tret = __packet_rcv_has_room(po, skb);\n\tpressure = ret != ROOM_NORMAL;\n\n\tif (READ_ONCE(po->pressure) != pressure)\n\t\tWRITE_ONCE(po->pressure, pressure);\n\n\treturn ret;\n}\n\nstatic void packet_rcv_try_clear_pressure(struct packet_sock *po)\n{\n\tif (READ_ONCE(po->pressure) &&\n\t    __packet_rcv_has_room(po, NULL) == ROOM_NORMAL)\n\t\tWRITE_ONCE(po->pressure,  0);\n}\n\nstatic void packet_sock_destruct(struct sock *sk)\n{\n\tskb_queue_purge(&sk->sk_error_queue);\n\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(refcount_read(&sk->sk_wmem_alloc));\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive packet socket: %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tsk_refcnt_debug_dec(sk);\n}\n\nstatic bool fanout_flow_is_huge(struct packet_sock *po, struct sk_buff *skb)\n{\n\tu32 *history = po->rollover->history;\n\tu32 victim, rxhash;\n\tint i, count = 0;\n\n\trxhash = skb_get_hash(skb);\n\tfor (i = 0; i < ROLLOVER_HLEN; i++)\n\t\tif (READ_ONCE(history[i]) == rxhash)\n\t\t\tcount++;\n\n\tvictim = prandom_u32() % ROLLOVER_HLEN;\n\n\t/* Avoid dirtying the cache line if possible */\n\tif (READ_ONCE(history[victim]) != rxhash)\n\t\tWRITE_ONCE(history[victim], rxhash);\n\n\treturn count > (ROLLOVER_HLEN >> 1);\n}\n\nstatic unsigned int fanout_demux_hash(struct packet_fanout *f,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      unsigned int num)\n{\n\treturn reciprocal_scale(__skb_get_hash_symmetric(skb), num);\n}\n\nstatic unsigned int fanout_demux_lb(struct packet_fanout *f,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    unsigned int num)\n{\n\tunsigned int val = atomic_inc_return(&f->rr_cur);\n\n\treturn val % num;\n}\n\nstatic unsigned int fanout_demux_cpu(struct packet_fanout *f,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     unsigned int num)\n{\n\treturn smp_processor_id() % num;\n}\n\nstatic unsigned int fanout_demux_rnd(struct packet_fanout *f,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     unsigned int num)\n{\n\treturn prandom_u32_max(num);\n}\n\nstatic unsigned int fanout_demux_rollover(struct packet_fanout *f,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  unsigned int idx, bool try_self,\n\t\t\t\t\t  unsigned int num)\n{\n\tstruct packet_sock *po, *po_next, *po_skip = NULL;\n\tunsigned int i, j, room = ROOM_NONE;\n\n\tpo = pkt_sk(f->arr[idx]);\n\n\tif (try_self) {\n\t\troom = packet_rcv_has_room(po, skb);\n\t\tif (room == ROOM_NORMAL ||\n\t\t    (room == ROOM_LOW && !fanout_flow_is_huge(po, skb)))\n\t\t\treturn idx;\n\t\tpo_skip = po;\n\t}\n\n\ti = j = min_t(int, po->rollover->sock, num - 1);\n\tdo {\n\t\tpo_next = pkt_sk(f->arr[i]);\n\t\tif (po_next != po_skip && !READ_ONCE(po_next->pressure) &&\n\t\t    packet_rcv_has_room(po_next, skb) == ROOM_NORMAL) {\n\t\t\tif (i != j)\n\t\t\t\tpo->rollover->sock = i;\n\t\t\tatomic_long_inc(&po->rollover->num);\n\t\t\tif (room == ROOM_LOW)\n\t\t\t\tatomic_long_inc(&po->rollover->num_huge);\n\t\t\treturn i;\n\t\t}\n\n\t\tif (++i == num)\n\t\t\ti = 0;\n\t} while (i != j);\n\n\tatomic_long_inc(&po->rollover->num_failed);\n\treturn idx;\n}\n\nstatic unsigned int fanout_demux_qm(struct packet_fanout *f,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    unsigned int num)\n{\n\treturn skb_get_queue_mapping(skb) % num;\n}\n\nstatic unsigned int fanout_demux_bpf(struct packet_fanout *f,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     unsigned int num)\n{\n\tstruct bpf_prog *prog;\n\tunsigned int ret = 0;\n\n\trcu_read_lock();\n\tprog = rcu_dereference(f->bpf_prog);\n\tif (prog)\n\t\tret = bpf_prog_run_clear_cb(prog, skb) % num;\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic bool fanout_has_flag(struct packet_fanout *f, u16 flag)\n{\n\treturn f->flags & (flag >> 8);\n}\n\nstatic int packet_rcv_fanout(struct sk_buff *skb, struct net_device *dev,\n\t\t\t     struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct packet_fanout *f = pt->af_packet_priv;\n\tunsigned int num = READ_ONCE(f->num_members);\n\tstruct net *net = read_pnet(&f->net);\n\tstruct packet_sock *po;\n\tunsigned int idx;\n\n\tif (!net_eq(dev_net(dev), net) || !num) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tif (fanout_has_flag(f, PACKET_FANOUT_FLAG_DEFRAG)) {\n\t\tskb = ip_check_defrag(net, skb, IP_DEFRAG_AF_PACKET);\n\t\tif (!skb)\n\t\t\treturn 0;\n\t}\n\tswitch (f->type) {\n\tcase PACKET_FANOUT_HASH:\n\tdefault:\n\t\tidx = fanout_demux_hash(f, skb, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_LB:\n\t\tidx = fanout_demux_lb(f, skb, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_CPU:\n\t\tidx = fanout_demux_cpu(f, skb, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_RND:\n\t\tidx = fanout_demux_rnd(f, skb, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_QM:\n\t\tidx = fanout_demux_qm(f, skb, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_ROLLOVER:\n\t\tidx = fanout_demux_rollover(f, skb, 0, false, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_CBPF:\n\tcase PACKET_FANOUT_EBPF:\n\t\tidx = fanout_demux_bpf(f, skb, num);\n\t\tbreak;\n\t}\n\n\tif (fanout_has_flag(f, PACKET_FANOUT_FLAG_ROLLOVER))\n\t\tidx = fanout_demux_rollover(f, skb, idx, true, num);\n\n\tpo = pkt_sk(f->arr[idx]);\n\treturn po->prot_hook.func(skb, dev, &po->prot_hook, orig_dev);\n}\n\nDEFINE_MUTEX(fanout_mutex);\nEXPORT_SYMBOL_GPL(fanout_mutex);\nstatic LIST_HEAD(fanout_list);\nstatic u16 fanout_next_id;\n\nstatic void __fanout_link(struct sock *sk, struct packet_sock *po)\n{\n\tstruct packet_fanout *f = po->fanout;\n\n\tspin_lock(&f->lock);\n\tf->arr[f->num_members] = sk;\n\tsmp_wmb();\n\tf->num_members++;\n\tif (f->num_members == 1)\n\t\tdev_add_pack(&f->prot_hook);\n\tspin_unlock(&f->lock);\n}\n\nstatic void __fanout_unlink(struct sock *sk, struct packet_sock *po)\n{\n\tstruct packet_fanout *f = po->fanout;\n\tint i;\n\n\tspin_lock(&f->lock);\n\tfor (i = 0; i < f->num_members; i++) {\n\t\tif (f->arr[i] == sk)\n\t\t\tbreak;\n\t}\n\tBUG_ON(i >= f->num_members);\n\tf->arr[i] = f->arr[f->num_members - 1];\n\tf->num_members--;\n\tif (f->num_members == 0)\n\t\t__dev_remove_pack(&f->prot_hook);\n\tspin_unlock(&f->lock);\n}\n\nstatic bool match_fanout_group(struct packet_type *ptype, struct sock *sk)\n{\n\tif (sk->sk_family != PF_PACKET)\n\t\treturn false;\n\n\treturn ptype->af_packet_priv == pkt_sk(sk)->fanout;\n}\n\nstatic void fanout_init_data(struct packet_fanout *f)\n{\n\tswitch (f->type) {\n\tcase PACKET_FANOUT_LB:\n\t\tatomic_set(&f->rr_cur, 0);\n\t\tbreak;\n\tcase PACKET_FANOUT_CBPF:\n\tcase PACKET_FANOUT_EBPF:\n\t\tRCU_INIT_POINTER(f->bpf_prog, NULL);\n\t\tbreak;\n\t}\n}\n\nstatic void __fanout_set_data_bpf(struct packet_fanout *f, struct bpf_prog *new)\n{\n\tstruct bpf_prog *old;\n\n\tspin_lock(&f->lock);\n\told = rcu_dereference_protected(f->bpf_prog, lockdep_is_held(&f->lock));\n\trcu_assign_pointer(f->bpf_prog, new);\n\tspin_unlock(&f->lock);\n\n\tif (old) {\n\t\tsynchronize_net();\n\t\tbpf_prog_destroy(old);\n\t}\n}\n\nstatic int fanout_set_data_cbpf(struct packet_sock *po, sockptr_t data,\n\t\t\t\tunsigned int len)\n{\n\tstruct bpf_prog *new;\n\tstruct sock_fprog fprog;\n\tint ret;\n\n\tif (sock_flag(&po->sk, SOCK_FILTER_LOCKED))\n\t\treturn -EPERM;\n\n\tret = copy_bpf_fprog_from_user(&fprog, data, len);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bpf_prog_create_from_user(&new, &fprog, NULL, false);\n\tif (ret)\n\t\treturn ret;\n\n\t__fanout_set_data_bpf(po->fanout, new);\n\treturn 0;\n}\n\nstatic int fanout_set_data_ebpf(struct packet_sock *po, sockptr_t data,\n\t\t\t\tunsigned int len)\n{\n\tstruct bpf_prog *new;\n\tu32 fd;\n\n\tif (sock_flag(&po->sk, SOCK_FILTER_LOCKED))\n\t\treturn -EPERM;\n\tif (len != sizeof(fd))\n\t\treturn -EINVAL;\n\tif (copy_from_sockptr(&fd, data, len))\n\t\treturn -EFAULT;\n\n\tnew = bpf_prog_get_type(fd, BPF_PROG_TYPE_SOCKET_FILTER);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\t__fanout_set_data_bpf(po->fanout, new);\n\treturn 0;\n}\n\nstatic int fanout_set_data(struct packet_sock *po, sockptr_t data,\n\t\t\t   unsigned int len)\n{\n\tswitch (po->fanout->type) {\n\tcase PACKET_FANOUT_CBPF:\n\t\treturn fanout_set_data_cbpf(po, data, len);\n\tcase PACKET_FANOUT_EBPF:\n\t\treturn fanout_set_data_ebpf(po, data, len);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void fanout_release_data(struct packet_fanout *f)\n{\n\tswitch (f->type) {\n\tcase PACKET_FANOUT_CBPF:\n\tcase PACKET_FANOUT_EBPF:\n\t\t__fanout_set_data_bpf(f, NULL);\n\t}\n}\n\nstatic bool __fanout_id_is_free(struct sock *sk, u16 candidate_id)\n{\n\tstruct packet_fanout *f;\n\n\tlist_for_each_entry(f, &fanout_list, list) {\n\t\tif (f->id == candidate_id &&\n\t\t    read_pnet(&f->net) == sock_net(sk)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool fanout_find_new_id(struct sock *sk, u16 *new_id)\n{\n\tu16 id = fanout_next_id;\n\n\tdo {\n\t\tif (__fanout_id_is_free(sk, id)) {\n\t\t\t*new_id = id;\n\t\t\tfanout_next_id = id + 1;\n\t\t\treturn true;\n\t\t}\n\n\t\tid++;\n\t} while (id != fanout_next_id);\n\n\treturn false;\n}\n\nstatic int fanout_add(struct sock *sk, struct fanout_args *args)\n{\n\tstruct packet_rollover *rollover = NULL;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tu16 type_flags = args->type_flags;\n\tstruct packet_fanout *f, *match;\n\tu8 type = type_flags & 0xff;\n\tu8 flags = type_flags >> 8;\n\tu16 id = args->id;\n\tint err;\n\n\tswitch (type) {\n\tcase PACKET_FANOUT_ROLLOVER:\n\t\tif (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)\n\t\t\treturn -EINVAL;\n\tcase PACKET_FANOUT_HASH:\n\tcase PACKET_FANOUT_LB:\n\tcase PACKET_FANOUT_CPU:\n\tcase PACKET_FANOUT_RND:\n\tcase PACKET_FANOUT_QM:\n\tcase PACKET_FANOUT_CBPF:\n\tcase PACKET_FANOUT_EBPF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&fanout_mutex);\n\n\terr = -EALREADY;\n\tif (po->fanout)\n\t\tgoto out;\n\n\tif (type == PACKET_FANOUT_ROLLOVER ||\n\t    (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {\n\t\terr = -ENOMEM;\n\t\trollover = kzalloc(sizeof(*rollover), GFP_KERNEL);\n\t\tif (!rollover)\n\t\t\tgoto out;\n\t\tatomic_long_set(&rollover->num, 0);\n\t\tatomic_long_set(&rollover->num_huge, 0);\n\t\tatomic_long_set(&rollover->num_failed, 0);\n\t}\n\n\tif (type_flags & PACKET_FANOUT_FLAG_UNIQUEID) {\n\t\tif (id != 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!fanout_find_new_id(sk, &id)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/* ephemeral flag for the first socket in the group: drop it */\n\t\tflags &= ~(PACKET_FANOUT_FLAG_UNIQUEID >> 8);\n\t}\n\n\tmatch = NULL;\n\tlist_for_each_entry(f, &fanout_list, list) {\n\t\tif (f->id == id &&\n\t\t    read_pnet(&f->net) == sock_net(sk)) {\n\t\t\tmatch = f;\n\t\t\tbreak;\n\t\t}\n\t}\n\terr = -EINVAL;\n\tif (match) {\n\t\tif (match->flags != flags)\n\t\t\tgoto out;\n\t\tif (args->max_num_members &&\n\t\t    args->max_num_members != match->max_num_members)\n\t\t\tgoto out;\n\t} else {\n\t\tif (args->max_num_members > PACKET_FANOUT_MAX)\n\t\t\tgoto out;\n\t\tif (!args->max_num_members)\n\t\t\t/* legacy PACKET_FANOUT_MAX */\n\t\t\targs->max_num_members = 256;\n\t\terr = -ENOMEM;\n\t\tmatch = kvzalloc(struct_size(match, arr, args->max_num_members),\n\t\t\t\t GFP_KERNEL);\n\t\tif (!match)\n\t\t\tgoto out;\n\t\twrite_pnet(&match->net, sock_net(sk));\n\t\tmatch->id = id;\n\t\tmatch->type = type;\n\t\tmatch->flags = flags;\n\t\tINIT_LIST_HEAD(&match->list);\n\t\tspin_lock_init(&match->lock);\n\t\trefcount_set(&match->sk_ref, 0);\n\t\tfanout_init_data(match);\n\t\tmatch->prot_hook.type = po->prot_hook.type;\n\t\tmatch->prot_hook.dev = po->prot_hook.dev;\n\t\tmatch->prot_hook.func = packet_rcv_fanout;\n\t\tmatch->prot_hook.af_packet_priv = match;\n\t\tmatch->prot_hook.id_match = match_fanout_group;\n\t\tmatch->max_num_members = args->max_num_members;\n\t\tlist_add(&match->list, &fanout_list);\n\t}\n\terr = -EINVAL;\n\n\tspin_lock(&po->bind_lock);\n\tif (po->running &&\n\t    match->type == type &&\n\t    match->prot_hook.type == po->prot_hook.type &&\n\t    match->prot_hook.dev == po->prot_hook.dev) {\n\t\terr = -ENOSPC;\n\t\tif (refcount_read(&match->sk_ref) < match->max_num_members) {\n\t\t\t__dev_remove_pack(&po->prot_hook);\n\t\t\tpo->fanout = match;\n\t\t\tpo->rollover = rollover;\n\t\t\trollover = NULL;\n\t\t\trefcount_set(&match->sk_ref, refcount_read(&match->sk_ref) + 1);\n\t\t\t__fanout_link(sk, po);\n\t\t\terr = 0;\n\t\t}\n\t}\n\tspin_unlock(&po->bind_lock);\n\n\tif (err && !refcount_read(&match->sk_ref)) {\n\t\tlist_del(&match->list);\n\t\tkvfree(match);\n\t}\n\nout:\n\tkfree(rollover);\n\tmutex_unlock(&fanout_mutex);\n\treturn err;\n}\n\n/* If pkt_sk(sk)->fanout->sk_ref is zero, this function removes\n * pkt_sk(sk)->fanout from fanout_list and returns pkt_sk(sk)->fanout.\n * It is the responsibility of the caller to call fanout_release_data() and\n * free the returned packet_fanout (after synchronize_net())\n */\nstatic struct packet_fanout *fanout_release(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_fanout *f;\n\n\tmutex_lock(&fanout_mutex);\n\tf = po->fanout;\n\tif (f) {\n\t\tpo->fanout = NULL;\n\n\t\tif (refcount_dec_and_test(&f->sk_ref))\n\t\t\tlist_del(&f->list);\n\t\telse\n\t\t\tf = NULL;\n\t}\n\tmutex_unlock(&fanout_mutex);\n\n\treturn f;\n}\n\nstatic bool packet_extra_vlan_len_allowed(const struct net_device *dev,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\t/* Earlier code assumed this would be a VLAN pkt, double-check\n\t * this now that we have the actual packet in hand. We can only\n\t * do this check on Ethernet devices.\n\t */\n\tif (unlikely(dev->type != ARPHRD_ETHER))\n\t\treturn false;\n\n\tskb_reset_mac_header(skb);\n\treturn likely(eth_hdr(skb)->h_proto == htons(ETH_P_8021Q));\n}\n\nstatic const struct proto_ops packet_ops;\n\nstatic const struct proto_ops packet_ops_spkt;\n\nstatic int packet_rcv_spkt(struct sk_buff *skb, struct net_device *dev,\n\t\t\t   struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct sock *sk;\n\tstruct sockaddr_pkt *spkt;\n\n\t/*\n\t *\tWhen we registered the protocol we saved the socket in the data\n\t *\tfield for just this event.\n\t */\n\n\tsk = pt->af_packet_priv;\n\n\t/*\n\t *\tYank back the headers [hope the device set this\n\t *\tright or kerboom...]\n\t *\n\t *\tIncoming packets have ll header pulled,\n\t *\tpush it back.\n\t *\n\t *\tFor outgoing ones skb->data == skb_mac_header(skb)\n\t *\tso that this procedure is noop.\n\t */\n\n\tif (skb->pkt_type == PACKET_LOOPBACK)\n\t\tgoto out;\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\tgoto out;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto oom;\n\n\t/* drop any routing info */\n\tskb_dst_drop(skb);\n\n\t/* drop conntrack reference */\n\tnf_reset_ct(skb);\n\n\tspkt = &PACKET_SKB_CB(skb)->sa.pkt;\n\n\tskb_push(skb, skb->data - skb_mac_header(skb));\n\n\t/*\n\t *\tThe SOCK_PACKET socket receives _all_ frames.\n\t */\n\n\tspkt->spkt_family = dev->type;\n\tstrlcpy(spkt->spkt_device, dev->name, sizeof(spkt->spkt_device));\n\tspkt->spkt_protocol = skb->protocol;\n\n\t/*\n\t *\tCharge the memory to the socket. This is done specifically\n\t *\tto prevent sockets using all the memory up.\n\t */\n\n\tif (sock_queue_rcv_skb(sk, skb) == 0)\n\t\treturn 0;\n\nout:\n\tkfree_skb(skb);\noom:\n\treturn 0;\n}\n\nstatic void packet_parse_headers(struct sk_buff *skb, struct socket *sock)\n{\n\tif ((!skb->protocol || skb->protocol == htons(ETH_P_ALL)) &&\n\t    sock->type == SOCK_RAW) {\n\t\tskb_reset_mac_header(skb);\n\t\tskb->protocol = dev_parse_header_protocol(skb);\n\t}\n\n\tskb_probe_transport_header(skb);\n}\n\n/*\n *\tOutput a raw packet to a device layer. This bypasses all the other\n *\tprotocol layers and you must therefore supply it with a complete frame\n */\n\nstatic int packet_sendmsg_spkt(struct socket *sock, struct msghdr *msg,\n\t\t\t       size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tDECLARE_SOCKADDR(struct sockaddr_pkt *, saddr, msg->msg_name);\n\tstruct sk_buff *skb = NULL;\n\tstruct net_device *dev;\n\tstruct sockcm_cookie sockc;\n\t__be16 proto = 0;\n\tint err;\n\tint extra_len = 0;\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\n\tif (saddr) {\n\t\tif (msg->msg_namelen < sizeof(struct sockaddr))\n\t\t\treturn -EINVAL;\n\t\tif (msg->msg_namelen == sizeof(struct sockaddr_pkt))\n\t\t\tproto = saddr->spkt_protocol;\n\t} else\n\t\treturn -ENOTCONN;\t/* SOCK_PACKET must be sent giving an address */\n\n\t/*\n\t *\tFind the device first to size check it\n\t */\n\n\tsaddr->spkt_device[sizeof(saddr->spkt_device) - 1] = 0;\nretry:\n\trcu_read_lock();\n\tdev = dev_get_by_name_rcu(sock_net(sk), saddr->spkt_device);\n\terr = -ENODEV;\n\tif (dev == NULL)\n\t\tgoto out_unlock;\n\n\terr = -ENETDOWN;\n\tif (!(dev->flags & IFF_UP))\n\t\tgoto out_unlock;\n\n\t/*\n\t * You may not queue a frame bigger than the mtu. This is the lowest level\n\t * raw protocol and you must do your own fragmentation at this level.\n\t */\n\n\tif (unlikely(sock_flag(sk, SOCK_NOFCS))) {\n\t\tif (!netif_supports_nofcs(dev)) {\n\t\t\terr = -EPROTONOSUPPORT;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\textra_len = 4; /* We're doing our own CRC */\n\t}\n\n\terr = -EMSGSIZE;\n\tif (len > dev->mtu + dev->hard_header_len + VLAN_HLEN + extra_len)\n\t\tgoto out_unlock;\n\n\tif (!skb) {\n\t\tsize_t reserved = LL_RESERVED_SPACE(dev);\n\t\tint tlen = dev->needed_tailroom;\n\t\tunsigned int hhlen = dev->header_ops ? dev->hard_header_len : 0;\n\n\t\trcu_read_unlock();\n\t\tskb = sock_wmalloc(sk, len + reserved + tlen, 0, GFP_KERNEL);\n\t\tif (skb == NULL)\n\t\t\treturn -ENOBUFS;\n\t\t/* FIXME: Save some space for broken drivers that write a hard\n\t\t * header at transmission time by themselves. PPP is the notable\n\t\t * one here. This should really be fixed at the driver level.\n\t\t */\n\t\tskb_reserve(skb, reserved);\n\t\tskb_reset_network_header(skb);\n\n\t\t/* Try to align data part correctly */\n\t\tif (hhlen) {\n\t\t\tskb->data -= hhlen;\n\t\t\tskb->tail -= hhlen;\n\t\t\tif (len < hhlen)\n\t\t\t\tskb_reset_network_header(skb);\n\t\t}\n\t\terr = memcpy_from_msg(skb_put(skb, len), msg, len);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tgoto retry;\n\t}\n\n\tif (!dev_validate_header(dev, skb->data, len)) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tif (len > (dev->mtu + dev->hard_header_len + extra_len) &&\n\t    !packet_extra_vlan_len_allowed(dev, skb)) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out_unlock;\n\t}\n\n\tsockcm_init(&sockc, sk);\n\tif (msg->msg_controllen) {\n\t\terr = sock_cmsg_send(sk, msg, &sockc);\n\t\tif (unlikely(err))\n\t\t\tgoto out_unlock;\n\t}\n\n\tskb->protocol = proto;\n\tskb->dev = dev;\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\tskb->tstamp = sockc.transmit_time;\n\n\tskb_setup_tx_timestamp(skb, sockc.tsflags);\n\n\tif (unlikely(extra_len == 4))\n\t\tskb->no_fcs = 1;\n\n\tpacket_parse_headers(skb, sock);\n\n\tdev_queue_xmit(skb);\n\trcu_read_unlock();\n\treturn len;\n\nout_unlock:\n\trcu_read_unlock();\nout_free:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic unsigned int run_filter(struct sk_buff *skb,\n\t\t\t       const struct sock *sk,\n\t\t\t       unsigned int res)\n{\n\tstruct sk_filter *filter;\n\n\trcu_read_lock();\n\tfilter = rcu_dereference(sk->sk_filter);\n\tif (filter != NULL)\n\t\tres = bpf_prog_run_clear_cb(filter->prog, skb);\n\trcu_read_unlock();\n\n\treturn res;\n}\n\nstatic int packet_rcv_vnet(struct msghdr *msg, const struct sk_buff *skb,\n\t\t\t   size_t *len)\n{\n\tstruct virtio_net_hdr vnet_hdr;\n\n\tif (*len < sizeof(vnet_hdr))\n\t\treturn -EINVAL;\n\t*len -= sizeof(vnet_hdr);\n\n\tif (virtio_net_hdr_from_skb(skb, &vnet_hdr, vio_le(), true, 0))\n\t\treturn -EINVAL;\n\n\treturn memcpy_to_msg(msg, (void *)&vnet_hdr, sizeof(vnet_hdr));\n}\n\n/*\n * This function makes lazy skb cloning in hope that most of packets\n * are discarded by BPF.\n *\n * Note tricky part: we DO mangle shared skb! skb->data, skb->len\n * and skb->cb are mangled. It works because (and until) packets\n * falling here are owned by current CPU. Output packets are cloned\n * by dev_queue_xmit_nit(), input packets are processed by net_bh\n * sequencially, so that if we return skb to original state on exit,\n * we will not harm anyone.\n */\n\nstatic int packet_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t      struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct sock *sk;\n\tstruct sockaddr_ll *sll;\n\tstruct packet_sock *po;\n\tu8 *skb_head = skb->data;\n\tint skb_len = skb->len;\n\tunsigned int snaplen, res;\n\tbool is_drop_n_account = false;\n\n\tif (skb->pkt_type == PACKET_LOOPBACK)\n\t\tgoto drop;\n\n\tsk = pt->af_packet_priv;\n\tpo = pkt_sk(sk);\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\tgoto drop;\n\n\tskb->dev = dev;\n\n\tif (dev_has_header(dev)) {\n\t\t/* The device has an explicit notion of ll header,\n\t\t * exported to higher levels.\n\t\t *\n\t\t * Otherwise, the device hides details of its frame\n\t\t * structure, so that corresponding packet head is\n\t\t * never delivered to user.\n\t\t */\n\t\tif (sk->sk_type != SOCK_DGRAM)\n\t\t\tskb_push(skb, skb->data - skb_mac_header(skb));\n\t\telse if (skb->pkt_type == PACKET_OUTGOING) {\n\t\t\t/* Special case: outgoing packets have ll header at head */\n\t\t\tskb_pull(skb, skb_network_offset(skb));\n\t\t}\n\t}\n\n\tsnaplen = skb->len;\n\n\tres = run_filter(skb, sk, snaplen);\n\tif (!res)\n\t\tgoto drop_n_restore;\n\tif (snaplen > res)\n\t\tsnaplen = res;\n\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\tgoto drop_n_acct;\n\n\tif (skb_shared(skb)) {\n\t\tstruct sk_buff *nskb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (nskb == NULL)\n\t\t\tgoto drop_n_acct;\n\n\t\tif (skb_head != skb->data) {\n\t\t\tskb->data = skb_head;\n\t\t\tskb->len = skb_len;\n\t\t}\n\t\tconsume_skb(skb);\n\t\tskb = nskb;\n\t}\n\n\tsock_skb_cb_check_size(sizeof(*PACKET_SKB_CB(skb)) + MAX_ADDR_LEN - 8);\n\n\tsll = &PACKET_SKB_CB(skb)->sa.ll;\n\tsll->sll_hatype = dev->type;\n\tsll->sll_pkttype = skb->pkt_type;\n\tif (unlikely(po->origdev))\n\t\tsll->sll_ifindex = orig_dev->ifindex;\n\telse\n\t\tsll->sll_ifindex = dev->ifindex;\n\n\tsll->sll_halen = dev_parse_header(skb, sll->sll_addr);\n\n\t/* sll->sll_family and sll->sll_protocol are set in packet_recvmsg().\n\t * Use their space for storing the original skb length.\n\t */\n\tPACKET_SKB_CB(skb)->sa.origlen = skb->len;\n\n\tif (pskb_trim(skb, snaplen))\n\t\tgoto drop_n_acct;\n\n\tskb_set_owner_r(skb, sk);\n\tskb->dev = NULL;\n\tskb_dst_drop(skb);\n\n\t/* drop conntrack reference */\n\tnf_reset_ct(skb);\n\n\tspin_lock(&sk->sk_receive_queue.lock);\n\tpo->stats.stats1.tp_packets++;\n\tsock_skb_set_dropcount(sk, skb);\n\t__skb_queue_tail(&sk->sk_receive_queue, skb);\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\tsk->sk_data_ready(sk);\n\treturn 0;\n\ndrop_n_acct:\n\tis_drop_n_account = true;\n\tatomic_inc(&po->tp_drops);\n\tatomic_inc(&sk->sk_drops);\n\ndrop_n_restore:\n\tif (skb_head != skb->data && skb_shared(skb)) {\n\t\tskb->data = skb_head;\n\t\tskb->len = skb_len;\n\t}\ndrop:\n\tif (!is_drop_n_account)\n\t\tconsume_skb(skb);\n\telse\n\t\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t       struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct sock *sk;\n\tstruct packet_sock *po;\n\tstruct sockaddr_ll *sll;\n\tunion tpacket_uhdr h;\n\tu8 *skb_head = skb->data;\n\tint skb_len = skb->len;\n\tunsigned int snaplen, res;\n\tunsigned long status = TP_STATUS_USER;\n\tunsigned short macoff, hdrlen;\n\tunsigned int netoff;\n\tstruct sk_buff *copy_skb = NULL;\n\tstruct timespec64 ts;\n\t__u32 ts_status;\n\tbool is_drop_n_account = false;\n\tunsigned int slot_id = 0;\n\tbool do_vnet = false;\n\n\t/* struct tpacket{2,3}_hdr is aligned to a multiple of TPACKET_ALIGNMENT.\n\t * We may add members to them until current aligned size without forcing\n\t * userspace to call getsockopt(..., PACKET_HDRLEN, ...).\n\t */\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);\n\n\tif (skb->pkt_type == PACKET_LOOPBACK)\n\t\tgoto drop;\n\n\tsk = pt->af_packet_priv;\n\tpo = pkt_sk(sk);\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\tgoto drop;\n\n\tif (dev_has_header(dev)) {\n\t\tif (sk->sk_type != SOCK_DGRAM)\n\t\t\tskb_push(skb, skb->data - skb_mac_header(skb));\n\t\telse if (skb->pkt_type == PACKET_OUTGOING) {\n\t\t\t/* Special case: outgoing packets have ll header at head */\n\t\t\tskb_pull(skb, skb_network_offset(skb));\n\t\t}\n\t}\n\n\tsnaplen = skb->len;\n\n\tres = run_filter(skb, sk, snaplen);\n\tif (!res)\n\t\tgoto drop_n_restore;\n\n\t/* If we are flooded, just give up */\n\tif (__packet_rcv_has_room(po, skb) == ROOM_NONE) {\n\t\tatomic_inc(&po->tp_drops);\n\t\tgoto drop_n_restore;\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tstatus |= TP_STATUS_CSUMNOTREADY;\n\telse if (skb->pkt_type != PACKET_OUTGOING &&\n\t\t (skb->ip_summed == CHECKSUM_COMPLETE ||\n\t\t  skb_csum_unnecessary(skb)))\n\t\tstatus |= TP_STATUS_CSUM_VALID;\n\n\tif (snaplen > res)\n\t\tsnaplen = res;\n\n\tif (sk->sk_type == SOCK_DGRAM) {\n\t\tmacoff = netoff = TPACKET_ALIGN(po->tp_hdrlen) + 16 +\n\t\t\t\t  po->tp_reserve;\n\t} else {\n\t\tunsigned int maclen = skb_network_offset(skb);\n\t\tnetoff = TPACKET_ALIGN(po->tp_hdrlen +\n\t\t\t\t       (maclen < 16 ? 16 : maclen)) +\n\t\t\t\t       po->tp_reserve;\n\t\tif (po->has_vnet_hdr) {\n\t\t\tnetoff += sizeof(struct virtio_net_hdr);\n\t\t\tdo_vnet = true;\n\t\t}\n\t\tmacoff = netoff - maclen;\n\t}\n\tif (netoff > USHRT_MAX) {\n\t\tatomic_inc(&po->tp_drops);\n\t\tgoto drop_n_restore;\n\t}\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tif (macoff + snaplen > po->rx_ring.frame_size) {\n\t\t\tif (po->copy_thresh &&\n\t\t\t    atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf) {\n\t\t\t\tif (skb_shared(skb)) {\n\t\t\t\t\tcopy_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\t} else {\n\t\t\t\t\tcopy_skb = skb_get(skb);\n\t\t\t\t\tskb_head = skb->data;\n\t\t\t\t}\n\t\t\t\tif (copy_skb)\n\t\t\t\t\tskb_set_owner_r(copy_skb, sk);\n\t\t\t}\n\t\t\tsnaplen = po->rx_ring.frame_size - macoff;\n\t\t\tif ((int)snaplen < 0) {\n\t\t\t\tsnaplen = 0;\n\t\t\t\tdo_vnet = false;\n\t\t\t}\n\t\t}\n\t} else if (unlikely(macoff + snaplen >\n\t\t\t    GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len)) {\n\t\tu32 nval;\n\n\t\tnval = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len - macoff;\n\t\tpr_err_once(\"tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\\n\",\n\t\t\t    snaplen, nval, macoff);\n\t\tsnaplen = nval;\n\t\tif (unlikely((int)snaplen < 0)) {\n\t\t\tsnaplen = 0;\n\t\t\tmacoff = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len;\n\t\t\tdo_vnet = false;\n\t\t}\n\t}\n\tspin_lock(&sk->sk_receive_queue.lock);\n\th.raw = packet_current_rx_frame(po, skb,\n\t\t\t\t\tTP_STATUS_KERNEL, (macoff+snaplen));\n\tif (!h.raw)\n\t\tgoto drop_n_account;\n\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tslot_id = po->rx_ring.head;\n\t\tif (test_bit(slot_id, po->rx_ring.rx_owner_map))\n\t\t\tgoto drop_n_account;\n\t\t__set_bit(slot_id, po->rx_ring.rx_owner_map);\n\t}\n\n\tif (do_vnet &&\n\t    virtio_net_hdr_from_skb(skb, h.raw + macoff -\n\t\t\t\t    sizeof(struct virtio_net_hdr),\n\t\t\t\t    vio_le(), true, 0)) {\n\t\tif (po->tp_version == TPACKET_V3)\n\t\t\tprb_clear_blk_fill_status(&po->rx_ring);\n\t\tgoto drop_n_account;\n\t}\n\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tpacket_increment_rx_head(po, &po->rx_ring);\n\t/*\n\t * LOSING will be reported till you read the stats,\n\t * because it's COR - Clear On Read.\n\t * Anyways, moving it for V1/V2 only as V3 doesn't need this\n\t * at packet level.\n\t */\n\t\tif (atomic_read(&po->tp_drops))\n\t\t\tstatus |= TP_STATUS_LOSING;\n\t}\n\n\tpo->stats.stats1.tp_packets++;\n\tif (copy_skb) {\n\t\tstatus |= TP_STATUS_COPY;\n\t\t__skb_queue_tail(&sk->sk_receive_queue, copy_skb);\n\t}\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\n\tskb_copy_bits(skb, 0, h.raw + macoff, snaplen);\n\n\tif (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))\n\t\tktime_get_real_ts64(&ts);\n\n\tstatus |= ts_status;\n\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\t\th.h1->tp_len = skb->len;\n\t\th.h1->tp_snaplen = snaplen;\n\t\th.h1->tp_mac = macoff;\n\t\th.h1->tp_net = netoff;\n\t\th.h1->tp_sec = ts.tv_sec;\n\t\th.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;\n\t\thdrlen = sizeof(*h.h1);\n\t\tbreak;\n\tcase TPACKET_V2:\n\t\th.h2->tp_len = skb->len;\n\t\th.h2->tp_snaplen = snaplen;\n\t\th.h2->tp_mac = macoff;\n\t\th.h2->tp_net = netoff;\n\t\th.h2->tp_sec = ts.tv_sec;\n\t\th.h2->tp_nsec = ts.tv_nsec;\n\t\tif (skb_vlan_tag_present(skb)) {\n\t\t\th.h2->tp_vlan_tci = skb_vlan_tag_get(skb);\n\t\t\th.h2->tp_vlan_tpid = ntohs(skb->vlan_proto);\n\t\t\tstatus |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;\n\t\t} else {\n\t\t\th.h2->tp_vlan_tci = 0;\n\t\t\th.h2->tp_vlan_tpid = 0;\n\t\t}\n\t\tmemset(h.h2->tp_padding, 0, sizeof(h.h2->tp_padding));\n\t\thdrlen = sizeof(*h.h2);\n\t\tbreak;\n\tcase TPACKET_V3:\n\t\t/* tp_nxt_offset,vlan are already populated above.\n\t\t * So DONT clear those fields here\n\t\t */\n\t\th.h3->tp_status |= status;\n\t\th.h3->tp_len = skb->len;\n\t\th.h3->tp_snaplen = snaplen;\n\t\th.h3->tp_mac = macoff;\n\t\th.h3->tp_net = netoff;\n\t\th.h3->tp_sec  = ts.tv_sec;\n\t\th.h3->tp_nsec = ts.tv_nsec;\n\t\tmemset(h.h3->tp_padding, 0, sizeof(h.h3->tp_padding));\n\t\thdrlen = sizeof(*h.h3);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsll = h.raw + TPACKET_ALIGN(hdrlen);\n\tsll->sll_halen = dev_parse_header(skb, sll->sll_addr);\n\tsll->sll_family = AF_PACKET;\n\tsll->sll_hatype = dev->type;\n\tsll->sll_protocol = skb->protocol;\n\tsll->sll_pkttype = skb->pkt_type;\n\tif (unlikely(po->origdev))\n\t\tsll->sll_ifindex = orig_dev->ifindex;\n\telse\n\t\tsll->sll_ifindex = dev->ifindex;\n\n\tsmp_mb();\n\n#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tu8 *start, *end;\n\n\t\tend = (u8 *) PAGE_ALIGN((unsigned long) h.raw +\n\t\t\t\t\tmacoff + snaplen);\n\n\t\tfor (start = h.raw; start < end; start += PAGE_SIZE)\n\t\t\tflush_dcache_page(pgv_to_page(start));\n\t}\n\tsmp_wmb();\n#endif\n\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tspin_lock(&sk->sk_receive_queue.lock);\n\t\t__packet_set_status(po, h.raw, status);\n\t\t__clear_bit(slot_id, po->rx_ring.rx_owner_map);\n\t\tspin_unlock(&sk->sk_receive_queue.lock);\n\t\tsk->sk_data_ready(sk);\n\t} else if (po->tp_version == TPACKET_V3) {\n\t\tprb_clear_blk_fill_status(&po->rx_ring);\n\t}\n\ndrop_n_restore:\n\tif (skb_head != skb->data && skb_shared(skb)) {\n\t\tskb->data = skb_head;\n\t\tskb->len = skb_len;\n\t}\ndrop:\n\tif (!is_drop_n_account)\n\t\tconsume_skb(skb);\n\telse\n\t\tkfree_skb(skb);\n\treturn 0;\n\ndrop_n_account:\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\tatomic_inc(&po->tp_drops);\n\tis_drop_n_account = true;\n\n\tsk->sk_data_ready(sk);\n\tkfree_skb(copy_skb);\n\tgoto drop_n_restore;\n}\n\nstatic void tpacket_destruct_skb(struct sk_buff *skb)\n{\n\tstruct packet_sock *po = pkt_sk(skb->sk);\n\n\tif (likely(po->tx_ring.pg_vec)) {\n\t\tvoid *ph;\n\t\t__u32 ts;\n\n\t\tph = skb_zcopy_get_nouarg(skb);\n\t\tpacket_dec_pending(&po->tx_ring);\n\n\t\tts = __packet_set_timestamp(po, ph, skb);\n\t\t__packet_set_status(po, ph, TP_STATUS_AVAILABLE | ts);\n\n\t\tif (!packet_read_pending(&po->tx_ring))\n\t\t\tcomplete(&po->skb_completion);\n\t}\n\n\tsock_wfree(skb);\n}\n\nstatic int __packet_snd_vnet_parse(struct virtio_net_hdr *vnet_hdr, size_t len)\n{\n\tif ((vnet_hdr->flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) &&\n\t    (__virtio16_to_cpu(vio_le(), vnet_hdr->csum_start) +\n\t     __virtio16_to_cpu(vio_le(), vnet_hdr->csum_offset) + 2 >\n\t      __virtio16_to_cpu(vio_le(), vnet_hdr->hdr_len)))\n\t\tvnet_hdr->hdr_len = __cpu_to_virtio16(vio_le(),\n\t\t\t __virtio16_to_cpu(vio_le(), vnet_hdr->csum_start) +\n\t\t\t__virtio16_to_cpu(vio_le(), vnet_hdr->csum_offset) + 2);\n\n\tif (__virtio16_to_cpu(vio_le(), vnet_hdr->hdr_len) > len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int packet_snd_vnet_parse(struct msghdr *msg, size_t *len,\n\t\t\t\t struct virtio_net_hdr *vnet_hdr)\n{\n\tif (*len < sizeof(*vnet_hdr))\n\t\treturn -EINVAL;\n\t*len -= sizeof(*vnet_hdr);\n\n\tif (!copy_from_iter_full(vnet_hdr, sizeof(*vnet_hdr), &msg->msg_iter))\n\t\treturn -EFAULT;\n\n\treturn __packet_snd_vnet_parse(vnet_hdr, *len);\n}\n\nstatic int tpacket_fill_skb(struct packet_sock *po, struct sk_buff *skb,\n\t\tvoid *frame, struct net_device *dev, void *data, int tp_len,\n\t\t__be16 proto, unsigned char *addr, int hlen, int copylen,\n\t\tconst struct sockcm_cookie *sockc)\n{\n\tunion tpacket_uhdr ph;\n\tint to_write, offset, len, nr_frags, len_max;\n\tstruct socket *sock = po->sk.sk_socket;\n\tstruct page *page;\n\tint err;\n\n\tph.raw = frame;\n\n\tskb->protocol = proto;\n\tskb->dev = dev;\n\tskb->priority = po->sk.sk_priority;\n\tskb->mark = po->sk.sk_mark;\n\tskb->tstamp = sockc->transmit_time;\n\tskb_setup_tx_timestamp(skb, sockc->tsflags);\n\tskb_zcopy_set_nouarg(skb, ph.raw);\n\n\tskb_reserve(skb, hlen);\n\tskb_reset_network_header(skb);\n\n\tto_write = tp_len;\n\n\tif (sock->type == SOCK_DGRAM) {\n\t\terr = dev_hard_header(skb, dev, ntohs(proto), addr,\n\t\t\t\tNULL, tp_len);\n\t\tif (unlikely(err < 0))\n\t\t\treturn -EINVAL;\n\t} else if (copylen) {\n\t\tint hdrlen = min_t(int, copylen, tp_len);\n\n\t\tskb_push(skb, dev->hard_header_len);\n\t\tskb_put(skb, copylen - dev->hard_header_len);\n\t\terr = skb_store_bits(skb, 0, data, hdrlen);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t\tif (!dev_validate_header(dev, skb->data, hdrlen))\n\t\t\treturn -EINVAL;\n\n\t\tdata += hdrlen;\n\t\tto_write -= hdrlen;\n\t}\n\n\toffset = offset_in_page(data);\n\tlen_max = PAGE_SIZE - offset;\n\tlen = ((to_write > len_max) ? len_max : to_write);\n\n\tskb->data_len = to_write;\n\tskb->len += to_write;\n\tskb->truesize += to_write;\n\trefcount_add(to_write, &po->sk.sk_wmem_alloc);\n\n\twhile (likely(to_write)) {\n\t\tnr_frags = skb_shinfo(skb)->nr_frags;\n\n\t\tif (unlikely(nr_frags >= MAX_SKB_FRAGS)) {\n\t\t\tpr_err(\"Packet exceed the number of skb frags(%lu)\\n\",\n\t\t\t       MAX_SKB_FRAGS);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tpage = pgv_to_page(data);\n\t\tdata += len;\n\t\tflush_dcache_page(page);\n\t\tget_page(page);\n\t\tskb_fill_page_desc(skb, nr_frags, page, offset, len);\n\t\tto_write -= len;\n\t\toffset = 0;\n\t\tlen_max = PAGE_SIZE;\n\t\tlen = ((to_write > len_max) ? len_max : to_write);\n\t}\n\n\tpacket_parse_headers(skb, sock);\n\n\treturn tp_len;\n}\n\nstatic int tpacket_parse_header(struct packet_sock *po, void *frame,\n\t\t\t\tint size_max, void **data)\n{\n\tunion tpacket_uhdr ph;\n\tint tp_len, off;\n\n\tph.raw = frame;\n\n\tswitch (po->tp_version) {\n\tcase TPACKET_V3:\n\t\tif (ph.h3->tp_next_offset != 0) {\n\t\t\tpr_warn_once(\"variable sized slot not supported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttp_len = ph.h3->tp_len;\n\t\tbreak;\n\tcase TPACKET_V2:\n\t\ttp_len = ph.h2->tp_len;\n\t\tbreak;\n\tdefault:\n\t\ttp_len = ph.h1->tp_len;\n\t\tbreak;\n\t}\n\tif (unlikely(tp_len > size_max)) {\n\t\tpr_err(\"packet size is too long (%d > %d)\\n\", tp_len, size_max);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (unlikely(po->tp_tx_has_off)) {\n\t\tint off_min, off_max;\n\n\t\toff_min = po->tp_hdrlen - sizeof(struct sockaddr_ll);\n\t\toff_max = po->tx_ring.frame_size - tp_len;\n\t\tif (po->sk.sk_type == SOCK_DGRAM) {\n\t\t\tswitch (po->tp_version) {\n\t\t\tcase TPACKET_V3:\n\t\t\t\toff = ph.h3->tp_net;\n\t\t\t\tbreak;\n\t\t\tcase TPACKET_V2:\n\t\t\t\toff = ph.h2->tp_net;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toff = ph.h1->tp_net;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (po->tp_version) {\n\t\t\tcase TPACKET_V3:\n\t\t\t\toff = ph.h3->tp_mac;\n\t\t\t\tbreak;\n\t\t\tcase TPACKET_V2:\n\t\t\t\toff = ph.h2->tp_mac;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toff = ph.h1->tp_mac;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (unlikely((off < off_min) || (off_max < off)))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\toff = po->tp_hdrlen - sizeof(struct sockaddr_ll);\n\t}\n\n\t*data = frame + off;\n\treturn tp_len;\n}\n\nstatic int tpacket_snd(struct packet_sock *po, struct msghdr *msg)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct net_device *dev;\n\tstruct virtio_net_hdr *vnet_hdr = NULL;\n\tstruct sockcm_cookie sockc;\n\t__be16 proto;\n\tint err, reserve = 0;\n\tvoid *ph;\n\tDECLARE_SOCKADDR(struct sockaddr_ll *, saddr, msg->msg_name);\n\tbool need_wait = !(msg->msg_flags & MSG_DONTWAIT);\n\tunsigned char *addr = NULL;\n\tint tp_len, size_max;\n\tvoid *data;\n\tint len_sum = 0;\n\tint status = TP_STATUS_AVAILABLE;\n\tint hlen, tlen, copylen = 0;\n\tlong timeo = 0;\n\n\tmutex_lock(&po->pg_vec_lock);\n\n\t/* packet_sendmsg() check on tx_ring.pg_vec was lockless,\n\t * we need to confirm it under protection of pg_vec_lock.\n\t */\n\tif (unlikely(!po->tx_ring.pg_vec)) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (likely(saddr == NULL)) {\n\t\tdev\t= packet_cached_dev_get(po);\n\t\tproto\t= po->num;\n\t} else {\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(struct sockaddr_ll))\n\t\t\tgoto out;\n\t\tif (msg->msg_namelen < (saddr->sll_halen\n\t\t\t\t\t+ offsetof(struct sockaddr_ll,\n\t\t\t\t\t\tsll_addr)))\n\t\t\tgoto out;\n\t\tproto\t= saddr->sll_protocol;\n\t\tdev = dev_get_by_index(sock_net(&po->sk), saddr->sll_ifindex);\n\t\tif (po->sk.sk_socket->type == SOCK_DGRAM) {\n\t\t\tif (dev && msg->msg_namelen < dev->addr_len +\n\t\t\t\t   offsetof(struct sockaddr_ll, sll_addr))\n\t\t\t\tgoto out_put;\n\t\t\taddr = saddr->sll_addr;\n\t\t}\n\t}\n\n\terr = -ENXIO;\n\tif (unlikely(dev == NULL))\n\t\tgoto out;\n\terr = -ENETDOWN;\n\tif (unlikely(!(dev->flags & IFF_UP)))\n\t\tgoto out_put;\n\n\tsockcm_init(&sockc, &po->sk);\n\tif (msg->msg_controllen) {\n\t\terr = sock_cmsg_send(&po->sk, msg, &sockc);\n\t\tif (unlikely(err))\n\t\t\tgoto out_put;\n\t}\n\n\tif (po->sk.sk_socket->type == SOCK_RAW)\n\t\treserve = dev->hard_header_len;\n\tsize_max = po->tx_ring.frame_size\n\t\t- (po->tp_hdrlen - sizeof(struct sockaddr_ll));\n\n\tif ((size_max > dev->mtu + reserve + VLAN_HLEN) && !po->has_vnet_hdr)\n\t\tsize_max = dev->mtu + reserve + VLAN_HLEN;\n\n\treinit_completion(&po->skb_completion);\n\n\tdo {\n\t\tph = packet_current_frame(po, &po->tx_ring,\n\t\t\t\t\t  TP_STATUS_SEND_REQUEST);\n\t\tif (unlikely(ph == NULL)) {\n\t\t\tif (need_wait && skb) {\n\t\t\t\ttimeo = sock_sndtimeo(&po->sk, msg->msg_flags & MSG_DONTWAIT);\n\t\t\t\ttimeo = wait_for_completion_interruptible_timeout(&po->skb_completion, timeo);\n\t\t\t\tif (timeo <= 0) {\n\t\t\t\t\terr = !timeo ? -ETIMEDOUT : -ERESTARTSYS;\n\t\t\t\t\tgoto out_put;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* check for additional frames */\n\t\t\tcontinue;\n\t\t}\n\n\t\tskb = NULL;\n\t\ttp_len = tpacket_parse_header(po, ph, size_max, &data);\n\t\tif (tp_len < 0)\n\t\t\tgoto tpacket_error;\n\n\t\tstatus = TP_STATUS_SEND_REQUEST;\n\t\thlen = LL_RESERVED_SPACE(dev);\n\t\ttlen = dev->needed_tailroom;\n\t\tif (po->has_vnet_hdr) {\n\t\t\tvnet_hdr = data;\n\t\t\tdata += sizeof(*vnet_hdr);\n\t\t\ttp_len -= sizeof(*vnet_hdr);\n\t\t\tif (tp_len < 0 ||\n\t\t\t    __packet_snd_vnet_parse(vnet_hdr, tp_len)) {\n\t\t\t\ttp_len = -EINVAL;\n\t\t\t\tgoto tpacket_error;\n\t\t\t}\n\t\t\tcopylen = __virtio16_to_cpu(vio_le(),\n\t\t\t\t\t\t    vnet_hdr->hdr_len);\n\t\t}\n\t\tcopylen = max_t(int, copylen, dev->hard_header_len);\n\t\tskb = sock_alloc_send_skb(&po->sk,\n\t\t\t\thlen + tlen + sizeof(struct sockaddr_ll) +\n\t\t\t\t(copylen - dev->hard_header_len),\n\t\t\t\t!need_wait, &err);\n\n\t\tif (unlikely(skb == NULL)) {\n\t\t\t/* we assume the socket was initially writeable ... */\n\t\t\tif (likely(len_sum > 0))\n\t\t\t\terr = len_sum;\n\t\t\tgoto out_status;\n\t\t}\n\t\ttp_len = tpacket_fill_skb(po, skb, ph, dev, data, tp_len, proto,\n\t\t\t\t\t  addr, hlen, copylen, &sockc);\n\t\tif (likely(tp_len >= 0) &&\n\t\t    tp_len > dev->mtu + reserve &&\n\t\t    !po->has_vnet_hdr &&\n\t\t    !packet_extra_vlan_len_allowed(dev, skb))\n\t\t\ttp_len = -EMSGSIZE;\n\n\t\tif (unlikely(tp_len < 0)) {\ntpacket_error:\n\t\t\tif (po->tp_loss) {\n\t\t\t\t__packet_set_status(po, ph,\n\t\t\t\t\t\tTP_STATUS_AVAILABLE);\n\t\t\t\tpacket_increment_head(&po->tx_ring);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tstatus = TP_STATUS_WRONG_FORMAT;\n\t\t\t\terr = tp_len;\n\t\t\t\tgoto out_status;\n\t\t\t}\n\t\t}\n\n\t\tif (po->has_vnet_hdr) {\n\t\t\tif (virtio_net_hdr_to_skb(skb, vnet_hdr, vio_le())) {\n\t\t\t\ttp_len = -EINVAL;\n\t\t\t\tgoto tpacket_error;\n\t\t\t}\n\t\t\tvirtio_net_hdr_set_proto(skb, vnet_hdr);\n\t\t}\n\n\t\tskb->destructor = tpacket_destruct_skb;\n\t\t__packet_set_status(po, ph, TP_STATUS_SENDING);\n\t\tpacket_inc_pending(&po->tx_ring);\n\n\t\tstatus = TP_STATUS_SEND_REQUEST;\n\t\terr = po->xmit(skb);\n\t\tif (unlikely(err > 0)) {\n\t\t\terr = net_xmit_errno(err);\n\t\t\tif (err && __packet_get_status(po, ph) ==\n\t\t\t\t   TP_STATUS_AVAILABLE) {\n\t\t\t\t/* skb was destructed already */\n\t\t\t\tskb = NULL;\n\t\t\t\tgoto out_status;\n\t\t\t}\n\t\t\t/*\n\t\t\t * skb was dropped but not destructed yet;\n\t\t\t * let's treat it like congestion or err < 0\n\t\t\t */\n\t\t\terr = 0;\n\t\t}\n\t\tpacket_increment_head(&po->tx_ring);\n\t\tlen_sum += tp_len;\n\t} while (likely((ph != NULL) ||\n\t\t/* Note: packet_read_pending() might be slow if we have\n\t\t * to call it as it's per_cpu variable, but in fast-path\n\t\t * we already short-circuit the loop with the first\n\t\t * condition, and luckily don't have to go that path\n\t\t * anyway.\n\t\t */\n\t\t (need_wait && packet_read_pending(&po->tx_ring))));\n\n\terr = len_sum;\n\tgoto out_put;\n\nout_status:\n\t__packet_set_status(po, ph, status);\n\tkfree_skb(skb);\nout_put:\n\tdev_put(dev);\nout:\n\tmutex_unlock(&po->pg_vec_lock);\n\treturn err;\n}\n\nstatic struct sk_buff *packet_alloc_skb(struct sock *sk, size_t prepad,\n\t\t\t\t        size_t reserve, size_t len,\n\t\t\t\t        size_t linear, int noblock,\n\t\t\t\t        int *err)\n{\n\tstruct sk_buff *skb;\n\n\t/* Under a page?  Don't bother with paged skb. */\n\tif (prepad + len < PAGE_SIZE || !linear)\n\t\tlinear = len;\n\n\tskb = sock_alloc_send_pskb(sk, prepad + linear, len - linear, noblock,\n\t\t\t\t   err, 0);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, reserve);\n\tskb_put(skb, linear);\n\tskb->data_len = len - linear;\n\tskb->len += len - linear;\n\n\treturn skb;\n}\n\nstatic int packet_snd(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tDECLARE_SOCKADDR(struct sockaddr_ll *, saddr, msg->msg_name);\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\t__be16 proto;\n\tunsigned char *addr = NULL;\n\tint err, reserve = 0;\n\tstruct sockcm_cookie sockc;\n\tstruct virtio_net_hdr vnet_hdr = { 0 };\n\tint offset = 0;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tbool has_vnet_hdr = false;\n\tint hlen, tlen, linear;\n\tint extra_len = 0;\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\n\tif (likely(saddr == NULL)) {\n\t\tdev\t= packet_cached_dev_get(po);\n\t\tproto\t= po->num;\n\t} else {\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(struct sockaddr_ll))\n\t\t\tgoto out;\n\t\tif (msg->msg_namelen < (saddr->sll_halen + offsetof(struct sockaddr_ll, sll_addr)))\n\t\t\tgoto out;\n\t\tproto\t= saddr->sll_protocol;\n\t\tdev = dev_get_by_index(sock_net(sk), saddr->sll_ifindex);\n\t\tif (sock->type == SOCK_DGRAM) {\n\t\t\tif (dev && msg->msg_namelen < dev->addr_len +\n\t\t\t\t   offsetof(struct sockaddr_ll, sll_addr))\n\t\t\t\tgoto out_unlock;\n\t\t\taddr = saddr->sll_addr;\n\t\t}\n\t}\n\n\terr = -ENXIO;\n\tif (unlikely(dev == NULL))\n\t\tgoto out_unlock;\n\terr = -ENETDOWN;\n\tif (unlikely(!(dev->flags & IFF_UP)))\n\t\tgoto out_unlock;\n\n\tsockcm_init(&sockc, sk);\n\tsockc.mark = sk->sk_mark;\n\tif (msg->msg_controllen) {\n\t\terr = sock_cmsg_send(sk, msg, &sockc);\n\t\tif (unlikely(err))\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (sock->type == SOCK_RAW)\n\t\treserve = dev->hard_header_len;\n\tif (po->has_vnet_hdr) {\n\t\terr = packet_snd_vnet_parse(msg, &len, &vnet_hdr);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t\thas_vnet_hdr = true;\n\t}\n\n\tif (unlikely(sock_flag(sk, SOCK_NOFCS))) {\n\t\tif (!netif_supports_nofcs(dev)) {\n\t\t\terr = -EPROTONOSUPPORT;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\textra_len = 4; /* We're doing our own CRC */\n\t}\n\n\terr = -EMSGSIZE;\n\tif (!vnet_hdr.gso_type &&\n\t    (len > dev->mtu + reserve + VLAN_HLEN + extra_len))\n\t\tgoto out_unlock;\n\n\terr = -ENOBUFS;\n\thlen = LL_RESERVED_SPACE(dev);\n\ttlen = dev->needed_tailroom;\n\tlinear = __virtio16_to_cpu(vio_le(), vnet_hdr.hdr_len);\n\tlinear = max(linear, min_t(int, len, dev->hard_header_len));\n\tskb = packet_alloc_skb(sk, hlen + tlen, hlen, len, linear,\n\t\t\t       msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out_unlock;\n\n\tskb_reset_network_header(skb);\n\n\terr = -EINVAL;\n\tif (sock->type == SOCK_DGRAM) {\n\t\toffset = dev_hard_header(skb, dev, ntohs(proto), addr, NULL, len);\n\t\tif (unlikely(offset < 0))\n\t\t\tgoto out_free;\n\t} else if (reserve) {\n\t\tskb_reserve(skb, -reserve);\n\t\tif (len < reserve + sizeof(struct ipv6hdr) &&\n\t\t    dev->min_header_len != dev->hard_header_len)\n\t\t\tskb_reset_network_header(skb);\n\t}\n\n\t/* Returns -EFAULT on error */\n\terr = skb_copy_datagram_from_iter(skb, offset, &msg->msg_iter, len);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (sock->type == SOCK_RAW &&\n\t    !dev_validate_header(dev, skb->data, len)) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tskb_setup_tx_timestamp(skb, sockc.tsflags);\n\n\tif (!vnet_hdr.gso_type && (len > dev->mtu + reserve + extra_len) &&\n\t    !packet_extra_vlan_len_allowed(dev, skb)) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out_free;\n\t}\n\n\tskb->protocol = proto;\n\tskb->dev = dev;\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sockc.mark;\n\tskb->tstamp = sockc.transmit_time;\n\n\tif (has_vnet_hdr) {\n\t\terr = virtio_net_hdr_to_skb(skb, &vnet_hdr, vio_le());\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tlen += sizeof(vnet_hdr);\n\t\tvirtio_net_hdr_set_proto(skb, &vnet_hdr);\n\t}\n\n\tpacket_parse_headers(skb, sock);\n\n\tif (unlikely(extra_len == 4))\n\t\tskb->no_fcs = 1;\n\n\terr = po->xmit(skb);\n\tif (err > 0 && (err = net_xmit_errno(err)) != 0)\n\t\tgoto out_unlock;\n\n\tdev_put(dev);\n\n\treturn len;\n\nout_free:\n\tkfree_skb(skb);\nout_unlock:\n\tif (dev)\n\t\tdev_put(dev);\nout:\n\treturn err;\n}\n\nstatic int packet_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\n\tif (po->tx_ring.pg_vec)\n\t\treturn tpacket_snd(po, msg);\n\telse\n\t\treturn packet_snd(sock, msg, len);\n}\n\n/*\n *\tClose a PACKET socket. This is fairly simple. We immediately go\n *\tto 'closed' state and remove our protocol entry in the device list.\n */\n\nstatic int packet_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po;\n\tstruct packet_fanout *f;\n\tstruct net *net;\n\tunion tpacket_req_u req_u;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tnet = sock_net(sk);\n\tpo = pkt_sk(sk);\n\n\tmutex_lock(&net->packet.sklist_lock);\n\tsk_del_node_init_rcu(sk);\n\tmutex_unlock(&net->packet.sklist_lock);\n\n\tpreempt_disable();\n\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\tpreempt_enable();\n\n\tspin_lock(&po->bind_lock);\n\tunregister_prot_hook(sk, false);\n\tpacket_cached_dev_reset(po);\n\n\tif (po->prot_hook.dev) {\n\t\tdev_put(po->prot_hook.dev);\n\t\tpo->prot_hook.dev = NULL;\n\t}\n\tspin_unlock(&po->bind_lock);\n\n\tpacket_flush_mclist(sk);\n\n\tlock_sock(sk);\n\tif (po->rx_ring.pg_vec) {\n\t\tmemset(&req_u, 0, sizeof(req_u));\n\t\tpacket_set_ring(sk, &req_u, 1, 0);\n\t}\n\n\tif (po->tx_ring.pg_vec) {\n\t\tmemset(&req_u, 0, sizeof(req_u));\n\t\tpacket_set_ring(sk, &req_u, 1, 1);\n\t}\n\trelease_sock(sk);\n\n\tf = fanout_release(sk);\n\n\tsynchronize_net();\n\n\tkfree(po->rollover);\n\tif (f) {\n\t\tfanout_release_data(f);\n\t\tkvfree(f);\n\t}\n\t/*\n\t *\tNow the socket is dead. No more input will appear.\n\t */\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\n\t/* Purge queues */\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tpacket_free_pending(po);\n\tsk_refcnt_debug_release(sk);\n\n\tsock_put(sk);\n\treturn 0;\n}\n\n/*\n *\tAttach a packet hook.\n */\n\nstatic int packet_do_bind(struct sock *sk, const char *name, int ifindex,\n\t\t\t  __be16 proto)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct net_device *dev_curr;\n\t__be16 proto_curr;\n\tbool need_rehook;\n\tstruct net_device *dev = NULL;\n\tint ret = 0;\n\tbool unlisted = false;\n\n\tlock_sock(sk);\n\tspin_lock(&po->bind_lock);\n\trcu_read_lock();\n\n\tif (po->fanout) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (name) {\n\t\tdev = dev_get_by_name_rcu(sock_net(sk), name);\n\t\tif (!dev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else if (ifindex) {\n\t\tdev = dev_get_by_index_rcu(sock_net(sk), ifindex);\n\t\tif (!dev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (dev)\n\t\tdev_hold(dev);\n\n\tproto_curr = po->prot_hook.type;\n\tdev_curr = po->prot_hook.dev;\n\n\tneed_rehook = proto_curr != proto || dev_curr != dev;\n\n\tif (need_rehook) {\n\t\tif (po->running) {\n\t\t\trcu_read_unlock();\n\t\t\t/* prevents packet_notifier() from calling\n\t\t\t * register_prot_hook()\n\t\t\t */\n\t\t\tpo->num = 0;\n\t\t\t__unregister_prot_hook(sk, true);\n\t\t\trcu_read_lock();\n\t\t\tdev_curr = po->prot_hook.dev;\n\t\t\tif (dev)\n\t\t\t\tunlisted = !dev_get_by_index_rcu(sock_net(sk),\n\t\t\t\t\t\t\t\t dev->ifindex);\n\t\t}\n\n\t\tBUG_ON(po->running);\n\t\tpo->num = proto;\n\t\tpo->prot_hook.type = proto;\n\n\t\tif (unlikely(unlisted)) {\n\t\t\tdev_put(dev);\n\t\t\tpo->prot_hook.dev = NULL;\n\t\t\tpo->ifindex = -1;\n\t\t\tpacket_cached_dev_reset(po);\n\t\t} else {\n\t\t\tpo->prot_hook.dev = dev;\n\t\t\tpo->ifindex = dev ? dev->ifindex : 0;\n\t\t\tpacket_cached_dev_assign(po, dev);\n\t\t}\n\t}\n\tif (dev_curr)\n\t\tdev_put(dev_curr);\n\n\tif (proto == 0 || !need_rehook)\n\t\tgoto out_unlock;\n\n\tif (!unlisted && (!dev || (dev->flags & IFF_UP))) {\n\t\tregister_prot_hook(sk);\n\t} else {\n\t\tsk->sk_err = ENETDOWN;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_error_report(sk);\n\t}\n\nout_unlock:\n\trcu_read_unlock();\n\tspin_unlock(&po->bind_lock);\n\trelease_sock(sk);\n\treturn ret;\n}\n\n/*\n *\tBind a packet socket to a device\n */\n\nstatic int packet_bind_spkt(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tchar name[sizeof(uaddr->sa_data) + 1];\n\n\t/*\n\t *\tCheck legality\n\t */\n\n\tif (addr_len != sizeof(struct sockaddr))\n\t\treturn -EINVAL;\n\t/* uaddr->sa_data comes from the userspace, it's not guaranteed to be\n\t * zero-terminated.\n\t */\n\tmemcpy(name, uaddr->sa_data, sizeof(uaddr->sa_data));\n\tname[sizeof(uaddr->sa_data)] = 0;\n\n\treturn packet_do_bind(sk, name, 0, pkt_sk(sk)->num);\n}\n\nstatic int packet_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sockaddr_ll *sll = (struct sockaddr_ll *)uaddr;\n\tstruct sock *sk = sock->sk;\n\n\t/*\n\t *\tCheck legality\n\t */\n\n\tif (addr_len < sizeof(struct sockaddr_ll))\n\t\treturn -EINVAL;\n\tif (sll->sll_family != AF_PACKET)\n\t\treturn -EINVAL;\n\n\treturn packet_do_bind(sk, NULL, sll->sll_ifindex,\n\t\t\t      sll->sll_protocol ? : pkt_sk(sk)->num);\n}\n\nstatic struct proto packet_proto = {\n\t.name\t  = \"PACKET\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct packet_sock),\n};\n\n/*\n *\tCreate a packet of type SOCK_PACKET.\n */\n\nstatic int packet_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t int kern)\n{\n\tstruct sock *sk;\n\tstruct packet_sock *po;\n\t__be16 proto = (__force __be16)protocol; /* weird, but documented */\n\tint err;\n\n\tif (!ns_capable(net->user_ns, CAP_NET_RAW))\n\t\treturn -EPERM;\n\tif (sock->type != SOCK_DGRAM && sock->type != SOCK_RAW &&\n\t    sock->type != SOCK_PACKET)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsock->state = SS_UNCONNECTED;\n\n\terr = -ENOBUFS;\n\tsk = sk_alloc(net, PF_PACKET, GFP_KERNEL, &packet_proto, kern);\n\tif (sk == NULL)\n\t\tgoto out;\n\n\tsock->ops = &packet_ops;\n\tif (sock->type == SOCK_PACKET)\n\t\tsock->ops = &packet_ops_spkt;\n\n\tsock_init_data(sock, sk);\n\n\tpo = pkt_sk(sk);\n\tinit_completion(&po->skb_completion);\n\tsk->sk_family = PF_PACKET;\n\tpo->num = proto;\n\tpo->xmit = dev_queue_xmit;\n\n\terr = packet_alloc_pending(po);\n\tif (err)\n\t\tgoto out2;\n\n\tpacket_cached_dev_reset(po);\n\n\tsk->sk_destruct = packet_sock_destruct;\n\tsk_refcnt_debug_inc(sk);\n\n\t/*\n\t *\tAttach a protocol block\n\t */\n\n\tspin_lock_init(&po->bind_lock);\n\tmutex_init(&po->pg_vec_lock);\n\tpo->rollover = NULL;\n\tpo->prot_hook.func = packet_rcv;\n\n\tif (sock->type == SOCK_PACKET)\n\t\tpo->prot_hook.func = packet_rcv_spkt;\n\n\tpo->prot_hook.af_packet_priv = sk;\n\n\tif (proto) {\n\t\tpo->prot_hook.type = proto;\n\t\t__register_prot_hook(sk);\n\t}\n\n\tmutex_lock(&net->packet.sklist_lock);\n\tsk_add_node_tail_rcu(sk, &net->packet.sklist);\n\tmutex_unlock(&net->packet.sklist_lock);\n\n\tpreempt_disable();\n\tsock_prot_inuse_add(net, &packet_proto, 1);\n\tpreempt_enable();\n\n\treturn 0;\nout2:\n\tsk_free(sk);\nout:\n\treturn err;\n}\n\n/*\n *\tPull a packet from our receive queue and hand it to the user.\n *\tIf necessary we block.\n */\n\nstatic int packet_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t  int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\tint vnet_hdr_len = 0;\n\tunsigned int origlen = 0;\n\n\terr = -EINVAL;\n\tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT|MSG_ERRQUEUE))\n\t\tgoto out;\n\n#if 0\n\t/* What error should we return now? EUNATTACH? */\n\tif (pkt_sk(sk)->ifindex < 0)\n\t\treturn -ENODEV;\n#endif\n\n\tif (flags & MSG_ERRQUEUE) {\n\t\terr = sock_recv_errqueue(sk, msg, len,\n\t\t\t\t\t SOL_PACKET, PACKET_TX_TIMESTAMP);\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tCall the generic datagram receiver. This handles all sorts\n\t *\tof horrible races and re-entrancy so we can forget about it\n\t *\tin the protocol layers.\n\t *\n\t *\tNow it will return ENETDOWN, if device have just gone down,\n\t *\tbut then it will block.\n\t */\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\n\t/*\n\t *\tAn error occurred so return it. Because skb_recv_datagram()\n\t *\thandles the blocking we don't see and worry about blocking\n\t *\tretries.\n\t */\n\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tpacket_rcv_try_clear_pressure(pkt_sk(sk));\n\n\tif (pkt_sk(sk)->has_vnet_hdr) {\n\t\terr = packet_rcv_vnet(msg, skb, &len);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tvnet_hdr_len = sizeof(struct virtio_net_hdr);\n\t}\n\n\t/* You lose any data beyond the buffer you gave. If it worries\n\t * a user program they can ask the device for its MTU\n\t * anyway.\n\t */\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tcopied = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (sock->type != SOCK_PACKET) {\n\t\tstruct sockaddr_ll *sll = &PACKET_SKB_CB(skb)->sa.ll;\n\n\t\t/* Original length was stored in sockaddr_ll fields */\n\t\toriglen = PACKET_SKB_CB(skb)->sa.origlen;\n\t\tsll->sll_family = AF_PACKET;\n\t\tsll->sll_protocol = skb->protocol;\n\t}\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (msg->msg_name) {\n\t\tint copy_len;\n\n\t\t/* If the address length field is there to be filled\n\t\t * in, we fill it in now.\n\t\t */\n\t\tif (sock->type == SOCK_PACKET) {\n\t\t\t__sockaddr_check_size(sizeof(struct sockaddr_pkt));\n\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_pkt);\n\t\t\tcopy_len = msg->msg_namelen;\n\t\t} else {\n\t\t\tstruct sockaddr_ll *sll = &PACKET_SKB_CB(skb)->sa.ll;\n\n\t\t\tmsg->msg_namelen = sll->sll_halen +\n\t\t\t\toffsetof(struct sockaddr_ll, sll_addr);\n\t\t\tcopy_len = msg->msg_namelen;\n\t\t\tif (msg->msg_namelen < sizeof(struct sockaddr_ll)) {\n\t\t\t\tmemset(msg->msg_name +\n\t\t\t\t       offsetof(struct sockaddr_ll, sll_addr),\n\t\t\t\t       0, sizeof(sll->sll_addr));\n\t\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_ll);\n\t\t\t}\n\t\t}\n\t\tmemcpy(msg->msg_name, &PACKET_SKB_CB(skb)->sa, copy_len);\n\t}\n\n\tif (pkt_sk(sk)->auxdata) {\n\t\tstruct tpacket_auxdata aux;\n\n\t\taux.tp_status = TP_STATUS_USER;\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\taux.tp_status |= TP_STATUS_CSUMNOTREADY;\n\t\telse if (skb->pkt_type != PACKET_OUTGOING &&\n\t\t\t (skb->ip_summed == CHECKSUM_COMPLETE ||\n\t\t\t  skb_csum_unnecessary(skb)))\n\t\t\taux.tp_status |= TP_STATUS_CSUM_VALID;\n\n\t\taux.tp_len = origlen;\n\t\taux.tp_snaplen = skb->len;\n\t\taux.tp_mac = 0;\n\t\taux.tp_net = skb_network_offset(skb);\n\t\tif (skb_vlan_tag_present(skb)) {\n\t\t\taux.tp_vlan_tci = skb_vlan_tag_get(skb);\n\t\t\taux.tp_vlan_tpid = ntohs(skb->vlan_proto);\n\t\t\taux.tp_status |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;\n\t\t} else {\n\t\t\taux.tp_vlan_tci = 0;\n\t\t\taux.tp_vlan_tpid = 0;\n\t\t}\n\t\tput_cmsg(msg, SOL_PACKET, PACKET_AUXDATA, sizeof(aux), &aux);\n\t}\n\n\t/*\n\t *\tFree or return the buffer as appropriate. Again this\n\t *\thides all the races and re-entrancy issues from us.\n\t */\n\terr = vnet_hdr_len + ((flags&MSG_TRUNC) ? skb->len : copied);\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n}\n\nstatic int packet_getname_spkt(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t       int peer)\n{\n\tstruct net_device *dev;\n\tstruct sock *sk\t= sock->sk;\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tuaddr->sa_family = AF_PACKET;\n\tmemset(uaddr->sa_data, 0, sizeof(uaddr->sa_data));\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(sock_net(sk), pkt_sk(sk)->ifindex);\n\tif (dev)\n\t\tstrlcpy(uaddr->sa_data, dev->name, sizeof(uaddr->sa_data));\n\trcu_read_unlock();\n\n\treturn sizeof(*uaddr);\n}\n\nstatic int packet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int peer)\n{\n\tstruct net_device *dev;\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_ll *, sll, uaddr);\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tsll->sll_family = AF_PACKET;\n\tsll->sll_ifindex = po->ifindex;\n\tsll->sll_protocol = po->num;\n\tsll->sll_pkttype = 0;\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(sock_net(sk), po->ifindex);\n\tif (dev) {\n\t\tsll->sll_hatype = dev->type;\n\t\tsll->sll_halen = dev->addr_len;\n\t\tmemcpy(sll->sll_addr, dev->dev_addr, dev->addr_len);\n\t} else {\n\t\tsll->sll_hatype = 0;\t/* Bad: we have no ARPHRD_UNSPEC */\n\t\tsll->sll_halen = 0;\n\t}\n\trcu_read_unlock();\n\n\treturn offsetof(struct sockaddr_ll, sll_addr) + sll->sll_halen;\n}\n\nstatic int packet_dev_mc(struct net_device *dev, struct packet_mclist *i,\n\t\t\t int what)\n{\n\tswitch (i->type) {\n\tcase PACKET_MR_MULTICAST:\n\t\tif (i->alen != dev->addr_len)\n\t\t\treturn -EINVAL;\n\t\tif (what > 0)\n\t\t\treturn dev_mc_add(dev, i->addr);\n\t\telse\n\t\t\treturn dev_mc_del(dev, i->addr);\n\t\tbreak;\n\tcase PACKET_MR_PROMISC:\n\t\treturn dev_set_promiscuity(dev, what);\n\tcase PACKET_MR_ALLMULTI:\n\t\treturn dev_set_allmulti(dev, what);\n\tcase PACKET_MR_UNICAST:\n\t\tif (i->alen != dev->addr_len)\n\t\t\treturn -EINVAL;\n\t\tif (what > 0)\n\t\t\treturn dev_uc_add(dev, i->addr);\n\t\telse\n\t\t\treturn dev_uc_del(dev, i->addr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void packet_dev_mclist_delete(struct net_device *dev,\n\t\t\t\t     struct packet_mclist **mlp)\n{\n\tstruct packet_mclist *ml;\n\n\twhile ((ml = *mlp) != NULL) {\n\t\tif (ml->ifindex == dev->ifindex) {\n\t\t\tpacket_dev_mc(dev, ml, -1);\n\t\t\t*mlp = ml->next;\n\t\t\tkfree(ml);\n\t\t} else\n\t\t\tmlp = &ml->next;\n\t}\n}\n\nstatic int packet_mc_add(struct sock *sk, struct packet_mreq_max *mreq)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_mclist *ml, *i;\n\tstruct net_device *dev;\n\tint err;\n\n\trtnl_lock();\n\n\terr = -ENODEV;\n\tdev = __dev_get_by_index(sock_net(sk), mreq->mr_ifindex);\n\tif (!dev)\n\t\tgoto done;\n\n\terr = -EINVAL;\n\tif (mreq->mr_alen > dev->addr_len)\n\t\tgoto done;\n\n\terr = -ENOBUFS;\n\ti = kmalloc(sizeof(*i), GFP_KERNEL);\n\tif (i == NULL)\n\t\tgoto done;\n\n\terr = 0;\n\tfor (ml = po->mclist; ml; ml = ml->next) {\n\t\tif (ml->ifindex == mreq->mr_ifindex &&\n\t\t    ml->type == mreq->mr_type &&\n\t\t    ml->alen == mreq->mr_alen &&\n\t\t    memcmp(ml->addr, mreq->mr_address, ml->alen) == 0) {\n\t\t\tml->count++;\n\t\t\t/* Free the new element ... */\n\t\t\tkfree(i);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\ti->type = mreq->mr_type;\n\ti->ifindex = mreq->mr_ifindex;\n\ti->alen = mreq->mr_alen;\n\tmemcpy(i->addr, mreq->mr_address, i->alen);\n\tmemset(i->addr + i->alen, 0, sizeof(i->addr) - i->alen);\n\ti->count = 1;\n\ti->next = po->mclist;\n\tpo->mclist = i;\n\terr = packet_dev_mc(dev, i, 1);\n\tif (err) {\n\t\tpo->mclist = i->next;\n\t\tkfree(i);\n\t}\n\ndone:\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic int packet_mc_drop(struct sock *sk, struct packet_mreq_max *mreq)\n{\n\tstruct packet_mclist *ml, **mlp;\n\n\trtnl_lock();\n\n\tfor (mlp = &pkt_sk(sk)->mclist; (ml = *mlp) != NULL; mlp = &ml->next) {\n\t\tif (ml->ifindex == mreq->mr_ifindex &&\n\t\t    ml->type == mreq->mr_type &&\n\t\t    ml->alen == mreq->mr_alen &&\n\t\t    memcmp(ml->addr, mreq->mr_address, ml->alen) == 0) {\n\t\t\tif (--ml->count == 0) {\n\t\t\t\tstruct net_device *dev;\n\t\t\t\t*mlp = ml->next;\n\t\t\t\tdev = __dev_get_by_index(sock_net(sk), ml->ifindex);\n\t\t\t\tif (dev)\n\t\t\t\t\tpacket_dev_mc(dev, ml, -1);\n\t\t\t\tkfree(ml);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\trtnl_unlock();\n\treturn 0;\n}\n\nstatic void packet_flush_mclist(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_mclist *ml;\n\n\tif (!po->mclist)\n\t\treturn;\n\n\trtnl_lock();\n\twhile ((ml = po->mclist) != NULL) {\n\t\tstruct net_device *dev;\n\n\t\tpo->mclist = ml->next;\n\t\tdev = __dev_get_by_index(sock_net(sk), ml->ifindex);\n\t\tif (dev != NULL)\n\t\t\tpacket_dev_mc(dev, ml, -1);\n\t\tkfree(ml);\n\t}\n\trtnl_unlock();\n}\n\nstatic int\npacket_setsockopt(struct socket *sock, int level, int optname, sockptr_t optval,\n\t\t  unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tint ret;\n\n\tif (level != SOL_PACKET)\n\t\treturn -ENOPROTOOPT;\n\n\tswitch (optname) {\n\tcase PACKET_ADD_MEMBERSHIP:\n\tcase PACKET_DROP_MEMBERSHIP:\n\t{\n\t\tstruct packet_mreq_max mreq;\n\t\tint len = optlen;\n\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\tif (len < sizeof(struct packet_mreq))\n\t\t\treturn -EINVAL;\n\t\tif (len > sizeof(mreq))\n\t\t\tlen = sizeof(mreq);\n\t\tif (copy_from_sockptr(&mreq, optval, len))\n\t\t\treturn -EFAULT;\n\t\tif (len < (mreq.mr_alen + offsetof(struct packet_mreq, mr_address)))\n\t\t\treturn -EINVAL;\n\t\tif (optname == PACKET_ADD_MEMBERSHIP)\n\t\t\tret = packet_mc_add(sk, &mreq);\n\t\telse\n\t\t\tret = packet_mc_drop(sk, &mreq);\n\t\treturn ret;\n\t}\n\n\tcase PACKET_RX_RING:\n\tcase PACKET_TX_RING:\n\t{\n\t\tunion tpacket_req_u req_u;\n\t\tint len;\n\n\t\tlock_sock(sk);\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V1:\n\t\tcase TPACKET_V2:\n\t\t\tlen = sizeof(req_u.req);\n\t\t\tbreak;\n\t\tcase TPACKET_V3:\n\t\tdefault:\n\t\t\tlen = sizeof(req_u.req3);\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < len) {\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tif (copy_from_sockptr(&req_u.req, optval, len))\n\t\t\t\tret = -EFAULT;\n\t\t\telse\n\t\t\t\tret = packet_set_ring(sk, &req_u, 0,\n\t\t\t\t\t\t    optname == PACKET_TX_RING);\n\t\t}\n\t\trelease_sock(sk);\n\t\treturn ret;\n\t}\n\tcase PACKET_COPY_THRESH:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpkt_sk(sk)->copy_thresh = val;\n\t\treturn 0;\n\t}\n\tcase PACKET_VERSION:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tswitch (val) {\n\t\tcase TPACKET_V1:\n\t\tcase TPACKET_V2:\n\t\tcase TPACKET_V3:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlock_sock(sk);\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec) {\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tpo->tp_version = val;\n\t\t\tret = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t\treturn ret;\n\t}\n\tcase PACKET_RESERVE:\n\t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tif (val > INT_MAX)\n\t\t\treturn -EINVAL;\n\t\tlock_sock(sk);\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec) {\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tpo->tp_reserve = val;\n\t\t\tret = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t\treturn ret;\n\t}\n\tcase PACKET_LOSS:\n\t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tlock_sock(sk);\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec) {\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tpo->tp_loss = !!val;\n\t\t\tret = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t\treturn ret;\n\t}\n\tcase PACKET_AUXDATA:\n\t{\n\t\tint val;\n\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tlock_sock(sk);\n\t\tpo->auxdata = !!val;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\tcase PACKET_ORIGDEV:\n\t{\n\t\tint val;\n\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tlock_sock(sk);\n\t\tpo->origdev = !!val;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\tcase PACKET_VNET_HDR:\n\t{\n\t\tint val;\n\n\t\tif (sock->type != SOCK_RAW)\n\t\t\treturn -EINVAL;\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tlock_sock(sk);\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec) {\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tpo->has_vnet_hdr = !!val;\n\t\t\tret = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t\treturn ret;\n\t}\n\tcase PACKET_TIMESTAMP:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->tp_tstamp = val;\n\t\treturn 0;\n\t}\n\tcase PACKET_FANOUT:\n\t{\n\t\tstruct fanout_args args = { 0 };\n\n\t\tif (optlen != sizeof(int) && optlen != sizeof(args))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&args, optval, optlen))\n\t\t\treturn -EFAULT;\n\n\t\treturn fanout_add(sk, &args);\n\t}\n\tcase PACKET_FANOUT_DATA:\n\t{\n\t\tif (!po->fanout)\n\t\t\treturn -EINVAL;\n\n\t\treturn fanout_set_data(po, optval, optlen);\n\t}\n\tcase PACKET_IGNORE_OUTGOING:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tif (val < 0 || val > 1)\n\t\t\treturn -EINVAL;\n\n\t\tpo->prot_hook.ignore_outgoing = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_TX_HAS_OFF:\n\t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tlock_sock(sk);\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec) {\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tpo->tp_tx_has_off = !!val;\n\t\t\tret = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\tcase PACKET_QDISC_BYPASS:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->xmit = val ? packet_direct_xmit : dev_queue_xmit;\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}\n\nstatic int packet_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t     char __user *optval, int __user *optlen)\n{\n\tint len;\n\tint val, lv = sizeof(val);\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tvoid *data = &val;\n\tunion tpacket_stats_u st;\n\tstruct tpacket_rollover_stats rstats;\n\tint drops;\n\n\tif (level != SOL_PACKET)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tswitch (optname) {\n\tcase PACKET_STATISTICS:\n\t\tspin_lock_bh(&sk->sk_receive_queue.lock);\n\t\tmemcpy(&st, &po->stats, sizeof(st));\n\t\tmemset(&po->stats, 0, sizeof(po->stats));\n\t\tspin_unlock_bh(&sk->sk_receive_queue.lock);\n\t\tdrops = atomic_xchg(&po->tp_drops, 0);\n\n\t\tif (po->tp_version == TPACKET_V3) {\n\t\t\tlv = sizeof(struct tpacket_stats_v3);\n\t\t\tst.stats3.tp_drops = drops;\n\t\t\tst.stats3.tp_packets += drops;\n\t\t\tdata = &st.stats3;\n\t\t} else {\n\t\t\tlv = sizeof(struct tpacket_stats);\n\t\t\tst.stats1.tp_drops = drops;\n\t\t\tst.stats1.tp_packets += drops;\n\t\t\tdata = &st.stats1;\n\t\t}\n\n\t\tbreak;\n\tcase PACKET_AUXDATA:\n\t\tval = po->auxdata;\n\t\tbreak;\n\tcase PACKET_ORIGDEV:\n\t\tval = po->origdev;\n\t\tbreak;\n\tcase PACKET_VNET_HDR:\n\t\tval = po->has_vnet_hdr;\n\t\tbreak;\n\tcase PACKET_VERSION:\n\t\tval = po->tp_version;\n\t\tbreak;\n\tcase PACKET_HDRLEN:\n\t\tif (len > sizeof(int))\n\t\t\tlen = sizeof(int);\n\t\tif (len < sizeof(int))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, len))\n\t\t\treturn -EFAULT;\n\t\tswitch (val) {\n\t\tcase TPACKET_V1:\n\t\t\tval = sizeof(struct tpacket_hdr);\n\t\t\tbreak;\n\t\tcase TPACKET_V2:\n\t\t\tval = sizeof(struct tpacket2_hdr);\n\t\t\tbreak;\n\t\tcase TPACKET_V3:\n\t\t\tval = sizeof(struct tpacket3_hdr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET_RESERVE:\n\t\tval = po->tp_reserve;\n\t\tbreak;\n\tcase PACKET_LOSS:\n\t\tval = po->tp_loss;\n\t\tbreak;\n\tcase PACKET_TIMESTAMP:\n\t\tval = po->tp_tstamp;\n\t\tbreak;\n\tcase PACKET_FANOUT:\n\t\tval = (po->fanout ?\n\t\t       ((u32)po->fanout->id |\n\t\t\t((u32)po->fanout->type << 16) |\n\t\t\t((u32)po->fanout->flags << 24)) :\n\t\t       0);\n\t\tbreak;\n\tcase PACKET_IGNORE_OUTGOING:\n\t\tval = po->prot_hook.ignore_outgoing;\n\t\tbreak;\n\tcase PACKET_ROLLOVER_STATS:\n\t\tif (!po->rollover)\n\t\t\treturn -EINVAL;\n\t\trstats.tp_all = atomic_long_read(&po->rollover->num);\n\t\trstats.tp_huge = atomic_long_read(&po->rollover->num_huge);\n\t\trstats.tp_failed = atomic_long_read(&po->rollover->num_failed);\n\t\tdata = &rstats;\n\t\tlv = sizeof(rstats);\n\t\tbreak;\n\tcase PACKET_TX_HAS_OFF:\n\t\tval = po->tp_tx_has_off;\n\t\tbreak;\n\tcase PACKET_QDISC_BYPASS:\n\t\tval = packet_use_direct_xmit(po);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (len > lv)\n\t\tlen = lv;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, data, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int packet_notifier(struct notifier_block *this,\n\t\t\t   unsigned long msg, void *ptr)\n{\n\tstruct sock *sk;\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(dev);\n\n\trcu_read_lock();\n\tsk_for_each_rcu(sk, &net->packet.sklist) {\n\t\tstruct packet_sock *po = pkt_sk(sk);\n\n\t\tswitch (msg) {\n\t\tcase NETDEV_UNREGISTER:\n\t\t\tif (po->mclist)\n\t\t\t\tpacket_dev_mclist_delete(dev, &po->mclist);\n\t\t\tfallthrough;\n\n\t\tcase NETDEV_DOWN:\n\t\t\tif (dev->ifindex == po->ifindex) {\n\t\t\t\tspin_lock(&po->bind_lock);\n\t\t\t\tif (po->running) {\n\t\t\t\t\t__unregister_prot_hook(sk, false);\n\t\t\t\t\tsk->sk_err = ENETDOWN;\n\t\t\t\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\t\t\t\tsk->sk_error_report(sk);\n\t\t\t\t}\n\t\t\t\tif (msg == NETDEV_UNREGISTER) {\n\t\t\t\t\tpacket_cached_dev_reset(po);\n\t\t\t\t\tpo->ifindex = -1;\n\t\t\t\t\tif (po->prot_hook.dev)\n\t\t\t\t\t\tdev_put(po->prot_hook.dev);\n\t\t\t\t\tpo->prot_hook.dev = NULL;\n\t\t\t\t}\n\t\t\t\tspin_unlock(&po->bind_lock);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NETDEV_UP:\n\t\t\tif (dev->ifindex == po->ifindex) {\n\t\t\t\tspin_lock(&po->bind_lock);\n\t\t\t\tif (po->num)\n\t\t\t\t\tregister_prot_hook(sk);\n\t\t\t\tspin_unlock(&po->bind_lock);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NOTIFY_DONE;\n}\n\n\nstatic int packet_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\n\tswitch (cmd) {\n\tcase SIOCOUTQ:\n\t{\n\t\tint amount = sk_wmem_alloc_get(sk);\n\n\t\treturn put_user(amount, (int __user *)arg);\n\t}\n\tcase SIOCINQ:\n\t{\n\t\tstruct sk_buff *skb;\n\t\tint amount = 0;\n\n\t\tspin_lock_bh(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tamount = skb->len;\n\t\tspin_unlock_bh(&sk->sk_receive_queue.lock);\n\t\treturn put_user(amount, (int __user *)arg);\n\t}\n#ifdef CONFIG_INET\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\tcase SIOCDARP:\n\tcase SIOCGARP:\n\tcase SIOCSARP:\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCSIFFLAGS:\n\t\treturn inet_dgram_ops.ioctl(sock, cmd, arg);\n#endif\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn 0;\n}\n\nstatic __poll_t packet_poll(struct file *file, struct socket *sock,\n\t\t\t\tpoll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\t__poll_t mask = datagram_poll(file, sock, wait);\n\n\tspin_lock_bh(&sk->sk_receive_queue.lock);\n\tif (po->rx_ring.pg_vec) {\n\t\tif (!packet_previous_rx_frame(po, &po->rx_ring,\n\t\t\tTP_STATUS_KERNEL))\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t}\n\tpacket_rcv_try_clear_pressure(po);\n\tspin_unlock_bh(&sk->sk_receive_queue.lock);\n\tspin_lock_bh(&sk->sk_write_queue.lock);\n\tif (po->tx_ring.pg_vec) {\n\t\tif (packet_current_frame(po, &po->tx_ring, TP_STATUS_AVAILABLE))\n\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t}\n\tspin_unlock_bh(&sk->sk_write_queue.lock);\n\treturn mask;\n}\n\n\n/* Dirty? Well, I still did not learn better way to account\n * for user mmaps.\n */\n\nstatic void packet_mm_open(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct socket *sock = file->private_data;\n\tstruct sock *sk = sock->sk;\n\n\tif (sk)\n\t\tatomic_inc(&pkt_sk(sk)->mapped);\n}\n\nstatic void packet_mm_close(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct socket *sock = file->private_data;\n\tstruct sock *sk = sock->sk;\n\n\tif (sk)\n\t\tatomic_dec(&pkt_sk(sk)->mapped);\n}\n\nstatic const struct vm_operations_struct packet_mmap_ops = {\n\t.open\t=\tpacket_mm_open,\n\t.close\t=\tpacket_mm_close,\n};\n\nstatic void free_pg_vec(struct pgv *pg_vec, unsigned int order,\n\t\t\tunsigned int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (likely(pg_vec[i].buffer)) {\n\t\t\tif (is_vmalloc_addr(pg_vec[i].buffer))\n\t\t\t\tvfree(pg_vec[i].buffer);\n\t\t\telse\n\t\t\t\tfree_pages((unsigned long)pg_vec[i].buffer,\n\t\t\t\t\t   order);\n\t\t\tpg_vec[i].buffer = NULL;\n\t\t}\n\t}\n\tkfree(pg_vec);\n}\n\nstatic char *alloc_one_pg_vec_page(unsigned long order)\n{\n\tchar *buffer;\n\tgfp_t gfp_flags = GFP_KERNEL | __GFP_COMP |\n\t\t\t  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;\n\n\tbuffer = (char *) __get_free_pages(gfp_flags, order);\n\tif (buffer)\n\t\treturn buffer;\n\n\t/* __get_free_pages failed, fall back to vmalloc */\n\tbuffer = vzalloc(array_size((1 << order), PAGE_SIZE));\n\tif (buffer)\n\t\treturn buffer;\n\n\t/* vmalloc failed, lets dig into swap here */\n\tgfp_flags &= ~__GFP_NORETRY;\n\tbuffer = (char *) __get_free_pages(gfp_flags, order);\n\tif (buffer)\n\t\treturn buffer;\n\n\t/* complete and utter failure */\n\treturn NULL;\n}\n\nstatic struct pgv *alloc_pg_vec(struct tpacket_req *req, int order)\n{\n\tunsigned int block_nr = req->tp_block_nr;\n\tstruct pgv *pg_vec;\n\tint i;\n\n\tpg_vec = kcalloc(block_nr, sizeof(struct pgv), GFP_KERNEL | __GFP_NOWARN);\n\tif (unlikely(!pg_vec))\n\t\tgoto out;\n\n\tfor (i = 0; i < block_nr; i++) {\n\t\tpg_vec[i].buffer = alloc_one_pg_vec_page(order);\n\t\tif (unlikely(!pg_vec[i].buffer))\n\t\t\tgoto out_free_pgvec;\n\t}\n\nout:\n\treturn pg_vec;\n\nout_free_pgvec:\n\tfree_pg_vec(pg_vec, order, block_nr);\n\tpg_vec = NULL;\n\tgoto out;\n}\n\nstatic int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,\n\t\tint closing, int tx_ring)\n{\n\tstruct pgv *pg_vec = NULL;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tunsigned long *rx_owner_map = NULL;\n\tint was_running, order = 0;\n\tstruct packet_ring_buffer *rb;\n\tstruct sk_buff_head *rb_queue;\n\t__be16 num;\n\tint err;\n\t/* Added to avoid minimal code churn */\n\tstruct tpacket_req *req = &req_u->req;\n\n\trb = tx_ring ? &po->tx_ring : &po->rx_ring;\n\trb_queue = tx_ring ? &sk->sk_write_queue : &sk->sk_receive_queue;\n\n\terr = -EBUSY;\n\tif (!closing) {\n\t\tif (atomic_read(&po->mapped))\n\t\t\tgoto out;\n\t\tif (packet_read_pending(rb))\n\t\t\tgoto out;\n\t}\n\n\tif (req->tp_block_nr) {\n\t\tunsigned int min_frame_size;\n\n\t\t/* Sanity tests and some calculations */\n\t\terr = -EBUSY;\n\t\tif (unlikely(rb->pg_vec))\n\t\t\tgoto out;\n\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V1:\n\t\t\tpo->tp_hdrlen = TPACKET_HDRLEN;\n\t\t\tbreak;\n\t\tcase TPACKET_V2:\n\t\t\tpo->tp_hdrlen = TPACKET2_HDRLEN;\n\t\t\tbreak;\n\t\tcase TPACKET_V3:\n\t\t\tpo->tp_hdrlen = TPACKET3_HDRLEN;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tif (unlikely((int)req->tp_block_size <= 0))\n\t\t\tgoto out;\n\t\tif (unlikely(!PAGE_ALIGNED(req->tp_block_size)))\n\t\t\tgoto out;\n\t\tmin_frame_size = po->tp_hdrlen + po->tp_reserve;\n\t\tif (po->tp_version >= TPACKET_V3 &&\n\t\t    req->tp_block_size <\n\t\t    BLK_PLUS_PRIV((u64)req_u->req3.tp_sizeof_priv) + min_frame_size)\n\t\t\tgoto out;\n\t\tif (unlikely(req->tp_frame_size < min_frame_size))\n\t\t\tgoto out;\n\t\tif (unlikely(req->tp_frame_size & (TPACKET_ALIGNMENT - 1)))\n\t\t\tgoto out;\n\n\t\trb->frames_per_block = req->tp_block_size / req->tp_frame_size;\n\t\tif (unlikely(rb->frames_per_block == 0))\n\t\t\tgoto out;\n\t\tif (unlikely(rb->frames_per_block > UINT_MAX / req->tp_block_nr))\n\t\t\tgoto out;\n\t\tif (unlikely((rb->frames_per_block * req->tp_block_nr) !=\n\t\t\t\t\treq->tp_frame_nr))\n\t\t\tgoto out;\n\n\t\terr = -ENOMEM;\n\t\torder = get_order(req->tp_block_size);\n\t\tpg_vec = alloc_pg_vec(req, order);\n\t\tif (unlikely(!pg_vec))\n\t\t\tgoto out;\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V3:\n\t\t\t/* Block transmit is not supported yet */\n\t\t\tif (!tx_ring) {\n\t\t\t\tinit_prb_bdqc(po, rb, pg_vec, req_u);\n\t\t\t} else {\n\t\t\t\tstruct tpacket_req3 *req3 = &req_u->req3;\n\n\t\t\t\tif (req3->tp_retire_blk_tov ||\n\t\t\t\t    req3->tp_sizeof_priv ||\n\t\t\t\t    req3->tp_feature_req_word) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_free_pg_vec;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!tx_ring) {\n\t\t\t\trx_owner_map = bitmap_alloc(req->tp_frame_nr,\n\t\t\t\t\tGFP_KERNEL | __GFP_NOWARN | __GFP_ZERO);\n\t\t\t\tif (!rx_owner_map)\n\t\t\t\t\tgoto out_free_pg_vec;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Done */\n\telse {\n\t\terr = -EINVAL;\n\t\tif (unlikely(req->tp_frame_nr))\n\t\t\tgoto out;\n\t}\n\n\n\t/* Detach socket from network */\n\tspin_lock(&po->bind_lock);\n\twas_running = po->running;\n\tnum = po->num;\n\tif (was_running) {\n\t\tpo->num = 0;\n\t\t__unregister_prot_hook(sk, false);\n\t}\n\tspin_unlock(&po->bind_lock);\n\n\tsynchronize_net();\n\n\terr = -EBUSY;\n\tmutex_lock(&po->pg_vec_lock);\n\tif (closing || atomic_read(&po->mapped) == 0) {\n\t\terr = 0;\n\t\tspin_lock_bh(&rb_queue->lock);\n\t\tswap(rb->pg_vec, pg_vec);\n\t\tif (po->tp_version <= TPACKET_V2)\n\t\t\tswap(rb->rx_owner_map, rx_owner_map);\n\t\trb->frame_max = (req->tp_frame_nr - 1);\n\t\trb->head = 0;\n\t\trb->frame_size = req->tp_frame_size;\n\t\tspin_unlock_bh(&rb_queue->lock);\n\n\t\tswap(rb->pg_vec_order, order);\n\t\tswap(rb->pg_vec_len, req->tp_block_nr);\n\n\t\trb->pg_vec_pages = req->tp_block_size/PAGE_SIZE;\n\t\tpo->prot_hook.func = (po->rx_ring.pg_vec) ?\n\t\t\t\t\t\ttpacket_rcv : packet_rcv;\n\t\tskb_queue_purge(rb_queue);\n\t\tif (atomic_read(&po->mapped))\n\t\t\tpr_err(\"packet_mmap: vma is busy: %d\\n\",\n\t\t\t       atomic_read(&po->mapped));\n\t}\n\tmutex_unlock(&po->pg_vec_lock);\n\n\tspin_lock(&po->bind_lock);\n\tif (was_running) {\n\t\tpo->num = num;\n\t\tregister_prot_hook(sk);\n\t}\n\tspin_unlock(&po->bind_lock);\n\tif (pg_vec && (po->tp_version > TPACKET_V2)) {\n\t\t/* Because we don't support block-based V3 on tx-ring */\n\t\tif (!tx_ring)\n\t\t\tprb_shutdown_retire_blk_timer(po, rb_queue);\n\t}\n\nout_free_pg_vec:\n\tbitmap_free(rx_owner_map);\n\tif (pg_vec)\n\t\tfree_pg_vec(pg_vec, order, req->tp_block_nr);\nout:\n\treturn err;\n}\n\nstatic int packet_mmap(struct file *file, struct socket *sock,\n\t\tstruct vm_area_struct *vma)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tunsigned long size, expected_size;\n\tstruct packet_ring_buffer *rb;\n\tunsigned long start;\n\tint err = -EINVAL;\n\tint i;\n\n\tif (vma->vm_pgoff)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&po->pg_vec_lock);\n\n\texpected_size = 0;\n\tfor (rb = &po->rx_ring; rb <= &po->tx_ring; rb++) {\n\t\tif (rb->pg_vec) {\n\t\t\texpected_size += rb->pg_vec_len\n\t\t\t\t\t\t* rb->pg_vec_pages\n\t\t\t\t\t\t* PAGE_SIZE;\n\t\t}\n\t}\n\n\tif (expected_size == 0)\n\t\tgoto out;\n\n\tsize = vma->vm_end - vma->vm_start;\n\tif (size != expected_size)\n\t\tgoto out;\n\n\tstart = vma->vm_start;\n\tfor (rb = &po->rx_ring; rb <= &po->tx_ring; rb++) {\n\t\tif (rb->pg_vec == NULL)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < rb->pg_vec_len; i++) {\n\t\t\tstruct page *page;\n\t\t\tvoid *kaddr = rb->pg_vec[i].buffer;\n\t\t\tint pg_num;\n\n\t\t\tfor (pg_num = 0; pg_num < rb->pg_vec_pages; pg_num++) {\n\t\t\t\tpage = pgv_to_page(kaddr);\n\t\t\t\terr = vm_insert_page(vma, start, page);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tgoto out;\n\t\t\t\tstart += PAGE_SIZE;\n\t\t\t\tkaddr += PAGE_SIZE;\n\t\t\t}\n\t\t}\n\t}\n\n\tatomic_inc(&po->mapped);\n\tvma->vm_ops = &packet_mmap_ops;\n\terr = 0;\n\nout:\n\tmutex_unlock(&po->pg_vec_lock);\n\treturn err;\n}\n\nstatic const struct proto_ops packet_ops_spkt = {\n\t.family =\tPF_PACKET,\n\t.owner =\tTHIS_MODULE,\n\t.release =\tpacket_release,\n\t.bind =\t\tpacket_bind_spkt,\n\t.connect =\tsock_no_connect,\n\t.socketpair =\tsock_no_socketpair,\n\t.accept =\tsock_no_accept,\n\t.getname =\tpacket_getname_spkt,\n\t.poll =\t\tdatagram_poll,\n\t.ioctl =\tpacket_ioctl,\n\t.gettstamp =\tsock_gettstamp,\n\t.listen =\tsock_no_listen,\n\t.shutdown =\tsock_no_shutdown,\n\t.sendmsg =\tpacket_sendmsg_spkt,\n\t.recvmsg =\tpacket_recvmsg,\n\t.mmap =\t\tsock_no_mmap,\n\t.sendpage =\tsock_no_sendpage,\n};\n\nstatic const struct proto_ops packet_ops = {\n\t.family =\tPF_PACKET,\n\t.owner =\tTHIS_MODULE,\n\t.release =\tpacket_release,\n\t.bind =\t\tpacket_bind,\n\t.connect =\tsock_no_connect,\n\t.socketpair =\tsock_no_socketpair,\n\t.accept =\tsock_no_accept,\n\t.getname =\tpacket_getname,\n\t.poll =\t\tpacket_poll,\n\t.ioctl =\tpacket_ioctl,\n\t.gettstamp =\tsock_gettstamp,\n\t.listen =\tsock_no_listen,\n\t.shutdown =\tsock_no_shutdown,\n\t.setsockopt =\tpacket_setsockopt,\n\t.getsockopt =\tpacket_getsockopt,\n\t.sendmsg =\tpacket_sendmsg,\n\t.recvmsg =\tpacket_recvmsg,\n\t.mmap =\t\tpacket_mmap,\n\t.sendpage =\tsock_no_sendpage,\n};\n\nstatic const struct net_proto_family packet_family_ops = {\n\t.family =\tPF_PACKET,\n\t.create =\tpacket_create,\n\t.owner\t=\tTHIS_MODULE,\n};\n\nstatic struct notifier_block packet_netdev_notifier = {\n\t.notifier_call =\tpacket_notifier,\n};\n\n#ifdef CONFIG_PROC_FS\n\nstatic void *packet_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct net *net = seq_file_net(seq);\n\n\trcu_read_lock();\n\treturn seq_hlist_start_head_rcu(&net->packet.sklist, *pos);\n}\n\nstatic void *packet_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct net *net = seq_file_net(seq);\n\treturn seq_hlist_next_rcu(v, &net->packet.sklist, pos);\n}\n\nstatic void packet_seq_stop(struct seq_file *seq, void *v)\n\t__releases(RCU)\n{\n\trcu_read_unlock();\n}\n\nstatic int packet_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_printf(seq,\n\t\t\t   \"%*sRefCnt Type Proto  Iface R Rmem   User   Inode\\n\",\n\t\t\t   IS_ENABLED(CONFIG_64BIT) ? -17 : -9, \"sk\");\n\telse {\n\t\tstruct sock *s = sk_entry(v);\n\t\tconst struct packet_sock *po = pkt_sk(s);\n\n\t\tseq_printf(seq,\n\t\t\t   \"%pK %-6d %-4d %04x   %-5d %1d %-6u %-6u %-6lu\\n\",\n\t\t\t   s,\n\t\t\t   refcount_read(&s->sk_refcnt),\n\t\t\t   s->sk_type,\n\t\t\t   ntohs(po->num),\n\t\t\t   po->ifindex,\n\t\t\t   po->running,\n\t\t\t   atomic_read(&s->sk_rmem_alloc),\n\t\t\t   from_kuid_munged(seq_user_ns(seq), sock_i_uid(s)),\n\t\t\t   sock_i_ino(s));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct seq_operations packet_seq_ops = {\n\t.start\t= packet_seq_start,\n\t.next\t= packet_seq_next,\n\t.stop\t= packet_seq_stop,\n\t.show\t= packet_seq_show,\n};\n#endif\n\nstatic int __net_init packet_net_init(struct net *net)\n{\n\tmutex_init(&net->packet.sklist_lock);\n\tINIT_HLIST_HEAD(&net->packet.sklist);\n\n#ifdef CONFIG_PROC_FS\n\tif (!proc_create_net(\"packet\", 0, net->proc_net, &packet_seq_ops,\n\t\t\tsizeof(struct seq_net_private)))\n\t\treturn -ENOMEM;\n#endif /* CONFIG_PROC_FS */\n\n\treturn 0;\n}\n\nstatic void __net_exit packet_net_exit(struct net *net)\n{\n\tremove_proc_entry(\"packet\", net->proc_net);\n\tWARN_ON_ONCE(!hlist_empty(&net->packet.sklist));\n}\n\nstatic struct pernet_operations packet_net_ops = {\n\t.init = packet_net_init,\n\t.exit = packet_net_exit,\n};\n\n\nstatic void __exit packet_exit(void)\n{\n\tunregister_netdevice_notifier(&packet_netdev_notifier);\n\tunregister_pernet_subsys(&packet_net_ops);\n\tsock_unregister(PF_PACKET);\n\tproto_unregister(&packet_proto);\n}\n\nstatic int __init packet_init(void)\n{\n\tint rc;\n\n\trc = proto_register(&packet_proto, 0);\n\tif (rc)\n\t\tgoto out;\n\trc = sock_register(&packet_family_ops);\n\tif (rc)\n\t\tgoto out_proto;\n\trc = register_pernet_subsys(&packet_net_ops);\n\tif (rc)\n\t\tgoto out_sock;\n\trc = register_netdevice_notifier(&packet_netdev_notifier);\n\tif (rc)\n\t\tgoto out_pernet;\n\n\treturn 0;\n\nout_pernet:\n\tunregister_pernet_subsys(&packet_net_ops);\nout_sock:\n\tsock_unregister(PF_PACKET);\nout_proto:\n\tproto_unregister(&packet_proto);\nout:\n\treturn rc;\n}\n\nmodule_init(packet_init);\nmodule_exit(packet_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_PACKET);\n"}, "2": {"id": 2, "path": "/src/include/linux/net.h", "content": "/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * NET\t\tAn implementation of the SOCKET network access protocol.\n *\t\tThis is the master header file for the Linux NET layer,\n *\t\tor, in plain English: the networking handling part of the\n *\t\tkernel.\n *\n * Version:\t@(#)net.h\t1.0.3\t05/25/93\n *\n * Authors:\tOrest Zborowski, <obz@Kodak.COM>\n *\t\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n */\n#ifndef _LINUX_NET_H\n#define _LINUX_NET_H\n\n#include <linux/stringify.h>\n#include <linux/random.h>\n#include <linux/wait.h>\n#include <linux/fcntl.h>\t/* For O_CLOEXEC and O_NONBLOCK */\n#include <linux/rcupdate.h>\n#include <linux/once.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/sockptr.h>\n\n#include <uapi/linux/net.h>\n\nstruct poll_table_struct;\nstruct pipe_inode_info;\nstruct inode;\nstruct file;\nstruct net;\n\n/* Historically, SOCKWQ_ASYNC_NOSPACE & SOCKWQ_ASYNC_WAITDATA were located\n * in sock->flags, but moved into sk->sk_wq->flags to be RCU protected.\n * Eventually all flags will be in sk->sk_wq->flags.\n */\n#define SOCKWQ_ASYNC_NOSPACE\t0\n#define SOCKWQ_ASYNC_WAITDATA\t1\n#define SOCK_NOSPACE\t\t2\n#define SOCK_PASSCRED\t\t3\n#define SOCK_PASSSEC\t\t4\n\n#define PROTO_CMSG_DATA_ONLY\t0x0001\n\n#ifndef ARCH_HAS_SOCKET_TYPES\n/**\n * enum sock_type - Socket types\n * @SOCK_STREAM: stream (connection) socket\n * @SOCK_DGRAM: datagram (conn.less) socket\n * @SOCK_RAW: raw socket\n * @SOCK_RDM: reliably-delivered message\n * @SOCK_SEQPACKET: sequential packet socket\n * @SOCK_DCCP: Datagram Congestion Control Protocol socket\n * @SOCK_PACKET: linux specific way of getting packets at the dev level.\n *\t\t  For writing rarp and other similar things on the user level.\n *\n * When adding some new socket type please\n * grep ARCH_HAS_SOCKET_TYPE include/asm-* /socket.h, at least MIPS\n * overrides this enum for binary compat reasons.\n */\nenum sock_type {\n\tSOCK_STREAM\t= 1,\n\tSOCK_DGRAM\t= 2,\n\tSOCK_RAW\t= 3,\n\tSOCK_RDM\t= 4,\n\tSOCK_SEQPACKET\t= 5,\n\tSOCK_DCCP\t= 6,\n\tSOCK_PACKET\t= 10,\n};\n\n#define SOCK_MAX (SOCK_PACKET + 1)\n/* Mask which covers at least up to SOCK_MASK-1.  The\n * remaining bits are used as flags. */\n#define SOCK_TYPE_MASK 0xf\n\n/* Flags for socket, socketpair, accept4 */\n#define SOCK_CLOEXEC\tO_CLOEXEC\n#ifndef SOCK_NONBLOCK\n#define SOCK_NONBLOCK\tO_NONBLOCK\n#endif\n\n#endif /* ARCH_HAS_SOCKET_TYPES */\n\n/**\n * enum sock_shutdown_cmd - Shutdown types\n * @SHUT_RD: shutdown receptions\n * @SHUT_WR: shutdown transmissions\n * @SHUT_RDWR: shutdown receptions/transmissions\n */\nenum sock_shutdown_cmd {\n\tSHUT_RD,\n\tSHUT_WR,\n\tSHUT_RDWR,\n};\n\nstruct socket_wq {\n\t/* Note: wait MUST be first field of socket_wq */\n\twait_queue_head_t\twait;\n\tstruct fasync_struct\t*fasync_list;\n\tunsigned long\t\tflags; /* %SOCKWQ_ASYNC_NOSPACE, etc */\n\tstruct rcu_head\t\trcu;\n} ____cacheline_aligned_in_smp;\n\n/**\n *  struct socket - general BSD socket\n *  @state: socket state (%SS_CONNECTED, etc)\n *  @type: socket type (%SOCK_STREAM, etc)\n *  @flags: socket flags (%SOCK_NOSPACE, etc)\n *  @ops: protocol specific socket operations\n *  @file: File back pointer for gc\n *  @sk: internal networking protocol agnostic socket representation\n *  @wq: wait queue for several uses\n */\nstruct socket {\n\tsocket_state\t\tstate;\n\n\tshort\t\t\ttype;\n\n\tunsigned long\t\tflags;\n\n\tstruct file\t\t*file;\n\tstruct sock\t\t*sk;\n\tconst struct proto_ops\t*ops;\n\n\tstruct socket_wq\twq;\n};\n\nstruct vm_area_struct;\nstruct page;\nstruct sockaddr;\nstruct msghdr;\nstruct module;\nstruct sk_buff;\ntypedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *,\n\t\t\t       unsigned int, size_t);\n\nstruct proto_ops {\n\tint\t\tfamily;\n\tunsigned int\tflags;\n\tstruct module\t*owner;\n\tint\t\t(*release)   (struct socket *sock);\n\tint\t\t(*bind)\t     (struct socket *sock,\n\t\t\t\t      struct sockaddr *myaddr,\n\t\t\t\t      int sockaddr_len);\n\tint\t\t(*connect)   (struct socket *sock,\n\t\t\t\t      struct sockaddr *vaddr,\n\t\t\t\t      int sockaddr_len, int flags);\n\tint\t\t(*socketpair)(struct socket *sock1,\n\t\t\t\t      struct socket *sock2);\n\tint\t\t(*accept)    (struct socket *sock,\n\t\t\t\t      struct socket *newsock, int flags, bool kern);\n\tint\t\t(*getname)   (struct socket *sock,\n\t\t\t\t      struct sockaddr *addr,\n\t\t\t\t      int peer);\n\t__poll_t\t(*poll)\t     (struct file *file, struct socket *sock,\n\t\t\t\t      struct poll_table_struct *wait);\n\tint\t\t(*ioctl)     (struct socket *sock, unsigned int cmd,\n\t\t\t\t      unsigned long arg);\n#ifdef CONFIG_COMPAT\n\tint\t \t(*compat_ioctl) (struct socket *sock, unsigned int cmd,\n\t\t\t\t      unsigned long arg);\n#endif\n\tint\t\t(*gettstamp) (struct socket *sock, void __user *userstamp,\n\t\t\t\t      bool timeval, bool time32);\n\tint\t\t(*listen)    (struct socket *sock, int len);\n\tint\t\t(*shutdown)  (struct socket *sock, int flags);\n\tint\t\t(*setsockopt)(struct socket *sock, int level,\n\t\t\t\t      int optname, sockptr_t optval,\n\t\t\t\t      unsigned int optlen);\n\tint\t\t(*getsockopt)(struct socket *sock, int level,\n\t\t\t\t      int optname, char __user *optval, int __user *optlen);\n\tvoid\t\t(*show_fdinfo)(struct seq_file *m, struct socket *sock);\n\tint\t\t(*sendmsg)   (struct socket *sock, struct msghdr *m,\n\t\t\t\t      size_t total_len);\n\t/* Notes for implementing recvmsg:\n\t * ===============================\n\t * msg->msg_namelen should get updated by the recvmsg handlers\n\t * iff msg_name != NULL. It is by default 0 to prevent\n\t * returning uninitialized memory to user space.  The recvfrom\n\t * handlers can assume that msg.msg_name is either NULL or has\n\t * a minimum size of sizeof(struct sockaddr_storage).\n\t */\n\tint\t\t(*recvmsg)   (struct socket *sock, struct msghdr *m,\n\t\t\t\t      size_t total_len, int flags);\n\tint\t\t(*mmap)\t     (struct file *file, struct socket *sock,\n\t\t\t\t      struct vm_area_struct * vma);\n\tssize_t\t\t(*sendpage)  (struct socket *sock, struct page *page,\n\t\t\t\t      int offset, size_t size, int flags);\n\tssize_t \t(*splice_read)(struct socket *sock,  loff_t *ppos,\n\t\t\t\t       struct pipe_inode_info *pipe, size_t len, unsigned int flags);\n\tint\t\t(*set_peek_off)(struct sock *sk, int val);\n\tint\t\t(*peek_len)(struct socket *sock);\n\n\t/* The following functions are called internally by kernel with\n\t * sock lock already held.\n\t */\n\tint\t\t(*read_sock)(struct sock *sk, read_descriptor_t *desc,\n\t\t\t\t     sk_read_actor_t recv_actor);\n\tint\t\t(*sendpage_locked)(struct sock *sk, struct page *page,\n\t\t\t\t\t   int offset, size_t size, int flags);\n\tint\t\t(*sendmsg_locked)(struct sock *sk, struct msghdr *msg,\n\t\t\t\t\t  size_t size);\n\tint\t\t(*set_rcvlowat)(struct sock *sk, int val);\n};\n\n#define DECLARE_SOCKADDR(type, dst, src)\t\\\n\ttype dst = ({ __sockaddr_check_size(sizeof(*dst)); (type) src; })\n\nstruct net_proto_family {\n\tint\t\tfamily;\n\tint\t\t(*create)(struct net *net, struct socket *sock,\n\t\t\t\t  int protocol, int kern);\n\tstruct module\t*owner;\n};\n\nstruct iovec;\nstruct kvec;\n\nenum {\n\tSOCK_WAKE_IO,\n\tSOCK_WAKE_WAITD,\n\tSOCK_WAKE_SPACE,\n\tSOCK_WAKE_URG,\n};\n\nint sock_wake_async(struct socket_wq *sk_wq, int how, int band);\nint sock_register(const struct net_proto_family *fam);\nvoid sock_unregister(int family);\nbool sock_is_registered(int family);\nint __sock_create(struct net *net, int family, int type, int proto,\n\t\t  struct socket **res, int kern);\nint sock_create(int family, int type, int proto, struct socket **res);\nint sock_create_kern(struct net *net, int family, int type, int proto, struct socket **res);\nint sock_create_lite(int family, int type, int proto, struct socket **res);\nstruct socket *sock_alloc(void);\nvoid sock_release(struct socket *sock);\nint sock_sendmsg(struct socket *sock, struct msghdr *msg);\nint sock_recvmsg(struct socket *sock, struct msghdr *msg, int flags);\nstruct file *sock_alloc_file(struct socket *sock, int flags, const char *dname);\nstruct socket *sockfd_lookup(int fd, int *err);\nstruct socket *sock_from_file(struct file *file);\n#define\t\t     sockfd_put(sock) fput(sock->file)\nint net_ratelimit(void);\n\n#define net_ratelimited_function(function, ...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (net_ratelimit())\t\t\t\t\t\\\n\t\tfunction(__VA_ARGS__);\t\t\t\t\\\n} while (0)\n\n#define net_emerg_ratelimited(fmt, ...)\t\t\t\t\\\n\tnet_ratelimited_function(pr_emerg, fmt, ##__VA_ARGS__)\n#define net_alert_ratelimited(fmt, ...)\t\t\t\t\\\n\tnet_ratelimited_function(pr_alert, fmt, ##__VA_ARGS__)\n#define net_crit_ratelimited(fmt, ...)\t\t\t\t\\\n\tnet_ratelimited_function(pr_crit, fmt, ##__VA_ARGS__)\n#define net_err_ratelimited(fmt, ...)\t\t\t\t\\\n\tnet_ratelimited_function(pr_err, fmt, ##__VA_ARGS__)\n#define net_notice_ratelimited(fmt, ...)\t\t\t\\\n\tnet_ratelimited_function(pr_notice, fmt, ##__VA_ARGS__)\n#define net_warn_ratelimited(fmt, ...)\t\t\t\t\\\n\tnet_ratelimited_function(pr_warn, fmt, ##__VA_ARGS__)\n#define net_info_ratelimited(fmt, ...)\t\t\t\t\\\n\tnet_ratelimited_function(pr_info, fmt, ##__VA_ARGS__)\n#if defined(CONFIG_DYNAMIC_DEBUG) || \\\n\t(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))\n#define net_dbg_ratelimited(fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tDEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt);\t\t\t\\\n\tif (DYNAMIC_DEBUG_BRANCH(descriptor) &&\t\t\t\t\\\n\t    net_ratelimit())\t\t\t\t\t\t\\\n\t\t__dynamic_pr_debug(&descriptor, pr_fmt(fmt),\t\t\\\n\t\t                   ##__VA_ARGS__);\t\t\t\\\n} while (0)\n#elif defined(DEBUG)\n#define net_dbg_ratelimited(fmt, ...)\t\t\t\t\\\n\tnet_ratelimited_function(pr_debug, fmt, ##__VA_ARGS__)\n#else\n#define net_dbg_ratelimited(fmt, ...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (0)\t\t\t\t\t\t\\\n\t\t\tno_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__); \\\n\t} while (0)\n#endif\n\n#define net_get_random_once(buf, nbytes)\t\t\t\\\n\tget_random_once((buf), (nbytes))\n#define net_get_random_once_wait(buf, nbytes)\t\t\t\\\n\tget_random_once_wait((buf), (nbytes))\n\n/*\n * E.g. XFS meta- & log-data is in slab pages, or bcache meta\n * data pages, or other high order pages allocated by\n * __get_free_pages() without __GFP_COMP, which have a page_count\n * of 0 and/or have PageSlab() set. We cannot use send_page for\n * those, as that does get_page(); put_page(); and would cause\n * either a VM_BUG directly, or __page_cache_release a page that\n * would actually still be referenced by someone, leading to some\n * obscure delayed Oops somewhere else.\n */\nstatic inline bool sendpage_ok(struct page *page)\n{\n\treturn !PageSlab(page) && page_count(page) >= 1;\n}\n\nint kernel_sendmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,\n\t\t   size_t num, size_t len);\nint kernel_sendmsg_locked(struct sock *sk, struct msghdr *msg,\n\t\t\t  struct kvec *vec, size_t num, size_t len);\nint kernel_recvmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,\n\t\t   size_t num, size_t len, int flags);\n\nint kernel_bind(struct socket *sock, struct sockaddr *addr, int addrlen);\nint kernel_listen(struct socket *sock, int backlog);\nint kernel_accept(struct socket *sock, struct socket **newsock, int flags);\nint kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,\n\t\t   int flags);\nint kernel_getsockname(struct socket *sock, struct sockaddr *addr);\nint kernel_getpeername(struct socket *sock, struct sockaddr *addr);\nint kernel_sendpage(struct socket *sock, struct page *page, int offset,\n\t\t    size_t size, int flags);\nint kernel_sendpage_locked(struct sock *sk, struct page *page, int offset,\n\t\t\t   size_t size, int flags);\nint kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how);\n\n/* Routine returns the IP overhead imposed by a (caller-protected) socket. */\nu32 kernel_sock_ip_overhead(struct sock *sk);\n\n#define MODULE_ALIAS_NETPROTO(proto) \\\n\tMODULE_ALIAS(\"net-pf-\" __stringify(proto))\n\n#define MODULE_ALIAS_NET_PF_PROTO(pf, proto) \\\n\tMODULE_ALIAS(\"net-pf-\" __stringify(pf) \"-proto-\" __stringify(proto))\n\n#define MODULE_ALIAS_NET_PF_PROTO_TYPE(pf, proto, type) \\\n\tMODULE_ALIAS(\"net-pf-\" __stringify(pf) \"-proto-\" __stringify(proto) \\\n\t\t     \"-type-\" __stringify(type))\n\n#define MODULE_ALIAS_NET_PF_PROTO_NAME(pf, proto, name) \\\n\tMODULE_ALIAS(\"net-pf-\" __stringify(pf) \"-proto-\" __stringify(proto) \\\n\t\t     name)\n#endif\t/* _LINUX_NET_H */\n"}, "3": {"id": 3, "path": "/src/include/linux/socket.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_SOCKET_H\n#define _LINUX_SOCKET_H\n\n\n#include <asm/socket.h>\t\t\t/* arch-dependent defines\t*/\n#include <linux/sockios.h>\t\t/* the SIOCxxx I/O controls\t*/\n#include <linux/uio.h>\t\t\t/* iovec support\t\t*/\n#include <linux/types.h>\t\t/* pid_t\t\t\t*/\n#include <linux/compiler.h>\t\t/* __user\t\t\t*/\n#include <uapi/linux/socket.h>\n\nstruct file;\nstruct pid;\nstruct cred;\nstruct socket;\n\n#define __sockaddr_check_size(size)\t\\\n\tBUILD_BUG_ON(((size) > sizeof(struct __kernel_sockaddr_storage)))\n\n#ifdef CONFIG_PROC_FS\nstruct seq_file;\nextern void socket_seq_show(struct seq_file *seq);\n#endif\n\ntypedef __kernel_sa_family_t\tsa_family_t;\n\n/*\n *\t1003.1g requires sa_family_t and that sa_data is char.\n */\n\nstruct sockaddr {\n\tsa_family_t\tsa_family;\t/* address family, AF_xxx\t*/\n\tchar\t\tsa_data[14];\t/* 14 bytes of protocol address\t*/\n};\n\nstruct linger {\n\tint\t\tl_onoff;\t/* Linger active\t\t*/\n\tint\t\tl_linger;\t/* How long to linger for\t*/\n};\n\n#define sockaddr_storage __kernel_sockaddr_storage\n\n/*\n *\tAs we do 4.4BSD message passing we use a 4.4BSD message passing\n *\tsystem, not 4.3. Thus msg_accrights(len) are now missing. They\n *\tbelong in an obscure libc emulation or the bin.\n */\n\nstruct msghdr {\n\tvoid\t\t*msg_name;\t/* ptr to socket address structure */\n\tint\t\tmsg_namelen;\t/* size of socket address structure */\n\tstruct iov_iter\tmsg_iter;\t/* data */\n\n\t/*\n\t * Ancillary data. msg_control_user is the user buffer used for the\n\t * recv* side when msg_control_is_user is set, msg_control is the kernel\n\t * buffer used for all other cases.\n\t */\n\tunion {\n\t\tvoid\t\t*msg_control;\n\t\tvoid __user\t*msg_control_user;\n\t};\n\tbool\t\tmsg_control_is_user : 1;\n\t__kernel_size_t\tmsg_controllen;\t/* ancillary data buffer length */\n\tunsigned int\tmsg_flags;\t/* flags on received message */\n\tstruct kiocb\t*msg_iocb;\t/* ptr to iocb for async requests */\n};\n\nstruct user_msghdr {\n\tvoid\t\t__user *msg_name;\t/* ptr to socket address structure */\n\tint\t\tmsg_namelen;\t\t/* size of socket address structure */\n\tstruct iovec\t__user *msg_iov;\t/* scatter/gather array */\n\t__kernel_size_t\tmsg_iovlen;\t\t/* # elements in msg_iov */\n\tvoid\t\t__user *msg_control;\t/* ancillary data */\n\t__kernel_size_t\tmsg_controllen;\t\t/* ancillary data buffer length */\n\tunsigned int\tmsg_flags;\t\t/* flags on received message */\n};\n\n/* For recvmmsg/sendmmsg */\nstruct mmsghdr {\n\tstruct user_msghdr  msg_hdr;\n\tunsigned int        msg_len;\n};\n\n/*\n *\tPOSIX 1003.1g - ancillary data object information\n *\tAncillary data consits of a sequence of pairs of\n *\t(cmsghdr, cmsg_data[])\n */\n\nstruct cmsghdr {\n\t__kernel_size_t\tcmsg_len;\t/* data byte count, including hdr */\n        int\t\tcmsg_level;\t/* originating protocol */\n        int\t\tcmsg_type;\t/* protocol-specific type */\n};\n\n/*\n *\tAncillary data object information MACROS\n *\tTable 5-14 of POSIX 1003.1g\n */\n\n#define __CMSG_NXTHDR(ctl, len, cmsg) __cmsg_nxthdr((ctl),(len),(cmsg))\n#define CMSG_NXTHDR(mhdr, cmsg) cmsg_nxthdr((mhdr), (cmsg))\n\n#define CMSG_ALIGN(len) ( ((len)+sizeof(long)-1) & ~(sizeof(long)-1) )\n\n#define CMSG_DATA(cmsg) \\\n\t((void *)(cmsg) + sizeof(struct cmsghdr))\n#define CMSG_USER_DATA(cmsg) \\\n\t((void __user *)(cmsg) + sizeof(struct cmsghdr))\n#define CMSG_SPACE(len) (sizeof(struct cmsghdr) + CMSG_ALIGN(len))\n#define CMSG_LEN(len) (sizeof(struct cmsghdr) + (len))\n\n#define __CMSG_FIRSTHDR(ctl,len) ((len) >= sizeof(struct cmsghdr) ? \\\n\t\t\t\t  (struct cmsghdr *)(ctl) : \\\n\t\t\t\t  (struct cmsghdr *)NULL)\n#define CMSG_FIRSTHDR(msg)\t__CMSG_FIRSTHDR((msg)->msg_control, (msg)->msg_controllen)\n#define CMSG_OK(mhdr, cmsg) ((cmsg)->cmsg_len >= sizeof(struct cmsghdr) && \\\n\t\t\t     (cmsg)->cmsg_len <= (unsigned long) \\\n\t\t\t     ((mhdr)->msg_controllen - \\\n\t\t\t      ((char *)(cmsg) - (char *)(mhdr)->msg_control)))\n#define for_each_cmsghdr(cmsg, msg) \\\n\tfor (cmsg = CMSG_FIRSTHDR(msg); \\\n\t     cmsg; \\\n\t     cmsg = CMSG_NXTHDR(msg, cmsg))\n\n/*\n *\tGet the next cmsg header\n *\n *\tPLEASE, do not touch this function. If you think, that it is\n *\tincorrect, grep kernel sources and think about consequences\n *\tbefore trying to improve it.\n *\n *\tNow it always returns valid, not truncated ancillary object\n *\tHEADER. But caller still MUST check, that cmsg->cmsg_len is\n *\tinside range, given by msg->msg_controllen before using\n *\tancillary object DATA.\t\t\t\t--ANK (980731)\n */\n\nstatic inline struct cmsghdr * __cmsg_nxthdr(void *__ctl, __kernel_size_t __size,\n\t\t\t\t\t       struct cmsghdr *__cmsg)\n{\n\tstruct cmsghdr * __ptr;\n\n\t__ptr = (struct cmsghdr*)(((unsigned char *) __cmsg) +  CMSG_ALIGN(__cmsg->cmsg_len));\n\tif ((unsigned long)((char*)(__ptr+1) - (char *) __ctl) > __size)\n\t\treturn (struct cmsghdr *)0;\n\n\treturn __ptr;\n}\n\nstatic inline struct cmsghdr * cmsg_nxthdr (struct msghdr *__msg, struct cmsghdr *__cmsg)\n{\n\treturn __cmsg_nxthdr(__msg->msg_control, __msg->msg_controllen, __cmsg);\n}\n\nstatic inline size_t msg_data_left(struct msghdr *msg)\n{\n\treturn iov_iter_count(&msg->msg_iter);\n}\n\n/* \"Socket\"-level control message types: */\n\n#define\tSCM_RIGHTS\t0x01\t\t/* rw: access rights (array of int) */\n#define SCM_CREDENTIALS 0x02\t\t/* rw: struct ucred\t\t*/\n#define SCM_SECURITY\t0x03\t\t/* rw: security label\t\t*/\n\nstruct ucred {\n\t__u32\tpid;\n\t__u32\tuid;\n\t__u32\tgid;\n};\n\n/* Supported address families. */\n#define AF_UNSPEC\t0\n#define AF_UNIX\t\t1\t/* Unix domain sockets \t\t*/\n#define AF_LOCAL\t1\t/* POSIX name for AF_UNIX\t*/\n#define AF_INET\t\t2\t/* Internet IP Protocol \t*/\n#define AF_AX25\t\t3\t/* Amateur Radio AX.25 \t\t*/\n#define AF_IPX\t\t4\t/* Novell IPX \t\t\t*/\n#define AF_APPLETALK\t5\t/* AppleTalk DDP \t\t*/\n#define AF_NETROM\t6\t/* Amateur Radio NET/ROM \t*/\n#define AF_BRIDGE\t7\t/* Multiprotocol bridge \t*/\n#define AF_ATMPVC\t8\t/* ATM PVCs\t\t\t*/\n#define AF_X25\t\t9\t/* Reserved for X.25 project \t*/\n#define AF_INET6\t10\t/* IP version 6\t\t\t*/\n#define AF_ROSE\t\t11\t/* Amateur Radio X.25 PLP\t*/\n#define AF_DECnet\t12\t/* Reserved for DECnet project\t*/\n#define AF_NETBEUI\t13\t/* Reserved for 802.2LLC project*/\n#define AF_SECURITY\t14\t/* Security callback pseudo AF */\n#define AF_KEY\t\t15      /* PF_KEY key management API */\n#define AF_NETLINK\t16\n#define AF_ROUTE\tAF_NETLINK /* Alias to emulate 4.4BSD */\n#define AF_PACKET\t17\t/* Packet family\t\t*/\n#define AF_ASH\t\t18\t/* Ash\t\t\t\t*/\n#define AF_ECONET\t19\t/* Acorn Econet\t\t\t*/\n#define AF_ATMSVC\t20\t/* ATM SVCs\t\t\t*/\n#define AF_RDS\t\t21\t/* RDS sockets \t\t\t*/\n#define AF_SNA\t\t22\t/* Linux SNA Project (nutters!) */\n#define AF_IRDA\t\t23\t/* IRDA sockets\t\t\t*/\n#define AF_PPPOX\t24\t/* PPPoX sockets\t\t*/\n#define AF_WANPIPE\t25\t/* Wanpipe API Sockets */\n#define AF_LLC\t\t26\t/* Linux LLC\t\t\t*/\n#define AF_IB\t\t27\t/* Native InfiniBand address\t*/\n#define AF_MPLS\t\t28\t/* MPLS */\n#define AF_CAN\t\t29\t/* Controller Area Network      */\n#define AF_TIPC\t\t30\t/* TIPC sockets\t\t\t*/\n#define AF_BLUETOOTH\t31\t/* Bluetooth sockets \t\t*/\n#define AF_IUCV\t\t32\t/* IUCV sockets\t\t\t*/\n#define AF_RXRPC\t33\t/* RxRPC sockets \t\t*/\n#define AF_ISDN\t\t34\t/* mISDN sockets \t\t*/\n#define AF_PHONET\t35\t/* Phonet sockets\t\t*/\n#define AF_IEEE802154\t36\t/* IEEE802154 sockets\t\t*/\n#define AF_CAIF\t\t37\t/* CAIF sockets\t\t\t*/\n#define AF_ALG\t\t38\t/* Algorithm sockets\t\t*/\n#define AF_NFC\t\t39\t/* NFC sockets\t\t\t*/\n#define AF_VSOCK\t40\t/* vSockets\t\t\t*/\n#define AF_KCM\t\t41\t/* Kernel Connection Multiplexor*/\n#define AF_QIPCRTR\t42\t/* Qualcomm IPC Router          */\n#define AF_SMC\t\t43\t/* smc sockets: reserve number for\n\t\t\t\t * PF_SMC protocol family that\n\t\t\t\t * reuses AF_INET address family\n\t\t\t\t */\n#define AF_XDP\t\t44\t/* XDP sockets\t\t\t*/\n\n#define AF_MAX\t\t45\t/* For now.. */\n\n/* Protocol families, same as address families. */\n#define PF_UNSPEC\tAF_UNSPEC\n#define PF_UNIX\t\tAF_UNIX\n#define PF_LOCAL\tAF_LOCAL\n#define PF_INET\t\tAF_INET\n#define PF_AX25\t\tAF_AX25\n#define PF_IPX\t\tAF_IPX\n#define PF_APPLETALK\tAF_APPLETALK\n#define\tPF_NETROM\tAF_NETROM\n#define PF_BRIDGE\tAF_BRIDGE\n#define PF_ATMPVC\tAF_ATMPVC\n#define PF_X25\t\tAF_X25\n#define PF_INET6\tAF_INET6\n#define PF_ROSE\t\tAF_ROSE\n#define PF_DECnet\tAF_DECnet\n#define PF_NETBEUI\tAF_NETBEUI\n#define PF_SECURITY\tAF_SECURITY\n#define PF_KEY\t\tAF_KEY\n#define PF_NETLINK\tAF_NETLINK\n#define PF_ROUTE\tAF_ROUTE\n#define PF_PACKET\tAF_PACKET\n#define PF_ASH\t\tAF_ASH\n#define PF_ECONET\tAF_ECONET\n#define PF_ATMSVC\tAF_ATMSVC\n#define PF_RDS\t\tAF_RDS\n#define PF_SNA\t\tAF_SNA\n#define PF_IRDA\t\tAF_IRDA\n#define PF_PPPOX\tAF_PPPOX\n#define PF_WANPIPE\tAF_WANPIPE\n#define PF_LLC\t\tAF_LLC\n#define PF_IB\t\tAF_IB\n#define PF_MPLS\t\tAF_MPLS\n#define PF_CAN\t\tAF_CAN\n#define PF_TIPC\t\tAF_TIPC\n#define PF_BLUETOOTH\tAF_BLUETOOTH\n#define PF_IUCV\t\tAF_IUCV\n#define PF_RXRPC\tAF_RXRPC\n#define PF_ISDN\t\tAF_ISDN\n#define PF_PHONET\tAF_PHONET\n#define PF_IEEE802154\tAF_IEEE802154\n#define PF_CAIF\t\tAF_CAIF\n#define PF_ALG\t\tAF_ALG\n#define PF_NFC\t\tAF_NFC\n#define PF_VSOCK\tAF_VSOCK\n#define PF_KCM\t\tAF_KCM\n#define PF_QIPCRTR\tAF_QIPCRTR\n#define PF_SMC\t\tAF_SMC\n#define PF_XDP\t\tAF_XDP\n#define PF_MAX\t\tAF_MAX\n\n/* Maximum queue length specifiable by listen.  */\n#define SOMAXCONN\t4096\n\n/* Flags we can use with send/ and recv.\n   Added those for 1003.1g not all are supported yet\n */\n\n#define MSG_OOB\t\t1\n#define MSG_PEEK\t2\n#define MSG_DONTROUTE\t4\n#define MSG_TRYHARD     4       /* Synonym for MSG_DONTROUTE for DECnet */\n#define MSG_CTRUNC\t8\n#define MSG_PROBE\t0x10\t/* Do not send. Only probe path f.e. for MTU */\n#define MSG_TRUNC\t0x20\n#define MSG_DONTWAIT\t0x40\t/* Nonblocking io\t\t */\n#define MSG_EOR         0x80\t/* End of record */\n#define MSG_WAITALL\t0x100\t/* Wait for a full request */\n#define MSG_FIN         0x200\n#define MSG_SYN\t\t0x400\n#define MSG_CONFIRM\t0x800\t/* Confirm path validity */\n#define MSG_RST\t\t0x1000\n#define MSG_ERRQUEUE\t0x2000\t/* Fetch message from error queue */\n#define MSG_NOSIGNAL\t0x4000\t/* Do not generate SIGPIPE */\n#define MSG_MORE\t0x8000\t/* Sender will send more */\n#define MSG_WAITFORONE\t0x10000\t/* recvmmsg(): block until 1+ packets avail */\n#define MSG_SENDPAGE_NOPOLICY 0x10000 /* sendpage() internal : do no apply policy */\n#define MSG_SENDPAGE_NOTLAST 0x20000 /* sendpage() internal : not the last page */\n#define MSG_BATCH\t0x40000 /* sendmmsg(): more messages coming */\n#define MSG_EOF         MSG_FIN\n#define MSG_NO_SHARED_FRAGS 0x80000 /* sendpage() internal : page frags are not shared */\n#define MSG_SENDPAGE_DECRYPTED\t0x100000 /* sendpage() internal : page may carry\n\t\t\t\t\t  * plain text and require encryption\n\t\t\t\t\t  */\n\n#define MSG_ZEROCOPY\t0x4000000\t/* Use user data in kernel path */\n#define MSG_FASTOPEN\t0x20000000\t/* Send data in TCP SYN */\n#define MSG_CMSG_CLOEXEC 0x40000000\t/* Set close_on_exec for file\n\t\t\t\t\t   descriptor received through\n\t\t\t\t\t   SCM_RIGHTS */\n#if defined(CONFIG_COMPAT)\n#define MSG_CMSG_COMPAT\t0x80000000\t/* This message needs 32 bit fixups */\n#else\n#define MSG_CMSG_COMPAT\t0\t\t/* We never have 32 bit fixups */\n#endif\n\n\n/* Setsockoptions(2) level. Thanks to BSD these must match IPPROTO_xxx */\n#define SOL_IP\t\t0\n/* #define SOL_ICMP\t1\tNo-no-no! Due to Linux :-) we cannot use SOL_ICMP=1 */\n#define SOL_TCP\t\t6\n#define SOL_UDP\t\t17\n#define SOL_IPV6\t41\n#define SOL_ICMPV6\t58\n#define SOL_SCTP\t132\n#define SOL_UDPLITE\t136     /* UDP-Lite (RFC 3828) */\n#define SOL_RAW\t\t255\n#define SOL_IPX\t\t256\n#define SOL_AX25\t257\n#define SOL_ATALK\t258\n#define SOL_NETROM\t259\n#define SOL_ROSE\t260\n#define SOL_DECNET\t261\n#define\tSOL_X25\t\t262\n#define SOL_PACKET\t263\n#define SOL_ATM\t\t264\t/* ATM layer (cell level) */\n#define SOL_AAL\t\t265\t/* ATM Adaption Layer (packet level) */\n#define SOL_IRDA        266\n#define SOL_NETBEUI\t267\n#define SOL_LLC\t\t268\n#define SOL_DCCP\t269\n#define SOL_NETLINK\t270\n#define SOL_TIPC\t271\n#define SOL_RXRPC\t272\n#define SOL_PPPOL2TP\t273\n#define SOL_BLUETOOTH\t274\n#define SOL_PNPIPE\t275\n#define SOL_RDS\t\t276\n#define SOL_IUCV\t277\n#define SOL_CAIF\t278\n#define SOL_ALG\t\t279\n#define SOL_NFC\t\t280\n#define SOL_KCM\t\t281\n#define SOL_TLS\t\t282\n#define SOL_XDP\t\t283\n\n/* IPX options */\n#define IPX_TYPE\t1\n\nextern int move_addr_to_kernel(void __user *uaddr, int ulen, struct sockaddr_storage *kaddr);\nextern int put_cmsg(struct msghdr*, int level, int type, int len, void *data);\n\nstruct timespec64;\nstruct __kernel_timespec;\nstruct old_timespec32;\n\nstruct scm_timestamping_internal {\n\tstruct timespec64 ts[3];\n};\n\nextern void put_cmsg_scm_timestamping64(struct msghdr *msg, struct scm_timestamping_internal *tss);\nextern void put_cmsg_scm_timestamping(struct msghdr *msg, struct scm_timestamping_internal *tss);\n\n/* The __sys_...msg variants allow MSG_CMSG_COMPAT iff\n * forbid_cmsg_compat==false\n */\nextern long __sys_recvmsg(int fd, struct user_msghdr __user *msg,\n\t\t\t  unsigned int flags, bool forbid_cmsg_compat);\nextern long __sys_sendmsg(int fd, struct user_msghdr __user *msg,\n\t\t\t  unsigned int flags, bool forbid_cmsg_compat);\nextern int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg,\n\t\t\t  unsigned int vlen, unsigned int flags,\n\t\t\t  struct __kernel_timespec __user *timeout,\n\t\t\t  struct old_timespec32 __user *timeout32);\nextern int __sys_sendmmsg(int fd, struct mmsghdr __user *mmsg,\n\t\t\t  unsigned int vlen, unsigned int flags,\n\t\t\t  bool forbid_cmsg_compat);\nextern long __sys_sendmsg_sock(struct socket *sock, struct msghdr *msg,\n\t\t\t       unsigned int flags);\nextern long __sys_recvmsg_sock(struct socket *sock, struct msghdr *msg,\n\t\t\t       struct user_msghdr __user *umsg,\n\t\t\t       struct sockaddr __user *uaddr,\n\t\t\t       unsigned int flags);\nextern int sendmsg_copy_msghdr(struct msghdr *msg,\n\t\t\t       struct user_msghdr __user *umsg, unsigned flags,\n\t\t\t       struct iovec **iov);\nextern int recvmsg_copy_msghdr(struct msghdr *msg,\n\t\t\t       struct user_msghdr __user *umsg, unsigned flags,\n\t\t\t       struct sockaddr __user **uaddr,\n\t\t\t       struct iovec **iov);\nextern int __copy_msghdr_from_user(struct msghdr *kmsg,\n\t\t\t\t   struct user_msghdr __user *umsg,\n\t\t\t\t   struct sockaddr __user **save_addr,\n\t\t\t\t   struct iovec __user **uiov, size_t *nsegs);\n\n/* helpers which do the actual work for syscalls */\nextern int __sys_recvfrom(int fd, void __user *ubuf, size_t size,\n\t\t\t  unsigned int flags, struct sockaddr __user *addr,\n\t\t\t  int __user *addr_len);\nextern int __sys_sendto(int fd, void __user *buff, size_t len,\n\t\t\tunsigned int flags, struct sockaddr __user *addr,\n\t\t\tint addr_len);\nextern int __sys_accept4_file(struct file *file, unsigned file_flags,\n\t\t\tstruct sockaddr __user *upeer_sockaddr,\n\t\t\t int __user *upeer_addrlen, int flags,\n\t\t\t unsigned long nofile);\nextern int __sys_accept4(int fd, struct sockaddr __user *upeer_sockaddr,\n\t\t\t int __user *upeer_addrlen, int flags);\nextern int __sys_socket(int family, int type, int protocol);\nextern int __sys_bind(int fd, struct sockaddr __user *umyaddr, int addrlen);\nextern int __sys_connect_file(struct file *file, struct sockaddr_storage *addr,\n\t\t\t      int addrlen, int file_flags);\nextern int __sys_connect(int fd, struct sockaddr __user *uservaddr,\n\t\t\t int addrlen);\nextern int __sys_listen(int fd, int backlog);\nextern int __sys_getsockname(int fd, struct sockaddr __user *usockaddr,\n\t\t\t     int __user *usockaddr_len);\nextern int __sys_getpeername(int fd, struct sockaddr __user *usockaddr,\n\t\t\t     int __user *usockaddr_len);\nextern int __sys_socketpair(int family, int type, int protocol,\n\t\t\t    int __user *usockvec);\nextern int __sys_shutdown_sock(struct socket *sock, int how);\nextern int __sys_shutdown(int fd, int how);\n\nextern struct ns_common *get_net_ns(struct ns_common *ns);\n#endif /* _LINUX_SOCKET_H */\n"}, "4": {"id": 4, "path": "/src/include/linux/build_bug.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_BUILD_BUG_H\n#define _LINUX_BUILD_BUG_H\n\n#include <linux/compiler.h>\n\n#ifdef __CHECKER__\n#define BUILD_BUG_ON_ZERO(e) (0)\n#else /* __CHECKER__ */\n/*\n * Force a compilation error if condition is true, but also produce a\n * result (of value 0 and type int), so the expression can be used\n * e.g. in a structure initializer (or where-ever else comma expressions\n * aren't permitted).\n */\n#define BUILD_BUG_ON_ZERO(e) ((int)(sizeof(struct { int:(-!!(e)); })))\n#endif /* __CHECKER__ */\n\n/* Force a compilation error if a constant expression is not a power of 2 */\n#define __BUILD_BUG_ON_NOT_POWER_OF_2(n)\t\\\n\tBUILD_BUG_ON(((n) & ((n) - 1)) != 0)\n#define BUILD_BUG_ON_NOT_POWER_OF_2(n)\t\t\t\\\n\tBUILD_BUG_ON((n) == 0 || (((n) & ((n) - 1)) != 0))\n\n/*\n * BUILD_BUG_ON_INVALID() permits the compiler to check the validity of the\n * expression but avoids the generation of any code, even if that expression\n * has side-effects.\n */\n#define BUILD_BUG_ON_INVALID(e) ((void)(sizeof((__force long)(e))))\n\n/**\n * BUILD_BUG_ON_MSG - break compile if a condition is true & emit supplied\n *\t\t      error message.\n * @condition: the condition which the compiler should know is false.\n *\n * See BUILD_BUG_ON for description.\n */\n#define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n\n/**\n * BUILD_BUG_ON - break compile if a condition is true.\n * @condition: the condition which the compiler should know is false.\n *\n * If you have some code which relies on certain constants being equal, or\n * some other compile-time-evaluated condition, you should use BUILD_BUG_ON to\n * detect if someone changes it.\n */\n#define BUILD_BUG_ON(condition) \\\n\tBUILD_BUG_ON_MSG(condition, \"BUILD_BUG_ON failed: \" #condition)\n\n/**\n * BUILD_BUG - break compile if used.\n *\n * If you have some code that you expect the compiler to eliminate at\n * build time, you should use BUILD_BUG to detect if it is\n * unexpectedly used.\n */\n#define BUILD_BUG() BUILD_BUG_ON_MSG(1, \"BUILD_BUG failed\")\n\n/**\n * static_assert - check integer constant expression at build time\n *\n * static_assert() is a wrapper for the C11 _Static_assert, with a\n * little macro magic to make the message optional (defaulting to the\n * stringification of the tested expression).\n *\n * Contrary to BUILD_BUG_ON(), static_assert() can be used at global\n * scope, but requires the expression to be an integer constant\n * expression (i.e., it is not enough that __builtin_constant_p() is\n * true for expr).\n *\n * Also note that BUILD_BUG_ON() fails the build if the condition is\n * true, while static_assert() fails the build if the expression is\n * false.\n */\n#define static_assert(expr, ...) __static_assert(expr, ##__VA_ARGS__, #expr)\n#define __static_assert(expr, msg, ...) _Static_assert(expr, msg)\n\n#endif\t/* _LINUX_BUILD_BUG_H */\n"}, "0": {"id": 0, "path": "/src/include/linux/virtio_net.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_VIRTIO_NET_H\n#define _LINUX_VIRTIO_NET_H\n\n#include <linux/if_vlan.h>\n#include <uapi/linux/tcp.h>\n#include <uapi/linux/udp.h>\n#include <uapi/linux/virtio_net.h>\n\nstatic inline int virtio_net_hdr_set_proto(struct sk_buff *skb,\n\t\t\t\t\t   const struct virtio_net_hdr *hdr)\n{\n\tswitch (hdr->gso_type & ~VIRTIO_NET_HDR_GSO_ECN) {\n\tcase VIRTIO_NET_HDR_GSO_TCPV4:\n\tcase VIRTIO_NET_HDR_GSO_UDP:\n\t\tskb->protocol = cpu_to_be16(ETH_P_IP);\n\t\tbreak;\n\tcase VIRTIO_NET_HDR_GSO_TCPV6:\n\t\tskb->protocol = cpu_to_be16(ETH_P_IPV6);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int virtio_net_hdr_to_skb(struct sk_buff *skb,\n\t\t\t\t\tconst struct virtio_net_hdr *hdr,\n\t\t\t\t\tbool little_endian)\n{\n\tunsigned int gso_type = 0;\n\tunsigned int thlen = 0;\n\tunsigned int p_off = 0;\n\tunsigned int ip_proto;\n\n\tif (hdr->gso_type != VIRTIO_NET_HDR_GSO_NONE) {\n\t\tswitch (hdr->gso_type & ~VIRTIO_NET_HDR_GSO_ECN) {\n\t\tcase VIRTIO_NET_HDR_GSO_TCPV4:\n\t\t\tgso_type = SKB_GSO_TCPV4;\n\t\t\tip_proto = IPPROTO_TCP;\n\t\t\tthlen = sizeof(struct tcphdr);\n\t\t\tbreak;\n\t\tcase VIRTIO_NET_HDR_GSO_TCPV6:\n\t\t\tgso_type = SKB_GSO_TCPV6;\n\t\t\tip_proto = IPPROTO_TCP;\n\t\t\tthlen = sizeof(struct tcphdr);\n\t\t\tbreak;\n\t\tcase VIRTIO_NET_HDR_GSO_UDP:\n\t\t\tgso_type = SKB_GSO_UDP;\n\t\t\tip_proto = IPPROTO_UDP;\n\t\t\tthlen = sizeof(struct udphdr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (hdr->gso_type & VIRTIO_NET_HDR_GSO_ECN)\n\t\t\tgso_type |= SKB_GSO_TCP_ECN;\n\n\t\tif (hdr->gso_size == 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) {\n\t\tu16 start = __virtio16_to_cpu(little_endian, hdr->csum_start);\n\t\tu16 off = __virtio16_to_cpu(little_endian, hdr->csum_offset);\n\n\t\tif (!skb_partial_csum_set(skb, start, off))\n\t\t\treturn -EINVAL;\n\n\t\tp_off = skb_transport_offset(skb) + thlen;\n\t\tif (p_off > skb_headlen(skb))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t/* gso packets without NEEDS_CSUM do not set transport_offset.\n\t\t * probe and drop if does not match one of the above types.\n\t\t */\n\t\tif (gso_type && skb->network_header) {\n\t\t\tstruct flow_keys_basic keys;\n\n\t\t\tif (!skb->protocol)\n\t\t\t\tvirtio_net_hdr_set_proto(skb, hdr);\nretry:\n\t\t\tif (!skb_flow_dissect_flow_keys_basic(NULL, skb, &keys,\n\t\t\t\t\t\t\t      NULL, 0, 0, 0,\n\t\t\t\t\t\t\t      0)) {\n\t\t\t\t/* UFO does not specify ipv4 or 6: try both */\n\t\t\t\tif (gso_type & SKB_GSO_UDP &&\n\t\t\t\t    skb->protocol == htons(ETH_P_IP)) {\n\t\t\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tp_off = keys.control.thoff + thlen;\n\t\t\tif (p_off > skb_headlen(skb) ||\n\t\t\t    keys.basic.ip_proto != ip_proto)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tskb_set_transport_header(skb, keys.control.thoff);\n\t\t} else if (gso_type) {\n\t\t\tp_off = thlen;\n\t\t\tif (p_off > skb_headlen(skb))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (hdr->gso_type != VIRTIO_NET_HDR_GSO_NONE) {\n\t\tu16 gso_size = __virtio16_to_cpu(little_endian, hdr->gso_size);\n\t\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\n\t\t/* Too small packets are not really GSO ones. */\n\t\tif (skb->len - p_off > gso_size) {\n\t\t\tshinfo->gso_size = gso_size;\n\t\t\tshinfo->gso_type = gso_type;\n\n\t\t\t/* Header must be checked, and gso_segs computed. */\n\t\t\tshinfo->gso_type |= SKB_GSO_DODGY;\n\t\t\tshinfo->gso_segs = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline int virtio_net_hdr_from_skb(const struct sk_buff *skb,\n\t\t\t\t\t  struct virtio_net_hdr *hdr,\n\t\t\t\t\t  bool little_endian,\n\t\t\t\t\t  bool has_data_valid,\n\t\t\t\t\t  int vlan_hlen)\n{\n\tmemset(hdr, 0, sizeof(*hdr));   /* no info leak */\n\n\tif (skb_is_gso(skb)) {\n\t\tstruct skb_shared_info *sinfo = skb_shinfo(skb);\n\n\t\t/* This is a hint as to how much should be linear. */\n\t\thdr->hdr_len = __cpu_to_virtio16(little_endian,\n\t\t\t\t\t\t skb_headlen(skb));\n\t\thdr->gso_size = __cpu_to_virtio16(little_endian,\n\t\t\t\t\t\t  sinfo->gso_size);\n\t\tif (sinfo->gso_type & SKB_GSO_TCPV4)\n\t\t\thdr->gso_type = VIRTIO_NET_HDR_GSO_TCPV4;\n\t\telse if (sinfo->gso_type & SKB_GSO_TCPV6)\n\t\t\thdr->gso_type = VIRTIO_NET_HDR_GSO_TCPV6;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tif (sinfo->gso_type & SKB_GSO_TCP_ECN)\n\t\t\thdr->gso_type |= VIRTIO_NET_HDR_GSO_ECN;\n\t} else\n\t\thdr->gso_type = VIRTIO_NET_HDR_GSO_NONE;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\thdr->flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\t\thdr->csum_start = __cpu_to_virtio16(little_endian,\n\t\t\tskb_checksum_start_offset(skb) + vlan_hlen);\n\t\thdr->csum_offset = __cpu_to_virtio16(little_endian,\n\t\t\t\tskb->csum_offset);\n\t} else if (has_data_valid &&\n\t\t   skb->ip_summed == CHECKSUM_UNNECESSARY) {\n\t\thdr->flags = VIRTIO_NET_HDR_F_DATA_VALID;\n\t} /* else everything is zero */\n\n\treturn 0;\n}\n\n#endif /* _LINUX_VIRTIO_NET_H */\n"}}, "reports": [{"events": [{"location": {"col": 6, "file": 1, "line": 3028}, "message": "Assuming field 'pg_vec' is non-null"}, {"location": {"col": 2, "file": 1, "line": 3028}, "message": "Taking true branch"}, {"location": {"col": 10, "file": 1, "line": 3029}, "message": "Calling 'tpacket_snd'"}, {"location": {"col": 2, "file": 1, "line": 2651}, "message": "'vnet_hdr' initialized to a null pointer value"}, {"location": {"col": 2, "file": 1, "line": 2656}, "message": "Taking false branch"}, {"location": {"col": 16, "file": 2, "line": 209}, "message": "expanded from macro 'DECLARE_SOCKADDR'"}, {"location": {"col": 2, "file": 3, "line": 19}, "message": "expanded from macro '__sockaddr_check_size'"}, {"location": {"col": 2, "file": 4, "line": 50}, "message": "expanded from macro 'BUILD_BUG_ON'"}, {"location": {"col": 6, "file": 0, "line": 37}, "message": "Access to field 'gso_type' results in a dereference of a null pointer (loaded from variable 'hdr')"}], "macros": [], "notes": [], "path": "/src/include/linux/virtio_net.h", "reportHash": "7e80fdd92ef151a7c7264d32337f9b9b", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
