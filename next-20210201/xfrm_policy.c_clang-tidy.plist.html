<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/net/xfrm/xfrm_policy.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * xfrm_policy.c\n *\n * Changes:\n *\tMitsuru KANDA @USAGI\n * \tKazunori MIYAZAWA @USAGI\n * \tKunihiro Ishiguro <kunihiro@ipinfusion.com>\n * \t\tIPv6 support\n * \tKazunori MIYAZAWA @USAGI\n * \tYOSHIFUJI Hideaki\n * \t\tSplit up af-specific portion\n *\tDerek Atkins <derek@ihtfp.com>\t\tAdd the post_input processor\n *\n */\n\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <linux/notifier.h>\n#include <linux/netdevice.h>\n#include <linux/netfilter.h>\n#include <linux/module.h>\n#include <linux/cache.h>\n#include <linux/cpu.h>\n#include <linux/audit.h>\n#include <linux/rhashtable.h>\n#include <linux/if_tunnel.h>\n#include <net/dst.h>\n#include <net/flow.h>\n#include <net/xfrm.h>\n#include <net/ip.h>\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n#include <net/mip6.h>\n#endif\n#ifdef CONFIG_XFRM_STATISTICS\n#include <net/snmp.h>\n#endif\n#ifdef CONFIG_XFRM_ESPINTCP\n#include <net/espintcp.h>\n#endif\n\n#include \"xfrm_hash.h\"\n\n#define XFRM_QUEUE_TMO_MIN ((unsigned)(HZ/10))\n#define XFRM_QUEUE_TMO_MAX ((unsigned)(60*HZ))\n#define XFRM_MAX_QUEUE_LEN\t100\n\nstruct xfrm_flo {\n\tstruct dst_entry *dst_orig;\n\tu8 flags;\n};\n\n/* prefixes smaller than this are stored in lists, not trees. */\n#define INEXACT_PREFIXLEN_IPV4\t16\n#define INEXACT_PREFIXLEN_IPV6\t48\n\nstruct xfrm_pol_inexact_node {\n\tstruct rb_node node;\n\tunion {\n\t\txfrm_address_t addr;\n\t\tstruct rcu_head rcu;\n\t};\n\tu8 prefixlen;\n\n\tstruct rb_root root;\n\n\t/* the policies matching this node, can be empty list */\n\tstruct hlist_head hhead;\n};\n\n/* xfrm inexact policy search tree:\n * xfrm_pol_inexact_bin = hash(dir,type,family,if_id);\n *  |\n * +---- root_d: sorted by daddr:prefix\n * |                 |\n * |        xfrm_pol_inexact_node\n * |                 |\n * |                 +- root: sorted by saddr/prefix\n * |                 |              |\n * |                 |         xfrm_pol_inexact_node\n * |                 |              |\n * |                 |              + root: unused\n * |                 |              |\n * |                 |              + hhead: saddr:daddr policies\n * |                 |\n * |                 +- coarse policies and all any:daddr policies\n * |\n * +---- root_s: sorted by saddr:prefix\n * |                 |\n * |        xfrm_pol_inexact_node\n * |                 |\n * |                 + root: unused\n * |                 |\n * |                 + hhead: saddr:any policies\n * |\n * +---- coarse policies and all any:any policies\n *\n * Lookups return four candidate lists:\n * 1. any:any list from top-level xfrm_pol_inexact_bin\n * 2. any:daddr list from daddr tree\n * 3. saddr:daddr list from 2nd level daddr tree\n * 4. saddr:any list from saddr tree\n *\n * This result set then needs to be searched for the policy with\n * the lowest priority.  If two results have same prio, youngest one wins.\n */\n\nstruct xfrm_pol_inexact_key {\n\tpossible_net_t net;\n\tu32 if_id;\n\tu16 family;\n\tu8 dir, type;\n};\n\nstruct xfrm_pol_inexact_bin {\n\tstruct xfrm_pol_inexact_key k;\n\tstruct rhash_head head;\n\t/* list containing '*:*' policies */\n\tstruct hlist_head hhead;\n\n\tseqcount_spinlock_t count;\n\t/* tree sorted by daddr/prefix */\n\tstruct rb_root root_d;\n\n\t/* tree sorted by saddr/prefix */\n\tstruct rb_root root_s;\n\n\t/* slow path below */\n\tstruct list_head inexact_bins;\n\tstruct rcu_head rcu;\n};\n\nenum xfrm_pol_inexact_candidate_type {\n\tXFRM_POL_CAND_BOTH,\n\tXFRM_POL_CAND_SADDR,\n\tXFRM_POL_CAND_DADDR,\n\tXFRM_POL_CAND_ANY,\n\n\tXFRM_POL_CAND_MAX,\n};\n\nstruct xfrm_pol_inexact_candidates {\n\tstruct hlist_head *res[XFRM_POL_CAND_MAX];\n};\n\nstatic DEFINE_SPINLOCK(xfrm_if_cb_lock);\nstatic struct xfrm_if_cb const __rcu *xfrm_if_cb __read_mostly;\n\nstatic DEFINE_SPINLOCK(xfrm_policy_afinfo_lock);\nstatic struct xfrm_policy_afinfo const __rcu *xfrm_policy_afinfo[AF_INET6 + 1]\n\t\t\t\t\t\t__read_mostly;\n\nstatic struct kmem_cache *xfrm_dst_cache __ro_after_init;\nstatic __read_mostly seqcount_mutex_t xfrm_policy_hash_generation;\n\nstatic struct rhashtable xfrm_policy_inexact_table;\nstatic const struct rhashtable_params xfrm_pol_inexact_params;\n\nstatic void xfrm_init_pmtu(struct xfrm_dst **bundle, int nr);\nstatic int stale_bundle(struct dst_entry *dst);\nstatic int xfrm_bundle_ok(struct xfrm_dst *xdst);\nstatic void xfrm_policy_queue_process(struct timer_list *t);\n\nstatic void __xfrm_policy_link(struct xfrm_policy *pol, int dir);\nstatic struct xfrm_policy *__xfrm_policy_unlink(struct xfrm_policy *pol,\n\t\t\t\t\t\tint dir);\n\nstatic struct xfrm_pol_inexact_bin *\nxfrm_policy_inexact_lookup(struct net *net, u8 type, u16 family, u8 dir,\n\t\t\t   u32 if_id);\n\nstatic struct xfrm_pol_inexact_bin *\nxfrm_policy_inexact_lookup_rcu(struct net *net,\n\t\t\t       u8 type, u16 family, u8 dir, u32 if_id);\nstatic struct xfrm_policy *\nxfrm_policy_insert_list(struct hlist_head *chain, struct xfrm_policy *policy,\n\t\t\tbool excl);\nstatic void xfrm_policy_insert_inexact_list(struct hlist_head *chain,\n\t\t\t\t\t    struct xfrm_policy *policy);\n\nstatic bool\nxfrm_policy_find_inexact_candidates(struct xfrm_pol_inexact_candidates *cand,\n\t\t\t\t    struct xfrm_pol_inexact_bin *b,\n\t\t\t\t    const xfrm_address_t *saddr,\n\t\t\t\t    const xfrm_address_t *daddr);\n\nstatic inline bool xfrm_pol_hold_rcu(struct xfrm_policy *policy)\n{\n\treturn refcount_inc_not_zero(&policy->refcnt);\n}\n\nstatic inline bool\n__xfrm4_selector_match(const struct xfrm_selector *sel, const struct flowi *fl)\n{\n\tconst struct flowi4 *fl4 = &fl->u.ip4;\n\n\treturn  addr4_match(fl4->daddr, sel->daddr.a4, sel->prefixlen_d) &&\n\t\taddr4_match(fl4->saddr, sel->saddr.a4, sel->prefixlen_s) &&\n\t\t!((xfrm_flowi_dport(fl, &fl4->uli) ^ sel->dport) & sel->dport_mask) &&\n\t\t!((xfrm_flowi_sport(fl, &fl4->uli) ^ sel->sport) & sel->sport_mask) &&\n\t\t(fl4->flowi4_proto == sel->proto || !sel->proto) &&\n\t\t(fl4->flowi4_oif == sel->ifindex || !sel->ifindex);\n}\n\nstatic inline bool\n__xfrm6_selector_match(const struct xfrm_selector *sel, const struct flowi *fl)\n{\n\tconst struct flowi6 *fl6 = &fl->u.ip6;\n\n\treturn  addr_match(&fl6->daddr, &sel->daddr, sel->prefixlen_d) &&\n\t\taddr_match(&fl6->saddr, &sel->saddr, sel->prefixlen_s) &&\n\t\t!((xfrm_flowi_dport(fl, &fl6->uli) ^ sel->dport) & sel->dport_mask) &&\n\t\t!((xfrm_flowi_sport(fl, &fl6->uli) ^ sel->sport) & sel->sport_mask) &&\n\t\t(fl6->flowi6_proto == sel->proto || !sel->proto) &&\n\t\t(fl6->flowi6_oif == sel->ifindex || !sel->ifindex);\n}\n\nbool xfrm_selector_match(const struct xfrm_selector *sel, const struct flowi *fl,\n\t\t\t unsigned short family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\treturn __xfrm4_selector_match(sel, fl);\n\tcase AF_INET6:\n\t\treturn __xfrm6_selector_match(sel, fl);\n\t}\n\treturn false;\n}\n\nstatic const struct xfrm_policy_afinfo *xfrm_policy_get_afinfo(unsigned short family)\n{\n\tconst struct xfrm_policy_afinfo *afinfo;\n\n\tif (unlikely(family >= ARRAY_SIZE(xfrm_policy_afinfo)))\n\t\treturn NULL;\n\trcu_read_lock();\n\tafinfo = rcu_dereference(xfrm_policy_afinfo[family]);\n\tif (unlikely(!afinfo))\n\t\trcu_read_unlock();\n\treturn afinfo;\n}\n\n/* Called with rcu_read_lock(). */\nstatic const struct xfrm_if_cb *xfrm_if_get_cb(void)\n{\n\treturn rcu_dereference(xfrm_if_cb);\n}\n\nstruct dst_entry *__xfrm_dst_lookup(struct net *net, int tos, int oif,\n\t\t\t\t    const xfrm_address_t *saddr,\n\t\t\t\t    const xfrm_address_t *daddr,\n\t\t\t\t    int family, u32 mark)\n{\n\tconst struct xfrm_policy_afinfo *afinfo;\n\tstruct dst_entry *dst;\n\n\tafinfo = xfrm_policy_get_afinfo(family);\n\tif (unlikely(afinfo == NULL))\n\t\treturn ERR_PTR(-EAFNOSUPPORT);\n\n\tdst = afinfo->dst_lookup(net, tos, oif, saddr, daddr, mark);\n\n\trcu_read_unlock();\n\n\treturn dst;\n}\nEXPORT_SYMBOL(__xfrm_dst_lookup);\n\nstatic inline struct dst_entry *xfrm_dst_lookup(struct xfrm_state *x,\n\t\t\t\t\t\tint tos, int oif,\n\t\t\t\t\t\txfrm_address_t *prev_saddr,\n\t\t\t\t\t\txfrm_address_t *prev_daddr,\n\t\t\t\t\t\tint family, u32 mark)\n{\n\tstruct net *net = xs_net(x);\n\txfrm_address_t *saddr = &x->props.saddr;\n\txfrm_address_t *daddr = &x->id.daddr;\n\tstruct dst_entry *dst;\n\n\tif (x->type->flags & XFRM_TYPE_LOCAL_COADDR) {\n\t\tsaddr = x->coaddr;\n\t\tdaddr = prev_daddr;\n\t}\n\tif (x->type->flags & XFRM_TYPE_REMOTE_COADDR) {\n\t\tsaddr = prev_saddr;\n\t\tdaddr = x->coaddr;\n\t}\n\n\tdst = __xfrm_dst_lookup(net, tos, oif, saddr, daddr, family, mark);\n\n\tif (!IS_ERR(dst)) {\n\t\tif (prev_saddr != saddr)\n\t\t\tmemcpy(prev_saddr, saddr,  sizeof(*prev_saddr));\n\t\tif (prev_daddr != daddr)\n\t\t\tmemcpy(prev_daddr, daddr,  sizeof(*prev_daddr));\n\t}\n\n\treturn dst;\n}\n\nstatic inline unsigned long make_jiffies(long secs)\n{\n\tif (secs >= (MAX_SCHEDULE_TIMEOUT-1)/HZ)\n\t\treturn MAX_SCHEDULE_TIMEOUT-1;\n\telse\n\t\treturn secs*HZ;\n}\n\nstatic void xfrm_policy_timer(struct timer_list *t)\n{\n\tstruct xfrm_policy *xp = from_timer(xp, t, timer);\n\ttime64_t now = ktime_get_real_seconds();\n\ttime64_t next = TIME64_MAX;\n\tint warn = 0;\n\tint dir;\n\n\tread_lock(&xp->lock);\n\n\tif (unlikely(xp->walk.dead))\n\t\tgoto out;\n\n\tdir = xfrm_policy_id2dir(xp->index);\n\n\tif (xp->lft.hard_add_expires_seconds) {\n\t\ttime64_t tmo = xp->lft.hard_add_expires_seconds +\n\t\t\txp->curlft.add_time - now;\n\t\tif (tmo <= 0)\n\t\t\tgoto expired;\n\t\tif (tmo < next)\n\t\t\tnext = tmo;\n\t}\n\tif (xp->lft.hard_use_expires_seconds) {\n\t\ttime64_t tmo = xp->lft.hard_use_expires_seconds +\n\t\t\t(xp->curlft.use_time ? : xp->curlft.add_time) - now;\n\t\tif (tmo <= 0)\n\t\t\tgoto expired;\n\t\tif (tmo < next)\n\t\t\tnext = tmo;\n\t}\n\tif (xp->lft.soft_add_expires_seconds) {\n\t\ttime64_t tmo = xp->lft.soft_add_expires_seconds +\n\t\t\txp->curlft.add_time - now;\n\t\tif (tmo <= 0) {\n\t\t\twarn = 1;\n\t\t\ttmo = XFRM_KM_TIMEOUT;\n\t\t}\n\t\tif (tmo < next)\n\t\t\tnext = tmo;\n\t}\n\tif (xp->lft.soft_use_expires_seconds) {\n\t\ttime64_t tmo = xp->lft.soft_use_expires_seconds +\n\t\t\t(xp->curlft.use_time ? : xp->curlft.add_time) - now;\n\t\tif (tmo <= 0) {\n\t\t\twarn = 1;\n\t\t\ttmo = XFRM_KM_TIMEOUT;\n\t\t}\n\t\tif (tmo < next)\n\t\t\tnext = tmo;\n\t}\n\n\tif (warn)\n\t\tkm_policy_expired(xp, dir, 0, 0);\n\tif (next != TIME64_MAX &&\n\t    !mod_timer(&xp->timer, jiffies + make_jiffies(next)))\n\t\txfrm_pol_hold(xp);\n\nout:\n\tread_unlock(&xp->lock);\n\txfrm_pol_put(xp);\n\treturn;\n\nexpired:\n\tread_unlock(&xp->lock);\n\tif (!xfrm_policy_delete(xp, dir))\n\t\tkm_policy_expired(xp, dir, 1, 0);\n\txfrm_pol_put(xp);\n}\n\n/* Allocate xfrm_policy. Not used here, it is supposed to be used by pfkeyv2\n * SPD calls.\n */\n\nstruct xfrm_policy *xfrm_policy_alloc(struct net *net, gfp_t gfp)\n{\n\tstruct xfrm_policy *policy;\n\n\tpolicy = kzalloc(sizeof(struct xfrm_policy), gfp);\n\n\tif (policy) {\n\t\twrite_pnet(&policy->xp_net, net);\n\t\tINIT_LIST_HEAD(&policy->walk.all);\n\t\tINIT_HLIST_NODE(&policy->bydst_inexact_list);\n\t\tINIT_HLIST_NODE(&policy->bydst);\n\t\tINIT_HLIST_NODE(&policy->byidx);\n\t\trwlock_init(&policy->lock);\n\t\trefcount_set(&policy->refcnt, 1);\n\t\tskb_queue_head_init(&policy->polq.hold_queue);\n\t\ttimer_setup(&policy->timer, xfrm_policy_timer, 0);\n\t\ttimer_setup(&policy->polq.hold_timer,\n\t\t\t    xfrm_policy_queue_process, 0);\n\t}\n\treturn policy;\n}\nEXPORT_SYMBOL(xfrm_policy_alloc);\n\nstatic void xfrm_policy_destroy_rcu(struct rcu_head *head)\n{\n\tstruct xfrm_policy *policy = container_of(head, struct xfrm_policy, rcu);\n\n\tsecurity_xfrm_policy_free(policy->security);\n\tkfree(policy);\n}\n\n/* Destroy xfrm_policy: descendant resources must be released to this moment. */\n\nvoid xfrm_policy_destroy(struct xfrm_policy *policy)\n{\n\tBUG_ON(!policy->walk.dead);\n\n\tif (del_timer(&policy->timer) || del_timer(&policy->polq.hold_timer))\n\t\tBUG();\n\n\tcall_rcu(&policy->rcu, xfrm_policy_destroy_rcu);\n}\nEXPORT_SYMBOL(xfrm_policy_destroy);\n\n/* Rule must be locked. Release descendant resources, announce\n * entry dead. The rule must be unlinked from lists to the moment.\n */\n\nstatic void xfrm_policy_kill(struct xfrm_policy *policy)\n{\n\twrite_lock_bh(&policy->lock);\n\tpolicy->walk.dead = 1;\n\twrite_unlock_bh(&policy->lock);\n\n\tatomic_inc(&policy->genid);\n\n\tif (del_timer(&policy->polq.hold_timer))\n\t\txfrm_pol_put(policy);\n\tskb_queue_purge(&policy->polq.hold_queue);\n\n\tif (del_timer(&policy->timer))\n\t\txfrm_pol_put(policy);\n\n\txfrm_pol_put(policy);\n}\n\nstatic unsigned int xfrm_policy_hashmax __read_mostly = 1 * 1024 * 1024;\n\nstatic inline unsigned int idx_hash(struct net *net, u32 index)\n{\n\treturn __idx_hash(index, net->xfrm.policy_idx_hmask);\n}\n\n/* calculate policy hash thresholds */\nstatic void __get_hash_thresh(struct net *net,\n\t\t\t      unsigned short family, int dir,\n\t\t\t      u8 *dbits, u8 *sbits)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\t*dbits = net->xfrm.policy_bydst[dir].dbits4;\n\t\t*sbits = net->xfrm.policy_bydst[dir].sbits4;\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\t*dbits = net->xfrm.policy_bydst[dir].dbits6;\n\t\t*sbits = net->xfrm.policy_bydst[dir].sbits6;\n\t\tbreak;\n\n\tdefault:\n\t\t*dbits = 0;\n\t\t*sbits = 0;\n\t}\n}\n\nstatic struct hlist_head *policy_hash_bysel(struct net *net,\n\t\t\t\t\t    const struct xfrm_selector *sel,\n\t\t\t\t\t    unsigned short family, int dir)\n{\n\tunsigned int hmask = net->xfrm.policy_bydst[dir].hmask;\n\tunsigned int hash;\n\tu8 dbits;\n\tu8 sbits;\n\n\t__get_hash_thresh(net, family, dir, &dbits, &sbits);\n\thash = __sel_hash(sel, family, hmask, dbits, sbits);\n\n\tif (hash == hmask + 1)\n\t\treturn NULL;\n\n\treturn rcu_dereference_check(net->xfrm.policy_bydst[dir].table,\n\t\t     lockdep_is_held(&net->xfrm.xfrm_policy_lock)) + hash;\n}\n\nstatic struct hlist_head *policy_hash_direct(struct net *net,\n\t\t\t\t\t     const xfrm_address_t *daddr,\n\t\t\t\t\t     const xfrm_address_t *saddr,\n\t\t\t\t\t     unsigned short family, int dir)\n{\n\tunsigned int hmask = net->xfrm.policy_bydst[dir].hmask;\n\tunsigned int hash;\n\tu8 dbits;\n\tu8 sbits;\n\n\t__get_hash_thresh(net, family, dir, &dbits, &sbits);\n\thash = __addr_hash(daddr, saddr, family, hmask, dbits, sbits);\n\n\treturn rcu_dereference_check(net->xfrm.policy_bydst[dir].table,\n\t\t     lockdep_is_held(&net->xfrm.xfrm_policy_lock)) + hash;\n}\n\nstatic void xfrm_dst_hash_transfer(struct net *net,\n\t\t\t\t   struct hlist_head *list,\n\t\t\t\t   struct hlist_head *ndsttable,\n\t\t\t\t   unsigned int nhashmask,\n\t\t\t\t   int dir)\n{\n\tstruct hlist_node *tmp, *entry0 = NULL;\n\tstruct xfrm_policy *pol;\n\tunsigned int h0 = 0;\n\tu8 dbits;\n\tu8 sbits;\n\nredo:\n\thlist_for_each_entry_safe(pol, tmp, list, bydst) {\n\t\tunsigned int h;\n\n\t\t__get_hash_thresh(net, pol->family, dir, &dbits, &sbits);\n\t\th = __addr_hash(&pol->selector.daddr, &pol->selector.saddr,\n\t\t\t\tpol->family, nhashmask, dbits, sbits);\n\t\tif (!entry0) {\n\t\t\thlist_del_rcu(&pol->bydst);\n\t\t\thlist_add_head_rcu(&pol->bydst, ndsttable + h);\n\t\t\th0 = h;\n\t\t} else {\n\t\t\tif (h != h0)\n\t\t\t\tcontinue;\n\t\t\thlist_del_rcu(&pol->bydst);\n\t\t\thlist_add_behind_rcu(&pol->bydst, entry0);\n\t\t}\n\t\tentry0 = &pol->bydst;\n\t}\n\tif (!hlist_empty(list)) {\n\t\tentry0 = NULL;\n\t\tgoto redo;\n\t}\n}\n\nstatic void xfrm_idx_hash_transfer(struct hlist_head *list,\n\t\t\t\t   struct hlist_head *nidxtable,\n\t\t\t\t   unsigned int nhashmask)\n{\n\tstruct hlist_node *tmp;\n\tstruct xfrm_policy *pol;\n\n\thlist_for_each_entry_safe(pol, tmp, list, byidx) {\n\t\tunsigned int h;\n\n\t\th = __idx_hash(pol->index, nhashmask);\n\t\thlist_add_head(&pol->byidx, nidxtable+h);\n\t}\n}\n\nstatic unsigned long xfrm_new_hash_mask(unsigned int old_hmask)\n{\n\treturn ((old_hmask + 1) << 1) - 1;\n}\n\nstatic void xfrm_bydst_resize(struct net *net, int dir)\n{\n\tunsigned int hmask = net->xfrm.policy_bydst[dir].hmask;\n\tunsigned int nhashmask = xfrm_new_hash_mask(hmask);\n\tunsigned int nsize = (nhashmask + 1) * sizeof(struct hlist_head);\n\tstruct hlist_head *ndst = xfrm_hash_alloc(nsize);\n\tstruct hlist_head *odst;\n\tint i;\n\n\tif (!ndst)\n\t\treturn;\n\n\tspin_lock_bh(&net->xfrm.xfrm_policy_lock);\n\twrite_seqcount_begin(&xfrm_policy_hash_generation);\n\n\todst = rcu_dereference_protected(net->xfrm.policy_bydst[dir].table,\n\t\t\t\tlockdep_is_held(&net->xfrm.xfrm_policy_lock));\n\n\tfor (i = hmask; i >= 0; i--)\n\t\txfrm_dst_hash_transfer(net, odst + i, ndst, nhashmask, dir);\n\n\trcu_assign_pointer(net->xfrm.policy_bydst[dir].table, ndst);\n\tnet->xfrm.policy_bydst[dir].hmask = nhashmask;\n\n\twrite_seqcount_end(&xfrm_policy_hash_generation);\n\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\n\tsynchronize_rcu();\n\n\txfrm_hash_free(odst, (hmask + 1) * sizeof(struct hlist_head));\n}\n\nstatic void xfrm_byidx_resize(struct net *net, int total)\n{\n\tunsigned int hmask = net->xfrm.policy_idx_hmask;\n\tunsigned int nhashmask = xfrm_new_hash_mask(hmask);\n\tunsigned int nsize = (nhashmask + 1) * sizeof(struct hlist_head);\n\tstruct hlist_head *oidx = net->xfrm.policy_byidx;\n\tstruct hlist_head *nidx = xfrm_hash_alloc(nsize);\n\tint i;\n\n\tif (!nidx)\n\t\treturn;\n\n\tspin_lock_bh(&net->xfrm.xfrm_policy_lock);\n\n\tfor (i = hmask; i >= 0; i--)\n\t\txfrm_idx_hash_transfer(oidx + i, nidx, nhashmask);\n\n\tnet->xfrm.policy_byidx = nidx;\n\tnet->xfrm.policy_idx_hmask = nhashmask;\n\n\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\n\txfrm_hash_free(oidx, (hmask + 1) * sizeof(struct hlist_head));\n}\n\nstatic inline int xfrm_bydst_should_resize(struct net *net, int dir, int *total)\n{\n\tunsigned int cnt = net->xfrm.policy_count[dir];\n\tunsigned int hmask = net->xfrm.policy_bydst[dir].hmask;\n\n\tif (total)\n\t\t*total += cnt;\n\n\tif ((hmask + 1) < xfrm_policy_hashmax &&\n\t    cnt > hmask)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic inline int xfrm_byidx_should_resize(struct net *net, int total)\n{\n\tunsigned int hmask = net->xfrm.policy_idx_hmask;\n\n\tif ((hmask + 1) < xfrm_policy_hashmax &&\n\t    total > hmask)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nvoid xfrm_spd_getinfo(struct net *net, struct xfrmk_spdinfo *si)\n{\n\tsi->incnt = net->xfrm.policy_count[XFRM_POLICY_IN];\n\tsi->outcnt = net->xfrm.policy_count[XFRM_POLICY_OUT];\n\tsi->fwdcnt = net->xfrm.policy_count[XFRM_POLICY_FWD];\n\tsi->inscnt = net->xfrm.policy_count[XFRM_POLICY_IN+XFRM_POLICY_MAX];\n\tsi->outscnt = net->xfrm.policy_count[XFRM_POLICY_OUT+XFRM_POLICY_MAX];\n\tsi->fwdscnt = net->xfrm.policy_count[XFRM_POLICY_FWD+XFRM_POLICY_MAX];\n\tsi->spdhcnt = net->xfrm.policy_idx_hmask;\n\tsi->spdhmcnt = xfrm_policy_hashmax;\n}\nEXPORT_SYMBOL(xfrm_spd_getinfo);\n\nstatic DEFINE_MUTEX(hash_resize_mutex);\nstatic void xfrm_hash_resize(struct work_struct *work)\n{\n\tstruct net *net = container_of(work, struct net, xfrm.policy_hash_work);\n\tint dir, total;\n\n\tmutex_lock(&hash_resize_mutex);\n\n\ttotal = 0;\n\tfor (dir = 0; dir < XFRM_POLICY_MAX; dir++) {\n\t\tif (xfrm_bydst_should_resize(net, dir, &total))\n\t\t\txfrm_bydst_resize(net, dir);\n\t}\n\tif (xfrm_byidx_should_resize(net, total))\n\t\txfrm_byidx_resize(net, total);\n\n\tmutex_unlock(&hash_resize_mutex);\n}\n\n/* Make sure *pol can be inserted into fastbin.\n * Useful to check that later insert requests will be sucessful\n * (provided xfrm_policy_lock is held throughout).\n */\nstatic struct xfrm_pol_inexact_bin *\nxfrm_policy_inexact_alloc_bin(const struct xfrm_policy *pol, u8 dir)\n{\n\tstruct xfrm_pol_inexact_bin *bin, *prev;\n\tstruct xfrm_pol_inexact_key k = {\n\t\t.family = pol->family,\n\t\t.type = pol->type,\n\t\t.dir = dir,\n\t\t.if_id = pol->if_id,\n\t};\n\tstruct net *net = xp_net(pol);\n\n\tlockdep_assert_held(&net->xfrm.xfrm_policy_lock);\n\n\twrite_pnet(&k.net, net);\n\tbin = rhashtable_lookup_fast(&xfrm_policy_inexact_table, &k,\n\t\t\t\t     xfrm_pol_inexact_params);\n\tif (bin)\n\t\treturn bin;\n\n\tbin = kzalloc(sizeof(*bin), GFP_ATOMIC);\n\tif (!bin)\n\t\treturn NULL;\n\n\tbin->k = k;\n\tINIT_HLIST_HEAD(&bin->hhead);\n\tbin->root_d = RB_ROOT;\n\tbin->root_s = RB_ROOT;\n\tseqcount_spinlock_init(&bin->count, &net->xfrm.xfrm_policy_lock);\n\n\tprev = rhashtable_lookup_get_insert_key(&xfrm_policy_inexact_table,\n\t\t\t\t\t\t&bin->k, &bin->head,\n\t\t\t\t\t\txfrm_pol_inexact_params);\n\tif (!prev) {\n\t\tlist_add(&bin->inexact_bins, &net->xfrm.inexact_bins);\n\t\treturn bin;\n\t}\n\n\tkfree(bin);\n\n\treturn IS_ERR(prev) ? NULL : prev;\n}\n\nstatic bool xfrm_pol_inexact_addr_use_any_list(const xfrm_address_t *addr,\n\t\t\t\t\t       int family, u8 prefixlen)\n{\n\tif (xfrm_addr_any(addr, family))\n\t\treturn true;\n\n\tif (family == AF_INET6 && prefixlen < INEXACT_PREFIXLEN_IPV6)\n\t\treturn true;\n\n\tif (family == AF_INET && prefixlen < INEXACT_PREFIXLEN_IPV4)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool\nxfrm_policy_inexact_insert_use_any_list(const struct xfrm_policy *policy)\n{\n\tconst xfrm_address_t *addr;\n\tbool saddr_any, daddr_any;\n\tu8 prefixlen;\n\n\taddr = &policy->selector.saddr;\n\tprefixlen = policy->selector.prefixlen_s;\n\n\tsaddr_any = xfrm_pol_inexact_addr_use_any_list(addr,\n\t\t\t\t\t\t       policy->family,\n\t\t\t\t\t\t       prefixlen);\n\taddr = &policy->selector.daddr;\n\tprefixlen = policy->selector.prefixlen_d;\n\tdaddr_any = xfrm_pol_inexact_addr_use_any_list(addr,\n\t\t\t\t\t\t       policy->family,\n\t\t\t\t\t\t       prefixlen);\n\treturn saddr_any && daddr_any;\n}\n\nstatic void xfrm_pol_inexact_node_init(struct xfrm_pol_inexact_node *node,\n\t\t\t\t       const xfrm_address_t *addr, u8 prefixlen)\n{\n\tnode->addr = *addr;\n\tnode->prefixlen = prefixlen;\n}\n\nstatic struct xfrm_pol_inexact_node *\nxfrm_pol_inexact_node_alloc(const xfrm_address_t *addr, u8 prefixlen)\n{\n\tstruct xfrm_pol_inexact_node *node;\n\n\tnode = kzalloc(sizeof(*node), GFP_ATOMIC);\n\tif (node)\n\t\txfrm_pol_inexact_node_init(node, addr, prefixlen);\n\n\treturn node;\n}\n\nstatic int xfrm_policy_addr_delta(const xfrm_address_t *a,\n\t\t\t\t  const xfrm_address_t *b,\n\t\t\t\t  u8 prefixlen, u16 family)\n{\n\tu32 ma, mb, mask;\n\tunsigned int pdw, pbi;\n\tint delta = 0;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\tif (prefixlen == 0)\n\t\t\treturn 0;\n\t\tmask = ~0U << (32 - prefixlen);\n\t\tma = ntohl(a->a4) & mask;\n\t\tmb = ntohl(b->a4) & mask;\n\t\tif (ma < mb)\n\t\t\tdelta = -1;\n\t\telse if (ma > mb)\n\t\t\tdelta = 1;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tpdw = prefixlen >> 5;\n\t\tpbi = prefixlen & 0x1f;\n\n\t\tif (pdw) {\n\t\t\tdelta = memcmp(a->a6, b->a6, pdw << 2);\n\t\t\tif (delta)\n\t\t\t\treturn delta;\n\t\t}\n\t\tif (pbi) {\n\t\t\tmask = ~0U << (32 - pbi);\n\t\t\tma = ntohl(a->a6[pdw]) & mask;\n\t\t\tmb = ntohl(b->a6[pdw]) & mask;\n\t\t\tif (ma < mb)\n\t\t\t\tdelta = -1;\n\t\t\telse if (ma > mb)\n\t\t\t\tdelta = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn delta;\n}\n\nstatic void xfrm_policy_inexact_list_reinsert(struct net *net,\n\t\t\t\t\t      struct xfrm_pol_inexact_node *n,\n\t\t\t\t\t      u16 family)\n{\n\tunsigned int matched_s, matched_d;\n\tstruct xfrm_policy *policy, *p;\n\n\tmatched_s = 0;\n\tmatched_d = 0;\n\n\tlist_for_each_entry_reverse(policy, &net->xfrm.policy_all, walk.all) {\n\t\tstruct hlist_node *newpos = NULL;\n\t\tbool matches_s, matches_d;\n\n\t\tif (!policy->bydst_reinsert)\n\t\t\tcontinue;\n\n\t\tWARN_ON_ONCE(policy->family != family);\n\n\t\tpolicy->bydst_reinsert = false;\n\t\thlist_for_each_entry(p, &n->hhead, bydst) {\n\t\t\tif (policy->priority > p->priority)\n\t\t\t\tnewpos = &p->bydst;\n\t\t\telse if (policy->priority == p->priority &&\n\t\t\t\t policy->pos > p->pos)\n\t\t\t\tnewpos = &p->bydst;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (newpos)\n\t\t\thlist_add_behind_rcu(&policy->bydst, newpos);\n\t\telse\n\t\t\thlist_add_head_rcu(&policy->bydst, &n->hhead);\n\n\t\t/* paranoia checks follow.\n\t\t * Check that the reinserted policy matches at least\n\t\t * saddr or daddr for current node prefix.\n\t\t *\n\t\t * Matching both is fine, matching saddr in one policy\n\t\t * (but not daddr) and then matching only daddr in another\n\t\t * is a bug.\n\t\t */\n\t\tmatches_s = xfrm_policy_addr_delta(&policy->selector.saddr,\n\t\t\t\t\t\t   &n->addr,\n\t\t\t\t\t\t   n->prefixlen,\n\t\t\t\t\t\t   family) == 0;\n\t\tmatches_d = xfrm_policy_addr_delta(&policy->selector.daddr,\n\t\t\t\t\t\t   &n->addr,\n\t\t\t\t\t\t   n->prefixlen,\n\t\t\t\t\t\t   family) == 0;\n\t\tif (matches_s && matches_d)\n\t\t\tcontinue;\n\n\t\tWARN_ON_ONCE(!matches_s && !matches_d);\n\t\tif (matches_s)\n\t\t\tmatched_s++;\n\t\tif (matches_d)\n\t\t\tmatched_d++;\n\t\tWARN_ON_ONCE(matched_s && matched_d);\n\t}\n}\n\nstatic void xfrm_policy_inexact_node_reinsert(struct net *net,\n\t\t\t\t\t      struct xfrm_pol_inexact_node *n,\n\t\t\t\t\t      struct rb_root *new,\n\t\t\t\t\t      u16 family)\n{\n\tstruct xfrm_pol_inexact_node *node;\n\tstruct rb_node **p, *parent;\n\n\t/* we should not have another subtree here */\n\tWARN_ON_ONCE(!RB_EMPTY_ROOT(&n->root));\nrestart:\n\tparent = NULL;\n\tp = &new->rb_node;\n\twhile (*p) {\n\t\tu8 prefixlen;\n\t\tint delta;\n\n\t\tparent = *p;\n\t\tnode = rb_entry(*p, struct xfrm_pol_inexact_node, node);\n\n\t\tprefixlen = min(node->prefixlen, n->prefixlen);\n\n\t\tdelta = xfrm_policy_addr_delta(&n->addr, &node->addr,\n\t\t\t\t\t       prefixlen, family);\n\t\tif (delta < 0) {\n\t\t\tp = &parent->rb_left;\n\t\t} else if (delta > 0) {\n\t\t\tp = &parent->rb_right;\n\t\t} else {\n\t\t\tbool same_prefixlen = node->prefixlen == n->prefixlen;\n\t\t\tstruct xfrm_policy *tmp;\n\n\t\t\thlist_for_each_entry(tmp, &n->hhead, bydst) {\n\t\t\t\ttmp->bydst_reinsert = true;\n\t\t\t\thlist_del_rcu(&tmp->bydst);\n\t\t\t}\n\n\t\t\tnode->prefixlen = prefixlen;\n\n\t\t\txfrm_policy_inexact_list_reinsert(net, node, family);\n\n\t\t\tif (same_prefixlen) {\n\t\t\t\tkfree_rcu(n, rcu);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\trb_erase(*p, new);\n\t\t\tkfree_rcu(n, rcu);\n\t\t\tn = node;\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\trb_link_node_rcu(&n->node, parent, p);\n\trb_insert_color(&n->node, new);\n}\n\n/* merge nodes v and n */\nstatic void xfrm_policy_inexact_node_merge(struct net *net,\n\t\t\t\t\t   struct xfrm_pol_inexact_node *v,\n\t\t\t\t\t   struct xfrm_pol_inexact_node *n,\n\t\t\t\t\t   u16 family)\n{\n\tstruct xfrm_pol_inexact_node *node;\n\tstruct xfrm_policy *tmp;\n\tstruct rb_node *rnode;\n\n\t/* To-be-merged node v has a subtree.\n\t *\n\t * Dismantle it and insert its nodes to n->root.\n\t */\n\twhile ((rnode = rb_first(&v->root)) != NULL) {\n\t\tnode = rb_entry(rnode, struct xfrm_pol_inexact_node, node);\n\t\trb_erase(&node->node, &v->root);\n\t\txfrm_policy_inexact_node_reinsert(net, node, &n->root,\n\t\t\t\t\t\t  family);\n\t}\n\n\thlist_for_each_entry(tmp, &v->hhead, bydst) {\n\t\ttmp->bydst_reinsert = true;\n\t\thlist_del_rcu(&tmp->bydst);\n\t}\n\n\txfrm_policy_inexact_list_reinsert(net, n, family);\n}\n\nstatic struct xfrm_pol_inexact_node *\nxfrm_policy_inexact_insert_node(struct net *net,\n\t\t\t\tstruct rb_root *root,\n\t\t\t\txfrm_address_t *addr,\n\t\t\t\tu16 family, u8 prefixlen, u8 dir)\n{\n\tstruct xfrm_pol_inexact_node *cached = NULL;\n\tstruct rb_node **p, *parent = NULL;\n\tstruct xfrm_pol_inexact_node *node;\n\n\tp = &root->rb_node;\n\twhile (*p) {\n\t\tint delta;\n\n\t\tparent = *p;\n\t\tnode = rb_entry(*p, struct xfrm_pol_inexact_node, node);\n\n\t\tdelta = xfrm_policy_addr_delta(addr, &node->addr,\n\t\t\t\t\t       node->prefixlen,\n\t\t\t\t\t       family);\n\t\tif (delta == 0 && prefixlen >= node->prefixlen) {\n\t\t\tWARN_ON_ONCE(cached); /* ipsec policies got lost */\n\t\t\treturn node;\n\t\t}\n\n\t\tif (delta < 0)\n\t\t\tp = &parent->rb_left;\n\t\telse\n\t\t\tp = &parent->rb_right;\n\n\t\tif (prefixlen < node->prefixlen) {\n\t\t\tdelta = xfrm_policy_addr_delta(addr, &node->addr,\n\t\t\t\t\t\t       prefixlen,\n\t\t\t\t\t\t       family);\n\t\t\tif (delta)\n\t\t\t\tcontinue;\n\n\t\t\t/* This node is a subnet of the new prefix. It needs\n\t\t\t * to be removed and re-inserted with the smaller\n\t\t\t * prefix and all nodes that are now also covered\n\t\t\t * by the reduced prefixlen.\n\t\t\t */\n\t\t\trb_erase(&node->node, root);\n\n\t\t\tif (!cached) {\n\t\t\t\txfrm_pol_inexact_node_init(node, addr,\n\t\t\t\t\t\t\t   prefixlen);\n\t\t\t\tcached = node;\n\t\t\t} else {\n\t\t\t\t/* This node also falls within the new\n\t\t\t\t * prefixlen. Merge the to-be-reinserted\n\t\t\t\t * node and this one.\n\t\t\t\t */\n\t\t\t\txfrm_policy_inexact_node_merge(net, node,\n\t\t\t\t\t\t\t       cached, family);\n\t\t\t\tkfree_rcu(node, rcu);\n\t\t\t}\n\n\t\t\t/* restart */\n\t\t\tp = &root->rb_node;\n\t\t\tparent = NULL;\n\t\t}\n\t}\n\n\tnode = cached;\n\tif (!node) {\n\t\tnode = xfrm_pol_inexact_node_alloc(addr, prefixlen);\n\t\tif (!node)\n\t\t\treturn NULL;\n\t}\n\n\trb_link_node_rcu(&node->node, parent, p);\n\trb_insert_color(&node->node, root);\n\n\treturn node;\n}\n\nstatic void xfrm_policy_inexact_gc_tree(struct rb_root *r, bool rm)\n{\n\tstruct xfrm_pol_inexact_node *node;\n\tstruct rb_node *rn = rb_first(r);\n\n\twhile (rn) {\n\t\tnode = rb_entry(rn, struct xfrm_pol_inexact_node, node);\n\n\t\txfrm_policy_inexact_gc_tree(&node->root, rm);\n\t\trn = rb_next(rn);\n\n\t\tif (!hlist_empty(&node->hhead) || !RB_EMPTY_ROOT(&node->root)) {\n\t\t\tWARN_ON_ONCE(rm);\n\t\t\tcontinue;\n\t\t}\n\n\t\trb_erase(&node->node, r);\n\t\tkfree_rcu(node, rcu);\n\t}\n}\n\nstatic void __xfrm_policy_inexact_prune_bin(struct xfrm_pol_inexact_bin *b, bool net_exit)\n{\n\twrite_seqcount_begin(&b->count);\n\txfrm_policy_inexact_gc_tree(&b->root_d, net_exit);\n\txfrm_policy_inexact_gc_tree(&b->root_s, net_exit);\n\twrite_seqcount_end(&b->count);\n\n\tif (!RB_EMPTY_ROOT(&b->root_d) || !RB_EMPTY_ROOT(&b->root_s) ||\n\t    !hlist_empty(&b->hhead)) {\n\t\tWARN_ON_ONCE(net_exit);\n\t\treturn;\n\t}\n\n\tif (rhashtable_remove_fast(&xfrm_policy_inexact_table, &b->head,\n\t\t\t\t   xfrm_pol_inexact_params) == 0) {\n\t\tlist_del(&b->inexact_bins);\n\t\tkfree_rcu(b, rcu);\n\t}\n}\n\nstatic void xfrm_policy_inexact_prune_bin(struct xfrm_pol_inexact_bin *b)\n{\n\tstruct net *net = read_pnet(&b->k.net);\n\n\tspin_lock_bh(&net->xfrm.xfrm_policy_lock);\n\t__xfrm_policy_inexact_prune_bin(b, false);\n\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n}\n\nstatic void __xfrm_policy_inexact_flush(struct net *net)\n{\n\tstruct xfrm_pol_inexact_bin *bin, *t;\n\n\tlockdep_assert_held(&net->xfrm.xfrm_policy_lock);\n\n\tlist_for_each_entry_safe(bin, t, &net->xfrm.inexact_bins, inexact_bins)\n\t\t__xfrm_policy_inexact_prune_bin(bin, false);\n}\n\nstatic struct hlist_head *\nxfrm_policy_inexact_alloc_chain(struct xfrm_pol_inexact_bin *bin,\n\t\t\t\tstruct xfrm_policy *policy, u8 dir)\n{\n\tstruct xfrm_pol_inexact_node *n;\n\tstruct net *net;\n\n\tnet = xp_net(policy);\n\tlockdep_assert_held(&net->xfrm.xfrm_policy_lock);\n\n\tif (xfrm_policy_inexact_insert_use_any_list(policy))\n\t\treturn &bin->hhead;\n\n\tif (xfrm_pol_inexact_addr_use_any_list(&policy->selector.daddr,\n\t\t\t\t\t       policy->family,\n\t\t\t\t\t       policy->selector.prefixlen_d)) {\n\t\twrite_seqcount_begin(&bin->count);\n\t\tn = xfrm_policy_inexact_insert_node(net,\n\t\t\t\t\t\t    &bin->root_s,\n\t\t\t\t\t\t    &policy->selector.saddr,\n\t\t\t\t\t\t    policy->family,\n\t\t\t\t\t\t    policy->selector.prefixlen_s,\n\t\t\t\t\t\t    dir);\n\t\twrite_seqcount_end(&bin->count);\n\t\tif (!n)\n\t\t\treturn NULL;\n\n\t\treturn &n->hhead;\n\t}\n\n\t/* daddr is fixed */\n\twrite_seqcount_begin(&bin->count);\n\tn = xfrm_policy_inexact_insert_node(net,\n\t\t\t\t\t    &bin->root_d,\n\t\t\t\t\t    &policy->selector.daddr,\n\t\t\t\t\t    policy->family,\n\t\t\t\t\t    policy->selector.prefixlen_d, dir);\n\twrite_seqcount_end(&bin->count);\n\tif (!n)\n\t\treturn NULL;\n\n\t/* saddr is wildcard */\n\tif (xfrm_pol_inexact_addr_use_any_list(&policy->selector.saddr,\n\t\t\t\t\t       policy->family,\n\t\t\t\t\t       policy->selector.prefixlen_s))\n\t\treturn &n->hhead;\n\n\twrite_seqcount_begin(&bin->count);\n\tn = xfrm_policy_inexact_insert_node(net,\n\t\t\t\t\t    &n->root,\n\t\t\t\t\t    &policy->selector.saddr,\n\t\t\t\t\t    policy->family,\n\t\t\t\t\t    policy->selector.prefixlen_s, dir);\n\twrite_seqcount_end(&bin->count);\n\tif (!n)\n\t\treturn NULL;\n\n\treturn &n->hhead;\n}\n\nstatic struct xfrm_policy *\nxfrm_policy_inexact_insert(struct xfrm_policy *policy, u8 dir, int excl)\n{\n\tstruct xfrm_pol_inexact_bin *bin;\n\tstruct xfrm_policy *delpol;\n\tstruct hlist_head *chain;\n\tstruct net *net;\n\n\tbin = xfrm_policy_inexact_alloc_bin(policy, dir);\n\tif (!bin)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnet = xp_net(policy);\n\tlockdep_assert_held(&net->xfrm.xfrm_policy_lock);\n\n\tchain = xfrm_policy_inexact_alloc_chain(bin, policy, dir);\n\tif (!chain) {\n\t\t__xfrm_policy_inexact_prune_bin(bin, false);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdelpol = xfrm_policy_insert_list(chain, policy, excl);\n\tif (delpol && excl) {\n\t\t__xfrm_policy_inexact_prune_bin(bin, false);\n\t\treturn ERR_PTR(-EEXIST);\n\t}\n\n\tchain = &net->xfrm.policy_inexact[dir];\n\txfrm_policy_insert_inexact_list(chain, policy);\n\n\tif (delpol)\n\t\t__xfrm_policy_inexact_prune_bin(bin, false);\n\n\treturn delpol;\n}\n\nstatic void xfrm_hash_rebuild(struct work_struct *work)\n{\n\tstruct net *net = container_of(work, struct net,\n\t\t\t\t       xfrm.policy_hthresh.work);\n\tunsigned int hmask;\n\tstruct xfrm_policy *pol;\n\tstruct xfrm_policy *policy;\n\tstruct hlist_head *chain;\n\tstruct hlist_head *odst;\n\tstruct hlist_node *newpos;\n\tint i;\n\tint dir;\n\tunsigned seq;\n\tu8 lbits4, rbits4, lbits6, rbits6;\n\n\tmutex_lock(&hash_resize_mutex);\n\n\t/* read selector prefixlen thresholds */\n\tdo {\n\t\tseq = read_seqbegin(&net->xfrm.policy_hthresh.lock);\n\n\t\tlbits4 = net->xfrm.policy_hthresh.lbits4;\n\t\trbits4 = net->xfrm.policy_hthresh.rbits4;\n\t\tlbits6 = net->xfrm.policy_hthresh.lbits6;\n\t\trbits6 = net->xfrm.policy_hthresh.rbits6;\n\t} while (read_seqretry(&net->xfrm.policy_hthresh.lock, seq));\n\n\tspin_lock_bh(&net->xfrm.xfrm_policy_lock);\n\twrite_seqcount_begin(&xfrm_policy_hash_generation);\n\n\t/* make sure that we can insert the indirect policies again before\n\t * we start with destructive action.\n\t */\n\tlist_for_each_entry(policy, &net->xfrm.policy_all, walk.all) {\n\t\tstruct xfrm_pol_inexact_bin *bin;\n\t\tu8 dbits, sbits;\n\n\t\tdir = xfrm_policy_id2dir(policy->index);\n\t\tif (policy->walk.dead || dir >= XFRM_POLICY_MAX)\n\t\t\tcontinue;\n\n\t\tif ((dir & XFRM_POLICY_MASK) == XFRM_POLICY_OUT) {\n\t\t\tif (policy->family == AF_INET) {\n\t\t\t\tdbits = rbits4;\n\t\t\t\tsbits = lbits4;\n\t\t\t} else {\n\t\t\t\tdbits = rbits6;\n\t\t\t\tsbits = lbits6;\n\t\t\t}\n\t\t} else {\n\t\t\tif (policy->family == AF_INET) {\n\t\t\t\tdbits = lbits4;\n\t\t\t\tsbits = rbits4;\n\t\t\t} else {\n\t\t\t\tdbits = lbits6;\n\t\t\t\tsbits = rbits6;\n\t\t\t}\n\t\t}\n\n\t\tif (policy->selector.prefixlen_d < dbits ||\n\t\t    policy->selector.prefixlen_s < sbits)\n\t\t\tcontinue;\n\n\t\tbin = xfrm_policy_inexact_alloc_bin(policy, dir);\n\t\tif (!bin)\n\t\t\tgoto out_unlock;\n\n\t\tif (!xfrm_policy_inexact_alloc_chain(bin, policy, dir))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* reset the bydst and inexact table in all directions */\n\tfor (dir = 0; dir < XFRM_POLICY_MAX; dir++) {\n\t\tstruct hlist_node *n;\n\n\t\thlist_for_each_entry_safe(policy, n,\n\t\t\t\t\t  &net->xfrm.policy_inexact[dir],\n\t\t\t\t\t  bydst_inexact_list) {\n\t\t\thlist_del_rcu(&policy->bydst);\n\t\t\thlist_del_init(&policy->bydst_inexact_list);\n\t\t}\n\n\t\thmask = net->xfrm.policy_bydst[dir].hmask;\n\t\todst = net->xfrm.policy_bydst[dir].table;\n\t\tfor (i = hmask; i >= 0; i--) {\n\t\t\thlist_for_each_entry_safe(policy, n, odst + i, bydst)\n\t\t\t\thlist_del_rcu(&policy->bydst);\n\t\t}\n\t\tif ((dir & XFRM_POLICY_MASK) == XFRM_POLICY_OUT) {\n\t\t\t/* dir out => dst = remote, src = local */\n\t\t\tnet->xfrm.policy_bydst[dir].dbits4 = rbits4;\n\t\t\tnet->xfrm.policy_bydst[dir].sbits4 = lbits4;\n\t\t\tnet->xfrm.policy_bydst[dir].dbits6 = rbits6;\n\t\t\tnet->xfrm.policy_bydst[dir].sbits6 = lbits6;\n\t\t} else {\n\t\t\t/* dir in/fwd => dst = local, src = remote */\n\t\t\tnet->xfrm.policy_bydst[dir].dbits4 = lbits4;\n\t\t\tnet->xfrm.policy_bydst[dir].sbits4 = rbits4;\n\t\t\tnet->xfrm.policy_bydst[dir].dbits6 = lbits6;\n\t\t\tnet->xfrm.policy_bydst[dir].sbits6 = rbits6;\n\t\t}\n\t}\n\n\t/* re-insert all policies by order of creation */\n\tlist_for_each_entry_reverse(policy, &net->xfrm.policy_all, walk.all) {\n\t\tif (policy->walk.dead)\n\t\t\tcontinue;\n\t\tdir = xfrm_policy_id2dir(policy->index);\n\t\tif (dir >= XFRM_POLICY_MAX) {\n\t\t\t/* skip socket policies */\n\t\t\tcontinue;\n\t\t}\n\t\tnewpos = NULL;\n\t\tchain = policy_hash_bysel(net, &policy->selector,\n\t\t\t\t\t  policy->family, dir);\n\n\t\tif (!chain) {\n\t\t\tvoid *p = xfrm_policy_inexact_insert(policy, dir, 0);\n\n\t\t\tWARN_ONCE(IS_ERR(p), \"reinsert: %ld\\n\", PTR_ERR(p));\n\t\t\tcontinue;\n\t\t}\n\n\t\thlist_for_each_entry(pol, chain, bydst) {\n\t\t\tif (policy->priority >= pol->priority)\n\t\t\t\tnewpos = &pol->bydst;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (newpos)\n\t\t\thlist_add_behind_rcu(&policy->bydst, newpos);\n\t\telse\n\t\t\thlist_add_head_rcu(&policy->bydst, chain);\n\t}\n\nout_unlock:\n\t__xfrm_policy_inexact_flush(net);\n\twrite_seqcount_end(&xfrm_policy_hash_generation);\n\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\n\tmutex_unlock(&hash_resize_mutex);\n}\n\nvoid xfrm_policy_hash_rebuild(struct net *net)\n{\n\tschedule_work(&net->xfrm.policy_hthresh.work);\n}\nEXPORT_SYMBOL(xfrm_policy_hash_rebuild);\n\n/* Generate new index... KAME seems to generate them ordered by cost\n * of an absolute inpredictability of ordering of rules. This will not pass. */\nstatic u32 xfrm_gen_index(struct net *net, int dir, u32 index)\n{\n\tstatic u32 idx_generator;\n\n\tfor (;;) {\n\t\tstruct hlist_head *list;\n\t\tstruct xfrm_policy *p;\n\t\tu32 idx;\n\t\tint found;\n\n\t\tif (!index) {\n\t\t\tidx = (idx_generator | dir);\n\t\t\tidx_generator += 8;\n\t\t} else {\n\t\t\tidx = index;\n\t\t\tindex = 0;\n\t\t}\n\n\t\tif (idx == 0)\n\t\t\tidx = 8;\n\t\tlist = net->xfrm.policy_byidx + idx_hash(net, idx);\n\t\tfound = 0;\n\t\thlist_for_each_entry(p, list, byidx) {\n\t\t\tif (p->index == idx) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\treturn idx;\n\t}\n}\n\nstatic inline int selector_cmp(struct xfrm_selector *s1, struct xfrm_selector *s2)\n{\n\tu32 *p1 = (u32 *) s1;\n\tu32 *p2 = (u32 *) s2;\n\tint len = sizeof(struct xfrm_selector) / sizeof(u32);\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (p1[i] != p2[i])\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void xfrm_policy_requeue(struct xfrm_policy *old,\n\t\t\t\tstruct xfrm_policy *new)\n{\n\tstruct xfrm_policy_queue *pq = &old->polq;\n\tstruct sk_buff_head list;\n\n\tif (skb_queue_empty(&pq->hold_queue))\n\t\treturn;\n\n\t__skb_queue_head_init(&list);\n\n\tspin_lock_bh(&pq->hold_queue.lock);\n\tskb_queue_splice_init(&pq->hold_queue, &list);\n\tif (del_timer(&pq->hold_timer))\n\t\txfrm_pol_put(old);\n\tspin_unlock_bh(&pq->hold_queue.lock);\n\n\tpq = &new->polq;\n\n\tspin_lock_bh(&pq->hold_queue.lock);\n\tskb_queue_splice(&list, &pq->hold_queue);\n\tpq->timeout = XFRM_QUEUE_TMO_MIN;\n\tif (!mod_timer(&pq->hold_timer, jiffies))\n\t\txfrm_pol_hold(new);\n\tspin_unlock_bh(&pq->hold_queue.lock);\n}\n\nstatic inline bool xfrm_policy_mark_match(const struct xfrm_mark *mark,\n\t\t\t\t\t  struct xfrm_policy *pol)\n{\n\treturn mark->v == pol->mark.v && mark->m == pol->mark.m;\n}\n\nstatic u32 xfrm_pol_bin_key(const void *data, u32 len, u32 seed)\n{\n\tconst struct xfrm_pol_inexact_key *k = data;\n\tu32 a = k->type << 24 | k->dir << 16 | k->family;\n\n\treturn jhash_3words(a, k->if_id, net_hash_mix(read_pnet(&k->net)),\n\t\t\t    seed);\n}\n\nstatic u32 xfrm_pol_bin_obj(const void *data, u32 len, u32 seed)\n{\n\tconst struct xfrm_pol_inexact_bin *b = data;\n\n\treturn xfrm_pol_bin_key(&b->k, 0, seed);\n}\n\nstatic int xfrm_pol_bin_cmp(struct rhashtable_compare_arg *arg,\n\t\t\t    const void *ptr)\n{\n\tconst struct xfrm_pol_inexact_key *key = arg->key;\n\tconst struct xfrm_pol_inexact_bin *b = ptr;\n\tint ret;\n\n\tif (!net_eq(read_pnet(&b->k.net), read_pnet(&key->net)))\n\t\treturn -1;\n\n\tret = b->k.dir ^ key->dir;\n\tif (ret)\n\t\treturn ret;\n\n\tret = b->k.type ^ key->type;\n\tif (ret)\n\t\treturn ret;\n\n\tret = b->k.family ^ key->family;\n\tif (ret)\n\t\treturn ret;\n\n\treturn b->k.if_id ^ key->if_id;\n}\n\nstatic const struct rhashtable_params xfrm_pol_inexact_params = {\n\t.head_offset\t\t= offsetof(struct xfrm_pol_inexact_bin, head),\n\t.hashfn\t\t\t= xfrm_pol_bin_key,\n\t.obj_hashfn\t\t= xfrm_pol_bin_obj,\n\t.obj_cmpfn\t\t= xfrm_pol_bin_cmp,\n\t.automatic_shrinking\t= true,\n};\n\nstatic void xfrm_policy_insert_inexact_list(struct hlist_head *chain,\n\t\t\t\t\t    struct xfrm_policy *policy)\n{\n\tstruct xfrm_policy *pol, *delpol = NULL;\n\tstruct hlist_node *newpos = NULL;\n\tint i = 0;\n\n\thlist_for_each_entry(pol, chain, bydst_inexact_list) {\n\t\tif (pol->type == policy->type &&\n\t\t    pol->if_id == policy->if_id &&\n\t\t    !selector_cmp(&pol->selector, &policy->selector) &&\n\t\t    xfrm_policy_mark_match(&policy->mark, pol) &&\n\t\t    xfrm_sec_ctx_match(pol->security, policy->security) &&\n\t\t    !WARN_ON(delpol)) {\n\t\t\tdelpol = pol;\n\t\t\tif (policy->priority > pol->priority)\n\t\t\t\tcontinue;\n\t\t} else if (policy->priority >= pol->priority) {\n\t\t\tnewpos = &pol->bydst_inexact_list;\n\t\t\tcontinue;\n\t\t}\n\t\tif (delpol)\n\t\t\tbreak;\n\t}\n\n\tif (newpos)\n\t\thlist_add_behind_rcu(&policy->bydst_inexact_list, newpos);\n\telse\n\t\thlist_add_head_rcu(&policy->bydst_inexact_list, chain);\n\n\thlist_for_each_entry(pol, chain, bydst_inexact_list) {\n\t\tpol->pos = i;\n\t\ti++;\n\t}\n}\n\nstatic struct xfrm_policy *xfrm_policy_insert_list(struct hlist_head *chain,\n\t\t\t\t\t\t   struct xfrm_policy *policy,\n\t\t\t\t\t\t   bool excl)\n{\n\tstruct xfrm_policy *pol, *newpos = NULL, *delpol = NULL;\n\n\thlist_for_each_entry(pol, chain, bydst) {\n\t\tif (pol->type == policy->type &&\n\t\t    pol->if_id == policy->if_id &&\n\t\t    !selector_cmp(&pol->selector, &policy->selector) &&\n\t\t    xfrm_policy_mark_match(&policy->mark, pol) &&\n\t\t    xfrm_sec_ctx_match(pol->security, policy->security) &&\n\t\t    !WARN_ON(delpol)) {\n\t\t\tif (excl)\n\t\t\t\treturn ERR_PTR(-EEXIST);\n\t\t\tdelpol = pol;\n\t\t\tif (policy->priority > pol->priority)\n\t\t\t\tcontinue;\n\t\t} else if (policy->priority >= pol->priority) {\n\t\t\tnewpos = pol;\n\t\t\tcontinue;\n\t\t}\n\t\tif (delpol)\n\t\t\tbreak;\n\t}\n\n\tif (newpos)\n\t\thlist_add_behind_rcu(&policy->bydst, &newpos->bydst);\n\telse\n\t\thlist_add_head_rcu(&policy->bydst, chain);\n\n\treturn delpol;\n}\n\nint xfrm_policy_insert(int dir, struct xfrm_policy *policy, int excl)\n{\n\tstruct net *net = xp_net(policy);\n\tstruct xfrm_policy *delpol;\n\tstruct hlist_head *chain;\n\n\tspin_lock_bh(&net->xfrm.xfrm_policy_lock);\n\tchain = policy_hash_bysel(net, &policy->selector, policy->family, dir);\n\tif (chain)\n\t\tdelpol = xfrm_policy_insert_list(chain, policy, excl);\n\telse\n\t\tdelpol = xfrm_policy_inexact_insert(policy, dir, excl);\n\n\tif (IS_ERR(delpol)) {\n\t\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\t\treturn PTR_ERR(delpol);\n\t}\n\n\t__xfrm_policy_link(policy, dir);\n\n\t/* After previous checking, family can either be AF_INET or AF_INET6 */\n\tif (policy->family == AF_INET)\n\t\trt_genid_bump_ipv4(net);\n\telse\n\t\trt_genid_bump_ipv6(net);\n\n\tif (delpol) {\n\t\txfrm_policy_requeue(delpol, policy);\n\t\t__xfrm_policy_unlink(delpol, dir);\n\t}\n\tpolicy->index = delpol ? delpol->index : xfrm_gen_index(net, dir, policy->index);\n\thlist_add_head(&policy->byidx, net->xfrm.policy_byidx+idx_hash(net, policy->index));\n\tpolicy->curlft.add_time = ktime_get_real_seconds();\n\tpolicy->curlft.use_time = 0;\n\tif (!mod_timer(&policy->timer, jiffies + HZ))\n\t\txfrm_pol_hold(policy);\n\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\n\tif (delpol)\n\t\txfrm_policy_kill(delpol);\n\telse if (xfrm_bydst_should_resize(net, dir, NULL))\n\t\tschedule_work(&net->xfrm.policy_hash_work);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(xfrm_policy_insert);\n\nstatic struct xfrm_policy *\n__xfrm_policy_bysel_ctx(struct hlist_head *chain, const struct xfrm_mark *mark,\n\t\t\tu32 if_id, u8 type, int dir, struct xfrm_selector *sel,\n\t\t\tstruct xfrm_sec_ctx *ctx)\n{\n\tstruct xfrm_policy *pol;\n\n\tif (!chain)\n\t\treturn NULL;\n\n\thlist_for_each_entry(pol, chain, bydst) {\n\t\tif (pol->type == type &&\n\t\t    pol->if_id == if_id &&\n\t\t    xfrm_policy_mark_match(mark, pol) &&\n\t\t    !selector_cmp(sel, &pol->selector) &&\n\t\t    xfrm_sec_ctx_match(ctx, pol->security))\n\t\t\treturn pol;\n\t}\n\n\treturn NULL;\n}\n\nstruct xfrm_policy *\nxfrm_policy_bysel_ctx(struct net *net, const struct xfrm_mark *mark, u32 if_id,\n\t\t      u8 type, int dir, struct xfrm_selector *sel,\n\t\t      struct xfrm_sec_ctx *ctx, int delete, int *err)\n{\n\tstruct xfrm_pol_inexact_bin *bin = NULL;\n\tstruct xfrm_policy *pol, *ret = NULL;\n\tstruct hlist_head *chain;\n\n\t*err = 0;\n\tspin_lock_bh(&net->xfrm.xfrm_policy_lock);\n\tchain = policy_hash_bysel(net, sel, sel->family, dir);\n\tif (!chain) {\n\t\tstruct xfrm_pol_inexact_candidates cand;\n\t\tint i;\n\n\t\tbin = xfrm_policy_inexact_lookup(net, type,\n\t\t\t\t\t\t sel->family, dir, if_id);\n\t\tif (!bin) {\n\t\t\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!xfrm_policy_find_inexact_candidates(&cand, bin,\n\t\t\t\t\t\t\t &sel->saddr,\n\t\t\t\t\t\t\t &sel->daddr)) {\n\t\t\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tpol = NULL;\n\t\tfor (i = 0; i < ARRAY_SIZE(cand.res); i++) {\n\t\t\tstruct xfrm_policy *tmp;\n\n\t\t\ttmp = __xfrm_policy_bysel_ctx(cand.res[i], mark,\n\t\t\t\t\t\t      if_id, type, dir,\n\t\t\t\t\t\t      sel, ctx);\n\t\t\tif (!tmp)\n\t\t\t\tcontinue;\n\n\t\t\tif (!pol || tmp->pos < pol->pos)\n\t\t\t\tpol = tmp;\n\t\t}\n\t} else {\n\t\tpol = __xfrm_policy_bysel_ctx(chain, mark, if_id, type, dir,\n\t\t\t\t\t      sel, ctx);\n\t}\n\n\tif (pol) {\n\t\txfrm_pol_hold(pol);\n\t\tif (delete) {\n\t\t\t*err = security_xfrm_policy_delete(pol->security);\n\t\t\tif (*err) {\n\t\t\t\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\t\t\t\treturn pol;\n\t\t\t}\n\t\t\t__xfrm_policy_unlink(pol, dir);\n\t\t}\n\t\tret = pol;\n\t}\n\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\n\tif (ret && delete)\n\t\txfrm_policy_kill(ret);\n\tif (bin && delete)\n\t\txfrm_policy_inexact_prune_bin(bin);\n\treturn ret;\n}\nEXPORT_SYMBOL(xfrm_policy_bysel_ctx);\n\nstruct xfrm_policy *\nxfrm_policy_byid(struct net *net, const struct xfrm_mark *mark, u32 if_id,\n\t\t u8 type, int dir, u32 id, int delete, int *err)\n{\n\tstruct xfrm_policy *pol, *ret;\n\tstruct hlist_head *chain;\n\n\t*err = -ENOENT;\n\tif (xfrm_policy_id2dir(id) != dir)\n\t\treturn NULL;\n\n\t*err = 0;\n\tspin_lock_bh(&net->xfrm.xfrm_policy_lock);\n\tchain = net->xfrm.policy_byidx + idx_hash(net, id);\n\tret = NULL;\n\thlist_for_each_entry(pol, chain, byidx) {\n\t\tif (pol->type == type && pol->index == id &&\n\t\t    pol->if_id == if_id && xfrm_policy_mark_match(mark, pol)) {\n\t\t\txfrm_pol_hold(pol);\n\t\t\tif (delete) {\n\t\t\t\t*err = security_xfrm_policy_delete(\n\t\t\t\t\t\t\t\tpol->security);\n\t\t\t\tif (*err) {\n\t\t\t\t\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\t\t\t\t\treturn pol;\n\t\t\t\t}\n\t\t\t\t__xfrm_policy_unlink(pol, dir);\n\t\t\t}\n\t\t\tret = pol;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\n\tif (ret && delete)\n\t\txfrm_policy_kill(ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(xfrm_policy_byid);\n\n#ifdef CONFIG_SECURITY_NETWORK_XFRM\nstatic inline int\nxfrm_policy_flush_secctx_check(struct net *net, u8 type, bool task_valid)\n{\n\tstruct xfrm_policy *pol;\n\tint err = 0;\n\n\tlist_for_each_entry(pol, &net->xfrm.policy_all, walk.all) {\n\t\tif (pol->walk.dead ||\n\t\t    xfrm_policy_id2dir(pol->index) >= XFRM_POLICY_MAX ||\n\t\t    pol->type != type)\n\t\t\tcontinue;\n\n\t\terr = security_xfrm_policy_delete(pol->security);\n\t\tif (err) {\n\t\t\txfrm_audit_policy_delete(pol, 0, task_valid);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn err;\n}\n#else\nstatic inline int\nxfrm_policy_flush_secctx_check(struct net *net, u8 type, bool task_valid)\n{\n\treturn 0;\n}\n#endif\n\nint xfrm_policy_flush(struct net *net, u8 type, bool task_valid)\n{\n\tint dir, err = 0, cnt = 0;\n\tstruct xfrm_policy *pol;\n\n\tspin_lock_bh(&net->xfrm.xfrm_policy_lock);\n\n\terr = xfrm_policy_flush_secctx_check(net, type, task_valid);\n\tif (err)\n\t\tgoto out;\n\nagain:\n\tlist_for_each_entry(pol, &net->xfrm.policy_all, walk.all) {\n\t\tdir = xfrm_policy_id2dir(pol->index);\n\t\tif (pol->walk.dead ||\n\t\t    dir >= XFRM_POLICY_MAX ||\n\t\t    pol->type != type)\n\t\t\tcontinue;\n\n\t\t__xfrm_policy_unlink(pol, dir);\n\t\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\t\tcnt++;\n\t\txfrm_audit_policy_delete(pol, 1, task_valid);\n\t\txfrm_policy_kill(pol);\n\t\tspin_lock_bh(&net->xfrm.xfrm_policy_lock);\n\t\tgoto again;\n\t}\n\tif (cnt)\n\t\t__xfrm_policy_inexact_flush(net);\n\telse\n\t\terr = -ESRCH;\nout:\n\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\treturn err;\n}\nEXPORT_SYMBOL(xfrm_policy_flush);\n\nint xfrm_policy_walk(struct net *net, struct xfrm_policy_walk *walk,\n\t\t     int (*func)(struct xfrm_policy *, int, int, void*),\n\t\t     void *data)\n{\n\tstruct xfrm_policy *pol;\n\tstruct xfrm_policy_walk_entry *x;\n\tint error = 0;\n\n\tif (walk->type >= XFRM_POLICY_TYPE_MAX &&\n\t    walk->type != XFRM_POLICY_TYPE_ANY)\n\t\treturn -EINVAL;\n\n\tif (list_empty(&walk->walk.all) && walk->seq != 0)\n\t\treturn 0;\n\n\tspin_lock_bh(&net->xfrm.xfrm_policy_lock);\n\tif (list_empty(&walk->walk.all))\n\t\tx = list_first_entry(&net->xfrm.policy_all, struct xfrm_policy_walk_entry, all);\n\telse\n\t\tx = list_first_entry(&walk->walk.all,\n\t\t\t\t     struct xfrm_policy_walk_entry, all);\n\n\tlist_for_each_entry_from(x, &net->xfrm.policy_all, all) {\n\t\tif (x->dead)\n\t\t\tcontinue;\n\t\tpol = container_of(x, struct xfrm_policy, walk);\n\t\tif (walk->type != XFRM_POLICY_TYPE_ANY &&\n\t\t    walk->type != pol->type)\n\t\t\tcontinue;\n\t\terror = func(pol, xfrm_policy_id2dir(pol->index),\n\t\t\t     walk->seq, data);\n\t\tif (error) {\n\t\t\tlist_move_tail(&walk->walk.all, &x->all);\n\t\t\tgoto out;\n\t\t}\n\t\twalk->seq++;\n\t}\n\tif (walk->seq == 0) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\tlist_del_init(&walk->walk.all);\nout:\n\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\treturn error;\n}\nEXPORT_SYMBOL(xfrm_policy_walk);\n\nvoid xfrm_policy_walk_init(struct xfrm_policy_walk *walk, u8 type)\n{\n\tINIT_LIST_HEAD(&walk->walk.all);\n\twalk->walk.dead = 1;\n\twalk->type = type;\n\twalk->seq = 0;\n}\nEXPORT_SYMBOL(xfrm_policy_walk_init);\n\nvoid xfrm_policy_walk_done(struct xfrm_policy_walk *walk, struct net *net)\n{\n\tif (list_empty(&walk->walk.all))\n\t\treturn;\n\n\tspin_lock_bh(&net->xfrm.xfrm_policy_lock); /*FIXME where is net? */\n\tlist_del(&walk->walk.all);\n\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n}\nEXPORT_SYMBOL(xfrm_policy_walk_done);\n\n/*\n * Find policy to apply to this flow.\n *\n * Returns 0 if policy found, else an -errno.\n */\nstatic int xfrm_policy_match(const struct xfrm_policy *pol,\n\t\t\t     const struct flowi *fl,\n\t\t\t     u8 type, u16 family, int dir, u32 if_id)\n{\n\tconst struct xfrm_selector *sel = &pol->selector;\n\tint ret = -ESRCH;\n\tbool match;\n\n\tif (pol->family != family ||\n\t    pol->if_id != if_id ||\n\t    (fl->flowi_mark & pol->mark.m) != pol->mark.v ||\n\t    pol->type != type)\n\t\treturn ret;\n\n\tmatch = xfrm_selector_match(sel, fl, family);\n\tif (match)\n\t\tret = security_xfrm_policy_lookup(pol->security, fl->flowi_secid,\n\t\t\t\t\t\t  dir);\n\treturn ret;\n}\n\nstatic struct xfrm_pol_inexact_node *\nxfrm_policy_lookup_inexact_addr(const struct rb_root *r,\n\t\t\t\tseqcount_spinlock_t *count,\n\t\t\t\tconst xfrm_address_t *addr, u16 family)\n{\n\tconst struct rb_node *parent;\n\tint seq;\n\nagain:\n\tseq = read_seqcount_begin(count);\n\n\tparent = rcu_dereference_raw(r->rb_node);\n\twhile (parent) {\n\t\tstruct xfrm_pol_inexact_node *node;\n\t\tint delta;\n\n\t\tnode = rb_entry(parent, struct xfrm_pol_inexact_node, node);\n\n\t\tdelta = xfrm_policy_addr_delta(addr, &node->addr,\n\t\t\t\t\t       node->prefixlen, family);\n\t\tif (delta < 0) {\n\t\t\tparent = rcu_dereference_raw(parent->rb_left);\n\t\t\tcontinue;\n\t\t} else if (delta > 0) {\n\t\t\tparent = rcu_dereference_raw(parent->rb_right);\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tif (read_seqcount_retry(count, seq))\n\t\tgoto again;\n\n\treturn NULL;\n}\n\nstatic bool\nxfrm_policy_find_inexact_candidates(struct xfrm_pol_inexact_candidates *cand,\n\t\t\t\t    struct xfrm_pol_inexact_bin *b,\n\t\t\t\t    const xfrm_address_t *saddr,\n\t\t\t\t    const xfrm_address_t *daddr)\n{\n\tstruct xfrm_pol_inexact_node *n;\n\tu16 family;\n\n\tif (!b)\n\t\treturn false;\n\n\tfamily = b->k.family;\n\tmemset(cand, 0, sizeof(*cand));\n\tcand->res[XFRM_POL_CAND_ANY] = &b->hhead;\n\n\tn = xfrm_policy_lookup_inexact_addr(&b->root_d, &b->count, daddr,\n\t\t\t\t\t    family);\n\tif (n) {\n\t\tcand->res[XFRM_POL_CAND_DADDR] = &n->hhead;\n\t\tn = xfrm_policy_lookup_inexact_addr(&n->root, &b->count, saddr,\n\t\t\t\t\t\t    family);\n\t\tif (n)\n\t\t\tcand->res[XFRM_POL_CAND_BOTH] = &n->hhead;\n\t}\n\n\tn = xfrm_policy_lookup_inexact_addr(&b->root_s, &b->count, saddr,\n\t\t\t\t\t    family);\n\tif (n)\n\t\tcand->res[XFRM_POL_CAND_SADDR] = &n->hhead;\n\n\treturn true;\n}\n\nstatic struct xfrm_pol_inexact_bin *\nxfrm_policy_inexact_lookup_rcu(struct net *net, u8 type, u16 family,\n\t\t\t       u8 dir, u32 if_id)\n{\n\tstruct xfrm_pol_inexact_key k = {\n\t\t.family = family,\n\t\t.type = type,\n\t\t.dir = dir,\n\t\t.if_id = if_id,\n\t};\n\n\twrite_pnet(&k.net, net);\n\n\treturn rhashtable_lookup(&xfrm_policy_inexact_table, &k,\n\t\t\t\t xfrm_pol_inexact_params);\n}\n\nstatic struct xfrm_pol_inexact_bin *\nxfrm_policy_inexact_lookup(struct net *net, u8 type, u16 family,\n\t\t\t   u8 dir, u32 if_id)\n{\n\tstruct xfrm_pol_inexact_bin *bin;\n\n\tlockdep_assert_held(&net->xfrm.xfrm_policy_lock);\n\n\trcu_read_lock();\n\tbin = xfrm_policy_inexact_lookup_rcu(net, type, family, dir, if_id);\n\trcu_read_unlock();\n\n\treturn bin;\n}\n\nstatic struct xfrm_policy *\n__xfrm_policy_eval_candidates(struct hlist_head *chain,\n\t\t\t      struct xfrm_policy *prefer,\n\t\t\t      const struct flowi *fl,\n\t\t\t      u8 type, u16 family, int dir, u32 if_id)\n{\n\tu32 priority = prefer ? prefer->priority : ~0u;\n\tstruct xfrm_policy *pol;\n\n\tif (!chain)\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu(pol, chain, bydst) {\n\t\tint err;\n\n\t\tif (pol->priority > priority)\n\t\t\tbreak;\n\n\t\terr = xfrm_policy_match(pol, fl, type, family, dir, if_id);\n\t\tif (err) {\n\t\t\tif (err != -ESRCH)\n\t\t\t\treturn ERR_PTR(err);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (prefer) {\n\t\t\t/* matches.  Is it older than *prefer? */\n\t\t\tif (pol->priority == priority &&\n\t\t\t    prefer->pos < pol->pos)\n\t\t\t\treturn prefer;\n\t\t}\n\n\t\treturn pol;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct xfrm_policy *\nxfrm_policy_eval_candidates(struct xfrm_pol_inexact_candidates *cand,\n\t\t\t    struct xfrm_policy *prefer,\n\t\t\t    const struct flowi *fl,\n\t\t\t    u8 type, u16 family, int dir, u32 if_id)\n{\n\tstruct xfrm_policy *tmp;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cand->res); i++) {\n\t\ttmp = __xfrm_policy_eval_candidates(cand->res[i],\n\t\t\t\t\t\t    prefer,\n\t\t\t\t\t\t    fl, type, family, dir,\n\t\t\t\t\t\t    if_id);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\n\t\tif (IS_ERR(tmp))\n\t\t\treturn tmp;\n\t\tprefer = tmp;\n\t}\n\n\treturn prefer;\n}\n\nstatic struct xfrm_policy *xfrm_policy_lookup_bytype(struct net *net, u8 type,\n\t\t\t\t\t\t     const struct flowi *fl,\n\t\t\t\t\t\t     u16 family, u8 dir,\n\t\t\t\t\t\t     u32 if_id)\n{\n\tstruct xfrm_pol_inexact_candidates cand;\n\tconst xfrm_address_t *daddr, *saddr;\n\tstruct xfrm_pol_inexact_bin *bin;\n\tstruct xfrm_policy *pol, *ret;\n\tstruct hlist_head *chain;\n\tunsigned int sequence;\n\tint err;\n\n\tdaddr = xfrm_flowi_daddr(fl, family);\n\tsaddr = xfrm_flowi_saddr(fl, family);\n\tif (unlikely(!daddr || !saddr))\n\t\treturn NULL;\n\n\trcu_read_lock();\n retry:\n\tdo {\n\t\tsequence = read_seqcount_begin(&xfrm_policy_hash_generation);\n\t\tchain = policy_hash_direct(net, daddr, saddr, family, dir);\n\t} while (read_seqcount_retry(&xfrm_policy_hash_generation, sequence));\n\n\tret = NULL;\n\thlist_for_each_entry_rcu(pol, chain, bydst) {\n\t\terr = xfrm_policy_match(pol, fl, type, family, dir, if_id);\n\t\tif (err) {\n\t\t\tif (err == -ESRCH)\n\t\t\t\tcontinue;\n\t\t\telse {\n\t\t\t\tret = ERR_PTR(err);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tret = pol;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbin = xfrm_policy_inexact_lookup_rcu(net, type, family, dir, if_id);\n\tif (!bin || !xfrm_policy_find_inexact_candidates(&cand, bin, saddr,\n\t\t\t\t\t\t\t daddr))\n\t\tgoto skip_inexact;\n\n\tpol = xfrm_policy_eval_candidates(&cand, ret, fl, type,\n\t\t\t\t\t  family, dir, if_id);\n\tif (pol) {\n\t\tret = pol;\n\t\tif (IS_ERR(pol))\n\t\t\tgoto fail;\n\t}\n\nskip_inexact:\n\tif (read_seqcount_retry(&xfrm_policy_hash_generation, sequence))\n\t\tgoto retry;\n\n\tif (ret && !xfrm_pol_hold_rcu(ret))\n\t\tgoto retry;\nfail:\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic struct xfrm_policy *xfrm_policy_lookup(struct net *net,\n\t\t\t\t\t      const struct flowi *fl,\n\t\t\t\t\t      u16 family, u8 dir, u32 if_id)\n{\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tstruct xfrm_policy *pol;\n\n\tpol = xfrm_policy_lookup_bytype(net, XFRM_POLICY_TYPE_SUB, fl, family,\n\t\t\t\t\tdir, if_id);\n\tif (pol != NULL)\n\t\treturn pol;\n#endif\n\treturn xfrm_policy_lookup_bytype(net, XFRM_POLICY_TYPE_MAIN, fl, family,\n\t\t\t\t\t dir, if_id);\n}\n\nstatic struct xfrm_policy *xfrm_sk_policy_lookup(const struct sock *sk, int dir,\n\t\t\t\t\t\t const struct flowi *fl,\n\t\t\t\t\t\t u16 family, u32 if_id)\n{\n\tstruct xfrm_policy *pol;\n\n\trcu_read_lock();\n again:\n\tpol = rcu_dereference(sk->sk_policy[dir]);\n\tif (pol != NULL) {\n\t\tbool match;\n\t\tint err = 0;\n\n\t\tif (pol->family != family) {\n\t\t\tpol = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmatch = xfrm_selector_match(&pol->selector, fl, family);\n\t\tif (match) {\n\t\t\tif ((sk->sk_mark & pol->mark.m) != pol->mark.v ||\n\t\t\t    pol->if_id != if_id) {\n\t\t\t\tpol = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terr = security_xfrm_policy_lookup(pol->security,\n\t\t\t\t\t\t      fl->flowi_secid,\n\t\t\t\t\t\t      dir);\n\t\t\tif (!err) {\n\t\t\t\tif (!xfrm_pol_hold_rcu(pol))\n\t\t\t\t\tgoto again;\n\t\t\t} else if (err == -ESRCH) {\n\t\t\t\tpol = NULL;\n\t\t\t} else {\n\t\t\t\tpol = ERR_PTR(err);\n\t\t\t}\n\t\t} else\n\t\t\tpol = NULL;\n\t}\nout:\n\trcu_read_unlock();\n\treturn pol;\n}\n\nstatic void __xfrm_policy_link(struct xfrm_policy *pol, int dir)\n{\n\tstruct net *net = xp_net(pol);\n\n\tlist_add(&pol->walk.all, &net->xfrm.policy_all);\n\tnet->xfrm.policy_count[dir]++;\n\txfrm_pol_hold(pol);\n}\n\nstatic struct xfrm_policy *__xfrm_policy_unlink(struct xfrm_policy *pol,\n\t\t\t\t\t\tint dir)\n{\n\tstruct net *net = xp_net(pol);\n\n\tif (list_empty(&pol->walk.all))\n\t\treturn NULL;\n\n\t/* Socket policies are not hashed. */\n\tif (!hlist_unhashed(&pol->bydst)) {\n\t\thlist_del_rcu(&pol->bydst);\n\t\thlist_del_init(&pol->bydst_inexact_list);\n\t\thlist_del(&pol->byidx);\n\t}\n\n\tlist_del_init(&pol->walk.all);\n\tnet->xfrm.policy_count[dir]--;\n\n\treturn pol;\n}\n\nstatic void xfrm_sk_policy_link(struct xfrm_policy *pol, int dir)\n{\n\t__xfrm_policy_link(pol, XFRM_POLICY_MAX + dir);\n}\n\nstatic void xfrm_sk_policy_unlink(struct xfrm_policy *pol, int dir)\n{\n\t__xfrm_policy_unlink(pol, XFRM_POLICY_MAX + dir);\n}\n\nint xfrm_policy_delete(struct xfrm_policy *pol, int dir)\n{\n\tstruct net *net = xp_net(pol);\n\n\tspin_lock_bh(&net->xfrm.xfrm_policy_lock);\n\tpol = __xfrm_policy_unlink(pol, dir);\n\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\tif (pol) {\n\t\txfrm_policy_kill(pol);\n\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL(xfrm_policy_delete);\n\nint xfrm_sk_policy_insert(struct sock *sk, int dir, struct xfrm_policy *pol)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_policy *old_pol;\n\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pol && pol->type != XFRM_POLICY_TYPE_MAIN)\n\t\treturn -EINVAL;\n#endif\n\n\tspin_lock_bh(&net->xfrm.xfrm_policy_lock);\n\told_pol = rcu_dereference_protected(sk->sk_policy[dir],\n\t\t\t\tlockdep_is_held(&net->xfrm.xfrm_policy_lock));\n\tif (pol) {\n\t\tpol->curlft.add_time = ktime_get_real_seconds();\n\t\tpol->index = xfrm_gen_index(net, XFRM_POLICY_MAX+dir, 0);\n\t\txfrm_sk_policy_link(pol, dir);\n\t}\n\trcu_assign_pointer(sk->sk_policy[dir], pol);\n\tif (old_pol) {\n\t\tif (pol)\n\t\t\txfrm_policy_requeue(old_pol, pol);\n\n\t\t/* Unlinking succeeds always. This is the only function\n\t\t * allowed to delete or replace socket policy.\n\t\t */\n\t\txfrm_sk_policy_unlink(old_pol, dir);\n\t}\n\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\n\tif (old_pol) {\n\t\txfrm_policy_kill(old_pol);\n\t}\n\treturn 0;\n}\n\nstatic struct xfrm_policy *clone_policy(const struct xfrm_policy *old, int dir)\n{\n\tstruct xfrm_policy *newp = xfrm_policy_alloc(xp_net(old), GFP_ATOMIC);\n\tstruct net *net = xp_net(old);\n\n\tif (newp) {\n\t\tnewp->selector = old->selector;\n\t\tif (security_xfrm_policy_clone(old->security,\n\t\t\t\t\t       &newp->security)) {\n\t\t\tkfree(newp);\n\t\t\treturn NULL;  /* ENOMEM */\n\t\t}\n\t\tnewp->lft = old->lft;\n\t\tnewp->curlft = old->curlft;\n\t\tnewp->mark = old->mark;\n\t\tnewp->if_id = old->if_id;\n\t\tnewp->action = old->action;\n\t\tnewp->flags = old->flags;\n\t\tnewp->xfrm_nr = old->xfrm_nr;\n\t\tnewp->index = old->index;\n\t\tnewp->type = old->type;\n\t\tnewp->family = old->family;\n\t\tmemcpy(newp->xfrm_vec, old->xfrm_vec,\n\t\t       newp->xfrm_nr*sizeof(struct xfrm_tmpl));\n\t\tspin_lock_bh(&net->xfrm.xfrm_policy_lock);\n\t\txfrm_sk_policy_link(newp, dir);\n\t\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\t\txfrm_pol_put(newp);\n\t}\n\treturn newp;\n}\n\nint __xfrm_sk_clone_policy(struct sock *sk, const struct sock *osk)\n{\n\tconst struct xfrm_policy *p;\n\tstruct xfrm_policy *np;\n\tint i, ret = 0;\n\n\trcu_read_lock();\n\tfor (i = 0; i < 2; i++) {\n\t\tp = rcu_dereference(osk->sk_policy[i]);\n\t\tif (p) {\n\t\t\tnp = clone_policy(p, i);\n\t\t\tif (unlikely(!np)) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trcu_assign_pointer(sk->sk_policy[i], np);\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic int\nxfrm_get_saddr(struct net *net, int oif, xfrm_address_t *local,\n\t       xfrm_address_t *remote, unsigned short family, u32 mark)\n{\n\tint err;\n\tconst struct xfrm_policy_afinfo *afinfo = xfrm_policy_get_afinfo(family);\n\n\tif (unlikely(afinfo == NULL))\n\t\treturn -EINVAL;\n\terr = afinfo->get_saddr(net, oif, local, remote, mark);\n\trcu_read_unlock();\n\treturn err;\n}\n\n/* Resolve list of templates for the flow, given policy. */\n\nstatic int\nxfrm_tmpl_resolve_one(struct xfrm_policy *policy, const struct flowi *fl,\n\t\t      struct xfrm_state **xfrm, unsigned short family)\n{\n\tstruct net *net = xp_net(policy);\n\tint nx;\n\tint i, error;\n\txfrm_address_t *daddr = xfrm_flowi_daddr(fl, family);\n\txfrm_address_t *saddr = xfrm_flowi_saddr(fl, family);\n\txfrm_address_t tmp;\n\n\tfor (nx = 0, i = 0; i < policy->xfrm_nr; i++) {\n\t\tstruct xfrm_state *x;\n\t\txfrm_address_t *remote = daddr;\n\t\txfrm_address_t *local  = saddr;\n\t\tstruct xfrm_tmpl *tmpl = &policy->xfrm_vec[i];\n\n\t\tif (tmpl->mode == XFRM_MODE_TUNNEL ||\n\t\t    tmpl->mode == XFRM_MODE_BEET) {\n\t\t\tremote = &tmpl->id.daddr;\n\t\t\tlocal = &tmpl->saddr;\n\t\t\tif (xfrm_addr_any(local, tmpl->encap_family)) {\n\t\t\t\terror = xfrm_get_saddr(net, fl->flowi_oif,\n\t\t\t\t\t\t       &tmp, remote,\n\t\t\t\t\t\t       tmpl->encap_family, 0);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto fail;\n\t\t\t\tlocal = &tmp;\n\t\t\t}\n\t\t}\n\n\t\tx = xfrm_state_find(remote, local, fl, tmpl, policy, &error,\n\t\t\t\t    family, policy->if_id);\n\n\t\tif (x && x->km.state == XFRM_STATE_VALID) {\n\t\t\txfrm[nx++] = x;\n\t\t\tdaddr = remote;\n\t\t\tsaddr = local;\n\t\t\tcontinue;\n\t\t}\n\t\tif (x) {\n\t\t\terror = (x->km.state == XFRM_STATE_ERROR ?\n\t\t\t\t -EINVAL : -EAGAIN);\n\t\t\txfrm_state_put(x);\n\t\t} else if (error == -ESRCH) {\n\t\t\terror = -EAGAIN;\n\t\t}\n\n\t\tif (!tmpl->optional)\n\t\t\tgoto fail;\n\t}\n\treturn nx;\n\nfail:\n\tfor (nx--; nx >= 0; nx--)\n\t\txfrm_state_put(xfrm[nx]);\n\treturn error;\n}\n\nstatic int\nxfrm_tmpl_resolve(struct xfrm_policy **pols, int npols, const struct flowi *fl,\n\t\t  struct xfrm_state **xfrm, unsigned short family)\n{\n\tstruct xfrm_state *tp[XFRM_MAX_DEPTH];\n\tstruct xfrm_state **tpp = (npols > 1) ? tp : xfrm;\n\tint cnx = 0;\n\tint error;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < npols; i++) {\n\t\tif (cnx + pols[i]->xfrm_nr >= XFRM_MAX_DEPTH) {\n\t\t\terror = -ENOBUFS;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tret = xfrm_tmpl_resolve_one(pols[i], fl, &tpp[cnx], family);\n\t\tif (ret < 0) {\n\t\t\terror = ret;\n\t\t\tgoto fail;\n\t\t} else\n\t\t\tcnx += ret;\n\t}\n\n\t/* found states are sorted for outbound processing */\n\tif (npols > 1)\n\t\txfrm_state_sort(xfrm, tpp, cnx, family);\n\n\treturn cnx;\n\n fail:\n\tfor (cnx--; cnx >= 0; cnx--)\n\t\txfrm_state_put(tpp[cnx]);\n\treturn error;\n\n}\n\nstatic int xfrm_get_tos(const struct flowi *fl, int family)\n{\n\tif (family == AF_INET)\n\t\treturn IPTOS_RT_MASK & fl->u.ip4.flowi4_tos;\n\n\treturn 0;\n}\n\nstatic inline struct xfrm_dst *xfrm_alloc_dst(struct net *net, int family)\n{\n\tconst struct xfrm_policy_afinfo *afinfo = xfrm_policy_get_afinfo(family);\n\tstruct dst_ops *dst_ops;\n\tstruct xfrm_dst *xdst;\n\n\tif (!afinfo)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\tdst_ops = &net->xfrm.xfrm4_dst_ops;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tdst_ops = &net->xfrm.xfrm6_dst_ops;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tBUG();\n\t}\n\txdst = dst_alloc(dst_ops, NULL, 1, DST_OBSOLETE_NONE, 0);\n\n\tif (likely(xdst)) {\n\t\tstruct dst_entry *dst = &xdst->u.dst;\n\n\t\tmemset(dst + 1, 0, sizeof(*xdst) - sizeof(*dst));\n\t} else\n\t\txdst = ERR_PTR(-ENOBUFS);\n\n\trcu_read_unlock();\n\n\treturn xdst;\n}\n\nstatic void xfrm_init_path(struct xfrm_dst *path, struct dst_entry *dst,\n\t\t\t   int nfheader_len)\n{\n\tif (dst->ops->family == AF_INET6) {\n\t\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\t\tpath->path_cookie = rt6_get_cookie(rt);\n\t\tpath->u.rt6.rt6i_nfheader_len = nfheader_len;\n\t}\n}\n\nstatic inline int xfrm_fill_dst(struct xfrm_dst *xdst, struct net_device *dev,\n\t\t\t\tconst struct flowi *fl)\n{\n\tconst struct xfrm_policy_afinfo *afinfo =\n\t\txfrm_policy_get_afinfo(xdst->u.dst.ops->family);\n\tint err;\n\n\tif (!afinfo)\n\t\treturn -EINVAL;\n\n\terr = afinfo->fill_dst(xdst, dev, fl);\n\n\trcu_read_unlock();\n\n\treturn err;\n}\n\n\n/* Allocate chain of dst_entry's, attach known xfrm's, calculate\n * all the metrics... Shortly, bundle a bundle.\n */\n\nstatic struct dst_entry *xfrm_bundle_create(struct xfrm_policy *policy,\n\t\t\t\t\t    struct xfrm_state **xfrm,\n\t\t\t\t\t    struct xfrm_dst **bundle,\n\t\t\t\t\t    int nx,\n\t\t\t\t\t    const struct flowi *fl,\n\t\t\t\t\t    struct dst_entry *dst)\n{\n\tconst struct xfrm_state_afinfo *afinfo;\n\tconst struct xfrm_mode *inner_mode;\n\tstruct net *net = xp_net(policy);\n\tunsigned long now = jiffies;\n\tstruct net_device *dev;\n\tstruct xfrm_dst *xdst_prev = NULL;\n\tstruct xfrm_dst *xdst0 = NULL;\n\tint i = 0;\n\tint err;\n\tint header_len = 0;\n\tint nfheader_len = 0;\n\tint trailer_len = 0;\n\tint tos;\n\tint family = policy->selector.family;\n\txfrm_address_t saddr, daddr;\n\n\txfrm_flowi_addr_get(fl, &saddr, &daddr, family);\n\n\ttos = xfrm_get_tos(fl, family);\n\n\tdst_hold(dst);\n\n\tfor (; i < nx; i++) {\n\t\tstruct xfrm_dst *xdst = xfrm_alloc_dst(net, family);\n\t\tstruct dst_entry *dst1 = &xdst->u.dst;\n\n\t\terr = PTR_ERR(xdst);\n\t\tif (IS_ERR(xdst)) {\n\t\t\tdst_release(dst);\n\t\t\tgoto put_states;\n\t\t}\n\n\t\tbundle[i] = xdst;\n\t\tif (!xdst_prev)\n\t\t\txdst0 = xdst;\n\t\telse\n\t\t\t/* Ref count is taken during xfrm_alloc_dst()\n\t\t\t * No need to do dst_clone() on dst1\n\t\t\t */\n\t\t\txfrm_dst_set_child(xdst_prev, &xdst->u.dst);\n\n\t\tif (xfrm[i]->sel.family == AF_UNSPEC) {\n\t\t\tinner_mode = xfrm_ip2inner_mode(xfrm[i],\n\t\t\t\t\t\t\txfrm_af2proto(family));\n\t\t\tif (!inner_mode) {\n\t\t\t\terr = -EAFNOSUPPORT;\n\t\t\t\tdst_release(dst);\n\t\t\t\tgoto put_states;\n\t\t\t}\n\t\t} else\n\t\t\tinner_mode = &xfrm[i]->inner_mode;\n\n\t\txdst->route = dst;\n\t\tdst_copy_metrics(dst1, dst);\n\n\t\tif (xfrm[i]->props.mode != XFRM_MODE_TRANSPORT) {\n\t\t\t__u32 mark = 0;\n\n\t\t\tif (xfrm[i]->props.smark.v || xfrm[i]->props.smark.m)\n\t\t\t\tmark = xfrm_smark_get(fl->flowi_mark, xfrm[i]);\n\n\t\t\tfamily = xfrm[i]->props.family;\n\t\t\tdst = xfrm_dst_lookup(xfrm[i], tos, fl->flowi_oif,\n\t\t\t\t\t      &saddr, &daddr, family, mark);\n\t\t\terr = PTR_ERR(dst);\n\t\t\tif (IS_ERR(dst))\n\t\t\t\tgoto put_states;\n\t\t} else\n\t\t\tdst_hold(dst);\n\n\t\tdst1->xfrm = xfrm[i];\n\t\txdst->xfrm_genid = xfrm[i]->genid;\n\n\t\tdst1->obsolete = DST_OBSOLETE_FORCE_CHK;\n\t\tdst1->lastuse = now;\n\n\t\tdst1->input = dst_discard;\n\n\t\trcu_read_lock();\n\t\tafinfo = xfrm_state_afinfo_get_rcu(inner_mode->family);\n\t\tif (likely(afinfo))\n\t\t\tdst1->output = afinfo->output;\n\t\telse\n\t\t\tdst1->output = dst_discard_out;\n\t\trcu_read_unlock();\n\n\t\txdst_prev = xdst;\n\n\t\theader_len += xfrm[i]->props.header_len;\n\t\tif (xfrm[i]->type->flags & XFRM_TYPE_NON_FRAGMENT)\n\t\t\tnfheader_len += xfrm[i]->props.header_len;\n\t\ttrailer_len += xfrm[i]->props.trailer_len;\n\t}\n\n\txfrm_dst_set_child(xdst_prev, dst);\n\txdst0->path = dst;\n\n\terr = -ENODEV;\n\tdev = dst->dev;\n\tif (!dev)\n\t\tgoto free_dst;\n\n\txfrm_init_path(xdst0, dst, nfheader_len);\n\txfrm_init_pmtu(bundle, nx);\n\n\tfor (xdst_prev = xdst0; xdst_prev != (struct xfrm_dst *)dst;\n\t     xdst_prev = (struct xfrm_dst *) xfrm_dst_child(&xdst_prev->u.dst)) {\n\t\terr = xfrm_fill_dst(xdst_prev, dev, fl);\n\t\tif (err)\n\t\t\tgoto free_dst;\n\n\t\txdst_prev->u.dst.header_len = header_len;\n\t\txdst_prev->u.dst.trailer_len = trailer_len;\n\t\theader_len -= xdst_prev->u.dst.xfrm->props.header_len;\n\t\ttrailer_len -= xdst_prev->u.dst.xfrm->props.trailer_len;\n\t}\n\n\treturn &xdst0->u.dst;\n\nput_states:\n\tfor (; i < nx; i++)\n\t\txfrm_state_put(xfrm[i]);\nfree_dst:\n\tif (xdst0)\n\t\tdst_release_immediate(&xdst0->u.dst);\n\n\treturn ERR_PTR(err);\n}\n\nstatic int xfrm_expand_policies(const struct flowi *fl, u16 family,\n\t\t\t\tstruct xfrm_policy **pols,\n\t\t\t\tint *num_pols, int *num_xfrms)\n{\n\tint i;\n\n\tif (*num_pols == 0 || !pols[0]) {\n\t\t*num_pols = 0;\n\t\t*num_xfrms = 0;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(pols[0]))\n\t\treturn PTR_ERR(pols[0]);\n\n\t*num_xfrms = pols[0]->xfrm_nr;\n\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0] && pols[0]->action == XFRM_POLICY_ALLOW &&\n\t    pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n\t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_OUT,\n\t\t\t\t\t\t    pols[0]->if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\txfrm_pols_put(pols, *num_pols);\n\t\t\t\treturn PTR_ERR(pols[1]);\n\t\t\t}\n\t\t\t(*num_pols)++;\n\t\t\t(*num_xfrms) += pols[1]->xfrm_nr;\n\t\t}\n\t}\n#endif\n\tfor (i = 0; i < *num_pols; i++) {\n\t\tif (pols[i]->action != XFRM_POLICY_ALLOW) {\n\t\t\t*num_xfrms = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}\n\nstatic struct xfrm_dst *\nxfrm_resolve_and_create_bundle(struct xfrm_policy **pols, int num_pols,\n\t\t\t       const struct flowi *fl, u16 family,\n\t\t\t       struct dst_entry *dst_orig)\n{\n\tstruct net *net = xp_net(pols[0]);\n\tstruct xfrm_state *xfrm[XFRM_MAX_DEPTH];\n\tstruct xfrm_dst *bundle[XFRM_MAX_DEPTH];\n\tstruct xfrm_dst *xdst;\n\tstruct dst_entry *dst;\n\tint err;\n\n\t/* Try to instantiate a bundle */\n\terr = xfrm_tmpl_resolve(pols, num_pols, fl, xfrm, family);\n\tif (err <= 0) {\n\t\tif (err == 0)\n\t\t\treturn NULL;\n\n\t\tif (err != -EAGAIN)\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTPOLERROR);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tdst = xfrm_bundle_create(pols[0], xfrm, bundle, err, fl, dst_orig);\n\tif (IS_ERR(dst)) {\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTBUNDLEGENERROR);\n\t\treturn ERR_CAST(dst);\n\t}\n\n\txdst = (struct xfrm_dst *)dst;\n\txdst->num_xfrms = err;\n\txdst->num_pols = num_pols;\n\tmemcpy(xdst->pols, pols, sizeof(struct xfrm_policy *) * num_pols);\n\txdst->policy_genid = atomic_read(&pols[0]->genid);\n\n\treturn xdst;\n}\n\nstatic void xfrm_policy_queue_process(struct timer_list *t)\n{\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\tstruct dst_entry *dst;\n\tstruct xfrm_policy *pol = from_timer(pol, t, polq.hold_timer);\n\tstruct net *net = xp_net(pol);\n\tstruct xfrm_policy_queue *pq = &pol->polq;\n\tstruct flowi fl;\n\tstruct sk_buff_head list;\n\t__u32 skb_mark;\n\n\tspin_lock(&pq->hold_queue.lock);\n\tskb = skb_peek(&pq->hold_queue);\n\tif (!skb) {\n\t\tspin_unlock(&pq->hold_queue.lock);\n\t\tgoto out;\n\t}\n\tdst = skb_dst(skb);\n\tsk = skb->sk;\n\n\t/* Fixup the mark to support VTI. */\n\tskb_mark = skb->mark;\n\tskb->mark = pol->mark.v;\n\txfrm_decode_session(skb, &fl, dst->ops->family);\n\tskb->mark = skb_mark;\n\tspin_unlock(&pq->hold_queue.lock);\n\n\tdst_hold(xfrm_dst_path(dst));\n\tdst = xfrm_lookup(net, xfrm_dst_path(dst), &fl, sk, XFRM_LOOKUP_QUEUE);\n\tif (IS_ERR(dst))\n\t\tgoto purge_queue;\n\n\tif (dst->flags & DST_XFRM_QUEUE) {\n\t\tdst_release(dst);\n\n\t\tif (pq->timeout >= XFRM_QUEUE_TMO_MAX)\n\t\t\tgoto purge_queue;\n\n\t\tpq->timeout = pq->timeout << 1;\n\t\tif (!mod_timer(&pq->hold_timer, jiffies + pq->timeout))\n\t\t\txfrm_pol_hold(pol);\n\t\tgoto out;\n\t}\n\n\tdst_release(dst);\n\n\t__skb_queue_head_init(&list);\n\n\tspin_lock(&pq->hold_queue.lock);\n\tpq->timeout = 0;\n\tskb_queue_splice_init(&pq->hold_queue, &list);\n\tspin_unlock(&pq->hold_queue.lock);\n\n\twhile (!skb_queue_empty(&list)) {\n\t\tskb = __skb_dequeue(&list);\n\n\t\t/* Fixup the mark to support VTI. */\n\t\tskb_mark = skb->mark;\n\t\tskb->mark = pol->mark.v;\n\t\txfrm_decode_session(skb, &fl, skb_dst(skb)->ops->family);\n\t\tskb->mark = skb_mark;\n\n\t\tdst_hold(xfrm_dst_path(skb_dst(skb)));\n\t\tdst = xfrm_lookup(net, xfrm_dst_path(skb_dst(skb)), &fl, skb->sk, 0);\n\t\tif (IS_ERR(dst)) {\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnf_reset_ct(skb);\n\t\tskb_dst_drop(skb);\n\t\tskb_dst_set(skb, dst);\n\n\t\tdst_output(net, skb->sk, skb);\n\t}\n\nout:\n\txfrm_pol_put(pol);\n\treturn;\n\npurge_queue:\n\tpq->timeout = 0;\n\tskb_queue_purge(&pq->hold_queue);\n\txfrm_pol_put(pol);\n}\n\nstatic int xdst_queue_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tunsigned long sched_next;\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct xfrm_dst *xdst = (struct xfrm_dst *) dst;\n\tstruct xfrm_policy *pol = xdst->pols[0];\n\tstruct xfrm_policy_queue *pq = &pol->polq;\n\n\tif (unlikely(skb_fclone_busy(sk, skb))) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tif (pq->hold_queue.qlen > XFRM_MAX_QUEUE_LEN) {\n\t\tkfree_skb(skb);\n\t\treturn -EAGAIN;\n\t}\n\n\tskb_dst_force(skb);\n\n\tspin_lock_bh(&pq->hold_queue.lock);\n\n\tif (!pq->timeout)\n\t\tpq->timeout = XFRM_QUEUE_TMO_MIN;\n\n\tsched_next = jiffies + pq->timeout;\n\n\tif (del_timer(&pq->hold_timer)) {\n\t\tif (time_before(pq->hold_timer.expires, sched_next))\n\t\t\tsched_next = pq->hold_timer.expires;\n\t\txfrm_pol_put(pol);\n\t}\n\n\t__skb_queue_tail(&pq->hold_queue, skb);\n\tif (!mod_timer(&pq->hold_timer, sched_next))\n\t\txfrm_pol_hold(pol);\n\n\tspin_unlock_bh(&pq->hold_queue.lock);\n\n\treturn 0;\n}\n\nstatic struct xfrm_dst *xfrm_create_dummy_bundle(struct net *net,\n\t\t\t\t\t\t struct xfrm_flo *xflo,\n\t\t\t\t\t\t const struct flowi *fl,\n\t\t\t\t\t\t int num_xfrms,\n\t\t\t\t\t\t u16 family)\n{\n\tint err;\n\tstruct net_device *dev;\n\tstruct dst_entry *dst;\n\tstruct dst_entry *dst1;\n\tstruct xfrm_dst *xdst;\n\n\txdst = xfrm_alloc_dst(net, family);\n\tif (IS_ERR(xdst))\n\t\treturn xdst;\n\n\tif (!(xflo->flags & XFRM_LOOKUP_QUEUE) ||\n\t    net->xfrm.sysctl_larval_drop ||\n\t    num_xfrms <= 0)\n\t\treturn xdst;\n\n\tdst = xflo->dst_orig;\n\tdst1 = &xdst->u.dst;\n\tdst_hold(dst);\n\txdst->route = dst;\n\n\tdst_copy_metrics(dst1, dst);\n\n\tdst1->obsolete = DST_OBSOLETE_FORCE_CHK;\n\tdst1->flags |= DST_XFRM_QUEUE;\n\tdst1->lastuse = jiffies;\n\n\tdst1->input = dst_discard;\n\tdst1->output = xdst_queue_output;\n\n\tdst_hold(dst);\n\txfrm_dst_set_child(xdst, dst);\n\txdst->path = dst;\n\n\txfrm_init_path((struct xfrm_dst *)dst1, dst, 0);\n\n\terr = -ENODEV;\n\tdev = dst->dev;\n\tif (!dev)\n\t\tgoto free_dst;\n\n\terr = xfrm_fill_dst(xdst, dev, fl);\n\tif (err)\n\t\tgoto free_dst;\n\nout:\n\treturn xdst;\n\nfree_dst:\n\tdst_release(dst1);\n\txdst = ERR_PTR(err);\n\tgoto out;\n}\n\nstatic struct xfrm_dst *xfrm_bundle_lookup(struct net *net,\n\t\t\t\t\t   const struct flowi *fl,\n\t\t\t\t\t   u16 family, u8 dir,\n\t\t\t\t\t   struct xfrm_flo *xflo, u32 if_id)\n{\n\tstruct xfrm_policy *pols[XFRM_POLICY_TYPE_MAX];\n\tint num_pols = 0, num_xfrms = 0, err;\n\tstruct xfrm_dst *xdst;\n\n\t/* Resolve policies to use if we couldn't get them from\n\t * previous cache entry */\n\tnum_pols = 1;\n\tpols[0] = xfrm_policy_lookup(net, fl, family, dir, if_id);\n\terr = xfrm_expand_policies(fl, family, pols,\n\t\t\t\t\t   &num_pols, &num_xfrms);\n\tif (err < 0)\n\t\tgoto inc_error;\n\tif (num_pols == 0)\n\t\treturn NULL;\n\tif (num_xfrms <= 0)\n\t\tgoto make_dummy_bundle;\n\n\txdst = xfrm_resolve_and_create_bundle(pols, num_pols, fl, family,\n\t\t\t\t\t      xflo->dst_orig);\n\tif (IS_ERR(xdst)) {\n\t\terr = PTR_ERR(xdst);\n\t\tif (err == -EREMOTE) {\n\t\t\txfrm_pols_put(pols, num_pols);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (err != -EAGAIN)\n\t\t\tgoto error;\n\t\tgoto make_dummy_bundle;\n\t} else if (xdst == NULL) {\n\t\tnum_xfrms = 0;\n\t\tgoto make_dummy_bundle;\n\t}\n\n\treturn xdst;\n\nmake_dummy_bundle:\n\t/* We found policies, but there's no bundles to instantiate:\n\t * either because the policy blocks, has no transformations or\n\t * we could not build template (no xfrm_states).*/\n\txdst = xfrm_create_dummy_bundle(net, xflo, fl, num_xfrms, family);\n\tif (IS_ERR(xdst)) {\n\t\txfrm_pols_put(pols, num_pols);\n\t\treturn ERR_CAST(xdst);\n\t}\n\txdst->num_pols = num_pols;\n\txdst->num_xfrms = num_xfrms;\n\tmemcpy(xdst->pols, pols, sizeof(struct xfrm_policy *) * num_pols);\n\n\treturn xdst;\n\ninc_error:\n\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTPOLERROR);\nerror:\n\txfrm_pols_put(pols, num_pols);\n\treturn ERR_PTR(err);\n}\n\nstatic struct dst_entry *make_blackhole(struct net *net, u16 family,\n\t\t\t\t\tstruct dst_entry *dst_orig)\n{\n\tconst struct xfrm_policy_afinfo *afinfo = xfrm_policy_get_afinfo(family);\n\tstruct dst_entry *ret;\n\n\tif (!afinfo) {\n\t\tdst_release(dst_orig);\n\t\treturn ERR_PTR(-EINVAL);\n\t} else {\n\t\tret = afinfo->blackhole_route(net, dst_orig);\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\n/* Finds/creates a bundle for given flow and if_id\n *\n * At the moment we eat a raw IP route. Mostly to speed up lookups\n * on interfaces with disabled IPsec.\n *\n * xfrm_lookup uses an if_id of 0 by default, and is provided for\n * compatibility\n */\nstruct dst_entry *xfrm_lookup_with_ifid(struct net *net,\n\t\t\t\t\tstruct dst_entry *dst_orig,\n\t\t\t\t\tconst struct flowi *fl,\n\t\t\t\t\tconst struct sock *sk,\n\t\t\t\t\tint flags, u32 if_id)\n{\n\tstruct xfrm_policy *pols[XFRM_POLICY_TYPE_MAX];\n\tstruct xfrm_dst *xdst;\n\tstruct dst_entry *dst, *route;\n\tu16 family = dst_orig->ops->family;\n\tu8 dir = XFRM_POLICY_OUT;\n\tint i, err, num_pols, num_xfrms = 0, drop_pols = 0;\n\n\tdst = NULL;\n\txdst = NULL;\n\troute = NULL;\n\n\tsk = sk_const_to_full_sk(sk);\n\tif (sk && sk->sk_policy[XFRM_POLICY_OUT]) {\n\t\tnum_pols = 1;\n\t\tpols[0] = xfrm_sk_policy_lookup(sk, XFRM_POLICY_OUT, fl, family,\n\t\t\t\t\t\tif_id);\n\t\terr = xfrm_expand_policies(fl, family, pols,\n\t\t\t\t\t   &num_pols, &num_xfrms);\n\t\tif (err < 0)\n\t\t\tgoto dropdst;\n\n\t\tif (num_pols) {\n\t\t\tif (num_xfrms <= 0) {\n\t\t\t\tdrop_pols = num_pols;\n\t\t\t\tgoto no_transform;\n\t\t\t}\n\n\t\t\txdst = xfrm_resolve_and_create_bundle(\n\t\t\t\t\tpols, num_pols, fl,\n\t\t\t\t\tfamily, dst_orig);\n\n\t\t\tif (IS_ERR(xdst)) {\n\t\t\t\txfrm_pols_put(pols, num_pols);\n\t\t\t\terr = PTR_ERR(xdst);\n\t\t\t\tif (err == -EREMOTE)\n\t\t\t\t\tgoto nopol;\n\n\t\t\t\tgoto dropdst;\n\t\t\t} else if (xdst == NULL) {\n\t\t\t\tnum_xfrms = 0;\n\t\t\t\tdrop_pols = num_pols;\n\t\t\t\tgoto no_transform;\n\t\t\t}\n\n\t\t\troute = xdst->route;\n\t\t}\n\t}\n\n\tif (xdst == NULL) {\n\t\tstruct xfrm_flo xflo;\n\n\t\txflo.dst_orig = dst_orig;\n\t\txflo.flags = flags;\n\n\t\t/* To accelerate a bit...  */\n\t\tif (!if_id && ((dst_orig->flags & DST_NOXFRM) ||\n\t\t\t       !net->xfrm.policy_count[XFRM_POLICY_OUT]))\n\t\t\tgoto nopol;\n\n\t\txdst = xfrm_bundle_lookup(net, fl, family, dir, &xflo, if_id);\n\t\tif (xdst == NULL)\n\t\t\tgoto nopol;\n\t\tif (IS_ERR(xdst)) {\n\t\t\terr = PTR_ERR(xdst);\n\t\t\tgoto dropdst;\n\t\t}\n\n\t\tnum_pols = xdst->num_pols;\n\t\tnum_xfrms = xdst->num_xfrms;\n\t\tmemcpy(pols, xdst->pols, sizeof(struct xfrm_policy *) * num_pols);\n\t\troute = xdst->route;\n\t}\n\n\tdst = &xdst->u.dst;\n\tif (route == NULL && num_xfrms > 0) {\n\t\t/* The only case when xfrm_bundle_lookup() returns a\n\t\t * bundle with null route, is when the template could\n\t\t * not be resolved. It means policies are there, but\n\t\t * bundle could not be created, since we don't yet\n\t\t * have the xfrm_state's. We need to wait for KM to\n\t\t * negotiate new SA's or bail out with error.*/\n\t\tif (net->xfrm.sysctl_larval_drop) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTNOSTATES);\n\t\t\terr = -EREMOTE;\n\t\t\tgoto error;\n\t\t}\n\n\t\terr = -EAGAIN;\n\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTNOSTATES);\n\t\tgoto error;\n\t}\n\nno_transform:\n\tif (num_pols == 0)\n\t\tgoto nopol;\n\n\tif ((flags & XFRM_LOOKUP_ICMP) &&\n\t    !(pols[0]->flags & XFRM_POLICY_ICMP)) {\n\t\terr = -ENOENT;\n\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < num_pols; i++)\n\t\tpols[i]->curlft.use_time = ktime_get_real_seconds();\n\n\tif (num_xfrms < 0) {\n\t\t/* Prohibit the flow */\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTPOLBLOCK);\n\t\terr = -EPERM;\n\t\tgoto error;\n\t} else if (num_xfrms > 0) {\n\t\t/* Flow transformed */\n\t\tdst_release(dst_orig);\n\t} else {\n\t\t/* Flow passes untransformed */\n\t\tdst_release(dst);\n\t\tdst = dst_orig;\n\t}\nok:\n\txfrm_pols_put(pols, drop_pols);\n\tif (dst && dst->xfrm &&\n\t    dst->xfrm->props.mode == XFRM_MODE_TUNNEL)\n\t\tdst->flags |= DST_XFRM_TUNNEL;\n\treturn dst;\n\nnopol:\n\tif (!(flags & XFRM_LOOKUP_ICMP)) {\n\t\tdst = dst_orig;\n\t\tgoto ok;\n\t}\n\terr = -ENOENT;\nerror:\n\tdst_release(dst);\ndropdst:\n\tif (!(flags & XFRM_LOOKUP_KEEP_DST_REF))\n\t\tdst_release(dst_orig);\n\txfrm_pols_put(pols, drop_pols);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(xfrm_lookup_with_ifid);\n\n/* Main function: finds/creates a bundle for given flow.\n *\n * At the moment we eat a raw IP route. Mostly to speed up lookups\n * on interfaces with disabled IPsec.\n */\nstruct dst_entry *xfrm_lookup(struct net *net, struct dst_entry *dst_orig,\n\t\t\t      const struct flowi *fl, const struct sock *sk,\n\t\t\t      int flags)\n{\n\treturn xfrm_lookup_with_ifid(net, dst_orig, fl, sk, flags, 0);\n}\nEXPORT_SYMBOL(xfrm_lookup);\n\n/* Callers of xfrm_lookup_route() must ensure a call to dst_output().\n * Otherwise we may send out blackholed packets.\n */\nstruct dst_entry *xfrm_lookup_route(struct net *net, struct dst_entry *dst_orig,\n\t\t\t\t    const struct flowi *fl,\n\t\t\t\t    const struct sock *sk, int flags)\n{\n\tstruct dst_entry *dst = xfrm_lookup(net, dst_orig, fl, sk,\n\t\t\t\t\t    flags | XFRM_LOOKUP_QUEUE |\n\t\t\t\t\t    XFRM_LOOKUP_KEEP_DST_REF);\n\n\tif (PTR_ERR(dst) == -EREMOTE)\n\t\treturn make_blackhole(net, dst_orig->ops->family, dst_orig);\n\n\tif (IS_ERR(dst))\n\t\tdst_release(dst_orig);\n\n\treturn dst;\n}\nEXPORT_SYMBOL(xfrm_lookup_route);\n\nstatic inline int\nxfrm_secpath_reject(int idx, struct sk_buff *skb, const struct flowi *fl)\n{\n\tstruct sec_path *sp = skb_sec_path(skb);\n\tstruct xfrm_state *x;\n\n\tif (!sp || idx < 0 || idx >= sp->len)\n\t\treturn 0;\n\tx = sp->xvec[idx];\n\tif (!x->type->reject)\n\t\treturn 0;\n\treturn x->type->reject(x, skb, fl);\n}\n\n/* When skb is transformed back to its \"native\" form, we have to\n * check policy restrictions. At the moment we make this in maximally\n * stupid way. Shame on me. :-) Of course, connected sockets must\n * have policy cached at them.\n */\n\nstatic inline int\nxfrm_state_ok(const struct xfrm_tmpl *tmpl, const struct xfrm_state *x,\n\t      unsigned short family)\n{\n\tif (xfrm_state_kern(x))\n\t\treturn tmpl->optional && !xfrm_state_addr_cmp(tmpl, x, tmpl->encap_family);\n\treturn\tx->id.proto == tmpl->id.proto &&\n\t\t(x->id.spi == tmpl->id.spi || !tmpl->id.spi) &&\n\t\t(x->props.reqid == tmpl->reqid || !tmpl->reqid) &&\n\t\tx->props.mode == tmpl->mode &&\n\t\t(tmpl->allalgs || (tmpl->aalgos & (1<<x->props.aalgo)) ||\n\t\t !(xfrm_id_proto_match(tmpl->id.proto, IPSEC_PROTO_ANY))) &&\n\t\t!(x->props.mode != XFRM_MODE_TRANSPORT &&\n\t\t  xfrm_state_addr_cmp(tmpl, x, family));\n}\n\n/*\n * 0 or more than 0 is returned when validation is succeeded (either bypass\n * because of optional transport mode, or next index of the mathced secpath\n * state with the template.\n * -1 is returned when no matching template is found.\n * Otherwise \"-2 - errored_index\" is returned.\n */\nstatic inline int\nxfrm_policy_ok(const struct xfrm_tmpl *tmpl, const struct sec_path *sp, int start,\n\t       unsigned short family)\n{\n\tint idx = start;\n\n\tif (tmpl->optional) {\n\t\tif (tmpl->mode == XFRM_MODE_TRANSPORT)\n\t\t\treturn start;\n\t} else\n\t\tstart = -1;\n\tfor (; idx < sp->len; idx++) {\n\t\tif (xfrm_state_ok(tmpl, sp->xvec[idx], family))\n\t\t\treturn ++idx;\n\t\tif (sp->xvec[idx]->props.mode != XFRM_MODE_TRANSPORT) {\n\t\t\tif (start == -1)\n\t\t\t\tstart = -2-idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn start;\n}\n\nstatic void\ndecode_session4(struct sk_buff *skb, struct flowi *fl, bool reverse)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tint ihl = iph->ihl;\n\tu8 *xprth = skb_network_header(skb) + ihl * 4;\n\tstruct flowi4 *fl4 = &fl->u.ip4;\n\tint oif = 0;\n\n\tif (skb_dst(skb) && skb_dst(skb)->dev)\n\t\toif = skb_dst(skb)->dev->ifindex;\n\n\tmemset(fl4, 0, sizeof(struct flowi4));\n\tfl4->flowi4_mark = skb->mark;\n\tfl4->flowi4_oif = reverse ? skb->skb_iif : oif;\n\n\tfl4->flowi4_proto = iph->protocol;\n\tfl4->daddr = reverse ? iph->saddr : iph->daddr;\n\tfl4->saddr = reverse ? iph->daddr : iph->saddr;\n\tfl4->flowi4_tos = iph->tos;\n\n\tif (!ip_is_fragment(iph)) {\n\t\tswitch (iph->protocol) {\n\t\tcase IPPROTO_UDP:\n\t\tcase IPPROTO_UDPLITE:\n\t\tcase IPPROTO_TCP:\n\t\tcase IPPROTO_SCTP:\n\t\tcase IPPROTO_DCCP:\n\t\t\tif (xprth + 4 < skb->data ||\n\t\t\t    pskb_may_pull(skb, xprth + 4 - skb->data)) {\n\t\t\t\t__be16 *ports;\n\n\t\t\t\txprth = skb_network_header(skb) + ihl * 4;\n\t\t\t\tports = (__be16 *)xprth;\n\n\t\t\t\tfl4->fl4_sport = ports[!!reverse];\n\t\t\t\tfl4->fl4_dport = ports[!reverse];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IPPROTO_ICMP:\n\t\t\tif (xprth + 2 < skb->data ||\n\t\t\t    pskb_may_pull(skb, xprth + 2 - skb->data)) {\n\t\t\t\tu8 *icmp;\n\n\t\t\t\txprth = skb_network_header(skb) + ihl * 4;\n\t\t\t\ticmp = xprth;\n\n\t\t\t\tfl4->fl4_icmp_type = icmp[0];\n\t\t\t\tfl4->fl4_icmp_code = icmp[1];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IPPROTO_ESP:\n\t\t\tif (xprth + 4 < skb->data ||\n\t\t\t    pskb_may_pull(skb, xprth + 4 - skb->data)) {\n\t\t\t\t__be32 *ehdr;\n\n\t\t\t\txprth = skb_network_header(skb) + ihl * 4;\n\t\t\t\tehdr = (__be32 *)xprth;\n\n\t\t\t\tfl4->fl4_ipsec_spi = ehdr[0];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IPPROTO_AH:\n\t\t\tif (xprth + 8 < skb->data ||\n\t\t\t    pskb_may_pull(skb, xprth + 8 - skb->data)) {\n\t\t\t\t__be32 *ah_hdr;\n\n\t\t\t\txprth = skb_network_header(skb) + ihl * 4;\n\t\t\t\tah_hdr = (__be32 *)xprth;\n\n\t\t\t\tfl4->fl4_ipsec_spi = ah_hdr[1];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IPPROTO_COMP:\n\t\t\tif (xprth + 4 < skb->data ||\n\t\t\t    pskb_may_pull(skb, xprth + 4 - skb->data)) {\n\t\t\t\t__be16 *ipcomp_hdr;\n\n\t\t\t\txprth = skb_network_header(skb) + ihl * 4;\n\t\t\t\tipcomp_hdr = (__be16 *)xprth;\n\n\t\t\t\tfl4->fl4_ipsec_spi = htonl(ntohs(ipcomp_hdr[1]));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IPPROTO_GRE:\n\t\t\tif (xprth + 12 < skb->data ||\n\t\t\t    pskb_may_pull(skb, xprth + 12 - skb->data)) {\n\t\t\t\t__be16 *greflags;\n\t\t\t\t__be32 *gre_hdr;\n\n\t\t\t\txprth = skb_network_header(skb) + ihl * 4;\n\t\t\t\tgreflags = (__be16 *)xprth;\n\t\t\t\tgre_hdr = (__be32 *)xprth;\n\n\t\t\t\tif (greflags[0] & GRE_KEY) {\n\t\t\t\t\tif (greflags[0] & GRE_CSUM)\n\t\t\t\t\t\tgre_hdr++;\n\t\t\t\t\tfl4->fl4_gre_key = gre_hdr[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfl4->fl4_ipsec_spi = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void\ndecode_session6(struct sk_buff *skb, struct flowi *fl, bool reverse)\n{\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tint onlyproto = 0;\n\tconst struct ipv6hdr *hdr = ipv6_hdr(skb);\n\tu32 offset = sizeof(*hdr);\n\tstruct ipv6_opt_hdr *exthdr;\n\tconst unsigned char *nh = skb_network_header(skb);\n\tu16 nhoff = IP6CB(skb)->nhoff;\n\tint oif = 0;\n\tu8 nexthdr;\n\n\tif (!nhoff)\n\t\tnhoff = offsetof(struct ipv6hdr, nexthdr);\n\n\tnexthdr = nh[nhoff];\n\n\tif (skb_dst(skb) && skb_dst(skb)->dev)\n\t\toif = skb_dst(skb)->dev->ifindex;\n\n\tmemset(fl6, 0, sizeof(struct flowi6));\n\tfl6->flowi6_mark = skb->mark;\n\tfl6->flowi6_oif = reverse ? skb->skb_iif : oif;\n\n\tfl6->daddr = reverse ? hdr->saddr : hdr->daddr;\n\tfl6->saddr = reverse ? hdr->daddr : hdr->saddr;\n\n\twhile (nh + offset + sizeof(*exthdr) < skb->data ||\n\t       pskb_may_pull(skb, nh + offset + sizeof(*exthdr) - skb->data)) {\n\t\tnh = skb_network_header(skb);\n\t\texthdr = (struct ipv6_opt_hdr *)(nh + offset);\n\n\t\tswitch (nexthdr) {\n\t\tcase NEXTHDR_FRAGMENT:\n\t\t\tonlyproto = 1;\n\t\t\tfallthrough;\n\t\tcase NEXTHDR_ROUTING:\n\t\tcase NEXTHDR_HOP:\n\t\tcase NEXTHDR_DEST:\n\t\t\toffset += ipv6_optlen(exthdr);\n\t\t\tnexthdr = exthdr->nexthdr;\n\t\t\texthdr = (struct ipv6_opt_hdr *)(nh + offset);\n\t\t\tbreak;\n\t\tcase IPPROTO_UDP:\n\t\tcase IPPROTO_UDPLITE:\n\t\tcase IPPROTO_TCP:\n\t\tcase IPPROTO_SCTP:\n\t\tcase IPPROTO_DCCP:\n\t\t\tif (!onlyproto && (nh + offset + 4 < skb->data ||\n\t\t\t     pskb_may_pull(skb, nh + offset + 4 - skb->data))) {\n\t\t\t\t__be16 *ports;\n\n\t\t\t\tnh = skb_network_header(skb);\n\t\t\t\tports = (__be16 *)(nh + offset);\n\t\t\t\tfl6->fl6_sport = ports[!!reverse];\n\t\t\t\tfl6->fl6_dport = ports[!reverse];\n\t\t\t}\n\t\t\tfl6->flowi6_proto = nexthdr;\n\t\t\treturn;\n\t\tcase IPPROTO_ICMPV6:\n\t\t\tif (!onlyproto && (nh + offset + 2 < skb->data ||\n\t\t\t    pskb_may_pull(skb, nh + offset + 2 - skb->data))) {\n\t\t\t\tu8 *icmp;\n\n\t\t\t\tnh = skb_network_header(skb);\n\t\t\t\ticmp = (u8 *)(nh + offset);\n\t\t\t\tfl6->fl6_icmp_type = icmp[0];\n\t\t\t\tfl6->fl6_icmp_code = icmp[1];\n\t\t\t}\n\t\t\tfl6->flowi6_proto = nexthdr;\n\t\t\treturn;\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\tcase IPPROTO_MH:\n\t\t\toffset += ipv6_optlen(exthdr);\n\t\t\tif (!onlyproto && (nh + offset + 3 < skb->data ||\n\t\t\t    pskb_may_pull(skb, nh + offset + 3 - skb->data))) {\n\t\t\t\tstruct ip6_mh *mh;\n\n\t\t\t\tnh = skb_network_header(skb);\n\t\t\t\tmh = (struct ip6_mh *)(nh + offset);\n\t\t\t\tfl6->fl6_mh_type = mh->ip6mh_type;\n\t\t\t}\n\t\t\tfl6->flowi6_proto = nexthdr;\n\t\t\treturn;\n#endif\n\t\t/* XXX Why are there these headers? */\n\t\tcase IPPROTO_AH:\n\t\tcase IPPROTO_ESP:\n\t\tcase IPPROTO_COMP:\n\t\tdefault:\n\t\t\tfl6->fl6_ipsec_spi = 0;\n\t\t\tfl6->flowi6_proto = nexthdr;\n\t\t\treturn;\n\t\t}\n\t}\n}\n#endif\n\nint __xfrm_decode_session(struct sk_buff *skb, struct flowi *fl,\n\t\t\t  unsigned int family, int reverse)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\tdecode_session4(skb, fl, reverse);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tdecode_session6(skb, fl, reverse);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EAFNOSUPPORT;\n\t}\n\n\treturn security_xfrm_decode_session(skb, &fl->flowi_secid);\n}\nEXPORT_SYMBOL(__xfrm_decode_session);\n\nstatic inline int secpath_has_nontransport(const struct sec_path *sp, int k, int *idxp)\n{\n\tfor (; k < sp->len; k++) {\n\t\tif (sp->xvec[k]->props.mode != XFRM_MODE_TRANSPORT) {\n\t\t\t*idxp = k;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint __xfrm_policy_check(struct sock *sk, int dir, struct sk_buff *skb,\n\t\t\tunsigned short family)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct xfrm_policy *pol;\n\tstruct xfrm_policy *pols[XFRM_POLICY_TYPE_MAX];\n\tint npols = 0;\n\tint xfrm_nr;\n\tint pi;\n\tint reverse;\n\tstruct flowi fl;\n\tint xerr_idx = -1;\n\tconst struct xfrm_if_cb *ifcb;\n\tstruct sec_path *sp;\n\tstruct xfrm_if *xi;\n\tu32 if_id = 0;\n\n\trcu_read_lock();\n\tifcb = xfrm_if_get_cb();\n\n\tif (ifcb) {\n\t\txi = ifcb->decode_session(skb, family);\n\t\tif (xi) {\n\t\t\tif_id = xi->p.if_id;\n\t\t\tnet = xi->net;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treverse = dir & ~XFRM_POLICY_MASK;\n\tdir &= XFRM_POLICY_MASK;\n\n\tif (__xfrm_decode_session(skb, &fl, family, reverse) < 0) {\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINHDRERROR);\n\t\treturn 0;\n\t}\n\n\tnf_nat_decode_session(skb, &fl, family);\n\n\t/* First, check used SA against their selectors. */\n\tsp = skb_sec_path(skb);\n\tif (sp) {\n\t\tint i;\n\n\t\tfor (i = sp->len - 1; i >= 0; i--) {\n\t\t\tstruct xfrm_state *x = sp->xvec[i];\n\t\t\tif (!xfrm_selector_match(&x->sel, &fl, family)) {\n\t\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMISMATCH);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpol = NULL;\n\tsk = sk_to_full_sk(sk);\n\tif (sk && sk->sk_policy[dir]) {\n\t\tpol = xfrm_sk_policy_lookup(sk, dir, &fl, family, if_id);\n\t\tif (IS_ERR(pol)) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINPOLERROR);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!pol)\n\t\tpol = xfrm_policy_lookup(net, &fl, family, dir, if_id);\n\n\tif (IS_ERR(pol)) {\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINPOLERROR);\n\t\treturn 0;\n\t}\n\n\tif (!pol) {\n\t\tif (sp && secpath_has_nontransport(sp, 0, &xerr_idx)) {\n\t\t\txfrm_secpath_reject(xerr_idx, skb, &fl);\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINNOPOLS);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tpol->curlft.use_time = ktime_get_real_seconds();\n\n\tpols[0] = pol;\n\tnpols++;\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(net, XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    &fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_IN, if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINPOLERROR);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpols[1]->curlft.use_time = ktime_get_real_seconds();\n\t\t\tnpols++;\n\t\t}\n\t}\n#endif\n\n\tif (pol->action == XFRM_POLICY_ALLOW) {\n\t\tstatic struct sec_path dummy;\n\t\tstruct xfrm_tmpl *tp[XFRM_MAX_DEPTH];\n\t\tstruct xfrm_tmpl *stp[XFRM_MAX_DEPTH];\n\t\tstruct xfrm_tmpl **tpp = tp;\n\t\tint ti = 0;\n\t\tint i, k;\n\n\t\tsp = skb_sec_path(skb);\n\t\tif (!sp)\n\t\t\tsp = &dummy;\n\n\t\tfor (pi = 0; pi < npols; pi++) {\n\t\t\tif (pols[pi] != pol &&\n\t\t\t    pols[pi]->action != XFRM_POLICY_ALLOW) {\n\t\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINPOLBLOCK);\n\t\t\t\tgoto reject;\n\t\t\t}\n\t\t\tif (ti + pols[pi]->xfrm_nr >= XFRM_MAX_DEPTH) {\n\t\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINBUFFERERROR);\n\t\t\t\tgoto reject_error;\n\t\t\t}\n\t\t\tfor (i = 0; i < pols[pi]->xfrm_nr; i++)\n\t\t\t\ttpp[ti++] = &pols[pi]->xfrm_vec[i];\n\t\t}\n\t\txfrm_nr = ti;\n\t\tif (npols > 1) {\n\t\t\txfrm_tmpl_sort(stp, tpp, xfrm_nr, family);\n\t\t\ttpp = stp;\n\t\t}\n\n\t\t/* For each tunnel xfrm, find the first matching tmpl.\n\t\t * For each tmpl before that, find corresponding xfrm.\n\t\t * Order is _important_. Later we will implement\n\t\t * some barriers, but at the moment barriers\n\t\t * are implied between each two transformations.\n\t\t */\n\t\tfor (i = xfrm_nr-1, k = 0; i >= 0; i--) {\n\t\t\tk = xfrm_policy_ok(tpp[i], sp, k, family);\n\t\t\tif (k < 0) {\n\t\t\t\tif (k < -1)\n\t\t\t\t\t/* \"-2 - errored_index\" returned */\n\t\t\t\t\txerr_idx = -(2+k);\n\t\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINTMPLMISMATCH);\n\t\t\t\tgoto reject;\n\t\t\t}\n\t\t}\n\n\t\tif (secpath_has_nontransport(sp, k, &xerr_idx)) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINTMPLMISMATCH);\n\t\t\tgoto reject;\n\t\t}\n\n\t\txfrm_pols_put(pols, npols);\n\t\treturn 1;\n\t}\n\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINPOLBLOCK);\n\nreject:\n\txfrm_secpath_reject(xerr_idx, skb, &fl);\nreject_error:\n\txfrm_pols_put(pols, npols);\n\treturn 0;\n}\nEXPORT_SYMBOL(__xfrm_policy_check);\n\nint __xfrm_route_forward(struct sk_buff *skb, unsigned short family)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct flowi fl;\n\tstruct dst_entry *dst;\n\tint res = 1;\n\n\tif (xfrm_decode_session(skb, &fl, family) < 0) {\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMFWDHDRERROR);\n\t\treturn 0;\n\t}\n\n\tskb_dst_force(skb);\n\tif (!skb_dst(skb)) {\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMFWDHDRERROR);\n\t\treturn 0;\n\t}\n\n\tdst = xfrm_lookup(net, skb_dst(skb), &fl, NULL, XFRM_LOOKUP_QUEUE);\n\tif (IS_ERR(dst)) {\n\t\tres = 0;\n\t\tdst = NULL;\n\t}\n\tskb_dst_set(skb, dst);\n\treturn res;\n}\nEXPORT_SYMBOL(__xfrm_route_forward);\n\n/* Optimize later using cookies and generation ids. */\n\nstatic struct dst_entry *xfrm_dst_check(struct dst_entry *dst, u32 cookie)\n{\n\t/* Code (such as __xfrm4_bundle_create()) sets dst->obsolete\n\t * to DST_OBSOLETE_FORCE_CHK to force all XFRM destinations to\n\t * get validated by dst_ops->check on every use.  We do this\n\t * because when a normal route referenced by an XFRM dst is\n\t * obsoleted we do not go looking around for all parent\n\t * referencing XFRM dsts so that we can invalidate them.  It\n\t * is just too much work.  Instead we make the checks here on\n\t * every use.  For example:\n\t *\n\t *\tXFRM dst A --> IPv4 dst X\n\t *\n\t * X is the \"xdst->route\" of A (X is also the \"dst->path\" of A\n\t * in this example).  If X is marked obsolete, \"A\" will not\n\t * notice.  That's what we are validating here via the\n\t * stale_bundle() check.\n\t *\n\t * When a dst is removed from the fib tree, DST_OBSOLETE_DEAD will\n\t * be marked on it.\n\t * This will force stale_bundle() to fail on any xdst bundle with\n\t * this dst linked in it.\n\t */\n\tif (dst->obsolete < 0 && !stale_bundle(dst))\n\t\treturn dst;\n\n\treturn NULL;\n}\n\nstatic int stale_bundle(struct dst_entry *dst)\n{\n\treturn !xfrm_bundle_ok((struct xfrm_dst *)dst);\n}\n\nvoid xfrm_dst_ifdown(struct dst_entry *dst, struct net_device *dev)\n{\n\twhile ((dst = xfrm_dst_child(dst)) && dst->xfrm && dst->dev == dev) {\n\t\tdst->dev = dev_net(dev)->loopback_dev;\n\t\tdev_hold(dst->dev);\n\t\tdev_put(dev);\n\t}\n}\nEXPORT_SYMBOL(xfrm_dst_ifdown);\n\nstatic void xfrm_link_failure(struct sk_buff *skb)\n{\n\t/* Impossible. Such dst must be popped before reaches point of failure. */\n}\n\nstatic struct dst_entry *xfrm_negative_advice(struct dst_entry *dst)\n{\n\tif (dst) {\n\t\tif (dst->obsolete) {\n\t\t\tdst_release(dst);\n\t\t\tdst = NULL;\n\t\t}\n\t}\n\treturn dst;\n}\n\nstatic void xfrm_init_pmtu(struct xfrm_dst **bundle, int nr)\n{\n\twhile (nr--) {\n\t\tstruct xfrm_dst *xdst = bundle[nr];\n\t\tu32 pmtu, route_mtu_cached;\n\t\tstruct dst_entry *dst;\n\n\t\tdst = &xdst->u.dst;\n\t\tpmtu = dst_mtu(xfrm_dst_child(dst));\n\t\txdst->child_mtu_cached = pmtu;\n\n\t\tpmtu = xfrm_state_mtu(dst->xfrm, pmtu);\n\n\t\troute_mtu_cached = dst_mtu(xdst->route);\n\t\txdst->route_mtu_cached = route_mtu_cached;\n\n\t\tif (pmtu > route_mtu_cached)\n\t\t\tpmtu = route_mtu_cached;\n\n\t\tdst_metric_set(dst, RTAX_MTU, pmtu);\n\t}\n}\n\n/* Check that the bundle accepts the flow and its components are\n * still valid.\n */\n\nstatic int xfrm_bundle_ok(struct xfrm_dst *first)\n{\n\tstruct xfrm_dst *bundle[XFRM_MAX_DEPTH];\n\tstruct dst_entry *dst = &first->u.dst;\n\tstruct xfrm_dst *xdst;\n\tint start_from, nr;\n\tu32 mtu;\n\n\tif (!dst_check(xfrm_dst_path(dst), ((struct xfrm_dst *)dst)->path_cookie) ||\n\t    (dst->dev && !netif_running(dst->dev)))\n\t\treturn 0;\n\n\tif (dst->flags & DST_XFRM_QUEUE)\n\t\treturn 1;\n\n\tstart_from = nr = 0;\n\tdo {\n\t\tstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\n\n\t\tif (dst->xfrm->km.state != XFRM_STATE_VALID)\n\t\t\treturn 0;\n\t\tif (xdst->xfrm_genid != dst->xfrm->genid)\n\t\t\treturn 0;\n\t\tif (xdst->num_pols > 0 &&\n\t\t    xdst->policy_genid != atomic_read(&xdst->pols[0]->genid))\n\t\t\treturn 0;\n\n\t\tbundle[nr++] = xdst;\n\n\t\tmtu = dst_mtu(xfrm_dst_child(dst));\n\t\tif (xdst->child_mtu_cached != mtu) {\n\t\t\tstart_from = nr;\n\t\t\txdst->child_mtu_cached = mtu;\n\t\t}\n\n\t\tif (!dst_check(xdst->route, xdst->route_cookie))\n\t\t\treturn 0;\n\t\tmtu = dst_mtu(xdst->route);\n\t\tif (xdst->route_mtu_cached != mtu) {\n\t\t\tstart_from = nr;\n\t\t\txdst->route_mtu_cached = mtu;\n\t\t}\n\n\t\tdst = xfrm_dst_child(dst);\n\t} while (dst->xfrm);\n\n\tif (likely(!start_from))\n\t\treturn 1;\n\n\txdst = bundle[start_from - 1];\n\tmtu = xdst->child_mtu_cached;\n\twhile (start_from--) {\n\t\tdst = &xdst->u.dst;\n\n\t\tmtu = xfrm_state_mtu(dst->xfrm, mtu);\n\t\tif (mtu > xdst->route_mtu_cached)\n\t\t\tmtu = xdst->route_mtu_cached;\n\t\tdst_metric_set(dst, RTAX_MTU, mtu);\n\t\tif (!start_from)\n\t\t\tbreak;\n\n\t\txdst = bundle[start_from - 1];\n\t\txdst->child_mtu_cached = mtu;\n\t}\n\n\treturn 1;\n}\n\nstatic unsigned int xfrm_default_advmss(const struct dst_entry *dst)\n{\n\treturn dst_metric_advmss(xfrm_dst_path(dst));\n}\n\nstatic unsigned int xfrm_mtu(const struct dst_entry *dst)\n{\n\tunsigned int mtu = dst_metric_raw(dst, RTAX_MTU);\n\n\treturn mtu ? : dst_mtu(xfrm_dst_path(dst));\n}\n\nstatic const void *xfrm_get_dst_nexthop(const struct dst_entry *dst,\n\t\t\t\t\tconst void *daddr)\n{\n\twhile (dst->xfrm) {\n\t\tconst struct xfrm_state *xfrm = dst->xfrm;\n\n\t\tdst = xfrm_dst_child(dst);\n\n\t\tif (xfrm->props.mode == XFRM_MODE_TRANSPORT)\n\t\t\tcontinue;\n\t\tif (xfrm->type->flags & XFRM_TYPE_REMOTE_COADDR)\n\t\t\tdaddr = xfrm->coaddr;\n\t\telse if (!(xfrm->type->flags & XFRM_TYPE_LOCAL_COADDR))\n\t\t\tdaddr = &xfrm->id.daddr;\n\t}\n\treturn daddr;\n}\n\nstatic struct neighbour *xfrm_neigh_lookup(const struct dst_entry *dst,\n\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t   const void *daddr)\n{\n\tconst struct dst_entry *path = xfrm_dst_path(dst);\n\n\tif (!skb)\n\t\tdaddr = xfrm_get_dst_nexthop(dst, daddr);\n\treturn path->ops->neigh_lookup(path, skb, daddr);\n}\n\nstatic void xfrm_confirm_neigh(const struct dst_entry *dst, const void *daddr)\n{\n\tconst struct dst_entry *path = xfrm_dst_path(dst);\n\n\tdaddr = xfrm_get_dst_nexthop(dst, daddr);\n\tpath->ops->confirm_neigh(path, daddr);\n}\n\nint xfrm_policy_register_afinfo(const struct xfrm_policy_afinfo *afinfo, int family)\n{\n\tint err = 0;\n\n\tif (WARN_ON(family >= ARRAY_SIZE(xfrm_policy_afinfo)))\n\t\treturn -EAFNOSUPPORT;\n\n\tspin_lock(&xfrm_policy_afinfo_lock);\n\tif (unlikely(xfrm_policy_afinfo[family] != NULL))\n\t\terr = -EEXIST;\n\telse {\n\t\tstruct dst_ops *dst_ops = afinfo->dst_ops;\n\t\tif (likely(dst_ops->kmem_cachep == NULL))\n\t\t\tdst_ops->kmem_cachep = xfrm_dst_cache;\n\t\tif (likely(dst_ops->check == NULL))\n\t\t\tdst_ops->check = xfrm_dst_check;\n\t\tif (likely(dst_ops->default_advmss == NULL))\n\t\t\tdst_ops->default_advmss = xfrm_default_advmss;\n\t\tif (likely(dst_ops->mtu == NULL))\n\t\t\tdst_ops->mtu = xfrm_mtu;\n\t\tif (likely(dst_ops->negative_advice == NULL))\n\t\t\tdst_ops->negative_advice = xfrm_negative_advice;\n\t\tif (likely(dst_ops->link_failure == NULL))\n\t\t\tdst_ops->link_failure = xfrm_link_failure;\n\t\tif (likely(dst_ops->neigh_lookup == NULL))\n\t\t\tdst_ops->neigh_lookup = xfrm_neigh_lookup;\n\t\tif (likely(!dst_ops->confirm_neigh))\n\t\t\tdst_ops->confirm_neigh = xfrm_confirm_neigh;\n\t\trcu_assign_pointer(xfrm_policy_afinfo[family], afinfo);\n\t}\n\tspin_unlock(&xfrm_policy_afinfo_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(xfrm_policy_register_afinfo);\n\nvoid xfrm_policy_unregister_afinfo(const struct xfrm_policy_afinfo *afinfo)\n{\n\tstruct dst_ops *dst_ops = afinfo->dst_ops;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(xfrm_policy_afinfo); i++) {\n\t\tif (xfrm_policy_afinfo[i] != afinfo)\n\t\t\tcontinue;\n\t\tRCU_INIT_POINTER(xfrm_policy_afinfo[i], NULL);\n\t\tbreak;\n\t}\n\n\tsynchronize_rcu();\n\n\tdst_ops->kmem_cachep = NULL;\n\tdst_ops->check = NULL;\n\tdst_ops->negative_advice = NULL;\n\tdst_ops->link_failure = NULL;\n}\nEXPORT_SYMBOL(xfrm_policy_unregister_afinfo);\n\nvoid xfrm_if_register_cb(const struct xfrm_if_cb *ifcb)\n{\n\tspin_lock(&xfrm_if_cb_lock);\n\trcu_assign_pointer(xfrm_if_cb, ifcb);\n\tspin_unlock(&xfrm_if_cb_lock);\n}\nEXPORT_SYMBOL(xfrm_if_register_cb);\n\nvoid xfrm_if_unregister_cb(void)\n{\n\tRCU_INIT_POINTER(xfrm_if_cb, NULL);\n\tsynchronize_rcu();\n}\nEXPORT_SYMBOL(xfrm_if_unregister_cb);\n\n#ifdef CONFIG_XFRM_STATISTICS\nstatic int __net_init xfrm_statistics_init(struct net *net)\n{\n\tint rv;\n\tnet->mib.xfrm_statistics = alloc_percpu(struct linux_xfrm_mib);\n\tif (!net->mib.xfrm_statistics)\n\t\treturn -ENOMEM;\n\trv = xfrm_proc_init(net);\n\tif (rv < 0)\n\t\tfree_percpu(net->mib.xfrm_statistics);\n\treturn rv;\n}\n\nstatic void xfrm_statistics_fini(struct net *net)\n{\n\txfrm_proc_fini(net);\n\tfree_percpu(net->mib.xfrm_statistics);\n}\n#else\nstatic int __net_init xfrm_statistics_init(struct net *net)\n{\n\treturn 0;\n}\n\nstatic void xfrm_statistics_fini(struct net *net)\n{\n}\n#endif\n\nstatic int __net_init xfrm_policy_init(struct net *net)\n{\n\tunsigned int hmask, sz;\n\tint dir, err;\n\n\tif (net_eq(net, &init_net)) {\n\t\txfrm_dst_cache = kmem_cache_create(\"xfrm_dst_cache\",\n\t\t\t\t\t   sizeof(struct xfrm_dst),\n\t\t\t\t\t   0, SLAB_HWCACHE_ALIGN|SLAB_PANIC,\n\t\t\t\t\t   NULL);\n\t\terr = rhashtable_init(&xfrm_policy_inexact_table,\n\t\t\t\t      &xfrm_pol_inexact_params);\n\t\tBUG_ON(err);\n\t}\n\n\thmask = 8 - 1;\n\tsz = (hmask+1) * sizeof(struct hlist_head);\n\n\tnet->xfrm.policy_byidx = xfrm_hash_alloc(sz);\n\tif (!net->xfrm.policy_byidx)\n\t\tgoto out_byidx;\n\tnet->xfrm.policy_idx_hmask = hmask;\n\n\tfor (dir = 0; dir < XFRM_POLICY_MAX; dir++) {\n\t\tstruct xfrm_policy_hash *htab;\n\n\t\tnet->xfrm.policy_count[dir] = 0;\n\t\tnet->xfrm.policy_count[XFRM_POLICY_MAX + dir] = 0;\n\t\tINIT_HLIST_HEAD(&net->xfrm.policy_inexact[dir]);\n\n\t\thtab = &net->xfrm.policy_bydst[dir];\n\t\thtab->table = xfrm_hash_alloc(sz);\n\t\tif (!htab->table)\n\t\t\tgoto out_bydst;\n\t\thtab->hmask = hmask;\n\t\thtab->dbits4 = 32;\n\t\thtab->sbits4 = 32;\n\t\thtab->dbits6 = 128;\n\t\thtab->sbits6 = 128;\n\t}\n\tnet->xfrm.policy_hthresh.lbits4 = 32;\n\tnet->xfrm.policy_hthresh.rbits4 = 32;\n\tnet->xfrm.policy_hthresh.lbits6 = 128;\n\tnet->xfrm.policy_hthresh.rbits6 = 128;\n\n\tseqlock_init(&net->xfrm.policy_hthresh.lock);\n\n\tINIT_LIST_HEAD(&net->xfrm.policy_all);\n\tINIT_LIST_HEAD(&net->xfrm.inexact_bins);\n\tINIT_WORK(&net->xfrm.policy_hash_work, xfrm_hash_resize);\n\tINIT_WORK(&net->xfrm.policy_hthresh.work, xfrm_hash_rebuild);\n\treturn 0;\n\nout_bydst:\n\tfor (dir--; dir >= 0; dir--) {\n\t\tstruct xfrm_policy_hash *htab;\n\n\t\thtab = &net->xfrm.policy_bydst[dir];\n\t\txfrm_hash_free(htab->table, sz);\n\t}\n\txfrm_hash_free(net->xfrm.policy_byidx, sz);\nout_byidx:\n\treturn -ENOMEM;\n}\n\nstatic void xfrm_policy_fini(struct net *net)\n{\n\tstruct xfrm_pol_inexact_bin *b, *t;\n\tunsigned int sz;\n\tint dir;\n\n\tflush_work(&net->xfrm.policy_hash_work);\n#ifdef CONFIG_XFRM_SUB_POLICY\n\txfrm_policy_flush(net, XFRM_POLICY_TYPE_SUB, false);\n#endif\n\txfrm_policy_flush(net, XFRM_POLICY_TYPE_MAIN, false);\n\n\tWARN_ON(!list_empty(&net->xfrm.policy_all));\n\n\tfor (dir = 0; dir < XFRM_POLICY_MAX; dir++) {\n\t\tstruct xfrm_policy_hash *htab;\n\n\t\tWARN_ON(!hlist_empty(&net->xfrm.policy_inexact[dir]));\n\n\t\thtab = &net->xfrm.policy_bydst[dir];\n\t\tsz = (htab->hmask + 1) * sizeof(struct hlist_head);\n\t\tWARN_ON(!hlist_empty(htab->table));\n\t\txfrm_hash_free(htab->table, sz);\n\t}\n\n\tsz = (net->xfrm.policy_idx_hmask + 1) * sizeof(struct hlist_head);\n\tWARN_ON(!hlist_empty(net->xfrm.policy_byidx));\n\txfrm_hash_free(net->xfrm.policy_byidx, sz);\n\n\tspin_lock_bh(&net->xfrm.xfrm_policy_lock);\n\tlist_for_each_entry_safe(b, t, &net->xfrm.inexact_bins, inexact_bins)\n\t\t__xfrm_policy_inexact_prune_bin(b, true);\n\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n}\n\nstatic int __net_init xfrm_net_init(struct net *net)\n{\n\tint rv;\n\n\t/* Initialize the per-net locks here */\n\tspin_lock_init(&net->xfrm.xfrm_state_lock);\n\tspin_lock_init(&net->xfrm.xfrm_policy_lock);\n\tmutex_init(&net->xfrm.xfrm_cfg_mutex);\n\n\trv = xfrm_statistics_init(net);\n\tif (rv < 0)\n\t\tgoto out_statistics;\n\trv = xfrm_state_init(net);\n\tif (rv < 0)\n\t\tgoto out_state;\n\trv = xfrm_policy_init(net);\n\tif (rv < 0)\n\t\tgoto out_policy;\n\trv = xfrm_sysctl_init(net);\n\tif (rv < 0)\n\t\tgoto out_sysctl;\n\n\treturn 0;\n\nout_sysctl:\n\txfrm_policy_fini(net);\nout_policy:\n\txfrm_state_fini(net);\nout_state:\n\txfrm_statistics_fini(net);\nout_statistics:\n\treturn rv;\n}\n\nstatic void __net_exit xfrm_net_exit(struct net *net)\n{\n\txfrm_sysctl_fini(net);\n\txfrm_policy_fini(net);\n\txfrm_state_fini(net);\n\txfrm_statistics_fini(net);\n}\n\nstatic struct pernet_operations __net_initdata xfrm_net_ops = {\n\t.init = xfrm_net_init,\n\t.exit = xfrm_net_exit,\n};\n\nvoid __init xfrm_init(void)\n{\n\tregister_pernet_subsys(&xfrm_net_ops);\n\txfrm_dev_init();\n\tseqcount_mutex_init(&xfrm_policy_hash_generation, &hash_resize_mutex);\n\txfrm_input_init();\n\n#ifdef CONFIG_XFRM_ESPINTCP\n\tespintcp_init();\n#endif\n\n\tRCU_INIT_POINTER(xfrm_if_cb, NULL);\n\tsynchronize_rcu();\n}\n\n#ifdef CONFIG_AUDITSYSCALL\nstatic void xfrm_audit_common_policyinfo(struct xfrm_policy *xp,\n\t\t\t\t\t struct audit_buffer *audit_buf)\n{\n\tstruct xfrm_sec_ctx *ctx = xp->security;\n\tstruct xfrm_selector *sel = &xp->selector;\n\n\tif (ctx)\n\t\taudit_log_format(audit_buf, \" sec_alg=%u sec_doi=%u sec_obj=%s\",\n\t\t\t\t ctx->ctx_alg, ctx->ctx_doi, ctx->ctx_str);\n\n\tswitch (sel->family) {\n\tcase AF_INET:\n\t\taudit_log_format(audit_buf, \" src=%pI4\", &sel->saddr.a4);\n\t\tif (sel->prefixlen_s != 32)\n\t\t\taudit_log_format(audit_buf, \" src_prefixlen=%d\",\n\t\t\t\t\t sel->prefixlen_s);\n\t\taudit_log_format(audit_buf, \" dst=%pI4\", &sel->daddr.a4);\n\t\tif (sel->prefixlen_d != 32)\n\t\t\taudit_log_format(audit_buf, \" dst_prefixlen=%d\",\n\t\t\t\t\t sel->prefixlen_d);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taudit_log_format(audit_buf, \" src=%pI6\", sel->saddr.a6);\n\t\tif (sel->prefixlen_s != 128)\n\t\t\taudit_log_format(audit_buf, \" src_prefixlen=%d\",\n\t\t\t\t\t sel->prefixlen_s);\n\t\taudit_log_format(audit_buf, \" dst=%pI6\", sel->daddr.a6);\n\t\tif (sel->prefixlen_d != 128)\n\t\t\taudit_log_format(audit_buf, \" dst_prefixlen=%d\",\n\t\t\t\t\t sel->prefixlen_d);\n\t\tbreak;\n\t}\n}\n\nvoid xfrm_audit_policy_add(struct xfrm_policy *xp, int result, bool task_valid)\n{\n\tstruct audit_buffer *audit_buf;\n\n\taudit_buf = xfrm_audit_start(\"SPD-add\");\n\tif (audit_buf == NULL)\n\t\treturn;\n\txfrm_audit_helper_usrinfo(task_valid, audit_buf);\n\taudit_log_format(audit_buf, \" res=%u\", result);\n\txfrm_audit_common_policyinfo(xp, audit_buf);\n\taudit_log_end(audit_buf);\n}\nEXPORT_SYMBOL_GPL(xfrm_audit_policy_add);\n\nvoid xfrm_audit_policy_delete(struct xfrm_policy *xp, int result,\n\t\t\t      bool task_valid)\n{\n\tstruct audit_buffer *audit_buf;\n\n\taudit_buf = xfrm_audit_start(\"SPD-delete\");\n\tif (audit_buf == NULL)\n\t\treturn;\n\txfrm_audit_helper_usrinfo(task_valid, audit_buf);\n\taudit_log_format(audit_buf, \" res=%u\", result);\n\txfrm_audit_common_policyinfo(xp, audit_buf);\n\taudit_log_end(audit_buf);\n}\nEXPORT_SYMBOL_GPL(xfrm_audit_policy_delete);\n#endif\n\n#ifdef CONFIG_XFRM_MIGRATE\nstatic bool xfrm_migrate_selector_match(const struct xfrm_selector *sel_cmp,\n\t\t\t\t\tconst struct xfrm_selector *sel_tgt)\n{\n\tif (sel_cmp->proto == IPSEC_ULPROTO_ANY) {\n\t\tif (sel_tgt->family == sel_cmp->family &&\n\t\t    xfrm_addr_equal(&sel_tgt->daddr, &sel_cmp->daddr,\n\t\t\t\t    sel_cmp->family) &&\n\t\t    xfrm_addr_equal(&sel_tgt->saddr, &sel_cmp->saddr,\n\t\t\t\t    sel_cmp->family) &&\n\t\t    sel_tgt->prefixlen_d == sel_cmp->prefixlen_d &&\n\t\t    sel_tgt->prefixlen_s == sel_cmp->prefixlen_s) {\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\tif (memcmp(sel_tgt, sel_cmp, sizeof(*sel_tgt)) == 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic struct xfrm_policy *xfrm_migrate_policy_find(const struct xfrm_selector *sel,\n\t\t\t\t\t\t    u8 dir, u8 type, struct net *net)\n{\n\tstruct xfrm_policy *pol, *ret = NULL;\n\tstruct hlist_head *chain;\n\tu32 priority = ~0U;\n\n\tspin_lock_bh(&net->xfrm.xfrm_policy_lock);\n\tchain = policy_hash_direct(net, &sel->daddr, &sel->saddr, sel->family, dir);\n\thlist_for_each_entry(pol, chain, bydst) {\n\t\tif (xfrm_migrate_selector_match(sel, &pol->selector) &&\n\t\t    pol->type == type) {\n\t\t\tret = pol;\n\t\t\tpriority = ret->priority;\n\t\t\tbreak;\n\t\t}\n\t}\n\tchain = &net->xfrm.policy_inexact[dir];\n\thlist_for_each_entry(pol, chain, bydst_inexact_list) {\n\t\tif ((pol->priority >= priority) && ret)\n\t\t\tbreak;\n\n\t\tif (xfrm_migrate_selector_match(sel, &pol->selector) &&\n\t\t    pol->type == type) {\n\t\t\tret = pol;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\txfrm_pol_hold(ret);\n\n\tspin_unlock_bh(&net->xfrm.xfrm_policy_lock);\n\n\treturn ret;\n}\n\nstatic int migrate_tmpl_match(const struct xfrm_migrate *m, const struct xfrm_tmpl *t)\n{\n\tint match = 0;\n\n\tif (t->mode == m->mode && t->id.proto == m->proto &&\n\t    (m->reqid == 0 || t->reqid == m->reqid)) {\n\t\tswitch (t->mode) {\n\t\tcase XFRM_MODE_TUNNEL:\n\t\tcase XFRM_MODE_BEET:\n\t\t\tif (xfrm_addr_equal(&t->id.daddr, &m->old_daddr,\n\t\t\t\t\t    m->old_family) &&\n\t\t\t    xfrm_addr_equal(&t->saddr, &m->old_saddr,\n\t\t\t\t\t    m->old_family)) {\n\t\t\t\tmatch = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase XFRM_MODE_TRANSPORT:\n\t\t\t/* in case of transport mode, template does not store\n\t\t\t   any IP addresses, hence we just compare mode and\n\t\t\t   protocol */\n\t\t\tmatch = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn match;\n}\n\n/* update endpoint address(es) of template(s) */\nstatic int xfrm_policy_migrate(struct xfrm_policy *pol,\n\t\t\t       struct xfrm_migrate *m, int num_migrate)\n{\n\tstruct xfrm_migrate *mp;\n\tint i, j, n = 0;\n\n\twrite_lock_bh(&pol->lock);\n\tif (unlikely(pol->walk.dead)) {\n\t\t/* target policy has been deleted */\n\t\twrite_unlock_bh(&pol->lock);\n\t\treturn -ENOENT;\n\t}\n\n\tfor (i = 0; i < pol->xfrm_nr; i++) {\n\t\tfor (j = 0, mp = m; j < num_migrate; j++, mp++) {\n\t\t\tif (!migrate_tmpl_match(mp, &pol->xfrm_vec[i]))\n\t\t\t\tcontinue;\n\t\t\tn++;\n\t\t\tif (pol->xfrm_vec[i].mode != XFRM_MODE_TUNNEL &&\n\t\t\t    pol->xfrm_vec[i].mode != XFRM_MODE_BEET)\n\t\t\t\tcontinue;\n\t\t\t/* update endpoints */\n\t\t\tmemcpy(&pol->xfrm_vec[i].id.daddr, &mp->new_daddr,\n\t\t\t       sizeof(pol->xfrm_vec[i].id.daddr));\n\t\t\tmemcpy(&pol->xfrm_vec[i].saddr, &mp->new_saddr,\n\t\t\t       sizeof(pol->xfrm_vec[i].saddr));\n\t\t\tpol->xfrm_vec[i].encap_family = mp->new_family;\n\t\t\t/* flush bundles */\n\t\t\tatomic_inc(&pol->genid);\n\t\t}\n\t}\n\n\twrite_unlock_bh(&pol->lock);\n\n\tif (!n)\n\t\treturn -ENODATA;\n\n\treturn 0;\n}\n\nstatic int xfrm_migrate_check(const struct xfrm_migrate *m, int num_migrate)\n{\n\tint i, j;\n\n\tif (num_migrate < 1 || num_migrate > XFRM_MAX_DEPTH)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_migrate; i++) {\n\t\tif (xfrm_addr_any(&m[i].new_daddr, m[i].new_family) ||\n\t\t    xfrm_addr_any(&m[i].new_saddr, m[i].new_family))\n\t\t\treturn -EINVAL;\n\n\t\t/* check if there is any duplicated entry */\n\t\tfor (j = i + 1; j < num_migrate; j++) {\n\t\t\tif (!memcmp(&m[i].old_daddr, &m[j].old_daddr,\n\t\t\t\t    sizeof(m[i].old_daddr)) &&\n\t\t\t    !memcmp(&m[i].old_saddr, &m[j].old_saddr,\n\t\t\t\t    sizeof(m[i].old_saddr)) &&\n\t\t\t    m[i].proto == m[j].proto &&\n\t\t\t    m[i].mode == m[j].mode &&\n\t\t\t    m[i].reqid == m[j].reqid &&\n\t\t\t    m[i].old_family == m[j].old_family)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t struct xfrm_migrate *m, int num_migrate,\n\t\t struct xfrm_kmaddress *k, struct net *net,\n\t\t struct xfrm_encap_tmpl *encap)\n{\n\tint i, err, nx_cur = 0, nx_new = 0;\n\tstruct xfrm_policy *pol = NULL;\n\tstruct xfrm_state *x, *xc;\n\tstruct xfrm_state *x_cur[XFRM_MAX_DEPTH];\n\tstruct xfrm_state *x_new[XFRM_MAX_DEPTH];\n\tstruct xfrm_migrate *mp;\n\n\t/* Stage 0 - sanity checks */\n\tif ((err = xfrm_migrate_check(m, num_migrate)) < 0)\n\t\tgoto out;\n\n\tif (dir >= XFRM_POLICY_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Stage 1 - find policy */\n\tif ((pol = xfrm_migrate_policy_find(sel, dir, type, net)) == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* Stage 2 - find and update state(s) */\n\tfor (i = 0, mp = m; i < num_migrate; i++, mp++) {\n\t\tif ((x = xfrm_migrate_state_find(mp, net))) {\n\t\t\tx_cur[nx_cur] = x;\n\t\t\tnx_cur++;\n\t\t\txc = xfrm_state_migrate(x, mp, encap);\n\t\t\tif (xc) {\n\t\t\t\tx_new[nx_new] = xc;\n\t\t\t\tnx_new++;\n\t\t\t} else {\n\t\t\t\terr = -ENODATA;\n\t\t\t\tgoto restore_state;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Stage 3 - update policy */\n\tif ((err = xfrm_policy_migrate(pol, m, num_migrate)) < 0)\n\t\tgoto restore_state;\n\n\t/* Stage 4 - delete old state(s) */\n\tif (nx_cur) {\n\t\txfrm_states_put(x_cur, nx_cur);\n\t\txfrm_states_delete(x_cur, nx_cur);\n\t}\n\n\t/* Stage 5 - announce */\n\tkm_migrate(sel, dir, type, m, num_migrate, k, encap);\n\n\txfrm_pol_put(pol);\n\n\treturn 0;\nout:\n\treturn err;\n\nrestore_state:\n\tif (pol)\n\t\txfrm_pol_put(pol);\n\tif (nx_cur)\n\t\txfrm_states_put(x_cur, nx_cur);\n\tif (nx_new)\n\t\txfrm_states_delete(x_new, nx_new);\n\n\treturn err;\n}\nEXPORT_SYMBOL(xfrm_migrate);\n#endif\n"}, "1": {"id": 1, "path": "/src/include/linux/err.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_ERR_H\n#define _LINUX_ERR_H\n\n#include <linux/compiler.h>\n#include <linux/types.h>\n\n#include <asm/errno.h>\n\n/*\n * Kernel pointers have redundant information, so we can use a\n * scheme where we can return either an error code or a normal\n * pointer with the same return value.\n *\n * This should be a per-architecture thing, to allow different\n * error and pointer decisions.\n */\n#define MAX_ERRNO\t4095\n\n#ifndef __ASSEMBLY__\n\n#define IS_ERR_VALUE(x) unlikely((unsigned long)(void *)(x) >= (unsigned long)-MAX_ERRNO)\n\nstatic inline void * __must_check ERR_PTR(long error)\n{\n\treturn (void *) error;\n}\n\nstatic inline long __must_check PTR_ERR(__force const void *ptr)\n{\n\treturn (long) ptr;\n}\n\nstatic inline bool __must_check IS_ERR(__force const void *ptr)\n{\n\treturn IS_ERR_VALUE((unsigned long)ptr);\n}\n\nstatic inline bool __must_check IS_ERR_OR_NULL(__force const void *ptr)\n{\n\treturn unlikely(!ptr) || IS_ERR_VALUE((unsigned long)ptr);\n}\n\n/**\n * ERR_CAST - Explicitly cast an error-valued pointer to another pointer type\n * @ptr: The pointer to cast.\n *\n * Explicitly cast an error-valued pointer to another pointer type in such a\n * way as to make it clear that's what's going on.\n */\nstatic inline void * __must_check ERR_CAST(__force const void *ptr)\n{\n\t/* cast away the const */\n\treturn (void *) ptr;\n}\n\nstatic inline int __must_check PTR_ERR_OR_ZERO(__force const void *ptr)\n{\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\telse\n\t\treturn 0;\n}\n\n#endif\n\n#endif /* _LINUX_ERR_H */\n"}, "2": {"id": 2, "path": "/src/include/linux/compiler.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_H\n#define __LINUX_COMPILER_H\n\n#include <linux/compiler_types.h>\n\n#ifndef __ASSEMBLY__\n\n#ifdef __KERNEL__\n\n/*\n * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code\n * to disable branch tracing on a per file basis.\n */\n#if defined(CONFIG_TRACE_BRANCH_PROFILING) \\\n    && !defined(DISABLE_BRANCH_PROFILING) && !defined(__CHECKER__)\nvoid ftrace_likely_update(struct ftrace_likely_data *f, int val,\n\t\t\t  int expect, int is_constant);\n\n#define likely_notrace(x)\t__builtin_expect(!!(x), 1)\n#define unlikely_notrace(x)\t__builtin_expect(!!(x), 0)\n\n#define __branch_check__(x, expect, is_constant) ({\t\t\t\\\n\t\t\tlong ______r;\t\t\t\t\t\\\n\t\t\tstatic struct ftrace_likely_data\t\t\\\n\t\t\t\t__aligned(4)\t\t\t\t\\\n\t\t\t\t__section(\"_ftrace_annotated_branch\")\t\\\n\t\t\t\t______f = {\t\t\t\t\\\n\t\t\t\t.data.func = __func__,\t\t\t\\\n\t\t\t\t.data.file = __FILE__,\t\t\t\\\n\t\t\t\t.data.line = __LINE__,\t\t\t\\\n\t\t\t};\t\t\t\t\t\t\\\n\t\t\t______r = __builtin_expect(!!(x), expect);\t\\\n\t\t\tftrace_likely_update(&______f, ______r,\t\t\\\n\t\t\t\t\t     expect, is_constant);\t\\\n\t\t\t______r;\t\t\t\t\t\\\n\t\t})\n\n/*\n * Using __builtin_constant_p(x) to ignore cases where the return\n * value is always the same.  This idea is taken from a similar patch\n * written by Daniel Walker.\n */\n# ifndef likely\n#  define likely(x)\t(__branch_check__(x, 1, __builtin_constant_p(x)))\n# endif\n# ifndef unlikely\n#  define unlikely(x)\t(__branch_check__(x, 0, __builtin_constant_p(x)))\n# endif\n\n#ifdef CONFIG_PROFILE_ALL_BRANCHES\n/*\n * \"Define 'is'\", Bill Clinton\n * \"Define 'if'\", Steven Rostedt\n */\n#define if(cond, ...) if ( __trace_if_var( !!(cond , ## __VA_ARGS__) ) )\n\n#define __trace_if_var(cond) (__builtin_constant_p(cond) ? (cond) : __trace_if_value(cond))\n\n#define __trace_if_value(cond) ({\t\t\t\\\n\tstatic struct ftrace_branch_data\t\t\\\n\t\t__aligned(4)\t\t\t\t\\\n\t\t__section(\"_ftrace_branch\")\t\t\\\n\t\t__if_trace = {\t\t\t\t\\\n\t\t\t.func = __func__,\t\t\\\n\t\t\t.file = __FILE__,\t\t\\\n\t\t\t.line = __LINE__,\t\t\\\n\t\t};\t\t\t\t\t\\\n\t(cond) ?\t\t\t\t\t\\\n\t\t(__if_trace.miss_hit[1]++,1) :\t\t\\\n\t\t(__if_trace.miss_hit[0]++,0);\t\t\\\n})\n\n#endif /* CONFIG_PROFILE_ALL_BRANCHES */\n\n#else\n# define likely(x)\t__builtin_expect(!!(x), 1)\n# define unlikely(x)\t__builtin_expect(!!(x), 0)\n# define likely_notrace(x)\tlikely(x)\n# define unlikely_notrace(x)\tunlikely(x)\n#endif\n\n/* Optimization barrier */\n#ifndef barrier\n/* The \"volatile\" is due to gcc bugs */\n# define barrier() __asm__ __volatile__(\"\": : :\"memory\")\n#endif\n\n#ifndef barrier_data\n/*\n * This version is i.e. to prevent dead stores elimination on @ptr\n * where gcc and llvm may behave differently when otherwise using\n * normal barrier(): while gcc behavior gets along with a normal\n * barrier(), llvm needs an explicit input variable to be assumed\n * clobbered. The issue is as follows: while the inline asm might\n * access any memory it wants, the compiler could have fit all of\n * @ptr into memory registers instead, and since @ptr never escaped\n * from that, it proved that the inline asm wasn't touching any of\n * it. This version works well with both compilers, i.e. we're telling\n * the compiler that the inline asm absolutely may see the contents\n * of @ptr. See also: https://llvm.org/bugs/show_bug.cgi?id=15495\n */\n# define barrier_data(ptr) __asm__ __volatile__(\"\": :\"r\"(ptr) :\"memory\")\n#endif\n\n/* workaround for GCC PR82365 if needed */\n#ifndef barrier_before_unreachable\n# define barrier_before_unreachable() do { } while (0)\n#endif\n\n/* Unreachable code */\n#ifdef CONFIG_STACK_VALIDATION\n/*\n * These macros help objtool understand GCC code flow for unreachable code.\n * The __COUNTER__ based labels are a hack to make each instance of the macros\n * unique, to convince GCC not to merge duplicate inline asm statements.\n */\n#define annotate_reachable() ({\t\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.reachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define annotate_unreachable() ({\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.unreachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define ASM_UNREACHABLE\t\t\t\t\t\t\t\\\n\t\"999:\\n\\t\"\t\t\t\t\t\t\t\\\n\t\".pushsection .discard.unreachable\\n\\t\"\t\t\t\t\\\n\t\".long 999b - .\\n\\t\"\t\t\t\t\t\t\\\n\t\".popsection\\n\\t\"\n\n/* Annotate a C jump table to allow objtool to follow the code flow */\n#define __annotate_jump_table __section(\".rodata..c_jump_table\")\n\n#else\n#define annotate_reachable()\n#define annotate_unreachable()\n#define __annotate_jump_table\n#endif\n\n#ifndef ASM_UNREACHABLE\n# define ASM_UNREACHABLE\n#endif\n#ifndef unreachable\n# define unreachable() do {\t\t\\\n\tannotate_unreachable();\t\t\\\n\t__builtin_unreachable();\t\\\n} while (0)\n#endif\n\n/*\n * KENTRY - kernel entry point\n * This can be used to annotate symbols (functions or data) that are used\n * without their linker symbol being referenced explicitly. For example,\n * interrupt vector handlers, or functions in the kernel image that are found\n * programatically.\n *\n * Not required for symbols exported with EXPORT_SYMBOL, or initcalls. Those\n * are handled in their own way (with KEEP() in linker scripts).\n *\n * KENTRY can be avoided if the symbols in question are marked as KEEP() in the\n * linker script. For example an architecture could KEEP() its entire\n * boot/exception vector code rather than annotate each function and data.\n */\n#ifndef KENTRY\n# define KENTRY(sym)\t\t\t\t\t\t\\\n\textern typeof(sym) sym;\t\t\t\t\t\\\n\tstatic const unsigned long __kentry_##sym\t\t\\\n\t__used\t\t\t\t\t\t\t\\\n\t__attribute__((__section__(\"___kentry+\" #sym)))\t\t\\\n\t= (unsigned long)&sym;\n#endif\n\n#ifndef RELOC_HIDE\n# define RELOC_HIDE(ptr, off)\t\t\t\t\t\\\n  ({ unsigned long __ptr;\t\t\t\t\t\\\n     __ptr = (unsigned long) (ptr);\t\t\t\t\\\n    (typeof(ptr)) (__ptr + (off)); })\n#endif\n\n#ifndef OPTIMIZER_HIDE_VAR\n/* Make the optimizer believe the variable can be manipulated arbitrarily. */\n#define OPTIMIZER_HIDE_VAR(var)\t\t\t\t\t\t\\\n\t__asm__ (\"\" : \"=r\" (var) : \"0\" (var))\n#endif\n\n/* Not-quite-unique ID. */\n#ifndef __UNIQUE_ID\n# define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)\n#endif\n\n/**\n * data_race - mark an expression as containing intentional data races\n *\n * This data_race() macro is useful for situations in which data races\n * should be forgiven.  One example is diagnostic code that accesses\n * shared variables but is not a part of the core synchronization design.\n *\n * This macro *does not* affect normal code generation, but is a hint\n * to tooling that data races here are to be ignored.\n */\n#define data_race(expr)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__unqual_scalar_typeof(({ expr; })) __v = ({\t\t\t\\\n\t\t__kcsan_disable_current();\t\t\t\t\\\n\t\texpr;\t\t\t\t\t\t\t\\\n\t});\t\t\t\t\t\t\t\t\\\n\t__kcsan_enable_current();\t\t\t\t\t\\\n\t__v;\t\t\t\t\t\t\t\t\\\n})\n\n#endif /* __KERNEL__ */\n\n/*\n * Force the compiler to emit 'sym' as a symbol, so that we can reference\n * it from inline assembler. Necessary in case 'sym' could be inlined\n * otherwise, or eliminated entirely due to lack of references that are\n * visible to the compiler.\n */\n#define __ADDRESSABLE(sym) \\\n\tstatic void * __section(\".discard.addressable\") __used \\\n\t\t__UNIQUE_ID(__PASTE(__addressable_,sym)) = (void *)&sym;\n\n/**\n * offset_to_ptr - convert a relative memory offset to an absolute pointer\n * @off:\tthe address of the 32-bit offset value\n */\nstatic inline void *offset_to_ptr(const int *off)\n{\n\treturn (void *)((unsigned long)off + *off);\n}\n\n#endif /* __ASSEMBLY__ */\n\n/* &a[0] degrades to a pointer: a different type from an array */\n#define __must_be_array(a)\tBUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))\n\n/*\n * This is needed in functions which generate the stack canary, see\n * arch/x86/kernel/smpboot.c::start_secondary() for an example.\n */\n#define prevent_tail_call_optimization()\tmb()\n\n#include <asm/rwonce.h>\n\n#endif /* __LINUX_COMPILER_H */\n"}}, "reports": [{"events": [{"location": {"col": 26, "file": 0, "line": 3198}, "message": "Calling 'xfrm_lookup'"}, {"location": {"col": 9, "file": 0, "line": 3187}, "message": "Calling 'xfrm_lookup_with_ifid'"}, {"location": {"col": 6, "file": 0, "line": 3048}, "message": "'sk' is non-null"}, {"location": {"col": 6, "file": 0, "line": 3048}, "message": "Left side of '&&' is true"}, {"location": {"col": 12, "file": 0, "line": 3048}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 0, "line": 3048}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 3054}, "message": "'err' is >= 0"}, {"location": {"col": 3, "file": 0, "line": 3054}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 3057}, "message": "'num_pols' is 1"}, {"location": {"col": 3, "file": 0, "line": 3057}, "message": "Taking true branch"}, {"location": {"col": 8, "file": 0, "line": 3058}, "message": "Assuming 'num_xfrms' is > 0"}, {"location": {"col": 4, "file": 0, "line": 3058}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 3063}, "message": "Calling 'xfrm_resolve_and_create_bundle'"}, {"location": {"col": 8, "file": 0, "line": 2729}, "message": "Calling 'xfrm_tmpl_resolve'"}, {"location": {"col": 29, "file": 0, "line": 2427}, "message": "'npols' is <= 1"}, {"location": {"col": 28, "file": 0, "line": 2427}, "message": "'?' condition is false"}, {"location": {"col": 2, "file": 0, "line": 2433}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 7, "file": 0, "line": 2434}, "message": "Assuming the condition is false"}, {"location": {"col": 3, "file": 0, "line": 2434}, "message": "Taking false branch"}, {"location": {"col": 9, "file": 0, "line": 2439}, "message": "Calling 'xfrm_tmpl_resolve_one'"}, {"location": {"col": 22, "file": 0, "line": 2374}, "message": "'i' is < field 'xfrm_nr'"}, {"location": {"col": 2, "file": 0, "line": 2374}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 7, "file": 0, "line": 2380}, "message": "Assuming field 'mode' is equal to XFRM_MODE_TUNNEL"}, {"location": {"col": 38, "file": 0, "line": 2380}, "message": "Left side of '||' is true"}, {"location": {"col": 8, "file": 0, "line": 2384}, "message": "Assuming the condition is true"}, {"location": {"col": 4, "file": 0, "line": 2384}, "message": "Taking true branch"}, {"location": {"col": 9, "file": 0, "line": 2388}, "message": "Assuming 'error' is not equal to 0"}, {"location": {"col": 5, "file": 0, "line": 2388}, "message": "Taking true branch"}, {"location": {"col": 6, "file": 0, "line": 2389}, "message": "Control jumps to line 2417"}, {"location": {"col": 2, "file": 0, "line": 2417}, "message": "Loop condition is false. Execution continues on line 2419"}, {"location": {"col": 2, "file": 0, "line": 2419}, "message": "Returning without writing to '*xfrm'"}, {"location": {"col": 9, "file": 0, "line": 2439}, "message": "Returning from 'xfrm_tmpl_resolve_one'"}, {"location": {"col": 7, "file": 0, "line": 2440}, "message": "Assuming 'ret' is >= 0"}, {"location": {"col": 3, "file": 0, "line": 2440}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 2433}, "message": "Loop condition is false. Execution continues on line 2448"}, {"location": {"col": 6, "file": 0, "line": 2448}, "message": "'npols' is <= 1"}, {"location": {"col": 2, "file": 0, "line": 2448}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 2451}, "message": "Returning without writing to '*xfrm'"}, {"location": {"col": 8, "file": 0, "line": 2729}, "message": "Returning from 'xfrm_tmpl_resolve'"}, {"location": {"col": 6, "file": 0, "line": 2730}, "message": "'err' is > 0"}, {"location": {"col": 2, "file": 0, "line": 2730}, "message": "Taking false branch"}, {"location": {"col": 8, "file": 0, "line": 2739}, "message": "Calling 'xfrm_bundle_create'"}, {"location": {"col": 2, "file": 0, "line": 2549}, "message": "'i' initialized to 0"}, {"location": {"col": 9, "file": 0, "line": 2564}, "message": "'i' is < 'nx'"}, {"location": {"col": 2, "file": 0, "line": 2564}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 7, "file": 0, "line": 2569}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 1, "line": 36}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 1, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 1, "line": 36}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 7, "file": 0, "line": 2569}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 3, "file": 0, "line": 2569}, "message": "Taking false branch"}, {"location": {"col": 8, "file": 0, "line": 2575}, "message": "'xdst_prev' is null"}, {"location": {"col": 3, "file": 0, "line": 2575}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 2583}, "message": "Dereference of undefined pointer value"}, {"location": {"col": 7, "file": 0, "line": 2583}, "message": "Dereference of undefined pointer value"}], "macros": [], "notes": [], "path": "/src/net/xfrm/xfrm_policy.c", "reportHash": "e599b48e0988c62842bbe3fae586146f", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 0, "line": 3198}, "message": "Calling 'xfrm_lookup'"}, {"location": {"col": 9, "file": 0, "line": 3187}, "message": "Calling 'xfrm_lookup_with_ifid'"}, {"location": {"col": 6, "file": 0, "line": 3048}, "message": "'sk' is non-null"}, {"location": {"col": 6, "file": 0, "line": 3048}, "message": "Left side of '&&' is true"}, {"location": {"col": 12, "file": 0, "line": 3048}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 0, "line": 3048}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 3054}, "message": "'err' is >= 0"}, {"location": {"col": 3, "file": 0, "line": 3054}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 3057}, "message": "'num_pols' is 1"}, {"location": {"col": 3, "file": 0, "line": 3057}, "message": "Taking true branch"}, {"location": {"col": 8, "file": 0, "line": 3058}, "message": "Assuming 'num_xfrms' is > 0"}, {"location": {"col": 4, "file": 0, "line": 3058}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 3063}, "message": "Calling 'xfrm_resolve_and_create_bundle'"}, {"location": {"col": 8, "file": 0, "line": 2729}, "message": "Calling 'xfrm_tmpl_resolve'"}, {"location": {"col": 29, "file": 0, "line": 2427}, "message": "'npols' is <= 1"}, {"location": {"col": 28, "file": 0, "line": 2427}, "message": "'?' condition is false"}, {"location": {"col": 2, "file": 0, "line": 2433}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 7, "file": 0, "line": 2434}, "message": "Assuming the condition is false"}, {"location": {"col": 3, "file": 0, "line": 2434}, "message": "Taking false branch"}, {"location": {"col": 9, "file": 0, "line": 2439}, "message": "Calling 'xfrm_tmpl_resolve_one'"}, {"location": {"col": 22, "file": 0, "line": 2374}, "message": "'i' is < field 'xfrm_nr'"}, {"location": {"col": 2, "file": 0, "line": 2374}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 7, "file": 0, "line": 2380}, "message": "Assuming field 'mode' is not equal to XFRM_MODE_TUNNEL"}, {"location": {"col": 7, "file": 0, "line": 2380}, "message": "Left side of '||' is false"}, {"location": {"col": 7, "file": 0, "line": 2381}, "message": "Assuming field 'mode' is not equal to XFRM_MODE_BEET"}, {"location": {"col": 3, "file": 0, "line": 2380}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 2397}, "message": "Assuming 'x' is null"}, {"location": {"col": 9, "file": 0, "line": 2397}, "message": "Left side of '&&' is false"}, {"location": {"col": 7, "file": 0, "line": 2403}, "message": "'x' is null"}, {"location": {"col": 3, "file": 0, "line": 2403}, "message": "Taking false branch"}, {"location": {"col": 14, "file": 0, "line": 2407}, "message": "Assuming the condition is false"}, {"location": {"col": 10, "file": 0, "line": 2407}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 2411}, "message": "Assuming field 'optional' is 0"}, {"location": {"col": 3, "file": 0, "line": 2411}, "message": "Taking true branch"}, {"location": {"col": 4, "file": 0, "line": 2412}, "message": "Control jumps to line 2417"}, {"location": {"col": 2, "file": 0, "line": 2417}, "message": "Loop condition is false. Execution continues on line 2419"}, {"location": {"col": 2, "file": 0, "line": 2419}, "message": "Returning without writing to '*xfrm'"}, {"location": {"col": 9, "file": 0, "line": 2439}, "message": "Returning from 'xfrm_tmpl_resolve_one'"}, {"location": {"col": 7, "file": 0, "line": 2440}, "message": "Assuming 'ret' is >= 0"}, {"location": {"col": 3, "file": 0, "line": 2440}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 2433}, "message": "Loop condition is false. Execution continues on line 2448"}, {"location": {"col": 6, "file": 0, "line": 2448}, "message": "'npols' is <= 1"}, {"location": {"col": 2, "file": 0, "line": 2448}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 2451}, "message": "Returning without writing to '*xfrm'"}, {"location": {"col": 8, "file": 0, "line": 2729}, "message": "Returning from 'xfrm_tmpl_resolve'"}, {"location": {"col": 6, "file": 0, "line": 2730}, "message": "Assuming 'err' is > 0"}, {"location": {"col": 2, "file": 0, "line": 2730}, "message": "Taking false branch"}, {"location": {"col": 8, "file": 0, "line": 2739}, "message": "Calling 'xfrm_bundle_create'"}, {"location": {"col": 2, "file": 0, "line": 2549}, "message": "'i' initialized to 0"}, {"location": {"col": 9, "file": 0, "line": 2564}, "message": "'i' is < 'nx'"}, {"location": {"col": 2, "file": 0, "line": 2564}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 7, "file": 0, "line": 2569}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 2, "file": 1, "line": 36}, "message": "Returning the value 1, which participates in a condition later"}, {"location": {"col": 7, "file": 0, "line": 2569}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 3, "file": 0, "line": 2569}, "message": "Taking true branch"}, {"location": {"col": 4, "file": 0, "line": 2571}, "message": "Control jumps to line 2662"}, {"location": {"col": 9, "file": 0, "line": 2662}, "message": "'i' is < 'nx'"}, {"location": {"col": 2, "file": 0, "line": 2662}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 3, "file": 0, "line": 2663}, "message": "1st function call argument is an uninitialized value"}, {"location": {"col": 3, "file": 0, "line": 2663}, "message": "1st function call argument is an uninitialized value"}], "macros": [], "notes": [], "path": "/src/net/xfrm/xfrm_policy.c", "reportHash": "36386bc909793b6594633cb74d8d56aa", "checkerName": "clang-analyzer-core.CallAndMessage", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 4, "file": 0, "line": 3429}, "message": "Value stored to 'exthdr' is never read"}, {"location": {"col": 4, "file": 0, "line": 3429}, "message": "Value stored to 'exthdr' is never read"}], "macros": [], "notes": [], "path": "/src/net/xfrm/xfrm_policy.c", "reportHash": "86755220473ea131ad4927ddf658e8d6", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
