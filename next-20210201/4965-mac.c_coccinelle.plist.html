<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/net/wireless/intel/iwlegacy/4965-mac.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/******************************************************************************\n *\n * Copyright(c) 2003 - 2011 Intel Corporation. All rights reserved.\n *\n * Portions of this file are derived from the ipw3945 project, as well\n * as portions of the ieee80211 subsystem header files.\n *\n * Contact Information:\n *  Intel Linux Wireless <ilw@linux.intel.com>\n * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497\n *\n *****************************************************************************/\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/firmware.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n#include <linux/units.h>\n\n#include <net/mac80211.h>\n\n#include <asm/div64.h>\n\n#define DRV_NAME        \"iwl4965\"\n\n#include \"common.h\"\n#include \"4965.h\"\n\n/******************************************************************************\n *\n * module boiler plate\n *\n ******************************************************************************/\n\n/*\n * module name, copyright, version, etc.\n */\n#define DRV_DESCRIPTION\t\"Intel(R) Wireless WiFi 4965 driver for Linux\"\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n#define VD \"d\"\n#else\n#define VD\n#endif\n\n#define DRV_VERSION     IWLWIFI_VERSION VD\n\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_VERSION(DRV_VERSION);\nMODULE_AUTHOR(DRV_COPYRIGHT \" \" DRV_AUTHOR);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"iwl4965\");\n\nvoid\nil4965_check_abort_status(struct il_priv *il, u8 frame_count, u32 status)\n{\n\tif (frame_count == 1 && status == TX_STATUS_FAIL_RFKILL_FLUSH) {\n\t\tIL_ERR(\"Tx flush command to flush out all frames\\n\");\n\t\tif (!test_bit(S_EXIT_PENDING, &il->status))\n\t\t\tqueue_work(il->workqueue, &il->tx_flush);\n\t}\n}\n\n/*\n * EEPROM\n */\nstruct il_mod_params il4965_mod_params = {\n\t.restart_fw = 1,\n\t/* the rest are 0 by default */\n};\n\nvoid\nil4965_rx_queue_reset(struct il_priv *il, struct il_rx_queue *rxq)\n{\n\tunsigned long flags;\n\tint i;\n\tspin_lock_irqsave(&rxq->lock, flags);\n\tINIT_LIST_HEAD(&rxq->rx_free);\n\tINIT_LIST_HEAD(&rxq->rx_used);\n\t/* Fill the rx_used queue with _all_ of the Rx buffers */\n\tfor (i = 0; i < RX_FREE_BUFFERS + RX_QUEUE_SIZE; i++) {\n\t\t/* In the reset function, these buffers may have been allocated\n\t\t * to an SKB, so we need to unmap and free potential storage */\n\t\tif (rxq->pool[i].page != NULL) {\n\t\t\tpci_unmap_page(il->pci_dev, rxq->pool[i].page_dma,\n\t\t\t\t       PAGE_SIZE << il->hw_params.rx_page_order,\n\t\t\t\t       PCI_DMA_FROMDEVICE);\n\t\t\t__il_free_pages(il, rxq->pool[i].page);\n\t\t\trxq->pool[i].page = NULL;\n\t\t}\n\t\tlist_add_tail(&rxq->pool[i].list, &rxq->rx_used);\n\t}\n\n\tfor (i = 0; i < RX_QUEUE_SIZE; i++)\n\t\trxq->queue[i] = NULL;\n\n\t/* Set us so that we have processed and used all buffers, but have\n\t * not restocked the Rx queue with fresh buffers */\n\trxq->read = rxq->write = 0;\n\trxq->write_actual = 0;\n\trxq->free_count = 0;\n\tspin_unlock_irqrestore(&rxq->lock, flags);\n}\n\nint\nil4965_rx_init(struct il_priv *il, struct il_rx_queue *rxq)\n{\n\tu32 rb_size;\n\tconst u32 rfdnlog = RX_QUEUE_SIZE_LOG;\t/* 256 RBDs */\n\tu32 rb_timeout = 0;\n\n\tif (il->cfg->mod_params->amsdu_size_8K)\n\t\trb_size = FH49_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_8K;\n\telse\n\t\trb_size = FH49_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_4K;\n\n\t/* Stop Rx DMA */\n\til_wr(il, FH49_MEM_RCSR_CHNL0_CONFIG_REG, 0);\n\n\t/* Reset driver's Rx queue write idx */\n\til_wr(il, FH49_RSCSR_CHNL0_RBDCB_WPTR_REG, 0);\n\n\t/* Tell device where to find RBD circular buffer in DRAM */\n\til_wr(il, FH49_RSCSR_CHNL0_RBDCB_BASE_REG, (u32) (rxq->bd_dma >> 8));\n\n\t/* Tell device where in DRAM to update its Rx status */\n\til_wr(il, FH49_RSCSR_CHNL0_STTS_WPTR_REG, rxq->rb_stts_dma >> 4);\n\n\t/* Enable Rx DMA\n\t * Direct rx interrupts to hosts\n\t * Rx buffer size 4 or 8k\n\t * RB timeout 0x10\n\t * 256 RBDs\n\t */\n\til_wr(il, FH49_MEM_RCSR_CHNL0_CONFIG_REG,\n\t      FH49_RCSR_RX_CONFIG_CHNL_EN_ENABLE_VAL |\n\t      FH49_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_INT_HOST_VAL |\n\t      FH49_RCSR_CHNL0_RX_CONFIG_SINGLE_FRAME_MSK |\n\t      rb_size |\n\t      (rb_timeout << FH49_RCSR_RX_CONFIG_REG_IRQ_RBTH_POS) |\n\t      (rfdnlog << FH49_RCSR_RX_CONFIG_RBDCB_SIZE_POS));\n\n\t/* Set interrupt coalescing timer to default (2048 usecs) */\n\til_write8(il, CSR_INT_COALESCING, IL_HOST_INT_TIMEOUT_DEF);\n\n\treturn 0;\n}\n\nstatic void\nil4965_set_pwr_vmain(struct il_priv *il)\n{\n/*\n * (for documentation purposes)\n * to set power to V_AUX, do:\n\n\t\tif (pci_pme_capable(il->pci_dev, PCI_D3cold))\n\t\t\til_set_bits_mask_prph(il, APMG_PS_CTRL_REG,\n\t\t\t\t\t       APMG_PS_CTRL_VAL_PWR_SRC_VAUX,\n\t\t\t\t\t       ~APMG_PS_CTRL_MSK_PWR_SRC);\n */\n\n\til_set_bits_mask_prph(il, APMG_PS_CTRL_REG,\n\t\t\t      APMG_PS_CTRL_VAL_PWR_SRC_VMAIN,\n\t\t\t      ~APMG_PS_CTRL_MSK_PWR_SRC);\n}\n\nint\nil4965_hw_nic_init(struct il_priv *il)\n{\n\tunsigned long flags;\n\tstruct il_rx_queue *rxq = &il->rxq;\n\tint ret;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\til_apm_init(il);\n\t/* Set interrupt coalescing calibration timer to default (512 usecs) */\n\til_write8(il, CSR_INT_COALESCING, IL_HOST_INT_CALIB_TIMEOUT_DEF);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\til4965_set_pwr_vmain(il);\n\til4965_nic_config(il);\n\n\t/* Allocate the RX queue, or reset if it is already allocated */\n\tif (!rxq->bd) {\n\t\tret = il_rx_queue_alloc(il);\n\t\tif (ret) {\n\t\t\tIL_ERR(\"Unable to initialize Rx queue\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else\n\t\til4965_rx_queue_reset(il, rxq);\n\n\til4965_rx_replenish(il);\n\n\til4965_rx_init(il, rxq);\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\trxq->need_update = 1;\n\til_rx_queue_update_write_ptr(il, rxq);\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\t/* Allocate or reset and init all Tx and Command queues */\n\tif (!il->txq) {\n\t\tret = il4965_txq_ctx_alloc(il);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\til4965_txq_ctx_reset(il);\n\n\tset_bit(S_INIT, &il->status);\n\n\treturn 0;\n}\n\n/*\n * il4965_dma_addr2rbd_ptr - convert a DMA address to a uCode read buffer ptr\n */\nstatic inline __le32\nil4965_dma_addr2rbd_ptr(struct il_priv *il, dma_addr_t dma_addr)\n{\n\treturn cpu_to_le32((u32) (dma_addr >> 8));\n}\n\n/*\n * il4965_rx_queue_restock - refill RX queue from pre-allocated pool\n *\n * If there are slots in the RX queue that need to be restocked,\n * and we have free pre-allocated buffers, fill the ranks as much\n * as we can, pulling from rx_free.\n *\n * This moves the 'write' idx forward to catch up with 'processed', and\n * also updates the memory address in the firmware to reference the new\n * target buffer.\n */\nvoid\nil4965_rx_queue_restock(struct il_priv *il)\n{\n\tstruct il_rx_queue *rxq = &il->rxq;\n\tstruct list_head *element;\n\tstruct il_rx_buf *rxb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rxq->lock, flags);\n\twhile (il_rx_queue_space(rxq) > 0 && rxq->free_count) {\n\t\t/* The overwritten rxb must be a used one */\n\t\trxb = rxq->queue[rxq->write];\n\t\tBUG_ON(rxb && rxb->page);\n\n\t\t/* Get next free Rx buffer, remove from free list */\n\t\telement = rxq->rx_free.next;\n\t\trxb = list_entry(element, struct il_rx_buf, list);\n\t\tlist_del(element);\n\n\t\t/* Point to Rx buffer via next RBD in circular buffer */\n\t\trxq->bd[rxq->write] =\n\t\t    il4965_dma_addr2rbd_ptr(il, rxb->page_dma);\n\t\trxq->queue[rxq->write] = rxb;\n\t\trxq->write = (rxq->write + 1) & RX_QUEUE_MASK;\n\t\trxq->free_count--;\n\t}\n\tspin_unlock_irqrestore(&rxq->lock, flags);\n\t/* If the pre-allocated buffer pool is dropping low, schedule to\n\t * refill it */\n\tif (rxq->free_count <= RX_LOW_WATERMARK)\n\t\tqueue_work(il->workqueue, &il->rx_replenish);\n\n\t/* If we've added more space for the firmware to place data, tell it.\n\t * Increment device's write pointer in multiples of 8. */\n\tif (rxq->write_actual != (rxq->write & ~0x7)) {\n\t\tspin_lock_irqsave(&rxq->lock, flags);\n\t\trxq->need_update = 1;\n\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\t\til_rx_queue_update_write_ptr(il, rxq);\n\t}\n}\n\n/*\n * il4965_rx_replenish - Move all used packet from rx_used to rx_free\n *\n * When moving to rx_free an SKB is allocated for the slot.\n *\n * Also restock the Rx queue via il_rx_queue_restock.\n * This is called as a scheduled work item (except for during initialization)\n */\nstatic void\nil4965_rx_allocate(struct il_priv *il, gfp_t priority)\n{\n\tstruct il_rx_queue *rxq = &il->rxq;\n\tstruct list_head *element;\n\tstruct il_rx_buf *rxb;\n\tstruct page *page;\n\tdma_addr_t page_dma;\n\tunsigned long flags;\n\tgfp_t gfp_mask = priority;\n\n\twhile (1) {\n\t\tspin_lock_irqsave(&rxq->lock, flags);\n\t\tif (list_empty(&rxq->rx_used)) {\n\t\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\n\t\tif (rxq->free_count > RX_LOW_WATERMARK)\n\t\t\tgfp_mask |= __GFP_NOWARN;\n\n\t\tif (il->hw_params.rx_page_order > 0)\n\t\t\tgfp_mask |= __GFP_COMP;\n\n\t\t/* Alloc a new receive buffer */\n\t\tpage = alloc_pages(gfp_mask, il->hw_params.rx_page_order);\n\t\tif (!page) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tD_INFO(\"alloc_pages failed, \" \"order: %d\\n\",\n\t\t\t\t       il->hw_params.rx_page_order);\n\n\t\t\tif (rxq->free_count <= RX_LOW_WATERMARK &&\n\t\t\t    net_ratelimit())\n\t\t\t\tIL_ERR(\"Failed to alloc_pages with %s. \"\n\t\t\t\t       \"Only %u free buffers remaining.\\n\",\n\t\t\t\t       priority ==\n\t\t\t\t       GFP_ATOMIC ? \"GFP_ATOMIC\" : \"GFP_KERNEL\",\n\t\t\t\t       rxq->free_count);\n\t\t\t/* We don't reschedule replenish work here -- we will\n\t\t\t * call the restock method and if it still needs\n\t\t\t * more buffers it will schedule replenish */\n\t\t\treturn;\n\t\t}\n\n\t\t/* Get physical address of the RB */\n\t\tpage_dma =\n\t\t    pci_map_page(il->pci_dev, page, 0,\n\t\t\t\t PAGE_SIZE << il->hw_params.rx_page_order,\n\t\t\t\t PCI_DMA_FROMDEVICE);\n\t\tif (unlikely(pci_dma_mapping_error(il->pci_dev, page_dma))) {\n\t\t\t__free_pages(page, il->hw_params.rx_page_order);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock_irqsave(&rxq->lock, flags);\n\n\t\tif (list_empty(&rxq->rx_used)) {\n\t\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\t\t\tpci_unmap_page(il->pci_dev, page_dma,\n\t\t\t\t       PAGE_SIZE << il->hw_params.rx_page_order,\n\t\t\t\t       PCI_DMA_FROMDEVICE);\n\t\t\t__free_pages(page, il->hw_params.rx_page_order);\n\t\t\treturn;\n\t\t}\n\n\t\telement = rxq->rx_used.next;\n\t\trxb = list_entry(element, struct il_rx_buf, list);\n\t\tlist_del(element);\n\n\t\tBUG_ON(rxb->page);\n\n\t\trxb->page = page;\n\t\trxb->page_dma = page_dma;\n\t\tlist_add_tail(&rxb->list, &rxq->rx_free);\n\t\trxq->free_count++;\n\t\til->alloc_rxb_page++;\n\n\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\t}\n}\n\nvoid\nil4965_rx_replenish(struct il_priv *il)\n{\n\tunsigned long flags;\n\n\til4965_rx_allocate(il, GFP_KERNEL);\n\n\tspin_lock_irqsave(&il->lock, flags);\n\til4965_rx_queue_restock(il);\n\tspin_unlock_irqrestore(&il->lock, flags);\n}\n\nvoid\nil4965_rx_replenish_now(struct il_priv *il)\n{\n\til4965_rx_allocate(il, GFP_ATOMIC);\n\n\til4965_rx_queue_restock(il);\n}\n\n/* Assumes that the skb field of the buffers in 'pool' is kept accurate.\n * If an SKB has been detached, the POOL needs to have its SKB set to NULL\n * This free routine walks the list of POOL entries and if SKB is set to\n * non NULL it is unmapped and freed\n */\nvoid\nil4965_rx_queue_free(struct il_priv *il, struct il_rx_queue *rxq)\n{\n\tint i;\n\tfor (i = 0; i < RX_QUEUE_SIZE + RX_FREE_BUFFERS; i++) {\n\t\tif (rxq->pool[i].page != NULL) {\n\t\t\tpci_unmap_page(il->pci_dev, rxq->pool[i].page_dma,\n\t\t\t\t       PAGE_SIZE << il->hw_params.rx_page_order,\n\t\t\t\t       PCI_DMA_FROMDEVICE);\n\t\t\t__il_free_pages(il, rxq->pool[i].page);\n\t\t\trxq->pool[i].page = NULL;\n\t\t}\n\t}\n\n\tdma_free_coherent(&il->pci_dev->dev, 4 * RX_QUEUE_SIZE, rxq->bd,\n\t\t\t  rxq->bd_dma);\n\tdma_free_coherent(&il->pci_dev->dev, sizeof(struct il_rb_status),\n\t\t\t  rxq->rb_stts, rxq->rb_stts_dma);\n\trxq->bd = NULL;\n\trxq->rb_stts = NULL;\n}\n\nint\nil4965_rxq_stop(struct il_priv *il)\n{\n\tint ret;\n\n\t_il_wr(il, FH49_MEM_RCSR_CHNL0_CONFIG_REG, 0);\n\tret = _il_poll_bit(il, FH49_MEM_RSSR_RX_STATUS_REG,\n\t\t\t   FH49_RSSR_CHNL0_RX_STATUS_CHNL_IDLE,\n\t\t\t   FH49_RSSR_CHNL0_RX_STATUS_CHNL_IDLE,\n\t\t\t   1000);\n\tif (ret < 0)\n\t\tIL_ERR(\"Can't stop Rx DMA.\\n\");\n\n\treturn 0;\n}\n\nint\nil4965_hwrate_to_mac80211_idx(u32 rate_n_flags, enum nl80211_band band)\n{\n\tint idx = 0;\n\tint band_offset = 0;\n\n\t/* HT rate format: mac80211 wants an MCS number, which is just LSB */\n\tif (rate_n_flags & RATE_MCS_HT_MSK) {\n\t\tidx = (rate_n_flags & 0xff);\n\t\treturn idx;\n\t\t/* Legacy rate format, search for match in table */\n\t} else {\n\t\tif (band == NL80211_BAND_5GHZ)\n\t\t\tband_offset = IL_FIRST_OFDM_RATE;\n\t\tfor (idx = band_offset; idx < RATE_COUNT_LEGACY; idx++)\n\t\t\tif (il_rates[idx].plcp == (rate_n_flags & 0xFF))\n\t\t\t\treturn idx - band_offset;\n\t}\n\n\treturn -1;\n}\n\nstatic int\nil4965_calc_rssi(struct il_priv *il, struct il_rx_phy_res *rx_resp)\n{\n\t/* data from PHY/DSP regarding signal strength, etc.,\n\t *   contents are always there, not configurable by host.  */\n\tstruct il4965_rx_non_cfg_phy *ncphy =\n\t    (struct il4965_rx_non_cfg_phy *)rx_resp->non_cfg_phy_buf;\n\tu32 agc =\n\t    (le16_to_cpu(ncphy->agc_info) & IL49_AGC_DB_MASK) >>\n\t    IL49_AGC_DB_POS;\n\n\tu32 valid_antennae =\n\t    (le16_to_cpu(rx_resp->phy_flags) & IL49_RX_PHY_FLAGS_ANTENNAE_MASK)\n\t    >> IL49_RX_PHY_FLAGS_ANTENNAE_OFFSET;\n\tu8 max_rssi = 0;\n\tu32 i;\n\n\t/* Find max rssi among 3 possible receivers.\n\t * These values are measured by the digital signal processor (DSP).\n\t * They should stay fairly constant even as the signal strength varies,\n\t *   if the radio's automatic gain control (AGC) is working right.\n\t * AGC value (see below) will provide the \"interesting\" info. */\n\tfor (i = 0; i < 3; i++)\n\t\tif (valid_antennae & (1 << i))\n\t\t\tmax_rssi = max(ncphy->rssi_info[i << 1], max_rssi);\n\n\tD_STATS(\"Rssi In A %d B %d C %d Max %d AGC dB %d\\n\",\n\t\tncphy->rssi_info[0], ncphy->rssi_info[2], ncphy->rssi_info[4],\n\t\tmax_rssi, agc);\n\n\t/* dBm = max_rssi dB - agc dB - constant.\n\t * Higher AGC (higher radio gain) means lower signal. */\n\treturn max_rssi - agc - IL4965_RSSI_OFFSET;\n}\n\nstatic u32\nil4965_translate_rx_status(struct il_priv *il, u32 decrypt_in)\n{\n\tu32 decrypt_out = 0;\n\n\tif ((decrypt_in & RX_RES_STATUS_STATION_FOUND) ==\n\t    RX_RES_STATUS_STATION_FOUND)\n\t\tdecrypt_out |=\n\t\t    (RX_RES_STATUS_STATION_FOUND |\n\t\t     RX_RES_STATUS_NO_STATION_INFO_MISMATCH);\n\n\tdecrypt_out |= (decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK);\n\n\t/* packet was not encrypted */\n\tif ((decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK) ==\n\t    RX_RES_STATUS_SEC_TYPE_NONE)\n\t\treturn decrypt_out;\n\n\t/* packet was encrypted with unknown alg */\n\tif ((decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK) ==\n\t    RX_RES_STATUS_SEC_TYPE_ERR)\n\t\treturn decrypt_out;\n\n\t/* decryption was not done in HW */\n\tif ((decrypt_in & RX_MPDU_RES_STATUS_DEC_DONE_MSK) !=\n\t    RX_MPDU_RES_STATUS_DEC_DONE_MSK)\n\t\treturn decrypt_out;\n\n\tswitch (decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK) {\n\n\tcase RX_RES_STATUS_SEC_TYPE_CCMP:\n\t\t/* alg is CCM: check MIC only */\n\t\tif (!(decrypt_in & RX_MPDU_RES_STATUS_MIC_OK))\n\t\t\t/* Bad MIC */\n\t\t\tdecrypt_out |= RX_RES_STATUS_BAD_ICV_MIC;\n\t\telse\n\t\t\tdecrypt_out |= RX_RES_STATUS_DECRYPT_OK;\n\n\t\tbreak;\n\n\tcase RX_RES_STATUS_SEC_TYPE_TKIP:\n\t\tif (!(decrypt_in & RX_MPDU_RES_STATUS_TTAK_OK)) {\n\t\t\t/* Bad TTAK */\n\t\t\tdecrypt_out |= RX_RES_STATUS_BAD_KEY_TTAK;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\t/* if TTAK OK */\n\tdefault:\n\t\tif (!(decrypt_in & RX_MPDU_RES_STATUS_ICV_OK))\n\t\t\tdecrypt_out |= RX_RES_STATUS_BAD_ICV_MIC;\n\t\telse\n\t\t\tdecrypt_out |= RX_RES_STATUS_DECRYPT_OK;\n\t\tbreak;\n\t}\n\n\tD_RX(\"decrypt_in:0x%x  decrypt_out = 0x%x\\n\", decrypt_in, decrypt_out);\n\n\treturn decrypt_out;\n}\n\n#define SMALL_PACKET_SIZE 256\n\nstatic void\nil4965_pass_packet_to_mac80211(struct il_priv *il, struct ieee80211_hdr *hdr,\n\t\t\t       u32 len, u32 ampdu_status, struct il_rx_buf *rxb,\n\t\t\t       struct ieee80211_rx_status *stats)\n{\n\tstruct sk_buff *skb;\n\t__le16 fc = hdr->frame_control;\n\n\t/* We only process data packets if the interface is open */\n\tif (unlikely(!il->is_open)) {\n\t\tD_DROP(\"Dropping packet while interface is not open.\\n\");\n\t\treturn;\n\t}\n\n\tif (unlikely(test_bit(IL_STOP_REASON_PASSIVE, &il->stop_reason))) {\n\t\til_wake_queues_by_reason(il, IL_STOP_REASON_PASSIVE);\n\t\tD_INFO(\"Woke queues - frame received on passive channel\\n\");\n\t}\n\n\t/* In case of HW accelerated crypto and bad decryption, drop */\n\tif (!il->cfg->mod_params->sw_crypto &&\n\t    il_set_decrypted_flag(il, hdr, ampdu_status, stats))\n\t\treturn;\n\n\tskb = dev_alloc_skb(SMALL_PACKET_SIZE);\n\tif (!skb) {\n\t\tIL_ERR(\"dev_alloc_skb failed\\n\");\n\t\treturn;\n\t}\n\n\tif (len <= SMALL_PACKET_SIZE) {\n\t\tskb_put_data(skb, hdr, len);\n\t} else {\n\t\tskb_add_rx_frag(skb, 0, rxb->page, (void *)hdr - rxb_addr(rxb),\n\t\t\t\tlen, PAGE_SIZE << il->hw_params.rx_page_order);\n\t\til->alloc_rxb_page--;\n\t\trxb->page = NULL;\n\t}\n\n\til_update_stats(il, false, fc, len);\n\tmemcpy(IEEE80211_SKB_RXCB(skb), stats, sizeof(*stats));\n\n\tieee80211_rx(il->hw, skb);\n}\n\n/* Called for N_RX (legacy ABG frames), or\n * N_RX_MPDU (HT high-throughput N frames). */\nstatic void\nil4965_hdl_rx(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct ieee80211_hdr *header;\n\tstruct ieee80211_rx_status rx_status = {};\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il_rx_phy_res *phy_res;\n\t__le32 rx_pkt_status;\n\tstruct il_rx_mpdu_res_start *amsdu;\n\tu32 len;\n\tu32 ampdu_status;\n\tu32 rate_n_flags;\n\n\t/**\n\t * N_RX and N_RX_MPDU are handled differently.\n\t *\tN_RX: physical layer info is in this buffer\n\t *\tN_RX_MPDU: physical layer info was sent in separate\n\t *\t\tcommand and cached in il->last_phy_res\n\t *\n\t * Here we set up local variables depending on which command is\n\t * received.\n\t */\n\tif (pkt->hdr.cmd == N_RX) {\n\t\tphy_res = (struct il_rx_phy_res *)pkt->u.raw;\n\t\theader =\n\t\t    (struct ieee80211_hdr *)(pkt->u.raw + sizeof(*phy_res) +\n\t\t\t\t\t     phy_res->cfg_phy_cnt);\n\n\t\tlen = le16_to_cpu(phy_res->byte_count);\n\t\trx_pkt_status =\n\t\t    *(__le32 *) (pkt->u.raw + sizeof(*phy_res) +\n\t\t\t\t phy_res->cfg_phy_cnt + len);\n\t\tampdu_status = le32_to_cpu(rx_pkt_status);\n\t} else {\n\t\tif (!il->_4965.last_phy_res_valid) {\n\t\t\tIL_ERR(\"MPDU frame without cached PHY data\\n\");\n\t\t\treturn;\n\t\t}\n\t\tphy_res = &il->_4965.last_phy_res;\n\t\tamsdu = (struct il_rx_mpdu_res_start *)pkt->u.raw;\n\t\theader = (struct ieee80211_hdr *)(pkt->u.raw + sizeof(*amsdu));\n\t\tlen = le16_to_cpu(amsdu->byte_count);\n\t\trx_pkt_status = *(__le32 *) (pkt->u.raw + sizeof(*amsdu) + len);\n\t\tampdu_status =\n\t\t    il4965_translate_rx_status(il, le32_to_cpu(rx_pkt_status));\n\t}\n\n\tif ((unlikely(phy_res->cfg_phy_cnt > 20))) {\n\t\tD_DROP(\"dsp size out of range [0,20]: %d\\n\",\n\t\t       phy_res->cfg_phy_cnt);\n\t\treturn;\n\t}\n\n\tif (!(rx_pkt_status & RX_RES_STATUS_NO_CRC32_ERROR) ||\n\t    !(rx_pkt_status & RX_RES_STATUS_NO_RXE_OVERFLOW)) {\n\t\tD_RX(\"Bad CRC or FIFO: 0x%08X.\\n\", le32_to_cpu(rx_pkt_status));\n\t\treturn;\n\t}\n\n\t/* This will be used in several places later */\n\trate_n_flags = le32_to_cpu(phy_res->rate_n_flags);\n\n\t/* rx_status carries information about the packet to mac80211 */\n\trx_status.mactime = le64_to_cpu(phy_res->timestamp);\n\trx_status.band =\n\t    (phy_res->\n\t     phy_flags & RX_RES_PHY_FLAGS_BAND_24_MSK) ? NL80211_BAND_2GHZ :\n\t    NL80211_BAND_5GHZ;\n\trx_status.freq =\n\t    ieee80211_channel_to_frequency(le16_to_cpu(phy_res->channel),\n\t\t\t\t\t   rx_status.band);\n\trx_status.rate_idx =\n\t    il4965_hwrate_to_mac80211_idx(rate_n_flags, rx_status.band);\n\trx_status.flag = 0;\n\n\t/* TSF isn't reliable. In order to allow smooth user experience,\n\t * this W/A doesn't propagate it to the mac80211 */\n\t/*rx_status.flag |= RX_FLAG_MACTIME_START; */\n\n\til->ucode_beacon_time = le32_to_cpu(phy_res->beacon_time_stamp);\n\n\t/* Find max signal strength (dBm) among 3 antenna/receiver chains */\n\trx_status.signal = il4965_calc_rssi(il, phy_res);\n\n\tD_STATS(\"Rssi %d, TSF %llu\\n\", rx_status.signal,\n\t\t(unsigned long long)rx_status.mactime);\n\n\t/*\n\t * \"antenna number\"\n\t *\n\t * It seems that the antenna field in the phy flags value\n\t * is actually a bit field. This is undefined by radiotap,\n\t * it wants an actual antenna number but I always get \"7\"\n\t * for most legacy frames I receive indicating that the\n\t * same frame was received on all three RX chains.\n\t *\n\t * I think this field should be removed in favor of a\n\t * new 802.11n radiotap field \"RX chains\" that is defined\n\t * as a bitmask.\n\t */\n\trx_status.antenna =\n\t    (le16_to_cpu(phy_res->phy_flags) & RX_RES_PHY_FLAGS_ANTENNA_MSK) >>\n\t    RX_RES_PHY_FLAGS_ANTENNA_POS;\n\n\t/* set the preamble flag if appropriate */\n\tif (phy_res->phy_flags & RX_RES_PHY_FLAGS_SHORT_PREAMBLE_MSK)\n\t\trx_status.enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\n\t/* Set up the HT phy flags */\n\tif (rate_n_flags & RATE_MCS_HT_MSK)\n\t\trx_status.encoding = RX_ENC_HT;\n\tif (rate_n_flags & RATE_MCS_HT40_MSK)\n\t\trx_status.bw = RATE_INFO_BW_40;\n\telse\n\t\trx_status.bw = RATE_INFO_BW_20;\n\tif (rate_n_flags & RATE_MCS_SGI_MSK)\n\t\trx_status.enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\n\tif (phy_res->phy_flags & RX_RES_PHY_FLAGS_AGG_MSK) {\n\t\t/* We know which subframes of an A-MPDU belong\n\t\t * together since we get a single PHY response\n\t\t * from the firmware for all of them.\n\t\t */\n\n\t\trx_status.flag |= RX_FLAG_AMPDU_DETAILS;\n\t\trx_status.ampdu_reference = il->_4965.ampdu_ref;\n\t}\n\n\til4965_pass_packet_to_mac80211(il, header, len, ampdu_status, rxb,\n\t\t\t\t       &rx_status);\n}\n\n/* Cache phy data (Rx signal strength, etc) for HT frame (N_RX_PHY).\n * This will be used later in il_hdl_rx() for N_RX_MPDU. */\nstatic void\nil4965_hdl_rx_phy(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\til->_4965.last_phy_res_valid = true;\n\til->_4965.ampdu_ref++;\n\tmemcpy(&il->_4965.last_phy_res, pkt->u.raw,\n\t       sizeof(struct il_rx_phy_res));\n}\n\nstatic int\nil4965_get_channels_for_scan(struct il_priv *il, struct ieee80211_vif *vif,\n\t\t\t     enum nl80211_band band, u8 is_active,\n\t\t\t     u8 n_probes, struct il_scan_channel *scan_ch)\n{\n\tstruct ieee80211_channel *chan;\n\tconst struct ieee80211_supported_band *sband;\n\tconst struct il_channel_info *ch_info;\n\tu16 passive_dwell = 0;\n\tu16 active_dwell = 0;\n\tint added, i;\n\tu16 channel;\n\n\tsband = il_get_hw_mode(il, band);\n\tif (!sband)\n\t\treturn 0;\n\n\tactive_dwell = il_get_active_dwell_time(il, band, n_probes);\n\tpassive_dwell = il_get_passive_dwell_time(il, band, vif);\n\n\tif (passive_dwell <= active_dwell)\n\t\tpassive_dwell = active_dwell + 1;\n\n\tfor (i = 0, added = 0; i < il->scan_request->n_channels; i++) {\n\t\tchan = il->scan_request->channels[i];\n\n\t\tif (chan->band != band)\n\t\t\tcontinue;\n\n\t\tchannel = chan->hw_value;\n\t\tscan_ch->channel = cpu_to_le16(channel);\n\n\t\tch_info = il_get_channel_info(il, band, channel);\n\t\tif (!il_is_channel_valid(ch_info)) {\n\t\t\tD_SCAN(\"Channel %d is INVALID for this band.\\n\",\n\t\t\t       channel);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!is_active || il_is_channel_passive(ch_info) ||\n\t\t    (chan->flags & IEEE80211_CHAN_NO_IR))\n\t\t\tscan_ch->type = SCAN_CHANNEL_TYPE_PASSIVE;\n\t\telse\n\t\t\tscan_ch->type = SCAN_CHANNEL_TYPE_ACTIVE;\n\n\t\tif (n_probes)\n\t\t\tscan_ch->type |= IL_SCAN_PROBE_MASK(n_probes);\n\n\t\tscan_ch->active_dwell = cpu_to_le16(active_dwell);\n\t\tscan_ch->passive_dwell = cpu_to_le16(passive_dwell);\n\n\t\t/* Set txpower levels to defaults */\n\t\tscan_ch->dsp_atten = 110;\n\n\t\t/* NOTE: if we were doing 6Mb OFDM for scans we'd use\n\t\t * power level:\n\t\t * scan_ch->tx_gain = ((1 << 5) | (2 << 3)) | 3;\n\t\t */\n\t\tif (band == NL80211_BAND_5GHZ)\n\t\t\tscan_ch->tx_gain = ((1 << 5) | (3 << 3)) | 3;\n\t\telse\n\t\t\tscan_ch->tx_gain = ((1 << 5) | (5 << 3));\n\n\t\tD_SCAN(\"Scanning ch=%d prob=0x%X [%s %d]\\n\", channel,\n\t\t       le32_to_cpu(scan_ch->type),\n\t\t       (scan_ch->\n\t\t\ttype & SCAN_CHANNEL_TYPE_ACTIVE) ? \"ACTIVE\" : \"PASSIVE\",\n\t\t       (scan_ch->\n\t\t\ttype & SCAN_CHANNEL_TYPE_ACTIVE) ? active_dwell :\n\t\t       passive_dwell);\n\n\t\tscan_ch++;\n\t\tadded++;\n\t}\n\n\tD_SCAN(\"total channels to scan %d\\n\", added);\n\treturn added;\n}\n\nstatic void\nil4965_toggle_tx_ant(struct il_priv *il, u8 *ant, u8 valid)\n{\n\tint i;\n\tu8 ind = *ant;\n\n\tfor (i = 0; i < RATE_ANT_NUM - 1; i++) {\n\t\tind = (ind + 1) < RATE_ANT_NUM ? ind + 1 : 0;\n\t\tif (valid & BIT(ind)) {\n\t\t\t*ant = ind;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint\nil4965_request_scan(struct il_priv *il, struct ieee80211_vif *vif)\n{\n\tstruct il_host_cmd cmd = {\n\t\t.id = C_SCAN,\n\t\t.len = sizeof(struct il_scan_cmd),\n\t\t.flags = CMD_SIZE_HUGE,\n\t};\n\tstruct il_scan_cmd *scan;\n\tu32 rate_flags = 0;\n\tu16 cmd_len;\n\tu16 rx_chain = 0;\n\tenum nl80211_band band;\n\tu8 n_probes = 0;\n\tu8 rx_ant = il->hw_params.valid_rx_ant;\n\tu8 rate;\n\tbool is_active = false;\n\tint chan_mod;\n\tu8 active_chains;\n\tu8 scan_tx_antennas = il->hw_params.valid_tx_ant;\n\tint ret;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tif (!il->scan_cmd) {\n\t\til->scan_cmd =\n\t\t    kmalloc(sizeof(struct il_scan_cmd) + IL_MAX_SCAN_SIZE,\n\t\t\t    GFP_KERNEL);\n\t\tif (!il->scan_cmd) {\n\t\t\tD_SCAN(\"fail to allocate memory for scan\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tscan = il->scan_cmd;\n\tmemset(scan, 0, sizeof(struct il_scan_cmd) + IL_MAX_SCAN_SIZE);\n\n\tscan->quiet_plcp_th = IL_PLCP_QUIET_THRESH;\n\tscan->quiet_time = IL_ACTIVE_QUIET_TIME;\n\n\tif (il_is_any_associated(il)) {\n\t\tu16 interval;\n\t\tu32 extra;\n\t\tu32 suspend_time = 100;\n\t\tu32 scan_suspend_time = 100;\n\n\t\tD_INFO(\"Scanning while associated...\\n\");\n\t\tinterval = vif->bss_conf.beacon_int;\n\n\t\tscan->suspend_time = 0;\n\t\tscan->max_out_time = cpu_to_le32(200 * 1024);\n\t\tif (!interval)\n\t\t\tinterval = suspend_time;\n\n\t\textra = (suspend_time / interval) << 22;\n\t\tscan_suspend_time =\n\t\t    (extra | ((suspend_time % interval) * 1024));\n\t\tscan->suspend_time = cpu_to_le32(scan_suspend_time);\n\t\tD_SCAN(\"suspend_time 0x%X beacon interval %d\\n\",\n\t\t       scan_suspend_time, interval);\n\t}\n\n\tif (il->scan_request->n_ssids) {\n\t\tint i, p = 0;\n\t\tD_SCAN(\"Kicking off active scan\\n\");\n\t\tfor (i = 0; i < il->scan_request->n_ssids; i++) {\n\t\t\t/* always does wildcard anyway */\n\t\t\tif (!il->scan_request->ssids[i].ssid_len)\n\t\t\t\tcontinue;\n\t\t\tscan->direct_scan[p].id = WLAN_EID_SSID;\n\t\t\tscan->direct_scan[p].len =\n\t\t\t    il->scan_request->ssids[i].ssid_len;\n\t\t\tmemcpy(scan->direct_scan[p].ssid,\n\t\t\t       il->scan_request->ssids[i].ssid,\n\t\t\t       il->scan_request->ssids[i].ssid_len);\n\t\t\tn_probes++;\n\t\t\tp++;\n\t\t}\n\t\tis_active = true;\n\t} else\n\t\tD_SCAN(\"Start passive scan.\\n\");\n\n\tscan->tx_cmd.tx_flags = TX_CMD_FLG_SEQ_CTL_MSK;\n\tscan->tx_cmd.sta_id = il->hw_params.bcast_id;\n\tscan->tx_cmd.stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\n\n\tswitch (il->scan_band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tscan->flags = RXON_FLG_BAND_24G_MSK | RXON_FLG_AUTO_DETECT_MSK;\n\t\tchan_mod =\n\t\t    le32_to_cpu(il->active.flags & RXON_FLG_CHANNEL_MODE_MSK) >>\n\t\t    RXON_FLG_CHANNEL_MODE_POS;\n\t\tif (chan_mod == CHANNEL_MODE_PURE_40) {\n\t\t\trate = RATE_6M_PLCP;\n\t\t} else {\n\t\t\trate = RATE_1M_PLCP;\n\t\t\trate_flags = RATE_MCS_CCK_MSK;\n\t\t}\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\trate = RATE_6M_PLCP;\n\t\tbreak;\n\tdefault:\n\t\tIL_WARN(\"Invalid scan band\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * If active scanning is requested but a certain channel is\n\t * marked passive, we can do active scanning if we detect\n\t * transmissions.\n\t *\n\t * There is an issue with some firmware versions that triggers\n\t * a sysassert on a \"good CRC threshold\" of zero (== disabled),\n\t * on a radar channel even though this means that we should NOT\n\t * send probes.\n\t *\n\t * The \"good CRC threshold\" is the number of frames that we\n\t * need to receive during our dwell time on a channel before\n\t * sending out probes -- setting this to a huge value will\n\t * mean we never reach it, but at the same time work around\n\t * the aforementioned issue. Thus use IL_GOOD_CRC_TH_NEVER\n\t * here instead of IL_GOOD_CRC_TH_DISABLED.\n\t */\n\tscan->good_CRC_th =\n\t    is_active ? IL_GOOD_CRC_TH_DEFAULT : IL_GOOD_CRC_TH_NEVER;\n\n\tband = il->scan_band;\n\n\tif (il->cfg->scan_rx_antennas[band])\n\t\trx_ant = il->cfg->scan_rx_antennas[band];\n\n\til4965_toggle_tx_ant(il, &il->scan_tx_ant[band], scan_tx_antennas);\n\trate_flags |= BIT(il->scan_tx_ant[band]) << RATE_MCS_ANT_POS;\n\tscan->tx_cmd.rate_n_flags = cpu_to_le32(rate | rate_flags);\n\n\t/* In power save mode use one chain, otherwise use all chains */\n\tif (test_bit(S_POWER_PMI, &il->status)) {\n\t\t/* rx_ant has been set to all valid chains previously */\n\t\tactive_chains =\n\t\t    rx_ant & ((u8) (il->chain_noise_data.active_chains));\n\t\tif (!active_chains)\n\t\t\tactive_chains = rx_ant;\n\n\t\tD_SCAN(\"chain_noise_data.active_chains: %u\\n\",\n\t\t       il->chain_noise_data.active_chains);\n\n\t\trx_ant = il4965_first_antenna(active_chains);\n\t}\n\n\t/* MIMO is not used here, but value is required */\n\trx_chain |= il->hw_params.valid_rx_ant << RXON_RX_CHAIN_VALID_POS;\n\trx_chain |= rx_ant << RXON_RX_CHAIN_FORCE_MIMO_SEL_POS;\n\trx_chain |= rx_ant << RXON_RX_CHAIN_FORCE_SEL_POS;\n\trx_chain |= 0x1 << RXON_RX_CHAIN_DRIVER_FORCE_POS;\n\tscan->rx_chain = cpu_to_le16(rx_chain);\n\n\tcmd_len =\n\t    il_fill_probe_req(il, (struct ieee80211_mgmt *)scan->data,\n\t\t\t      vif->addr, il->scan_request->ie,\n\t\t\t      il->scan_request->ie_len,\n\t\t\t      IL_MAX_SCAN_SIZE - sizeof(*scan));\n\tscan->tx_cmd.len = cpu_to_le16(cmd_len);\n\n\tscan->filter_flags |=\n\t    (RXON_FILTER_ACCEPT_GRP_MSK | RXON_FILTER_BCON_AWARE_MSK);\n\n\tscan->channel_count =\n\t    il4965_get_channels_for_scan(il, vif, band, is_active, n_probes,\n\t\t\t\t\t (void *)&scan->data[cmd_len]);\n\tif (scan->channel_count == 0) {\n\t\tD_SCAN(\"channel count %d\\n\", scan->channel_count);\n\t\treturn -EIO;\n\t}\n\n\tcmd.len +=\n\t    le16_to_cpu(scan->tx_cmd.len) +\n\t    scan->channel_count * sizeof(struct il_scan_channel);\n\tcmd.data = scan;\n\tscan->len = cpu_to_le16(cmd.len);\n\n\tset_bit(S_SCAN_HW, &il->status);\n\n\tret = il_send_cmd_sync(il, &cmd);\n\tif (ret)\n\t\tclear_bit(S_SCAN_HW, &il->status);\n\n\treturn ret;\n}\n\nint\nil4965_manage_ibss_station(struct il_priv *il, struct ieee80211_vif *vif,\n\t\t\t   bool add)\n{\n\tstruct il_vif_priv *vif_priv = (void *)vif->drv_priv;\n\n\tif (add)\n\t\treturn il4965_add_bssid_station(il, vif->bss_conf.bssid,\n\t\t\t\t\t\t&vif_priv->ibss_bssid_sta_id);\n\treturn il_remove_station(il, vif_priv->ibss_bssid_sta_id,\n\t\t\t\t vif->bss_conf.bssid);\n}\n\nvoid\nil4965_free_tfds_in_queue(struct il_priv *il, int sta_id, int tid, int freed)\n{\n\tlockdep_assert_held(&il->sta_lock);\n\n\tif (il->stations[sta_id].tid[tid].tfds_in_queue >= freed)\n\t\til->stations[sta_id].tid[tid].tfds_in_queue -= freed;\n\telse {\n\t\tD_TX(\"free more than tfds_in_queue (%u:%d)\\n\",\n\t\t     il->stations[sta_id].tid[tid].tfds_in_queue, freed);\n\t\til->stations[sta_id].tid[tid].tfds_in_queue = 0;\n\t}\n}\n\n#define IL_TX_QUEUE_MSK\t0xfffff\n\nstatic bool\nil4965_is_single_rx_stream(struct il_priv *il)\n{\n\treturn il->current_ht_config.smps == IEEE80211_SMPS_STATIC ||\n\t    il->current_ht_config.single_chain_sufficient;\n}\n\n#define IL_NUM_RX_CHAINS_MULTIPLE\t3\n#define IL_NUM_RX_CHAINS_SINGLE\t2\n#define IL_NUM_IDLE_CHAINS_DUAL\t2\n#define IL_NUM_IDLE_CHAINS_SINGLE\t1\n\n/*\n * Determine how many receiver/antenna chains to use.\n *\n * More provides better reception via diversity.  Fewer saves power\n * at the expense of throughput, but only when not in powersave to\n * start with.\n *\n * MIMO (dual stream) requires at least 2, but works better with 3.\n * This does not determine *which* chains to use, just how many.\n */\nstatic int\nil4965_get_active_rx_chain_count(struct il_priv *il)\n{\n\t/* # of Rx chains to use when expecting MIMO. */\n\tif (il4965_is_single_rx_stream(il))\n\t\treturn IL_NUM_RX_CHAINS_SINGLE;\n\telse\n\t\treturn IL_NUM_RX_CHAINS_MULTIPLE;\n}\n\n/*\n * When we are in power saving mode, unless device support spatial\n * multiplexing power save, use the active count for rx chain count.\n */\nstatic int\nil4965_get_idle_rx_chain_count(struct il_priv *il, int active_cnt)\n{\n\t/* # Rx chains when idling, depending on SMPS mode */\n\tswitch (il->current_ht_config.smps) {\n\tcase IEEE80211_SMPS_STATIC:\n\tcase IEEE80211_SMPS_DYNAMIC:\n\t\treturn IL_NUM_IDLE_CHAINS_SINGLE;\n\tcase IEEE80211_SMPS_OFF:\n\t\treturn active_cnt;\n\tdefault:\n\t\tWARN(1, \"invalid SMPS mode %d\", il->current_ht_config.smps);\n\t\treturn active_cnt;\n\t}\n}\n\n/* up to 4 chains */\nstatic u8\nil4965_count_chain_bitmap(u32 chain_bitmap)\n{\n\tu8 res;\n\tres = (chain_bitmap & BIT(0)) >> 0;\n\tres += (chain_bitmap & BIT(1)) >> 1;\n\tres += (chain_bitmap & BIT(2)) >> 2;\n\tres += (chain_bitmap & BIT(3)) >> 3;\n\treturn res;\n}\n\n/*\n * il4965_set_rxon_chain - Set up Rx chain usage in \"staging\" RXON image\n *\n * Selects how many and which Rx receivers/antennas/chains to use.\n * This should not be used for scan command ... it puts data in wrong place.\n */\nvoid\nil4965_set_rxon_chain(struct il_priv *il)\n{\n\tbool is_single = il4965_is_single_rx_stream(il);\n\tbool is_cam = !test_bit(S_POWER_PMI, &il->status);\n\tu8 idle_rx_cnt, active_rx_cnt, valid_rx_cnt;\n\tu32 active_chains;\n\tu16 rx_chain;\n\n\t/* Tell uCode which antennas are actually connected.\n\t * Before first association, we assume all antennas are connected.\n\t * Just after first association, il4965_chain_noise_calibration()\n\t *    checks which antennas actually *are* connected. */\n\tif (il->chain_noise_data.active_chains)\n\t\tactive_chains = il->chain_noise_data.active_chains;\n\telse\n\t\tactive_chains = il->hw_params.valid_rx_ant;\n\n\trx_chain = active_chains << RXON_RX_CHAIN_VALID_POS;\n\n\t/* How many receivers should we use? */\n\tactive_rx_cnt = il4965_get_active_rx_chain_count(il);\n\tidle_rx_cnt = il4965_get_idle_rx_chain_count(il, active_rx_cnt);\n\n\t/* correct rx chain count according hw settings\n\t * and chain noise calibration\n\t */\n\tvalid_rx_cnt = il4965_count_chain_bitmap(active_chains);\n\tif (valid_rx_cnt < active_rx_cnt)\n\t\tactive_rx_cnt = valid_rx_cnt;\n\n\tif (valid_rx_cnt < idle_rx_cnt)\n\t\tidle_rx_cnt = valid_rx_cnt;\n\n\trx_chain |= active_rx_cnt << RXON_RX_CHAIN_MIMO_CNT_POS;\n\trx_chain |= idle_rx_cnt << RXON_RX_CHAIN_CNT_POS;\n\n\til->staging.rx_chain = cpu_to_le16(rx_chain);\n\n\tif (!is_single && active_rx_cnt >= IL_NUM_RX_CHAINS_SINGLE && is_cam)\n\t\til->staging.rx_chain |= RXON_RX_CHAIN_MIMO_FORCE_MSK;\n\telse\n\t\til->staging.rx_chain &= ~RXON_RX_CHAIN_MIMO_FORCE_MSK;\n\n\tD_ASSOC(\"rx_chain=0x%X active=%d idle=%d\\n\", il->staging.rx_chain,\n\t\tactive_rx_cnt, idle_rx_cnt);\n\n\tWARN_ON(active_rx_cnt == 0 || idle_rx_cnt == 0 ||\n\t\tactive_rx_cnt < idle_rx_cnt);\n}\n\nstatic const char *\nil4965_get_fh_string(int cmd)\n{\n\tswitch (cmd) {\n\t\tIL_CMD(FH49_RSCSR_CHNL0_STTS_WPTR_REG);\n\t\tIL_CMD(FH49_RSCSR_CHNL0_RBDCB_BASE_REG);\n\t\tIL_CMD(FH49_RSCSR_CHNL0_WPTR);\n\t\tIL_CMD(FH49_MEM_RCSR_CHNL0_CONFIG_REG);\n\t\tIL_CMD(FH49_MEM_RSSR_SHARED_CTRL_REG);\n\t\tIL_CMD(FH49_MEM_RSSR_RX_STATUS_REG);\n\t\tIL_CMD(FH49_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV);\n\t\tIL_CMD(FH49_TSSR_TX_STATUS_REG);\n\t\tIL_CMD(FH49_TSSR_TX_ERROR_REG);\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\nint\nil4965_dump_fh(struct il_priv *il, char **buf, bool display)\n{\n\tint i;\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tint pos = 0;\n\tsize_t bufsz = 0;\n#endif\n\tstatic const u32 fh_tbl[] = {\n\t\tFH49_RSCSR_CHNL0_STTS_WPTR_REG,\n\t\tFH49_RSCSR_CHNL0_RBDCB_BASE_REG,\n\t\tFH49_RSCSR_CHNL0_WPTR,\n\t\tFH49_MEM_RCSR_CHNL0_CONFIG_REG,\n\t\tFH49_MEM_RSSR_SHARED_CTRL_REG,\n\t\tFH49_MEM_RSSR_RX_STATUS_REG,\n\t\tFH49_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV,\n\t\tFH49_TSSR_TX_STATUS_REG,\n\t\tFH49_TSSR_TX_ERROR_REG\n\t};\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tif (display) {\n\t\tbufsz = ARRAY_SIZE(fh_tbl) * 48 + 40;\n\t\t*buf = kmalloc(bufsz, GFP_KERNEL);\n\t\tif (!*buf)\n\t\t\treturn -ENOMEM;\n\t\tpos +=\n\t\t    scnprintf(*buf + pos, bufsz - pos, \"FH register values:\\n\");\n\t\tfor (i = 0; i < ARRAY_SIZE(fh_tbl); i++) {\n\t\t\tpos +=\n\t\t\t    scnprintf(*buf + pos, bufsz - pos,\n\t\t\t\t      \"  %34s: 0X%08x\\n\",\n\t\t\t\t      il4965_get_fh_string(fh_tbl[i]),\n\t\t\t\t      il_rd(il, fh_tbl[i]));\n\t\t}\n\t\treturn pos;\n\t}\n#endif\n\tIL_ERR(\"FH register values:\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(fh_tbl); i++) {\n\t\tIL_ERR(\"  %34s: 0X%08x\\n\", il4965_get_fh_string(fh_tbl[i]),\n\t\t       il_rd(il, fh_tbl[i]));\n\t}\n\treturn 0;\n}\n\nstatic void\nil4965_hdl_missed_beacon(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il_missed_beacon_notif *missed_beacon;\n\n\tmissed_beacon = &pkt->u.missed_beacon;\n\tif (le32_to_cpu(missed_beacon->consecutive_missed_beacons) >\n\t    il->missed_beacon_threshold) {\n\t\tD_CALIB(\"missed bcn cnsq %d totl %d rcd %d expctd %d\\n\",\n\t\t\tle32_to_cpu(missed_beacon->consecutive_missed_beacons),\n\t\t\tle32_to_cpu(missed_beacon->total_missed_becons),\n\t\t\tle32_to_cpu(missed_beacon->num_recvd_beacons),\n\t\t\tle32_to_cpu(missed_beacon->num_expected_beacons));\n\t\tif (!test_bit(S_SCANNING, &il->status))\n\t\t\til4965_init_sensitivity(il);\n\t}\n}\n\n/* Calculate noise level, based on measurements during network silence just\n *   before arriving beacon.  This measurement can be done only if we know\n *   exactly when to expect beacons, therefore only when we're associated. */\nstatic void\nil4965_rx_calc_noise(struct il_priv *il)\n{\n\tstruct stats_rx_non_phy *rx_info;\n\tint num_active_rx = 0;\n\tint total_silence = 0;\n\tint bcn_silence_a, bcn_silence_b, bcn_silence_c;\n\tint last_rx_noise;\n\n\trx_info = &(il->_4965.stats.rx.general);\n\tbcn_silence_a =\n\t    le32_to_cpu(rx_info->beacon_silence_rssi_a) & IN_BAND_FILTER;\n\tbcn_silence_b =\n\t    le32_to_cpu(rx_info->beacon_silence_rssi_b) & IN_BAND_FILTER;\n\tbcn_silence_c =\n\t    le32_to_cpu(rx_info->beacon_silence_rssi_c) & IN_BAND_FILTER;\n\n\tif (bcn_silence_a) {\n\t\ttotal_silence += bcn_silence_a;\n\t\tnum_active_rx++;\n\t}\n\tif (bcn_silence_b) {\n\t\ttotal_silence += bcn_silence_b;\n\t\tnum_active_rx++;\n\t}\n\tif (bcn_silence_c) {\n\t\ttotal_silence += bcn_silence_c;\n\t\tnum_active_rx++;\n\t}\n\n\t/* Average among active antennas */\n\tif (num_active_rx)\n\t\tlast_rx_noise = (total_silence / num_active_rx) - 107;\n\telse\n\t\tlast_rx_noise = IL_NOISE_MEAS_NOT_AVAILABLE;\n\n\tD_CALIB(\"inband silence a %u, b %u, c %u, dBm %d\\n\", bcn_silence_a,\n\t\tbcn_silence_b, bcn_silence_c, last_rx_noise);\n}\n\n#ifdef CONFIG_IWLEGACY_DEBUGFS\n/*\n *  based on the assumption of all stats counter are in DWORD\n *  FIXME: This function is for debugging, do not deal with\n *  the case of counters roll-over.\n */\nstatic void\nil4965_accumulative_stats(struct il_priv *il, __le32 * stats)\n{\n\tint i, size;\n\t__le32 *prev_stats;\n\tu32 *accum_stats;\n\tu32 *delta, *max_delta;\n\tstruct stats_general_common *general, *accum_general;\n\n\tprev_stats = (__le32 *) &il->_4965.stats;\n\taccum_stats = (u32 *) &il->_4965.accum_stats;\n\tsize = sizeof(struct il_notif_stats);\n\tgeneral = &il->_4965.stats.general.common;\n\taccum_general = &il->_4965.accum_stats.general.common;\n\tdelta = (u32 *) &il->_4965.delta_stats;\n\tmax_delta = (u32 *) &il->_4965.max_delta;\n\n\tfor (i = sizeof(__le32); i < size;\n\t     i +=\n\t     sizeof(__le32), stats++, prev_stats++, delta++, max_delta++,\n\t     accum_stats++) {\n\t\tif (le32_to_cpu(*stats) > le32_to_cpu(*prev_stats)) {\n\t\t\t*delta =\n\t\t\t    (le32_to_cpu(*stats) - le32_to_cpu(*prev_stats));\n\t\t\t*accum_stats += *delta;\n\t\t\tif (*delta > *max_delta)\n\t\t\t\t*max_delta = *delta;\n\t\t}\n\t}\n\n\t/* reset accumulative stats for \"no-counter\" type stats */\n\taccum_general->temperature = general->temperature;\n\taccum_general->ttl_timestamp = general->ttl_timestamp;\n}\n#endif\n\nstatic void\nil4965_hdl_stats(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tconst int recalib_seconds = 60;\n\tbool change;\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\n\tD_RX(\"Statistics notification received (%d vs %d).\\n\",\n\t     (int)sizeof(struct il_notif_stats),\n\t     le32_to_cpu(pkt->len_n_flags) & IL_RX_FRAME_SIZE_MSK);\n\n\tchange =\n\t    ((il->_4965.stats.general.common.temperature !=\n\t      pkt->u.stats.general.common.temperature) ||\n\t     ((il->_4965.stats.flag & STATS_REPLY_FLG_HT40_MODE_MSK) !=\n\t      (pkt->u.stats.flag & STATS_REPLY_FLG_HT40_MODE_MSK)));\n#ifdef CONFIG_IWLEGACY_DEBUGFS\n\til4965_accumulative_stats(il, (__le32 *) &pkt->u.stats);\n#endif\n\n\t/* TODO: reading some of stats is unneeded */\n\tmemcpy(&il->_4965.stats, &pkt->u.stats, sizeof(il->_4965.stats));\n\n\tset_bit(S_STATS, &il->status);\n\n\t/*\n\t * Reschedule the stats timer to occur in recalib_seconds to ensure\n\t * we get a thermal update even if the uCode doesn't give us one\n\t */\n\tmod_timer(&il->stats_periodic,\n\t\t  jiffies + msecs_to_jiffies(recalib_seconds * 1000));\n\n\tif (unlikely(!test_bit(S_SCANNING, &il->status)) &&\n\t    (pkt->hdr.cmd == N_STATS)) {\n\t\til4965_rx_calc_noise(il);\n\t\tqueue_work(il->workqueue, &il->run_time_calib_work);\n\t}\n\n\tif (change)\n\t\til4965_temperature_calib(il);\n}\n\nstatic void\nil4965_hdl_c_stats(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\n\tif (le32_to_cpu(pkt->u.stats.flag) & UCODE_STATS_CLEAR_MSK) {\n#ifdef CONFIG_IWLEGACY_DEBUGFS\n\t\tmemset(&il->_4965.accum_stats, 0,\n\t\t       sizeof(struct il_notif_stats));\n\t\tmemset(&il->_4965.delta_stats, 0,\n\t\t       sizeof(struct il_notif_stats));\n\t\tmemset(&il->_4965.max_delta, 0, sizeof(struct il_notif_stats));\n#endif\n\t\tD_RX(\"Statistics have been cleared\\n\");\n\t}\n\til4965_hdl_stats(il, rxb);\n}\n\n\n/*\n * mac80211 queues, ACs, hardware queues, FIFOs.\n *\n * Cf. https://wireless.wiki.kernel.org/en/developers/Documentation/mac80211/queues\n *\n * Mac80211 uses the following numbers, which we get as from it\n * by way of skb_get_queue_mapping(skb):\n *\n *     VO      0\n *     VI      1\n *     BE      2\n *     BK      3\n *\n *\n * Regular (not A-MPDU) frames are put into hardware queues corresponding\n * to the FIFOs, see comments in iwl-prph.h. Aggregated frames get their\n * own queue per aggregation session (RA/TID combination), such queues are\n * set up to map into FIFOs too, for which we need an AC->FIFO mapping. In\n * order to map frames to the right queue, we also need an AC->hw queue\n * mapping. This is implemented here.\n *\n * Due to the way hw queues are set up (by the hw specific modules like\n * 4965.c), the AC->hw queue mapping is the identity\n * mapping.\n */\n\nstatic const u8 tid_to_ac[] = {\n\tIEEE80211_AC_BE,\n\tIEEE80211_AC_BK,\n\tIEEE80211_AC_BK,\n\tIEEE80211_AC_BE,\n\tIEEE80211_AC_VI,\n\tIEEE80211_AC_VI,\n\tIEEE80211_AC_VO,\n\tIEEE80211_AC_VO\n};\n\nstatic inline int\nil4965_get_ac_from_tid(u16 tid)\n{\n\tif (likely(tid < ARRAY_SIZE(tid_to_ac)))\n\t\treturn tid_to_ac[tid];\n\n\t/* no support for TIDs 8-15 yet */\n\treturn -EINVAL;\n}\n\nstatic inline int\nil4965_get_fifo_from_tid(u16 tid)\n{\n\tstatic const u8 ac_to_fifo[] = {\n\t\tIL_TX_FIFO_VO,\n\t\tIL_TX_FIFO_VI,\n\t\tIL_TX_FIFO_BE,\n\t\tIL_TX_FIFO_BK,\n\t};\n\n\tif (likely(tid < ARRAY_SIZE(tid_to_ac)))\n\t\treturn ac_to_fifo[tid_to_ac[tid]];\n\n\t/* no support for TIDs 8-15 yet */\n\treturn -EINVAL;\n}\n\n/*\n * handle build C_TX command notification.\n */\nstatic void\nil4965_tx_cmd_build_basic(struct il_priv *il, struct sk_buff *skb,\n\t\t\t  struct il_tx_cmd *tx_cmd,\n\t\t\t  struct ieee80211_tx_info *info,\n\t\t\t  struct ieee80211_hdr *hdr, u8 std_id)\n{\n\t__le16 fc = hdr->frame_control;\n\t__le32 tx_flags = tx_cmd->tx_flags;\n\n\ttx_cmd->stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\n\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK)) {\n\t\ttx_flags |= TX_CMD_FLG_ACK_MSK;\n\t\tif (ieee80211_is_mgmt(fc))\n\t\t\ttx_flags |= TX_CMD_FLG_SEQ_CTL_MSK;\n\t\tif (ieee80211_is_probe_resp(fc) &&\n\t\t    !(le16_to_cpu(hdr->seq_ctrl) & 0xf))\n\t\t\ttx_flags |= TX_CMD_FLG_TSF_MSK;\n\t} else {\n\t\ttx_flags &= (~TX_CMD_FLG_ACK_MSK);\n\t\ttx_flags |= TX_CMD_FLG_SEQ_CTL_MSK;\n\t}\n\n\tif (ieee80211_is_back_req(fc))\n\t\ttx_flags |= TX_CMD_FLG_ACK_MSK | TX_CMD_FLG_IMM_BA_RSP_MASK;\n\n\ttx_cmd->sta_id = std_id;\n\tif (ieee80211_has_morefrags(fc))\n\t\ttx_flags |= TX_CMD_FLG_MORE_FRAG_MSK;\n\n\tif (ieee80211_is_data_qos(fc)) {\n\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\t\ttx_cmd->tid_tspec = qc[0] & 0xf;\n\t\ttx_flags &= ~TX_CMD_FLG_SEQ_CTL_MSK;\n\t} else {\n\t\ttx_flags |= TX_CMD_FLG_SEQ_CTL_MSK;\n\t}\n\n\til_tx_cmd_protection(il, info, fc, &tx_flags);\n\n\ttx_flags &= ~(TX_CMD_FLG_ANT_SEL_MSK);\n\tif (ieee80211_is_mgmt(fc)) {\n\t\tif (ieee80211_is_assoc_req(fc) || ieee80211_is_reassoc_req(fc))\n\t\t\ttx_cmd->timeout.pm_frame_timeout = cpu_to_le16(3);\n\t\telse\n\t\t\ttx_cmd->timeout.pm_frame_timeout = cpu_to_le16(2);\n\t} else {\n\t\ttx_cmd->timeout.pm_frame_timeout = 0;\n\t}\n\n\ttx_cmd->driver_txop = 0;\n\ttx_cmd->tx_flags = tx_flags;\n\ttx_cmd->next_frame_len = 0;\n}\n\nstatic void\nil4965_tx_cmd_build_rate(struct il_priv *il,\n\t\t\t struct il_tx_cmd *tx_cmd,\n\t\t\t struct ieee80211_tx_info *info,\n\t\t\t struct ieee80211_sta *sta,\n\t\t\t __le16 fc)\n{\n\tconst u8 rts_retry_limit = 60;\n\tu32 rate_flags;\n\tint rate_idx;\n\tu8 data_retry_limit;\n\tu8 rate_plcp;\n\n\t/* Set retry limit on DATA packets and Probe Responses */\n\tif (ieee80211_is_probe_resp(fc))\n\t\tdata_retry_limit = 3;\n\telse\n\t\tdata_retry_limit = IL4965_DEFAULT_TX_RETRY;\n\ttx_cmd->data_retry_limit = data_retry_limit;\n\t/* Set retry limit on RTS packets */\n\ttx_cmd->rts_retry_limit = min(data_retry_limit, rts_retry_limit);\n\n\t/* DATA packets will use the uCode station table for rate/antenna\n\t * selection */\n\tif (ieee80211_is_data(fc)) {\n\t\ttx_cmd->initial_rate_idx = 0;\n\t\ttx_cmd->tx_flags |= TX_CMD_FLG_STA_RATE_MSK;\n\t\treturn;\n\t}\n\n\t/**\n\t * If the current TX rate stored in mac80211 has the MCS bit set, it's\n\t * not really a TX rate.  Thus, we use the lowest supported rate for\n\t * this band.  Also use the lowest supported rate if the stored rate\n\t * idx is invalid.\n\t */\n\trate_idx = info->control.rates[0].idx;\n\tif ((info->control.rates[0].flags & IEEE80211_TX_RC_MCS) || rate_idx < 0\n\t    || rate_idx > RATE_COUNT_LEGACY)\n\t\trate_idx = rate_lowest_index(&il->bands[info->band], sta);\n\t/* For 5 GHZ band, remap mac80211 rate indices into driver indices */\n\tif (info->band == NL80211_BAND_5GHZ)\n\t\trate_idx += IL_FIRST_OFDM_RATE;\n\t/* Get PLCP rate for tx_cmd->rate_n_flags */\n\trate_plcp = il_rates[rate_idx].plcp;\n\t/* Zero out flags for this packet */\n\trate_flags = 0;\n\n\t/* Set CCK flag as needed */\n\tif (rate_idx >= IL_FIRST_CCK_RATE && rate_idx <= IL_LAST_CCK_RATE)\n\t\trate_flags |= RATE_MCS_CCK_MSK;\n\n\t/* Set up antennas */\n\til4965_toggle_tx_ant(il, &il->mgmt_tx_ant, il->hw_params.valid_tx_ant);\n\trate_flags |= BIT(il->mgmt_tx_ant) << RATE_MCS_ANT_POS;\n\n\t/* Set the rate in the TX cmd */\n\ttx_cmd->rate_n_flags = cpu_to_le32(rate_plcp | rate_flags);\n}\n\nstatic void\nil4965_tx_cmd_build_hwcrypto(struct il_priv *il, struct ieee80211_tx_info *info,\n\t\t\t     struct il_tx_cmd *tx_cmd, struct sk_buff *skb_frag,\n\t\t\t     int sta_id)\n{\n\tstruct ieee80211_key_conf *keyconf = info->control.hw_key;\n\n\tswitch (keyconf->cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\ttx_cmd->sec_ctl = TX_CMD_SEC_CCM;\n\t\tmemcpy(tx_cmd->key, keyconf->key, keyconf->keylen);\n\t\tif (info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\t\ttx_cmd->tx_flags |= TX_CMD_FLG_AGG_CCMP_MSK;\n\t\tD_TX(\"tx_cmd with AES hwcrypto\\n\");\n\t\tbreak;\n\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\ttx_cmd->sec_ctl = TX_CMD_SEC_TKIP;\n\t\tieee80211_get_tkip_p2k(keyconf, skb_frag, tx_cmd->key);\n\t\tD_TX(\"tx_cmd with tkip hwcrypto\\n\");\n\t\tbreak;\n\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\ttx_cmd->sec_ctl |= TX_CMD_SEC_KEY128;\n\t\tfallthrough;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\ttx_cmd->sec_ctl |=\n\t\t    (TX_CMD_SEC_WEP | (keyconf->keyidx & TX_CMD_SEC_MSK) <<\n\t\t     TX_CMD_SEC_SHIFT);\n\n\t\tmemcpy(&tx_cmd->key[3], keyconf->key, keyconf->keylen);\n\n\t\tD_TX(\"Configuring packet for WEP encryption \" \"with key %d\\n\",\n\t\t     keyconf->keyidx);\n\t\tbreak;\n\n\tdefault:\n\t\tIL_ERR(\"Unknown encode cipher %x\\n\", keyconf->cipher);\n\t\tbreak;\n\t}\n}\n\n/*\n * start C_TX command process\n */\nint\nil4965_tx_skb(struct il_priv *il,\n\t      struct ieee80211_sta *sta,\n\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct il_station_priv *sta_priv = NULL;\n\tstruct il_tx_queue *txq;\n\tstruct il_queue *q;\n\tstruct il_device_cmd *out_cmd;\n\tstruct il_cmd_meta *out_meta;\n\tstruct il_tx_cmd *tx_cmd;\n\tint txq_id;\n\tdma_addr_t phys_addr;\n\tdma_addr_t txcmd_phys;\n\tdma_addr_t scratch_phys;\n\tu16 len, firstlen, secondlen;\n\tu16 seq_number = 0;\n\t__le16 fc;\n\tu8 hdr_len;\n\tu8 sta_id;\n\tu8 wait_write_ptr = 0;\n\tu8 tid = 0;\n\tu8 *qc = NULL;\n\tunsigned long flags;\n\tbool is_agg = false;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\tif (il_is_rfkill(il)) {\n\t\tD_DROP(\"Dropping - RF KILL\\n\");\n\t\tgoto drop_unlock;\n\t}\n\n\tfc = hdr->frame_control;\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tif (ieee80211_is_auth(fc))\n\t\tD_TX(\"Sending AUTH frame\\n\");\n\telse if (ieee80211_is_assoc_req(fc))\n\t\tD_TX(\"Sending ASSOC frame\\n\");\n\telse if (ieee80211_is_reassoc_req(fc))\n\t\tD_TX(\"Sending REASSOC frame\\n\");\n#endif\n\n\thdr_len = ieee80211_hdrlen(fc);\n\n\t/* For management frames use broadcast id to do not break aggregation */\n\tif (!ieee80211_is_data(fc))\n\t\tsta_id = il->hw_params.bcast_id;\n\telse {\n\t\t/* Find idx into station table for destination station */\n\t\tsta_id = il_sta_id_or_broadcast(il, sta);\n\n\t\tif (sta_id == IL_INVALID_STATION) {\n\t\t\tD_DROP(\"Dropping - INVALID STATION: %pM\\n\", hdr->addr1);\n\t\t\tgoto drop_unlock;\n\t\t}\n\t}\n\n\tD_TX(\"station Id %d\\n\", sta_id);\n\n\tif (sta)\n\t\tsta_priv = (void *)sta->drv_priv;\n\n\tif (sta_priv && sta_priv->asleep &&\n\t    (info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER)) {\n\t\t/*\n\t\t * This sends an asynchronous command to the device,\n\t\t * but we can rely on it being processed before the\n\t\t * next frame is processed -- and the next frame to\n\t\t * this station is the one that will consume this\n\t\t * counter.\n\t\t * For now set the counter to just 1 since we do not\n\t\t * support uAPSD yet.\n\t\t */\n\t\til4965_sta_modify_sleep_tx_count(il, sta_id, 1);\n\t}\n\n\t/* FIXME: remove me ? */\n\tWARN_ON_ONCE(info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM);\n\n\t/* Access category (AC) is also the queue number */\n\ttxq_id = skb_get_queue_mapping(skb);\n\n\t/* irqs already disabled/saved above when locking il->lock */\n\tspin_lock(&il->sta_lock);\n\n\tif (ieee80211_is_data_qos(fc)) {\n\t\tqc = ieee80211_get_qos_ctl(hdr);\n\t\ttid = qc[0] & IEEE80211_QOS_CTL_TID_MASK;\n\t\tif (WARN_ON_ONCE(tid >= MAX_TID_COUNT)) {\n\t\t\tspin_unlock(&il->sta_lock);\n\t\t\tgoto drop_unlock;\n\t\t}\n\t\tseq_number = il->stations[sta_id].tid[tid].seq_number;\n\t\tseq_number &= IEEE80211_SCTL_SEQ;\n\t\thdr->seq_ctrl =\n\t\t    hdr->seq_ctrl & cpu_to_le16(IEEE80211_SCTL_FRAG);\n\t\thdr->seq_ctrl |= cpu_to_le16(seq_number);\n\t\tseq_number += 0x10;\n\t\t/* aggregation is on for this <sta,tid> */\n\t\tif (info->flags & IEEE80211_TX_CTL_AMPDU &&\n\t\t    il->stations[sta_id].tid[tid].agg.state == IL_AGG_ON) {\n\t\t\ttxq_id = il->stations[sta_id].tid[tid].agg.txq_id;\n\t\t\tis_agg = true;\n\t\t}\n\t}\n\n\ttxq = &il->txq[txq_id];\n\tq = &txq->q;\n\n\tif (unlikely(il_queue_space(q) < q->high_mark)) {\n\t\tspin_unlock(&il->sta_lock);\n\t\tgoto drop_unlock;\n\t}\n\n\tif (ieee80211_is_data_qos(fc)) {\n\t\til->stations[sta_id].tid[tid].tfds_in_queue++;\n\t\tif (!ieee80211_has_morefrags(fc))\n\t\t\til->stations[sta_id].tid[tid].seq_number = seq_number;\n\t}\n\n\tspin_unlock(&il->sta_lock);\n\n\ttxq->skbs[q->write_ptr] = skb;\n\n\t/* Set up first empty entry in queue's array of Tx/cmd buffers */\n\tout_cmd = txq->cmd[q->write_ptr];\n\tout_meta = &txq->meta[q->write_ptr];\n\ttx_cmd = &out_cmd->cmd.tx;\n\tmemset(&out_cmd->hdr, 0, sizeof(out_cmd->hdr));\n\tmemset(tx_cmd, 0, sizeof(struct il_tx_cmd));\n\n\t/*\n\t * Set up the Tx-command (not MAC!) header.\n\t * Store the chosen Tx queue and TFD idx within the sequence field;\n\t * after Tx, uCode's Tx response will return this value so driver can\n\t * locate the frame within the tx queue and do post-tx processing.\n\t */\n\tout_cmd->hdr.cmd = C_TX;\n\tout_cmd->hdr.sequence =\n\t    cpu_to_le16((u16)\n\t\t\t(QUEUE_TO_SEQ(txq_id) | IDX_TO_SEQ(q->write_ptr)));\n\n\t/* Copy MAC header from skb into command buffer */\n\tmemcpy(tx_cmd->hdr, hdr, hdr_len);\n\n\t/* Total # bytes to be transmitted */\n\ttx_cmd->len = cpu_to_le16((u16) skb->len);\n\n\tif (info->control.hw_key)\n\t\til4965_tx_cmd_build_hwcrypto(il, info, tx_cmd, skb, sta_id);\n\n\t/* TODO need this for burst mode later on */\n\til4965_tx_cmd_build_basic(il, skb, tx_cmd, info, hdr, sta_id);\n\n\til4965_tx_cmd_build_rate(il, tx_cmd, info, sta, fc);\n\n\t/*\n\t * Use the first empty entry in this queue's command buffer array\n\t * to contain the Tx command and MAC header concatenated together\n\t * (payload data will be in another buffer).\n\t * Size of this varies, due to varying MAC header length.\n\t * If end is not dword aligned, we'll have 2 extra bytes at the end\n\t * of the MAC header (device reads on dword boundaries).\n\t * We'll tell device about this padding later.\n\t */\n\tlen = sizeof(struct il_tx_cmd) + sizeof(struct il_cmd_header) + hdr_len;\n\tfirstlen = (len + 3) & ~3;\n\n\t/* Tell NIC about any 2-byte padding after MAC header */\n\tif (firstlen != len)\n\t\ttx_cmd->tx_flags |= TX_CMD_FLG_MH_PAD_MSK;\n\n\t/* Physical address of this Tx command's header (not MAC header!),\n\t * within command buffer array. */\n\ttxcmd_phys =\n\t    pci_map_single(il->pci_dev, &out_cmd->hdr, firstlen,\n\t\t\t   PCI_DMA_BIDIRECTIONAL);\n\tif (unlikely(pci_dma_mapping_error(il->pci_dev, txcmd_phys)))\n\t\tgoto drop_unlock;\n\n\t/* Set up TFD's 2nd entry to point directly to remainder of skb,\n\t * if any (802.11 null frames have no payload). */\n\tsecondlen = skb->len - hdr_len;\n\tif (secondlen > 0) {\n\t\tphys_addr =\n\t\t    pci_map_single(il->pci_dev, skb->data + hdr_len, secondlen,\n\t\t\t\t   PCI_DMA_TODEVICE);\n\t\tif (unlikely(pci_dma_mapping_error(il->pci_dev, phys_addr)))\n\t\t\tgoto drop_unlock;\n\t}\n\n\t/* Add buffer containing Tx command and MAC(!) header to TFD's\n\t * first entry */\n\til->ops->txq_attach_buf_to_tfd(il, txq, txcmd_phys, firstlen, 1, 0);\n\tdma_unmap_addr_set(out_meta, mapping, txcmd_phys);\n\tdma_unmap_len_set(out_meta, len, firstlen);\n\tif (secondlen)\n\t\til->ops->txq_attach_buf_to_tfd(il, txq, phys_addr, secondlen,\n\t\t\t\t\t       0, 0);\n\n\tif (!ieee80211_has_morefrags(hdr->frame_control)) {\n\t\ttxq->need_update = 1;\n\t} else {\n\t\twait_write_ptr = 1;\n\t\ttxq->need_update = 0;\n\t}\n\n\tscratch_phys =\n\t    txcmd_phys + sizeof(struct il_cmd_header) +\n\t    offsetof(struct il_tx_cmd, scratch);\n\n\t/* take back ownership of DMA buffer to enable update */\n\tpci_dma_sync_single_for_cpu(il->pci_dev, txcmd_phys, firstlen,\n\t\t\t\t    PCI_DMA_BIDIRECTIONAL);\n\ttx_cmd->dram_lsb_ptr = cpu_to_le32(scratch_phys);\n\ttx_cmd->dram_msb_ptr = il_get_dma_hi_addr(scratch_phys);\n\n\til_update_stats(il, true, fc, skb->len);\n\n\tD_TX(\"sequence nr = 0X%x\\n\", le16_to_cpu(out_cmd->hdr.sequence));\n\tD_TX(\"tx_flags = 0X%x\\n\", le32_to_cpu(tx_cmd->tx_flags));\n\til_print_hex_dump(il, IL_DL_TX, (u8 *) tx_cmd, sizeof(*tx_cmd));\n\til_print_hex_dump(il, IL_DL_TX, (u8 *) tx_cmd->hdr, hdr_len);\n\n\t/* Set up entry for this TFD in Tx byte-count array */\n\tif (info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\til->ops->txq_update_byte_cnt_tbl(il, txq, le16_to_cpu(tx_cmd->len));\n\n\tpci_dma_sync_single_for_device(il->pci_dev, txcmd_phys, firstlen,\n\t\t\t\t       PCI_DMA_BIDIRECTIONAL);\n\n\t/* Tell device the write idx *just past* this latest filled TFD */\n\tq->write_ptr = il_queue_inc_wrap(q->write_ptr, q->n_bd);\n\til_txq_update_write_ptr(il, txq);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\t/*\n\t * At this point the frame is \"transmitted\" successfully\n\t * and we will get a TX status notification eventually,\n\t * regardless of the value of ret. \"ret\" only indicates\n\t * whether or not we should update the write pointer.\n\t */\n\n\t/*\n\t * Avoid atomic ops if it isn't an associated client.\n\t * Also, if this is a packet for aggregation, don't\n\t * increase the counter because the ucode will stop\n\t * aggregation queues when their respective station\n\t * goes to sleep.\n\t */\n\tif (sta_priv && sta_priv->client && !is_agg)\n\t\tatomic_inc(&sta_priv->pending_frames);\n\n\tif (il_queue_space(q) < q->high_mark && il->mac80211_registered) {\n\t\tif (wait_write_ptr) {\n\t\t\tspin_lock_irqsave(&il->lock, flags);\n\t\t\ttxq->need_update = 1;\n\t\t\til_txq_update_write_ptr(il, txq);\n\t\t\tspin_unlock_irqrestore(&il->lock, flags);\n\t\t} else {\n\t\t\til_stop_queue(il, txq);\n\t\t}\n\t}\n\n\treturn 0;\n\ndrop_unlock:\n\tspin_unlock_irqrestore(&il->lock, flags);\n\treturn -1;\n}\n\nstatic inline int\nil4965_alloc_dma_ptr(struct il_priv *il, struct il_dma_ptr *ptr, size_t size)\n{\n\tptr->addr = dma_alloc_coherent(&il->pci_dev->dev, size, &ptr->dma,\n\t\t\t\t       GFP_KERNEL);\n\tif (!ptr->addr)\n\t\treturn -ENOMEM;\n\tptr->size = size;\n\treturn 0;\n}\n\nstatic inline void\nil4965_free_dma_ptr(struct il_priv *il, struct il_dma_ptr *ptr)\n{\n\tif (unlikely(!ptr->addr))\n\t\treturn;\n\n\tdma_free_coherent(&il->pci_dev->dev, ptr->size, ptr->addr, ptr->dma);\n\tmemset(ptr, 0, sizeof(*ptr));\n}\n\n/*\n * il4965_hw_txq_ctx_free - Free TXQ Context\n *\n * Destroy all TX DMA queues and structures\n */\nvoid\nil4965_hw_txq_ctx_free(struct il_priv *il)\n{\n\tint txq_id;\n\n\t/* Tx queues */\n\tif (il->txq) {\n\t\tfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++)\n\t\t\tif (txq_id == il->cmd_queue)\n\t\t\t\til_cmd_queue_free(il);\n\t\t\telse\n\t\t\t\til_tx_queue_free(il, txq_id);\n\t}\n\til4965_free_dma_ptr(il, &il->kw);\n\n\til4965_free_dma_ptr(il, &il->scd_bc_tbls);\n\n\t/* free tx queue structure */\n\til_free_txq_mem(il);\n}\n\n/*\n * il4965_txq_ctx_alloc - allocate TX queue context\n * Allocate all Tx DMA structures and initialize them\n */\nint\nil4965_txq_ctx_alloc(struct il_priv *il)\n{\n\tint ret, txq_id;\n\tunsigned long flags;\n\n\t/* Free all tx/cmd queues and keep-warm buffer */\n\til4965_hw_txq_ctx_free(il);\n\n\tret =\n\t    il4965_alloc_dma_ptr(il, &il->scd_bc_tbls,\n\t\t\t\t il->hw_params.scd_bc_tbls_size);\n\tif (ret) {\n\t\tIL_ERR(\"Scheduler BC Table allocation failed\\n\");\n\t\tgoto error_bc_tbls;\n\t}\n\t/* Alloc keep-warm buffer */\n\tret = il4965_alloc_dma_ptr(il, &il->kw, IL_KW_SIZE);\n\tif (ret) {\n\t\tIL_ERR(\"Keep Warm allocation failed\\n\");\n\t\tgoto error_kw;\n\t}\n\n\t/* allocate tx queue structure */\n\tret = il_alloc_txq_mem(il);\n\tif (ret)\n\t\tgoto error;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\t/* Turn off all Tx DMA fifos */\n\til4965_txq_set_sched(il, 0);\n\n\t/* Tell NIC where to find the \"keep warm\" buffer */\n\til_wr(il, FH49_KW_MEM_ADDR_REG, il->kw.dma >> 4);\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\t/* Alloc and init all Tx queues, including the command queue (#4/#9) */\n\tfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++) {\n\t\tret = il_tx_queue_init(il, txq_id);\n\t\tif (ret) {\n\t\t\tIL_ERR(\"Tx %d queue init failed\\n\", txq_id);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn ret;\n\nerror:\n\til4965_hw_txq_ctx_free(il);\n\til4965_free_dma_ptr(il, &il->kw);\nerror_kw:\n\til4965_free_dma_ptr(il, &il->scd_bc_tbls);\nerror_bc_tbls:\n\treturn ret;\n}\n\nvoid\nil4965_txq_ctx_reset(struct il_priv *il)\n{\n\tint txq_id;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\t/* Turn off all Tx DMA fifos */\n\til4965_txq_set_sched(il, 0);\n\t/* Tell NIC where to find the \"keep warm\" buffer */\n\til_wr(il, FH49_KW_MEM_ADDR_REG, il->kw.dma >> 4);\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\t/* Alloc and init all Tx queues, including the command queue (#4) */\n\tfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++)\n\t\til_tx_queue_reset(il, txq_id);\n}\n\nstatic void\nil4965_txq_ctx_unmap(struct il_priv *il)\n{\n\tint txq_id;\n\n\tif (!il->txq)\n\t\treturn;\n\n\t/* Unmap DMA from host system and free skb's */\n\tfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++)\n\t\tif (txq_id == il->cmd_queue)\n\t\t\til_cmd_queue_unmap(il);\n\t\telse\n\t\t\til_tx_queue_unmap(il, txq_id);\n}\n\n/*\n * il4965_txq_ctx_stop - Stop all Tx DMA channels\n */\nvoid\nil4965_txq_ctx_stop(struct il_priv *il)\n{\n\tint ch, ret;\n\n\t_il_wr_prph(il, IL49_SCD_TXFACT, 0);\n\n\t/* Stop each Tx DMA channel, and wait for it to be idle */\n\tfor (ch = 0; ch < il->hw_params.dma_chnl_num; ch++) {\n\t\t_il_wr(il, FH49_TCSR_CHNL_TX_CONFIG_REG(ch), 0x0);\n\t\tret =\n\t\t    _il_poll_bit(il, FH49_TSSR_TX_STATUS_REG,\n\t\t\t\t FH49_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE(ch),\n\t\t\t\t FH49_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE(ch),\n\t\t\t\t 1000);\n\t\tif (ret < 0)\n\t\t\tIL_ERR(\"Timeout stopping DMA channel %d [0x%08x]\",\n\t\t\t       ch, _il_rd(il, FH49_TSSR_TX_STATUS_REG));\n\t}\n}\n\n/*\n * Find first available (lowest unused) Tx Queue, mark it \"active\".\n * Called only when finding queue for aggregation.\n * Should never return anything < 7, because they should already\n * be in use as EDCA AC (0-3), Command (4), reserved (5, 6)\n */\nstatic int\nil4965_txq_ctx_activate_free(struct il_priv *il)\n{\n\tint txq_id;\n\n\tfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++)\n\t\tif (!test_and_set_bit(txq_id, &il->txq_ctx_active_msk))\n\t\t\treturn txq_id;\n\treturn -1;\n}\n\n/*\n * il4965_tx_queue_stop_scheduler - Stop queue, but keep configuration\n */\nstatic void\nil4965_tx_queue_stop_scheduler(struct il_priv *il, u16 txq_id)\n{\n\t/* Simply stop the queue, but don't change any configuration;\n\t * the SCD_ACT_EN bit is the write-enable mask for the ACTIVE bit. */\n\til_wr_prph(il, IL49_SCD_QUEUE_STATUS_BITS(txq_id),\n\t\t   (0 << IL49_SCD_QUEUE_STTS_REG_POS_ACTIVE) |\n\t\t   (1 << IL49_SCD_QUEUE_STTS_REG_POS_SCD_ACT_EN));\n}\n\n/*\n * il4965_tx_queue_set_q2ratid - Map unique receiver/tid combination to a queue\n */\nstatic int\nil4965_tx_queue_set_q2ratid(struct il_priv *il, u16 ra_tid, u16 txq_id)\n{\n\tu32 tbl_dw_addr;\n\tu32 tbl_dw;\n\tu16 scd_q2ratid;\n\n\tscd_q2ratid = ra_tid & IL_SCD_QUEUE_RA_TID_MAP_RATID_MSK;\n\n\ttbl_dw_addr =\n\t    il->scd_base_addr + IL49_SCD_TRANSLATE_TBL_OFFSET_QUEUE(txq_id);\n\n\ttbl_dw = il_read_targ_mem(il, tbl_dw_addr);\n\n\tif (txq_id & 0x1)\n\t\ttbl_dw = (scd_q2ratid << 16) | (tbl_dw & 0x0000FFFF);\n\telse\n\t\ttbl_dw = scd_q2ratid | (tbl_dw & 0xFFFF0000);\n\n\til_write_targ_mem(il, tbl_dw_addr, tbl_dw);\n\n\treturn 0;\n}\n\n/*\n * il4965_tx_queue_agg_enable - Set up & enable aggregation for selected queue\n *\n * NOTE:  txq_id must be greater than IL49_FIRST_AMPDU_QUEUE,\n *        i.e. it must be one of the higher queues used for aggregation\n */\nstatic int\nil4965_txq_agg_enable(struct il_priv *il, int txq_id, int tx_fifo, int sta_id,\n\t\t      int tid, u16 ssn_idx)\n{\n\tunsigned long flags;\n\tu16 ra_tid;\n\tint ret;\n\n\tif ((IL49_FIRST_AMPDU_QUEUE > txq_id) ||\n\t    (IL49_FIRST_AMPDU_QUEUE +\n\t     il->cfg->num_of_ampdu_queues <= txq_id)) {\n\t\tIL_WARN(\"queue number out of range: %d, must be %d to %d\\n\",\n\t\t\ttxq_id, IL49_FIRST_AMPDU_QUEUE,\n\t\t\tIL49_FIRST_AMPDU_QUEUE +\n\t\t\til->cfg->num_of_ampdu_queues - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tra_tid = BUILD_RAxTID(sta_id, tid);\n\n\t/* Modify device's station table to Tx this TID */\n\tret = il4965_sta_tx_modify_enable_tid(il, sta_id, tid);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\t/* Stop this Tx queue before configuring it */\n\til4965_tx_queue_stop_scheduler(il, txq_id);\n\n\t/* Map receiver-address / traffic-ID to this queue */\n\til4965_tx_queue_set_q2ratid(il, ra_tid, txq_id);\n\n\t/* Set this queue as a chain-building queue */\n\til_set_bits_prph(il, IL49_SCD_QUEUECHAIN_SEL, (1 << txq_id));\n\n\t/* Place first TFD at idx corresponding to start sequence number.\n\t * Assumes that ssn_idx is valid (!= 0xFFF) */\n\til->txq[txq_id].q.read_ptr = (ssn_idx & 0xff);\n\til->txq[txq_id].q.write_ptr = (ssn_idx & 0xff);\n\til4965_set_wr_ptrs(il, txq_id, ssn_idx);\n\n\t/* Set up Tx win size and frame limit for this queue */\n\til_write_targ_mem(il,\n\t\t\t  il->scd_base_addr +\n\t\t\t  IL49_SCD_CONTEXT_QUEUE_OFFSET(txq_id),\n\t\t\t  (SCD_WIN_SIZE << IL49_SCD_QUEUE_CTX_REG1_WIN_SIZE_POS)\n\t\t\t  & IL49_SCD_QUEUE_CTX_REG1_WIN_SIZE_MSK);\n\n\til_write_targ_mem(il,\n\t\t\t  il->scd_base_addr +\n\t\t\t  IL49_SCD_CONTEXT_QUEUE_OFFSET(txq_id) + sizeof(u32),\n\t\t\t  (SCD_FRAME_LIMIT <<\n\t\t\t   IL49_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_POS) &\n\t\t\t  IL49_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_MSK);\n\n\til_set_bits_prph(il, IL49_SCD_INTERRUPT_MASK, (1 << txq_id));\n\n\t/* Set up Status area in SRAM, map to Tx DMA/FIFO, activate the queue */\n\til4965_tx_queue_set_status(il, &il->txq[txq_id], tx_fifo, 1);\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\treturn 0;\n}\n\nint\nil4965_tx_agg_start(struct il_priv *il, struct ieee80211_vif *vif,\n\t\t    struct ieee80211_sta *sta, u16 tid, u16 * ssn)\n{\n\tint sta_id;\n\tint tx_fifo;\n\tint txq_id;\n\tint ret;\n\tunsigned long flags;\n\tstruct il_tid_data *tid_data;\n\n\t/* FIXME: warning if tx fifo not found ? */\n\ttx_fifo = il4965_get_fifo_from_tid(tid);\n\tif (unlikely(tx_fifo < 0))\n\t\treturn tx_fifo;\n\n\tD_HT(\"%s on ra = %pM tid = %d\\n\", __func__, sta->addr, tid);\n\n\tsta_id = il_sta_id(sta);\n\tif (sta_id == IL_INVALID_STATION) {\n\t\tIL_ERR(\"Start AGG on invalid station\\n\");\n\t\treturn -ENXIO;\n\t}\n\tif (unlikely(tid >= MAX_TID_COUNT))\n\t\treturn -EINVAL;\n\n\tif (il->stations[sta_id].tid[tid].agg.state != IL_AGG_OFF) {\n\t\tIL_ERR(\"Start AGG when state is not IL_AGG_OFF !\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\ttxq_id = il4965_txq_ctx_activate_free(il);\n\tif (txq_id == -1) {\n\t\tIL_ERR(\"No free aggregation queue available\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\ttid_data = &il->stations[sta_id].tid[tid];\n\t*ssn = IEEE80211_SEQ_TO_SN(tid_data->seq_number);\n\ttid_data->agg.txq_id = txq_id;\n\til_set_swq_id(&il->txq[txq_id], il4965_get_ac_from_tid(tid), txq_id);\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\tret = il4965_txq_agg_enable(il, txq_id, tx_fifo, sta_id, tid, *ssn);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\ttid_data = &il->stations[sta_id].tid[tid];\n\tif (tid_data->tfds_in_queue == 0) {\n\t\tD_HT(\"HW queue is empty\\n\");\n\t\ttid_data->agg.state = IL_AGG_ON;\n\t\tret = IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\t} else {\n\t\tD_HT(\"HW queue is NOT empty: %d packets in HW queue\\n\",\n\t\t     tid_data->tfds_in_queue);\n\t\ttid_data->agg.state = IL_EMPTYING_HW_QUEUE_ADDBA;\n\t}\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\treturn ret;\n}\n\n/*\n * txq_id must be greater than IL49_FIRST_AMPDU_QUEUE\n * il->lock must be held by the caller\n */\nstatic int\nil4965_txq_agg_disable(struct il_priv *il, u16 txq_id, u16 ssn_idx, u8 tx_fifo)\n{\n\tif ((IL49_FIRST_AMPDU_QUEUE > txq_id) ||\n\t    (IL49_FIRST_AMPDU_QUEUE +\n\t     il->cfg->num_of_ampdu_queues <= txq_id)) {\n\t\tIL_WARN(\"queue number out of range: %d, must be %d to %d\\n\",\n\t\t\ttxq_id, IL49_FIRST_AMPDU_QUEUE,\n\t\t\tIL49_FIRST_AMPDU_QUEUE +\n\t\t\til->cfg->num_of_ampdu_queues - 1);\n\t\treturn -EINVAL;\n\t}\n\n\til4965_tx_queue_stop_scheduler(il, txq_id);\n\n\til_clear_bits_prph(il, IL49_SCD_QUEUECHAIN_SEL, (1 << txq_id));\n\n\til->txq[txq_id].q.read_ptr = (ssn_idx & 0xff);\n\til->txq[txq_id].q.write_ptr = (ssn_idx & 0xff);\n\t/* supposes that ssn_idx is valid (!= 0xFFF) */\n\til4965_set_wr_ptrs(il, txq_id, ssn_idx);\n\n\til_clear_bits_prph(il, IL49_SCD_INTERRUPT_MASK, (1 << txq_id));\n\til_txq_ctx_deactivate(il, txq_id);\n\til4965_tx_queue_set_status(il, &il->txq[txq_id], tx_fifo, 0);\n\n\treturn 0;\n}\n\nint\nil4965_tx_agg_stop(struct il_priv *il, struct ieee80211_vif *vif,\n\t\t   struct ieee80211_sta *sta, u16 tid)\n{\n\tint tx_fifo_id, txq_id, sta_id, ssn;\n\tstruct il_tid_data *tid_data;\n\tint write_ptr, read_ptr;\n\tunsigned long flags;\n\n\t/* FIXME: warning if tx_fifo_id not found ? */\n\ttx_fifo_id = il4965_get_fifo_from_tid(tid);\n\tif (unlikely(tx_fifo_id < 0))\n\t\treturn tx_fifo_id;\n\n\tsta_id = il_sta_id(sta);\n\n\tif (sta_id == IL_INVALID_STATION) {\n\t\tIL_ERR(\"Invalid station for AGG tid %d\\n\", tid);\n\t\treturn -ENXIO;\n\t}\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\n\ttid_data = &il->stations[sta_id].tid[tid];\n\tssn = (tid_data->seq_number & IEEE80211_SCTL_SEQ) >> 4;\n\ttxq_id = tid_data->agg.txq_id;\n\n\tswitch (il->stations[sta_id].tid[tid].agg.state) {\n\tcase IL_EMPTYING_HW_QUEUE_ADDBA:\n\t\t/*\n\t\t * This can happen if the peer stops aggregation\n\t\t * again before we've had a chance to drain the\n\t\t * queue we selected previously, i.e. before the\n\t\t * session was really started completely.\n\t\t */\n\t\tD_HT(\"AGG stop before setup done\\n\");\n\t\tgoto turn_off;\n\tcase IL_AGG_ON:\n\t\tbreak;\n\tdefault:\n\t\tIL_WARN(\"Stopping AGG while state not ON or starting\\n\");\n\t}\n\n\twrite_ptr = il->txq[txq_id].q.write_ptr;\n\tread_ptr = il->txq[txq_id].q.read_ptr;\n\n\t/* The queue is not empty */\n\tif (write_ptr != read_ptr) {\n\t\tD_HT(\"Stopping a non empty AGG HW QUEUE\\n\");\n\t\til->stations[sta_id].tid[tid].agg.state =\n\t\t    IL_EMPTYING_HW_QUEUE_DELBA;\n\t\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\t\treturn 0;\n\t}\n\n\tD_HT(\"HW queue is empty\\n\");\nturn_off:\n\til->stations[sta_id].tid[tid].agg.state = IL_AGG_OFF;\n\n\t/* do not restore/save irqs */\n\tspin_unlock(&il->sta_lock);\n\tspin_lock(&il->lock);\n\n\t/*\n\t * the only reason this call can fail is queue number out of range,\n\t * which can happen if uCode is reloaded and all the station\n\t * information are lost. if it is outside the range, there is no need\n\t * to deactivate the uCode queue, just return \"success\" to allow\n\t *  mac80211 to clean up it own data.\n\t */\n\til4965_txq_agg_disable(il, txq_id, ssn, tx_fifo_id);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\n\treturn 0;\n}\n\nint\nil4965_txq_check_empty(struct il_priv *il, int sta_id, u8 tid, int txq_id)\n{\n\tstruct il_queue *q = &il->txq[txq_id].q;\n\tu8 *addr = il->stations[sta_id].sta.sta.addr;\n\tstruct il_tid_data *tid_data = &il->stations[sta_id].tid[tid];\n\n\tlockdep_assert_held(&il->sta_lock);\n\n\tswitch (il->stations[sta_id].tid[tid].agg.state) {\n\tcase IL_EMPTYING_HW_QUEUE_DELBA:\n\t\t/* We are reclaiming the last packet of the */\n\t\t/* aggregated HW queue */\n\t\tif (txq_id == tid_data->agg.txq_id &&\n\t\t    q->read_ptr == q->write_ptr) {\n\t\t\tu16 ssn = IEEE80211_SEQ_TO_SN(tid_data->seq_number);\n\t\t\tint tx_fifo = il4965_get_fifo_from_tid(tid);\n\t\t\tD_HT(\"HW queue empty: continue DELBA flow\\n\");\n\t\t\til4965_txq_agg_disable(il, txq_id, ssn, tx_fifo);\n\t\t\ttid_data->agg.state = IL_AGG_OFF;\n\t\t\tieee80211_stop_tx_ba_cb_irqsafe(il->vif, addr, tid);\n\t\t}\n\t\tbreak;\n\tcase IL_EMPTYING_HW_QUEUE_ADDBA:\n\t\t/* We are reclaiming the last packet of the queue */\n\t\tif (tid_data->tfds_in_queue == 0) {\n\t\t\tD_HT(\"HW queue empty: continue ADDBA flow\\n\");\n\t\t\ttid_data->agg.state = IL_AGG_ON;\n\t\t\tieee80211_start_tx_ba_cb_irqsafe(il->vif, addr, tid);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nil4965_non_agg_tx_status(struct il_priv *il, const u8 *addr1)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct il_station_priv *sta_priv;\n\n\trcu_read_lock();\n\tsta = ieee80211_find_sta(il->vif, addr1);\n\tif (sta) {\n\t\tsta_priv = (void *)sta->drv_priv;\n\t\t/* avoid atomic ops if this isn't a client */\n\t\tif (sta_priv->client &&\n\t\t    atomic_dec_return(&sta_priv->pending_frames) == 0)\n\t\t\tieee80211_sta_block_awake(il->hw, sta, false);\n\t}\n\trcu_read_unlock();\n}\n\nstatic void\nil4965_tx_status(struct il_priv *il, struct sk_buff *skb, bool is_agg)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\n\tif (!is_agg)\n\t\til4965_non_agg_tx_status(il, hdr->addr1);\n\n\tieee80211_tx_status_irqsafe(il->hw, skb);\n}\n\nint\nil4965_tx_queue_reclaim(struct il_priv *il, int txq_id, int idx)\n{\n\tstruct il_tx_queue *txq = &il->txq[txq_id];\n\tstruct il_queue *q = &txq->q;\n\tint nfreed = 0;\n\tstruct ieee80211_hdr *hdr;\n\tstruct sk_buff *skb;\n\n\tif (idx >= q->n_bd || il_queue_used(q, idx) == 0) {\n\t\tIL_ERR(\"Read idx for DMA queue txq id (%d), idx %d, \"\n\t\t       \"is out of range [0-%d] %d %d.\\n\", txq_id, idx, q->n_bd,\n\t\t       q->write_ptr, q->read_ptr);\n\t\treturn 0;\n\t}\n\n\tfor (idx = il_queue_inc_wrap(idx, q->n_bd); q->read_ptr != idx;\n\t     q->read_ptr = il_queue_inc_wrap(q->read_ptr, q->n_bd)) {\n\n\t\tskb = txq->skbs[txq->q.read_ptr];\n\n\t\tif (WARN_ON_ONCE(skb == NULL))\n\t\t\tcontinue;\n\n\t\thdr = (struct ieee80211_hdr *) skb->data;\n\t\tif (ieee80211_is_data_qos(hdr->frame_control))\n\t\t\tnfreed++;\n\n\t\til4965_tx_status(il, skb, txq_id >= IL4965_FIRST_AMPDU_QUEUE);\n\n\t\ttxq->skbs[txq->q.read_ptr] = NULL;\n\t\til->ops->txq_free_tfd(il, txq);\n\t}\n\treturn nfreed;\n}\n\n/*\n * il4965_tx_status_reply_compressed_ba - Update tx status from block-ack\n *\n * Go through block-ack's bitmap of ACK'd frames, update driver's record of\n * ACK vs. not.  This gets sent to mac80211, then to rate scaling algo.\n */\nstatic int\nil4965_tx_status_reply_compressed_ba(struct il_priv *il, struct il_ht_agg *agg,\n\t\t\t\t     struct il_compressed_ba_resp *ba_resp)\n{\n\tint i, sh, ack;\n\tu16 seq_ctl = le16_to_cpu(ba_resp->seq_ctl);\n\tu16 scd_flow = le16_to_cpu(ba_resp->scd_flow);\n\tint successes = 0;\n\tstruct ieee80211_tx_info *info;\n\tu64 bitmap, sent_bitmap;\n\n\tif (unlikely(!agg->wait_for_ba)) {\n\t\tif (unlikely(ba_resp->bitmap))\n\t\t\tIL_ERR(\"Received BA when not expected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Mark that the expected block-ack response arrived */\n\tagg->wait_for_ba = 0;\n\tD_TX_REPLY(\"BA %d %d\\n\", agg->start_idx, ba_resp->seq_ctl);\n\n\t/* Calculate shift to align block-ack bits with our Tx win bits */\n\tsh = agg->start_idx - SEQ_TO_IDX(seq_ctl >> 4);\n\tif (sh < 0)\t\t/* tbw something is wrong with indices */\n\t\tsh += 0x100;\n\n\tif (agg->frame_count > (64 - sh)) {\n\t\tD_TX_REPLY(\"more frames than bitmap size\");\n\t\treturn -1;\n\t}\n\n\t/* don't use 64-bit values for now */\n\tbitmap = le64_to_cpu(ba_resp->bitmap) >> sh;\n\n\t/* check for success or failure according to the\n\t * transmitted bitmap and block-ack bitmap */\n\tsent_bitmap = bitmap & agg->bitmap;\n\n\t/* For each frame attempted in aggregation,\n\t * update driver's record of tx frame's status. */\n\ti = 0;\n\twhile (sent_bitmap) {\n\t\tack = sent_bitmap & 1ULL;\n\t\tsuccesses += ack;\n\t\tD_TX_REPLY(\"%s ON i=%d idx=%d raw=%d\\n\", ack ? \"ACK\" : \"NACK\",\n\t\t\t   i, (agg->start_idx + i) & 0xff, agg->start_idx + i);\n\t\tsent_bitmap >>= 1;\n\t\t++i;\n\t}\n\n\tD_TX_REPLY(\"Bitmap %llx\\n\", (unsigned long long)bitmap);\n\n\tinfo = IEEE80211_SKB_CB(il->txq[scd_flow].skbs[agg->start_idx]);\n\tmemset(&info->status, 0, sizeof(info->status));\n\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\tinfo->flags |= IEEE80211_TX_STAT_AMPDU;\n\tinfo->status.ampdu_ack_len = successes;\n\tinfo->status.ampdu_len = agg->frame_count;\n\til4965_hwrate_to_tx_control(il, agg->rate_n_flags, info);\n\n\treturn 0;\n}\n\nstatic inline bool\nil4965_is_tx_success(u32 status)\n{\n\tstatus &= TX_STATUS_MSK;\n\treturn (status == TX_STATUS_SUCCESS || status == TX_STATUS_DIRECT_DONE);\n}\n\nstatic u8\nil4965_find_station(struct il_priv *il, const u8 *addr)\n{\n\tint i;\n\tint start = 0;\n\tint ret = IL_INVALID_STATION;\n\tunsigned long flags;\n\n\tif (il->iw_mode == NL80211_IFTYPE_ADHOC)\n\t\tstart = IL_STA_ID;\n\n\tif (is_broadcast_ether_addr(addr))\n\t\treturn il->hw_params.bcast_id;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\tfor (i = start; i < il->hw_params.max_stations; i++)\n\t\tif (il->stations[i].used &&\n\t\t    ether_addr_equal(il->stations[i].sta.sta.addr, addr)) {\n\t\t\tret = i;\n\t\t\tgoto out;\n\t\t}\n\n\tD_ASSOC(\"can not find STA %pM total %d\\n\", addr, il->num_stations);\n\nout:\n\t/*\n\t * It may be possible that more commands interacting with stations\n\t * arrive before we completed processing the adding of\n\t * station\n\t */\n\tif (ret != IL_INVALID_STATION &&\n\t    (!(il->stations[ret].used & IL_STA_UCODE_ACTIVE) ||\n\t     ((il->stations[ret].used & IL_STA_UCODE_ACTIVE) &&\n\t      (il->stations[ret].used & IL_STA_UCODE_INPROGRESS)))) {\n\t\tIL_ERR(\"Requested station info for sta %d before ready.\\n\",\n\t\t       ret);\n\t\tret = IL_INVALID_STATION;\n\t}\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\treturn ret;\n}\n\nstatic int\nil4965_get_ra_sta_id(struct il_priv *il, struct ieee80211_hdr *hdr)\n{\n\tif (il->iw_mode == NL80211_IFTYPE_STATION)\n\t\treturn IL_AP_ID;\n\telse {\n\t\tu8 *da = ieee80211_get_DA(hdr);\n\n\t\treturn il4965_find_station(il, da);\n\t}\n}\n\nstatic inline u32\nil4965_get_scd_ssn(struct il4965_tx_resp *tx_resp)\n{\n\treturn le32_to_cpup(&tx_resp->u.status +\n\t\t\t    tx_resp->frame_count) & IEEE80211_MAX_SN;\n}\n\nstatic inline u32\nil4965_tx_status_to_mac80211(u32 status)\n{\n\tstatus &= TX_STATUS_MSK;\n\n\tswitch (status) {\n\tcase TX_STATUS_SUCCESS:\n\tcase TX_STATUS_DIRECT_DONE:\n\t\treturn IEEE80211_TX_STAT_ACK;\n\tcase TX_STATUS_FAIL_DEST_PS:\n\t\treturn IEEE80211_TX_STAT_TX_FILTERED;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n/*\n * il4965_tx_status_reply_tx - Handle Tx response for frames in aggregation queue\n */\nstatic int\nil4965_tx_status_reply_tx(struct il_priv *il, struct il_ht_agg *agg,\n\t\t\t  struct il4965_tx_resp *tx_resp, int txq_id,\n\t\t\t  u16 start_idx)\n{\n\tu16 status;\n\tstruct agg_tx_status *frame_status = tx_resp->u.agg_status;\n\tstruct ieee80211_tx_info *info = NULL;\n\tstruct ieee80211_hdr *hdr = NULL;\n\tu32 rate_n_flags = le32_to_cpu(tx_resp->rate_n_flags);\n\tint i, sh, idx;\n\tu16 seq;\n\tif (agg->wait_for_ba)\n\t\tD_TX_REPLY(\"got tx response w/o block-ack\\n\");\n\n\tagg->frame_count = tx_resp->frame_count;\n\tagg->start_idx = start_idx;\n\tagg->rate_n_flags = rate_n_flags;\n\tagg->bitmap = 0;\n\n\t/* num frames attempted by Tx command */\n\tif (agg->frame_count == 1) {\n\t\t/* Only one frame was attempted; no block-ack will arrive */\n\t\tstatus = le16_to_cpu(frame_status[0].status);\n\t\tidx = start_idx;\n\n\t\tD_TX_REPLY(\"FrameCnt = %d, StartIdx=%d idx=%d\\n\",\n\t\t\t   agg->frame_count, agg->start_idx, idx);\n\n\t\tinfo = IEEE80211_SKB_CB(il->txq[txq_id].skbs[idx]);\n\t\tinfo->status.rates[0].count = tx_resp->failure_frame + 1;\n\t\tinfo->flags &= ~IEEE80211_TX_CTL_AMPDU;\n\t\tinfo->flags |= il4965_tx_status_to_mac80211(status);\n\t\til4965_hwrate_to_tx_control(il, rate_n_flags, info);\n\n\t\tD_TX_REPLY(\"1 Frame 0x%x failure :%d\\n\", status & 0xff,\n\t\t\t   tx_resp->failure_frame);\n\t\tD_TX_REPLY(\"Rate Info rate_n_flags=%x\\n\", rate_n_flags);\n\n\t\tagg->wait_for_ba = 0;\n\t} else {\n\t\t/* Two or more frames were attempted; expect block-ack */\n\t\tu64 bitmap = 0;\n\t\tint start = agg->start_idx;\n\t\tstruct sk_buff *skb;\n\n\t\t/* Construct bit-map of pending frames within Tx win */\n\t\tfor (i = 0; i < agg->frame_count; i++) {\n\t\t\tu16 sc;\n\t\t\tstatus = le16_to_cpu(frame_status[i].status);\n\t\t\tseq = le16_to_cpu(frame_status[i].sequence);\n\t\t\tidx = SEQ_TO_IDX(seq);\n\t\t\ttxq_id = SEQ_TO_QUEUE(seq);\n\n\t\t\tif (status &\n\t\t\t    (AGG_TX_STATE_FEW_BYTES_MSK |\n\t\t\t     AGG_TX_STATE_ABORT_MSK))\n\t\t\t\tcontinue;\n\n\t\t\tD_TX_REPLY(\"FrameCnt = %d, txq_id=%d idx=%d\\n\",\n\t\t\t\t   agg->frame_count, txq_id, idx);\n\n\t\t\tskb = il->txq[txq_id].skbs[idx];\n\t\t\tif (WARN_ON_ONCE(skb == NULL))\n\t\t\t\treturn -1;\n\t\t\thdr = (struct ieee80211_hdr *) skb->data;\n\n\t\t\tsc = le16_to_cpu(hdr->seq_ctrl);\n\t\t\tif (idx != (IEEE80211_SEQ_TO_SN(sc) & 0xff)) {\n\t\t\t\tIL_ERR(\"BUG_ON idx doesn't match seq control\"\n\t\t\t\t       \" idx=%d, seq_idx=%d, seq=%d\\n\", idx,\n\t\t\t\t       IEEE80211_SEQ_TO_SN(sc), hdr->seq_ctrl);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tD_TX_REPLY(\"AGG Frame i=%d idx %d seq=%d\\n\", i, idx,\n\t\t\t\t   IEEE80211_SEQ_TO_SN(sc));\n\n\t\t\tsh = idx - start;\n\t\t\tif (sh > 64) {\n\t\t\t\tsh = (start - idx) + 0xff;\n\t\t\t\tbitmap = bitmap << sh;\n\t\t\t\tsh = 0;\n\t\t\t\tstart = idx;\n\t\t\t} else if (sh < -64)\n\t\t\t\tsh = 0xff - (start - idx);\n\t\t\telse if (sh < 0) {\n\t\t\t\tsh = start - idx;\n\t\t\t\tstart = idx;\n\t\t\t\tbitmap = bitmap << sh;\n\t\t\t\tsh = 0;\n\t\t\t}\n\t\t\tbitmap |= 1ULL << sh;\n\t\t\tD_TX_REPLY(\"start=%d bitmap=0x%llx\\n\", start,\n\t\t\t\t   (unsigned long long)bitmap);\n\t\t}\n\n\t\tagg->bitmap = bitmap;\n\t\tagg->start_idx = start;\n\t\tD_TX_REPLY(\"Frames %d start_idx=%d bitmap=0x%llx\\n\",\n\t\t\t   agg->frame_count, agg->start_idx,\n\t\t\t   (unsigned long long)agg->bitmap);\n\n\t\tif (bitmap)\n\t\t\tagg->wait_for_ba = 1;\n\t}\n\treturn 0;\n}\n\n/*\n * il4965_hdl_tx - Handle standard (non-aggregation) Tx response\n */\nstatic void\nil4965_hdl_tx(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tu16 sequence = le16_to_cpu(pkt->hdr.sequence);\n\tint txq_id = SEQ_TO_QUEUE(sequence);\n\tint idx = SEQ_TO_IDX(sequence);\n\tstruct il_tx_queue *txq = &il->txq[txq_id];\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *info;\n\tstruct il4965_tx_resp *tx_resp = (void *)&pkt->u.raw[0];\n\tu32 status = le32_to_cpu(tx_resp->u.status);\n\tint tid;\n\tint sta_id;\n\tint freed;\n\tu8 *qc = NULL;\n\tunsigned long flags;\n\n\tif (idx >= txq->q.n_bd || il_queue_used(&txq->q, idx) == 0) {\n\t\tIL_ERR(\"Read idx for DMA queue txq_id (%d) idx %d \"\n\t\t       \"is out of range [0-%d] %d %d\\n\", txq_id, idx,\n\t\t       txq->q.n_bd, txq->q.write_ptr, txq->q.read_ptr);\n\t\treturn;\n\t}\n\n\ttxq->time_stamp = jiffies;\n\n\tskb = txq->skbs[txq->q.read_ptr];\n\tinfo = IEEE80211_SKB_CB(skb);\n\tmemset(&info->status, 0, sizeof(info->status));\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tqc = ieee80211_get_qos_ctl(hdr);\n\t\ttid = qc[0] & 0xf;\n\t}\n\n\tsta_id = il4965_get_ra_sta_id(il, hdr);\n\tif (txq->sched_retry && unlikely(sta_id == IL_INVALID_STATION)) {\n\t\tIL_ERR(\"Station not known\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Firmware will not transmit frame on passive channel, if it not yet\n\t * received some valid frame on that channel. When this error happen\n\t * we have to wait until firmware will unblock itself i.e. when we\n\t * note received beacon or other frame. We unblock queues in\n\t * il4965_pass_packet_to_mac80211 or in il_mac_bss_info_changed.\n\t */\n\tif (unlikely((status & TX_STATUS_MSK) == TX_STATUS_FAIL_PASSIVE_NO_RX) &&\n\t    il->iw_mode == NL80211_IFTYPE_STATION) {\n\t\til_stop_queues_by_reason(il, IL_STOP_REASON_PASSIVE);\n\t\tD_INFO(\"Stopped queues - RX waiting on passive channel\\n\");\n\t}\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\tif (txq->sched_retry) {\n\t\tconst u32 scd_ssn = il4965_get_scd_ssn(tx_resp);\n\t\tstruct il_ht_agg *agg;\n\n\t\tif (WARN_ON(!qc))\n\t\t\tgoto out;\n\n\t\tagg = &il->stations[sta_id].tid[tid].agg;\n\n\t\til4965_tx_status_reply_tx(il, agg, tx_resp, txq_id, idx);\n\n\t\t/* check if BAR is needed */\n\t\tif (tx_resp->frame_count == 1 &&\n\t\t    !il4965_is_tx_success(status))\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_AMPDU_NO_BACK;\n\n\t\tif (txq->q.read_ptr != (scd_ssn & 0xff)) {\n\t\t\tidx = il_queue_dec_wrap(scd_ssn & 0xff, txq->q.n_bd);\n\t\t\tD_TX_REPLY(\"Retry scheduler reclaim scd_ssn \"\n\t\t\t\t   \"%d idx %d\\n\", scd_ssn, idx);\n\t\t\tfreed = il4965_tx_queue_reclaim(il, txq_id, idx);\n\t\t\til4965_free_tfds_in_queue(il, sta_id, tid, freed);\n\n\t\t\tif (il->mac80211_registered &&\n\t\t\t    il_queue_space(&txq->q) > txq->q.low_mark &&\n\t\t\t    agg->state != IL_EMPTYING_HW_QUEUE_DELBA)\n\t\t\t\til_wake_queue(il, txq);\n\t\t}\n\t} else {\n\t\tinfo->status.rates[0].count = tx_resp->failure_frame + 1;\n\t\tinfo->flags |= il4965_tx_status_to_mac80211(status);\n\t\til4965_hwrate_to_tx_control(il,\n\t\t\t\t\t    le32_to_cpu(tx_resp->rate_n_flags),\n\t\t\t\t\t    info);\n\n\t\tD_TX_REPLY(\"TXQ %d status %s (0x%08x) \"\n\t\t\t   \"rate_n_flags 0x%x retries %d\\n\", txq_id,\n\t\t\t   il4965_get_tx_fail_reason(status), status,\n\t\t\t   le32_to_cpu(tx_resp->rate_n_flags),\n\t\t\t   tx_resp->failure_frame);\n\n\t\tfreed = il4965_tx_queue_reclaim(il, txq_id, idx);\n\t\tif (qc && likely(sta_id != IL_INVALID_STATION))\n\t\t\til4965_free_tfds_in_queue(il, sta_id, tid, freed);\n\t\telse if (sta_id == IL_INVALID_STATION)\n\t\t\tD_TX_REPLY(\"Station not known\\n\");\n\n\t\tif (il->mac80211_registered &&\n\t\t    il_queue_space(&txq->q) > txq->q.low_mark)\n\t\t\til_wake_queue(il, txq);\n\t}\nout:\n\tif (qc && likely(sta_id != IL_INVALID_STATION))\n\t\til4965_txq_check_empty(il, sta_id, tid, txq_id);\n\n\til4965_check_abort_status(il, tx_resp->frame_count, status);\n\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n}\n\n/*\n * translate ucode response to mac80211 tx status control values\n */\nvoid\nil4965_hwrate_to_tx_control(struct il_priv *il, u32 rate_n_flags,\n\t\t\t    struct ieee80211_tx_info *info)\n{\n\tstruct ieee80211_tx_rate *r = &info->status.rates[0];\n\n\tinfo->status.antenna =\n\t    ((rate_n_flags & RATE_MCS_ANT_ABC_MSK) >> RATE_MCS_ANT_POS);\n\tif (rate_n_flags & RATE_MCS_HT_MSK)\n\t\tr->flags |= IEEE80211_TX_RC_MCS;\n\tif (rate_n_flags & RATE_MCS_GF_MSK)\n\t\tr->flags |= IEEE80211_TX_RC_GREEN_FIELD;\n\tif (rate_n_flags & RATE_MCS_HT40_MSK)\n\t\tr->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\tif (rate_n_flags & RATE_MCS_DUP_MSK)\n\t\tr->flags |= IEEE80211_TX_RC_DUP_DATA;\n\tif (rate_n_flags & RATE_MCS_SGI_MSK)\n\t\tr->flags |= IEEE80211_TX_RC_SHORT_GI;\n\tr->idx = il4965_hwrate_to_mac80211_idx(rate_n_flags, info->band);\n}\n\n/*\n * il4965_hdl_compressed_ba - Handler for N_COMPRESSED_BA\n *\n * Handles block-acknowledge notification from device, which reports success\n * of frames sent via aggregation.\n */\nstatic void\nil4965_hdl_compressed_ba(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il_compressed_ba_resp *ba_resp = &pkt->u.compressed_ba;\n\tstruct il_tx_queue *txq = NULL;\n\tstruct il_ht_agg *agg;\n\tint idx;\n\tint sta_id;\n\tint tid;\n\tunsigned long flags;\n\n\t/* \"flow\" corresponds to Tx queue */\n\tu16 scd_flow = le16_to_cpu(ba_resp->scd_flow);\n\n\t/* \"ssn\" is start of block-ack Tx win, corresponds to idx\n\t * (in Tx queue's circular buffer) of first TFD/frame in win */\n\tu16 ba_resp_scd_ssn = le16_to_cpu(ba_resp->scd_ssn);\n\n\tif (scd_flow >= il->hw_params.max_txq_num) {\n\t\tIL_ERR(\"BUG_ON scd_flow is bigger than number of queues\\n\");\n\t\treturn;\n\t}\n\n\ttxq = &il->txq[scd_flow];\n\tsta_id = ba_resp->sta_id;\n\ttid = ba_resp->tid;\n\tagg = &il->stations[sta_id].tid[tid].agg;\n\tif (unlikely(agg->txq_id != scd_flow)) {\n\t\t/*\n\t\t * FIXME: this is a uCode bug which need to be addressed,\n\t\t * log the information and return for now!\n\t\t * since it is possible happen very often and in order\n\t\t * not to fill the syslog, don't enable the logging by default\n\t\t */\n\t\tD_TX_REPLY(\"BA scd_flow %d does not match txq_id %d\\n\",\n\t\t\t   scd_flow, agg->txq_id);\n\t\treturn;\n\t}\n\n\t/* Find idx just before block-ack win */\n\tidx = il_queue_dec_wrap(ba_resp_scd_ssn & 0xff, txq->q.n_bd);\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\n\tD_TX_REPLY(\"N_COMPRESSED_BA [%d] Received from %pM, \" \"sta_id = %d\\n\",\n\t\t   agg->wait_for_ba, (u8 *) &ba_resp->sta_addr_lo32,\n\t\t   ba_resp->sta_id);\n\tD_TX_REPLY(\"TID = %d, SeqCtl = %d, bitmap = 0x%llx,\" \"scd_flow = \"\n\t\t   \"%d, scd_ssn = %d\\n\", ba_resp->tid, ba_resp->seq_ctl,\n\t\t   (unsigned long long)le64_to_cpu(ba_resp->bitmap),\n\t\t   ba_resp->scd_flow, ba_resp->scd_ssn);\n\tD_TX_REPLY(\"DAT start_idx = %d, bitmap = 0x%llx\\n\", agg->start_idx,\n\t\t   (unsigned long long)agg->bitmap);\n\n\t/* Update driver's record of ACK vs. not for each frame in win */\n\til4965_tx_status_reply_compressed_ba(il, agg, ba_resp);\n\n\t/* Release all TFDs before the SSN, i.e. all TFDs in front of\n\t * block-ack win (we assume that they've been successfully\n\t * transmitted ... if not, it's too late anyway). */\n\tif (txq->q.read_ptr != (ba_resp_scd_ssn & 0xff)) {\n\t\t/* calculate mac80211 ampdu sw queue to wake */\n\t\tint freed = il4965_tx_queue_reclaim(il, scd_flow, idx);\n\t\til4965_free_tfds_in_queue(il, sta_id, tid, freed);\n\n\t\tif (il_queue_space(&txq->q) > txq->q.low_mark &&\n\t\t    il->mac80211_registered &&\n\t\t    agg->state != IL_EMPTYING_HW_QUEUE_DELBA)\n\t\t\til_wake_queue(il, txq);\n\n\t\til4965_txq_check_empty(il, sta_id, tid, scd_flow);\n\t}\n\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n}\n\n#ifdef CONFIG_IWLEGACY_DEBUG\nconst char *\nil4965_get_tx_fail_reason(u32 status)\n{\n#define TX_STATUS_FAIL(x) case TX_STATUS_FAIL_ ## x: return #x\n#define TX_STATUS_POSTPONE(x) case TX_STATUS_POSTPONE_ ## x: return #x\n\n\tswitch (status & TX_STATUS_MSK) {\n\tcase TX_STATUS_SUCCESS:\n\t\treturn \"SUCCESS\";\n\t\tTX_STATUS_POSTPONE(DELAY);\n\t\tTX_STATUS_POSTPONE(FEW_BYTES);\n\t\tTX_STATUS_POSTPONE(QUIET_PERIOD);\n\t\tTX_STATUS_POSTPONE(CALC_TTAK);\n\t\tTX_STATUS_FAIL(INTERNAL_CROSSED_RETRY);\n\t\tTX_STATUS_FAIL(SHORT_LIMIT);\n\t\tTX_STATUS_FAIL(LONG_LIMIT);\n\t\tTX_STATUS_FAIL(FIFO_UNDERRUN);\n\t\tTX_STATUS_FAIL(DRAIN_FLOW);\n\t\tTX_STATUS_FAIL(RFKILL_FLUSH);\n\t\tTX_STATUS_FAIL(LIFE_EXPIRE);\n\t\tTX_STATUS_FAIL(DEST_PS);\n\t\tTX_STATUS_FAIL(HOST_ABORTED);\n\t\tTX_STATUS_FAIL(BT_RETRY);\n\t\tTX_STATUS_FAIL(STA_INVALID);\n\t\tTX_STATUS_FAIL(FRAG_DROPPED);\n\t\tTX_STATUS_FAIL(TID_DISABLE);\n\t\tTX_STATUS_FAIL(FIFO_FLUSHED);\n\t\tTX_STATUS_FAIL(INSUFFICIENT_CF_POLL);\n\t\tTX_STATUS_FAIL(PASSIVE_NO_RX);\n\t\tTX_STATUS_FAIL(NO_BEACON_ON_RADAR);\n\t}\n\n\treturn \"UNKNOWN\";\n\n#undef TX_STATUS_FAIL\n#undef TX_STATUS_POSTPONE\n}\n#endif /* CONFIG_IWLEGACY_DEBUG */\n\nstatic struct il_link_quality_cmd *\nil4965_sta_alloc_lq(struct il_priv *il, u8 sta_id)\n{\n\tint i, r;\n\tstruct il_link_quality_cmd *link_cmd;\n\tu32 rate_flags = 0;\n\t__le32 rate_n_flags;\n\n\tlink_cmd = kzalloc(sizeof(struct il_link_quality_cmd), GFP_KERNEL);\n\tif (!link_cmd) {\n\t\tIL_ERR(\"Unable to allocate memory for LQ cmd.\\n\");\n\t\treturn NULL;\n\t}\n\t/* Set up the rate scaling to start at selected rate, fall back\n\t * all the way down to 1M in IEEE order, and then spin on 1M */\n\tif (il->band == NL80211_BAND_5GHZ)\n\t\tr = RATE_6M_IDX;\n\telse\n\t\tr = RATE_1M_IDX;\n\n\tif (r >= IL_FIRST_CCK_RATE && r <= IL_LAST_CCK_RATE)\n\t\trate_flags |= RATE_MCS_CCK_MSK;\n\n\trate_flags |=\n\t    il4965_first_antenna(il->hw_params.\n\t\t\t\t valid_tx_ant) << RATE_MCS_ANT_POS;\n\trate_n_flags = cpu_to_le32(il_rates[r].plcp | rate_flags);\n\tfor (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++)\n\t\tlink_cmd->rs_table[i].rate_n_flags = rate_n_flags;\n\n\tlink_cmd->general_params.single_stream_ant_msk =\n\t    il4965_first_antenna(il->hw_params.valid_tx_ant);\n\n\tlink_cmd->general_params.dual_stream_ant_msk =\n\t    il->hw_params.valid_tx_ant & ~il4965_first_antenna(il->hw_params.\n\t\t\t\t\t\t\t       valid_tx_ant);\n\tif (!link_cmd->general_params.dual_stream_ant_msk) {\n\t\tlink_cmd->general_params.dual_stream_ant_msk = ANT_AB;\n\t} else if (il4965_num_of_ant(il->hw_params.valid_tx_ant) == 2) {\n\t\tlink_cmd->general_params.dual_stream_ant_msk =\n\t\t    il->hw_params.valid_tx_ant;\n\t}\n\n\tlink_cmd->agg_params.agg_dis_start_th = LINK_QUAL_AGG_DISABLE_START_DEF;\n\tlink_cmd->agg_params.agg_time_limit =\n\t    cpu_to_le16(LINK_QUAL_AGG_TIME_LIMIT_DEF);\n\n\tlink_cmd->sta_id = sta_id;\n\n\treturn link_cmd;\n}\n\n/*\n * il4965_add_bssid_station - Add the special IBSS BSSID station\n *\n * Function sleeps.\n */\nint\nil4965_add_bssid_station(struct il_priv *il, const u8 *addr, u8 *sta_id_r)\n{\n\tint ret;\n\tu8 sta_id;\n\tstruct il_link_quality_cmd *link_cmd;\n\tunsigned long flags;\n\n\tif (sta_id_r)\n\t\t*sta_id_r = IL_INVALID_STATION;\n\n\tret = il_add_station_common(il, addr, 0, NULL, &sta_id);\n\tif (ret) {\n\t\tIL_ERR(\"Unable to add station %pM\\n\", addr);\n\t\treturn ret;\n\t}\n\n\tif (sta_id_r)\n\t\t*sta_id_r = sta_id;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].used |= IL_STA_LOCAL;\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\t/* Set up default rate scaling table in device's station table */\n\tlink_cmd = il4965_sta_alloc_lq(il, sta_id);\n\tif (!link_cmd) {\n\t\tIL_ERR(\"Unable to initialize rate scaling for station %pM.\\n\",\n\t\t       addr);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = il_send_lq_cmd(il, link_cmd, CMD_SYNC, true);\n\tif (ret)\n\t\tIL_ERR(\"Link quality command failed (%d)\\n\", ret);\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].lq = link_cmd;\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn 0;\n}\n\nstatic int\nil4965_static_wepkey_cmd(struct il_priv *il, bool send_if_empty)\n{\n\tint i;\n\tu8 buff[sizeof(struct il_wep_cmd) +\n\t\tsizeof(struct il_wep_key) * WEP_KEYS_MAX];\n\tstruct il_wep_cmd *wep_cmd = (struct il_wep_cmd *)buff;\n\tsize_t cmd_size = sizeof(struct il_wep_cmd);\n\tstruct il_host_cmd cmd = {\n\t\t.id = C_WEPKEY,\n\t\t.data = wep_cmd,\n\t\t.flags = CMD_SYNC,\n\t};\n\tbool not_empty = false;\n\n\tmight_sleep();\n\n\tmemset(wep_cmd, 0,\n\t       cmd_size + (sizeof(struct il_wep_key) * WEP_KEYS_MAX));\n\n\tfor (i = 0; i < WEP_KEYS_MAX; i++) {\n\t\tu8 key_size = il->_4965.wep_keys[i].key_size;\n\n\t\twep_cmd->key[i].key_idx = i;\n\t\tif (key_size) {\n\t\t\twep_cmd->key[i].key_offset = i;\n\t\t\tnot_empty = true;\n\t\t} else\n\t\t\twep_cmd->key[i].key_offset = WEP_INVALID_OFFSET;\n\n\t\twep_cmd->key[i].key_size = key_size;\n\t\tmemcpy(&wep_cmd->key[i].key[3], il->_4965.wep_keys[i].key, key_size);\n\t}\n\n\twep_cmd->global_key_type = WEP_KEY_WEP_TYPE;\n\twep_cmd->num_keys = WEP_KEYS_MAX;\n\n\tcmd_size += sizeof(struct il_wep_key) * WEP_KEYS_MAX;\n\tcmd.len = cmd_size;\n\n\tif (not_empty || send_if_empty)\n\t\treturn il_send_cmd(il, &cmd);\n\telse\n\t\treturn 0;\n}\n\nint\nil4965_restore_default_wep_keys(struct il_priv *il)\n{\n\tlockdep_assert_held(&il->mutex);\n\n\treturn il4965_static_wepkey_cmd(il, false);\n}\n\nint\nil4965_remove_default_wep_key(struct il_priv *il,\n\t\t\t      struct ieee80211_key_conf *keyconf)\n{\n\tint ret;\n\tint idx = keyconf->keyidx;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tD_WEP(\"Removing default WEP key: idx=%d\\n\", idx);\n\n\tmemset(&il->_4965.wep_keys[idx], 0, sizeof(struct il_wep_key));\n\tif (il_is_rfkill(il)) {\n\t\tD_WEP(\"Not sending C_WEPKEY command due to RFKILL.\\n\");\n\t\t/* but keys in device are clear anyway so return success */\n\t\treturn 0;\n\t}\n\tret = il4965_static_wepkey_cmd(il, 1);\n\tD_WEP(\"Remove default WEP key: idx=%d ret=%d\\n\", idx, ret);\n\n\treturn ret;\n}\n\nint\nil4965_set_default_wep_key(struct il_priv *il,\n\t\t\t   struct ieee80211_key_conf *keyconf)\n{\n\tint ret;\n\tint len = keyconf->keylen;\n\tint idx = keyconf->keyidx;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tif (len != WEP_KEY_LEN_128 && len != WEP_KEY_LEN_64) {\n\t\tD_WEP(\"Bad WEP key length %d\\n\", keyconf->keylen);\n\t\treturn -EINVAL;\n\t}\n\n\tkeyconf->flags &= ~IEEE80211_KEY_FLAG_GENERATE_IV;\n\tkeyconf->hw_key_idx = HW_KEY_DEFAULT;\n\til->stations[IL_AP_ID].keyinfo.cipher = keyconf->cipher;\n\n\til->_4965.wep_keys[idx].key_size = len;\n\tmemcpy(&il->_4965.wep_keys[idx].key, &keyconf->key, len);\n\n\tret = il4965_static_wepkey_cmd(il, false);\n\n\tD_WEP(\"Set default WEP key: len=%d idx=%d ret=%d\\n\", len, idx, ret);\n\treturn ret;\n}\n\nstatic int\nil4965_set_wep_dynamic_key_info(struct il_priv *il,\n\t\t\t\tstruct ieee80211_key_conf *keyconf, u8 sta_id)\n{\n\tunsigned long flags;\n\t__le16 key_flags = 0;\n\tstruct il_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tkeyconf->flags &= ~IEEE80211_KEY_FLAG_GENERATE_IV;\n\n\tkey_flags |= (STA_KEY_FLG_WEP | STA_KEY_FLG_MAP_KEY_MSK);\n\tkey_flags |= cpu_to_le16(keyconf->keyidx << STA_KEY_FLG_KEYID_POS);\n\tkey_flags &= ~STA_KEY_FLG_INVALID;\n\n\tif (keyconf->keylen == WEP_KEY_LEN_128)\n\t\tkey_flags |= STA_KEY_FLG_KEY_SIZE_MSK;\n\n\tif (sta_id == il->hw_params.bcast_id)\n\t\tkey_flags |= STA_KEY_MULTICAST_MSK;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\n\til->stations[sta_id].keyinfo.cipher = keyconf->cipher;\n\til->stations[sta_id].keyinfo.keylen = keyconf->keylen;\n\til->stations[sta_id].keyinfo.keyidx = keyconf->keyidx;\n\n\tmemcpy(il->stations[sta_id].keyinfo.key, keyconf->key, keyconf->keylen);\n\n\tmemcpy(&il->stations[sta_id].sta.key.key[3], keyconf->key,\n\t       keyconf->keylen);\n\n\tif ((il->stations[sta_id].sta.key.\n\t     key_flags & STA_KEY_FLG_ENCRYPT_MSK) == STA_KEY_FLG_NO_ENC)\n\t\til->stations[sta_id].sta.key.key_offset =\n\t\t    il_get_free_ucode_key_idx(il);\n\t/* else, we are overriding an existing key => no need to allocated room\n\t * in uCode. */\n\n\tWARN(il->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET,\n\t     \"no space for a new key\");\n\n\til->stations[sta_id].sta.key.key_flags = key_flags;\n\til->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\n\tmemcpy(&sta_cmd, &il->stations[sta_id].sta,\n\t       sizeof(struct il_addsta_cmd));\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\n}\n\nstatic int\nil4965_set_ccmp_dynamic_key_info(struct il_priv *il,\n\t\t\t\t struct ieee80211_key_conf *keyconf, u8 sta_id)\n{\n\tunsigned long flags;\n\t__le16 key_flags = 0;\n\tstruct il_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tkey_flags |= (STA_KEY_FLG_CCMP | STA_KEY_FLG_MAP_KEY_MSK);\n\tkey_flags |= cpu_to_le16(keyconf->keyidx << STA_KEY_FLG_KEYID_POS);\n\tkey_flags &= ~STA_KEY_FLG_INVALID;\n\n\tif (sta_id == il->hw_params.bcast_id)\n\t\tkey_flags |= STA_KEY_MULTICAST_MSK;\n\n\tkeyconf->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].keyinfo.cipher = keyconf->cipher;\n\til->stations[sta_id].keyinfo.keylen = keyconf->keylen;\n\n\tmemcpy(il->stations[sta_id].keyinfo.key, keyconf->key, keyconf->keylen);\n\n\tmemcpy(il->stations[sta_id].sta.key.key, keyconf->key, keyconf->keylen);\n\n\tif ((il->stations[sta_id].sta.key.\n\t     key_flags & STA_KEY_FLG_ENCRYPT_MSK) == STA_KEY_FLG_NO_ENC)\n\t\til->stations[sta_id].sta.key.key_offset =\n\t\t    il_get_free_ucode_key_idx(il);\n\t/* else, we are overriding an existing key => no need to allocated room\n\t * in uCode. */\n\n\tWARN(il->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET,\n\t     \"no space for a new key\");\n\n\til->stations[sta_id].sta.key.key_flags = key_flags;\n\til->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\n\tmemcpy(&sta_cmd, &il->stations[sta_id].sta,\n\t       sizeof(struct il_addsta_cmd));\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\n}\n\nstatic int\nil4965_set_tkip_dynamic_key_info(struct il_priv *il,\n\t\t\t\t struct ieee80211_key_conf *keyconf, u8 sta_id)\n{\n\tunsigned long flags;\n\t__le16 key_flags = 0;\n\n\tkey_flags |= (STA_KEY_FLG_TKIP | STA_KEY_FLG_MAP_KEY_MSK);\n\tkey_flags |= cpu_to_le16(keyconf->keyidx << STA_KEY_FLG_KEYID_POS);\n\tkey_flags &= ~STA_KEY_FLG_INVALID;\n\n\tif (sta_id == il->hw_params.bcast_id)\n\t\tkey_flags |= STA_KEY_MULTICAST_MSK;\n\n\tkeyconf->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\tkeyconf->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\n\til->stations[sta_id].keyinfo.cipher = keyconf->cipher;\n\til->stations[sta_id].keyinfo.keylen = 16;\n\n\tif ((il->stations[sta_id].sta.key.\n\t     key_flags & STA_KEY_FLG_ENCRYPT_MSK) == STA_KEY_FLG_NO_ENC)\n\t\til->stations[sta_id].sta.key.key_offset =\n\t\t    il_get_free_ucode_key_idx(il);\n\t/* else, we are overriding an existing key => no need to allocated room\n\t * in uCode. */\n\n\tWARN(il->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET,\n\t     \"no space for a new key\");\n\n\til->stations[sta_id].sta.key.key_flags = key_flags;\n\n\t/* This copy is acutally not needed: we get the key with each TX */\n\tmemcpy(il->stations[sta_id].keyinfo.key, keyconf->key, 16);\n\n\tmemcpy(il->stations[sta_id].sta.key.key, keyconf->key, 16);\n\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn 0;\n}\n\nvoid\nil4965_update_tkip_key(struct il_priv *il, struct ieee80211_key_conf *keyconf,\n\t\t       struct ieee80211_sta *sta, u32 iv32, u16 *phase1key)\n{\n\tu8 sta_id;\n\tunsigned long flags;\n\tint i;\n\n\tif (il_scan_cancel(il)) {\n\t\t/* cancel scan failed, just live w/ bad key and rely\n\t\t   briefly on SW decryption */\n\t\treturn;\n\t}\n\n\tsta_id = il_sta_id_or_broadcast(il, sta);\n\tif (sta_id == IL_INVALID_STATION)\n\t\treturn;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\n\til->stations[sta_id].sta.key.tkip_rx_tsc_byte2 = (u8) iv32;\n\n\tfor (i = 0; i < 5; i++)\n\t\til->stations[sta_id].sta.key.tkip_rx_ttak[i] =\n\t\t    cpu_to_le16(phase1key[i]);\n\n\til->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\n\til_send_add_sta(il, &il->stations[sta_id].sta, CMD_ASYNC);\n\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n}\n\nint\nil4965_remove_dynamic_key(struct il_priv *il,\n\t\t\t  struct ieee80211_key_conf *keyconf, u8 sta_id)\n{\n\tunsigned long flags;\n\tu16 key_flags;\n\tu8 keyidx;\n\tstruct il_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&il->mutex);\n\n\til->_4965.key_mapping_keys--;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\tkey_flags = le16_to_cpu(il->stations[sta_id].sta.key.key_flags);\n\tkeyidx = (key_flags >> STA_KEY_FLG_KEYID_POS) & 0x3;\n\n\tD_WEP(\"Remove dynamic key: idx=%d sta=%d\\n\", keyconf->keyidx, sta_id);\n\n\tif (keyconf->keyidx != keyidx) {\n\t\t/* We need to remove a key with idx different that the one\n\t\t * in the uCode. This means that the key we need to remove has\n\t\t * been replaced by another one with different idx.\n\t\t * Don't do anything and return ok\n\t\t */\n\t\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\t\treturn 0;\n\t}\n\n\tif (il->stations[sta_id].sta.key.key_flags & STA_KEY_FLG_INVALID) {\n\t\tIL_WARN(\"Removing wrong key %d 0x%x\\n\", keyconf->keyidx,\n\t\t\tkey_flags);\n\t\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\t\treturn 0;\n\t}\n\n\tif (!test_and_clear_bit\n\t    (il->stations[sta_id].sta.key.key_offset, &il->ucode_key_table))\n\t\tIL_ERR(\"idx %d not used in uCode key table.\\n\",\n\t\t       il->stations[sta_id].sta.key.key_offset);\n\tmemset(&il->stations[sta_id].keyinfo, 0, sizeof(struct il_hw_key));\n\tmemset(&il->stations[sta_id].sta.key, 0, sizeof(struct il4965_keyinfo));\n\til->stations[sta_id].sta.key.key_flags =\n\t    STA_KEY_FLG_NO_ENC | STA_KEY_FLG_INVALID;\n\til->stations[sta_id].sta.key.key_offset = keyconf->hw_key_idx;\n\til->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\n\tif (il_is_rfkill(il)) {\n\t\tD_WEP\n\t\t    (\"Not sending C_ADD_STA command because RFKILL enabled.\\n\");\n\t\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\t\treturn 0;\n\t}\n\tmemcpy(&sta_cmd, &il->stations[sta_id].sta,\n\t       sizeof(struct il_addsta_cmd));\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\n}\n\nint\nil4965_set_dynamic_key(struct il_priv *il, struct ieee80211_key_conf *keyconf,\n\t\t       u8 sta_id)\n{\n\tint ret;\n\n\tlockdep_assert_held(&il->mutex);\n\n\til->_4965.key_mapping_keys++;\n\tkeyconf->hw_key_idx = HW_KEY_DYNAMIC;\n\n\tswitch (keyconf->cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tret =\n\t\t    il4965_set_ccmp_dynamic_key_info(il, keyconf, sta_id);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tret =\n\t\t    il4965_set_tkip_dynamic_key_info(il, keyconf, sta_id);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tret = il4965_set_wep_dynamic_key_info(il, keyconf, sta_id);\n\t\tbreak;\n\tdefault:\n\t\tIL_ERR(\"Unknown alg: %s cipher = %x\\n\", __func__,\n\t\t       keyconf->cipher);\n\t\tret = -EINVAL;\n\t}\n\n\tD_WEP(\"Set dynamic key: cipher=%x len=%d idx=%d sta=%d ret=%d\\n\",\n\t      keyconf->cipher, keyconf->keylen, keyconf->keyidx, sta_id, ret);\n\n\treturn ret;\n}\n\n/*\n * il4965_alloc_bcast_station - add broadcast station into driver's station table.\n *\n * This adds the broadcast station into the driver's station table\n * and marks it driver active, so that it will be restored to the\n * device at the next best time.\n */\nint\nil4965_alloc_bcast_station(struct il_priv *il)\n{\n\tstruct il_link_quality_cmd *link_cmd;\n\tunsigned long flags;\n\tu8 sta_id;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\tsta_id = il_prep_station(il, il_bcast_addr, false, NULL);\n\tif (sta_id == IL_INVALID_STATION) {\n\t\tIL_ERR(\"Unable to prepare broadcast station\\n\");\n\t\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\t\treturn -EINVAL;\n\t}\n\n\til->stations[sta_id].used |= IL_STA_DRIVER_ACTIVE;\n\til->stations[sta_id].used |= IL_STA_BCAST;\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\tlink_cmd = il4965_sta_alloc_lq(il, sta_id);\n\tif (!link_cmd) {\n\t\tIL_ERR\n\t\t    (\"Unable to initialize rate scaling for bcast station.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].lq = link_cmd;\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn 0;\n}\n\n/*\n * il4965_update_bcast_station - update broadcast station's LQ command\n *\n * Only used by iwl4965. Placed here to have all bcast station management\n * code together.\n */\nstatic int\nil4965_update_bcast_station(struct il_priv *il)\n{\n\tunsigned long flags;\n\tstruct il_link_quality_cmd *link_cmd;\n\tu8 sta_id = il->hw_params.bcast_id;\n\n\tlink_cmd = il4965_sta_alloc_lq(il, sta_id);\n\tif (!link_cmd) {\n\t\tIL_ERR(\"Unable to initialize rate scaling for bcast sta.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\tif (il->stations[sta_id].lq)\n\t\tkfree(il->stations[sta_id].lq);\n\telse\n\t\tD_INFO(\"Bcast sta rate scaling has not been initialized.\\n\");\n\til->stations[sta_id].lq = link_cmd;\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn 0;\n}\n\nint\nil4965_update_bcast_stations(struct il_priv *il)\n{\n\treturn il4965_update_bcast_station(il);\n}\n\n/*\n * il4965_sta_tx_modify_enable_tid - Enable Tx for this TID in station table\n */\nint\nil4965_sta_tx_modify_enable_tid(struct il_priv *il, int sta_id, int tid)\n{\n\tunsigned long flags;\n\tstruct il_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&il->mutex);\n\n\t/* Remove \"disable\" flag, to enable Tx for this TID */\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_TID_DISABLE_TX;\n\til->stations[sta_id].sta.tid_disable_tx &= cpu_to_le16(~(1 << tid));\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\tmemcpy(&sta_cmd, &il->stations[sta_id].sta,\n\t       sizeof(struct il_addsta_cmd));\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\n}\n\nint\nil4965_sta_rx_agg_start(struct il_priv *il, struct ieee80211_sta *sta, int tid,\n\t\t\tu16 ssn)\n{\n\tunsigned long flags;\n\tint sta_id;\n\tstruct il_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tsta_id = il_sta_id(sta);\n\tif (sta_id == IL_INVALID_STATION)\n\t\treturn -ENXIO;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].sta.station_flags_msk = 0;\n\til->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_ADDBA_TID_MSK;\n\til->stations[sta_id].sta.add_immediate_ba_tid = (u8) tid;\n\til->stations[sta_id].sta.add_immediate_ba_ssn = cpu_to_le16(ssn);\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\tmemcpy(&sta_cmd, &il->stations[sta_id].sta,\n\t       sizeof(struct il_addsta_cmd));\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\n}\n\nint\nil4965_sta_rx_agg_stop(struct il_priv *il, struct ieee80211_sta *sta, int tid)\n{\n\tunsigned long flags;\n\tint sta_id;\n\tstruct il_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tsta_id = il_sta_id(sta);\n\tif (sta_id == IL_INVALID_STATION) {\n\t\tIL_ERR(\"Invalid station for AGG tid %d\\n\", tid);\n\t\treturn -ENXIO;\n\t}\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].sta.station_flags_msk = 0;\n\til->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_DELBA_TID_MSK;\n\til->stations[sta_id].sta.remove_immediate_ba_tid = (u8) tid;\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\tmemcpy(&sta_cmd, &il->stations[sta_id].sta,\n\t       sizeof(struct il_addsta_cmd));\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\n}\n\nvoid\nil4965_sta_modify_sleep_tx_count(struct il_priv *il, int sta_id, int cnt)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].sta.station_flags |= STA_FLG_PWR_SAVE_MSK;\n\til->stations[sta_id].sta.station_flags_msk = STA_FLG_PWR_SAVE_MSK;\n\til->stations[sta_id].sta.sta.modify_mask =\n\t    STA_MODIFY_SLEEP_TX_COUNT_MSK;\n\til->stations[sta_id].sta.sleep_tx_count = cpu_to_le16(cnt);\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\til_send_add_sta(il, &il->stations[sta_id].sta, CMD_ASYNC);\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n}\n\nvoid\nil4965_update_chain_flags(struct il_priv *il)\n{\n\tif (il->ops->set_rxon_chain) {\n\t\til->ops->set_rxon_chain(il);\n\t\tif (il->active.rx_chain != il->staging.rx_chain)\n\t\t\til_commit_rxon(il);\n\t}\n}\n\nstatic void\nil4965_clear_free_frames(struct il_priv *il)\n{\n\tstruct list_head *element;\n\n\tD_INFO(\"%d frames on pre-allocated heap on clear.\\n\", il->frames_count);\n\n\twhile (!list_empty(&il->free_frames)) {\n\t\telement = il->free_frames.next;\n\t\tlist_del(element);\n\t\tkfree(list_entry(element, struct il_frame, list));\n\t\til->frames_count--;\n\t}\n\n\tif (il->frames_count) {\n\t\tIL_WARN(\"%d frames still in use.  Did we lose one?\\n\",\n\t\t\til->frames_count);\n\t\til->frames_count = 0;\n\t}\n}\n\nstatic struct il_frame *\nil4965_get_free_frame(struct il_priv *il)\n{\n\tstruct il_frame *frame;\n\tstruct list_head *element;\n\tif (list_empty(&il->free_frames)) {\n\t\tframe = kzalloc(sizeof(*frame), GFP_KERNEL);\n\t\tif (!frame) {\n\t\t\tIL_ERR(\"Could not allocate frame!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\til->frames_count++;\n\t\treturn frame;\n\t}\n\n\telement = il->free_frames.next;\n\tlist_del(element);\n\treturn list_entry(element, struct il_frame, list);\n}\n\nstatic void\nil4965_free_frame(struct il_priv *il, struct il_frame *frame)\n{\n\tmemset(frame, 0, sizeof(*frame));\n\tlist_add(&frame->list, &il->free_frames);\n}\n\nstatic u32\nil4965_fill_beacon_frame(struct il_priv *il, struct ieee80211_hdr *hdr,\n\t\t\t int left)\n{\n\tlockdep_assert_held(&il->mutex);\n\n\tif (!il->beacon_skb)\n\t\treturn 0;\n\n\tif (il->beacon_skb->len > left)\n\t\treturn 0;\n\n\tmemcpy(hdr, il->beacon_skb->data, il->beacon_skb->len);\n\n\treturn il->beacon_skb->len;\n}\n\n/* Parse the beacon frame to find the TIM element and set tim_idx & tim_size */\nstatic void\nil4965_set_beacon_tim(struct il_priv *il,\n\t\t      struct il_tx_beacon_cmd *tx_beacon_cmd, u8 * beacon,\n\t\t      u32 frame_size)\n{\n\tu16 tim_idx;\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)beacon;\n\n\t/*\n\t * The idx is relative to frame start but we start looking at the\n\t * variable-length part of the beacon.\n\t */\n\ttim_idx = mgmt->u.beacon.variable - beacon;\n\n\t/* Parse variable-length elements of beacon to find WLAN_EID_TIM */\n\twhile ((tim_idx < (frame_size - 2)) &&\n\t       (beacon[tim_idx] != WLAN_EID_TIM))\n\t\ttim_idx += beacon[tim_idx + 1] + 2;\n\n\t/* If TIM field was found, set variables */\n\tif ((tim_idx < (frame_size - 1)) && (beacon[tim_idx] == WLAN_EID_TIM)) {\n\t\ttx_beacon_cmd->tim_idx = cpu_to_le16(tim_idx);\n\t\ttx_beacon_cmd->tim_size = beacon[tim_idx + 1];\n\t} else\n\t\tIL_WARN(\"Unable to find TIM Element in beacon\\n\");\n}\n\nstatic unsigned int\nil4965_hw_get_beacon_cmd(struct il_priv *il, struct il_frame *frame)\n{\n\tstruct il_tx_beacon_cmd *tx_beacon_cmd;\n\tu32 frame_size;\n\tu32 rate_flags;\n\tu32 rate;\n\t/*\n\t * We have to set up the TX command, the TX Beacon command, and the\n\t * beacon contents.\n\t */\n\n\tlockdep_assert_held(&il->mutex);\n\n\tif (!il->beacon_enabled) {\n\t\tIL_ERR(\"Trying to build beacon without beaconing enabled\\n\");\n\t\treturn 0;\n\t}\n\n\t/* Initialize memory */\n\ttx_beacon_cmd = &frame->u.beacon;\n\tmemset(tx_beacon_cmd, 0, sizeof(*tx_beacon_cmd));\n\n\t/* Set up TX beacon contents */\n\tframe_size =\n\t    il4965_fill_beacon_frame(il, tx_beacon_cmd->frame,\n\t\t\t\t     sizeof(frame->u) - sizeof(*tx_beacon_cmd));\n\tif (WARN_ON_ONCE(frame_size > MAX_MPDU_SIZE))\n\t\treturn 0;\n\tif (!frame_size)\n\t\treturn 0;\n\n\t/* Set up TX command fields */\n\ttx_beacon_cmd->tx.len = cpu_to_le16((u16) frame_size);\n\ttx_beacon_cmd->tx.sta_id = il->hw_params.bcast_id;\n\ttx_beacon_cmd->tx.stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\n\ttx_beacon_cmd->tx.tx_flags =\n\t    TX_CMD_FLG_SEQ_CTL_MSK | TX_CMD_FLG_TSF_MSK |\n\t    TX_CMD_FLG_STA_RATE_MSK;\n\n\t/* Set up TX beacon command fields */\n\til4965_set_beacon_tim(il, tx_beacon_cmd, (u8 *) tx_beacon_cmd->frame,\n\t\t\t      frame_size);\n\n\t/* Set up packet rate and flags */\n\trate = il_get_lowest_plcp(il);\n\til4965_toggle_tx_ant(il, &il->mgmt_tx_ant, il->hw_params.valid_tx_ant);\n\trate_flags = BIT(il->mgmt_tx_ant) << RATE_MCS_ANT_POS;\n\tif ((rate >= IL_FIRST_CCK_RATE) && (rate <= IL_LAST_CCK_RATE))\n\t\trate_flags |= RATE_MCS_CCK_MSK;\n\ttx_beacon_cmd->tx.rate_n_flags = cpu_to_le32(rate | rate_flags);\n\n\treturn sizeof(*tx_beacon_cmd) + frame_size;\n}\n\nint\nil4965_send_beacon_cmd(struct il_priv *il)\n{\n\tstruct il_frame *frame;\n\tunsigned int frame_size;\n\tint rc;\n\n\tframe = il4965_get_free_frame(il);\n\tif (!frame) {\n\t\tIL_ERR(\"Could not obtain free frame buffer for beacon \"\n\t\t       \"command.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tframe_size = il4965_hw_get_beacon_cmd(il, frame);\n\tif (!frame_size) {\n\t\tIL_ERR(\"Error configuring the beacon command\\n\");\n\t\til4965_free_frame(il, frame);\n\t\treturn -EINVAL;\n\t}\n\n\trc = il_send_cmd_pdu(il, C_TX_BEACON, frame_size, &frame->u.cmd[0]);\n\n\til4965_free_frame(il, frame);\n\n\treturn rc;\n}\n\nstatic inline dma_addr_t\nil4965_tfd_tb_get_addr(struct il_tfd *tfd, u8 idx)\n{\n\tstruct il_tfd_tb *tb = &tfd->tbs[idx];\n\n\tdma_addr_t addr = get_unaligned_le32(&tb->lo);\n\tif (sizeof(dma_addr_t) > sizeof(u32))\n\t\taddr |=\n\t\t    ((dma_addr_t) (le16_to_cpu(tb->hi_n_len) & 0xF) << 16) <<\n\t\t    16;\n\n\treturn addr;\n}\n\nstatic inline u16\nil4965_tfd_tb_get_len(struct il_tfd *tfd, u8 idx)\n{\n\tstruct il_tfd_tb *tb = &tfd->tbs[idx];\n\n\treturn le16_to_cpu(tb->hi_n_len) >> 4;\n}\n\nstatic inline void\nil4965_tfd_set_tb(struct il_tfd *tfd, u8 idx, dma_addr_t addr, u16 len)\n{\n\tstruct il_tfd_tb *tb = &tfd->tbs[idx];\n\tu16 hi_n_len = len << 4;\n\n\tput_unaligned_le32(addr, &tb->lo);\n\tif (sizeof(dma_addr_t) > sizeof(u32))\n\t\thi_n_len |= ((addr >> 16) >> 16) & 0xF;\n\n\ttb->hi_n_len = cpu_to_le16(hi_n_len);\n\n\ttfd->num_tbs = idx + 1;\n}\n\nstatic inline u8\nil4965_tfd_get_num_tbs(struct il_tfd *tfd)\n{\n\treturn tfd->num_tbs & 0x1f;\n}\n\n/*\n * il4965_hw_txq_free_tfd - Free all chunks referenced by TFD [txq->q.read_ptr]\n *\n * Does NOT advance any TFD circular buffer read/write idxes\n * Does NOT free the TFD itself (which is within circular buffer)\n */\nvoid\nil4965_hw_txq_free_tfd(struct il_priv *il, struct il_tx_queue *txq)\n{\n\tstruct il_tfd *tfd_tmp = (struct il_tfd *)txq->tfds;\n\tstruct il_tfd *tfd;\n\tstruct pci_dev *dev = il->pci_dev;\n\tint idx = txq->q.read_ptr;\n\tint i;\n\tint num_tbs;\n\n\ttfd = &tfd_tmp[idx];\n\n\t/* Sanity check on number of chunks */\n\tnum_tbs = il4965_tfd_get_num_tbs(tfd);\n\n\tif (num_tbs >= IL_NUM_OF_TBS) {\n\t\tIL_ERR(\"Too many chunks: %i\\n\", num_tbs);\n\t\t/* @todo issue fatal error, it is quite serious situation */\n\t\treturn;\n\t}\n\n\t/* Unmap tx_cmd */\n\tif (num_tbs)\n\t\tpci_unmap_single(dev, dma_unmap_addr(&txq->meta[idx], mapping),\n\t\t\t\t dma_unmap_len(&txq->meta[idx], len),\n\t\t\t\t PCI_DMA_BIDIRECTIONAL);\n\n\t/* Unmap chunks, if any. */\n\tfor (i = 1; i < num_tbs; i++)\n\t\tpci_unmap_single(dev, il4965_tfd_tb_get_addr(tfd, i),\n\t\t\t\t il4965_tfd_tb_get_len(tfd, i),\n\t\t\t\t PCI_DMA_TODEVICE);\n\n\t/* free SKB */\n\tif (txq->skbs) {\n\t\tstruct sk_buff *skb = txq->skbs[txq->q.read_ptr];\n\n\t\t/* can be called from irqs-disabled context */\n\t\tif (skb) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\ttxq->skbs[txq->q.read_ptr] = NULL;\n\t\t}\n\t}\n}\n\nint\nil4965_hw_txq_attach_buf_to_tfd(struct il_priv *il, struct il_tx_queue *txq,\n\t\t\t\tdma_addr_t addr, u16 len, u8 reset, u8 pad)\n{\n\tstruct il_queue *q;\n\tstruct il_tfd *tfd, *tfd_tmp;\n\tu32 num_tbs;\n\n\tq = &txq->q;\n\ttfd_tmp = (struct il_tfd *)txq->tfds;\n\ttfd = &tfd_tmp[q->write_ptr];\n\n\tif (reset)\n\t\tmemset(tfd, 0, sizeof(*tfd));\n\n\tnum_tbs = il4965_tfd_get_num_tbs(tfd);\n\n\t/* Each TFD can point to a maximum 20 Tx buffers */\n\tif (num_tbs >= IL_NUM_OF_TBS) {\n\t\tIL_ERR(\"Error can not send more than %d chunks\\n\",\n\t\t       IL_NUM_OF_TBS);\n\t\treturn -EINVAL;\n\t}\n\n\tBUG_ON(addr & ~DMA_BIT_MASK(36));\n\tif (unlikely(addr & ~IL_TX_DMA_MASK))\n\t\tIL_ERR(\"Unaligned address = %llx\\n\", (unsigned long long)addr);\n\n\til4965_tfd_set_tb(tfd, num_tbs, addr, len);\n\n\treturn 0;\n}\n\n/*\n * Tell nic where to find circular buffer of Tx Frame Descriptors for\n * given Tx queue, and enable the DMA channel used for that queue.\n *\n * 4965 supports up to 16 Tx queues in DRAM, mapped to up to 8 Tx DMA\n * channels supported in hardware.\n */\nint\nil4965_hw_tx_queue_init(struct il_priv *il, struct il_tx_queue *txq)\n{\n\tint txq_id = txq->q.id;\n\n\t/* Circular buffer (TFD queue in DRAM) physical base address */\n\til_wr(il, FH49_MEM_CBBC_QUEUE(txq_id), txq->q.dma_addr >> 8);\n\n\treturn 0;\n}\n\n/******************************************************************************\n *\n * Generic RX handler implementations\n *\n ******************************************************************************/\nstatic void\nil4965_hdl_alive(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il_alive_resp *palive;\n\tstruct delayed_work *pwork;\n\n\tpalive = &pkt->u.alive_frame;\n\n\tD_INFO(\"Alive ucode status 0x%08X revision \" \"0x%01X 0x%01X\\n\",\n\t       palive->is_valid, palive->ver_type, palive->ver_subtype);\n\n\tif (palive->ver_subtype == INITIALIZE_SUBTYPE) {\n\t\tD_INFO(\"Initialization Alive received.\\n\");\n\t\tmemcpy(&il->card_alive_init, &pkt->u.alive_frame,\n\t\t       sizeof(struct il_init_alive_resp));\n\t\tpwork = &il->init_alive_start;\n\t} else {\n\t\tD_INFO(\"Runtime Alive received.\\n\");\n\t\tmemcpy(&il->card_alive, &pkt->u.alive_frame,\n\t\t       sizeof(struct il_alive_resp));\n\t\tpwork = &il->alive_start;\n\t}\n\n\t/* We delay the ALIVE response by 5ms to\n\t * give the HW RF Kill time to activate... */\n\tif (palive->is_valid == UCODE_VALID_OK)\n\t\tqueue_delayed_work(il->workqueue, pwork, msecs_to_jiffies(5));\n\telse\n\t\tIL_WARN(\"uCode did not respond OK.\\n\");\n}\n\n/*\n * il4965_bg_stats_periodic - Timer callback to queue stats\n *\n * This callback is provided in order to send a stats request.\n *\n * This timer function is continually reset to execute within\n * 60 seconds since the last N_STATS was received.  We need to\n * ensure we receive the stats in order to update the temperature\n * used for calibrating the TXPOWER.\n */\nstatic void\nil4965_bg_stats_periodic(struct timer_list *t)\n{\n\tstruct il_priv *il = from_timer(il, t, stats_periodic);\n\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn;\n\n\t/* dont send host command if rf-kill is on */\n\tif (!il_is_ready_rf(il))\n\t\treturn;\n\n\til_send_stats_request(il, CMD_ASYNC, false);\n}\n\nstatic void\nil4965_hdl_beacon(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il4965_beacon_notif *beacon =\n\t    (struct il4965_beacon_notif *)pkt->u.raw;\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tu8 rate = il4965_hw_get_rate(beacon->beacon_notify_hdr.rate_n_flags);\n\n\tD_RX(\"beacon status %x retries %d iss %d tsf:0x%.8x%.8x rate %d\\n\",\n\t     le32_to_cpu(beacon->beacon_notify_hdr.u.status) & TX_STATUS_MSK,\n\t     beacon->beacon_notify_hdr.failure_frame,\n\t     le32_to_cpu(beacon->ibss_mgr_status),\n\t     le32_to_cpu(beacon->high_tsf), le32_to_cpu(beacon->low_tsf), rate);\n#endif\n\til->ibss_manager = le32_to_cpu(beacon->ibss_mgr_status);\n}\n\nstatic void\nil4965_perform_ct_kill_task(struct il_priv *il)\n{\n\tunsigned long flags;\n\n\tD_POWER(\"Stop all queues\\n\");\n\n\tif (il->mac80211_registered)\n\t\tieee80211_stop_queues(il->hw);\n\n\t_il_wr(il, CSR_UCODE_DRV_GP1_SET,\n\t       CSR_UCODE_DRV_GP1_REG_BIT_CT_KILL_EXIT);\n\t_il_rd(il, CSR_UCODE_DRV_GP1);\n\n\tspin_lock_irqsave(&il->reg_lock, flags);\n\tif (likely(_il_grab_nic_access(il)))\n\t\t_il_release_nic_access(il);\n\tspin_unlock_irqrestore(&il->reg_lock, flags);\n}\n\n/* Handle notification from uCode that card's power state is changing\n * due to software, hardware, or critical temperature RFKILL */\nstatic void\nil4965_hdl_card_state(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tu32 flags = le32_to_cpu(pkt->u.card_state_notif.flags);\n\tunsigned long status = il->status;\n\n\tD_RF_KILL(\"Card state received: HW:%s SW:%s CT:%s\\n\",\n\t\t  (flags & HW_CARD_DISABLED) ? \"Kill\" : \"On\",\n\t\t  (flags & SW_CARD_DISABLED) ? \"Kill\" : \"On\",\n\t\t  (flags & CT_CARD_DISABLED) ? \"Reached\" : \"Not reached\");\n\n\tif (flags & (SW_CARD_DISABLED | HW_CARD_DISABLED | CT_CARD_DISABLED)) {\n\n\t\t_il_wr(il, CSR_UCODE_DRV_GP1_SET,\n\t\t       CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);\n\n\t\til_wr(il, HBUS_TARG_MBX_C, HBUS_TARG_MBX_C_REG_BIT_CMD_BLOCKED);\n\n\t\tif (!(flags & RXON_CARD_DISABLED)) {\n\t\t\t_il_wr(il, CSR_UCODE_DRV_GP1_CLR,\n\t\t\t       CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);\n\t\t\til_wr(il, HBUS_TARG_MBX_C,\n\t\t\t      HBUS_TARG_MBX_C_REG_BIT_CMD_BLOCKED);\n\t\t}\n\t}\n\n\tif (flags & CT_CARD_DISABLED)\n\t\til4965_perform_ct_kill_task(il);\n\n\tif (flags & HW_CARD_DISABLED)\n\t\tset_bit(S_RFKILL, &il->status);\n\telse\n\t\tclear_bit(S_RFKILL, &il->status);\n\n\tif (!(flags & RXON_CARD_DISABLED))\n\t\til_scan_cancel(il);\n\n\tif ((test_bit(S_RFKILL, &status) !=\n\t     test_bit(S_RFKILL, &il->status)))\n\t\twiphy_rfkill_set_hw_state(il->hw->wiphy,\n\t\t\t\t\t  test_bit(S_RFKILL, &il->status));\n\telse\n\t\twake_up(&il->wait_command_queue);\n}\n\n/*\n * il4965_setup_handlers - Initialize Rx handler callbacks\n *\n * Setup the RX handlers for each of the reply types sent from the uCode\n * to the host.\n *\n * This function chains into the hardware specific files for them to setup\n * any hardware specific handlers as well.\n */\nstatic void\nil4965_setup_handlers(struct il_priv *il)\n{\n\til->handlers[N_ALIVE] = il4965_hdl_alive;\n\til->handlers[N_ERROR] = il_hdl_error;\n\til->handlers[N_CHANNEL_SWITCH] = il_hdl_csa;\n\til->handlers[N_SPECTRUM_MEASUREMENT] = il_hdl_spectrum_measurement;\n\til->handlers[N_PM_SLEEP] = il_hdl_pm_sleep;\n\til->handlers[N_PM_DEBUG_STATS] = il_hdl_pm_debug_stats;\n\til->handlers[N_BEACON] = il4965_hdl_beacon;\n\n\t/*\n\t * The same handler is used for both the REPLY to a discrete\n\t * stats request from the host as well as for the periodic\n\t * stats notifications (after received beacons) from the uCode.\n\t */\n\til->handlers[C_STATS] = il4965_hdl_c_stats;\n\til->handlers[N_STATS] = il4965_hdl_stats;\n\n\til_setup_rx_scan_handlers(il);\n\n\t/* status change handler */\n\til->handlers[N_CARD_STATE] = il4965_hdl_card_state;\n\n\til->handlers[N_MISSED_BEACONS] = il4965_hdl_missed_beacon;\n\t/* Rx handlers */\n\til->handlers[N_RX_PHY] = il4965_hdl_rx_phy;\n\til->handlers[N_RX_MPDU] = il4965_hdl_rx;\n\til->handlers[N_RX] = il4965_hdl_rx;\n\t/* block ack */\n\til->handlers[N_COMPRESSED_BA] = il4965_hdl_compressed_ba;\n\t/* Tx response */\n\til->handlers[C_TX] = il4965_hdl_tx;\n}\n\n/*\n * il4965_rx_handle - Main entry function for receiving responses from uCode\n *\n * Uses the il->handlers callback function array to invoke\n * the appropriate handlers, including command responses,\n * frame-received notifications, and other notifications.\n */\nvoid\nil4965_rx_handle(struct il_priv *il)\n{\n\tstruct il_rx_buf *rxb;\n\tstruct il_rx_pkt *pkt;\n\tstruct il_rx_queue *rxq = &il->rxq;\n\tu32 r, i;\n\tint reclaim;\n\tunsigned long flags;\n\tu8 fill_rx = 0;\n\tu32 count = 8;\n\tint total_empty;\n\n\t/* uCode's read idx (stored in shared DRAM) indicates the last Rx\n\t * buffer that the driver may process (last buffer filled by ucode). */\n\tr = le16_to_cpu(rxq->rb_stts->closed_rb_num) & 0x0FFF;\n\ti = rxq->read;\n\n\t/* Rx interrupt, but nothing sent from uCode */\n\tif (i == r)\n\t\tD_RX(\"r = %d, i = %d\\n\", r, i);\n\n\t/* calculate total frames need to be restock after handling RX */\n\ttotal_empty = r - rxq->write_actual;\n\tif (total_empty < 0)\n\t\ttotal_empty += RX_QUEUE_SIZE;\n\n\tif (total_empty > (RX_QUEUE_SIZE / 2))\n\t\tfill_rx = 1;\n\n\twhile (i != r) {\n\t\tint len;\n\n\t\trxb = rxq->queue[i];\n\n\t\t/* If an RXB doesn't have a Rx queue slot associated with it,\n\t\t * then a bug has been introduced in the queue refilling\n\t\t * routines -- catch it here */\n\t\tBUG_ON(rxb == NULL);\n\n\t\trxq->queue[i] = NULL;\n\n\t\tpci_unmap_page(il->pci_dev, rxb->page_dma,\n\t\t\t       PAGE_SIZE << il->hw_params.rx_page_order,\n\t\t\t       PCI_DMA_FROMDEVICE);\n\t\tpkt = rxb_addr(rxb);\n\n\t\tlen = le32_to_cpu(pkt->len_n_flags) & IL_RX_FRAME_SIZE_MSK;\n\t\tlen += sizeof(u32);\t/* account for status word */\n\n\t\treclaim = il_need_reclaim(il, pkt);\n\n\t\t/* Based on type of command response or notification,\n\t\t *   handle those that need handling via function in\n\t\t *   handlers table.  See il4965_setup_handlers() */\n\t\tif (il->handlers[pkt->hdr.cmd]) {\n\t\t\tD_RX(\"r = %d, i = %d, %s, 0x%02x\\n\", r, i,\n\t\t\t     il_get_cmd_string(pkt->hdr.cmd), pkt->hdr.cmd);\n\t\t\til->isr_stats.handlers[pkt->hdr.cmd]++;\n\t\t\til->handlers[pkt->hdr.cmd] (il, rxb);\n\t\t} else {\n\t\t\t/* No handling needed */\n\t\t\tD_RX(\"r %d i %d No handler needed for %s, 0x%02x\\n\", r,\n\t\t\t     i, il_get_cmd_string(pkt->hdr.cmd), pkt->hdr.cmd);\n\t\t}\n\n\t\t/*\n\t\t * XXX: After here, we should always check rxb->page\n\t\t * against NULL before touching it or its virtual\n\t\t * memory (pkt). Because some handler might have\n\t\t * already taken or freed the pages.\n\t\t */\n\n\t\tif (reclaim) {\n\t\t\t/* Invoke any callbacks, transfer the buffer to caller,\n\t\t\t * and fire off the (possibly) blocking il_send_cmd()\n\t\t\t * as we reclaim the driver command queue */\n\t\t\tif (rxb->page)\n\t\t\t\til_tx_cmd_complete(il, rxb);\n\t\t\telse\n\t\t\t\tIL_WARN(\"Claim null rxb?\\n\");\n\t\t}\n\n\t\t/* Reuse the page if possible. For notification packets and\n\t\t * SKBs that fail to Rx correctly, add them back into the\n\t\t * rx_free list for reuse later. */\n\t\tspin_lock_irqsave(&rxq->lock, flags);\n\t\tif (rxb->page != NULL) {\n\t\t\trxb->page_dma =\n\t\t\t    pci_map_page(il->pci_dev, rxb->page, 0,\n\t\t\t\t\t PAGE_SIZE << il->hw_params.\n\t\t\t\t\t rx_page_order, PCI_DMA_FROMDEVICE);\n\n\t\t\tif (unlikely(pci_dma_mapping_error(il->pci_dev,\n\t\t\t\t\t\t\t   rxb->page_dma))) {\n\t\t\t\t__il_free_pages(il, rxb->page);\n\t\t\t\trxb->page = NULL;\n\t\t\t\tlist_add_tail(&rxb->list, &rxq->rx_used);\n\t\t\t} else {\n\t\t\t\tlist_add_tail(&rxb->list, &rxq->rx_free);\n\t\t\t\trxq->free_count++;\n\t\t\t}\n\t\t} else\n\t\t\tlist_add_tail(&rxb->list, &rxq->rx_used);\n\n\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\n\t\ti = (i + 1) & RX_QUEUE_MASK;\n\t\t/* If there are a lot of unused frames,\n\t\t * restock the Rx queue so ucode wont assert. */\n\t\tif (fill_rx) {\n\t\t\tcount++;\n\t\t\tif (count >= 8) {\n\t\t\t\trxq->read = i;\n\t\t\t\til4965_rx_replenish_now(il);\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Backtrack one entry */\n\trxq->read = i;\n\tif (fill_rx)\n\t\til4965_rx_replenish_now(il);\n\telse\n\t\til4965_rx_queue_restock(il);\n}\n\n/* call this function to flush any scheduled tasklet */\nstatic inline void\nil4965_synchronize_irq(struct il_priv *il)\n{\n\t/* wait to make sure we flush pending tasklet */\n\tsynchronize_irq(il->pci_dev->irq);\n\ttasklet_kill(&il->irq_tasklet);\n}\n\nstatic void\nil4965_irq_tasklet(struct tasklet_struct *t)\n{\n\tstruct il_priv *il = from_tasklet(il, t, irq_tasklet);\n\tu32 inta, handled = 0;\n\tu32 inta_fh;\n\tunsigned long flags;\n\tu32 i;\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tu32 inta_mask;\n#endif\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\t/* Ack/clear/reset pending uCode interrupts.\n\t * Note:  Some bits in CSR_INT are \"OR\" of bits in CSR_FH_INT_STATUS,\n\t *  and will clear only when CSR_FH_INT_STATUS gets cleared. */\n\tinta = _il_rd(il, CSR_INT);\n\t_il_wr(il, CSR_INT, inta);\n\n\t/* Ack/clear/reset pending flow-handler (DMA) interrupts.\n\t * Any new interrupts that happen after this, either while we're\n\t * in this tasklet, or later, will show up in next ISR/tasklet. */\n\tinta_fh = _il_rd(il, CSR_FH_INT_STATUS);\n\t_il_wr(il, CSR_FH_INT_STATUS, inta_fh);\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tif (il_get_debug_level(il) & IL_DL_ISR) {\n\t\t/* just for debug */\n\t\tinta_mask = _il_rd(il, CSR_INT_MASK);\n\t\tD_ISR(\"inta 0x%08x, enabled 0x%08x, fh 0x%08x\\n\", inta,\n\t\t      inta_mask, inta_fh);\n\t}\n#endif\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\t/* Since CSR_INT and CSR_FH_INT_STATUS reads and clears are not\n\t * atomic, make sure that inta covers all the interrupts that\n\t * we've discovered, even if FH interrupt came in just after\n\t * reading CSR_INT. */\n\tif (inta_fh & CSR49_FH_INT_RX_MASK)\n\t\tinta |= CSR_INT_BIT_FH_RX;\n\tif (inta_fh & CSR49_FH_INT_TX_MASK)\n\t\tinta |= CSR_INT_BIT_FH_TX;\n\n\t/* Now service all interrupt bits discovered above. */\n\tif (inta & CSR_INT_BIT_HW_ERR) {\n\t\tIL_ERR(\"Hardware error detected.  Restarting.\\n\");\n\n\t\t/* Tell the device to stop sending interrupts */\n\t\til_disable_interrupts(il);\n\n\t\til->isr_stats.hw++;\n\t\til_irq_handle_error(il);\n\n\t\thandled |= CSR_INT_BIT_HW_ERR;\n\n\t\treturn;\n\t}\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tif (il_get_debug_level(il) & (IL_DL_ISR)) {\n\t\t/* NIC fires this, but we don't use it, redundant with WAKEUP */\n\t\tif (inta & CSR_INT_BIT_SCD) {\n\t\t\tD_ISR(\"Scheduler finished to transmit \"\n\t\t\t      \"the frame/frames.\\n\");\n\t\t\til->isr_stats.sch++;\n\t\t}\n\n\t\t/* Alive notification via Rx interrupt will do the real work */\n\t\tif (inta & CSR_INT_BIT_ALIVE) {\n\t\t\tD_ISR(\"Alive interrupt\\n\");\n\t\t\til->isr_stats.alive++;\n\t\t}\n\t}\n#endif\n\t/* Safely ignore these bits for debug checks below */\n\tinta &= ~(CSR_INT_BIT_SCD | CSR_INT_BIT_ALIVE);\n\n\t/* HW RF KILL switch toggled */\n\tif (inta & CSR_INT_BIT_RF_KILL) {\n\t\tint hw_rf_kill = 0;\n\n\t\tif (!(_il_rd(il, CSR_GP_CNTRL) & CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW))\n\t\t\thw_rf_kill = 1;\n\n\t\tIL_WARN(\"RF_KILL bit toggled to %s.\\n\",\n\t\t\thw_rf_kill ? \"disable radio\" : \"enable radio\");\n\n\t\til->isr_stats.rfkill++;\n\n\t\t/* driver only loads ucode once setting the interface up.\n\t\t * the driver allows loading the ucode even if the radio\n\t\t * is killed. Hence update the killswitch state here. The\n\t\t * rfkill handler will care about restarting if needed.\n\t\t */\n\t\tif (hw_rf_kill) {\n\t\t\tset_bit(S_RFKILL, &il->status);\n\t\t} else {\n\t\t\tclear_bit(S_RFKILL, &il->status);\n\t\t\til_force_reset(il, true);\n\t\t}\n\t\twiphy_rfkill_set_hw_state(il->hw->wiphy, hw_rf_kill);\n\n\t\thandled |= CSR_INT_BIT_RF_KILL;\n\t}\n\n\t/* Chip got too hot and stopped itself */\n\tif (inta & CSR_INT_BIT_CT_KILL) {\n\t\tIL_ERR(\"Microcode CT kill error detected.\\n\");\n\t\til->isr_stats.ctkill++;\n\t\thandled |= CSR_INT_BIT_CT_KILL;\n\t}\n\n\t/* Error detected by uCode */\n\tif (inta & CSR_INT_BIT_SW_ERR) {\n\t\tIL_ERR(\"Microcode SW error detected. \" \" Restarting 0x%X.\\n\",\n\t\t       inta);\n\t\til->isr_stats.sw++;\n\t\til_irq_handle_error(il);\n\t\thandled |= CSR_INT_BIT_SW_ERR;\n\t}\n\n\t/*\n\t * uCode wakes up after power-down sleep.\n\t * Tell device about any new tx or host commands enqueued,\n\t * and about any Rx buffers made available while asleep.\n\t */\n\tif (inta & CSR_INT_BIT_WAKEUP) {\n\t\tD_ISR(\"Wakeup interrupt\\n\");\n\t\til_rx_queue_update_write_ptr(il, &il->rxq);\n\t\tfor (i = 0; i < il->hw_params.max_txq_num; i++)\n\t\t\til_txq_update_write_ptr(il, &il->txq[i]);\n\t\til->isr_stats.wakeup++;\n\t\thandled |= CSR_INT_BIT_WAKEUP;\n\t}\n\n\t/* All uCode command responses, including Tx command responses,\n\t * Rx \"responses\" (frame-received notification), and other\n\t * notifications from uCode come through here*/\n\tif (inta & (CSR_INT_BIT_FH_RX | CSR_INT_BIT_SW_RX)) {\n\t\til4965_rx_handle(il);\n\t\til->isr_stats.rx++;\n\t\thandled |= (CSR_INT_BIT_FH_RX | CSR_INT_BIT_SW_RX);\n\t}\n\n\t/* This \"Tx\" DMA channel is used only for loading uCode */\n\tif (inta & CSR_INT_BIT_FH_TX) {\n\t\tD_ISR(\"uCode load interrupt\\n\");\n\t\til->isr_stats.tx++;\n\t\thandled |= CSR_INT_BIT_FH_TX;\n\t\t/* Wake up uCode load routine, now that load is complete */\n\t\til->ucode_write_complete = 1;\n\t\twake_up(&il->wait_command_queue);\n\t}\n\n\tif (inta & ~handled) {\n\t\tIL_ERR(\"Unhandled INTA bits 0x%08x\\n\", inta & ~handled);\n\t\til->isr_stats.unhandled++;\n\t}\n\n\tif (inta & ~(il->inta_mask)) {\n\t\tIL_WARN(\"Disabled INTA bits 0x%08x were pending\\n\",\n\t\t\tinta & ~il->inta_mask);\n\t\tIL_WARN(\"   with FH49_INT = 0x%08x\\n\", inta_fh);\n\t}\n\n\t/* Re-enable all interrupts */\n\t/* only Re-enable if disabled by irq */\n\tif (test_bit(S_INT_ENABLED, &il->status))\n\t\til_enable_interrupts(il);\n\t/* Re-enable RF_KILL if it occurred */\n\telse if (handled & CSR_INT_BIT_RF_KILL)\n\t\til_enable_rfkill_int(il);\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tif (il_get_debug_level(il) & (IL_DL_ISR)) {\n\t\tinta = _il_rd(il, CSR_INT);\n\t\tinta_mask = _il_rd(il, CSR_INT_MASK);\n\t\tinta_fh = _il_rd(il, CSR_FH_INT_STATUS);\n\t\tD_ISR(\"End inta 0x%08x, enabled 0x%08x, fh 0x%08x, \"\n\t\t      \"flags 0x%08lx\\n\", inta, inta_mask, inta_fh, flags);\n\t}\n#endif\n}\n\n/*****************************************************************************\n *\n * sysfs attributes\n *\n *****************************************************************************/\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n\n/*\n * The following adds a new attribute to the sysfs representation\n * of this device driver (i.e. a new file in /sys/class/net/wlan0/device/)\n * used for controlling the debug level.\n *\n * See the level definitions in iwl for details.\n *\n * The debug_level being managed using sysfs below is a per device debug\n * level that is used instead of the global debug level if it (the per\n * device debug level) is set.\n */\nstatic ssize_t\nil4965_show_debug_level(struct device *d, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\treturn sprintf(buf, \"0x%08X\\n\", il_get_debug_level(il));\n}\n\nstatic ssize_t\nil4965_store_debug_level(struct device *d, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &val);\n\tif (ret)\n\t\tIL_ERR(\"%s is not in hex or decimal form.\\n\", buf);\n\telse\n\t\til->debug_level = val;\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(debug_level, 0644, il4965_show_debug_level,\n\t\t   il4965_store_debug_level);\n\n#endif /* CONFIG_IWLEGACY_DEBUG */\n\nstatic ssize_t\nil4965_show_temperature(struct device *d, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\n\tif (!il_is_alive(il))\n\t\treturn -EAGAIN;\n\n\treturn sprintf(buf, \"%d\\n\", il->temperature);\n}\n\nstatic DEVICE_ATTR(temperature, 0444, il4965_show_temperature, NULL);\n\nstatic ssize_t\nil4965_show_tx_power(struct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\n\tif (!il_is_ready_rf(il))\n\t\treturn sprintf(buf, \"off\\n\");\n\telse\n\t\treturn sprintf(buf, \"%d\\n\", il->tx_power_user_lmt);\n}\n\nstatic ssize_t\nil4965_store_tx_power(struct device *d, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\tIL_INFO(\"%s is not in decimal form.\\n\", buf);\n\telse {\n\t\tret = il_set_tx_power(il, val, false);\n\t\tif (ret)\n\t\t\tIL_ERR(\"failed setting tx power (0x%08x).\\n\", ret);\n\t\telse\n\t\t\tret = count;\n\t}\n\treturn ret;\n}\n\nstatic DEVICE_ATTR(tx_power, 0644, il4965_show_tx_power,\n\t\t   il4965_store_tx_power);\n\nstatic struct attribute *il_sysfs_entries[] = {\n\t&dev_attr_temperature.attr,\n\t&dev_attr_tx_power.attr,\n#ifdef CONFIG_IWLEGACY_DEBUG\n\t&dev_attr_debug_level.attr,\n#endif\n\tNULL\n};\n\nstatic const struct attribute_group il_attribute_group = {\n\t.name = NULL,\t\t/* put in device directory */\n\t.attrs = il_sysfs_entries,\n};\n\n/******************************************************************************\n *\n * uCode download functions\n *\n ******************************************************************************/\n\nstatic void\nil4965_dealloc_ucode_pci(struct il_priv *il)\n{\n\til_free_fw_desc(il->pci_dev, &il->ucode_code);\n\til_free_fw_desc(il->pci_dev, &il->ucode_data);\n\til_free_fw_desc(il->pci_dev, &il->ucode_data_backup);\n\til_free_fw_desc(il->pci_dev, &il->ucode_init);\n\til_free_fw_desc(il->pci_dev, &il->ucode_init_data);\n\til_free_fw_desc(il->pci_dev, &il->ucode_boot);\n}\n\nstatic void\nil4965_nic_start(struct il_priv *il)\n{\n\t/* Remove all resets to allow NIC to operate */\n\t_il_wr(il, CSR_RESET, 0);\n}\n\nstatic void il4965_ucode_callback(const struct firmware *ucode_raw,\n\t\t\t\t  void *context);\nstatic int il4965_mac_setup_register(struct il_priv *il, u32 max_probe_length);\n\nstatic int __must_check\nil4965_request_firmware(struct il_priv *il, bool first)\n{\n\tconst char *name_pre = il->cfg->fw_name_pre;\n\tchar tag[8];\n\n\tif (first) {\n\t\til->fw_idx = il->cfg->ucode_api_max;\n\t\tsprintf(tag, \"%d\", il->fw_idx);\n\t} else {\n\t\til->fw_idx--;\n\t\tsprintf(tag, \"%d\", il->fw_idx);\n\t}\n\n\tif (il->fw_idx < il->cfg->ucode_api_min) {\n\t\tIL_ERR(\"no suitable firmware found!\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tsprintf(il->firmware_name, \"%s%s%s\", name_pre, tag, \".ucode\");\n\n\tD_INFO(\"attempting to load firmware '%s'\\n\", il->firmware_name);\n\n\treturn request_firmware_nowait(THIS_MODULE, 1, il->firmware_name,\n\t\t\t\t       &il->pci_dev->dev, GFP_KERNEL, il,\n\t\t\t\t       il4965_ucode_callback);\n}\n\nstruct il4965_firmware_pieces {\n\tconst void *inst, *data, *init, *init_data, *boot;\n\tsize_t inst_size, data_size, init_size, init_data_size, boot_size;\n};\n\nstatic int\nil4965_load_firmware(struct il_priv *il, const struct firmware *ucode_raw,\n\t\t     struct il4965_firmware_pieces *pieces)\n{\n\tstruct il_ucode_header *ucode = (void *)ucode_raw->data;\n\tu32 api_ver, hdr_size;\n\tconst u8 *src;\n\n\til->ucode_ver = le32_to_cpu(ucode->ver);\n\tapi_ver = IL_UCODE_API(il->ucode_ver);\n\n\tswitch (api_ver) {\n\tdefault:\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\thdr_size = 24;\n\t\tif (ucode_raw->size < hdr_size) {\n\t\t\tIL_ERR(\"File size too small!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpieces->inst_size = le32_to_cpu(ucode->v1.inst_size);\n\t\tpieces->data_size = le32_to_cpu(ucode->v1.data_size);\n\t\tpieces->init_size = le32_to_cpu(ucode->v1.init_size);\n\t\tpieces->init_data_size = le32_to_cpu(ucode->v1.init_data_size);\n\t\tpieces->boot_size = le32_to_cpu(ucode->v1.boot_size);\n\t\tsrc = ucode->v1.data;\n\t\tbreak;\n\t}\n\n\t/* Verify size of file vs. image size info in file's header */\n\tif (ucode_raw->size !=\n\t    hdr_size + pieces->inst_size + pieces->data_size +\n\t    pieces->init_size + pieces->init_data_size + pieces->boot_size) {\n\n\t\tIL_ERR(\"uCode file size %d does not match expected size\\n\",\n\t\t       (int)ucode_raw->size);\n\t\treturn -EINVAL;\n\t}\n\n\tpieces->inst = src;\n\tsrc += pieces->inst_size;\n\tpieces->data = src;\n\tsrc += pieces->data_size;\n\tpieces->init = src;\n\tsrc += pieces->init_size;\n\tpieces->init_data = src;\n\tsrc += pieces->init_data_size;\n\tpieces->boot = src;\n\tsrc += pieces->boot_size;\n\n\treturn 0;\n}\n\n/*\n * il4965_ucode_callback - callback when firmware was loaded\n *\n * If loaded successfully, copies the firmware into buffers\n * for the card to fetch (via DMA).\n */\nstatic void\nil4965_ucode_callback(const struct firmware *ucode_raw, void *context)\n{\n\tstruct il_priv *il = context;\n\tint err;\n\tstruct il4965_firmware_pieces pieces;\n\tconst unsigned int api_max = il->cfg->ucode_api_max;\n\tconst unsigned int api_min = il->cfg->ucode_api_min;\n\tu32 api_ver;\n\n\tu32 max_probe_length = 200;\n\tu32 standard_phy_calibration_size =\n\t    IL_DEFAULT_STANDARD_PHY_CALIBRATE_TBL_SIZE;\n\n\tmemset(&pieces, 0, sizeof(pieces));\n\n\tif (!ucode_raw) {\n\t\tif (il->fw_idx <= il->cfg->ucode_api_max)\n\t\t\tIL_ERR(\"request for firmware file '%s' failed.\\n\",\n\t\t\t       il->firmware_name);\n\t\tgoto try_again;\n\t}\n\n\tD_INFO(\"Loaded firmware file '%s' (%zd bytes).\\n\", il->firmware_name,\n\t       ucode_raw->size);\n\n\t/* Make sure that we got at least the API version number */\n\tif (ucode_raw->size < 4) {\n\t\tIL_ERR(\"File size way too small!\\n\");\n\t\tgoto try_again;\n\t}\n\n\t/* Data from ucode file:  header followed by uCode images */\n\terr = il4965_load_firmware(il, ucode_raw, &pieces);\n\n\tif (err)\n\t\tgoto try_again;\n\n\tapi_ver = IL_UCODE_API(il->ucode_ver);\n\n\t/*\n\t * api_ver should match the api version forming part of the\n\t * firmware filename ... but we don't check for that and only rely\n\t * on the API version read from firmware header from here on forward\n\t */\n\tif (api_ver < api_min || api_ver > api_max) {\n\t\tIL_ERR(\"Driver unable to support your firmware API. \"\n\t\t       \"Driver supports v%u, firmware is v%u.\\n\", api_max,\n\t\t       api_ver);\n\t\tgoto try_again;\n\t}\n\n\tif (api_ver != api_max)\n\t\tIL_ERR(\"Firmware has old API version. Expected v%u, \"\n\t\t       \"got v%u. New firmware can be obtained \"\n\t\t       \"from http://www.intellinuxwireless.org.\\n\", api_max,\n\t\t       api_ver);\n\n\tIL_INFO(\"loaded firmware version %u.%u.%u.%u\\n\",\n\t\tIL_UCODE_MAJOR(il->ucode_ver), IL_UCODE_MINOR(il->ucode_ver),\n\t\tIL_UCODE_API(il->ucode_ver), IL_UCODE_SERIAL(il->ucode_ver));\n\n\tsnprintf(il->hw->wiphy->fw_version, sizeof(il->hw->wiphy->fw_version),\n\t\t \"%u.%u.%u.%u\", IL_UCODE_MAJOR(il->ucode_ver),\n\t\t IL_UCODE_MINOR(il->ucode_ver), IL_UCODE_API(il->ucode_ver),\n\t\t IL_UCODE_SERIAL(il->ucode_ver));\n\n\t/*\n\t * For any of the failures below (before allocating pci memory)\n\t * we will try to load a version with a smaller API -- maybe the\n\t * user just got a corrupted version of the latest API.\n\t */\n\n\tD_INFO(\"f/w package hdr ucode version raw = 0x%x\\n\", il->ucode_ver);\n\tD_INFO(\"f/w package hdr runtime inst size = %zd\\n\", pieces.inst_size);\n\tD_INFO(\"f/w package hdr runtime data size = %zd\\n\", pieces.data_size);\n\tD_INFO(\"f/w package hdr init inst size = %zd\\n\", pieces.init_size);\n\tD_INFO(\"f/w package hdr init data size = %zd\\n\", pieces.init_data_size);\n\tD_INFO(\"f/w package hdr boot inst size = %zd\\n\", pieces.boot_size);\n\n\t/* Verify that uCode images will fit in card's SRAM */\n\tif (pieces.inst_size > il->hw_params.max_inst_size) {\n\t\tIL_ERR(\"uCode instr len %zd too large to fit in\\n\",\n\t\t       pieces.inst_size);\n\t\tgoto try_again;\n\t}\n\n\tif (pieces.data_size > il->hw_params.max_data_size) {\n\t\tIL_ERR(\"uCode data len %zd too large to fit in\\n\",\n\t\t       pieces.data_size);\n\t\tgoto try_again;\n\t}\n\n\tif (pieces.init_size > il->hw_params.max_inst_size) {\n\t\tIL_ERR(\"uCode init instr len %zd too large to fit in\\n\",\n\t\t       pieces.init_size);\n\t\tgoto try_again;\n\t}\n\n\tif (pieces.init_data_size > il->hw_params.max_data_size) {\n\t\tIL_ERR(\"uCode init data len %zd too large to fit in\\n\",\n\t\t       pieces.init_data_size);\n\t\tgoto try_again;\n\t}\n\n\tif (pieces.boot_size > il->hw_params.max_bsm_size) {\n\t\tIL_ERR(\"uCode boot instr len %zd too large to fit in\\n\",\n\t\t       pieces.boot_size);\n\t\tgoto try_again;\n\t}\n\n\t/* Allocate ucode buffers for card's bus-master loading ... */\n\n\t/* Runtime instructions and 2 copies of data:\n\t * 1) unmodified from disk\n\t * 2) backup cache for save/restore during power-downs */\n\til->ucode_code.len = pieces.inst_size;\n\til_alloc_fw_desc(il->pci_dev, &il->ucode_code);\n\n\til->ucode_data.len = pieces.data_size;\n\til_alloc_fw_desc(il->pci_dev, &il->ucode_data);\n\n\til->ucode_data_backup.len = pieces.data_size;\n\til_alloc_fw_desc(il->pci_dev, &il->ucode_data_backup);\n\n\tif (!il->ucode_code.v_addr || !il->ucode_data.v_addr ||\n\t    !il->ucode_data_backup.v_addr)\n\t\tgoto err_pci_alloc;\n\n\t/* Initialization instructions and data */\n\tif (pieces.init_size && pieces.init_data_size) {\n\t\til->ucode_init.len = pieces.init_size;\n\t\til_alloc_fw_desc(il->pci_dev, &il->ucode_init);\n\n\t\til->ucode_init_data.len = pieces.init_data_size;\n\t\til_alloc_fw_desc(il->pci_dev, &il->ucode_init_data);\n\n\t\tif (!il->ucode_init.v_addr || !il->ucode_init_data.v_addr)\n\t\t\tgoto err_pci_alloc;\n\t}\n\n\t/* Bootstrap (instructions only, no data) */\n\tif (pieces.boot_size) {\n\t\til->ucode_boot.len = pieces.boot_size;\n\t\til_alloc_fw_desc(il->pci_dev, &il->ucode_boot);\n\n\t\tif (!il->ucode_boot.v_addr)\n\t\t\tgoto err_pci_alloc;\n\t}\n\n\t/* Now that we can no longer fail, copy information */\n\n\til->sta_key_max_num = STA_KEY_MAX_NUM;\n\n\t/* Copy images into buffers for card's bus-master reads ... */\n\n\t/* Runtime instructions (first block of data in file) */\n\tD_INFO(\"Copying (but not loading) uCode instr len %zd\\n\",\n\t       pieces.inst_size);\n\tmemcpy(il->ucode_code.v_addr, pieces.inst, pieces.inst_size);\n\n\tD_INFO(\"uCode instr buf vaddr = 0x%p, paddr = 0x%08x\\n\",\n\t       il->ucode_code.v_addr, (u32) il->ucode_code.p_addr);\n\n\t/*\n\t * Runtime data\n\t * NOTE:  Copy into backup buffer will be done in il_up()\n\t */\n\tD_INFO(\"Copying (but not loading) uCode data len %zd\\n\",\n\t       pieces.data_size);\n\tmemcpy(il->ucode_data.v_addr, pieces.data, pieces.data_size);\n\tmemcpy(il->ucode_data_backup.v_addr, pieces.data, pieces.data_size);\n\n\t/* Initialization instructions */\n\tif (pieces.init_size) {\n\t\tD_INFO(\"Copying (but not loading) init instr len %zd\\n\",\n\t\t       pieces.init_size);\n\t\tmemcpy(il->ucode_init.v_addr, pieces.init, pieces.init_size);\n\t}\n\n\t/* Initialization data */\n\tif (pieces.init_data_size) {\n\t\tD_INFO(\"Copying (but not loading) init data len %zd\\n\",\n\t\t       pieces.init_data_size);\n\t\tmemcpy(il->ucode_init_data.v_addr, pieces.init_data,\n\t\t       pieces.init_data_size);\n\t}\n\n\t/* Bootstrap instructions */\n\tD_INFO(\"Copying (but not loading) boot instr len %zd\\n\",\n\t       pieces.boot_size);\n\tmemcpy(il->ucode_boot.v_addr, pieces.boot, pieces.boot_size);\n\n\t/*\n\t * figure out the offset of chain noise reset and gain commands\n\t * base on the size of standard phy calibration commands table size\n\t */\n\til->_4965.phy_calib_chain_noise_reset_cmd =\n\t    standard_phy_calibration_size;\n\til->_4965.phy_calib_chain_noise_gain_cmd =\n\t    standard_phy_calibration_size + 1;\n\n\t/**************************************************\n\t * This is still part of probe() in a sense...\n\t *\n\t * 9. Setup and register with mac80211 and debugfs\n\t **************************************************/\n\terr = il4965_mac_setup_register(il, max_probe_length);\n\tif (err)\n\t\tgoto out_unbind;\n\n\til_dbgfs_register(il, DRV_NAME);\n\n\terr = sysfs_create_group(&il->pci_dev->dev.kobj, &il_attribute_group);\n\tif (err) {\n\t\tIL_ERR(\"failed to create sysfs device attributes\\n\");\n\t\tgoto out_unbind;\n\t}\n\n\t/* We have our copies now, allow OS release its copies */\n\trelease_firmware(ucode_raw);\n\tcomplete(&il->_4965.firmware_loading_complete);\n\treturn;\n\ntry_again:\n\t/* try next, if any */\n\tif (il4965_request_firmware(il, false))\n\t\tgoto out_unbind;\n\trelease_firmware(ucode_raw);\n\treturn;\n\nerr_pci_alloc:\n\tIL_ERR(\"failed to allocate pci memory\\n\");\n\til4965_dealloc_ucode_pci(il);\nout_unbind:\n\tcomplete(&il->_4965.firmware_loading_complete);\n\tdevice_release_driver(&il->pci_dev->dev);\n\trelease_firmware(ucode_raw);\n}\n\nstatic const char *const desc_lookup_text[] = {\n\t\"OK\",\n\t\"FAIL\",\n\t\"BAD_PARAM\",\n\t\"BAD_CHECKSUM\",\n\t\"NMI_INTERRUPT_WDG\",\n\t\"SYSASSERT\",\n\t\"FATAL_ERROR\",\n\t\"BAD_COMMAND\",\n\t\"HW_ERROR_TUNE_LOCK\",\n\t\"HW_ERROR_TEMPERATURE\",\n\t\"ILLEGAL_CHAN_FREQ\",\n\t\"VCC_NOT_STBL\",\n\t\"FH49_ERROR\",\n\t\"NMI_INTERRUPT_HOST\",\n\t\"NMI_INTERRUPT_ACTION_PT\",\n\t\"NMI_INTERRUPT_UNKNOWN\",\n\t\"UCODE_VERSION_MISMATCH\",\n\t\"HW_ERROR_ABS_LOCK\",\n\t\"HW_ERROR_CAL_LOCK_FAIL\",\n\t\"NMI_INTERRUPT_INST_ACTION_PT\",\n\t\"NMI_INTERRUPT_DATA_ACTION_PT\",\n\t\"NMI_TRM_HW_ER\",\n\t\"NMI_INTERRUPT_TRM\",\n\t\"NMI_INTERRUPT_BREAK_POINT\",\n\t\"DEBUG_0\",\n\t\"DEBUG_1\",\n\t\"DEBUG_2\",\n\t\"DEBUG_3\",\n};\n\nstatic struct {\n\tchar *name;\n\tu8 num;\n} advanced_lookup[] = {\n\t{\n\t\"NMI_INTERRUPT_WDG\", 0x34}, {\n\t\"SYSASSERT\", 0x35}, {\n\t\"UCODE_VERSION_MISMATCH\", 0x37}, {\n\t\"BAD_COMMAND\", 0x38}, {\n\t\"NMI_INTERRUPT_DATA_ACTION_PT\", 0x3C}, {\n\t\"FATAL_ERROR\", 0x3D}, {\n\t\"NMI_TRM_HW_ERR\", 0x46}, {\n\t\"NMI_INTERRUPT_TRM\", 0x4C}, {\n\t\"NMI_INTERRUPT_BREAK_POINT\", 0x54}, {\n\t\"NMI_INTERRUPT_WDG_RXF_FULL\", 0x5C}, {\n\t\"NMI_INTERRUPT_WDG_NO_RBD_RXF_FULL\", 0x64}, {\n\t\"NMI_INTERRUPT_HOST\", 0x66}, {\n\t\"NMI_INTERRUPT_ACTION_PT\", 0x7C}, {\n\t\"NMI_INTERRUPT_UNKNOWN\", 0x84}, {\n\t\"NMI_INTERRUPT_INST_ACTION_PT\", 0x86}, {\n\"ADVANCED_SYSASSERT\", 0},};\n\nstatic const char *\nil4965_desc_lookup(u32 num)\n{\n\tint i;\n\tint max = ARRAY_SIZE(desc_lookup_text);\n\n\tif (num < max)\n\t\treturn desc_lookup_text[num];\n\n\tmax = ARRAY_SIZE(advanced_lookup) - 1;\n\tfor (i = 0; i < max; i++) {\n\t\tif (advanced_lookup[i].num == num)\n\t\t\tbreak;\n\t}\n\treturn advanced_lookup[i].name;\n}\n\n#define ERROR_START_OFFSET  (1 * sizeof(u32))\n#define ERROR_ELEM_SIZE     (7 * sizeof(u32))\n\nvoid\nil4965_dump_nic_error_log(struct il_priv *il)\n{\n\tu32 data2, line;\n\tu32 desc, time, count, base, data1;\n\tu32 blink1, blink2, ilink1, ilink2;\n\tu32 pc, hcmd;\n\n\tif (il->ucode_type == UCODE_INIT)\n\t\tbase = le32_to_cpu(il->card_alive_init.error_event_table_ptr);\n\telse\n\t\tbase = le32_to_cpu(il->card_alive.error_event_table_ptr);\n\n\tif (!il->ops->is_valid_rtc_data_addr(base)) {\n\t\tIL_ERR(\"Not valid error log pointer 0x%08X for %s uCode\\n\",\n\t\t       base, (il->ucode_type == UCODE_INIT) ? \"Init\" : \"RT\");\n\t\treturn;\n\t}\n\n\tcount = il_read_targ_mem(il, base);\n\n\tif (ERROR_START_OFFSET <= count * ERROR_ELEM_SIZE) {\n\t\tIL_ERR(\"Start IWL Error Log Dump:\\n\");\n\t\tIL_ERR(\"Status: 0x%08lX, count: %d\\n\", il->status, count);\n\t}\n\n\tdesc = il_read_targ_mem(il, base + 1 * sizeof(u32));\n\til->isr_stats.err_code = desc;\n\tpc = il_read_targ_mem(il, base + 2 * sizeof(u32));\n\tblink1 = il_read_targ_mem(il, base + 3 * sizeof(u32));\n\tblink2 = il_read_targ_mem(il, base + 4 * sizeof(u32));\n\tilink1 = il_read_targ_mem(il, base + 5 * sizeof(u32));\n\tilink2 = il_read_targ_mem(il, base + 6 * sizeof(u32));\n\tdata1 = il_read_targ_mem(il, base + 7 * sizeof(u32));\n\tdata2 = il_read_targ_mem(il, base + 8 * sizeof(u32));\n\tline = il_read_targ_mem(il, base + 9 * sizeof(u32));\n\ttime = il_read_targ_mem(il, base + 11 * sizeof(u32));\n\thcmd = il_read_targ_mem(il, base + 22 * sizeof(u32));\n\n\tIL_ERR(\"Desc                                  Time       \"\n\t       \"data1      data2      line\\n\");\n\tIL_ERR(\"%-28s (0x%04X) %010u 0x%08X 0x%08X %u\\n\",\n\t       il4965_desc_lookup(desc), desc, time, data1, data2, line);\n\tIL_ERR(\"pc      blink1  blink2  ilink1  ilink2  hcmd\\n\");\n\tIL_ERR(\"0x%05X 0x%05X 0x%05X 0x%05X 0x%05X 0x%05X\\n\", pc, blink1,\n\t       blink2, ilink1, ilink2, hcmd);\n}\n\nstatic void\nil4965_rf_kill_ct_config(struct il_priv *il)\n{\n\tstruct il_ct_kill_config cmd;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\t_il_wr(il, CSR_UCODE_DRV_GP1_CLR,\n\t       CSR_UCODE_DRV_GP1_REG_BIT_CT_KILL_EXIT);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\tcmd.critical_temperature_R =\n\t    cpu_to_le32(il->hw_params.ct_kill_threshold);\n\n\tret = il_send_cmd_pdu(il, C_CT_KILL_CONFIG, sizeof(cmd), &cmd);\n\tif (ret)\n\t\tIL_ERR(\"C_CT_KILL_CONFIG failed\\n\");\n\telse\n\t\tD_INFO(\"C_CT_KILL_CONFIG \" \"succeeded, \"\n\t\t       \"critical temperature is %d\\n\",\n\t\t       il->hw_params.ct_kill_threshold);\n}\n\nstatic const s8 default_queue_to_tx_fifo[] = {\n\tIL_TX_FIFO_VO,\n\tIL_TX_FIFO_VI,\n\tIL_TX_FIFO_BE,\n\tIL_TX_FIFO_BK,\n\tIL49_CMD_FIFO_NUM,\n\tIL_TX_FIFO_UNUSED,\n\tIL_TX_FIFO_UNUSED,\n};\n\n#define IL_MASK(lo, hi) ((1 << (hi)) | ((1 << (hi)) - (1 << (lo))))\n\nstatic int\nil4965_alive_notify(struct il_priv *il)\n{\n\tu32 a;\n\tunsigned long flags;\n\tint i, chan;\n\tu32 reg_val;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\t/* Clear 4965's internal Tx Scheduler data base */\n\til->scd_base_addr = il_rd_prph(il, IL49_SCD_SRAM_BASE_ADDR);\n\ta = il->scd_base_addr + IL49_SCD_CONTEXT_DATA_OFFSET;\n\tfor (; a < il->scd_base_addr + IL49_SCD_TX_STTS_BITMAP_OFFSET; a += 4)\n\t\til_write_targ_mem(il, a, 0);\n\tfor (; a < il->scd_base_addr + IL49_SCD_TRANSLATE_TBL_OFFSET; a += 4)\n\t\til_write_targ_mem(il, a, 0);\n\tfor (;\n\t     a <\n\t     il->scd_base_addr +\n\t     IL49_SCD_TRANSLATE_TBL_OFFSET_QUEUE(il->hw_params.max_txq_num);\n\t     a += 4)\n\t\til_write_targ_mem(il, a, 0);\n\n\t/* Tel 4965 where to find Tx byte count tables */\n\til_wr_prph(il, IL49_SCD_DRAM_BASE_ADDR, il->scd_bc_tbls.dma >> 10);\n\n\t/* Enable DMA channel */\n\tfor (chan = 0; chan < FH49_TCSR_CHNL_NUM; chan++)\n\t\til_wr(il, FH49_TCSR_CHNL_TX_CONFIG_REG(chan),\n\t\t      FH49_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE |\n\t\t      FH49_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_ENABLE);\n\n\t/* Update FH chicken bits */\n\treg_val = il_rd(il, FH49_TX_CHICKEN_BITS_REG);\n\til_wr(il, FH49_TX_CHICKEN_BITS_REG,\n\t      reg_val | FH49_TX_CHICKEN_BITS_SCD_AUTO_RETRY_EN);\n\n\t/* Disable chain mode for all queues */\n\til_wr_prph(il, IL49_SCD_QUEUECHAIN_SEL, 0);\n\n\t/* Initialize each Tx queue (including the command queue) */\n\tfor (i = 0; i < il->hw_params.max_txq_num; i++) {\n\n\t\t/* TFD circular buffer read/write idxes */\n\t\til_wr_prph(il, IL49_SCD_QUEUE_RDPTR(i), 0);\n\t\til_wr(il, HBUS_TARG_WRPTR, 0 | (i << 8));\n\n\t\t/* Max Tx Window size for Scheduler-ACK mode */\n\t\til_write_targ_mem(il,\n\t\t\t\t  il->scd_base_addr +\n\t\t\t\t  IL49_SCD_CONTEXT_QUEUE_OFFSET(i),\n\t\t\t\t  (SCD_WIN_SIZE <<\n\t\t\t\t   IL49_SCD_QUEUE_CTX_REG1_WIN_SIZE_POS) &\n\t\t\t\t  IL49_SCD_QUEUE_CTX_REG1_WIN_SIZE_MSK);\n\n\t\t/* Frame limit */\n\t\til_write_targ_mem(il,\n\t\t\t\t  il->scd_base_addr +\n\t\t\t\t  IL49_SCD_CONTEXT_QUEUE_OFFSET(i) +\n\t\t\t\t  sizeof(u32),\n\t\t\t\t  (SCD_FRAME_LIMIT <<\n\t\t\t\t   IL49_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_POS) &\n\t\t\t\t  IL49_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_MSK);\n\n\t}\n\til_wr_prph(il, IL49_SCD_INTERRUPT_MASK,\n\t\t   (1 << il->hw_params.max_txq_num) - 1);\n\n\t/* Activate all Tx DMA/FIFO channels */\n\til4965_txq_set_sched(il, IL_MASK(0, 6));\n\n\til4965_set_wr_ptrs(il, IL_DEFAULT_CMD_QUEUE_NUM, 0);\n\n\t/* make sure all queue are not stopped */\n\tmemset(&il->queue_stopped[0], 0, sizeof(il->queue_stopped));\n\tfor (i = 0; i < 4; i++)\n\t\tatomic_set(&il->queue_stop_count[i], 0);\n\n\t/* reset to 0 to enable all the queue first */\n\til->txq_ctx_active_msk = 0;\n\t/* Map each Tx/cmd queue to its corresponding fifo */\n\tBUILD_BUG_ON(ARRAY_SIZE(default_queue_to_tx_fifo) != 7);\n\n\tfor (i = 0; i < ARRAY_SIZE(default_queue_to_tx_fifo); i++) {\n\t\tint ac = default_queue_to_tx_fifo[i];\n\n\t\til_txq_ctx_activate(il, i);\n\n\t\tif (ac == IL_TX_FIFO_UNUSED)\n\t\t\tcontinue;\n\n\t\til4965_tx_queue_set_status(il, &il->txq[i], ac, 0);\n\t}\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\treturn 0;\n}\n\n/*\n * il4965_alive_start - called after N_ALIVE notification received\n *                   from protocol/runtime uCode (initialization uCode's\n *                   Alive gets handled by il_init_alive_start()).\n */\nstatic void\nil4965_alive_start(struct il_priv *il)\n{\n\tint ret = 0;\n\n\tD_INFO(\"Runtime Alive received.\\n\");\n\n\tif (il->card_alive.is_valid != UCODE_VALID_OK) {\n\t\t/* We had an error bringing up the hardware, so take it\n\t\t * all the way back down so we can try again */\n\t\tD_INFO(\"Alive failed.\\n\");\n\t\tgoto restart;\n\t}\n\n\t/* Initialize uCode has loaded Runtime uCode ... verify inst image.\n\t * This is a paranoid check, because we would not have gotten the\n\t * \"runtime\" alive if code weren't properly loaded.  */\n\tif (il4965_verify_ucode(il)) {\n\t\t/* Runtime instruction load was bad;\n\t\t * take it all the way back down so we can try again */\n\t\tD_INFO(\"Bad runtime uCode load.\\n\");\n\t\tgoto restart;\n\t}\n\n\tret = il4965_alive_notify(il);\n\tif (ret) {\n\t\tIL_WARN(\"Could not complete ALIVE transition [ntf]: %d\\n\", ret);\n\t\tgoto restart;\n\t}\n\n\t/* After the ALIVE response, we can send host commands to the uCode */\n\tset_bit(S_ALIVE, &il->status);\n\n\t/* Enable watchdog to monitor the driver tx queues */\n\til_setup_watchdog(il);\n\n\tif (il_is_rfkill(il))\n\t\treturn;\n\n\tieee80211_wake_queues(il->hw);\n\n\til->active_rate = RATES_MASK;\n\n\til_power_update_mode(il, true);\n\tD_INFO(\"Updated power mode\\n\");\n\n\tif (il_is_associated(il)) {\n\t\tstruct il_rxon_cmd *active_rxon =\n\t\t    (struct il_rxon_cmd *)&il->active;\n\t\t/* apply any changes in staging */\n\t\til->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\n\t\tactive_rxon->filter_flags &= ~RXON_FILTER_ASSOC_MSK;\n\t} else {\n\t\t/* Initialize our rx_config data */\n\t\til_connection_init_rx_config(il);\n\n\t\tif (il->ops->set_rxon_chain)\n\t\t\til->ops->set_rxon_chain(il);\n\t}\n\n\t/* Configure bluetooth coexistence if enabled */\n\til_send_bt_config(il);\n\n\til4965_reset_run_time_calib(il);\n\n\tset_bit(S_READY, &il->status);\n\n\t/* Configure the adapter for unassociated operation */\n\til_commit_rxon(il);\n\n\t/* At this point, the NIC is initialized and operational */\n\til4965_rf_kill_ct_config(il);\n\n\tD_INFO(\"ALIVE processing complete.\\n\");\n\twake_up(&il->wait_command_queue);\n\n\treturn;\n\nrestart:\n\tqueue_work(il->workqueue, &il->restart);\n}\n\nstatic void il4965_cancel_deferred_work(struct il_priv *il);\n\nstatic void\n__il4965_down(struct il_priv *il)\n{\n\tunsigned long flags;\n\tint exit_pending;\n\n\tD_INFO(DRV_NAME \" is going down\\n\");\n\n\til_scan_cancel_timeout(il, 200);\n\n\texit_pending = test_and_set_bit(S_EXIT_PENDING, &il->status);\n\n\t/* Stop TX queues watchdog. We need to have S_EXIT_PENDING bit set\n\t * to prevent rearm timer */\n\tdel_timer_sync(&il->watchdog);\n\n\til_clear_ucode_stations(il);\n\n\t/* FIXME: race conditions ? */\n\tspin_lock_irq(&il->sta_lock);\n\t/*\n\t * Remove all key information that is not stored as part\n\t * of station information since mac80211 may not have had\n\t * a chance to remove all the keys. When device is\n\t * reconfigured by mac80211 after an error all keys will\n\t * be reconfigured.\n\t */\n\tmemset(il->_4965.wep_keys, 0, sizeof(il->_4965.wep_keys));\n\til->_4965.key_mapping_keys = 0;\n\tspin_unlock_irq(&il->sta_lock);\n\n\til_dealloc_bcast_stations(il);\n\til_clear_driver_stations(il);\n\n\t/* Unblock any waiting calls */\n\twake_up_all(&il->wait_command_queue);\n\n\t/* Wipe out the EXIT_PENDING status bit if we are not actually\n\t * exiting the module */\n\tif (!exit_pending)\n\t\tclear_bit(S_EXIT_PENDING, &il->status);\n\n\t/* stop and reset the on-board processor */\n\t_il_wr(il, CSR_RESET, CSR_RESET_REG_FLAG_NEVO_RESET);\n\n\t/* tell the device to stop sending interrupts */\n\tspin_lock_irqsave(&il->lock, flags);\n\til_disable_interrupts(il);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\til4965_synchronize_irq(il);\n\n\tif (il->mac80211_registered)\n\t\tieee80211_stop_queues(il->hw);\n\n\t/* If we have not previously called il_init() then\n\t * clear all bits but the RF Kill bit and return */\n\tif (!il_is_init(il)) {\n\t\til->status =\n\t\t    test_bit(S_RFKILL, &il->status) << S_RFKILL |\n\t\t    test_bit(S_GEO_CONFIGURED, &il->status) << S_GEO_CONFIGURED |\n\t\t    test_bit(S_EXIT_PENDING, &il->status) << S_EXIT_PENDING;\n\t\tgoto exit;\n\t}\n\n\t/* ...otherwise clear out all the status bits but the RF Kill\n\t * bit and continue taking the NIC down. */\n\til->status &=\n\t    test_bit(S_RFKILL, &il->status) << S_RFKILL |\n\t    test_bit(S_GEO_CONFIGURED, &il->status) << S_GEO_CONFIGURED |\n\t    test_bit(S_FW_ERROR, &il->status) << S_FW_ERROR |\n\t    test_bit(S_EXIT_PENDING, &il->status) << S_EXIT_PENDING;\n\n\t/*\n\t * We disabled and synchronized interrupt, and priv->mutex is taken, so\n\t * here is the only thread which will program device registers, but\n\t * still have lockdep assertions, so we are taking reg_lock.\n\t */\n\tspin_lock_irq(&il->reg_lock);\n\t/* FIXME: il_grab_nic_access if rfkill is off ? */\n\n\til4965_txq_ctx_stop(il);\n\til4965_rxq_stop(il);\n\t/* Power-down device's busmaster DMA clocks */\n\t_il_wr_prph(il, APMG_CLK_DIS_REG, APMG_CLK_VAL_DMA_CLK_RQT);\n\tudelay(5);\n\t/* Make sure (redundant) we've released our request to stay awake */\n\t_il_clear_bit(il, CSR_GP_CNTRL, CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);\n\t/* Stop the device, and put it in low power state */\n\t_il_apm_stop(il);\n\n\tspin_unlock_irq(&il->reg_lock);\n\n\til4965_txq_ctx_unmap(il);\nexit:\n\tmemset(&il->card_alive, 0, sizeof(struct il_alive_resp));\n\n\tdev_kfree_skb(il->beacon_skb);\n\til->beacon_skb = NULL;\n\n\t/* clear out any free frames */\n\til4965_clear_free_frames(il);\n}\n\nstatic void\nil4965_down(struct il_priv *il)\n{\n\tmutex_lock(&il->mutex);\n\t__il4965_down(il);\n\tmutex_unlock(&il->mutex);\n\n\til4965_cancel_deferred_work(il);\n}\n\n\nstatic void\nil4965_set_hw_ready(struct il_priv *il)\n{\n\tint ret;\n\n\til_set_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t   CSR_HW_IF_CONFIG_REG_BIT_NIC_READY);\n\n\t/* See if we got it */\n\tret = _il_poll_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t\t   CSR_HW_IF_CONFIG_REG_BIT_NIC_READY,\n\t\t\t   CSR_HW_IF_CONFIG_REG_BIT_NIC_READY,\n\t\t\t   100);\n\tif (ret >= 0)\n\t\til->hw_ready = true;\n\n\tD_INFO(\"hardware %s ready\\n\", (il->hw_ready) ? \"\" : \"not\");\n}\n\nstatic void\nil4965_prepare_card_hw(struct il_priv *il)\n{\n\tint ret;\n\n\til->hw_ready = false;\n\n\til4965_set_hw_ready(il);\n\tif (il->hw_ready)\n\t\treturn;\n\n\t/* If HW is not ready, prepare the conditions to check again */\n\til_set_bit(il, CSR_HW_IF_CONFIG_REG, CSR_HW_IF_CONFIG_REG_PREPARE);\n\n\tret =\n\t    _il_poll_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t\t ~CSR_HW_IF_CONFIG_REG_BIT_NIC_PREPARE_DONE,\n\t\t\t CSR_HW_IF_CONFIG_REG_BIT_NIC_PREPARE_DONE, 150000);\n\n\t/* HW should be ready by now, check again. */\n\tif (ret != -ETIMEDOUT)\n\t\til4965_set_hw_ready(il);\n}\n\n#define MAX_HW_RESTARTS 5\n\nstatic int\n__il4965_up(struct il_priv *il)\n{\n\tint i;\n\tint ret;\n\n\tif (test_bit(S_EXIT_PENDING, &il->status)) {\n\t\tIL_WARN(\"Exit pending; will not bring the NIC up\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (!il->ucode_data_backup.v_addr || !il->ucode_data.v_addr) {\n\t\tIL_ERR(\"ucode not available for device bringup\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = il4965_alloc_bcast_station(il);\n\tif (ret) {\n\t\til_dealloc_bcast_stations(il);\n\t\treturn ret;\n\t}\n\n\til4965_prepare_card_hw(il);\n\tif (!il->hw_ready) {\n\t\til_dealloc_bcast_stations(il);\n\t\tIL_ERR(\"HW not ready\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* If platform's RF_KILL switch is NOT set to KILL */\n\tif (_il_rd(il, CSR_GP_CNTRL) & CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW)\n\t\tclear_bit(S_RFKILL, &il->status);\n\telse {\n\t\tset_bit(S_RFKILL, &il->status);\n\t\twiphy_rfkill_set_hw_state(il->hw->wiphy, true);\n\n\t\til_dealloc_bcast_stations(il);\n\t\til_enable_rfkill_int(il);\n\t\tIL_WARN(\"Radio disabled by HW RF Kill switch\\n\");\n\t\treturn 0;\n\t}\n\n\t_il_wr(il, CSR_INT, 0xFFFFFFFF);\n\n\t/* must be initialised before il_hw_nic_init */\n\til->cmd_queue = IL_DEFAULT_CMD_QUEUE_NUM;\n\n\tret = il4965_hw_nic_init(il);\n\tif (ret) {\n\t\tIL_ERR(\"Unable to init nic\\n\");\n\t\til_dealloc_bcast_stations(il);\n\t\treturn ret;\n\t}\n\n\t/* make sure rfkill handshake bits are cleared */\n\t_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\n\t_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);\n\n\t/* clear (again), then enable host interrupts */\n\t_il_wr(il, CSR_INT, 0xFFFFFFFF);\n\til_enable_interrupts(il);\n\n\t/* really make sure rfkill handshake bits are cleared */\n\t_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\n\t_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\n\n\t/* Copy original ucode data image from disk into backup cache.\n\t * This will be used to initialize the on-board processor's\n\t * data SRAM for a clean start when the runtime program first loads. */\n\tmemcpy(il->ucode_data_backup.v_addr, il->ucode_data.v_addr,\n\t       il->ucode_data.len);\n\n\tfor (i = 0; i < MAX_HW_RESTARTS; i++) {\n\n\t\t/* load bootstrap state machine,\n\t\t * load bootstrap program into processor's memory,\n\t\t * prepare to load the \"initialize\" uCode */\n\t\tret = il->ops->load_ucode(il);\n\n\t\tif (ret) {\n\t\t\tIL_ERR(\"Unable to set up bootstrap uCode: %d\\n\", ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* start card; \"initialize\" will load runtime ucode */\n\t\til4965_nic_start(il);\n\n\t\tD_INFO(DRV_NAME \" is coming up\\n\");\n\n\t\treturn 0;\n\t}\n\n\tset_bit(S_EXIT_PENDING, &il->status);\n\t__il4965_down(il);\n\tclear_bit(S_EXIT_PENDING, &il->status);\n\n\t/* tried to restart and config the device for as long as our\n\t * patience could withstand */\n\tIL_ERR(\"Unable to initialize device after %d attempts.\\n\", i);\n\treturn -EIO;\n}\n\n/*****************************************************************************\n *\n * Workqueue callbacks\n *\n *****************************************************************************/\n\nstatic void\nil4965_bg_init_alive_start(struct work_struct *data)\n{\n\tstruct il_priv *il =\n\t    container_of(data, struct il_priv, init_alive_start.work);\n\n\tmutex_lock(&il->mutex);\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\tgoto out;\n\n\til->ops->init_alive_start(il);\nout:\n\tmutex_unlock(&il->mutex);\n}\n\nstatic void\nil4965_bg_alive_start(struct work_struct *data)\n{\n\tstruct il_priv *il =\n\t    container_of(data, struct il_priv, alive_start.work);\n\n\tmutex_lock(&il->mutex);\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\tgoto out;\n\n\til4965_alive_start(il);\nout:\n\tmutex_unlock(&il->mutex);\n}\n\nstatic void\nil4965_bg_run_time_calib_work(struct work_struct *work)\n{\n\tstruct il_priv *il = container_of(work, struct il_priv,\n\t\t\t\t\t  run_time_calib_work);\n\n\tmutex_lock(&il->mutex);\n\n\tif (test_bit(S_EXIT_PENDING, &il->status) ||\n\t    test_bit(S_SCANNING, &il->status)) {\n\t\tmutex_unlock(&il->mutex);\n\t\treturn;\n\t}\n\n\tif (il->start_calib) {\n\t\til4965_chain_noise_calibration(il, (void *)&il->_4965.stats);\n\t\til4965_sensitivity_calibration(il, (void *)&il->_4965.stats);\n\t}\n\n\tmutex_unlock(&il->mutex);\n}\n\nstatic void\nil4965_bg_restart(struct work_struct *data)\n{\n\tstruct il_priv *il = container_of(data, struct il_priv, restart);\n\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn;\n\n\tif (test_and_clear_bit(S_FW_ERROR, &il->status)) {\n\t\tmutex_lock(&il->mutex);\n\t\til->is_open = 0;\n\n\t\t__il4965_down(il);\n\n\t\tmutex_unlock(&il->mutex);\n\t\til4965_cancel_deferred_work(il);\n\t\tieee80211_restart_hw(il->hw);\n\t} else {\n\t\til4965_down(il);\n\n\t\tmutex_lock(&il->mutex);\n\t\tif (test_bit(S_EXIT_PENDING, &il->status)) {\n\t\t\tmutex_unlock(&il->mutex);\n\t\t\treturn;\n\t\t}\n\n\t\t__il4965_up(il);\n\t\tmutex_unlock(&il->mutex);\n\t}\n}\n\nstatic void\nil4965_bg_rx_replenish(struct work_struct *data)\n{\n\tstruct il_priv *il = container_of(data, struct il_priv, rx_replenish);\n\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn;\n\n\tmutex_lock(&il->mutex);\n\til4965_rx_replenish(il);\n\tmutex_unlock(&il->mutex);\n}\n\n/*****************************************************************************\n *\n * mac80211 entry point functions\n *\n *****************************************************************************/\n\n#define UCODE_READY_TIMEOUT\t(4 * HZ)\n\n/*\n * Not a mac80211 entry point function, but it fits in with all the\n * other mac80211 functions grouped here.\n */\nstatic int\nil4965_mac_setup_register(struct il_priv *il, u32 max_probe_length)\n{\n\tint ret;\n\tstruct ieee80211_hw *hw = il->hw;\n\n\thw->rate_control_algorithm = \"iwl-4965-rs\";\n\n\t/* Tell mac80211 our characteristics */\n\tieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);\n\tieee80211_hw_set(hw, SUPPORTS_PS);\n\tieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(hw, SPECTRUM_MGMT);\n\tieee80211_hw_set(hw, NEED_DTIM_BEFORE_ASSOC);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\tif (il->cfg->sku & IL_SKU_N)\n\t\thw->wiphy->features |= NL80211_FEATURE_DYNAMIC_SMPS |\n\t\t\t\t       NL80211_FEATURE_STATIC_SMPS;\n\n\thw->sta_data_size = sizeof(struct il_station_priv);\n\thw->vif_data_size = sizeof(struct il_vif_priv);\n\n\thw->wiphy->interface_modes =\n\t    BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_ADHOC);\n\n\thw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\n\thw->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG |\n\t\t\t\t       REGULATORY_DISABLE_BEACON_HINTS;\n\n\t/*\n\t * For now, disable PS by default because it affects\n\t * RX performance significantly.\n\t */\n\thw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\n\n\thw->wiphy->max_scan_ssids = PROBE_OPTION_MAX;\n\t/* we create the 802.11 header and a zero-length SSID element */\n\thw->wiphy->max_scan_ie_len = max_probe_length - 24 - 2;\n\n\t/* Default value; 4 EDCA QOS priorities */\n\thw->queues = 4;\n\n\thw->max_listen_interval = IL_CONN_MAX_LISTEN_INTERVAL;\n\n\tif (il->bands[NL80211_BAND_2GHZ].n_channels)\n\t\til->hw->wiphy->bands[NL80211_BAND_2GHZ] =\n\t\t    &il->bands[NL80211_BAND_2GHZ];\n\tif (il->bands[NL80211_BAND_5GHZ].n_channels)\n\t\til->hw->wiphy->bands[NL80211_BAND_5GHZ] =\n\t\t    &il->bands[NL80211_BAND_5GHZ];\n\n\til_leds_init(il);\n\n\twiphy_ext_feature_set(il->hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\tret = ieee80211_register_hw(il->hw);\n\tif (ret) {\n\t\tIL_ERR(\"Failed to register hw (error %d)\\n\", ret);\n\t\treturn ret;\n\t}\n\til->mac80211_registered = 1;\n\n\treturn 0;\n}\n\nint\nil4965_mac_start(struct ieee80211_hw *hw)\n{\n\tstruct il_priv *il = hw->priv;\n\tint ret;\n\n\tD_MAC80211(\"enter\\n\");\n\n\t/* we should be verifying the device is ready to be opened */\n\tmutex_lock(&il->mutex);\n\tret = __il4965_up(il);\n\tmutex_unlock(&il->mutex);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (il_is_rfkill(il))\n\t\tgoto out;\n\n\tD_INFO(\"Start UP work done.\\n\");\n\n\t/* Wait for START_ALIVE from Run Time ucode. Otherwise callbacks from\n\t * mac80211 will not be run successfully. */\n\tret = wait_event_timeout(il->wait_command_queue,\n\t\t\t\t test_bit(S_READY, &il->status),\n\t\t\t\t UCODE_READY_TIMEOUT);\n\tif (!ret) {\n\t\tif (!test_bit(S_READY, &il->status)) {\n\t\t\tIL_ERR(\"START_ALIVE timeout after %dms.\\n\",\n\t\t\t\tjiffies_to_msecs(UCODE_READY_TIMEOUT));\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\til4965_led_enable(il);\n\nout:\n\til->is_open = 1;\n\tD_MAC80211(\"leave\\n\");\n\treturn 0;\n}\n\nvoid\nil4965_mac_stop(struct ieee80211_hw *hw)\n{\n\tstruct il_priv *il = hw->priv;\n\n\tD_MAC80211(\"enter\\n\");\n\n\tif (!il->is_open)\n\t\treturn;\n\n\til->is_open = 0;\n\n\til4965_down(il);\n\n\tflush_workqueue(il->workqueue);\n\n\t/* User space software may expect getting rfkill changes\n\t * even if interface is down */\n\t_il_wr(il, CSR_INT, 0xFFFFFFFF);\n\til_enable_rfkill_int(il);\n\n\tD_MAC80211(\"leave\\n\");\n}\n\nvoid\nil4965_mac_tx(struct ieee80211_hw *hw,\n\t      struct ieee80211_tx_control *control,\n\t      struct sk_buff *skb)\n{\n\tstruct il_priv *il = hw->priv;\n\n\tD_MACDUMP(\"enter\\n\");\n\n\tD_TX(\"dev->xmit(%d bytes) at rate 0x%02x\\n\", skb->len,\n\t     ieee80211_get_tx_rate(hw, IEEE80211_SKB_CB(skb))->bitrate);\n\n\tif (il4965_tx_skb(il, control->sta, skb))\n\t\tdev_kfree_skb_any(skb);\n\n\tD_MACDUMP(\"leave\\n\");\n}\n\nvoid\nil4965_mac_update_tkip_key(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_key_conf *keyconf,\n\t\t\t   struct ieee80211_sta *sta, u32 iv32, u16 * phase1key)\n{\n\tstruct il_priv *il = hw->priv;\n\n\tD_MAC80211(\"enter\\n\");\n\n\til4965_update_tkip_key(il, keyconf, sta, iv32, phase1key);\n\n\tD_MAC80211(\"leave\\n\");\n}\n\nint\nil4965_mac_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t   struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t   struct ieee80211_key_conf *key)\n{\n\tstruct il_priv *il = hw->priv;\n\tint ret;\n\tu8 sta_id;\n\tbool is_default_wep_key = false;\n\n\tD_MAC80211(\"enter\\n\");\n\n\tif (il->cfg->mod_params->sw_crypto) {\n\t\tD_MAC80211(\"leave - hwcrypto disabled\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/*\n\t * To support IBSS RSN, don't program group keys in IBSS, the\n\t * hardware will then not attempt to decrypt the frames.\n\t */\n\tif (vif->type == NL80211_IFTYPE_ADHOC &&\n\t    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE)) {\n\t\tD_MAC80211(\"leave - ad-hoc group key\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tsta_id = il_sta_id_or_broadcast(il, sta);\n\tif (sta_id == IL_INVALID_STATION)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&il->mutex);\n\til_scan_cancel_timeout(il, 100);\n\n\t/*\n\t * If we are getting WEP group key and we didn't receive any key mapping\n\t * so far, we are in legacy wep mode (group key only), otherwise we are\n\t * in 1X mode.\n\t * In legacy wep mode, we use another host command to the uCode.\n\t */\n\tif ((key->cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t     key->cipher == WLAN_CIPHER_SUITE_WEP104) && !sta) {\n\t\tif (cmd == SET_KEY)\n\t\t\tis_default_wep_key = !il->_4965.key_mapping_keys;\n\t\telse\n\t\t\tis_default_wep_key =\n\t\t\t    (key->hw_key_idx == HW_KEY_DEFAULT);\n\t}\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tif (is_default_wep_key)\n\t\t\tret = il4965_set_default_wep_key(il, key);\n\t\telse\n\t\t\tret = il4965_set_dynamic_key(il, key, sta_id);\n\n\t\tD_MAC80211(\"enable hwcrypto key\\n\");\n\t\tbreak;\n\tcase DISABLE_KEY:\n\t\tif (is_default_wep_key)\n\t\t\tret = il4965_remove_default_wep_key(il, key);\n\t\telse\n\t\t\tret = il4965_remove_dynamic_key(il, key, sta_id);\n\n\t\tD_MAC80211(\"disable hwcrypto key\\n\");\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&il->mutex);\n\tD_MAC80211(\"leave\\n\");\n\n\treturn ret;\n}\n\nint\nil4965_mac_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_ampdu_params *params)\n{\n\tstruct il_priv *il = hw->priv;\n\tint ret = -EINVAL;\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\tu16 *ssn = &params->ssn;\n\n\tD_HT(\"A-MPDU action on addr %pM tid %d\\n\", sta->addr, tid);\n\n\tif (!(il->cfg->sku & IL_SKU_N))\n\t\treturn -EACCES;\n\n\tmutex_lock(&il->mutex);\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tD_HT(\"start Rx\\n\");\n\t\tret = il4965_sta_rx_agg_start(il, sta, tid, *ssn);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tD_HT(\"stop Rx\\n\");\n\t\tret = il4965_sta_rx_agg_stop(il, sta, tid);\n\t\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\t\tret = 0;\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tD_HT(\"start Tx\\n\");\n\t\tret = il4965_tx_agg_start(il, vif, sta, tid, ssn);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tD_HT(\"stop Tx\\n\");\n\t\tret = il4965_tx_agg_stop(il, vif, sta, tid);\n\t\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\t\tret = 0;\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\tmutex_unlock(&il->mutex);\n\n\treturn ret;\n}\n\nint\nil4965_mac_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t   struct ieee80211_sta *sta)\n{\n\tstruct il_priv *il = hw->priv;\n\tstruct il_station_priv *sta_priv = (void *)sta->drv_priv;\n\tbool is_ap = vif->type == NL80211_IFTYPE_STATION;\n\tint ret;\n\tu8 sta_id;\n\n\tD_INFO(\"received request to add station %pM\\n\", sta->addr);\n\tmutex_lock(&il->mutex);\n\tD_INFO(\"proceeding to add station %pM\\n\", sta->addr);\n\tsta_priv->common.sta_id = IL_INVALID_STATION;\n\n\tatomic_set(&sta_priv->pending_frames, 0);\n\n\tret =\n\t    il_add_station_common(il, sta->addr, is_ap, sta, &sta_id);\n\tif (ret) {\n\t\tIL_ERR(\"Unable to add station %pM (%d)\\n\", sta->addr, ret);\n\t\t/* Should we return success if return code is EEXIST ? */\n\t\tmutex_unlock(&il->mutex);\n\t\treturn ret;\n\t}\n\n\tsta_priv->common.sta_id = sta_id;\n\n\t/* Initialize rate scaling */\n\tD_INFO(\"Initializing rate scaling for station %pM\\n\", sta->addr);\n\til4965_rs_rate_init(il, sta, sta_id);\n\tmutex_unlock(&il->mutex);\n\n\treturn 0;\n}\n\nvoid\nil4965_mac_channel_switch(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_channel_switch *ch_switch)\n{\n\tstruct il_priv *il = hw->priv;\n\tconst struct il_channel_info *ch_info;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tstruct ieee80211_channel *channel = ch_switch->chandef.chan;\n\tstruct il_ht_config *ht_conf = &il->current_ht_config;\n\tu16 ch;\n\n\tD_MAC80211(\"enter\\n\");\n\n\tmutex_lock(&il->mutex);\n\n\tif (il_is_rfkill(il))\n\t\tgoto out;\n\n\tif (test_bit(S_EXIT_PENDING, &il->status) ||\n\t    test_bit(S_SCANNING, &il->status) ||\n\t    test_bit(S_CHANNEL_SWITCH_PENDING, &il->status))\n\t\tgoto out;\n\n\tif (!il_is_associated(il))\n\t\tgoto out;\n\n\tif (!il->ops->set_channel_switch)\n\t\tgoto out;\n\n\tch = channel->hw_value;\n\tif (le16_to_cpu(il->active.channel) == ch)\n\t\tgoto out;\n\n\tch_info = il_get_channel_info(il, channel->band, ch);\n\tif (!il_is_channel_valid(ch_info)) {\n\t\tD_MAC80211(\"invalid channel\\n\");\n\t\tgoto out;\n\t}\n\n\tspin_lock_irq(&il->lock);\n\n\til->current_ht_config.smps = conf->smps_mode;\n\n\t/* Configure HT40 channels */\n\tswitch (cfg80211_get_chandef_type(&ch_switch->chandef)) {\n\tcase NL80211_CHAN_NO_HT:\n\tcase NL80211_CHAN_HT20:\n\t\til->ht.is_40mhz = false;\n\t\til->ht.extension_chan_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n\t\tbreak;\n\tcase NL80211_CHAN_HT40MINUS:\n\t\til->ht.extension_chan_offset = IEEE80211_HT_PARAM_CHA_SEC_BELOW;\n\t\til->ht.is_40mhz = true;\n\t\tbreak;\n\tcase NL80211_CHAN_HT40PLUS:\n\t\til->ht.extension_chan_offset = IEEE80211_HT_PARAM_CHA_SEC_ABOVE;\n\t\til->ht.is_40mhz = true;\n\t\tbreak;\n\t}\n\n\tif ((le16_to_cpu(il->staging.channel) != ch))\n\t\til->staging.flags = 0;\n\n\til_set_rxon_channel(il, channel);\n\til_set_rxon_ht(il, ht_conf);\n\til_set_flags_for_band(il, channel->band, il->vif);\n\n\tspin_unlock_irq(&il->lock);\n\n\til_set_rate(il);\n\t/*\n\t * at this point, staging_rxon has the\n\t * configuration for channel switch\n\t */\n\tset_bit(S_CHANNEL_SWITCH_PENDING, &il->status);\n\til->switch_channel = cpu_to_le16(ch);\n\tif (il->ops->set_channel_switch(il, ch_switch)) {\n\t\tclear_bit(S_CHANNEL_SWITCH_PENDING, &il->status);\n\t\til->switch_channel = 0;\n\t\tieee80211_chswitch_done(il->vif, false);\n\t}\n\nout:\n\tmutex_unlock(&il->mutex);\n\tD_MAC80211(\"leave\\n\");\n}\n\nvoid\nil4965_configure_filter(struct ieee80211_hw *hw, unsigned int changed_flags,\n\t\t\tunsigned int *total_flags, u64 multicast)\n{\n\tstruct il_priv *il = hw->priv;\n\t__le32 filter_or = 0, filter_nand = 0;\n\n#define CHK(test, flag)\tdo { \\\n\tif (*total_flags & (test))\t\t\\\n\t\tfilter_or |= (flag);\t\t\\\n\telse\t\t\t\t\t\\\n\t\tfilter_nand |= (flag);\t\t\\\n\t} while (0)\n\n\tD_MAC80211(\"Enter: changed: 0x%x, total: 0x%x\\n\", changed_flags,\n\t\t   *total_flags);\n\n\tCHK(FIF_OTHER_BSS, RXON_FILTER_PROMISC_MSK);\n\t/* Setting _just_ RXON_FILTER_CTL2HOST_MSK causes FH errors */\n\tCHK(FIF_CONTROL, RXON_FILTER_CTL2HOST_MSK | RXON_FILTER_PROMISC_MSK);\n\tCHK(FIF_BCN_PRBRESP_PROMISC, RXON_FILTER_BCON_AWARE_MSK);\n\n#undef CHK\n\n\tmutex_lock(&il->mutex);\n\n\til->staging.filter_flags &= ~filter_nand;\n\til->staging.filter_flags |= filter_or;\n\n\t/*\n\t * Not committing directly because hardware can perform a scan,\n\t * but we'll eventually commit the filter flags change anyway.\n\t */\n\n\tmutex_unlock(&il->mutex);\n\n\t/*\n\t * Receiving all multicast frames is always enabled by the\n\t * default flags setup in il_connection_init_rx_config()\n\t * since we currently do not support programming multicast\n\t * filters into the device.\n\t */\n\t*total_flags &=\n\t    FIF_OTHER_BSS | FIF_ALLMULTI |\n\t    FIF_BCN_PRBRESP_PROMISC | FIF_CONTROL;\n}\n\n/*****************************************************************************\n *\n * driver setup and teardown\n *\n *****************************************************************************/\n\nstatic void\nil4965_bg_txpower_work(struct work_struct *work)\n{\n\tstruct il_priv *il = container_of(work, struct il_priv,\n\t\t\t\t\t  txpower_work);\n\n\tmutex_lock(&il->mutex);\n\n\t/* If a scan happened to start before we got here\n\t * then just return; the stats notification will\n\t * kick off another scheduled work to compensate for\n\t * any temperature delta we missed here. */\n\tif (test_bit(S_EXIT_PENDING, &il->status) ||\n\t    test_bit(S_SCANNING, &il->status))\n\t\tgoto out;\n\n\t/* Regardless of if we are associated, we must reconfigure the\n\t * TX power since frames can be sent on non-radar channels while\n\t * not associated */\n\til->ops->send_tx_power(il);\n\n\t/* Update last_temperature to keep is_calib_needed from running\n\t * when it isn't needed... */\n\til->last_temperature = il->temperature;\nout:\n\tmutex_unlock(&il->mutex);\n}\n\nstatic void\nil4965_setup_deferred_work(struct il_priv *il)\n{\n\til->workqueue = create_singlethread_workqueue(DRV_NAME);\n\n\tinit_waitqueue_head(&il->wait_command_queue);\n\n\tINIT_WORK(&il->restart, il4965_bg_restart);\n\tINIT_WORK(&il->rx_replenish, il4965_bg_rx_replenish);\n\tINIT_WORK(&il->run_time_calib_work, il4965_bg_run_time_calib_work);\n\tINIT_DELAYED_WORK(&il->init_alive_start, il4965_bg_init_alive_start);\n\tINIT_DELAYED_WORK(&il->alive_start, il4965_bg_alive_start);\n\n\til_setup_scan_deferred_work(il);\n\n\tINIT_WORK(&il->txpower_work, il4965_bg_txpower_work);\n\n\ttimer_setup(&il->stats_periodic, il4965_bg_stats_periodic, 0);\n\n\ttimer_setup(&il->watchdog, il_bg_watchdog, 0);\n\n\ttasklet_setup(&il->irq_tasklet, il4965_irq_tasklet);\n}\n\nstatic void\nil4965_cancel_deferred_work(struct il_priv *il)\n{\n\tcancel_work_sync(&il->txpower_work);\n\tcancel_delayed_work_sync(&il->init_alive_start);\n\tcancel_delayed_work(&il->alive_start);\n\tcancel_work_sync(&il->run_time_calib_work);\n\n\til_cancel_scan_deferred_work(il);\n\n\tdel_timer_sync(&il->stats_periodic);\n}\n\nstatic void\nil4965_init_hw_rates(struct il_priv *il, struct ieee80211_rate *rates)\n{\n\tint i;\n\n\tfor (i = 0; i < RATE_COUNT_LEGACY; i++) {\n\t\trates[i].bitrate = il_rates[i].ieee * 5;\n\t\trates[i].hw_value = i;\t/* Rate scaling will work on idxes */\n\t\trates[i].hw_value_short = i;\n\t\trates[i].flags = 0;\n\t\tif ((i >= IL_FIRST_CCK_RATE) && (i <= IL_LAST_CCK_RATE)) {\n\t\t\t/*\n\t\t\t * If CCK != 1M then set short preamble rate flag.\n\t\t\t */\n\t\t\trates[i].flags |=\n\t\t\t    (il_rates[i].plcp ==\n\t\t\t     RATE_1M_PLCP) ? 0 : IEEE80211_RATE_SHORT_PREAMBLE;\n\t\t}\n\t}\n}\n\n/*\n * Acquire il->lock before calling this function !\n */\nvoid\nil4965_set_wr_ptrs(struct il_priv *il, int txq_id, u32 idx)\n{\n\til_wr(il, HBUS_TARG_WRPTR, (idx & 0xff) | (txq_id << 8));\n\til_wr_prph(il, IL49_SCD_QUEUE_RDPTR(txq_id), idx);\n}\n\nvoid\nil4965_tx_queue_set_status(struct il_priv *il, struct il_tx_queue *txq,\n\t\t\t   int tx_fifo_id, int scd_retry)\n{\n\tint txq_id = txq->q.id;\n\n\t/* Find out whether to activate Tx queue */\n\tint active = test_bit(txq_id, &il->txq_ctx_active_msk) ? 1 : 0;\n\n\t/* Set up and activate */\n\til_wr_prph(il, IL49_SCD_QUEUE_STATUS_BITS(txq_id),\n\t\t   (active << IL49_SCD_QUEUE_STTS_REG_POS_ACTIVE) |\n\t\t   (tx_fifo_id << IL49_SCD_QUEUE_STTS_REG_POS_TXF) |\n\t\t   (scd_retry << IL49_SCD_QUEUE_STTS_REG_POS_WSL) |\n\t\t   (scd_retry << IL49_SCD_QUEUE_STTS_REG_POS_SCD_ACK) |\n\t\t   IL49_SCD_QUEUE_STTS_REG_MSK);\n\n\ttxq->sched_retry = scd_retry;\n\n\tD_INFO(\"%s %s Queue %d on AC %d\\n\", active ? \"Activate\" : \"Deactivate\",\n\t       scd_retry ? \"BA\" : \"AC\", txq_id, tx_fifo_id);\n}\n\nstatic const struct ieee80211_ops il4965_mac_ops = {\n\t.tx = il4965_mac_tx,\n\t.start = il4965_mac_start,\n\t.stop = il4965_mac_stop,\n\t.add_interface = il_mac_add_interface,\n\t.remove_interface = il_mac_remove_interface,\n\t.change_interface = il_mac_change_interface,\n\t.config = il_mac_config,\n\t.configure_filter = il4965_configure_filter,\n\t.set_key = il4965_mac_set_key,\n\t.update_tkip_key = il4965_mac_update_tkip_key,\n\t.conf_tx = il_mac_conf_tx,\n\t.reset_tsf = il_mac_reset_tsf,\n\t.bss_info_changed = il_mac_bss_info_changed,\n\t.ampdu_action = il4965_mac_ampdu_action,\n\t.hw_scan = il_mac_hw_scan,\n\t.sta_add = il4965_mac_sta_add,\n\t.sta_remove = il_mac_sta_remove,\n\t.channel_switch = il4965_mac_channel_switch,\n\t.tx_last_beacon = il_mac_tx_last_beacon,\n\t.flush = il_mac_flush,\n};\n\nstatic int\nil4965_init_drv(struct il_priv *il)\n{\n\tint ret;\n\n\tspin_lock_init(&il->sta_lock);\n\tspin_lock_init(&il->hcmd_lock);\n\n\tINIT_LIST_HEAD(&il->free_frames);\n\n\tmutex_init(&il->mutex);\n\n\til->ieee_channels = NULL;\n\til->ieee_rates = NULL;\n\til->band = NL80211_BAND_2GHZ;\n\n\til->iw_mode = NL80211_IFTYPE_STATION;\n\til->current_ht_config.smps = IEEE80211_SMPS_STATIC;\n\til->missed_beacon_threshold = IL_MISSED_BEACON_THRESHOLD_DEF;\n\n\t/* initialize force reset */\n\til->force_reset.reset_duration = IL_DELAY_NEXT_FORCE_FW_RELOAD;\n\n\t/* Choose which receivers/antennas to use */\n\tif (il->ops->set_rxon_chain)\n\t\til->ops->set_rxon_chain(il);\n\n\til_init_scan_params(il);\n\n\tret = il_init_channel_map(il);\n\tif (ret) {\n\t\tIL_ERR(\"initializing regulatory failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = il_init_geos(il);\n\tif (ret) {\n\t\tIL_ERR(\"initializing geos failed: %d\\n\", ret);\n\t\tgoto err_free_channel_map;\n\t}\n\til4965_init_hw_rates(il, il->ieee_rates);\n\n\treturn 0;\n\nerr_free_channel_map:\n\til_free_channel_map(il);\nerr:\n\treturn ret;\n}\n\nstatic void\nil4965_uninit_drv(struct il_priv *il)\n{\n\til_free_geos(il);\n\til_free_channel_map(il);\n\tkfree(il->scan_cmd);\n}\n\nstatic void\nil4965_hw_detect(struct il_priv *il)\n{\n\til->hw_rev = _il_rd(il, CSR_HW_REV);\n\til->hw_wa_rev = _il_rd(il, CSR_HW_REV_WA_REG);\n\til->rev_id = il->pci_dev->revision;\n\tD_INFO(\"HW Revision ID = 0x%X\\n\", il->rev_id);\n}\n\nstatic const struct il_sensitivity_ranges il4965_sensitivity = {\n\t.min_nrg_cck = 97,\n\t.max_nrg_cck = 0,\t/* not used, set to 0 */\n\n\t.auto_corr_min_ofdm = 85,\n\t.auto_corr_min_ofdm_mrc = 170,\n\t.auto_corr_min_ofdm_x1 = 105,\n\t.auto_corr_min_ofdm_mrc_x1 = 220,\n\n\t.auto_corr_max_ofdm = 120,\n\t.auto_corr_max_ofdm_mrc = 210,\n\t.auto_corr_max_ofdm_x1 = 140,\n\t.auto_corr_max_ofdm_mrc_x1 = 270,\n\n\t.auto_corr_min_cck = 125,\n\t.auto_corr_max_cck = 200,\n\t.auto_corr_min_cck_mrc = 200,\n\t.auto_corr_max_cck_mrc = 400,\n\n\t.nrg_th_cck = 100,\n\t.nrg_th_ofdm = 100,\n\n\t.barker_corr_th_min = 190,\n\t.barker_corr_th_min_mrc = 390,\n\t.nrg_th_cca = 62,\n};\n\nstatic void\nil4965_set_hw_params(struct il_priv *il)\n{\n\til->hw_params.bcast_id = IL4965_BROADCAST_ID;\n\til->hw_params.max_rxq_size = RX_QUEUE_SIZE;\n\til->hw_params.max_rxq_log = RX_QUEUE_SIZE_LOG;\n\tif (il->cfg->mod_params->amsdu_size_8K)\n\t\til->hw_params.rx_page_order = get_order(IL_RX_BUF_SIZE_8K);\n\telse\n\t\til->hw_params.rx_page_order = get_order(IL_RX_BUF_SIZE_4K);\n\n\til->hw_params.max_beacon_itrvl = IL_MAX_UCODE_BEACON_INTERVAL;\n\n\tif (il->cfg->mod_params->disable_11n)\n\t\til->cfg->sku &= ~IL_SKU_N;\n\n\tif (il->cfg->mod_params->num_of_queues >= IL_MIN_NUM_QUEUES &&\n\t    il->cfg->mod_params->num_of_queues <= IL49_NUM_QUEUES)\n\t\til->cfg->num_of_queues =\n\t\t    il->cfg->mod_params->num_of_queues;\n\n\til->hw_params.max_txq_num = il->cfg->num_of_queues;\n\til->hw_params.dma_chnl_num = FH49_TCSR_CHNL_NUM;\n\til->hw_params.scd_bc_tbls_size =\n\t    il->cfg->num_of_queues *\n\t    sizeof(struct il4965_scd_bc_tbl);\n\n\til->hw_params.tfd_size = sizeof(struct il_tfd);\n\til->hw_params.max_stations = IL4965_STATION_COUNT;\n\til->hw_params.max_data_size = IL49_RTC_DATA_SIZE;\n\til->hw_params.max_inst_size = IL49_RTC_INST_SIZE;\n\til->hw_params.max_bsm_size = BSM_SRAM_SIZE;\n\til->hw_params.ht40_channel = BIT(NL80211_BAND_5GHZ);\n\n\til->hw_params.rx_wrt_ptr_reg = FH49_RSCSR_CHNL0_WPTR;\n\n\til->hw_params.tx_chains_num = il4965_num_of_ant(il->cfg->valid_tx_ant);\n\til->hw_params.rx_chains_num = il4965_num_of_ant(il->cfg->valid_rx_ant);\n\til->hw_params.valid_tx_ant = il->cfg->valid_tx_ant;\n\til->hw_params.valid_rx_ant = il->cfg->valid_rx_ant;\n\n\til->hw_params.ct_kill_threshold =\n\t   celsius_to_kelvin(CT_KILL_THRESHOLD_LEGACY);\n\n\til->hw_params.sens = &il4965_sensitivity;\n\til->hw_params.beacon_time_tsf_bits = IL4965_EXT_BEACON_TIME_POS;\n}\n\nstatic int\nil4965_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint err = 0;\n\tstruct il_priv *il;\n\tstruct ieee80211_hw *hw;\n\tstruct il_cfg *cfg = (struct il_cfg *)(ent->driver_data);\n\tunsigned long flags;\n\tu16 pci_cmd;\n\n\t/************************\n\t * 1. Allocating HW data\n\t ************************/\n\n\thw = ieee80211_alloc_hw(sizeof(struct il_priv), &il4965_mac_ops);\n\tif (!hw) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\til = hw->priv;\n\til->hw = hw;\n\tSET_IEEE80211_DEV(hw, &pdev->dev);\n\n\tD_INFO(\"*** LOAD DRIVER ***\\n\");\n\til->cfg = cfg;\n\til->ops = &il4965_ops;\n#ifdef CONFIG_IWLEGACY_DEBUGFS\n\til->debugfs_ops = &il4965_debugfs_ops;\n#endif\n\til->pci_dev = pdev;\n\til->inta_mask = CSR_INI_SET_MASK;\n\n\t/**************************\n\t * 2. Initializing PCI bus\n\t **************************/\n\tpci_disable_link_state(pdev,\n\t\t\t       PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 |\n\t\t\t       PCIE_LINK_STATE_CLKPM);\n\n\tif (pci_enable_device(pdev)) {\n\t\terr = -ENODEV;\n\t\tgoto out_ieee80211_free_hw;\n\t}\n\n\tpci_set_master(pdev);\n\n\terr = pci_set_dma_mask(pdev, DMA_BIT_MASK(36));\n\tif (!err)\n\t\terr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(36));\n\tif (err) {\n\t\terr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\t\tif (!err)\n\t\t\terr =\n\t\t\t    pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\n\t\t/* both attempts failed: */\n\t\tif (err) {\n\t\t\tIL_WARN(\"No suitable DMA available.\\n\");\n\t\t\tgoto out_pci_disable_device;\n\t\t}\n\t}\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err)\n\t\tgoto out_pci_disable_device;\n\n\tpci_set_drvdata(pdev, il);\n\n\t/***********************\n\t * 3. Read REV register\n\t ***********************/\n\til->hw_base = pci_ioremap_bar(pdev, 0);\n\tif (!il->hw_base) {\n\t\terr = -ENODEV;\n\t\tgoto out_pci_release_regions;\n\t}\n\n\tD_INFO(\"pci_resource_len = 0x%08llx\\n\",\n\t       (unsigned long long)pci_resource_len(pdev, 0));\n\tD_INFO(\"pci_resource_base = %p\\n\", il->hw_base);\n\n\t/* these spin locks will be used in apm_ops.init and EEPROM access\n\t * we should init now\n\t */\n\tspin_lock_init(&il->reg_lock);\n\tspin_lock_init(&il->lock);\n\n\t/*\n\t * stop and reset the on-board processor just in case it is in a\n\t * strange state ... like being left stranded by a primary kernel\n\t * and this is now the kdump kernel trying to start up\n\t */\n\t_il_wr(il, CSR_RESET, CSR_RESET_REG_FLAG_NEVO_RESET);\n\n\til4965_hw_detect(il);\n\tIL_INFO(\"Detected %s, REV=0x%X\\n\", il->cfg->name, il->hw_rev);\n\n\t/* We disable the RETRY_TIMEOUT register (0x41) to keep\n\t * PCI Tx retries from interfering with C3 CPU state */\n\tpci_write_config_byte(pdev, PCI_CFG_RETRY_TIMEOUT, 0x00);\n\n\til4965_prepare_card_hw(il);\n\tif (!il->hw_ready) {\n\t\tIL_WARN(\"Failed, HW not ready\\n\");\n\t\terr = -EIO;\n\t\tgoto out_iounmap;\n\t}\n\n\t/*****************\n\t * 4. Read EEPROM\n\t *****************/\n\t/* Read the EEPROM */\n\terr = il_eeprom_init(il);\n\tif (err) {\n\t\tIL_ERR(\"Unable to init EEPROM\\n\");\n\t\tgoto out_iounmap;\n\t}\n\terr = il4965_eeprom_check_version(il);\n\tif (err)\n\t\tgoto out_free_eeprom;\n\n\t/* extract MAC Address */\n\til4965_eeprom_get_mac(il, il->addresses[0].addr);\n\tD_INFO(\"MAC address: %pM\\n\", il->addresses[0].addr);\n\til->hw->wiphy->addresses = il->addresses;\n\til->hw->wiphy->n_addresses = 1;\n\n\t/************************\n\t * 5. Setup HW constants\n\t ************************/\n\til4965_set_hw_params(il);\n\n\t/*******************\n\t * 6. Setup il\n\t *******************/\n\n\terr = il4965_init_drv(il);\n\tif (err)\n\t\tgoto out_free_eeprom;\n\t/* At this point both hw and il are initialized. */\n\n\t/********************\n\t * 7. Setup services\n\t ********************/\n\tspin_lock_irqsave(&il->lock, flags);\n\til_disable_interrupts(il);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\tpci_enable_msi(il->pci_dev);\n\n\terr = request_irq(il->pci_dev->irq, il_isr, IRQF_SHARED, DRV_NAME, il);\n\tif (err) {\n\t\tIL_ERR(\"Error allocating IRQ %d\\n\", il->pci_dev->irq);\n\t\tgoto out_disable_msi;\n\t}\n\n\til4965_setup_deferred_work(il);\n\til4965_setup_handlers(il);\n\n\t/*********************************************\n\t * 8. Enable interrupts and read RFKILL state\n\t *********************************************/\n\n\t/* enable rfkill interrupt: hw bug w/a */\n\tpci_read_config_word(il->pci_dev, PCI_COMMAND, &pci_cmd);\n\tif (pci_cmd & PCI_COMMAND_INTX_DISABLE) {\n\t\tpci_cmd &= ~PCI_COMMAND_INTX_DISABLE;\n\t\tpci_write_config_word(il->pci_dev, PCI_COMMAND, pci_cmd);\n\t}\n\n\til_enable_rfkill_int(il);\n\n\t/* If platform's RF_KILL switch is NOT set to KILL */\n\tif (_il_rd(il, CSR_GP_CNTRL) & CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW)\n\t\tclear_bit(S_RFKILL, &il->status);\n\telse\n\t\tset_bit(S_RFKILL, &il->status);\n\n\twiphy_rfkill_set_hw_state(il->hw->wiphy,\n\t\t\t\t  test_bit(S_RFKILL, &il->status));\n\n\til_power_initialize(il);\n\n\tinit_completion(&il->_4965.firmware_loading_complete);\n\n\terr = il4965_request_firmware(il, true);\n\tif (err)\n\t\tgoto out_destroy_workqueue;\n\n\treturn 0;\n\nout_destroy_workqueue:\n\tdestroy_workqueue(il->workqueue);\n\til->workqueue = NULL;\n\tfree_irq(il->pci_dev->irq, il);\nout_disable_msi:\n\tpci_disable_msi(il->pci_dev);\n\til4965_uninit_drv(il);\nout_free_eeprom:\n\til_eeprom_free(il);\nout_iounmap:\n\tiounmap(il->hw_base);\nout_pci_release_regions:\n\tpci_release_regions(pdev);\nout_pci_disable_device:\n\tpci_disable_device(pdev);\nout_ieee80211_free_hw:\n\tieee80211_free_hw(il->hw);\nout:\n\treturn err;\n}\n\nstatic void\nil4965_pci_remove(struct pci_dev *pdev)\n{\n\tstruct il_priv *il = pci_get_drvdata(pdev);\n\tunsigned long flags;\n\n\tif (!il)\n\t\treturn;\n\n\twait_for_completion(&il->_4965.firmware_loading_complete);\n\n\tD_INFO(\"*** UNLOAD DRIVER ***\\n\");\n\n\til_dbgfs_unregister(il);\n\tsysfs_remove_group(&pdev->dev.kobj, &il_attribute_group);\n\n\t/* ieee80211_unregister_hw call wil cause il_mac_stop to\n\t * to be called and il4965_down since we are removing the device\n\t * we need to set S_EXIT_PENDING bit.\n\t */\n\tset_bit(S_EXIT_PENDING, &il->status);\n\n\til_leds_exit(il);\n\n\tif (il->mac80211_registered) {\n\t\tieee80211_unregister_hw(il->hw);\n\t\til->mac80211_registered = 0;\n\t} else {\n\t\til4965_down(il);\n\t}\n\n\t/*\n\t * Make sure device is reset to low power before unloading driver.\n\t * This may be redundant with il4965_down(), but there are paths to\n\t * run il4965_down() without calling apm_ops.stop(), and there are\n\t * paths to avoid running il4965_down() at all before leaving driver.\n\t * This (inexpensive) call *makes sure* device is reset.\n\t */\n\til_apm_stop(il);\n\n\t/* make sure we flush any pending irq or\n\t * tasklet for the driver\n\t */\n\tspin_lock_irqsave(&il->lock, flags);\n\til_disable_interrupts(il);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\til4965_synchronize_irq(il);\n\n\til4965_dealloc_ucode_pci(il);\n\n\tif (il->rxq.bd)\n\t\til4965_rx_queue_free(il, &il->rxq);\n\til4965_hw_txq_ctx_free(il);\n\n\til_eeprom_free(il);\n\n\t/*netif_stop_queue(dev); */\n\tflush_workqueue(il->workqueue);\n\n\t/* ieee80211_unregister_hw calls il_mac_stop, which flushes\n\t * il->workqueue... so we can't take down the workqueue\n\t * until now... */\n\tdestroy_workqueue(il->workqueue);\n\til->workqueue = NULL;\n\n\tfree_irq(il->pci_dev->irq, il);\n\tpci_disable_msi(il->pci_dev);\n\tiounmap(il->hw_base);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\n\til4965_uninit_drv(il);\n\n\tdev_kfree_skb(il->beacon_skb);\n\n\tieee80211_free_hw(il->hw);\n}\n\n/*\n * Activate/Deactivate Tx DMA/FIFO channels according tx fifos mask\n * must be called under il->lock and mac access\n */\nvoid\nil4965_txq_set_sched(struct il_priv *il, u32 mask)\n{\n\til_wr_prph(il, IL49_SCD_TXFACT, mask);\n}\n\n/*****************************************************************************\n *\n * driver and module entry point\n *\n *****************************************************************************/\n\n/* Hardware specific file defines the PCI IDs table for that hardware module */\nstatic const struct pci_device_id il4965_hw_card_ids[] = {\n\t{IL_PCI_DEVICE(0x4229, PCI_ANY_ID, il4965_cfg)},\n\t{IL_PCI_DEVICE(0x4230, PCI_ANY_ID, il4965_cfg)},\n\t{0}\n};\nMODULE_DEVICE_TABLE(pci, il4965_hw_card_ids);\n\nstatic struct pci_driver il4965_driver = {\n\t.name = DRV_NAME,\n\t.id_table = il4965_hw_card_ids,\n\t.probe = il4965_pci_probe,\n\t.remove = il4965_pci_remove,\n\t.driver.pm = IL_LEGACY_PM_OPS,\n};\n\nstatic int __init\nil4965_init(void)\n{\n\n\tint ret;\n\tpr_info(DRV_DESCRIPTION \", \" DRV_VERSION \"\\n\");\n\tpr_info(DRV_COPYRIGHT \"\\n\");\n\n\tret = il4965_rate_control_register();\n\tif (ret) {\n\t\tpr_err(\"Unable to register rate control algorithm: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = pci_register_driver(&il4965_driver);\n\tif (ret) {\n\t\tpr_err(\"Unable to initialize PCI module\\n\");\n\t\tgoto error_register;\n\t}\n\n\treturn ret;\n\nerror_register:\n\til4965_rate_control_unregister();\n\treturn ret;\n}\n\nstatic void __exit\nil4965_exit(void)\n{\n\tpci_unregister_driver(&il4965_driver);\n\til4965_rate_control_unregister();\n}\n\nmodule_exit(il4965_exit);\nmodule_init(il4965_init);\n\n#ifdef CONFIG_IWLEGACY_DEBUG\nmodule_param_named(debug, il_debug_level, uint, 0644);\nMODULE_PARM_DESC(debug, \"debug output mask\");\n#endif\n\nmodule_param_named(swcrypto, il4965_mod_params.sw_crypto, int, 0444);\nMODULE_PARM_DESC(swcrypto, \"using crypto in software (default 0 [hardware])\");\nmodule_param_named(queues_num, il4965_mod_params.num_of_queues, int, 0444);\nMODULE_PARM_DESC(queues_num, \"number of hw queues.\");\nmodule_param_named(11n_disable, il4965_mod_params.disable_11n, int, 0444);\nMODULE_PARM_DESC(11n_disable, \"disable 11n functionality\");\nmodule_param_named(amsdu_size_8K, il4965_mod_params.amsdu_size_8K, int, 0444);\nMODULE_PARM_DESC(amsdu_size_8K, \"enable 8K amsdu size (default 0 [disabled])\");\nmodule_param_named(fw_restart, il4965_mod_params.restart_fw, int, 0444);\nMODULE_PARM_DESC(fw_restart, \"restart firmware in case of error\");\n"}}, "reports": [{"events": [{"location": {"col": 54, "file": 0, "line": 2596}, "message": "WARNING !A || A && B is equivalent to !A || B"}], "macros": [], "notes": [], "path": "/src/drivers/net/wireless/intel/iwlegacy/4965-mac.c", "reportHash": "2ad96877d60f5d9ee2b9d476dff4f877", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
