<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/md/md-bitmap.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * bitmap.c two-level bitmap (C) Peter T. Breuer (ptb@ot.uc3m.es) 2003\n *\n * bitmap_create  - sets up the bitmap structure\n * bitmap_destroy - destroys the bitmap structure\n *\n * additions, Copyright (C) 2003-2004, Paul Clements, SteelEye Technology, Inc.:\n * - added disk storage for bitmap\n * - changes to allow various bitmap chunk sizes\n */\n\n/*\n * Still to do:\n *\n * flush after percent set rather than just time based. (maybe both).\n */\n\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/seq_file.h>\n#include <trace/events/block.h>\n#include \"md.h\"\n#include \"md-bitmap.h\"\n\nstatic inline char *bmname(struct bitmap *bitmap)\n{\n\treturn bitmap->mddev ? mdname(bitmap->mddev) : \"mdX\";\n}\n\n/*\n * check a page and, if necessary, allocate it (or hijack it if the alloc fails)\n *\n * 1) check to see if this page is allocated, if it's not then try to alloc\n * 2) if the alloc fails, set the page's hijacked flag so we'll use the\n *    page pointer directly as a counter\n *\n * if we find our page, we increment the page's refcount so that it stays\n * allocated while we're using it\n */\nstatic int md_bitmap_checkpage(struct bitmap_counts *bitmap,\n\t\t\t       unsigned long page, int create, int no_hijack)\n__releases(bitmap->lock)\n__acquires(bitmap->lock)\n{\n\tunsigned char *mappage;\n\n\tif (page >= bitmap->pages) {\n\t\t/* This can happen if bitmap_start_sync goes beyond\n\t\t * End-of-device while looking for a whole page.\n\t\t * It is harmless.\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tif (bitmap->bp[page].hijacked) /* it's hijacked, don't try to alloc */\n\t\treturn 0;\n\n\tif (bitmap->bp[page].map) /* page is already allocated, just return */\n\t\treturn 0;\n\n\tif (!create)\n\t\treturn -ENOENT;\n\n\t/* this page has not been allocated yet */\n\n\tspin_unlock_irq(&bitmap->lock);\n\t/* It is possible that this is being called inside a\n\t * prepare_to_wait/finish_wait loop from raid5c:make_request().\n\t * In general it is not permitted to sleep in that context as it\n\t * can cause the loop to spin freely.\n\t * That doesn't apply here as we can only reach this point\n\t * once with any loop.\n\t * When this function completes, either bp[page].map or\n\t * bp[page].hijacked.  In either case, this function will\n\t * abort before getting to this point again.  So there is\n\t * no risk of a free-spin, and so it is safe to assert\n\t * that sleeping here is allowed.\n\t */\n\tsched_annotate_sleep();\n\tmappage = kzalloc(PAGE_SIZE, GFP_NOIO);\n\tspin_lock_irq(&bitmap->lock);\n\n\tif (mappage == NULL) {\n\t\tpr_debug(\"md/bitmap: map page allocation failed, hijacking\\n\");\n\t\t/* We don't support hijack for cluster raid */\n\t\tif (no_hijack)\n\t\t\treturn -ENOMEM;\n\t\t/* failed - set the hijacked flag so that we can use the\n\t\t * pointer as a counter */\n\t\tif (!bitmap->bp[page].map)\n\t\t\tbitmap->bp[page].hijacked = 1;\n\t} else if (bitmap->bp[page].map ||\n\t\t   bitmap->bp[page].hijacked) {\n\t\t/* somebody beat us to getting the page */\n\t\tkfree(mappage);\n\t} else {\n\n\t\t/* no page was in place and we have one, so install it */\n\n\t\tbitmap->bp[page].map = mappage;\n\t\tbitmap->missing_pages--;\n\t}\n\treturn 0;\n}\n\n/* if page is completely empty, put it back on the free list, or dealloc it */\n/* if page was hijacked, unmark the flag so it might get alloced next time */\n/* Note: lock should be held when calling this */\nstatic void md_bitmap_checkfree(struct bitmap_counts *bitmap, unsigned long page)\n{\n\tchar *ptr;\n\n\tif (bitmap->bp[page].count) /* page is still busy */\n\t\treturn;\n\n\t/* page is no longer in use, it can be released */\n\n\tif (bitmap->bp[page].hijacked) { /* page was hijacked, undo this now */\n\t\tbitmap->bp[page].hijacked = 0;\n\t\tbitmap->bp[page].map = NULL;\n\t} else {\n\t\t/* normal case, free the page */\n\t\tptr = bitmap->bp[page].map;\n\t\tbitmap->bp[page].map = NULL;\n\t\tbitmap->missing_pages++;\n\t\tkfree(ptr);\n\t}\n}\n\n/*\n * bitmap file handling - read and write the bitmap file and its superblock\n */\n\n/*\n * basic page I/O operations\n */\n\n/* IO operations when bitmap is stored near all superblocks */\nstatic int read_sb_page(struct mddev *mddev, loff_t offset,\n\t\t\tstruct page *page,\n\t\t\tunsigned long index, int size)\n{\n\t/* choose a good rdev and read the page from there */\n\n\tstruct md_rdev *rdev;\n\tsector_t target;\n\n\trdev_for_each(rdev, mddev) {\n\t\tif (! test_bit(In_sync, &rdev->flags)\n\t\t    || test_bit(Faulty, &rdev->flags)\n\t\t    || test_bit(Bitmap_sync, &rdev->flags))\n\t\t\tcontinue;\n\n\t\ttarget = offset + index * (PAGE_SIZE/512);\n\n\t\tif (sync_page_io(rdev, target,\n\t\t\t\t roundup(size, bdev_logical_block_size(rdev->bdev)),\n\t\t\t\t page, REQ_OP_READ, 0, true)) {\n\t\t\tpage->index = index;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EIO;\n}\n\nstatic struct md_rdev *next_active_rdev(struct md_rdev *rdev, struct mddev *mddev)\n{\n\t/* Iterate the disks of an mddev, using rcu to protect access to the\n\t * linked list, and raising the refcount of devices we return to ensure\n\t * they don't disappear while in use.\n\t * As devices are only added or removed when raid_disk is < 0 and\n\t * nr_pending is 0 and In_sync is clear, the entries we return will\n\t * still be in the same position on the list when we re-enter\n\t * list_for_each_entry_continue_rcu.\n\t *\n\t * Note that if entered with 'rdev == NULL' to start at the\n\t * beginning, we temporarily assign 'rdev' to an address which\n\t * isn't really an rdev, but which can be used by\n\t * list_for_each_entry_continue_rcu() to find the first entry.\n\t */\n\trcu_read_lock();\n\tif (rdev == NULL)\n\t\t/* start at the beginning */\n\t\trdev = list_entry(&mddev->disks, struct md_rdev, same_set);\n\telse {\n\t\t/* release the previous rdev and start from there. */\n\t\trdev_dec_pending(rdev, mddev);\n\t}\n\tlist_for_each_entry_continue_rcu(rdev, &mddev->disks, same_set) {\n\t\tif (rdev->raid_disk >= 0 &&\n\t\t    !test_bit(Faulty, &rdev->flags)) {\n\t\t\t/* this is a usable devices */\n\t\t\tatomic_inc(&rdev->nr_pending);\n\t\t\trcu_read_unlock();\n\t\t\treturn rdev;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NULL;\n}\n\nstatic int write_sb_page(struct bitmap *bitmap, struct page *page, int wait)\n{\n\tstruct md_rdev *rdev;\n\tstruct block_device *bdev;\n\tstruct mddev *mddev = bitmap->mddev;\n\tstruct bitmap_storage *store = &bitmap->storage;\n\nrestart:\n\trdev = NULL;\n\twhile ((rdev = next_active_rdev(rdev, mddev)) != NULL) {\n\t\tint size = PAGE_SIZE;\n\t\tloff_t offset = mddev->bitmap_info.offset;\n\n\t\tbdev = (rdev->meta_bdev) ? rdev->meta_bdev : rdev->bdev;\n\n\t\tif (page->index == store->file_pages-1) {\n\t\t\tint last_page_size = store->bytes & (PAGE_SIZE-1);\n\t\t\tif (last_page_size == 0)\n\t\t\t\tlast_page_size = PAGE_SIZE;\n\t\t\tsize = roundup(last_page_size,\n\t\t\t\t       bdev_logical_block_size(bdev));\n\t\t}\n\t\t/* Just make sure we aren't corrupting data or\n\t\t * metadata\n\t\t */\n\t\tif (mddev->external) {\n\t\t\t/* Bitmap could be anywhere. */\n\t\t\tif (rdev->sb_start + offset + (page->index\n\t\t\t\t\t\t       * (PAGE_SIZE/512))\n\t\t\t    > rdev->data_offset\n\t\t\t    &&\n\t\t\t    rdev->sb_start + offset\n\t\t\t    < (rdev->data_offset + mddev->dev_sectors\n\t\t\t     + (PAGE_SIZE/512)))\n\t\t\t\tgoto bad_alignment;\n\t\t} else if (offset < 0) {\n\t\t\t/* DATA  BITMAP METADATA  */\n\t\t\tif (offset\n\t\t\t    + (long)(page->index * (PAGE_SIZE/512))\n\t\t\t    + size/512 > 0)\n\t\t\t\t/* bitmap runs in to metadata */\n\t\t\t\tgoto bad_alignment;\n\t\t\tif (rdev->data_offset + mddev->dev_sectors\n\t\t\t    > rdev->sb_start + offset)\n\t\t\t\t/* data runs in to bitmap */\n\t\t\t\tgoto bad_alignment;\n\t\t} else if (rdev->sb_start < rdev->data_offset) {\n\t\t\t/* METADATA BITMAP DATA */\n\t\t\tif (rdev->sb_start\n\t\t\t    + offset\n\t\t\t    + page->index*(PAGE_SIZE/512) + size/512\n\t\t\t    > rdev->data_offset)\n\t\t\t\t/* bitmap runs in to data */\n\t\t\t\tgoto bad_alignment;\n\t\t} else {\n\t\t\t/* DATA METADATA BITMAP - no problems */\n\t\t}\n\t\tmd_super_write(mddev, rdev,\n\t\t\t       rdev->sb_start + offset\n\t\t\t       + page->index * (PAGE_SIZE/512),\n\t\t\t       size,\n\t\t\t       page);\n\t}\n\n\tif (wait && md_super_wait(mddev) < 0)\n\t\tgoto restart;\n\treturn 0;\n\n bad_alignment:\n\treturn -EINVAL;\n}\n\nstatic void md_bitmap_file_kick(struct bitmap *bitmap);\n/*\n * write out a page to a file\n */\nstatic void write_page(struct bitmap *bitmap, struct page *page, int wait)\n{\n\tstruct buffer_head *bh;\n\n\tif (bitmap->storage.file == NULL) {\n\t\tswitch (write_sb_page(bitmap, page, wait)) {\n\t\tcase -EINVAL:\n\t\t\tset_bit(BITMAP_WRITE_ERROR, &bitmap->flags);\n\t\t}\n\t} else {\n\n\t\tbh = page_buffers(page);\n\n\t\twhile (bh && bh->b_blocknr) {\n\t\t\tatomic_inc(&bitmap->pending_writes);\n\t\t\tset_buffer_locked(bh);\n\t\t\tset_buffer_mapped(bh);\n\t\t\tsubmit_bh(REQ_OP_WRITE, REQ_SYNC, bh);\n\t\t\tbh = bh->b_this_page;\n\t\t}\n\n\t\tif (wait)\n\t\t\twait_event(bitmap->write_wait,\n\t\t\t\t   atomic_read(&bitmap->pending_writes)==0);\n\t}\n\tif (test_bit(BITMAP_WRITE_ERROR, &bitmap->flags))\n\t\tmd_bitmap_file_kick(bitmap);\n}\n\nstatic void end_bitmap_write(struct buffer_head *bh, int uptodate)\n{\n\tstruct bitmap *bitmap = bh->b_private;\n\n\tif (!uptodate)\n\t\tset_bit(BITMAP_WRITE_ERROR, &bitmap->flags);\n\tif (atomic_dec_and_test(&bitmap->pending_writes))\n\t\twake_up(&bitmap->write_wait);\n}\n\nstatic void free_buffers(struct page *page)\n{\n\tstruct buffer_head *bh;\n\n\tif (!PagePrivate(page))\n\t\treturn;\n\n\tbh = page_buffers(page);\n\twhile (bh) {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tfree_buffer_head(bh);\n\t\tbh = next;\n\t}\n\tdetach_page_private(page);\n\tput_page(page);\n}\n\n/* read a page from a file.\n * We both read the page, and attach buffers to the page to record the\n * address of each block (using bmap).  These addresses will be used\n * to write the block later, completely bypassing the filesystem.\n * This usage is similar to how swap files are handled, and allows us\n * to write to a file with no concerns of memory allocation failing.\n */\nstatic int read_page(struct file *file, unsigned long index,\n\t\t     struct bitmap *bitmap,\n\t\t     unsigned long count,\n\t\t     struct page *page)\n{\n\tint ret = 0;\n\tstruct inode *inode = file_inode(file);\n\tstruct buffer_head *bh;\n\tsector_t block, blk_cur;\n\tunsigned long blocksize = i_blocksize(inode);\n\n\tpr_debug(\"read bitmap file (%dB @ %llu)\\n\", (int)PAGE_SIZE,\n\t\t (unsigned long long)index << PAGE_SHIFT);\n\n\tbh = alloc_page_buffers(page, blocksize, false);\n\tif (!bh) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tattach_page_private(page, bh);\n\tblk_cur = index << (PAGE_SHIFT - inode->i_blkbits);\n\twhile (bh) {\n\t\tblock = blk_cur;\n\n\t\tif (count == 0)\n\t\t\tbh->b_blocknr = 0;\n\t\telse {\n\t\t\tret = bmap(inode, &block);\n\t\t\tif (ret || !block) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbh->b_blocknr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbh->b_blocknr = block;\n\t\t\tbh->b_bdev = inode->i_sb->s_bdev;\n\t\t\tif (count < blocksize)\n\t\t\t\tcount = 0;\n\t\t\telse\n\t\t\t\tcount -= blocksize;\n\n\t\t\tbh->b_end_io = end_bitmap_write;\n\t\t\tbh->b_private = bitmap;\n\t\t\tatomic_inc(&bitmap->pending_writes);\n\t\t\tset_buffer_locked(bh);\n\t\t\tset_buffer_mapped(bh);\n\t\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t\t}\n\t\tblk_cur++;\n\t\tbh = bh->b_this_page;\n\t}\n\tpage->index = index;\n\n\twait_event(bitmap->write_wait,\n\t\t   atomic_read(&bitmap->pending_writes)==0);\n\tif (test_bit(BITMAP_WRITE_ERROR, &bitmap->flags))\n\t\tret = -EIO;\nout:\n\tif (ret)\n\t\tpr_err(\"md: bitmap read error: (%dB @ %llu): %d\\n\",\n\t\t       (int)PAGE_SIZE,\n\t\t       (unsigned long long)index << PAGE_SHIFT,\n\t\t       ret);\n\treturn ret;\n}\n\n/*\n * bitmap file superblock operations\n */\n\n/*\n * md_bitmap_wait_writes() should be called before writing any bitmap\n * blocks, to ensure previous writes, particularly from\n * md_bitmap_daemon_work(), have completed.\n */\nstatic void md_bitmap_wait_writes(struct bitmap *bitmap)\n{\n\tif (bitmap->storage.file)\n\t\twait_event(bitmap->write_wait,\n\t\t\t   atomic_read(&bitmap->pending_writes)==0);\n\telse\n\t\t/* Note that we ignore the return value.  The writes\n\t\t * might have failed, but that would just mean that\n\t\t * some bits which should be cleared haven't been,\n\t\t * which is safe.  The relevant bitmap blocks will\n\t\t * probably get written again, but there is no great\n\t\t * loss if they aren't.\n\t\t */\n\t\tmd_super_wait(bitmap->mddev);\n}\n\n\n/* update the event counter and sync the superblock to disk */\nvoid md_bitmap_update_sb(struct bitmap *bitmap)\n{\n\tbitmap_super_t *sb;\n\n\tif (!bitmap || !bitmap->mddev) /* no bitmap for this array */\n\t\treturn;\n\tif (bitmap->mddev->bitmap_info.external)\n\t\treturn;\n\tif (!bitmap->storage.sb_page) /* no superblock */\n\t\treturn;\n\tsb = kmap_atomic(bitmap->storage.sb_page);\n\tsb->events = cpu_to_le64(bitmap->mddev->events);\n\tif (bitmap->mddev->events < bitmap->events_cleared)\n\t\t/* rocking back to read-only */\n\t\tbitmap->events_cleared = bitmap->mddev->events;\n\tsb->events_cleared = cpu_to_le64(bitmap->events_cleared);\n\t/*\n\t * clear BITMAP_WRITE_ERROR bit to protect against the case that\n\t * a bitmap write error occurred but the later writes succeeded.\n\t */\n\tsb->state = cpu_to_le32(bitmap->flags & ~BIT(BITMAP_WRITE_ERROR));\n\t/* Just in case these have been changed via sysfs: */\n\tsb->daemon_sleep = cpu_to_le32(bitmap->mddev->bitmap_info.daemon_sleep/HZ);\n\tsb->write_behind = cpu_to_le32(bitmap->mddev->bitmap_info.max_write_behind);\n\t/* This might have been changed by a reshape */\n\tsb->sync_size = cpu_to_le64(bitmap->mddev->resync_max_sectors);\n\tsb->chunksize = cpu_to_le32(bitmap->mddev->bitmap_info.chunksize);\n\tsb->nodes = cpu_to_le32(bitmap->mddev->bitmap_info.nodes);\n\tsb->sectors_reserved = cpu_to_le32(bitmap->mddev->\n\t\t\t\t\t   bitmap_info.space);\n\tkunmap_atomic(sb);\n\twrite_page(bitmap, bitmap->storage.sb_page, 1);\n}\nEXPORT_SYMBOL(md_bitmap_update_sb);\n\n/* print out the bitmap file superblock */\nvoid md_bitmap_print_sb(struct bitmap *bitmap)\n{\n\tbitmap_super_t *sb;\n\n\tif (!bitmap || !bitmap->storage.sb_page)\n\t\treturn;\n\tsb = kmap_atomic(bitmap->storage.sb_page);\n\tpr_debug(\"%s: bitmap file superblock:\\n\", bmname(bitmap));\n\tpr_debug(\"         magic: %08x\\n\", le32_to_cpu(sb->magic));\n\tpr_debug(\"       version: %d\\n\", le32_to_cpu(sb->version));\n\tpr_debug(\"          uuid: %08x.%08x.%08x.%08x\\n\",\n\t\t le32_to_cpu(*(__le32 *)(sb->uuid+0)),\n\t\t le32_to_cpu(*(__le32 *)(sb->uuid+4)),\n\t\t le32_to_cpu(*(__le32 *)(sb->uuid+8)),\n\t\t le32_to_cpu(*(__le32 *)(sb->uuid+12)));\n\tpr_debug(\"        events: %llu\\n\",\n\t\t (unsigned long long) le64_to_cpu(sb->events));\n\tpr_debug(\"events cleared: %llu\\n\",\n\t\t (unsigned long long) le64_to_cpu(sb->events_cleared));\n\tpr_debug(\"         state: %08x\\n\", le32_to_cpu(sb->state));\n\tpr_debug(\"     chunksize: %d B\\n\", le32_to_cpu(sb->chunksize));\n\tpr_debug(\"  daemon sleep: %ds\\n\", le32_to_cpu(sb->daemon_sleep));\n\tpr_debug(\"     sync size: %llu KB\\n\",\n\t\t (unsigned long long)le64_to_cpu(sb->sync_size)/2);\n\tpr_debug(\"max write behind: %d\\n\", le32_to_cpu(sb->write_behind));\n\tkunmap_atomic(sb);\n}\n\n/*\n * bitmap_new_disk_sb\n * @bitmap\n *\n * This function is somewhat the reverse of bitmap_read_sb.  bitmap_read_sb\n * reads and verifies the on-disk bitmap superblock and populates bitmap_info.\n * This function verifies 'bitmap_info' and populates the on-disk bitmap\n * structure, which is to be written to disk.\n *\n * Returns: 0 on success, -Exxx on error\n */\nstatic int md_bitmap_new_disk_sb(struct bitmap *bitmap)\n{\n\tbitmap_super_t *sb;\n\tunsigned long chunksize, daemon_sleep, write_behind;\n\n\tbitmap->storage.sb_page = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (bitmap->storage.sb_page == NULL)\n\t\treturn -ENOMEM;\n\tbitmap->storage.sb_page->index = 0;\n\n\tsb = kmap_atomic(bitmap->storage.sb_page);\n\n\tsb->magic = cpu_to_le32(BITMAP_MAGIC);\n\tsb->version = cpu_to_le32(BITMAP_MAJOR_HI);\n\n\tchunksize = bitmap->mddev->bitmap_info.chunksize;\n\tBUG_ON(!chunksize);\n\tif (!is_power_of_2(chunksize)) {\n\t\tkunmap_atomic(sb);\n\t\tpr_warn(\"bitmap chunksize not a power of 2\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsb->chunksize = cpu_to_le32(chunksize);\n\n\tdaemon_sleep = bitmap->mddev->bitmap_info.daemon_sleep;\n\tif (!daemon_sleep || (daemon_sleep > MAX_SCHEDULE_TIMEOUT)) {\n\t\tpr_debug(\"Choosing daemon_sleep default (5 sec)\\n\");\n\t\tdaemon_sleep = 5 * HZ;\n\t}\n\tsb->daemon_sleep = cpu_to_le32(daemon_sleep);\n\tbitmap->mddev->bitmap_info.daemon_sleep = daemon_sleep;\n\n\t/*\n\t * FIXME: write_behind for RAID1.  If not specified, what\n\t * is a good choice?  We choose COUNTER_MAX / 2 arbitrarily.\n\t */\n\twrite_behind = bitmap->mddev->bitmap_info.max_write_behind;\n\tif (write_behind > COUNTER_MAX)\n\t\twrite_behind = COUNTER_MAX / 2;\n\tsb->write_behind = cpu_to_le32(write_behind);\n\tbitmap->mddev->bitmap_info.max_write_behind = write_behind;\n\n\t/* keep the array size field of the bitmap superblock up to date */\n\tsb->sync_size = cpu_to_le64(bitmap->mddev->resync_max_sectors);\n\n\tmemcpy(sb->uuid, bitmap->mddev->uuid, 16);\n\n\tset_bit(BITMAP_STALE, &bitmap->flags);\n\tsb->state = cpu_to_le32(bitmap->flags);\n\tbitmap->events_cleared = bitmap->mddev->events;\n\tsb->events_cleared = cpu_to_le64(bitmap->mddev->events);\n\tbitmap->mddev->bitmap_info.nodes = 0;\n\n\tkunmap_atomic(sb);\n\n\treturn 0;\n}\n\n/* read the superblock from the bitmap file and initialize some bitmap fields */\nstatic int md_bitmap_read_sb(struct bitmap *bitmap)\n{\n\tchar *reason = NULL;\n\tbitmap_super_t *sb;\n\tunsigned long chunksize, daemon_sleep, write_behind;\n\tunsigned long long events;\n\tint nodes = 0;\n\tunsigned long sectors_reserved = 0;\n\tint err = -EINVAL;\n\tstruct page *sb_page;\n\tloff_t offset = bitmap->mddev->bitmap_info.offset;\n\n\tif (!bitmap->storage.file && !bitmap->mddev->bitmap_info.offset) {\n\t\tchunksize = 128 * 1024 * 1024;\n\t\tdaemon_sleep = 5 * HZ;\n\t\twrite_behind = 0;\n\t\tset_bit(BITMAP_STALE, &bitmap->flags);\n\t\terr = 0;\n\t\tgoto out_no_sb;\n\t}\n\t/* page 0 is the superblock, read it... */\n\tsb_page = alloc_page(GFP_KERNEL);\n\tif (!sb_page)\n\t\treturn -ENOMEM;\n\tbitmap->storage.sb_page = sb_page;\n\nre_read:\n\t/* If cluster_slot is set, the cluster is setup */\n\tif (bitmap->cluster_slot >= 0) {\n\t\tsector_t bm_blocks = bitmap->mddev->resync_max_sectors;\n\n\t\tbm_blocks = DIV_ROUND_UP_SECTOR_T(bm_blocks,\n\t\t\t   (bitmap->mddev->bitmap_info.chunksize >> 9));\n\t\t/* bits to bytes */\n\t\tbm_blocks = ((bm_blocks+7) >> 3) + sizeof(bitmap_super_t);\n\t\t/* to 4k blocks */\n\t\tbm_blocks = DIV_ROUND_UP_SECTOR_T(bm_blocks, 4096);\n\t\toffset = bitmap->mddev->bitmap_info.offset + (bitmap->cluster_slot * (bm_blocks << 3));\n\t\tpr_debug(\"%s:%d bm slot: %d offset: %llu\\n\", __func__, __LINE__,\n\t\t\tbitmap->cluster_slot, offset);\n\t}\n\n\tif (bitmap->storage.file) {\n\t\tloff_t isize = i_size_read(bitmap->storage.file->f_mapping->host);\n\t\tint bytes = isize > PAGE_SIZE ? PAGE_SIZE : isize;\n\n\t\terr = read_page(bitmap->storage.file, 0,\n\t\t\t\tbitmap, bytes, sb_page);\n\t} else {\n\t\terr = read_sb_page(bitmap->mddev,\n\t\t\t\t   offset,\n\t\t\t\t   sb_page,\n\t\t\t\t   0, sizeof(bitmap_super_t));\n\t}\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tsb = kmap_atomic(sb_page);\n\n\tchunksize = le32_to_cpu(sb->chunksize);\n\tdaemon_sleep = le32_to_cpu(sb->daemon_sleep) * HZ;\n\twrite_behind = le32_to_cpu(sb->write_behind);\n\tsectors_reserved = le32_to_cpu(sb->sectors_reserved);\n\t/* Setup nodes/clustername only if bitmap version is\n\t * cluster-compatible\n\t */\n\tif (sb->version == cpu_to_le32(BITMAP_MAJOR_CLUSTERED)) {\n\t\tnodes = le32_to_cpu(sb->nodes);\n\t\tstrlcpy(bitmap->mddev->bitmap_info.cluster_name,\n\t\t\t\tsb->cluster_name, 64);\n\t}\n\n\t/* verify that the bitmap-specific fields are valid */\n\tif (sb->magic != cpu_to_le32(BITMAP_MAGIC))\n\t\treason = \"bad magic\";\n\telse if (le32_to_cpu(sb->version) < BITMAP_MAJOR_LO ||\n\t\t le32_to_cpu(sb->version) > BITMAP_MAJOR_CLUSTERED)\n\t\treason = \"unrecognized superblock version\";\n\telse if (chunksize < 512)\n\t\treason = \"bitmap chunksize too small\";\n\telse if (!is_power_of_2(chunksize))\n\t\treason = \"bitmap chunksize not a power of 2\";\n\telse if (daemon_sleep < 1 || daemon_sleep > MAX_SCHEDULE_TIMEOUT)\n\t\treason = \"daemon sleep period out of range\";\n\telse if (write_behind > COUNTER_MAX)\n\t\treason = \"write-behind limit out of range (0 - 16383)\";\n\tif (reason) {\n\t\tpr_warn(\"%s: invalid bitmap file superblock: %s\\n\",\n\t\t\tbmname(bitmap), reason);\n\t\tgoto out;\n\t}\n\n\t/* keep the array size field of the bitmap superblock up to date */\n\tsb->sync_size = cpu_to_le64(bitmap->mddev->resync_max_sectors);\n\n\tif (bitmap->mddev->persistent) {\n\t\t/*\n\t\t * We have a persistent array superblock, so compare the\n\t\t * bitmap's UUID and event counter to the mddev's\n\t\t */\n\t\tif (memcmp(sb->uuid, bitmap->mddev->uuid, 16)) {\n\t\t\tpr_warn(\"%s: bitmap superblock UUID mismatch\\n\",\n\t\t\t\tbmname(bitmap));\n\t\t\tgoto out;\n\t\t}\n\t\tevents = le64_to_cpu(sb->events);\n\t\tif (!nodes && (events < bitmap->mddev->events)) {\n\t\t\tpr_warn(\"%s: bitmap file is out of date (%llu < %llu) -- forcing full recovery\\n\",\n\t\t\t\tbmname(bitmap), events,\n\t\t\t\t(unsigned long long) bitmap->mddev->events);\n\t\t\tset_bit(BITMAP_STALE, &bitmap->flags);\n\t\t}\n\t}\n\n\t/* assign fields using values from superblock */\n\tbitmap->flags |= le32_to_cpu(sb->state);\n\tif (le32_to_cpu(sb->version) == BITMAP_MAJOR_HOSTENDIAN)\n\t\tset_bit(BITMAP_HOSTENDIAN, &bitmap->flags);\n\tbitmap->events_cleared = le64_to_cpu(sb->events_cleared);\n\tstrlcpy(bitmap->mddev->bitmap_info.cluster_name, sb->cluster_name, 64);\n\terr = 0;\n\nout:\n\tkunmap_atomic(sb);\n\t/* Assigning chunksize is required for \"re_read\" */\n\tbitmap->mddev->bitmap_info.chunksize = chunksize;\n\tif (err == 0 && nodes && (bitmap->cluster_slot < 0)) {\n\t\terr = md_setup_cluster(bitmap->mddev, nodes);\n\t\tif (err) {\n\t\t\tpr_warn(\"%s: Could not setup cluster service (%d)\\n\",\n\t\t\t\tbmname(bitmap), err);\n\t\t\tgoto out_no_sb;\n\t\t}\n\t\tbitmap->cluster_slot = md_cluster_ops->slot_number(bitmap->mddev);\n\t\tgoto re_read;\n\t}\n\n\nout_no_sb:\n\tif (test_bit(BITMAP_STALE, &bitmap->flags))\n\t\tbitmap->events_cleared = bitmap->mddev->events;\n\tbitmap->mddev->bitmap_info.chunksize = chunksize;\n\tbitmap->mddev->bitmap_info.daemon_sleep = daemon_sleep;\n\tbitmap->mddev->bitmap_info.max_write_behind = write_behind;\n\tbitmap->mddev->bitmap_info.nodes = nodes;\n\tif (bitmap->mddev->bitmap_info.space == 0 ||\n\t    bitmap->mddev->bitmap_info.space > sectors_reserved)\n\t\tbitmap->mddev->bitmap_info.space = sectors_reserved;\n\tif (err) {\n\t\tmd_bitmap_print_sb(bitmap);\n\t\tif (bitmap->cluster_slot < 0)\n\t\t\tmd_cluster_stop(bitmap->mddev);\n\t}\n\treturn err;\n}\n\n/*\n * general bitmap file operations\n */\n\n/*\n * on-disk bitmap:\n *\n * Use one bit per \"chunk\" (block set). We do the disk I/O on the bitmap\n * file a page at a time. There's a superblock at the start of the file.\n */\n/* calculate the index of the page that contains this bit */\nstatic inline unsigned long file_page_index(struct bitmap_storage *store,\n\t\t\t\t\t    unsigned long chunk)\n{\n\tif (store->sb_page)\n\t\tchunk += sizeof(bitmap_super_t) << 3;\n\treturn chunk >> PAGE_BIT_SHIFT;\n}\n\n/* calculate the (bit) offset of this bit within a page */\nstatic inline unsigned long file_page_offset(struct bitmap_storage *store,\n\t\t\t\t\t     unsigned long chunk)\n{\n\tif (store->sb_page)\n\t\tchunk += sizeof(bitmap_super_t) << 3;\n\treturn chunk & (PAGE_BITS - 1);\n}\n\n/*\n * return a pointer to the page in the filemap that contains the given bit\n *\n */\nstatic inline struct page *filemap_get_page(struct bitmap_storage *store,\n\t\t\t\t\t    unsigned long chunk)\n{\n\tif (file_page_index(store, chunk) >= store->file_pages)\n\t\treturn NULL;\n\treturn store->filemap[file_page_index(store, chunk)];\n}\n\nstatic int md_bitmap_storage_alloc(struct bitmap_storage *store,\n\t\t\t\t   unsigned long chunks, int with_super,\n\t\t\t\t   int slot_number)\n{\n\tint pnum, offset = 0;\n\tunsigned long num_pages;\n\tunsigned long bytes;\n\n\tbytes = DIV_ROUND_UP(chunks, 8);\n\tif (with_super)\n\t\tbytes += sizeof(bitmap_super_t);\n\n\tnum_pages = DIV_ROUND_UP(bytes, PAGE_SIZE);\n\toffset = slot_number * num_pages;\n\n\tstore->filemap = kmalloc_array(num_pages, sizeof(struct page *),\n\t\t\t\t       GFP_KERNEL);\n\tif (!store->filemap)\n\t\treturn -ENOMEM;\n\n\tif (with_super && !store->sb_page) {\n\t\tstore->sb_page = alloc_page(GFP_KERNEL|__GFP_ZERO);\n\t\tif (store->sb_page == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tpnum = 0;\n\tif (store->sb_page) {\n\t\tstore->filemap[0] = store->sb_page;\n\t\tpnum = 1;\n\t\tstore->sb_page->index = offset;\n\t}\n\n\tfor ( ; pnum < num_pages; pnum++) {\n\t\tstore->filemap[pnum] = alloc_page(GFP_KERNEL|__GFP_ZERO);\n\t\tif (!store->filemap[pnum]) {\n\t\t\tstore->file_pages = pnum;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tstore->filemap[pnum]->index = pnum + offset;\n\t}\n\tstore->file_pages = pnum;\n\n\t/* We need 4 bits per page, rounded up to a multiple\n\t * of sizeof(unsigned long) */\n\tstore->filemap_attr = kzalloc(\n\t\troundup(DIV_ROUND_UP(num_pages*4, 8), sizeof(unsigned long)),\n\t\tGFP_KERNEL);\n\tif (!store->filemap_attr)\n\t\treturn -ENOMEM;\n\n\tstore->bytes = bytes;\n\n\treturn 0;\n}\n\nstatic void md_bitmap_file_unmap(struct bitmap_storage *store)\n{\n\tstruct page **map, *sb_page;\n\tint pages;\n\tstruct file *file;\n\n\tfile = store->file;\n\tmap = store->filemap;\n\tpages = store->file_pages;\n\tsb_page = store->sb_page;\n\n\twhile (pages--)\n\t\tif (map[pages] != sb_page) /* 0 is sb_page, release it below */\n\t\t\tfree_buffers(map[pages]);\n\tkfree(map);\n\tkfree(store->filemap_attr);\n\n\tif (sb_page)\n\t\tfree_buffers(sb_page);\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tinvalidate_mapping_pages(inode->i_mapping, 0, -1);\n\t\tfput(file);\n\t}\n}\n\n/*\n * bitmap_file_kick - if an error occurs while manipulating the bitmap file\n * then it is no longer reliable, so we stop using it and we mark the file\n * as failed in the superblock\n */\nstatic void md_bitmap_file_kick(struct bitmap *bitmap)\n{\n\tchar *path, *ptr = NULL;\n\n\tif (!test_and_set_bit(BITMAP_STALE, &bitmap->flags)) {\n\t\tmd_bitmap_update_sb(bitmap);\n\n\t\tif (bitmap->storage.file) {\n\t\t\tpath = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\t\t\tif (path)\n\t\t\t\tptr = file_path(bitmap->storage.file,\n\t\t\t\t\t     path, PAGE_SIZE);\n\n\t\t\tpr_warn(\"%s: kicking failed bitmap file %s from array!\\n\",\n\t\t\t\tbmname(bitmap), IS_ERR(ptr) ? \"\" : ptr);\n\n\t\t\tkfree(path);\n\t\t} else\n\t\t\tpr_warn(\"%s: disabling internal bitmap due to errors\\n\",\n\t\t\t\tbmname(bitmap));\n\t}\n}\n\nenum bitmap_page_attr {\n\tBITMAP_PAGE_DIRTY = 0,     /* there are set bits that need to be synced */\n\tBITMAP_PAGE_PENDING = 1,   /* there are bits that are being cleaned.\n\t\t\t\t    * i.e. counter is 1 or 2. */\n\tBITMAP_PAGE_NEEDWRITE = 2, /* there are cleared bits that need to be synced */\n};\n\nstatic inline void set_page_attr(struct bitmap *bitmap, int pnum,\n\t\t\t\t enum bitmap_page_attr attr)\n{\n\tset_bit((pnum<<2) + attr, bitmap->storage.filemap_attr);\n}\n\nstatic inline void clear_page_attr(struct bitmap *bitmap, int pnum,\n\t\t\t\t   enum bitmap_page_attr attr)\n{\n\tclear_bit((pnum<<2) + attr, bitmap->storage.filemap_attr);\n}\n\nstatic inline int test_page_attr(struct bitmap *bitmap, int pnum,\n\t\t\t\t enum bitmap_page_attr attr)\n{\n\treturn test_bit((pnum<<2) + attr, bitmap->storage.filemap_attr);\n}\n\nstatic inline int test_and_clear_page_attr(struct bitmap *bitmap, int pnum,\n\t\t\t\t\t   enum bitmap_page_attr attr)\n{\n\treturn test_and_clear_bit((pnum<<2) + attr,\n\t\t\t\t  bitmap->storage.filemap_attr);\n}\n/*\n * bitmap_file_set_bit -- called before performing a write to the md device\n * to set (and eventually sync) a particular bit in the bitmap file\n *\n * we set the bit immediately, then we record the page number so that\n * when an unplug occurs, we can flush the dirty pages out to disk\n */\nstatic void md_bitmap_file_set_bit(struct bitmap *bitmap, sector_t block)\n{\n\tunsigned long bit;\n\tstruct page *page;\n\tvoid *kaddr;\n\tunsigned long chunk = block >> bitmap->counts.chunkshift;\n\tstruct bitmap_storage *store = &bitmap->storage;\n\tunsigned long node_offset = 0;\n\n\tif (mddev_is_clustered(bitmap->mddev))\n\t\tnode_offset = bitmap->cluster_slot * store->file_pages;\n\n\tpage = filemap_get_page(&bitmap->storage, chunk);\n\tif (!page)\n\t\treturn;\n\tbit = file_page_offset(&bitmap->storage, chunk);\n\n\t/* set the bit */\n\tkaddr = kmap_atomic(page);\n\tif (test_bit(BITMAP_HOSTENDIAN, &bitmap->flags))\n\t\tset_bit(bit, kaddr);\n\telse\n\t\tset_bit_le(bit, kaddr);\n\tkunmap_atomic(kaddr);\n\tpr_debug(\"set file bit %lu page %lu\\n\", bit, page->index);\n\t/* record page number so it gets flushed to disk when unplug occurs */\n\tset_page_attr(bitmap, page->index - node_offset, BITMAP_PAGE_DIRTY);\n}\n\nstatic void md_bitmap_file_clear_bit(struct bitmap *bitmap, sector_t block)\n{\n\tunsigned long bit;\n\tstruct page *page;\n\tvoid *paddr;\n\tunsigned long chunk = block >> bitmap->counts.chunkshift;\n\tstruct bitmap_storage *store = &bitmap->storage;\n\tunsigned long node_offset = 0;\n\n\tif (mddev_is_clustered(bitmap->mddev))\n\t\tnode_offset = bitmap->cluster_slot * store->file_pages;\n\n\tpage = filemap_get_page(&bitmap->storage, chunk);\n\tif (!page)\n\t\treturn;\n\tbit = file_page_offset(&bitmap->storage, chunk);\n\tpaddr = kmap_atomic(page);\n\tif (test_bit(BITMAP_HOSTENDIAN, &bitmap->flags))\n\t\tclear_bit(bit, paddr);\n\telse\n\t\tclear_bit_le(bit, paddr);\n\tkunmap_atomic(paddr);\n\tif (!test_page_attr(bitmap, page->index - node_offset, BITMAP_PAGE_NEEDWRITE)) {\n\t\tset_page_attr(bitmap, page->index - node_offset, BITMAP_PAGE_PENDING);\n\t\tbitmap->allclean = 0;\n\t}\n}\n\nstatic int md_bitmap_file_test_bit(struct bitmap *bitmap, sector_t block)\n{\n\tunsigned long bit;\n\tstruct page *page;\n\tvoid *paddr;\n\tunsigned long chunk = block >> bitmap->counts.chunkshift;\n\tint set = 0;\n\n\tpage = filemap_get_page(&bitmap->storage, chunk);\n\tif (!page)\n\t\treturn -EINVAL;\n\tbit = file_page_offset(&bitmap->storage, chunk);\n\tpaddr = kmap_atomic(page);\n\tif (test_bit(BITMAP_HOSTENDIAN, &bitmap->flags))\n\t\tset = test_bit(bit, paddr);\n\telse\n\t\tset = test_bit_le(bit, paddr);\n\tkunmap_atomic(paddr);\n\treturn set;\n}\n\n\n/* this gets called when the md device is ready to unplug its underlying\n * (slave) device queues -- before we let any writes go down, we need to\n * sync the dirty pages of the bitmap file to disk */\nvoid md_bitmap_unplug(struct bitmap *bitmap)\n{\n\tunsigned long i;\n\tint dirty, need_write;\n\tint writing = 0;\n\n\tif (!bitmap || !bitmap->storage.filemap ||\n\t    test_bit(BITMAP_STALE, &bitmap->flags))\n\t\treturn;\n\n\t/* look at each page to see if there are any set bits that need to be\n\t * flushed out to disk */\n\tfor (i = 0; i < bitmap->storage.file_pages; i++) {\n\t\tdirty = test_and_clear_page_attr(bitmap, i, BITMAP_PAGE_DIRTY);\n\t\tneed_write = test_and_clear_page_attr(bitmap, i,\n\t\t\t\t\t\t      BITMAP_PAGE_NEEDWRITE);\n\t\tif (dirty || need_write) {\n\t\t\tif (!writing) {\n\t\t\t\tmd_bitmap_wait_writes(bitmap);\n\t\t\t\tif (bitmap->mddev->queue)\n\t\t\t\t\tblk_add_trace_msg(bitmap->mddev->queue,\n\t\t\t\t\t\t\t  \"md bitmap_unplug\");\n\t\t\t}\n\t\t\tclear_page_attr(bitmap, i, BITMAP_PAGE_PENDING);\n\t\t\twrite_page(bitmap, bitmap->storage.filemap[i], 0);\n\t\t\twriting = 1;\n\t\t}\n\t}\n\tif (writing)\n\t\tmd_bitmap_wait_writes(bitmap);\n\n\tif (test_bit(BITMAP_WRITE_ERROR, &bitmap->flags))\n\t\tmd_bitmap_file_kick(bitmap);\n}\nEXPORT_SYMBOL(md_bitmap_unplug);\n\nstatic void md_bitmap_set_memory_bits(struct bitmap *bitmap, sector_t offset, int needed);\n/* * bitmap_init_from_disk -- called at bitmap_create time to initialize\n * the in-memory bitmap from the on-disk bitmap -- also, sets up the\n * memory mapping of the bitmap file\n * Special cases:\n *   if there's no bitmap file, or if the bitmap file had been\n *   previously kicked from the array, we mark all the bits as\n *   1's in order to cause a full resync.\n *\n * We ignore all bits for sectors that end earlier than 'start'.\n * This is used when reading an out-of-date bitmap...\n */\nstatic int md_bitmap_init_from_disk(struct bitmap *bitmap, sector_t start)\n{\n\tunsigned long i, chunks, index, oldindex, bit, node_offset = 0;\n\tstruct page *page = NULL;\n\tunsigned long bit_cnt = 0;\n\tstruct file *file;\n\tunsigned long offset;\n\tint outofdate;\n\tint ret = -ENOSPC;\n\tvoid *paddr;\n\tstruct bitmap_storage *store = &bitmap->storage;\n\n\tchunks = bitmap->counts.chunks;\n\tfile = store->file;\n\n\tif (!file && !bitmap->mddev->bitmap_info.offset) {\n\t\t/* No permanent bitmap - fill with '1s'. */\n\t\tstore->filemap = NULL;\n\t\tstore->file_pages = 0;\n\t\tfor (i = 0; i < chunks ; i++) {\n\t\t\t/* if the disk bit is set, set the memory bit */\n\t\t\tint needed = ((sector_t)(i+1) << (bitmap->counts.chunkshift)\n\t\t\t\t      >= start);\n\t\t\tmd_bitmap_set_memory_bits(bitmap,\n\t\t\t\t\t\t  (sector_t)i << bitmap->counts.chunkshift,\n\t\t\t\t\t\t  needed);\n\t\t}\n\t\treturn 0;\n\t}\n\n\toutofdate = test_bit(BITMAP_STALE, &bitmap->flags);\n\tif (outofdate)\n\t\tpr_warn(\"%s: bitmap file is out of date, doing full recovery\\n\", bmname(bitmap));\n\n\tif (file && i_size_read(file->f_mapping->host) < store->bytes) {\n\t\tpr_warn(\"%s: bitmap file too short %lu < %lu\\n\",\n\t\t\tbmname(bitmap),\n\t\t\t(unsigned long) i_size_read(file->f_mapping->host),\n\t\t\tstore->bytes);\n\t\tgoto err;\n\t}\n\n\toldindex = ~0L;\n\toffset = 0;\n\tif (!bitmap->mddev->bitmap_info.external)\n\t\toffset = sizeof(bitmap_super_t);\n\n\tif (mddev_is_clustered(bitmap->mddev))\n\t\tnode_offset = bitmap->cluster_slot * (DIV_ROUND_UP(store->bytes, PAGE_SIZE));\n\n\tfor (i = 0; i < chunks; i++) {\n\t\tint b;\n\t\tindex = file_page_index(&bitmap->storage, i);\n\t\tbit = file_page_offset(&bitmap->storage, i);\n\t\tif (index != oldindex) { /* this is a new page, read it in */\n\t\t\tint count;\n\t\t\t/* unmap the old page, we're done with it */\n\t\t\tif (index == store->file_pages-1)\n\t\t\t\tcount = store->bytes - index * PAGE_SIZE;\n\t\t\telse\n\t\t\t\tcount = PAGE_SIZE;\n\t\t\tpage = store->filemap[index];\n\t\t\tif (file)\n\t\t\t\tret = read_page(file, index, bitmap,\n\t\t\t\t\t\tcount, page);\n\t\t\telse\n\t\t\t\tret = read_sb_page(\n\t\t\t\t\tbitmap->mddev,\n\t\t\t\t\tbitmap->mddev->bitmap_info.offset,\n\t\t\t\t\tpage,\n\t\t\t\t\tindex + node_offset, count);\n\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\toldindex = index;\n\n\t\t\tif (outofdate) {\n\t\t\t\t/*\n\t\t\t\t * if bitmap is out of date, dirty the\n\t\t\t\t * whole page and write it out\n\t\t\t\t */\n\t\t\t\tpaddr = kmap_atomic(page);\n\t\t\t\tmemset(paddr + offset, 0xff,\n\t\t\t\t       PAGE_SIZE - offset);\n\t\t\t\tkunmap_atomic(paddr);\n\t\t\t\twrite_page(bitmap, page, 1);\n\n\t\t\t\tret = -EIO;\n\t\t\t\tif (test_bit(BITMAP_WRITE_ERROR,\n\t\t\t\t\t     &bitmap->flags))\n\t\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t\tpaddr = kmap_atomic(page);\n\t\tif (test_bit(BITMAP_HOSTENDIAN, &bitmap->flags))\n\t\t\tb = test_bit(bit, paddr);\n\t\telse\n\t\t\tb = test_bit_le(bit, paddr);\n\t\tkunmap_atomic(paddr);\n\t\tif (b) {\n\t\t\t/* if the disk bit is set, set the memory bit */\n\t\t\tint needed = ((sector_t)(i+1) << bitmap->counts.chunkshift\n\t\t\t\t      >= start);\n\t\t\tmd_bitmap_set_memory_bits(bitmap,\n\t\t\t\t\t\t  (sector_t)i << bitmap->counts.chunkshift,\n\t\t\t\t\t\t  needed);\n\t\t\tbit_cnt++;\n\t\t}\n\t\toffset = 0;\n\t}\n\n\tpr_debug(\"%s: bitmap initialized from disk: read %lu pages, set %lu of %lu bits\\n\",\n\t\t bmname(bitmap), store->file_pages,\n\t\t bit_cnt, chunks);\n\n\treturn 0;\n\n err:\n\tpr_warn(\"%s: bitmap initialisation failed: %d\\n\",\n\t\tbmname(bitmap), ret);\n\treturn ret;\n}\n\nvoid md_bitmap_write_all(struct bitmap *bitmap)\n{\n\t/* We don't actually write all bitmap blocks here,\n\t * just flag them as needing to be written\n\t */\n\tint i;\n\n\tif (!bitmap || !bitmap->storage.filemap)\n\t\treturn;\n\tif (bitmap->storage.file)\n\t\t/* Only one copy, so nothing needed */\n\t\treturn;\n\n\tfor (i = 0; i < bitmap->storage.file_pages; i++)\n\t\tset_page_attr(bitmap, i,\n\t\t\t      BITMAP_PAGE_NEEDWRITE);\n\tbitmap->allclean = 0;\n}\n\nstatic void md_bitmap_count_page(struct bitmap_counts *bitmap,\n\t\t\t\t sector_t offset, int inc)\n{\n\tsector_t chunk = offset >> bitmap->chunkshift;\n\tunsigned long page = chunk >> PAGE_COUNTER_SHIFT;\n\tbitmap->bp[page].count += inc;\n\tmd_bitmap_checkfree(bitmap, page);\n}\n\nstatic void md_bitmap_set_pending(struct bitmap_counts *bitmap, sector_t offset)\n{\n\tsector_t chunk = offset >> bitmap->chunkshift;\n\tunsigned long page = chunk >> PAGE_COUNTER_SHIFT;\n\tstruct bitmap_page *bp = &bitmap->bp[page];\n\n\tif (!bp->pending)\n\t\tbp->pending = 1;\n}\n\nstatic bitmap_counter_t *md_bitmap_get_counter(struct bitmap_counts *bitmap,\n\t\t\t\t\t       sector_t offset, sector_t *blocks,\n\t\t\t\t\t       int create);\n\n/*\n * bitmap daemon -- periodically wakes up to clean bits and flush pages\n *\t\t\tout to disk\n */\n\nvoid md_bitmap_daemon_work(struct mddev *mddev)\n{\n\tstruct bitmap *bitmap;\n\tunsigned long j;\n\tunsigned long nextpage;\n\tsector_t blocks;\n\tstruct bitmap_counts *counts;\n\n\t/* Use a mutex to guard daemon_work against\n\t * bitmap_destroy.\n\t */\n\tmutex_lock(&mddev->bitmap_info.mutex);\n\tbitmap = mddev->bitmap;\n\tif (bitmap == NULL) {\n\t\tmutex_unlock(&mddev->bitmap_info.mutex);\n\t\treturn;\n\t}\n\tif (time_before(jiffies, bitmap->daemon_lastrun\n\t\t\t+ mddev->bitmap_info.daemon_sleep))\n\t\tgoto done;\n\n\tbitmap->daemon_lastrun = jiffies;\n\tif (bitmap->allclean) {\n\t\tmddev->thread->timeout = MAX_SCHEDULE_TIMEOUT;\n\t\tgoto done;\n\t}\n\tbitmap->allclean = 1;\n\n\tif (bitmap->mddev->queue)\n\t\tblk_add_trace_msg(bitmap->mddev->queue,\n\t\t\t\t  \"md bitmap_daemon_work\");\n\n\t/* Any file-page which is PENDING now needs to be written.\n\t * So set NEEDWRITE now, then after we make any last-minute changes\n\t * we will write it.\n\t */\n\tfor (j = 0; j < bitmap->storage.file_pages; j++)\n\t\tif (test_and_clear_page_attr(bitmap, j,\n\t\t\t\t\t     BITMAP_PAGE_PENDING))\n\t\t\tset_page_attr(bitmap, j,\n\t\t\t\t      BITMAP_PAGE_NEEDWRITE);\n\n\tif (bitmap->need_sync &&\n\t    mddev->bitmap_info.external == 0) {\n\t\t/* Arrange for superblock update as well as\n\t\t * other changes */\n\t\tbitmap_super_t *sb;\n\t\tbitmap->need_sync = 0;\n\t\tif (bitmap->storage.filemap) {\n\t\t\tsb = kmap_atomic(bitmap->storage.sb_page);\n\t\t\tsb->events_cleared =\n\t\t\t\tcpu_to_le64(bitmap->events_cleared);\n\t\t\tkunmap_atomic(sb);\n\t\t\tset_page_attr(bitmap, 0,\n\t\t\t\t      BITMAP_PAGE_NEEDWRITE);\n\t\t}\n\t}\n\t/* Now look at the bitmap counters and if any are '2' or '1',\n\t * decrement and handle accordingly.\n\t */\n\tcounts = &bitmap->counts;\n\tspin_lock_irq(&counts->lock);\n\tnextpage = 0;\n\tfor (j = 0; j < counts->chunks; j++) {\n\t\tbitmap_counter_t *bmc;\n\t\tsector_t  block = (sector_t)j << counts->chunkshift;\n\n\t\tif (j == nextpage) {\n\t\t\tnextpage += PAGE_COUNTER_RATIO;\n\t\t\tif (!counts->bp[j >> PAGE_COUNTER_SHIFT].pending) {\n\t\t\t\tj |= PAGE_COUNTER_MASK;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcounts->bp[j >> PAGE_COUNTER_SHIFT].pending = 0;\n\t\t}\n\n\t\tbmc = md_bitmap_get_counter(counts, block, &blocks, 0);\n\t\tif (!bmc) {\n\t\t\tj |= PAGE_COUNTER_MASK;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*bmc == 1 && !bitmap->need_sync) {\n\t\t\t/* We can clear the bit */\n\t\t\t*bmc = 0;\n\t\t\tmd_bitmap_count_page(counts, block, -1);\n\t\t\tmd_bitmap_file_clear_bit(bitmap, block);\n\t\t} else if (*bmc && *bmc <= 2) {\n\t\t\t*bmc = 1;\n\t\t\tmd_bitmap_set_pending(counts, block);\n\t\t\tbitmap->allclean = 0;\n\t\t}\n\t}\n\tspin_unlock_irq(&counts->lock);\n\n\tmd_bitmap_wait_writes(bitmap);\n\t/* Now start writeout on any page in NEEDWRITE that isn't DIRTY.\n\t * DIRTY pages need to be written by bitmap_unplug so it can wait\n\t * for them.\n\t * If we find any DIRTY page we stop there and let bitmap_unplug\n\t * handle all the rest.  This is important in the case where\n\t * the first blocking holds the superblock and it has been updated.\n\t * We mustn't write any other blocks before the superblock.\n\t */\n\tfor (j = 0;\n\t     j < bitmap->storage.file_pages\n\t\t     && !test_bit(BITMAP_STALE, &bitmap->flags);\n\t     j++) {\n\t\tif (test_page_attr(bitmap, j,\n\t\t\t\t   BITMAP_PAGE_DIRTY))\n\t\t\t/* bitmap_unplug will handle the rest */\n\t\t\tbreak;\n\t\tif (bitmap->storage.filemap &&\n\t\t    test_and_clear_page_attr(bitmap, j,\n\t\t\t\t\t     BITMAP_PAGE_NEEDWRITE)) {\n\t\t\twrite_page(bitmap, bitmap->storage.filemap[j], 0);\n\t\t}\n\t}\n\n done:\n\tif (bitmap->allclean == 0)\n\t\tmddev->thread->timeout =\n\t\t\tmddev->bitmap_info.daemon_sleep;\n\tmutex_unlock(&mddev->bitmap_info.mutex);\n}\n\nstatic bitmap_counter_t *md_bitmap_get_counter(struct bitmap_counts *bitmap,\n\t\t\t\t\t       sector_t offset, sector_t *blocks,\n\t\t\t\t\t       int create)\n__releases(bitmap->lock)\n__acquires(bitmap->lock)\n{\n\t/* If 'create', we might release the lock and reclaim it.\n\t * The lock must have been taken with interrupts enabled.\n\t * If !create, we don't release the lock.\n\t */\n\tsector_t chunk = offset >> bitmap->chunkshift;\n\tunsigned long page = chunk >> PAGE_COUNTER_SHIFT;\n\tunsigned long pageoff = (chunk & PAGE_COUNTER_MASK) << COUNTER_BYTE_SHIFT;\n\tsector_t csize;\n\tint err;\n\n\terr = md_bitmap_checkpage(bitmap, page, create, 0);\n\n\tif (bitmap->bp[page].hijacked ||\n\t    bitmap->bp[page].map == NULL)\n\t\tcsize = ((sector_t)1) << (bitmap->chunkshift +\n\t\t\t\t\t  PAGE_COUNTER_SHIFT);\n\telse\n\t\tcsize = ((sector_t)1) << bitmap->chunkshift;\n\t*blocks = csize - (offset & (csize - 1));\n\n\tif (err < 0)\n\t\treturn NULL;\n\n\t/* now locked ... */\n\n\tif (bitmap->bp[page].hijacked) { /* hijacked pointer */\n\t\t/* should we use the first or second counter field\n\t\t * of the hijacked pointer? */\n\t\tint hi = (pageoff > PAGE_COUNTER_MASK);\n\t\treturn  &((bitmap_counter_t *)\n\t\t\t  &bitmap->bp[page].map)[hi];\n\t} else /* page is allocated */\n\t\treturn (bitmap_counter_t *)\n\t\t\t&(bitmap->bp[page].map[pageoff]);\n}\n\nint md_bitmap_startwrite(struct bitmap *bitmap, sector_t offset, unsigned long sectors, int behind)\n{\n\tif (!bitmap)\n\t\treturn 0;\n\n\tif (behind) {\n\t\tint bw;\n\t\tatomic_inc(&bitmap->behind_writes);\n\t\tbw = atomic_read(&bitmap->behind_writes);\n\t\tif (bw > bitmap->behind_writes_used)\n\t\t\tbitmap->behind_writes_used = bw;\n\n\t\tpr_debug(\"inc write-behind count %d/%lu\\n\",\n\t\t\t bw, bitmap->mddev->bitmap_info.max_write_behind);\n\t}\n\n\twhile (sectors) {\n\t\tsector_t blocks;\n\t\tbitmap_counter_t *bmc;\n\n\t\tspin_lock_irq(&bitmap->counts.lock);\n\t\tbmc = md_bitmap_get_counter(&bitmap->counts, offset, &blocks, 1);\n\t\tif (!bmc) {\n\t\t\tspin_unlock_irq(&bitmap->counts.lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (unlikely(COUNTER(*bmc) == COUNTER_MAX)) {\n\t\t\tDEFINE_WAIT(__wait);\n\t\t\t/* note that it is safe to do the prepare_to_wait\n\t\t\t * after the test as long as we do it before dropping\n\t\t\t * the spinlock.\n\t\t\t */\n\t\t\tprepare_to_wait(&bitmap->overflow_wait, &__wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&bitmap->counts.lock);\n\t\t\tschedule();\n\t\t\tfinish_wait(&bitmap->overflow_wait, &__wait);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (*bmc) {\n\t\tcase 0:\n\t\t\tmd_bitmap_file_set_bit(bitmap, offset);\n\t\t\tmd_bitmap_count_page(&bitmap->counts, offset, 1);\n\t\t\tfallthrough;\n\t\tcase 1:\n\t\t\t*bmc = 2;\n\t\t}\n\n\t\t(*bmc)++;\n\n\t\tspin_unlock_irq(&bitmap->counts.lock);\n\n\t\toffset += blocks;\n\t\tif (sectors > blocks)\n\t\t\tsectors -= blocks;\n\t\telse\n\t\t\tsectors = 0;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(md_bitmap_startwrite);\n\nvoid md_bitmap_endwrite(struct bitmap *bitmap, sector_t offset,\n\t\t\tunsigned long sectors, int success, int behind)\n{\n\tif (!bitmap)\n\t\treturn;\n\tif (behind) {\n\t\tif (atomic_dec_and_test(&bitmap->behind_writes))\n\t\t\twake_up(&bitmap->behind_wait);\n\t\tpr_debug(\"dec write-behind count %d/%lu\\n\",\n\t\t\t atomic_read(&bitmap->behind_writes),\n\t\t\t bitmap->mddev->bitmap_info.max_write_behind);\n\t}\n\n\twhile (sectors) {\n\t\tsector_t blocks;\n\t\tunsigned long flags;\n\t\tbitmap_counter_t *bmc;\n\n\t\tspin_lock_irqsave(&bitmap->counts.lock, flags);\n\t\tbmc = md_bitmap_get_counter(&bitmap->counts, offset, &blocks, 0);\n\t\tif (!bmc) {\n\t\t\tspin_unlock_irqrestore(&bitmap->counts.lock, flags);\n\t\t\treturn;\n\t\t}\n\n\t\tif (success && !bitmap->mddev->degraded &&\n\t\t    bitmap->events_cleared < bitmap->mddev->events) {\n\t\t\tbitmap->events_cleared = bitmap->mddev->events;\n\t\t\tbitmap->need_sync = 1;\n\t\t\tsysfs_notify_dirent_safe(bitmap->sysfs_can_clear);\n\t\t}\n\n\t\tif (!success && !NEEDED(*bmc))\n\t\t\t*bmc |= NEEDED_MASK;\n\n\t\tif (COUNTER(*bmc) == COUNTER_MAX)\n\t\t\twake_up(&bitmap->overflow_wait);\n\n\t\t(*bmc)--;\n\t\tif (*bmc <= 2) {\n\t\t\tmd_bitmap_set_pending(&bitmap->counts, offset);\n\t\t\tbitmap->allclean = 0;\n\t\t}\n\t\tspin_unlock_irqrestore(&bitmap->counts.lock, flags);\n\t\toffset += blocks;\n\t\tif (sectors > blocks)\n\t\t\tsectors -= blocks;\n\t\telse\n\t\t\tsectors = 0;\n\t}\n}\nEXPORT_SYMBOL(md_bitmap_endwrite);\n\nstatic int __bitmap_start_sync(struct bitmap *bitmap, sector_t offset, sector_t *blocks,\n\t\t\t       int degraded)\n{\n\tbitmap_counter_t *bmc;\n\tint rv;\n\tif (bitmap == NULL) {/* FIXME or bitmap set as 'failed' */\n\t\t*blocks = 1024;\n\t\treturn 1; /* always resync if no bitmap */\n\t}\n\tspin_lock_irq(&bitmap->counts.lock);\n\tbmc = md_bitmap_get_counter(&bitmap->counts, offset, blocks, 0);\n\trv = 0;\n\tif (bmc) {\n\t\t/* locked */\n\t\tif (RESYNC(*bmc))\n\t\t\trv = 1;\n\t\telse if (NEEDED(*bmc)) {\n\t\t\trv = 1;\n\t\t\tif (!degraded) { /* don't set/clear bits if degraded */\n\t\t\t\t*bmc |= RESYNC_MASK;\n\t\t\t\t*bmc &= ~NEEDED_MASK;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irq(&bitmap->counts.lock);\n\treturn rv;\n}\n\nint md_bitmap_start_sync(struct bitmap *bitmap, sector_t offset, sector_t *blocks,\n\t\t\t int degraded)\n{\n\t/* bitmap_start_sync must always report on multiples of whole\n\t * pages, otherwise resync (which is very PAGE_SIZE based) will\n\t * get confused.\n\t * So call __bitmap_start_sync repeatedly (if needed) until\n\t * At least PAGE_SIZE>>9 blocks are covered.\n\t * Return the 'or' of the result.\n\t */\n\tint rv = 0;\n\tsector_t blocks1;\n\n\t*blocks = 0;\n\twhile (*blocks < (PAGE_SIZE>>9)) {\n\t\trv |= __bitmap_start_sync(bitmap, offset,\n\t\t\t\t\t  &blocks1, degraded);\n\t\toffset += blocks1;\n\t\t*blocks += blocks1;\n\t}\n\treturn rv;\n}\nEXPORT_SYMBOL(md_bitmap_start_sync);\n\nvoid md_bitmap_end_sync(struct bitmap *bitmap, sector_t offset, sector_t *blocks, int aborted)\n{\n\tbitmap_counter_t *bmc;\n\tunsigned long flags;\n\n\tif (bitmap == NULL) {\n\t\t*blocks = 1024;\n\t\treturn;\n\t}\n\tspin_lock_irqsave(&bitmap->counts.lock, flags);\n\tbmc = md_bitmap_get_counter(&bitmap->counts, offset, blocks, 0);\n\tif (bmc == NULL)\n\t\tgoto unlock;\n\t/* locked */\n\tif (RESYNC(*bmc)) {\n\t\t*bmc &= ~RESYNC_MASK;\n\n\t\tif (!NEEDED(*bmc) && aborted)\n\t\t\t*bmc |= NEEDED_MASK;\n\t\telse {\n\t\t\tif (*bmc <= 2) {\n\t\t\t\tmd_bitmap_set_pending(&bitmap->counts, offset);\n\t\t\t\tbitmap->allclean = 0;\n\t\t\t}\n\t\t}\n\t}\n unlock:\n\tspin_unlock_irqrestore(&bitmap->counts.lock, flags);\n}\nEXPORT_SYMBOL(md_bitmap_end_sync);\n\nvoid md_bitmap_close_sync(struct bitmap *bitmap)\n{\n\t/* Sync has finished, and any bitmap chunks that weren't synced\n\t * properly have been aborted.  It remains to us to clear the\n\t * RESYNC bit wherever it is still on\n\t */\n\tsector_t sector = 0;\n\tsector_t blocks;\n\tif (!bitmap)\n\t\treturn;\n\twhile (sector < bitmap->mddev->resync_max_sectors) {\n\t\tmd_bitmap_end_sync(bitmap, sector, &blocks, 0);\n\t\tsector += blocks;\n\t}\n}\nEXPORT_SYMBOL(md_bitmap_close_sync);\n\nvoid md_bitmap_cond_end_sync(struct bitmap *bitmap, sector_t sector, bool force)\n{\n\tsector_t s = 0;\n\tsector_t blocks;\n\n\tif (!bitmap)\n\t\treturn;\n\tif (sector == 0) {\n\t\tbitmap->last_end_sync = jiffies;\n\t\treturn;\n\t}\n\tif (!force && time_before(jiffies, (bitmap->last_end_sync\n\t\t\t\t  + bitmap->mddev->bitmap_info.daemon_sleep)))\n\t\treturn;\n\twait_event(bitmap->mddev->recovery_wait,\n\t\t   atomic_read(&bitmap->mddev->recovery_active) == 0);\n\n\tbitmap->mddev->curr_resync_completed = sector;\n\tset_bit(MD_SB_CHANGE_CLEAN, &bitmap->mddev->sb_flags);\n\tsector &= ~((1ULL << bitmap->counts.chunkshift) - 1);\n\ts = 0;\n\twhile (s < sector && s < bitmap->mddev->resync_max_sectors) {\n\t\tmd_bitmap_end_sync(bitmap, s, &blocks, 0);\n\t\ts += blocks;\n\t}\n\tbitmap->last_end_sync = jiffies;\n\tsysfs_notify_dirent_safe(bitmap->mddev->sysfs_completed);\n}\nEXPORT_SYMBOL(md_bitmap_cond_end_sync);\n\nvoid md_bitmap_sync_with_cluster(struct mddev *mddev,\n\t\t\t      sector_t old_lo, sector_t old_hi,\n\t\t\t      sector_t new_lo, sector_t new_hi)\n{\n\tstruct bitmap *bitmap = mddev->bitmap;\n\tsector_t sector, blocks = 0;\n\n\tfor (sector = old_lo; sector < new_lo; ) {\n\t\tmd_bitmap_end_sync(bitmap, sector, &blocks, 0);\n\t\tsector += blocks;\n\t}\n\tWARN((blocks > new_lo) && old_lo, \"alignment is not correct for lo\\n\");\n\n\tfor (sector = old_hi; sector < new_hi; ) {\n\t\tmd_bitmap_start_sync(bitmap, sector, &blocks, 0);\n\t\tsector += blocks;\n\t}\n\tWARN((blocks > new_hi) && old_hi, \"alignment is not correct for hi\\n\");\n}\nEXPORT_SYMBOL(md_bitmap_sync_with_cluster);\n\nstatic void md_bitmap_set_memory_bits(struct bitmap *bitmap, sector_t offset, int needed)\n{\n\t/* For each chunk covered by any of these sectors, set the\n\t * counter to 2 and possibly set resync_needed.  They should all\n\t * be 0 at this point\n\t */\n\n\tsector_t secs;\n\tbitmap_counter_t *bmc;\n\tspin_lock_irq(&bitmap->counts.lock);\n\tbmc = md_bitmap_get_counter(&bitmap->counts, offset, &secs, 1);\n\tif (!bmc) {\n\t\tspin_unlock_irq(&bitmap->counts.lock);\n\t\treturn;\n\t}\n\tif (!*bmc) {\n\t\t*bmc = 2;\n\t\tmd_bitmap_count_page(&bitmap->counts, offset, 1);\n\t\tmd_bitmap_set_pending(&bitmap->counts, offset);\n\t\tbitmap->allclean = 0;\n\t}\n\tif (needed)\n\t\t*bmc |= NEEDED_MASK;\n\tspin_unlock_irq(&bitmap->counts.lock);\n}\n\n/* dirty the memory and file bits for bitmap chunks \"s\" to \"e\" */\nvoid md_bitmap_dirty_bits(struct bitmap *bitmap, unsigned long s, unsigned long e)\n{\n\tunsigned long chunk;\n\n\tfor (chunk = s; chunk <= e; chunk++) {\n\t\tsector_t sec = (sector_t)chunk << bitmap->counts.chunkshift;\n\t\tmd_bitmap_set_memory_bits(bitmap, sec, 1);\n\t\tmd_bitmap_file_set_bit(bitmap, sec);\n\t\tif (sec < bitmap->mddev->recovery_cp)\n\t\t\t/* We are asserting that the array is dirty,\n\t\t\t * so move the recovery_cp address back so\n\t\t\t * that it is obvious that it is dirty\n\t\t\t */\n\t\t\tbitmap->mddev->recovery_cp = sec;\n\t}\n}\n\n/*\n * flush out any pending updates\n */\nvoid md_bitmap_flush(struct mddev *mddev)\n{\n\tstruct bitmap *bitmap = mddev->bitmap;\n\tlong sleep;\n\n\tif (!bitmap) /* there was no bitmap */\n\t\treturn;\n\n\t/* run the daemon_work three time to ensure everything is flushed\n\t * that can be\n\t */\n\tsleep = mddev->bitmap_info.daemon_sleep * 2;\n\tbitmap->daemon_lastrun -= sleep;\n\tmd_bitmap_daemon_work(mddev);\n\tbitmap->daemon_lastrun -= sleep;\n\tmd_bitmap_daemon_work(mddev);\n\tbitmap->daemon_lastrun -= sleep;\n\tmd_bitmap_daemon_work(mddev);\n\tmd_bitmap_update_sb(bitmap);\n}\n\n/*\n * free memory that was allocated\n */\nvoid md_bitmap_free(struct bitmap *bitmap)\n{\n\tunsigned long k, pages;\n\tstruct bitmap_page *bp;\n\n\tif (!bitmap) /* there was no bitmap */\n\t\treturn;\n\n\tif (bitmap->sysfs_can_clear)\n\t\tsysfs_put(bitmap->sysfs_can_clear);\n\n\tif (mddev_is_clustered(bitmap->mddev) && bitmap->mddev->cluster_info &&\n\t\tbitmap->cluster_slot == md_cluster_ops->slot_number(bitmap->mddev))\n\t\tmd_cluster_stop(bitmap->mddev);\n\n\t/* Shouldn't be needed - but just in case.... */\n\twait_event(bitmap->write_wait,\n\t\t   atomic_read(&bitmap->pending_writes) == 0);\n\n\t/* release the bitmap file  */\n\tmd_bitmap_file_unmap(&bitmap->storage);\n\n\tbp = bitmap->counts.bp;\n\tpages = bitmap->counts.pages;\n\n\t/* free all allocated memory */\n\n\tif (bp) /* deallocate the page memory */\n\t\tfor (k = 0; k < pages; k++)\n\t\t\tif (bp[k].map && !bp[k].hijacked)\n\t\t\t\tkfree(bp[k].map);\n\tkfree(bp);\n\tkfree(bitmap);\n}\nEXPORT_SYMBOL(md_bitmap_free);\n\nvoid md_bitmap_wait_behind_writes(struct mddev *mddev)\n{\n\tstruct bitmap *bitmap = mddev->bitmap;\n\n\t/* wait for behind writes to complete */\n\tif (bitmap && atomic_read(&bitmap->behind_writes) > 0) {\n\t\tpr_debug(\"md:%s: behind writes in progress - waiting to stop.\\n\",\n\t\t\t mdname(mddev));\n\t\t/* need to kick something here to make sure I/O goes? */\n\t\twait_event(bitmap->behind_wait,\n\t\t\t   atomic_read(&bitmap->behind_writes) == 0);\n\t}\n}\n\nvoid md_bitmap_destroy(struct mddev *mddev)\n{\n\tstruct bitmap *bitmap = mddev->bitmap;\n\n\tif (!bitmap) /* there was no bitmap */\n\t\treturn;\n\n\tmd_bitmap_wait_behind_writes(mddev);\n\tif (!mddev->serialize_policy)\n\t\tmddev_destroy_serial_pool(mddev, NULL, true);\n\n\tmutex_lock(&mddev->bitmap_info.mutex);\n\tspin_lock(&mddev->lock);\n\tmddev->bitmap = NULL; /* disconnect from the md device */\n\tspin_unlock(&mddev->lock);\n\tmutex_unlock(&mddev->bitmap_info.mutex);\n\tif (mddev->thread)\n\t\tmddev->thread->timeout = MAX_SCHEDULE_TIMEOUT;\n\n\tmd_bitmap_free(bitmap);\n}\n\n/*\n * initialize the bitmap structure\n * if this returns an error, bitmap_destroy must be called to do clean up\n * once mddev->bitmap is set\n */\nstruct bitmap *md_bitmap_create(struct mddev *mddev, int slot)\n{\n\tstruct bitmap *bitmap;\n\tsector_t blocks = mddev->resync_max_sectors;\n\tstruct file *file = mddev->bitmap_info.file;\n\tint err;\n\tstruct kernfs_node *bm = NULL;\n\n\tBUILD_BUG_ON(sizeof(bitmap_super_t) != 256);\n\n\tBUG_ON(file && mddev->bitmap_info.offset);\n\n\tif (test_bit(MD_HAS_JOURNAL, &mddev->flags)) {\n\t\tpr_notice(\"md/raid:%s: array with journal cannot have bitmap\\n\",\n\t\t\t  mdname(mddev));\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tbitmap = kzalloc(sizeof(*bitmap), GFP_KERNEL);\n\tif (!bitmap)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&bitmap->counts.lock);\n\tatomic_set(&bitmap->pending_writes, 0);\n\tinit_waitqueue_head(&bitmap->write_wait);\n\tinit_waitqueue_head(&bitmap->overflow_wait);\n\tinit_waitqueue_head(&bitmap->behind_wait);\n\n\tbitmap->mddev = mddev;\n\tbitmap->cluster_slot = slot;\n\n\tif (mddev->kobj.sd)\n\t\tbm = sysfs_get_dirent(mddev->kobj.sd, \"bitmap\");\n\tif (bm) {\n\t\tbitmap->sysfs_can_clear = sysfs_get_dirent(bm, \"can_clear\");\n\t\tsysfs_put(bm);\n\t} else\n\t\tbitmap->sysfs_can_clear = NULL;\n\n\tbitmap->storage.file = file;\n\tif (file) {\n\t\tget_file(file);\n\t\t/* As future accesses to this file will use bmap,\n\t\t * and bypass the page cache, we must sync the file\n\t\t * first.\n\t\t */\n\t\tvfs_fsync(file, 1);\n\t}\n\t/* read superblock from bitmap file (this sets mddev->bitmap_info.chunksize) */\n\tif (!mddev->bitmap_info.external) {\n\t\t/*\n\t\t * If 'MD_ARRAY_FIRST_USE' is set, then device-mapper is\n\t\t * instructing us to create a new on-disk bitmap instance.\n\t\t */\n\t\tif (test_and_clear_bit(MD_ARRAY_FIRST_USE, &mddev->flags))\n\t\t\terr = md_bitmap_new_disk_sb(bitmap);\n\t\telse\n\t\t\terr = md_bitmap_read_sb(bitmap);\n\t} else {\n\t\terr = 0;\n\t\tif (mddev->bitmap_info.chunksize == 0 ||\n\t\t    mddev->bitmap_info.daemon_sleep == 0)\n\t\t\t/* chunksize and time_base need to be\n\t\t\t * set first. */\n\t\t\terr = -EINVAL;\n\t}\n\tif (err)\n\t\tgoto error;\n\n\tbitmap->daemon_lastrun = jiffies;\n\terr = md_bitmap_resize(bitmap, blocks, mddev->bitmap_info.chunksize, 1);\n\tif (err)\n\t\tgoto error;\n\n\tpr_debug(\"created bitmap (%lu pages) for device %s\\n\",\n\t\t bitmap->counts.pages, bmname(bitmap));\n\n\terr = test_bit(BITMAP_WRITE_ERROR, &bitmap->flags) ? -EIO : 0;\n\tif (err)\n\t\tgoto error;\n\n\treturn bitmap;\n error:\n\tmd_bitmap_free(bitmap);\n\treturn ERR_PTR(err);\n}\n\nint md_bitmap_load(struct mddev *mddev)\n{\n\tint err = 0;\n\tsector_t start = 0;\n\tsector_t sector = 0;\n\tstruct bitmap *bitmap = mddev->bitmap;\n\tstruct md_rdev *rdev;\n\n\tif (!bitmap)\n\t\tgoto out;\n\n\trdev_for_each(rdev, mddev)\n\t\tmddev_create_serial_pool(mddev, rdev, true);\n\n\tif (mddev_is_clustered(mddev))\n\t\tmd_cluster_ops->load_bitmaps(mddev, mddev->bitmap_info.nodes);\n\n\t/* Clear out old bitmap info first:  Either there is none, or we\n\t * are resuming after someone else has possibly changed things,\n\t * so we should forget old cached info.\n\t * All chunks should be clean, but some might need_sync.\n\t */\n\twhile (sector < mddev->resync_max_sectors) {\n\t\tsector_t blocks;\n\t\tmd_bitmap_start_sync(bitmap, sector, &blocks, 0);\n\t\tsector += blocks;\n\t}\n\tmd_bitmap_close_sync(bitmap);\n\n\tif (mddev->degraded == 0\n\t    || bitmap->events_cleared == mddev->events)\n\t\t/* no need to keep dirty bits to optimise a\n\t\t * re-add of a missing device */\n\t\tstart = mddev->recovery_cp;\n\n\tmutex_lock(&mddev->bitmap_info.mutex);\n\terr = md_bitmap_init_from_disk(bitmap, start);\n\tmutex_unlock(&mddev->bitmap_info.mutex);\n\n\tif (err)\n\t\tgoto out;\n\tclear_bit(BITMAP_STALE, &bitmap->flags);\n\n\t/* Kick recovery in case any bits were set */\n\tset_bit(MD_RECOVERY_NEEDED, &bitmap->mddev->recovery);\n\n\tmddev->thread->timeout = mddev->bitmap_info.daemon_sleep;\n\tmd_wakeup_thread(mddev->thread);\n\n\tmd_bitmap_update_sb(bitmap);\n\n\tif (test_bit(BITMAP_WRITE_ERROR, &bitmap->flags))\n\t\terr = -EIO;\nout:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(md_bitmap_load);\n\n/* caller need to free returned bitmap with md_bitmap_free() */\nstruct bitmap *get_bitmap_from_slot(struct mddev *mddev, int slot)\n{\n\tint rv = 0;\n\tstruct bitmap *bitmap;\n\n\tbitmap = md_bitmap_create(mddev, slot);\n\tif (IS_ERR(bitmap)) {\n\t\trv = PTR_ERR(bitmap);\n\t\treturn ERR_PTR(rv);\n\t}\n\n\trv = md_bitmap_init_from_disk(bitmap, 0);\n\tif (rv) {\n\t\tmd_bitmap_free(bitmap);\n\t\treturn ERR_PTR(rv);\n\t}\n\n\treturn bitmap;\n}\nEXPORT_SYMBOL(get_bitmap_from_slot);\n\n/* Loads the bitmap associated with slot and copies the resync information\n * to our bitmap\n */\nint md_bitmap_copy_from_slot(struct mddev *mddev, int slot,\n\t\tsector_t *low, sector_t *high, bool clear_bits)\n{\n\tint rv = 0, i, j;\n\tsector_t block, lo = 0, hi = 0;\n\tstruct bitmap_counts *counts;\n\tstruct bitmap *bitmap;\n\n\tbitmap = get_bitmap_from_slot(mddev, slot);\n\tif (IS_ERR(bitmap)) {\n\t\tpr_err(\"%s can't get bitmap from slot %d\\n\", __func__, slot);\n\t\treturn -1;\n\t}\n\n\tcounts = &bitmap->counts;\n\tfor (j = 0; j < counts->chunks; j++) {\n\t\tblock = (sector_t)j << counts->chunkshift;\n\t\tif (md_bitmap_file_test_bit(bitmap, block)) {\n\t\t\tif (!lo)\n\t\t\t\tlo = block;\n\t\t\thi = block;\n\t\t\tmd_bitmap_file_clear_bit(bitmap, block);\n\t\t\tmd_bitmap_set_memory_bits(mddev->bitmap, block, 1);\n\t\t\tmd_bitmap_file_set_bit(mddev->bitmap, block);\n\t\t}\n\t}\n\n\tif (clear_bits) {\n\t\tmd_bitmap_update_sb(bitmap);\n\t\t/* BITMAP_PAGE_PENDING is set, but bitmap_unplug needs\n\t\t * BITMAP_PAGE_DIRTY or _NEEDWRITE to write ... */\n\t\tfor (i = 0; i < bitmap->storage.file_pages; i++)\n\t\t\tif (test_page_attr(bitmap, i, BITMAP_PAGE_PENDING))\n\t\t\t\tset_page_attr(bitmap, i, BITMAP_PAGE_NEEDWRITE);\n\t\tmd_bitmap_unplug(bitmap);\n\t}\n\tmd_bitmap_unplug(mddev->bitmap);\n\t*low = lo;\n\t*high = hi;\n\tmd_bitmap_free(bitmap);\n\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(md_bitmap_copy_from_slot);\n\n\nvoid md_bitmap_status(struct seq_file *seq, struct bitmap *bitmap)\n{\n\tunsigned long chunk_kb;\n\tstruct bitmap_counts *counts;\n\n\tif (!bitmap)\n\t\treturn;\n\n\tcounts = &bitmap->counts;\n\n\tchunk_kb = bitmap->mddev->bitmap_info.chunksize >> 10;\n\tseq_printf(seq, \"bitmap: %lu/%lu pages [%luKB], \"\n\t\t   \"%lu%s chunk\",\n\t\t   counts->pages - counts->missing_pages,\n\t\t   counts->pages,\n\t\t   (counts->pages - counts->missing_pages)\n\t\t   << (PAGE_SHIFT - 10),\n\t\t   chunk_kb ? chunk_kb : bitmap->mddev->bitmap_info.chunksize,\n\t\t   chunk_kb ? \"KB\" : \"B\");\n\tif (bitmap->storage.file) {\n\t\tseq_printf(seq, \", file: \");\n\t\tseq_file_path(seq, bitmap->storage.file, \" \\t\\n\");\n\t}\n\n\tseq_printf(seq, \"\\n\");\n}\n\nint md_bitmap_resize(struct bitmap *bitmap, sector_t blocks,\n\t\t  int chunksize, int init)\n{\n\t/* If chunk_size is 0, choose an appropriate chunk size.\n\t * Then possibly allocate new storage space.\n\t * Then quiesce, copy bits, replace bitmap, and re-start\n\t *\n\t * This function is called both to set up the initial bitmap\n\t * and to resize the bitmap while the array is active.\n\t * If this happens as a result of the array being resized,\n\t * chunksize will be zero, and we need to choose a suitable\n\t * chunksize, otherwise we use what we are given.\n\t */\n\tstruct bitmap_storage store;\n\tstruct bitmap_counts old_counts;\n\tunsigned long chunks;\n\tsector_t block;\n\tsector_t old_blocks, new_blocks;\n\tint chunkshift;\n\tint ret = 0;\n\tlong pages;\n\tstruct bitmap_page *new_bp;\n\n\tif (bitmap->storage.file && !init) {\n\t\tpr_info(\"md: cannot resize file-based bitmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (chunksize == 0) {\n\t\t/* If there is enough space, leave the chunk size unchanged,\n\t\t * else increase by factor of two until there is enough space.\n\t\t */\n\t\tlong bytes;\n\t\tlong space = bitmap->mddev->bitmap_info.space;\n\n\t\tif (space == 0) {\n\t\t\t/* We don't know how much space there is, so limit\n\t\t\t * to current size - in sectors.\n\t\t\t */\n\t\t\tbytes = DIV_ROUND_UP(bitmap->counts.chunks, 8);\n\t\t\tif (!bitmap->mddev->bitmap_info.external)\n\t\t\t\tbytes += sizeof(bitmap_super_t);\n\t\t\tspace = DIV_ROUND_UP(bytes, 512);\n\t\t\tbitmap->mddev->bitmap_info.space = space;\n\t\t}\n\t\tchunkshift = bitmap->counts.chunkshift;\n\t\tchunkshift--;\n\t\tdo {\n\t\t\t/* 'chunkshift' is shift from block size to chunk size */\n\t\t\tchunkshift++;\n\t\t\tchunks = DIV_ROUND_UP_SECTOR_T(blocks, 1 << chunkshift);\n\t\t\tbytes = DIV_ROUND_UP(chunks, 8);\n\t\t\tif (!bitmap->mddev->bitmap_info.external)\n\t\t\t\tbytes += sizeof(bitmap_super_t);\n\t\t} while (bytes > (space << 9));\n\t} else\n\t\tchunkshift = ffz(~chunksize) - BITMAP_BLOCK_SHIFT;\n\n\tchunks = DIV_ROUND_UP_SECTOR_T(blocks, 1 << chunkshift);\n\tmemset(&store, 0, sizeof(store));\n\tif (bitmap->mddev->bitmap_info.offset || bitmap->mddev->bitmap_info.file)\n\t\tret = md_bitmap_storage_alloc(&store, chunks,\n\t\t\t\t\t      !bitmap->mddev->bitmap_info.external,\n\t\t\t\t\t      mddev_is_clustered(bitmap->mddev)\n\t\t\t\t\t      ? bitmap->cluster_slot : 0);\n\tif (ret) {\n\t\tmd_bitmap_file_unmap(&store);\n\t\tgoto err;\n\t}\n\n\tpages = DIV_ROUND_UP(chunks, PAGE_COUNTER_RATIO);\n\n\tnew_bp = kcalloc(pages, sizeof(*new_bp), GFP_KERNEL);\n\tret = -ENOMEM;\n\tif (!new_bp) {\n\t\tmd_bitmap_file_unmap(&store);\n\t\tgoto err;\n\t}\n\n\tif (!init)\n\t\tbitmap->mddev->pers->quiesce(bitmap->mddev, 1);\n\n\tstore.file = bitmap->storage.file;\n\tbitmap->storage.file = NULL;\n\n\tif (store.sb_page && bitmap->storage.sb_page)\n\t\tmemcpy(page_address(store.sb_page),\n\t\t       page_address(bitmap->storage.sb_page),\n\t\t       sizeof(bitmap_super_t));\n\tspin_lock_irq(&bitmap->counts.lock);\n\tmd_bitmap_file_unmap(&bitmap->storage);\n\tbitmap->storage = store;\n\n\told_counts = bitmap->counts;\n\tbitmap->counts.bp = new_bp;\n\tbitmap->counts.pages = pages;\n\tbitmap->counts.missing_pages = pages;\n\tbitmap->counts.chunkshift = chunkshift;\n\tbitmap->counts.chunks = chunks;\n\tbitmap->mddev->bitmap_info.chunksize = 1 << (chunkshift +\n\t\t\t\t\t\t     BITMAP_BLOCK_SHIFT);\n\n\tblocks = min(old_counts.chunks << old_counts.chunkshift,\n\t\t     chunks << chunkshift);\n\n\t/* For cluster raid, need to pre-allocate bitmap */\n\tif (mddev_is_clustered(bitmap->mddev)) {\n\t\tunsigned long page;\n\t\tfor (page = 0; page < pages; page++) {\n\t\t\tret = md_bitmap_checkpage(&bitmap->counts, page, 1, 1);\n\t\t\tif (ret) {\n\t\t\t\tunsigned long k;\n\n\t\t\t\t/* deallocate the page memory */\n\t\t\t\tfor (k = 0; k < page; k++) {\n\t\t\t\t\tkfree(new_bp[k].map);\n\t\t\t\t}\n\t\t\t\tkfree(new_bp);\n\n\t\t\t\t/* restore some fields from old_counts */\n\t\t\t\tbitmap->counts.bp = old_counts.bp;\n\t\t\t\tbitmap->counts.pages = old_counts.pages;\n\t\t\t\tbitmap->counts.missing_pages = old_counts.pages;\n\t\t\t\tbitmap->counts.chunkshift = old_counts.chunkshift;\n\t\t\t\tbitmap->counts.chunks = old_counts.chunks;\n\t\t\t\tbitmap->mddev->bitmap_info.chunksize = 1 << (old_counts.chunkshift +\n\t\t\t\t\t\t\t\t\t     BITMAP_BLOCK_SHIFT);\n\t\t\t\tblocks = old_counts.chunks << old_counts.chunkshift;\n\t\t\t\tpr_warn(\"Could not pre-allocate in-memory bitmap for cluster raid\\n\");\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tbitmap->counts.bp[page].count += 1;\n\t\t}\n\t}\n\n\tfor (block = 0; block < blocks; ) {\n\t\tbitmap_counter_t *bmc_old, *bmc_new;\n\t\tint set;\n\n\t\tbmc_old = md_bitmap_get_counter(&old_counts, block, &old_blocks, 0);\n\t\tset = bmc_old && NEEDED(*bmc_old);\n\n\t\tif (set) {\n\t\t\tbmc_new = md_bitmap_get_counter(&bitmap->counts, block, &new_blocks, 1);\n\t\t\tif (*bmc_new == 0) {\n\t\t\t\t/* need to set on-disk bits too. */\n\t\t\t\tsector_t end = block + new_blocks;\n\t\t\t\tsector_t start = block >> chunkshift;\n\t\t\t\tstart <<= chunkshift;\n\t\t\t\twhile (start < end) {\n\t\t\t\t\tmd_bitmap_file_set_bit(bitmap, block);\n\t\t\t\t\tstart += 1 << chunkshift;\n\t\t\t\t}\n\t\t\t\t*bmc_new = 2;\n\t\t\t\tmd_bitmap_count_page(&bitmap->counts, block, 1);\n\t\t\t\tmd_bitmap_set_pending(&bitmap->counts, block);\n\t\t\t}\n\t\t\t*bmc_new |= NEEDED_MASK;\n\t\t\tif (new_blocks < old_blocks)\n\t\t\t\told_blocks = new_blocks;\n\t\t}\n\t\tblock += old_blocks;\n\t}\n\n\tif (bitmap->counts.bp != old_counts.bp) {\n\t\tunsigned long k;\n\t\tfor (k = 0; k < old_counts.pages; k++)\n\t\t\tif (!old_counts.bp[k].hijacked)\n\t\t\t\tkfree(old_counts.bp[k].map);\n\t\tkfree(old_counts.bp);\n\t}\n\n\tif (!init) {\n\t\tint i;\n\t\twhile (block < (chunks << chunkshift)) {\n\t\t\tbitmap_counter_t *bmc;\n\t\t\tbmc = md_bitmap_get_counter(&bitmap->counts, block, &new_blocks, 1);\n\t\t\tif (bmc) {\n\t\t\t\t/* new space.  It needs to be resynced, so\n\t\t\t\t * we set NEEDED_MASK.\n\t\t\t\t */\n\t\t\t\tif (*bmc == 0) {\n\t\t\t\t\t*bmc = NEEDED_MASK | 2;\n\t\t\t\t\tmd_bitmap_count_page(&bitmap->counts, block, 1);\n\t\t\t\t\tmd_bitmap_set_pending(&bitmap->counts, block);\n\t\t\t\t}\n\t\t\t}\n\t\t\tblock += new_blocks;\n\t\t}\n\t\tfor (i = 0; i < bitmap->storage.file_pages; i++)\n\t\t\tset_page_attr(bitmap, i, BITMAP_PAGE_DIRTY);\n\t}\n\tspin_unlock_irq(&bitmap->counts.lock);\n\n\tif (!init) {\n\t\tmd_bitmap_unplug(bitmap);\n\t\tbitmap->mddev->pers->quiesce(bitmap->mddev, 0);\n\t}\n\tret = 0;\nerr:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(md_bitmap_resize);\n\nstatic ssize_t\nlocation_show(struct mddev *mddev, char *page)\n{\n\tssize_t len;\n\tif (mddev->bitmap_info.file)\n\t\tlen = sprintf(page, \"file\");\n\telse if (mddev->bitmap_info.offset)\n\t\tlen = sprintf(page, \"%+lld\", (long long)mddev->bitmap_info.offset);\n\telse\n\t\tlen = sprintf(page, \"none\");\n\tlen += sprintf(page+len, \"\\n\");\n\treturn len;\n}\n\nstatic ssize_t\nlocation_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\tint rv;\n\n\trv = mddev_lock(mddev);\n\tif (rv)\n\t\treturn rv;\n\tif (mddev->pers) {\n\t\tif (!mddev->pers->quiesce) {\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tif (mddev->recovery || mddev->sync_thread) {\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (mddev->bitmap || mddev->bitmap_info.file ||\n\t    mddev->bitmap_info.offset) {\n\t\t/* bitmap already configured.  Only option is to clear it */\n\t\tif (strncmp(buf, \"none\", 4) != 0) {\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tif (mddev->pers) {\n\t\t\tmddev_suspend(mddev);\n\t\t\tmd_bitmap_destroy(mddev);\n\t\t\tmddev_resume(mddev);\n\t\t}\n\t\tmddev->bitmap_info.offset = 0;\n\t\tif (mddev->bitmap_info.file) {\n\t\t\tstruct file *f = mddev->bitmap_info.file;\n\t\t\tmddev->bitmap_info.file = NULL;\n\t\t\tfput(f);\n\t\t}\n\t} else {\n\t\t/* No bitmap, OK to set a location */\n\t\tlong long offset;\n\t\tif (strncmp(buf, \"none\", 4) == 0)\n\t\t\t/* nothing to be done */;\n\t\telse if (strncmp(buf, \"file:\", 5) == 0) {\n\t\t\t/* Not supported yet */\n\t\t\trv = -EINVAL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (buf[0] == '+')\n\t\t\t\trv = kstrtoll(buf+1, 10, &offset);\n\t\t\telse\n\t\t\t\trv = kstrtoll(buf, 10, &offset);\n\t\t\tif (rv)\n\t\t\t\tgoto out;\n\t\t\tif (offset == 0) {\n\t\t\t\trv = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (mddev->bitmap_info.external == 0 &&\n\t\t\t    mddev->major_version == 0 &&\n\t\t\t    offset != mddev->bitmap_info.default_offset) {\n\t\t\t\trv = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmddev->bitmap_info.offset = offset;\n\t\t\tif (mddev->pers) {\n\t\t\t\tstruct bitmap *bitmap;\n\t\t\t\tbitmap = md_bitmap_create(mddev, -1);\n\t\t\t\tmddev_suspend(mddev);\n\t\t\t\tif (IS_ERR(bitmap))\n\t\t\t\t\trv = PTR_ERR(bitmap);\n\t\t\t\telse {\n\t\t\t\t\tmddev->bitmap = bitmap;\n\t\t\t\t\trv = md_bitmap_load(mddev);\n\t\t\t\t\tif (rv)\n\t\t\t\t\t\tmddev->bitmap_info.offset = 0;\n\t\t\t\t}\n\t\t\t\tif (rv) {\n\t\t\t\t\tmd_bitmap_destroy(mddev);\n\t\t\t\t\tmddev_resume(mddev);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmddev_resume(mddev);\n\t\t\t}\n\t\t}\n\t}\n\tif (!mddev->external) {\n\t\t/* Ensure new bitmap info is stored in\n\t\t * metadata promptly.\n\t\t */\n\t\tset_bit(MD_SB_CHANGE_DEVS, &mddev->sb_flags);\n\t\tmd_wakeup_thread(mddev->thread);\n\t}\n\trv = 0;\nout:\n\tmddev_unlock(mddev);\n\tif (rv)\n\t\treturn rv;\n\treturn len;\n}\n\nstatic struct md_sysfs_entry bitmap_location =\n__ATTR(location, S_IRUGO|S_IWUSR, location_show, location_store);\n\n/* 'bitmap/space' is the space available at 'location' for the\n * bitmap.  This allows the kernel to know when it is safe to\n * resize the bitmap to match a resized array.\n */\nstatic ssize_t\nspace_show(struct mddev *mddev, char *page)\n{\n\treturn sprintf(page, \"%lu\\n\", mddev->bitmap_info.space);\n}\n\nstatic ssize_t\nspace_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\tunsigned long sectors;\n\tint rv;\n\n\trv = kstrtoul(buf, 10, &sectors);\n\tif (rv)\n\t\treturn rv;\n\n\tif (sectors == 0)\n\t\treturn -EINVAL;\n\n\tif (mddev->bitmap &&\n\t    sectors < (mddev->bitmap->storage.bytes + 511) >> 9)\n\t\treturn -EFBIG; /* Bitmap is too big for this small space */\n\n\t/* could make sure it isn't too big, but that isn't really\n\t * needed - user-space should be careful.\n\t */\n\tmddev->bitmap_info.space = sectors;\n\treturn len;\n}\n\nstatic struct md_sysfs_entry bitmap_space =\n__ATTR(space, S_IRUGO|S_IWUSR, space_show, space_store);\n\nstatic ssize_t\ntimeout_show(struct mddev *mddev, char *page)\n{\n\tssize_t len;\n\tunsigned long secs = mddev->bitmap_info.daemon_sleep / HZ;\n\tunsigned long jifs = mddev->bitmap_info.daemon_sleep % HZ;\n\n\tlen = sprintf(page, \"%lu\", secs);\n\tif (jifs)\n\t\tlen += sprintf(page+len, \".%03u\", jiffies_to_msecs(jifs));\n\tlen += sprintf(page+len, \"\\n\");\n\treturn len;\n}\n\nstatic ssize_t\ntimeout_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\t/* timeout can be set at any time */\n\tunsigned long timeout;\n\tint rv = strict_strtoul_scaled(buf, &timeout, 4);\n\tif (rv)\n\t\treturn rv;\n\n\t/* just to make sure we don't overflow... */\n\tif (timeout >= LONG_MAX / HZ)\n\t\treturn -EINVAL;\n\n\ttimeout = timeout * HZ / 10000;\n\n\tif (timeout >= MAX_SCHEDULE_TIMEOUT)\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT-1;\n\tif (timeout < 1)\n\t\ttimeout = 1;\n\tmddev->bitmap_info.daemon_sleep = timeout;\n\tif (mddev->thread) {\n\t\t/* if thread->timeout is MAX_SCHEDULE_TIMEOUT, then\n\t\t * the bitmap is all clean and we don't need to\n\t\t * adjust the timeout right now\n\t\t */\n\t\tif (mddev->thread->timeout < MAX_SCHEDULE_TIMEOUT) {\n\t\t\tmddev->thread->timeout = timeout;\n\t\t\tmd_wakeup_thread(mddev->thread);\n\t\t}\n\t}\n\treturn len;\n}\n\nstatic struct md_sysfs_entry bitmap_timeout =\n__ATTR(time_base, S_IRUGO|S_IWUSR, timeout_show, timeout_store);\n\nstatic ssize_t\nbacklog_show(struct mddev *mddev, char *page)\n{\n\treturn sprintf(page, \"%lu\\n\", mddev->bitmap_info.max_write_behind);\n}\n\nstatic ssize_t\nbacklog_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\tunsigned long backlog;\n\tunsigned long old_mwb = mddev->bitmap_info.max_write_behind;\n\tint rv = kstrtoul(buf, 10, &backlog);\n\tif (rv)\n\t\treturn rv;\n\tif (backlog > COUNTER_MAX)\n\t\treturn -EINVAL;\n\tmddev->bitmap_info.max_write_behind = backlog;\n\tif (!backlog && mddev->serial_info_pool) {\n\t\t/* serial_info_pool is not needed if backlog is zero */\n\t\tif (!mddev->serialize_policy)\n\t\t\tmddev_destroy_serial_pool(mddev, NULL, false);\n\t} else if (backlog && !mddev->serial_info_pool) {\n\t\t/* serial_info_pool is needed since backlog is not zero */\n\t\tstruct md_rdev *rdev;\n\n\t\trdev_for_each(rdev, mddev)\n\t\t\tmddev_create_serial_pool(mddev, rdev, false);\n\t}\n\tif (old_mwb != backlog)\n\t\tmd_bitmap_update_sb(mddev->bitmap);\n\treturn len;\n}\n\nstatic struct md_sysfs_entry bitmap_backlog =\n__ATTR(backlog, S_IRUGO|S_IWUSR, backlog_show, backlog_store);\n\nstatic ssize_t\nchunksize_show(struct mddev *mddev, char *page)\n{\n\treturn sprintf(page, \"%lu\\n\", mddev->bitmap_info.chunksize);\n}\n\nstatic ssize_t\nchunksize_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\t/* Can only be changed when no bitmap is active */\n\tint rv;\n\tunsigned long csize;\n\tif (mddev->bitmap)\n\t\treturn -EBUSY;\n\trv = kstrtoul(buf, 10, &csize);\n\tif (rv)\n\t\treturn rv;\n\tif (csize < 512 ||\n\t    !is_power_of_2(csize))\n\t\treturn -EINVAL;\n\tmddev->bitmap_info.chunksize = csize;\n\treturn len;\n}\n\nstatic struct md_sysfs_entry bitmap_chunksize =\n__ATTR(chunksize, S_IRUGO|S_IWUSR, chunksize_show, chunksize_store);\n\nstatic ssize_t metadata_show(struct mddev *mddev, char *page)\n{\n\tif (mddev_is_clustered(mddev))\n\t\treturn sprintf(page, \"clustered\\n\");\n\treturn sprintf(page, \"%s\\n\", (mddev->bitmap_info.external\n\t\t\t\t      ? \"external\" : \"internal\"));\n}\n\nstatic ssize_t metadata_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\tif (mddev->bitmap ||\n\t    mddev->bitmap_info.file ||\n\t    mddev->bitmap_info.offset)\n\t\treturn -EBUSY;\n\tif (strncmp(buf, \"external\", 8) == 0)\n\t\tmddev->bitmap_info.external = 1;\n\telse if ((strncmp(buf, \"internal\", 8) == 0) ||\n\t\t\t(strncmp(buf, \"clustered\", 9) == 0))\n\t\tmddev->bitmap_info.external = 0;\n\telse\n\t\treturn -EINVAL;\n\treturn len;\n}\n\nstatic struct md_sysfs_entry bitmap_metadata =\n__ATTR(metadata, S_IRUGO|S_IWUSR, metadata_show, metadata_store);\n\nstatic ssize_t can_clear_show(struct mddev *mddev, char *page)\n{\n\tint len;\n\tspin_lock(&mddev->lock);\n\tif (mddev->bitmap)\n\t\tlen = sprintf(page, \"%s\\n\", (mddev->bitmap->need_sync ?\n\t\t\t\t\t     \"false\" : \"true\"));\n\telse\n\t\tlen = sprintf(page, \"\\n\");\n\tspin_unlock(&mddev->lock);\n\treturn len;\n}\n\nstatic ssize_t can_clear_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\tif (mddev->bitmap == NULL)\n\t\treturn -ENOENT;\n\tif (strncmp(buf, \"false\", 5) == 0)\n\t\tmddev->bitmap->need_sync = 1;\n\telse if (strncmp(buf, \"true\", 4) == 0) {\n\t\tif (mddev->degraded)\n\t\t\treturn -EBUSY;\n\t\tmddev->bitmap->need_sync = 0;\n\t} else\n\t\treturn -EINVAL;\n\treturn len;\n}\n\nstatic struct md_sysfs_entry bitmap_can_clear =\n__ATTR(can_clear, S_IRUGO|S_IWUSR, can_clear_show, can_clear_store);\n\nstatic ssize_t\nbehind_writes_used_show(struct mddev *mddev, char *page)\n{\n\tssize_t ret;\n\tspin_lock(&mddev->lock);\n\tif (mddev->bitmap == NULL)\n\t\tret = sprintf(page, \"0\\n\");\n\telse\n\t\tret = sprintf(page, \"%lu\\n\",\n\t\t\t      mddev->bitmap->behind_writes_used);\n\tspin_unlock(&mddev->lock);\n\treturn ret;\n}\n\nstatic ssize_t\nbehind_writes_used_reset(struct mddev *mddev, const char *buf, size_t len)\n{\n\tif (mddev->bitmap)\n\t\tmddev->bitmap->behind_writes_used = 0;\n\treturn len;\n}\n\nstatic struct md_sysfs_entry max_backlog_used =\n__ATTR(max_backlog_used, S_IRUGO | S_IWUSR,\n       behind_writes_used_show, behind_writes_used_reset);\n\nstatic struct attribute *md_bitmap_attrs[] = {\n\t&bitmap_location.attr,\n\t&bitmap_space.attr,\n\t&bitmap_timeout.attr,\n\t&bitmap_backlog.attr,\n\t&bitmap_chunksize.attr,\n\t&bitmap_metadata.attr,\n\t&bitmap_can_clear.attr,\n\t&max_backlog_used.attr,\n\tNULL\n};\nstruct attribute_group md_bitmap_group = {\n\t.name = \"bitmap\",\n\t.attrs = md_bitmap_attrs,\n};\n"}, "1": {"id": 1, "path": "/src/drivers/md/md.h", "content": "/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n   md.h : kernel internal structure of the Linux MD driver\n          Copyright (C) 1996-98 Ingo Molnar, Gadi Oxman\n\n*/\n\n#ifndef _MD_MD_H\n#define _MD_MD_H\n\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/badblocks.h>\n#include <linux/kobject.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/timer.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n#include \"md-cluster.h\"\n\n#define MaxSector (~(sector_t)0)\n\n/*\n * These flags should really be called \"NO_RETRY\" rather than\n * \"FAILFAST\" because they don't make any promise about time lapse,\n * only about the number of retries, which will be zero.\n * REQ_FAILFAST_DRIVER is not included because\n * Commit: 4a27446f3e39 (\"[SCSI] modify scsi to handle new fail fast flags.\")\n * seems to suggest that the errors it avoids retrying should usually\n * be retried.\n */\n#define\tMD_FAILFAST\t(REQ_FAILFAST_DEV | REQ_FAILFAST_TRANSPORT)\n\n/*\n * The struct embedded in rdev is used to serialize IO.\n */\nstruct serial_in_rdev {\n\tstruct rb_root_cached serial_rb;\n\tspinlock_t serial_lock;\n\twait_queue_head_t serial_io_wait;\n};\n\n/*\n * MD's 'extended' device\n */\nstruct md_rdev {\n\tstruct list_head same_set;\t/* RAID devices within the same set */\n\n\tsector_t sectors;\t\t/* Device size (in 512bytes sectors) */\n\tstruct mddev *mddev;\t\t/* RAID array if running */\n\tint last_events;\t\t/* IO event timestamp */\n\n\t/*\n\t * If meta_bdev is non-NULL, it means that a separate device is\n\t * being used to store the metadata (superblock/bitmap) which\n\t * would otherwise be contained on the same device as the data (bdev).\n\t */\n\tstruct block_device *meta_bdev;\n\tstruct block_device *bdev;\t/* block device handle */\n\n\tstruct page\t*sb_page, *bb_page;\n\tint\t\tsb_loaded;\n\t__u64\t\tsb_events;\n\tsector_t\tdata_offset;\t/* start of data in array */\n\tsector_t\tnew_data_offset;/* only relevant while reshaping */\n\tsector_t\tsb_start;\t/* offset of the super block (in 512byte sectors) */\n\tint\t\tsb_size;\t/* bytes in the superblock */\n\tint\t\tpreferred_minor;\t/* autorun support */\n\n\tstruct kobject\tkobj;\n\n\t/* A device can be in one of three states based on two flags:\n\t * Not working:   faulty==1 in_sync==0\n\t * Fully working: faulty==0 in_sync==1\n\t * Working, but not\n\t * in sync with array\n\t *                faulty==0 in_sync==0\n\t *\n\t * It can never have faulty==1, in_sync==1\n\t * This reduces the burden of testing multiple flags in many cases\n\t */\n\n\tunsigned long\tflags;\t/* bit set of 'enum flag_bits' bits. */\n\twait_queue_head_t blocked_wait;\n\n\tint desc_nr;\t\t\t/* descriptor index in the superblock */\n\tint raid_disk;\t\t\t/* role of device in array */\n\tint new_raid_disk;\t\t/* role that the device will have in\n\t\t\t\t\t * the array after a level-change completes.\n\t\t\t\t\t */\n\tint saved_raid_disk;\t\t/* role that device used to have in the\n\t\t\t\t\t * array and could again if we did a partial\n\t\t\t\t\t * resync from the bitmap\n\t\t\t\t\t */\n\tunion {\n\t\tsector_t recovery_offset;/* If this device has been partially\n\t\t\t\t\t * recovered, this is where we were\n\t\t\t\t\t * up to.\n\t\t\t\t\t */\n\t\tsector_t journal_tail;\t/* If this device is a journal device,\n\t\t\t\t\t * this is the journal tail (journal\n\t\t\t\t\t * recovery start point)\n\t\t\t\t\t */\n\t};\n\n\tatomic_t\tnr_pending;\t/* number of pending requests.\n\t\t\t\t\t * only maintained for arrays that\n\t\t\t\t\t * support hot removal\n\t\t\t\t\t */\n\tatomic_t\tread_errors;\t/* number of consecutive read errors that\n\t\t\t\t\t * we have tried to ignore.\n\t\t\t\t\t */\n\ttime64_t\tlast_read_error;\t/* monotonic time since our\n\t\t\t\t\t\t * last read error\n\t\t\t\t\t\t */\n\tatomic_t\tcorrected_errors; /* number of corrected read errors,\n\t\t\t\t\t   * for reporting to userspace and storing\n\t\t\t\t\t   * in superblock.\n\t\t\t\t\t   */\n\n\tstruct serial_in_rdev *serial;  /* used for raid1 io serialization */\n\n\tstruct work_struct del_work;\t/* used for delayed sysfs removal */\n\n\tstruct kernfs_node *sysfs_state; /* handle for 'state'\n\t\t\t\t\t   * sysfs entry */\n\t/* handle for 'unacknowledged_bad_blocks' sysfs dentry */\n\tstruct kernfs_node *sysfs_unack_badblocks;\n\t/* handle for 'bad_blocks' sysfs dentry */\n\tstruct kernfs_node *sysfs_badblocks;\n\tstruct badblocks badblocks;\n\n\tstruct {\n\t\tshort offset;\t/* Offset from superblock to start of PPL.\n\t\t\t\t * Not used by external metadata. */\n\t\tunsigned int size;\t/* Size in sectors of the PPL space */\n\t\tsector_t sector;\t/* First sector of the PPL space */\n\t} ppl;\n};\nenum flag_bits {\n\tFaulty,\t\t\t/* device is known to have a fault */\n\tIn_sync,\t\t/* device is in_sync with rest of array */\n\tBitmap_sync,\t\t/* ..actually, not quite In_sync.  Need a\n\t\t\t\t * bitmap-based recovery to get fully in sync.\n\t\t\t\t * The bit is only meaningful before device\n\t\t\t\t * has been passed to pers->hot_add_disk.\n\t\t\t\t */\n\tWriteMostly,\t\t/* Avoid reading if at all possible */\n\tAutoDetected,\t\t/* added by auto-detect */\n\tBlocked,\t\t/* An error occurred but has not yet\n\t\t\t\t * been acknowledged by the metadata\n\t\t\t\t * handler, so don't allow writes\n\t\t\t\t * until it is cleared */\n\tWriteErrorSeen,\t\t/* A write error has been seen on this\n\t\t\t\t * device\n\t\t\t\t */\n\tFaultRecorded,\t\t/* Intermediate state for clearing\n\t\t\t\t * Blocked.  The Fault is/will-be\n\t\t\t\t * recorded in the metadata, but that\n\t\t\t\t * metadata hasn't been stored safely\n\t\t\t\t * on disk yet.\n\t\t\t\t */\n\tBlockedBadBlocks,\t/* A writer is blocked because they\n\t\t\t\t * found an unacknowledged bad-block.\n\t\t\t\t * This can safely be cleared at any\n\t\t\t\t * time, and the writer will re-check.\n\t\t\t\t * It may be set at any time, and at\n\t\t\t\t * worst the writer will timeout and\n\t\t\t\t * re-check.  So setting it as\n\t\t\t\t * accurately as possible is good, but\n\t\t\t\t * not absolutely critical.\n\t\t\t\t */\n\tWantReplacement,\t/* This device is a candidate to be\n\t\t\t\t * hot-replaced, either because it has\n\t\t\t\t * reported some faults, or because\n\t\t\t\t * of explicit request.\n\t\t\t\t */\n\tReplacement,\t\t/* This device is a replacement for\n\t\t\t\t * a want_replacement device with same\n\t\t\t\t * raid_disk number.\n\t\t\t\t */\n\tCandidate,\t\t/* For clustered environments only:\n\t\t\t\t * This device is seen locally but not\n\t\t\t\t * by the whole cluster\n\t\t\t\t */\n\tJournal,\t\t/* This device is used as journal for\n\t\t\t\t * raid-5/6.\n\t\t\t\t * Usually, this device should be faster\n\t\t\t\t * than other devices in the array\n\t\t\t\t */\n\tClusterRemove,\n\tRemoveSynchronized,\t/* synchronize_rcu() was called after\n\t\t\t\t * this device was known to be faulty,\n\t\t\t\t * so it is safe to remove without\n\t\t\t\t * another synchronize_rcu() call.\n\t\t\t\t */\n\tExternalBbl,            /* External metadata provides bad\n\t\t\t\t * block management for a disk\n\t\t\t\t */\n\tFailFast,\t\t/* Minimal retries should be attempted on\n\t\t\t\t * this device, so use REQ_FAILFAST_DEV.\n\t\t\t\t * Also don't try to repair failed reads.\n\t\t\t\t * It is expects that no bad block log\n\t\t\t\t * is present.\n\t\t\t\t */\n\tLastDev,\t\t/* Seems to be the last working dev as\n\t\t\t\t * it didn't fail, so don't use FailFast\n\t\t\t\t * any more for metadata\n\t\t\t\t */\n\tCollisionCheck,\t\t/*\n\t\t\t\t * check if there is collision between raid1\n\t\t\t\t * serial bios.\n\t\t\t\t */\n};\n\nstatic inline int is_badblock(struct md_rdev *rdev, sector_t s, int sectors,\n\t\t\t      sector_t *first_bad, int *bad_sectors)\n{\n\tif (unlikely(rdev->badblocks.count)) {\n\t\tint rv = badblocks_check(&rdev->badblocks, rdev->data_offset + s,\n\t\t\t\t\tsectors,\n\t\t\t\t\tfirst_bad, bad_sectors);\n\t\tif (rv)\n\t\t\t*first_bad -= rdev->data_offset;\n\t\treturn rv;\n\t}\n\treturn 0;\n}\nextern int rdev_set_badblocks(struct md_rdev *rdev, sector_t s, int sectors,\n\t\t\t      int is_new);\nextern int rdev_clear_badblocks(struct md_rdev *rdev, sector_t s, int sectors,\n\t\t\t\tint is_new);\nstruct md_cluster_info;\n\n/* change UNSUPPORTED_MDDEV_FLAGS for each array type if new flag is added */\nenum mddev_flags {\n\tMD_ARRAY_FIRST_USE,\t/* First use of array, needs initialization */\n\tMD_CLOSING,\t\t/* If set, we are closing the array, do not open\n\t\t\t\t * it then */\n\tMD_JOURNAL_CLEAN,\t/* A raid with journal is already clean */\n\tMD_HAS_JOURNAL,\t\t/* The raid array has journal feature set */\n\tMD_CLUSTER_RESYNC_LOCKED, /* cluster raid only, which means node\n\t\t\t\t   * already took resync lock, need to\n\t\t\t\t   * release the lock */\n\tMD_FAILFAST_SUPPORTED,\t/* Using MD_FAILFAST on metadata writes is\n\t\t\t\t * supported as calls to md_error() will\n\t\t\t\t * never cause the array to become failed.\n\t\t\t\t */\n\tMD_HAS_PPL,\t\t/* The raid array has PPL feature set */\n\tMD_HAS_MULTIPLE_PPLS,\t/* The raid array has multiple PPLs feature set */\n\tMD_ALLOW_SB_UPDATE,\t/* md_check_recovery is allowed to update\n\t\t\t\t * the metadata without taking reconfig_mutex.\n\t\t\t\t */\n\tMD_UPDATING_SB,\t\t/* md_check_recovery is updating the metadata\n\t\t\t\t * without explicitly holding reconfig_mutex.\n\t\t\t\t */\n\tMD_NOT_READY,\t\t/* do_md_run() is active, so 'array_state'\n\t\t\t\t * must not report that array is ready yet\n\t\t\t\t */\n\tMD_BROKEN,              /* This is used in RAID-0/LINEAR only, to stop\n\t\t\t\t * I/O in case an array member is gone/failed.\n\t\t\t\t */\n};\n\nenum mddev_sb_flags {\n\tMD_SB_CHANGE_DEVS,\t\t/* Some device status has changed */\n\tMD_SB_CHANGE_CLEAN,\t/* transition to or from 'clean' */\n\tMD_SB_CHANGE_PENDING,\t/* switch from 'clean' to 'active' in progress */\n\tMD_SB_NEED_REWRITE,\t/* metadata write needs to be repeated */\n};\n\n#define NR_SERIAL_INFOS\t\t8\n/* record current range of serialize IOs */\nstruct serial_info {\n\tstruct rb_node node;\n\tsector_t start;\t\t/* start sector of rb node */\n\tsector_t last;\t\t/* end sector of rb node */\n\tsector_t _subtree_last; /* highest sector in subtree of rb node */\n};\n\nstruct mddev {\n\tvoid\t\t\t\t*private;\n\tstruct md_personality\t\t*pers;\n\tdev_t\t\t\t\tunit;\n\tint\t\t\t\tmd_minor;\n\tstruct list_head\t\tdisks;\n\tunsigned long\t\t\tflags;\n\tunsigned long\t\t\tsb_flags;\n\n\tint\t\t\t\tsuspended;\n\tatomic_t\t\t\tactive_io;\n\tint\t\t\t\tro;\n\tint\t\t\t\tsysfs_active; /* set when sysfs deletes\n\t\t\t\t\t\t       * are happening, so run/\n\t\t\t\t\t\t       * takeover/stop are not safe\n\t\t\t\t\t\t       */\n\tstruct gendisk\t\t\t*gendisk;\n\n\tstruct kobject\t\t\tkobj;\n\tint\t\t\t\thold_active;\n#define\tUNTIL_IOCTL\t1\n#define\tUNTIL_STOP\t2\n\n\t/* Superblock information */\n\tint\t\t\t\tmajor_version,\n\t\t\t\t\tminor_version,\n\t\t\t\t\tpatch_version;\n\tint\t\t\t\tpersistent;\n\tint\t\t\t\texternal;\t/* metadata is\n\t\t\t\t\t\t\t * managed externally */\n\tchar\t\t\t\tmetadata_type[17]; /* externally set*/\n\tint\t\t\t\tchunk_sectors;\n\ttime64_t\t\t\tctime, utime;\n\tint\t\t\t\tlevel, layout;\n\tchar\t\t\t\tclevel[16];\n\tint\t\t\t\traid_disks;\n\tint\t\t\t\tmax_disks;\n\tsector_t\t\t\tdev_sectors;\t/* used size of\n\t\t\t\t\t\t\t * component devices */\n\tsector_t\t\t\tarray_sectors; /* exported array size */\n\tint\t\t\t\texternal_size; /* size managed\n\t\t\t\t\t\t\t* externally */\n\t__u64\t\t\t\tevents;\n\t/* If the last 'event' was simply a clean->dirty transition, and\n\t * we didn't write it to the spares, then it is safe and simple\n\t * to just decrement the event count on a dirty->clean transition.\n\t * So we record that possibility here.\n\t */\n\tint\t\t\t\tcan_decrease_events;\n\n\tchar\t\t\t\tuuid[16];\n\n\t/* If the array is being reshaped, we need to record the\n\t * new shape and an indication of where we are up to.\n\t * This is written to the superblock.\n\t * If reshape_position is MaxSector, then no reshape is happening (yet).\n\t */\n\tsector_t\t\t\treshape_position;\n\tint\t\t\t\tdelta_disks, new_level, new_layout;\n\tint\t\t\t\tnew_chunk_sectors;\n\tint\t\t\t\treshape_backwards;\n\n\tstruct md_thread\t\t*thread;\t/* management thread */\n\tstruct md_thread\t\t*sync_thread;\t/* doing resync or reconstruct */\n\n\t/* 'last_sync_action' is initialized to \"none\".  It is set when a\n\t * sync operation (i.e \"data-check\", \"requested-resync\", \"resync\",\n\t * \"recovery\", or \"reshape\") is started.  It holds this value even\n\t * when the sync thread is \"frozen\" (interrupted) or \"idle\" (stopped\n\t * or finished).  It is overwritten when a new sync operation is begun.\n\t */\n\tchar\t\t\t\t*last_sync_action;\n\tsector_t\t\t\tcurr_resync;\t/* last block scheduled */\n\t/* As resync requests can complete out of order, we cannot easily track\n\t * how much resync has been completed.  So we occasionally pause until\n\t * everything completes, then set curr_resync_completed to curr_resync.\n\t * As such it may be well behind the real resync mark, but it is a value\n\t * we are certain of.\n\t */\n\tsector_t\t\t\tcurr_resync_completed;\n\tunsigned long\t\t\tresync_mark;\t/* a recent timestamp */\n\tsector_t\t\t\tresync_mark_cnt;/* blocks written at resync_mark */\n\tsector_t\t\t\tcurr_mark_cnt; /* blocks scheduled now */\n\n\tsector_t\t\t\tresync_max_sectors; /* may be set by personality */\n\n\tatomic64_t\t\t\tresync_mismatches; /* count of sectors where\n\t\t\t\t\t\t\t    * parity/replica mismatch found\n\t\t\t\t\t\t\t    */\n\n\t/* allow user-space to request suspension of IO to regions of the array */\n\tsector_t\t\t\tsuspend_lo;\n\tsector_t\t\t\tsuspend_hi;\n\t/* if zero, use the system-wide default */\n\tint\t\t\t\tsync_speed_min;\n\tint\t\t\t\tsync_speed_max;\n\n\t/* resync even though the same disks are shared among md-devices */\n\tint\t\t\t\tparallel_resync;\n\n\tint\t\t\t\tok_start_degraded;\n\n\tunsigned long\t\t\trecovery;\n\t/* If a RAID personality determines that recovery (of a particular\n\t * device) will fail due to a read error on the source device, it\n\t * takes a copy of this number and does not attempt recovery again\n\t * until this number changes.\n\t */\n\tint\t\t\t\trecovery_disabled;\n\n\tint\t\t\t\tin_sync;\t/* know to not need resync */\n\t/* 'open_mutex' avoids races between 'md_open' and 'do_md_stop', so\n\t * that we are never stopping an array while it is open.\n\t * 'reconfig_mutex' protects all other reconfiguration.\n\t * These locks are separate due to conflicting interactions\n\t * with bdev->bd_mutex.\n\t * Lock ordering is:\n\t *  reconfig_mutex -> bd_mutex\n\t *  bd_mutex -> open_mutex:  e.g. __blkdev_get -> md_open\n\t */\n\tstruct mutex\t\t\topen_mutex;\n\tstruct mutex\t\t\treconfig_mutex;\n\tatomic_t\t\t\tactive;\t\t/* general refcount */\n\tatomic_t\t\t\topeners;\t/* number of active opens */\n\n\tint\t\t\t\tchanged;\t/* True if we might need to\n\t\t\t\t\t\t\t * reread partition info */\n\tint\t\t\t\tdegraded;\t/* whether md should consider\n\t\t\t\t\t\t\t * adding a spare\n\t\t\t\t\t\t\t */\n\n\tatomic_t\t\t\trecovery_active; /* blocks scheduled, but not written */\n\twait_queue_head_t\t\trecovery_wait;\n\tsector_t\t\t\trecovery_cp;\n\tsector_t\t\t\tresync_min;\t/* user requested sync\n\t\t\t\t\t\t\t * starts here */\n\tsector_t\t\t\tresync_max;\t/* resync should pause\n\t\t\t\t\t\t\t * when it gets here */\n\n\tstruct kernfs_node\t\t*sysfs_state;\t/* handle for 'array_state'\n\t\t\t\t\t\t\t * file in sysfs.\n\t\t\t\t\t\t\t */\n\tstruct kernfs_node\t\t*sysfs_action;  /* handle for 'sync_action' */\n\tstruct kernfs_node\t\t*sysfs_completed;\t/*handle for 'sync_completed' */\n\tstruct kernfs_node\t\t*sysfs_degraded;\t/*handle for 'degraded' */\n\tstruct kernfs_node\t\t*sysfs_level;\t\t/*handle for 'level' */\n\n\tstruct work_struct del_work;\t/* used for delayed sysfs removal */\n\n\t/* \"lock\" protects:\n\t *   flush_bio transition from NULL to !NULL\n\t *   rdev superblocks, events\n\t *   clearing MD_CHANGE_*\n\t *   in_sync - and related safemode and MD_CHANGE changes\n\t *   pers (also protected by reconfig_mutex and pending IO).\n\t *   clearing ->bitmap\n\t *   clearing ->bitmap_info.file\n\t *   changing ->resync_{min,max}\n\t *   setting MD_RECOVERY_RUNNING (which interacts with resync_{min,max})\n\t */\n\tspinlock_t\t\t\tlock;\n\twait_queue_head_t\t\tsb_wait;\t/* for waiting on superblock updates */\n\tatomic_t\t\t\tpending_writes;\t/* number of active superblock writes */\n\n\tunsigned int\t\t\tsafemode;\t/* if set, update \"clean\" superblock\n\t\t\t\t\t\t\t * when no writes pending.\n\t\t\t\t\t\t\t */\n\tunsigned int\t\t\tsafemode_delay;\n\tstruct timer_list\t\tsafemode_timer;\n\tstruct percpu_ref\t\twrites_pending;\n\tint\t\t\t\tsync_checkers;\t/* # of threads checking writes_pending */\n\tstruct request_queue\t\t*queue;\t/* for plugging ... */\n\n\tstruct bitmap\t\t\t*bitmap; /* the bitmap for the device */\n\tstruct {\n\t\tstruct file\t\t*file; /* the bitmap file */\n\t\tloff_t\t\t\toffset; /* offset from superblock of\n\t\t\t\t\t\t * start of bitmap. May be\n\t\t\t\t\t\t * negative, but not '0'\n\t\t\t\t\t\t * For external metadata, offset\n\t\t\t\t\t\t * from start of device.\n\t\t\t\t\t\t */\n\t\tunsigned long\t\tspace; /* space available at this offset */\n\t\tloff_t\t\t\tdefault_offset; /* this is the offset to use when\n\t\t\t\t\t\t\t * hot-adding a bitmap.  It should\n\t\t\t\t\t\t\t * eventually be settable by sysfs.\n\t\t\t\t\t\t\t */\n\t\tunsigned long\t\tdefault_space; /* space available at\n\t\t\t\t\t\t\t* default offset */\n\t\tstruct mutex\t\tmutex;\n\t\tunsigned long\t\tchunksize;\n\t\tunsigned long\t\tdaemon_sleep; /* how many jiffies between updates? */\n\t\tunsigned long\t\tmax_write_behind; /* write-behind mode */\n\t\tint\t\t\texternal;\n\t\tint\t\t\tnodes; /* Maximum number of nodes in the cluster */\n\t\tchar                    cluster_name[64]; /* Name of the cluster */\n\t} bitmap_info;\n\n\tatomic_t\t\t\tmax_corr_read_errors; /* max read retries */\n\tstruct list_head\t\tall_mddevs;\n\n\tstruct attribute_group\t\t*to_remove;\n\n\tstruct bio_set\t\t\tbio_set;\n\tstruct bio_set\t\t\tsync_set; /* for sync operations like\n\t\t\t\t\t\t   * metadata and bitmap writes\n\t\t\t\t\t\t   */\n\tmempool_t\t\t\tmd_io_pool;\n\n\t/* Generic flush handling.\n\t * The last to finish preflush schedules a worker to submit\n\t * the rest of the request (without the REQ_PREFLUSH flag).\n\t */\n\tstruct bio *flush_bio;\n\tatomic_t flush_pending;\n\tktime_t start_flush, prev_flush_start; /* prev_flush_start is when the previous completed\n\t\t\t\t\t\t* flush was started.\n\t\t\t\t\t\t*/\n\tstruct work_struct flush_work;\n\tstruct work_struct event_work;\t/* used by dm to report failure event */\n\tmempool_t *serial_info_pool;\n\tvoid (*sync_super)(struct mddev *mddev, struct md_rdev *rdev);\n\tstruct md_cluster_info\t\t*cluster_info;\n\tunsigned int\t\t\tgood_device_nr;\t/* good device num within cluster raid */\n\tunsigned int\t\t\tnoio_flag; /* for memalloc scope API */\n\n\tbool\thas_superblocks:1;\n\tbool\tfail_last_dev:1;\n\tbool\tserialize_policy:1;\n};\n\nenum recovery_flags {\n\t/*\n\t * If neither SYNC or RESHAPE are set, then it is a recovery.\n\t */\n\tMD_RECOVERY_RUNNING,\t/* a thread is running, or about to be started */\n\tMD_RECOVERY_SYNC,\t/* actually doing a resync, not a recovery */\n\tMD_RECOVERY_RECOVER,\t/* doing recovery, or need to try it. */\n\tMD_RECOVERY_INTR,\t/* resync needs to be aborted for some reason */\n\tMD_RECOVERY_DONE,\t/* thread is done and is waiting to be reaped */\n\tMD_RECOVERY_NEEDED,\t/* we might need to start a resync/recover */\n\tMD_RECOVERY_REQUESTED,\t/* user-space has requested a sync (used with SYNC) */\n\tMD_RECOVERY_CHECK,\t/* user-space request for check-only, no repair */\n\tMD_RECOVERY_RESHAPE,\t/* A reshape is happening */\n\tMD_RECOVERY_FROZEN,\t/* User request to abort, and not restart, any action */\n\tMD_RECOVERY_ERROR,\t/* sync-action interrupted because io-error */\n\tMD_RECOVERY_WAIT,\t/* waiting for pers->start() to finish */\n\tMD_RESYNCING_REMOTE,\t/* remote node is running resync thread */\n};\n\nstatic inline int __must_check mddev_lock(struct mddev *mddev)\n{\n\treturn mutex_lock_interruptible(&mddev->reconfig_mutex);\n}\n\n/* Sometimes we need to take the lock in a situation where\n * failure due to interrupts is not acceptable.\n */\nstatic inline void mddev_lock_nointr(struct mddev *mddev)\n{\n\tmutex_lock(&mddev->reconfig_mutex);\n}\n\nstatic inline int mddev_trylock(struct mddev *mddev)\n{\n\treturn mutex_trylock(&mddev->reconfig_mutex);\n}\nextern void mddev_unlock(struct mddev *mddev);\n\nstatic inline void md_sync_acct(struct block_device *bdev, unsigned long nr_sectors)\n{\n\tatomic_add(nr_sectors, &bdev->bd_disk->sync_io);\n}\n\nstatic inline void md_sync_acct_bio(struct bio *bio, unsigned long nr_sectors)\n{\n\tmd_sync_acct(bio->bi_bdev, nr_sectors);\n}\n\nstruct md_personality\n{\n\tchar *name;\n\tint level;\n\tstruct list_head list;\n\tstruct module *owner;\n\tbool __must_check (*make_request)(struct mddev *mddev, struct bio *bio);\n\t/*\n\t * start up works that do NOT require md_thread. tasks that\n\t * requires md_thread should go into start()\n\t */\n\tint (*run)(struct mddev *mddev);\n\t/* start up works that require md threads */\n\tint (*start)(struct mddev *mddev);\n\tvoid (*free)(struct mddev *mddev, void *priv);\n\tvoid (*status)(struct seq_file *seq, struct mddev *mddev);\n\t/* error_handler must set ->faulty and clear ->in_sync\n\t * if appropriate, and should abort recovery if needed\n\t */\n\tvoid (*error_handler)(struct mddev *mddev, struct md_rdev *rdev);\n\tint (*hot_add_disk) (struct mddev *mddev, struct md_rdev *rdev);\n\tint (*hot_remove_disk) (struct mddev *mddev, struct md_rdev *rdev);\n\tint (*spare_active) (struct mddev *mddev);\n\tsector_t (*sync_request)(struct mddev *mddev, sector_t sector_nr, int *skipped);\n\tint (*resize) (struct mddev *mddev, sector_t sectors);\n\tsector_t (*size) (struct mddev *mddev, sector_t sectors, int raid_disks);\n\tint (*check_reshape) (struct mddev *mddev);\n\tint (*start_reshape) (struct mddev *mddev);\n\tvoid (*finish_reshape) (struct mddev *mddev);\n\tvoid (*update_reshape_pos) (struct mddev *mddev);\n\t/* quiesce suspends or resumes internal processing.\n\t * 1 - stop new actions and wait for action io to complete\n\t * 0 - return to normal behaviour\n\t */\n\tvoid (*quiesce) (struct mddev *mddev, int quiesce);\n\t/* takeover is used to transition an array from one\n\t * personality to another.  The new personality must be able\n\t * to handle the data in the current layout.\n\t * e.g. 2drive raid1 -> 2drive raid5\n\t *      ndrive raid5 -> degraded n+1drive raid6 with special layout\n\t * If the takeover succeeds, a new 'private' structure is returned.\n\t * This needs to be installed and then ->run used to activate the\n\t * array.\n\t */\n\tvoid *(*takeover) (struct mddev *mddev);\n\t/* Changes the consistency policy of an active array. */\n\tint (*change_consistency_policy)(struct mddev *mddev, const char *buf);\n};\n\nstruct md_sysfs_entry {\n\tstruct attribute attr;\n\tssize_t (*show)(struct mddev *, char *);\n\tssize_t (*store)(struct mddev *, const char *, size_t);\n};\nextern struct attribute_group md_bitmap_group;\n\nstatic inline struct kernfs_node *sysfs_get_dirent_safe(struct kernfs_node *sd, char *name)\n{\n\tif (sd)\n\t\treturn sysfs_get_dirent(sd, name);\n\treturn sd;\n}\nstatic inline void sysfs_notify_dirent_safe(struct kernfs_node *sd)\n{\n\tif (sd)\n\t\tsysfs_notify_dirent(sd);\n}\n\nstatic inline char * mdname (struct mddev * mddev)\n{\n\treturn mddev->gendisk ? mddev->gendisk->disk_name : \"mdX\";\n}\n\nstatic inline int sysfs_link_rdev(struct mddev *mddev, struct md_rdev *rdev)\n{\n\tchar nm[20];\n\tif (!test_bit(Replacement, &rdev->flags) &&\n\t    !test_bit(Journal, &rdev->flags) &&\n\t    mddev->kobj.sd) {\n\t\tsprintf(nm, \"rd%d\", rdev->raid_disk);\n\t\treturn sysfs_create_link(&mddev->kobj, &rdev->kobj, nm);\n\t} else\n\t\treturn 0;\n}\n\nstatic inline void sysfs_unlink_rdev(struct mddev *mddev, struct md_rdev *rdev)\n{\n\tchar nm[20];\n\tif (!test_bit(Replacement, &rdev->flags) &&\n\t    !test_bit(Journal, &rdev->flags) &&\n\t    mddev->kobj.sd) {\n\t\tsprintf(nm, \"rd%d\", rdev->raid_disk);\n\t\tsysfs_remove_link(&mddev->kobj, nm);\n\t}\n}\n\n/*\n * iterates through some rdev ringlist. It's safe to remove the\n * current 'rdev'. Dont touch 'tmp' though.\n */\n#define rdev_for_each_list(rdev, tmp, head)\t\t\t\t\\\n\tlist_for_each_entry_safe(rdev, tmp, head, same_set)\n\n/*\n * iterates through the 'same array disks' ringlist\n */\n#define rdev_for_each(rdev, mddev)\t\t\t\t\\\n\tlist_for_each_entry(rdev, &((mddev)->disks), same_set)\n\n#define rdev_for_each_safe(rdev, tmp, mddev)\t\t\t\t\\\n\tlist_for_each_entry_safe(rdev, tmp, &((mddev)->disks), same_set)\n\n#define rdev_for_each_rcu(rdev, mddev)\t\t\t\t\\\n\tlist_for_each_entry_rcu(rdev, &((mddev)->disks), same_set)\n\nstruct md_thread {\n\tvoid\t\t\t(*run) (struct md_thread *thread);\n\tstruct mddev\t\t*mddev;\n\twait_queue_head_t\twqueue;\n\tunsigned long\t\tflags;\n\tstruct task_struct\t*tsk;\n\tunsigned long\t\ttimeout;\n\tvoid\t\t\t*private;\n};\n\n#define THREAD_WAKEUP  0\n\nstatic inline void safe_put_page(struct page *p)\n{\n\tif (p) put_page(p);\n}\n\nextern int register_md_personality(struct md_personality *p);\nextern int unregister_md_personality(struct md_personality *p);\nextern int register_md_cluster_operations(struct md_cluster_operations *ops,\n\t\tstruct module *module);\nextern int unregister_md_cluster_operations(void);\nextern int md_setup_cluster(struct mddev *mddev, int nodes);\nextern void md_cluster_stop(struct mddev *mddev);\nextern struct md_thread *md_register_thread(\n\tvoid (*run)(struct md_thread *thread),\n\tstruct mddev *mddev,\n\tconst char *name);\nextern void md_unregister_thread(struct md_thread **threadp);\nextern void md_wakeup_thread(struct md_thread *thread);\nextern void md_check_recovery(struct mddev *mddev);\nextern void md_reap_sync_thread(struct mddev *mddev);\nextern int mddev_init_writes_pending(struct mddev *mddev);\nextern bool md_write_start(struct mddev *mddev, struct bio *bi);\nextern void md_write_inc(struct mddev *mddev, struct bio *bi);\nextern void md_write_end(struct mddev *mddev);\nextern void md_done_sync(struct mddev *mddev, int blocks, int ok);\nextern void md_error(struct mddev *mddev, struct md_rdev *rdev);\nextern void md_finish_reshape(struct mddev *mddev);\n\nextern bool __must_check md_flush_request(struct mddev *mddev, struct bio *bio);\nextern void md_super_write(struct mddev *mddev, struct md_rdev *rdev,\n\t\t\t   sector_t sector, int size, struct page *page);\nextern int md_super_wait(struct mddev *mddev);\nextern int sync_page_io(struct md_rdev *rdev, sector_t sector, int size,\n\t\t\tstruct page *page, int op, int op_flags,\n\t\t\tbool metadata_op);\nextern void md_do_sync(struct md_thread *thread);\nextern void md_new_event(struct mddev *mddev);\nextern void md_allow_write(struct mddev *mddev);\nextern void md_wait_for_blocked_rdev(struct md_rdev *rdev, struct mddev *mddev);\nextern void md_set_array_sectors(struct mddev *mddev, sector_t array_sectors);\nextern int md_check_no_bitmap(struct mddev *mddev);\nextern int md_integrity_register(struct mddev *mddev);\nextern int md_integrity_add_rdev(struct md_rdev *rdev, struct mddev *mddev);\nextern int strict_strtoul_scaled(const char *cp, unsigned long *res, int scale);\n\nextern void mddev_init(struct mddev *mddev);\nextern int md_run(struct mddev *mddev);\nextern int md_start(struct mddev *mddev);\nextern void md_stop(struct mddev *mddev);\nextern void md_stop_writes(struct mddev *mddev);\nextern int md_rdev_init(struct md_rdev *rdev);\nextern void md_rdev_clear(struct md_rdev *rdev);\n\nextern void md_handle_request(struct mddev *mddev, struct bio *bio);\nextern void mddev_suspend(struct mddev *mddev);\nextern void mddev_resume(struct mddev *mddev);\n\nextern void md_reload_sb(struct mddev *mddev, int raid_disk);\nextern void md_update_sb(struct mddev *mddev, int force);\nextern void md_kick_rdev_from_array(struct md_rdev * rdev);\nextern void mddev_create_serial_pool(struct mddev *mddev, struct md_rdev *rdev,\n\t\t\t\t     bool is_suspend);\nextern void mddev_destroy_serial_pool(struct mddev *mddev, struct md_rdev *rdev,\n\t\t\t\t      bool is_suspend);\nstruct md_rdev *md_find_rdev_nr_rcu(struct mddev *mddev, int nr);\nstruct md_rdev *md_find_rdev_rcu(struct mddev *mddev, dev_t dev);\n\nstatic inline bool is_mddev_broken(struct md_rdev *rdev, const char *md_type)\n{\n\tint flags = rdev->bdev->bd_disk->flags;\n\n\tif (!(flags & GENHD_FL_UP)) {\n\t\tif (!test_and_set_bit(MD_BROKEN, &rdev->mddev->flags))\n\t\t\tpr_warn(\"md: %s: %s array has a missing/failed member\\n\",\n\t\t\t\tmdname(rdev->mddev), md_type);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline void rdev_dec_pending(struct md_rdev *rdev, struct mddev *mddev)\n{\n\tint faulty = test_bit(Faulty, &rdev->flags);\n\tif (atomic_dec_and_test(&rdev->nr_pending) && faulty) {\n\t\tset_bit(MD_RECOVERY_NEEDED, &mddev->recovery);\n\t\tmd_wakeup_thread(mddev->thread);\n\t}\n}\n\nextern struct md_cluster_operations *md_cluster_ops;\nstatic inline int mddev_is_clustered(struct mddev *mddev)\n{\n\treturn mddev->cluster_info && mddev->bitmap_info.nodes > 1;\n}\n\n/* clear unsupported mddev_flags */\nstatic inline void mddev_clear_unsupported_flags(struct mddev *mddev,\n\tunsigned long unsupported_flags)\n{\n\tmddev->flags &= ~unsupported_flags;\n}\n\nstatic inline void mddev_check_writesame(struct mddev *mddev, struct bio *bio)\n{\n\tif (bio_op(bio) == REQ_OP_WRITE_SAME &&\n\t    !bio->bi_bdev->bd_disk->queue->limits.max_write_same_sectors)\n\t\tmddev->queue->limits.max_write_same_sectors = 0;\n}\n\nstatic inline void mddev_check_write_zeroes(struct mddev *mddev, struct bio *bio)\n{\n\tif (bio_op(bio) == REQ_OP_WRITE_ZEROES &&\n\t    !bio->bi_bdev->bd_disk->queue->limits.max_write_zeroes_sectors)\n\t\tmddev->queue->limits.max_write_zeroes_sectors = 0;\n}\n\nstruct mdu_array_info_s;\nstruct mdu_disk_info_s;\n\nextern int mdp_major;\nvoid md_autostart_arrays(int part);\nint md_set_array_info(struct mddev *mddev, struct mdu_array_info_s *info);\nint md_add_new_disk(struct mddev *mddev, struct mdu_disk_info_s *info);\nint do_md_run(struct mddev *mddev);\n\nextern const struct block_device_operations md_fops;\n\n#endif /* _MD_MD_H */\n"}, "2": {"id": 2, "path": "/src/include/linux/build_bug.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_BUILD_BUG_H\n#define _LINUX_BUILD_BUG_H\n\n#include <linux/compiler.h>\n\n#ifdef __CHECKER__\n#define BUILD_BUG_ON_ZERO(e) (0)\n#else /* __CHECKER__ */\n/*\n * Force a compilation error if condition is true, but also produce a\n * result (of value 0 and type int), so the expression can be used\n * e.g. in a structure initializer (or where-ever else comma expressions\n * aren't permitted).\n */\n#define BUILD_BUG_ON_ZERO(e) ((int)(sizeof(struct { int:(-!!(e)); })))\n#endif /* __CHECKER__ */\n\n/* Force a compilation error if a constant expression is not a power of 2 */\n#define __BUILD_BUG_ON_NOT_POWER_OF_2(n)\t\\\n\tBUILD_BUG_ON(((n) & ((n) - 1)) != 0)\n#define BUILD_BUG_ON_NOT_POWER_OF_2(n)\t\t\t\\\n\tBUILD_BUG_ON((n) == 0 || (((n) & ((n) - 1)) != 0))\n\n/*\n * BUILD_BUG_ON_INVALID() permits the compiler to check the validity of the\n * expression but avoids the generation of any code, even if that expression\n * has side-effects.\n */\n#define BUILD_BUG_ON_INVALID(e) ((void)(sizeof((__force long)(e))))\n\n/**\n * BUILD_BUG_ON_MSG - break compile if a condition is true & emit supplied\n *\t\t      error message.\n * @condition: the condition which the compiler should know is false.\n *\n * See BUILD_BUG_ON for description.\n */\n#define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n\n/**\n * BUILD_BUG_ON - break compile if a condition is true.\n * @condition: the condition which the compiler should know is false.\n *\n * If you have some code which relies on certain constants being equal, or\n * some other compile-time-evaluated condition, you should use BUILD_BUG_ON to\n * detect if someone changes it.\n */\n#define BUILD_BUG_ON(condition) \\\n\tBUILD_BUG_ON_MSG(condition, \"BUILD_BUG_ON failed: \" #condition)\n\n/**\n * BUILD_BUG - break compile if used.\n *\n * If you have some code that you expect the compiler to eliminate at\n * build time, you should use BUILD_BUG to detect if it is\n * unexpectedly used.\n */\n#define BUILD_BUG() BUILD_BUG_ON_MSG(1, \"BUILD_BUG failed\")\n\n/**\n * static_assert - check integer constant expression at build time\n *\n * static_assert() is a wrapper for the C11 _Static_assert, with a\n * little macro magic to make the message optional (defaulting to the\n * stringification of the tested expression).\n *\n * Contrary to BUILD_BUG_ON(), static_assert() can be used at global\n * scope, but requires the expression to be an integer constant\n * expression (i.e., it is not enough that __builtin_constant_p() is\n * true for expr).\n *\n * Also note that BUILD_BUG_ON() fails the build if the condition is\n * true, while static_assert() fails the build if the expression is\n * false.\n */\n#define static_assert(expr, ...) __static_assert(expr, ##__VA_ARGS__, #expr)\n#define __static_assert(expr, msg, ...) _Static_assert(expr, msg)\n\n#endif\t/* _LINUX_BUILD_BUG_H */\n"}, "3": {"id": 3, "path": "/src/include/linux/compiler_types.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_TYPES_H\n#define __LINUX_COMPILER_TYPES_H\n\n#ifndef __ASSEMBLY__\n\n#ifdef __CHECKER__\n/* address spaces */\n# define __kernel\t__attribute__((address_space(0)))\n# define __user\t\t__attribute__((noderef, address_space(__user)))\n# define __iomem\t__attribute__((noderef, address_space(__iomem)))\n# define __percpu\t__attribute__((noderef, address_space(__percpu)))\n# define __rcu\t\t__attribute__((noderef, address_space(__rcu)))\nstatic inline void __chk_user_ptr(const volatile void __user *ptr) { }\nstatic inline void __chk_io_ptr(const volatile void __iomem *ptr) { }\n/* context/locking */\n# define __must_hold(x)\t__attribute__((context(x,1,1)))\n# define __acquires(x)\t__attribute__((context(x,0,1)))\n# define __releases(x)\t__attribute__((context(x,1,0)))\n# define __acquire(x)\t__context__(x,1)\n# define __release(x)\t__context__(x,-1)\n# define __cond_lock(x,c)\t((c) ? ({ __acquire(x); 1; }) : 0)\n/* other */\n# define __force\t__attribute__((force))\n# define __nocast\t__attribute__((nocast))\n# define __safe\t\t__attribute__((safe))\n# define __private\t__attribute__((noderef))\n# define ACCESS_PRIVATE(p, member) (*((typeof((p)->member) __force *) &(p)->member))\n#else /* __CHECKER__ */\n/* address spaces */\n# define __kernel\n# ifdef STRUCTLEAK_PLUGIN\n#  define __user\t__attribute__((user))\n# else\n#  define __user\n# endif\n# define __iomem\n# define __percpu\n# define __rcu\n# define __chk_user_ptr(x)\t(void)0\n# define __chk_io_ptr(x)\t(void)0\n/* context/locking */\n# define __must_hold(x)\n# define __acquires(x)\n# define __releases(x)\n# define __acquire(x)\t(void)0\n# define __release(x)\t(void)0\n# define __cond_lock(x,c) (c)\n/* other */\n# define __force\n# define __nocast\n# define __safe\n# define __private\n# define ACCESS_PRIVATE(p, member) ((p)->member)\n# define __builtin_warning(x, y...) (1)\n#endif /* __CHECKER__ */\n\n/* Indirect macros required for expanded argument pasting, eg. __LINE__. */\n#define ___PASTE(a,b) a##b\n#define __PASTE(a,b) ___PASTE(a,b)\n\n#ifdef __KERNEL__\n\n/* Attributes */\n#include <linux/compiler_attributes.h>\n\n/* Builtins */\n\n/*\n * __has_builtin is supported on gcc >= 10, clang >= 3 and icc >= 21.\n * In the meantime, to support gcc < 10, we implement __has_builtin\n * by hand.\n */\n#ifndef __has_builtin\n#define __has_builtin(x) (0)\n#endif\n\n/* Compiler specific macros. */\n#ifdef __clang__\n#include <linux/compiler-clang.h>\n#elif defined(__INTEL_COMPILER)\n#include <linux/compiler-intel.h>\n#elif defined(__GNUC__)\n/* The above compilers also define __GNUC__, so order is important here. */\n#include <linux/compiler-gcc.h>\n#else\n#error \"Unknown compiler\"\n#endif\n\n/*\n * Some architectures need to provide custom definitions of macros provided\n * by linux/compiler-*.h, and can do so using asm/compiler.h. We include that\n * conditionally rather than using an asm-generic wrapper in order to avoid\n * build failures if any C compilation, which will include this file via an\n * -include argument in c_flags, occurs prior to the asm-generic wrappers being\n * generated.\n */\n#ifdef CONFIG_HAVE_ARCH_COMPILER_H\n#include <asm/compiler.h>\n#endif\n\nstruct ftrace_branch_data {\n\tconst char *func;\n\tconst char *file;\n\tunsigned line;\n\tunion {\n\t\tstruct {\n\t\t\tunsigned long correct;\n\t\t\tunsigned long incorrect;\n\t\t};\n\t\tstruct {\n\t\t\tunsigned long miss;\n\t\t\tunsigned long hit;\n\t\t};\n\t\tunsigned long miss_hit[2];\n\t};\n};\n\nstruct ftrace_likely_data {\n\tstruct ftrace_branch_data\tdata;\n\tunsigned long\t\t\tconstant;\n};\n\n#if defined(CC_USING_HOTPATCH)\n#define notrace\t\t\t__attribute__((hotpatch(0, 0)))\n#elif defined(CC_USING_PATCHABLE_FUNCTION_ENTRY)\n#define notrace\t\t\t__attribute__((patchable_function_entry(0, 0)))\n#else\n#define notrace\t\t\t__attribute__((__no_instrument_function__))\n#endif\n\n/*\n * it doesn't make sense on ARM (currently the only user of __naked)\n * to trace naked functions because then mcount is called without\n * stack and frame pointer being set up and there is no chance to\n * restore the lr register to the value before mcount was called.\n */\n#define __naked\t\t\t__attribute__((__naked__)) notrace\n\n#define __compiler_offsetof(a, b)\t__builtin_offsetof(a, b)\n\n/*\n * Prefer gnu_inline, so that extern inline functions do not emit an\n * externally visible function. This makes extern inline behave as per gnu89\n * semantics rather than c99. This prevents multiple symbol definition errors\n * of extern inline functions at link time.\n * A lot of inline functions can cause havoc with function tracing.\n */\n#define inline inline __gnu_inline __inline_maybe_unused notrace\n\n/*\n * gcc provides both __inline__ and __inline as alternate spellings of\n * the inline keyword, though the latter is undocumented. New kernel\n * code should only use the inline spelling, but some existing code\n * uses __inline__. Since we #define inline above, to ensure\n * __inline__ has the same semantics, we need this #define.\n *\n * However, the spelling __inline is strictly reserved for referring\n * to the bare keyword.\n */\n#define __inline__ inline\n\n/*\n * GCC does not warn about unused static inline functions for -Wunused-function.\n * Suppress the warning in clang as well by using __maybe_unused, but enable it\n * for W=1 build. This will allow clang to find unused functions. Remove the\n * __inline_maybe_unused entirely after fixing most of -Wunused-function warnings.\n */\n#ifdef KBUILD_EXTRA_WARN1\n#define __inline_maybe_unused\n#else\n#define __inline_maybe_unused __maybe_unused\n#endif\n\n/*\n * Rather then using noinline to prevent stack consumption, use\n * noinline_for_stack instead.  For documentation reasons.\n */\n#define noinline_for_stack noinline\n\n/*\n * Sanitizer helper attributes: Because using __always_inline and\n * __no_sanitize_* conflict, provide helper attributes that will either expand\n * to __no_sanitize_* in compilation units where instrumentation is enabled\n * (__SANITIZE_*__), or __always_inline in compilation units without\n * instrumentation (__SANITIZE_*__ undefined).\n */\n#ifdef __SANITIZE_ADDRESS__\n/*\n * We can't declare function 'inline' because __no_sanitize_address conflicts\n * with inlining. Attempt to inline it may cause a build failure.\n *     https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67368\n * '__maybe_unused' allows us to avoid defined-but-not-used warnings.\n */\n# define __no_kasan_or_inline __no_sanitize_address notrace __maybe_unused\n# define __no_sanitize_or_inline __no_kasan_or_inline\n#else\n# define __no_kasan_or_inline __always_inline\n#endif\n\n#define __no_kcsan __no_sanitize_thread\n#ifdef __SANITIZE_THREAD__\n# define __no_sanitize_or_inline __no_kcsan notrace __maybe_unused\n#endif\n\n#ifndef __no_sanitize_or_inline\n#define __no_sanitize_or_inline __always_inline\n#endif\n\n/* Section for code which can't be instrumented at all */\n#define noinstr\t\t\t\t\t\t\t\t\\\n\tnoinline notrace __attribute((__section__(\".noinstr.text\")))\t\\\n\t__no_kcsan __no_sanitize_address\n\n#endif /* __KERNEL__ */\n\n#endif /* __ASSEMBLY__ */\n\n/*\n * The below symbols may be defined for one or more, but not ALL, of the above\n * compilers. We don't consider that to be an error, so set them to nothing.\n * For example, some of them are for compiler specific plugins.\n */\n#ifndef __latent_entropy\n# define __latent_entropy\n#endif\n\n#ifndef __randomize_layout\n# define __randomize_layout __designated_init\n#endif\n\n#ifndef __no_randomize_layout\n# define __no_randomize_layout\n#endif\n\n#ifndef randomized_struct_fields_start\n# define randomized_struct_fields_start\n# define randomized_struct_fields_end\n#endif\n\n#ifndef __noscs\n# define __noscs\n#endif\n\n#ifndef asm_volatile_goto\n#define asm_volatile_goto(x...) asm goto(x)\n#endif\n\n#ifdef CONFIG_CC_HAS_ASM_INLINE\n#define asm_inline asm __inline\n#else\n#define asm_inline asm\n#endif\n\n/* Are two types/vars the same type (ignoring qualifiers)? */\n#define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))\n\n/*\n * __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leaving\n *\t\t\t       non-scalar types unchanged.\n */\n/*\n * Prefer C11 _Generic for better compile-times and simpler code. Note: 'char'\n * is not type-compatible with 'signed char', and we define a separate case.\n */\n#define __scalar_type_to_expr_cases(type)\t\t\t\t\\\n\t\tunsigned type:\t(unsigned type)0,\t\t\t\\\n\t\tsigned type:\t(signed type)0\n\n#define __unqual_scalar_typeof(x) typeof(\t\t\t\t\\\n\t\t_Generic((x),\t\t\t\t\t\t\\\n\t\t\t char:\t(char)0,\t\t\t\t\\\n\t\t\t __scalar_type_to_expr_cases(char),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(short),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(int),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(long),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(long long),\t\\\n\t\t\t default: (x)))\n\n/* Is this type a native word size -- useful for atomic operations */\n#define __native_word(t) \\\n\t(sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || \\\n\t sizeof(t) == sizeof(int) || sizeof(t) == sizeof(long))\n\n/* Compile time object size, -1 for unknown */\n#ifndef __compiletime_object_size\n# define __compiletime_object_size(obj) -1\n#endif\n#ifndef __compiletime_warning\n# define __compiletime_warning(message)\n#endif\n#ifndef __compiletime_error\n# define __compiletime_error(message)\n#endif\n\n#ifdef __OPTIMIZE__\n# define __compiletime_assert(condition, msg, prefix, suffix)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\textern void prefix ## suffix(void) __compiletime_error(msg); \\\n\t\tif (!(condition))\t\t\t\t\t\\\n\t\t\tprefix ## suffix();\t\t\t\t\\\n\t} while (0)\n#else\n# define __compiletime_assert(condition, msg, prefix, suffix) do { } while (0)\n#endif\n\n#define _compiletime_assert(condition, msg, prefix, suffix) \\\n\t__compiletime_assert(condition, msg, prefix, suffix)\n\n/**\n * compiletime_assert - break build and emit msg if condition is false\n * @condition: a compile-time constant condition to check\n * @msg:       a message to emit if condition is false\n *\n * In tradition of POSIX assert, this macro will break the build if the\n * supplied condition is *false*, emitting the supplied error message if the\n * compiler has support to do so.\n */\n#define compiletime_assert(condition, msg) \\\n\t_compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n\n#define compiletime_assert_atomic_type(t)\t\t\t\t\\\n\tcompiletime_assert(__native_word(t),\t\t\t\t\\\n\t\t\"Need native word sized stores/loads for atomicity.\")\n\n/* Helpers for emitting diagnostics in pragmas. */\n#ifndef __diag\n#define __diag(string)\n#endif\n\n#ifndef __diag_GCC\n#define __diag_GCC(version, severity, string)\n#endif\n\n#define __diag_push()\t__diag(push)\n#define __diag_pop()\t__diag(pop)\n\n#define __diag_ignore(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, ignore, option)\n#define __diag_warn(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, warn, option)\n#define __diag_error(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, error, option)\n\n#endif /* __LINUX_COMPILER_TYPES_H */\n"}, "4": {"id": 4, "path": "/src/include/asm-generic/bug.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _ASM_GENERIC_BUG_H\n#define _ASM_GENERIC_BUG_H\n\n#include <linux/compiler.h>\n#include <linux/instrumentation.h>\n\n#define CUT_HERE\t\t\"------------[ cut here ]------------\\n\"\n\n#ifdef CONFIG_GENERIC_BUG\n#define BUGFLAG_WARNING\t\t(1 << 0)\n#define BUGFLAG_ONCE\t\t(1 << 1)\n#define BUGFLAG_DONE\t\t(1 << 2)\n#define BUGFLAG_NO_CUT_HERE\t(1 << 3)\t/* CUT_HERE already sent */\n#define BUGFLAG_TAINT(taint)\t((taint) << 8)\n#define BUG_GET_TAINT(bug)\t((bug)->flags >> 8)\n#endif\n\n#ifndef __ASSEMBLY__\n#include <linux/kernel.h>\n\n#ifdef CONFIG_BUG\n\n#ifdef CONFIG_GENERIC_BUG\nstruct bug_entry {\n#ifndef CONFIG_GENERIC_BUG_RELATIVE_POINTERS\n\tunsigned long\tbug_addr;\n#else\n\tsigned int\tbug_addr_disp;\n#endif\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n#ifndef CONFIG_GENERIC_BUG_RELATIVE_POINTERS\n\tconst char\t*file;\n#else\n\tsigned int\tfile_disp;\n#endif\n\tunsigned short\tline;\n#endif\n\tunsigned short\tflags;\n};\n#endif\t/* CONFIG_GENERIC_BUG */\n\n/*\n * Don't use BUG() or BUG_ON() unless there's really no way out; one\n * example might be detecting data structure corruption in the middle\n * of an operation that can't be backed out of.  If the (sub)system\n * can somehow continue operating, perhaps with reduced functionality,\n * it's probably not BUG-worthy.\n *\n * If you're tempted to BUG(), think again:  is completely giving up\n * really the *only* solution?  There are usually better options, where\n * users don't need to reboot ASAP and can mostly shut down cleanly.\n */\n#ifndef HAVE_ARCH_BUG\n#define BUG() do { \\\n\tprintk(\"BUG: failure at %s:%d/%s()!\\n\", __FILE__, __LINE__, __func__); \\\n\tbarrier_before_unreachable(); \\\n\tpanic(\"BUG!\"); \\\n} while (0)\n#endif\n\n#ifndef HAVE_ARCH_BUG_ON\n#define BUG_ON(condition) do { if (unlikely(condition)) BUG(); } while (0)\n#endif\n\n/*\n * WARN(), WARN_ON(), WARN_ON_ONCE, and so on can be used to report\n * significant kernel issues that need prompt attention if they should ever\n * appear at runtime.\n *\n * Do not use these macros when checking for invalid external inputs\n * (e.g. invalid system call arguments, or invalid data coming from\n * network/devices), and on transient conditions like ENOMEM or EAGAIN.\n * These macros should be used for recoverable kernel issues only.\n * For invalid external inputs, transient conditions, etc use\n * pr_err[_once/_ratelimited]() followed by dump_stack(), if necessary.\n * Do not include \"BUG\"/\"WARNING\" in format strings manually to make these\n * conditions distinguishable from kernel issues.\n *\n * Use the versions with printk format strings to provide better diagnostics.\n */\n#ifndef __WARN_FLAGS\nextern __printf(4, 5)\nvoid warn_slowpath_fmt(const char *file, const int line, unsigned taint,\n\t\t       const char *fmt, ...);\n#define __WARN()\t\t__WARN_printf(TAINT_WARN, NULL)\n#define __WARN_printf(taint, arg...) do {\t\t\t\t\\\n\t\tinstrumentation_begin();\t\t\t\t\\\n\t\twarn_slowpath_fmt(__FILE__, __LINE__, taint, arg);\t\\\n\t\tinstrumentation_end();\t\t\t\t\t\\\n\t} while (0)\n#else\nextern __printf(1, 2) void __warn_printk(const char *fmt, ...);\n#define __WARN()\t\t__WARN_FLAGS(BUGFLAG_TAINT(TAINT_WARN))\n#define __WARN_printf(taint, arg...) do {\t\t\t\t\\\n\t\tinstrumentation_begin();\t\t\t\t\\\n\t\t__warn_printk(arg);\t\t\t\t\t\\\n\t\t__WARN_FLAGS(BUGFLAG_NO_CUT_HERE | BUGFLAG_TAINT(taint));\\\n\t\tinstrumentation_end();\t\t\t\t\t\\\n\t} while (0)\n#define WARN_ON_ONCE(condition) ({\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\\\n\t\t__WARN_FLAGS(BUGFLAG_ONCE |\t\t\t\\\n\t\t\t     BUGFLAG_TAINT(TAINT_WARN));\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\\\n})\n#endif\n\n/* used internally by panic.c */\nstruct warn_args;\nstruct pt_regs;\n\nvoid __warn(const char *file, int line, void *caller, unsigned taint,\n\t    struct pt_regs *regs, struct warn_args *args);\n\n#ifndef WARN_ON\n#define WARN_ON(condition) ({\t\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN();\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#ifndef WARN\n#define WARN(condition, format...) ({\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN_printf(TAINT_WARN, format);\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#define WARN_TAINT(condition, taint, format...) ({\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN_printf(taint, format);\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n\n#ifndef WARN_ON_ONCE\n#define WARN_ON_ONCE(condition)\t({\t\t\t\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN_ON(1);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n#endif\n\n#define WARN_ONCE(condition, format...)\t({\t\t\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN(1, format);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n\n#define WARN_TAINT_ONCE(condition, taint, format...)\t({\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN_TAINT(1, taint, format);\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n\n#else /* !CONFIG_BUG */\n#ifndef HAVE_ARCH_BUG\n#define BUG() do {} while (1)\n#endif\n\n#ifndef HAVE_ARCH_BUG_ON\n#define BUG_ON(condition) do { if (unlikely(condition)) BUG(); } while (0)\n#endif\n\n#ifndef HAVE_ARCH_WARN_ON\n#define WARN_ON(condition) ({\t\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#ifndef WARN\n#define WARN(condition, format...) ({\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tno_printk(format);\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#define WARN_ON_ONCE(condition) WARN_ON(condition)\n#define WARN_ONCE(condition, format...) WARN(condition, format)\n#define WARN_TAINT(condition, taint, format...) WARN(condition, format)\n#define WARN_TAINT_ONCE(condition, taint, format...) WARN(condition, format)\n\n#endif\n\n/*\n * WARN_ON_SMP() is for cases that the warning is either\n * meaningless for !SMP or may even cause failures.\n * It can also be used with values that are only defined\n * on SMP:\n *\n * struct foo {\n *  [...]\n * #ifdef CONFIG_SMP\n *\tint bar;\n * #endif\n * };\n *\n * void func(struct foo *zoot)\n * {\n *\tWARN_ON_SMP(!zoot->bar);\n *\n * For CONFIG_SMP, WARN_ON_SMP() should act the same as WARN_ON(),\n * and should be a nop and return false for uniprocessor.\n *\n * if (WARN_ON_SMP(x)) returns true only when CONFIG_SMP is set\n * and x is true.\n */\n#ifdef CONFIG_SMP\n# define WARN_ON_SMP(x)\t\t\tWARN_ON(x)\n#else\n/*\n * Use of ({0;}) because WARN_ON_SMP(x) may be used either as\n * a stand alone line statement or as a condition in an if ()\n * statement.\n * A simple \"0\" would cause gcc to give a \"statement has no effect\"\n * warning.\n */\n# define WARN_ON_SMP(x)\t\t\t({0;})\n#endif\n\n#endif /* __ASSEMBLY__ */\n\n#endif\n"}, "5": {"id": 5, "path": "/src/include/linux/compiler.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_H\n#define __LINUX_COMPILER_H\n\n#include <linux/compiler_types.h>\n\n#ifndef __ASSEMBLY__\n\n#ifdef __KERNEL__\n\n/*\n * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code\n * to disable branch tracing on a per file basis.\n */\n#if defined(CONFIG_TRACE_BRANCH_PROFILING) \\\n    && !defined(DISABLE_BRANCH_PROFILING) && !defined(__CHECKER__)\nvoid ftrace_likely_update(struct ftrace_likely_data *f, int val,\n\t\t\t  int expect, int is_constant);\n\n#define likely_notrace(x)\t__builtin_expect(!!(x), 1)\n#define unlikely_notrace(x)\t__builtin_expect(!!(x), 0)\n\n#define __branch_check__(x, expect, is_constant) ({\t\t\t\\\n\t\t\tlong ______r;\t\t\t\t\t\\\n\t\t\tstatic struct ftrace_likely_data\t\t\\\n\t\t\t\t__aligned(4)\t\t\t\t\\\n\t\t\t\t__section(\"_ftrace_annotated_branch\")\t\\\n\t\t\t\t______f = {\t\t\t\t\\\n\t\t\t\t.data.func = __func__,\t\t\t\\\n\t\t\t\t.data.file = __FILE__,\t\t\t\\\n\t\t\t\t.data.line = __LINE__,\t\t\t\\\n\t\t\t};\t\t\t\t\t\t\\\n\t\t\t______r = __builtin_expect(!!(x), expect);\t\\\n\t\t\tftrace_likely_update(&______f, ______r,\t\t\\\n\t\t\t\t\t     expect, is_constant);\t\\\n\t\t\t______r;\t\t\t\t\t\\\n\t\t})\n\n/*\n * Using __builtin_constant_p(x) to ignore cases where the return\n * value is always the same.  This idea is taken from a similar patch\n * written by Daniel Walker.\n */\n# ifndef likely\n#  define likely(x)\t(__branch_check__(x, 1, __builtin_constant_p(x)))\n# endif\n# ifndef unlikely\n#  define unlikely(x)\t(__branch_check__(x, 0, __builtin_constant_p(x)))\n# endif\n\n#ifdef CONFIG_PROFILE_ALL_BRANCHES\n/*\n * \"Define 'is'\", Bill Clinton\n * \"Define 'if'\", Steven Rostedt\n */\n#define if(cond, ...) if ( __trace_if_var( !!(cond , ## __VA_ARGS__) ) )\n\n#define __trace_if_var(cond) (__builtin_constant_p(cond) ? (cond) : __trace_if_value(cond))\n\n#define __trace_if_value(cond) ({\t\t\t\\\n\tstatic struct ftrace_branch_data\t\t\\\n\t\t__aligned(4)\t\t\t\t\\\n\t\t__section(\"_ftrace_branch\")\t\t\\\n\t\t__if_trace = {\t\t\t\t\\\n\t\t\t.func = __func__,\t\t\\\n\t\t\t.file = __FILE__,\t\t\\\n\t\t\t.line = __LINE__,\t\t\\\n\t\t};\t\t\t\t\t\\\n\t(cond) ?\t\t\t\t\t\\\n\t\t(__if_trace.miss_hit[1]++,1) :\t\t\\\n\t\t(__if_trace.miss_hit[0]++,0);\t\t\\\n})\n\n#endif /* CONFIG_PROFILE_ALL_BRANCHES */\n\n#else\n# define likely(x)\t__builtin_expect(!!(x), 1)\n# define unlikely(x)\t__builtin_expect(!!(x), 0)\n# define likely_notrace(x)\tlikely(x)\n# define unlikely_notrace(x)\tunlikely(x)\n#endif\n\n/* Optimization barrier */\n#ifndef barrier\n/* The \"volatile\" is due to gcc bugs */\n# define barrier() __asm__ __volatile__(\"\": : :\"memory\")\n#endif\n\n#ifndef barrier_data\n/*\n * This version is i.e. to prevent dead stores elimination on @ptr\n * where gcc and llvm may behave differently when otherwise using\n * normal barrier(): while gcc behavior gets along with a normal\n * barrier(), llvm needs an explicit input variable to be assumed\n * clobbered. The issue is as follows: while the inline asm might\n * access any memory it wants, the compiler could have fit all of\n * @ptr into memory registers instead, and since @ptr never escaped\n * from that, it proved that the inline asm wasn't touching any of\n * it. This version works well with both compilers, i.e. we're telling\n * the compiler that the inline asm absolutely may see the contents\n * of @ptr. See also: https://llvm.org/bugs/show_bug.cgi?id=15495\n */\n# define barrier_data(ptr) __asm__ __volatile__(\"\": :\"r\"(ptr) :\"memory\")\n#endif\n\n/* workaround for GCC PR82365 if needed */\n#ifndef barrier_before_unreachable\n# define barrier_before_unreachable() do { } while (0)\n#endif\n\n/* Unreachable code */\n#ifdef CONFIG_STACK_VALIDATION\n/*\n * These macros help objtool understand GCC code flow for unreachable code.\n * The __COUNTER__ based labels are a hack to make each instance of the macros\n * unique, to convince GCC not to merge duplicate inline asm statements.\n */\n#define annotate_reachable() ({\t\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.reachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define annotate_unreachable() ({\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.unreachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define ASM_UNREACHABLE\t\t\t\t\t\t\t\\\n\t\"999:\\n\\t\"\t\t\t\t\t\t\t\\\n\t\".pushsection .discard.unreachable\\n\\t\"\t\t\t\t\\\n\t\".long 999b - .\\n\\t\"\t\t\t\t\t\t\\\n\t\".popsection\\n\\t\"\n\n/* Annotate a C jump table to allow objtool to follow the code flow */\n#define __annotate_jump_table __section(\".rodata..c_jump_table\")\n\n#else\n#define annotate_reachable()\n#define annotate_unreachable()\n#define __annotate_jump_table\n#endif\n\n#ifndef ASM_UNREACHABLE\n# define ASM_UNREACHABLE\n#endif\n#ifndef unreachable\n# define unreachable() do {\t\t\\\n\tannotate_unreachable();\t\t\\\n\t__builtin_unreachable();\t\\\n} while (0)\n#endif\n\n/*\n * KENTRY - kernel entry point\n * This can be used to annotate symbols (functions or data) that are used\n * without their linker symbol being referenced explicitly. For example,\n * interrupt vector handlers, or functions in the kernel image that are found\n * programatically.\n *\n * Not required for symbols exported with EXPORT_SYMBOL, or initcalls. Those\n * are handled in their own way (with KEEP() in linker scripts).\n *\n * KENTRY can be avoided if the symbols in question are marked as KEEP() in the\n * linker script. For example an architecture could KEEP() its entire\n * boot/exception vector code rather than annotate each function and data.\n */\n#ifndef KENTRY\n# define KENTRY(sym)\t\t\t\t\t\t\\\n\textern typeof(sym) sym;\t\t\t\t\t\\\n\tstatic const unsigned long __kentry_##sym\t\t\\\n\t__used\t\t\t\t\t\t\t\\\n\t__attribute__((__section__(\"___kentry+\" #sym)))\t\t\\\n\t= (unsigned long)&sym;\n#endif\n\n#ifndef RELOC_HIDE\n# define RELOC_HIDE(ptr, off)\t\t\t\t\t\\\n  ({ unsigned long __ptr;\t\t\t\t\t\\\n     __ptr = (unsigned long) (ptr);\t\t\t\t\\\n    (typeof(ptr)) (__ptr + (off)); })\n#endif\n\n#ifndef OPTIMIZER_HIDE_VAR\n/* Make the optimizer believe the variable can be manipulated arbitrarily. */\n#define OPTIMIZER_HIDE_VAR(var)\t\t\t\t\t\t\\\n\t__asm__ (\"\" : \"=r\" (var) : \"0\" (var))\n#endif\n\n/* Not-quite-unique ID. */\n#ifndef __UNIQUE_ID\n# define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)\n#endif\n\n/**\n * data_race - mark an expression as containing intentional data races\n *\n * This data_race() macro is useful for situations in which data races\n * should be forgiven.  One example is diagnostic code that accesses\n * shared variables but is not a part of the core synchronization design.\n *\n * This macro *does not* affect normal code generation, but is a hint\n * to tooling that data races here are to be ignored.\n */\n#define data_race(expr)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__unqual_scalar_typeof(({ expr; })) __v = ({\t\t\t\\\n\t\t__kcsan_disable_current();\t\t\t\t\\\n\t\texpr;\t\t\t\t\t\t\t\\\n\t});\t\t\t\t\t\t\t\t\\\n\t__kcsan_enable_current();\t\t\t\t\t\\\n\t__v;\t\t\t\t\t\t\t\t\\\n})\n\n#endif /* __KERNEL__ */\n\n/*\n * Force the compiler to emit 'sym' as a symbol, so that we can reference\n * it from inline assembler. Necessary in case 'sym' could be inlined\n * otherwise, or eliminated entirely due to lack of references that are\n * visible to the compiler.\n */\n#define __ADDRESSABLE(sym) \\\n\tstatic void * __section(\".discard.addressable\") __used \\\n\t\t__UNIQUE_ID(__PASTE(__addressable_,sym)) = (void *)&sym;\n\n/**\n * offset_to_ptr - convert a relative memory offset to an absolute pointer\n * @off:\tthe address of the 32-bit offset value\n */\nstatic inline void *offset_to_ptr(const int *off)\n{\n\treturn (void *)((unsigned long)off + *off);\n}\n\n#endif /* __ASSEMBLY__ */\n\n/* &a[0] degrades to a pointer: a different type from an array */\n#define __must_be_array(a)\tBUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))\n\n/*\n * This is needed in functions which generate the stack canary, see\n * arch/x86/kernel/smpboot.c::start_secondary() for an example.\n */\n#define prevent_tail_call_optimization()\tmb()\n\n#include <asm/rwonce.h>\n\n#endif /* __LINUX_COMPILER_H */\n"}, "6": {"id": 6, "path": "/src/include/linux/slab.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * Written by Mark Hemment, 1996 (markhe@nextd.demon.co.uk).\n *\n * (C) SGI 2006, Christoph Lameter\n * \tCleaned up and restructured to ease the addition of alternative\n * \timplementations of SLAB allocators.\n * (C) Linux Foundation 2008-2013\n *      Unified interface for all slab allocators\n */\n\n#ifndef _LINUX_SLAB_H\n#define\t_LINUX_SLAB_H\n\n#include <linux/gfp.h>\n#include <linux/overflow.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include <linux/percpu-refcount.h>\n\n\n/*\n * Flags to pass to kmem_cache_create().\n * The ones marked DEBUG are only valid if CONFIG_DEBUG_SLAB is set.\n */\n/* DEBUG: Perform (expensive) checks on alloc/free */\n#define SLAB_CONSISTENCY_CHECKS\t((slab_flags_t __force)0x00000100U)\n/* DEBUG: Red zone objs in a cache */\n#define SLAB_RED_ZONE\t\t((slab_flags_t __force)0x00000400U)\n/* DEBUG: Poison objects */\n#define SLAB_POISON\t\t((slab_flags_t __force)0x00000800U)\n/* Align objs on cache lines */\n#define SLAB_HWCACHE_ALIGN\t((slab_flags_t __force)0x00002000U)\n/* Use GFP_DMA memory */\n#define SLAB_CACHE_DMA\t\t((slab_flags_t __force)0x00004000U)\n/* Use GFP_DMA32 memory */\n#define SLAB_CACHE_DMA32\t((slab_flags_t __force)0x00008000U)\n/* DEBUG: Store the last owner for bug hunting */\n#define SLAB_STORE_USER\t\t((slab_flags_t __force)0x00010000U)\n/* Panic if kmem_cache_create() fails */\n#define SLAB_PANIC\t\t((slab_flags_t __force)0x00040000U)\n/*\n * SLAB_TYPESAFE_BY_RCU - **WARNING** READ THIS!\n *\n * This delays freeing the SLAB page by a grace period, it does _NOT_\n * delay object freeing. This means that if you do kmem_cache_free()\n * that memory location is free to be reused at any time. Thus it may\n * be possible to see another object there in the same RCU grace period.\n *\n * This feature only ensures the memory location backing the object\n * stays valid, the trick to using this is relying on an independent\n * object validation pass. Something like:\n *\n *  rcu_read_lock()\n * again:\n *  obj = lockless_lookup(key);\n *  if (obj) {\n *    if (!try_get_ref(obj)) // might fail for free objects\n *      goto again;\n *\n *    if (obj->key != key) { // not the object we expected\n *      put_ref(obj);\n *      goto again;\n *    }\n *  }\n *  rcu_read_unlock();\n *\n * This is useful if we need to approach a kernel structure obliquely,\n * from its address obtained without the usual locking. We can lock\n * the structure to stabilize it and check it's still at the given address,\n * only if we can be sure that the memory has not been meanwhile reused\n * for some other kind of object (which our subsystem's lock might corrupt).\n *\n * rcu_read_lock before reading the address, then rcu_read_unlock after\n * taking the spinlock within the structure expected at that address.\n *\n * Note that SLAB_TYPESAFE_BY_RCU was originally named SLAB_DESTROY_BY_RCU.\n */\n/* Defer freeing slabs to RCU */\n#define SLAB_TYPESAFE_BY_RCU\t((slab_flags_t __force)0x00080000U)\n/* Spread some memory over cpuset */\n#define SLAB_MEM_SPREAD\t\t((slab_flags_t __force)0x00100000U)\n/* Trace allocations and frees */\n#define SLAB_TRACE\t\t((slab_flags_t __force)0x00200000U)\n\n/* Flag to prevent checks on free */\n#ifdef CONFIG_DEBUG_OBJECTS\n# define SLAB_DEBUG_OBJECTS\t((slab_flags_t __force)0x00400000U)\n#else\n# define SLAB_DEBUG_OBJECTS\t0\n#endif\n\n/* Avoid kmemleak tracing */\n#define SLAB_NOLEAKTRACE\t((slab_flags_t __force)0x00800000U)\n\n/* Fault injection mark */\n#ifdef CONFIG_FAILSLAB\n# define SLAB_FAILSLAB\t\t((slab_flags_t __force)0x02000000U)\n#else\n# define SLAB_FAILSLAB\t\t0\n#endif\n/* Account to memcg */\n#ifdef CONFIG_MEMCG_KMEM\n# define SLAB_ACCOUNT\t\t((slab_flags_t __force)0x04000000U)\n#else\n# define SLAB_ACCOUNT\t\t0\n#endif\n\n#ifdef CONFIG_KASAN\n#define SLAB_KASAN\t\t((slab_flags_t __force)0x08000000U)\n#else\n#define SLAB_KASAN\t\t0\n#endif\n\n/* The following flags affect the page allocator grouping pages by mobility */\n/* Objects are reclaimable */\n#define SLAB_RECLAIM_ACCOUNT\t((slab_flags_t __force)0x00020000U)\n#define SLAB_TEMPORARY\t\tSLAB_RECLAIM_ACCOUNT\t/* Objects are short-lived */\n\n/* Slab deactivation flag */\n#define SLAB_DEACTIVATED\t((slab_flags_t __force)0x10000000U)\n\n/*\n * ZERO_SIZE_PTR will be returned for zero sized kmalloc requests.\n *\n * Dereferencing ZERO_SIZE_PTR will lead to a distinct access fault.\n *\n * ZERO_SIZE_PTR can be passed to kfree though in the same way that NULL can.\n * Both make kfree a no-op.\n */\n#define ZERO_SIZE_PTR ((void *)16)\n\n#define ZERO_OR_NULL_PTR(x) ((unsigned long)(x) <= \\\n\t\t\t\t(unsigned long)ZERO_SIZE_PTR)\n\n#include <linux/kasan.h>\n\nstruct mem_cgroup;\n/*\n * struct kmem_cache related prototypes\n */\nvoid __init kmem_cache_init(void);\nbool slab_is_available(void);\n\nextern bool usercopy_fallback;\n\nstruct kmem_cache *kmem_cache_create(const char *name, unsigned int size,\n\t\t\tunsigned int align, slab_flags_t flags,\n\t\t\tvoid (*ctor)(void *));\nstruct kmem_cache *kmem_cache_create_usercopy(const char *name,\n\t\t\tunsigned int size, unsigned int align,\n\t\t\tslab_flags_t flags,\n\t\t\tunsigned int useroffset, unsigned int usersize,\n\t\t\tvoid (*ctor)(void *));\nvoid kmem_cache_destroy(struct kmem_cache *);\nint kmem_cache_shrink(struct kmem_cache *);\n\n/*\n * Please use this macro to create slab caches. Simply specify the\n * name of the structure and maybe some flags that are listed above.\n *\n * The alignment of the struct determines object alignment. If you\n * f.e. add ____cacheline_aligned_in_smp to the struct declaration\n * then the objects will be properly aligned in SMP configurations.\n */\n#define KMEM_CACHE(__struct, __flags)\t\t\t\t\t\\\n\t\tkmem_cache_create(#__struct, sizeof(struct __struct),\t\\\n\t\t\t__alignof__(struct __struct), (__flags), NULL)\n\n/*\n * To whitelist a single field for copying to/from usercopy, use this\n * macro instead for KMEM_CACHE() above.\n */\n#define KMEM_CACHE_USERCOPY(__struct, __flags, __field)\t\t\t\\\n\t\tkmem_cache_create_usercopy(#__struct,\t\t\t\\\n\t\t\tsizeof(struct __struct),\t\t\t\\\n\t\t\t__alignof__(struct __struct), (__flags),\t\\\n\t\t\toffsetof(struct __struct, __field),\t\t\\\n\t\t\tsizeof_field(struct __struct, __field), NULL)\n\n/*\n * Common kmalloc functions provided by all allocators\n */\nvoid * __must_check krealloc(const void *, size_t, gfp_t);\nvoid kfree(const void *);\nvoid kfree_sensitive(const void *);\nsize_t __ksize(const void *);\nsize_t ksize(const void *);\n#ifdef CONFIG_PRINTK\nbool kmem_valid_obj(void *object);\nvoid kmem_dump_obj(void *object);\n#endif\n\n#ifdef CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR\nvoid __check_heap_object(const void *ptr, unsigned long n, struct page *page,\n\t\t\tbool to_user);\n#else\nstatic inline void __check_heap_object(const void *ptr, unsigned long n,\n\t\t\t\t       struct page *page, bool to_user) { }\n#endif\n\n/*\n * Some archs want to perform DMA into kmalloc caches and need a guaranteed\n * alignment larger than the alignment of a 64-bit integer.\n * Setting ARCH_KMALLOC_MINALIGN in arch headers allows that.\n */\n#if defined(ARCH_DMA_MINALIGN) && ARCH_DMA_MINALIGN > 8\n#define ARCH_KMALLOC_MINALIGN ARCH_DMA_MINALIGN\n#define KMALLOC_MIN_SIZE ARCH_DMA_MINALIGN\n#define KMALLOC_SHIFT_LOW ilog2(ARCH_DMA_MINALIGN)\n#else\n#define ARCH_KMALLOC_MINALIGN __alignof__(unsigned long long)\n#endif\n\n/*\n * Setting ARCH_SLAB_MINALIGN in arch headers allows a different alignment.\n * Intended for arches that get misalignment faults even for 64 bit integer\n * aligned buffers.\n */\n#ifndef ARCH_SLAB_MINALIGN\n#define ARCH_SLAB_MINALIGN __alignof__(unsigned long long)\n#endif\n\n/*\n * kmalloc and friends return ARCH_KMALLOC_MINALIGN aligned\n * pointers. kmem_cache_alloc and friends return ARCH_SLAB_MINALIGN\n * aligned pointers.\n */\n#define __assume_kmalloc_alignment __assume_aligned(ARCH_KMALLOC_MINALIGN)\n#define __assume_slab_alignment __assume_aligned(ARCH_SLAB_MINALIGN)\n#define __assume_page_alignment __assume_aligned(PAGE_SIZE)\n\n/*\n * Kmalloc array related definitions\n */\n\n#ifdef CONFIG_SLAB\n/*\n * The largest kmalloc size supported by the SLAB allocators is\n * 32 megabyte (2^25) or the maximum allocatable page order if that is\n * less than 32 MB.\n *\n * WARNING: Its not easy to increase this value since the allocators have\n * to do various tricks to work around compiler limitations in order to\n * ensure proper constant folding.\n */\n#define KMALLOC_SHIFT_HIGH\t((MAX_ORDER + PAGE_SHIFT - 1) <= 25 ? \\\n\t\t\t\t(MAX_ORDER + PAGE_SHIFT - 1) : 25)\n#define KMALLOC_SHIFT_MAX\tKMALLOC_SHIFT_HIGH\n#ifndef KMALLOC_SHIFT_LOW\n#define KMALLOC_SHIFT_LOW\t5\n#endif\n#endif\n\n#ifdef CONFIG_SLUB\n/*\n * SLUB directly allocates requests fitting in to an order-1 page\n * (PAGE_SIZE*2).  Larger requests are passed to the page allocator.\n */\n#define KMALLOC_SHIFT_HIGH\t(PAGE_SHIFT + 1)\n#define KMALLOC_SHIFT_MAX\t(MAX_ORDER + PAGE_SHIFT - 1)\n#ifndef KMALLOC_SHIFT_LOW\n#define KMALLOC_SHIFT_LOW\t3\n#endif\n#endif\n\n#ifdef CONFIG_SLOB\n/*\n * SLOB passes all requests larger than one page to the page allocator.\n * No kmalloc array is necessary since objects of different sizes can\n * be allocated from the same page.\n */\n#define KMALLOC_SHIFT_HIGH\tPAGE_SHIFT\n#define KMALLOC_SHIFT_MAX\t(MAX_ORDER + PAGE_SHIFT - 1)\n#ifndef KMALLOC_SHIFT_LOW\n#define KMALLOC_SHIFT_LOW\t3\n#endif\n#endif\n\n/* Maximum allocatable size */\n#define KMALLOC_MAX_SIZE\t(1UL << KMALLOC_SHIFT_MAX)\n/* Maximum size for which we actually use a slab cache */\n#define KMALLOC_MAX_CACHE_SIZE\t(1UL << KMALLOC_SHIFT_HIGH)\n/* Maximum order allocatable via the slab allocator */\n#define KMALLOC_MAX_ORDER\t(KMALLOC_SHIFT_MAX - PAGE_SHIFT)\n\n/*\n * Kmalloc subsystem.\n */\n#ifndef KMALLOC_MIN_SIZE\n#define KMALLOC_MIN_SIZE (1 << KMALLOC_SHIFT_LOW)\n#endif\n\n/*\n * This restriction comes from byte sized index implementation.\n * Page size is normally 2^12 bytes and, in this case, if we want to use\n * byte sized index which can represent 2^8 entries, the size of the object\n * should be equal or greater to 2^12 / 2^8 = 2^4 = 16.\n * If minimum size of kmalloc is less than 16, we use it as minimum object\n * size and give up to use byte sized index.\n */\n#define SLAB_OBJ_MIN_SIZE      (KMALLOC_MIN_SIZE < 16 ? \\\n                               (KMALLOC_MIN_SIZE) : 16)\n\n/*\n * Whenever changing this, take care of that kmalloc_type() and\n * create_kmalloc_caches() still work as intended.\n */\nenum kmalloc_cache_type {\n\tKMALLOC_NORMAL = 0,\n\tKMALLOC_RECLAIM,\n#ifdef CONFIG_ZONE_DMA\n\tKMALLOC_DMA,\n#endif\n\tNR_KMALLOC_TYPES\n};\n\n#ifndef CONFIG_SLOB\nextern struct kmem_cache *\nkmalloc_caches[NR_KMALLOC_TYPES][KMALLOC_SHIFT_HIGH + 1];\n\nstatic __always_inline enum kmalloc_cache_type kmalloc_type(gfp_t flags)\n{\n#ifdef CONFIG_ZONE_DMA\n\t/*\n\t * The most common case is KMALLOC_NORMAL, so test for it\n\t * with a single branch for both flags.\n\t */\n\tif (likely((flags & (__GFP_DMA | __GFP_RECLAIMABLE)) == 0))\n\t\treturn KMALLOC_NORMAL;\n\n\t/*\n\t * At least one of the flags has to be set. If both are, __GFP_DMA\n\t * is more important.\n\t */\n\treturn flags & __GFP_DMA ? KMALLOC_DMA : KMALLOC_RECLAIM;\n#else\n\treturn flags & __GFP_RECLAIMABLE ? KMALLOC_RECLAIM : KMALLOC_NORMAL;\n#endif\n}\n\n/*\n * Figure out which kmalloc slab an allocation of a certain size\n * belongs to.\n * 0 = zero alloc\n * 1 =  65 .. 96 bytes\n * 2 = 129 .. 192 bytes\n * n = 2^(n-1)+1 .. 2^n\n */\nstatic __always_inline unsigned int kmalloc_index(size_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\n\tif (size <= KMALLOC_MIN_SIZE)\n\t\treturn KMALLOC_SHIFT_LOW;\n\n\tif (KMALLOC_MIN_SIZE <= 32 && size > 64 && size <= 96)\n\t\treturn 1;\n\tif (KMALLOC_MIN_SIZE <= 64 && size > 128 && size <= 192)\n\t\treturn 2;\n\tif (size <=          8) return 3;\n\tif (size <=         16) return 4;\n\tif (size <=         32) return 5;\n\tif (size <=         64) return 6;\n\tif (size <=        128) return 7;\n\tif (size <=        256) return 8;\n\tif (size <=        512) return 9;\n\tif (size <=       1024) return 10;\n\tif (size <=   2 * 1024) return 11;\n\tif (size <=   4 * 1024) return 12;\n\tif (size <=   8 * 1024) return 13;\n\tif (size <=  16 * 1024) return 14;\n\tif (size <=  32 * 1024) return 15;\n\tif (size <=  64 * 1024) return 16;\n\tif (size <= 128 * 1024) return 17;\n\tif (size <= 256 * 1024) return 18;\n\tif (size <= 512 * 1024) return 19;\n\tif (size <= 1024 * 1024) return 20;\n\tif (size <=  2 * 1024 * 1024) return 21;\n\tif (size <=  4 * 1024 * 1024) return 22;\n\tif (size <=  8 * 1024 * 1024) return 23;\n\tif (size <=  16 * 1024 * 1024) return 24;\n\tif (size <=  32 * 1024 * 1024) return 25;\n\tif (size <=  64 * 1024 * 1024) return 26;\n\tBUG();\n\n\t/* Will never be reached. Needed because the compiler may complain */\n\treturn -1;\n}\n#endif /* !CONFIG_SLOB */\n\nvoid *__kmalloc(size_t size, gfp_t flags) __assume_kmalloc_alignment __malloc;\nvoid *kmem_cache_alloc(struct kmem_cache *, gfp_t flags) __assume_slab_alignment __malloc;\nvoid kmem_cache_free(struct kmem_cache *, void *);\n\n/*\n * Bulk allocation and freeing operations. These are accelerated in an\n * allocator specific way to avoid taking locks repeatedly or building\n * metadata structures unnecessarily.\n *\n * Note that interrupts must be enabled when calling these functions.\n */\nvoid kmem_cache_free_bulk(struct kmem_cache *, size_t, void **);\nint kmem_cache_alloc_bulk(struct kmem_cache *, gfp_t, size_t, void **);\n\n/*\n * Caller must not use kfree_bulk() on memory not originally allocated\n * by kmalloc(), because the SLOB allocator cannot handle this.\n */\nstatic __always_inline void kfree_bulk(size_t size, void **p)\n{\n\tkmem_cache_free_bulk(NULL, size, p);\n}\n\n#ifdef CONFIG_NUMA\nvoid *__kmalloc_node(size_t size, gfp_t flags, int node) __assume_kmalloc_alignment __malloc;\nvoid *kmem_cache_alloc_node(struct kmem_cache *, gfp_t flags, int node) __assume_slab_alignment __malloc;\n#else\nstatic __always_inline void *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __kmalloc(size, flags);\n}\n\nstatic __always_inline void *kmem_cache_alloc_node(struct kmem_cache *s, gfp_t flags, int node)\n{\n\treturn kmem_cache_alloc(s, flags);\n}\n#endif\n\n#ifdef CONFIG_TRACING\nextern void *kmem_cache_alloc_trace(struct kmem_cache *, gfp_t, size_t) __assume_slab_alignment __malloc;\n\n#ifdef CONFIG_NUMA\nextern void *kmem_cache_alloc_node_trace(struct kmem_cache *s,\n\t\t\t\t\t   gfp_t gfpflags,\n\t\t\t\t\t   int node, size_t size) __assume_slab_alignment __malloc;\n#else\nstatic __always_inline void *\nkmem_cache_alloc_node_trace(struct kmem_cache *s,\n\t\t\t      gfp_t gfpflags,\n\t\t\t      int node, size_t size)\n{\n\treturn kmem_cache_alloc_trace(s, gfpflags, size);\n}\n#endif /* CONFIG_NUMA */\n\n#else /* CONFIG_TRACING */\nstatic __always_inline void *kmem_cache_alloc_trace(struct kmem_cache *s,\n\t\tgfp_t flags, size_t size)\n{\n\tvoid *ret = kmem_cache_alloc(s, flags);\n\n\tret = kasan_kmalloc(s, ret, size, flags);\n\treturn ret;\n}\n\nstatic __always_inline void *\nkmem_cache_alloc_node_trace(struct kmem_cache *s,\n\t\t\t      gfp_t gfpflags,\n\t\t\t      int node, size_t size)\n{\n\tvoid *ret = kmem_cache_alloc_node(s, gfpflags, node);\n\n\tret = kasan_kmalloc(s, ret, size, gfpflags);\n\treturn ret;\n}\n#endif /* CONFIG_TRACING */\n\nextern void *kmalloc_order(size_t size, gfp_t flags, unsigned int order) __assume_page_alignment __malloc;\n\n#ifdef CONFIG_TRACING\nextern void *kmalloc_order_trace(size_t size, gfp_t flags, unsigned int order) __assume_page_alignment __malloc;\n#else\nstatic __always_inline void *\nkmalloc_order_trace(size_t size, gfp_t flags, unsigned int order)\n{\n\treturn kmalloc_order(size, flags, order);\n}\n#endif\n\nstatic __always_inline void *kmalloc_large(size_t size, gfp_t flags)\n{\n\tunsigned int order = get_order(size);\n\treturn kmalloc_order_trace(size, flags, order);\n}\n\n/**\n * kmalloc - allocate memory\n * @size: how many bytes of memory are required.\n * @flags: the type of memory to allocate.\n *\n * kmalloc is the normal method of allocating memory\n * for objects smaller than page size in the kernel.\n *\n * The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN\n * bytes. For @size of power of two bytes, the alignment is also guaranteed\n * to be at least to the size.\n *\n * The @flags argument may be one of the GFP flags defined at\n * include/linux/gfp.h and described at\n * :ref:`Documentation/core-api/mm-api.rst <mm-api-gfp-flags>`\n *\n * The recommended usage of the @flags is described at\n * :ref:`Documentation/core-api/memory-allocation.rst <memory_allocation>`\n *\n * Below is a brief outline of the most useful GFP flags\n *\n * %GFP_KERNEL\n *\tAllocate normal kernel ram. May sleep.\n *\n * %GFP_NOWAIT\n *\tAllocation will not sleep.\n *\n * %GFP_ATOMIC\n *\tAllocation will not sleep.  May use emergency pools.\n *\n * %GFP_HIGHUSER\n *\tAllocate memory from high memory on behalf of user.\n *\n * Also it is possible to set different flags by OR'ing\n * in one or more of the following additional @flags:\n *\n * %__GFP_HIGH\n *\tThis allocation has high priority and may use emergency pools.\n *\n * %__GFP_NOFAIL\n *\tIndicate that this allocation is in no way allowed to fail\n *\t(think twice before using).\n *\n * %__GFP_NORETRY\n *\tIf memory is not immediately available,\n *\tthen give up at once.\n *\n * %__GFP_NOWARN\n *\tIf allocation fails, don't issue any warnings.\n *\n * %__GFP_RETRY_MAYFAIL\n *\tTry really hard to succeed the allocation but fail\n *\teventually.\n */\nstatic __always_inline void *kmalloc(size_t size, gfp_t flags)\n{\n\tif (__builtin_constant_p(size)) {\n#ifndef CONFIG_SLOB\n\t\tunsigned int index;\n#endif\n\t\tif (size > KMALLOC_MAX_CACHE_SIZE)\n\t\t\treturn kmalloc_large(size, flags);\n#ifndef CONFIG_SLOB\n\t\tindex = kmalloc_index(size);\n\n\t\tif (!index)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\treturn kmem_cache_alloc_trace(\n\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],\n\t\t\t\tflags, size);\n#endif\n\t}\n\treturn __kmalloc(size, flags);\n}\n\nstatic __always_inline void *kmalloc_node(size_t size, gfp_t flags, int node)\n{\n#ifndef CONFIG_SLOB\n\tif (__builtin_constant_p(size) &&\n\t\tsize <= KMALLOC_MAX_CACHE_SIZE) {\n\t\tunsigned int i = kmalloc_index(size);\n\n\t\tif (!i)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\treturn kmem_cache_alloc_node_trace(\n\t\t\t\tkmalloc_caches[kmalloc_type(flags)][i],\n\t\t\t\t\t\tflags, node, size);\n\t}\n#endif\n\treturn __kmalloc_node(size, flags, node);\n}\n\n/**\n * kmalloc_array - allocate memory for an array.\n * @n: number of elements.\n * @size: element size.\n * @flags: the type of memory to allocate (see kmalloc).\n */\nstatic inline void *kmalloc_array(size_t n, size_t size, gfp_t flags)\n{\n\tsize_t bytes;\n\n\tif (unlikely(check_mul_overflow(n, size, &bytes)))\n\t\treturn NULL;\n\tif (__builtin_constant_p(n) && __builtin_constant_p(size))\n\t\treturn kmalloc(bytes, flags);\n\treturn __kmalloc(bytes, flags);\n}\n\n/**\n * krealloc_array - reallocate memory for an array.\n * @p: pointer to the memory chunk to reallocate\n * @new_n: new number of elements to alloc\n * @new_size: new size of a single member of the array\n * @flags: the type of memory to allocate (see kmalloc)\n */\nstatic __must_check inline void *\nkrealloc_array(void *p, size_t new_n, size_t new_size, gfp_t flags)\n{\n\tsize_t bytes;\n\n\tif (unlikely(check_mul_overflow(new_n, new_size, &bytes)))\n\t\treturn NULL;\n\n\treturn krealloc(p, bytes, flags);\n}\n\n/**\n * kcalloc - allocate memory for an array. The memory is set to zero.\n * @n: number of elements.\n * @size: element size.\n * @flags: the type of memory to allocate (see kmalloc).\n */\nstatic inline void *kcalloc(size_t n, size_t size, gfp_t flags)\n{\n\treturn kmalloc_array(n, size, flags | __GFP_ZERO);\n}\n\n/*\n * kmalloc_track_caller is a special version of kmalloc that records the\n * calling function of the routine calling it for slab leak tracking instead\n * of just the calling function (confusing, eh?).\n * It's useful when the call to kmalloc comes from a widely-used standard\n * allocator where we care about the real place the memory allocation\n * request comes from.\n */\nextern void *__kmalloc_track_caller(size_t, gfp_t, unsigned long);\n#define kmalloc_track_caller(size, flags) \\\n\t__kmalloc_track_caller(size, flags, _RET_IP_)\n\nstatic inline void *kmalloc_array_node(size_t n, size_t size, gfp_t flags,\n\t\t\t\t       int node)\n{\n\tsize_t bytes;\n\n\tif (unlikely(check_mul_overflow(n, size, &bytes)))\n\t\treturn NULL;\n\tif (__builtin_constant_p(n) && __builtin_constant_p(size))\n\t\treturn kmalloc_node(bytes, flags, node);\n\treturn __kmalloc_node(bytes, flags, node);\n}\n\nstatic inline void *kcalloc_node(size_t n, size_t size, gfp_t flags, int node)\n{\n\treturn kmalloc_array_node(n, size, flags | __GFP_ZERO, node);\n}\n\n\n#ifdef CONFIG_NUMA\nextern void *__kmalloc_node_track_caller(size_t, gfp_t, int, unsigned long);\n#define kmalloc_node_track_caller(size, flags, node) \\\n\t__kmalloc_node_track_caller(size, flags, node, \\\n\t\t\t_RET_IP_)\n\n#else /* CONFIG_NUMA */\n\n#define kmalloc_node_track_caller(size, flags, node) \\\n\tkmalloc_track_caller(size, flags)\n\n#endif /* CONFIG_NUMA */\n\n/*\n * Shortcuts\n */\nstatic inline void *kmem_cache_zalloc(struct kmem_cache *k, gfp_t flags)\n{\n\treturn kmem_cache_alloc(k, flags | __GFP_ZERO);\n}\n\n/**\n * kzalloc - allocate memory. The memory is set to zero.\n * @size: how many bytes of memory are required.\n * @flags: the type of memory to allocate (see kmalloc).\n */\nstatic inline void *kzalloc(size_t size, gfp_t flags)\n{\n\treturn kmalloc(size, flags | __GFP_ZERO);\n}\n\n/**\n * kzalloc_node - allocate zeroed memory from a particular memory node.\n * @size: how many bytes of memory are required.\n * @flags: the type of memory to allocate (see kmalloc).\n * @node: memory node from which to allocate\n */\nstatic inline void *kzalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn kmalloc_node(size, flags | __GFP_ZERO, node);\n}\n\nunsigned int kmem_cache_size(struct kmem_cache *s);\nvoid __init kmem_cache_init_late(void);\n\n#if defined(CONFIG_SMP) && defined(CONFIG_SLAB)\nint slab_prepare_cpu(unsigned int cpu);\nint slab_dead_cpu(unsigned int cpu);\n#else\n#define slab_prepare_cpu\tNULL\n#define slab_dead_cpu\t\tNULL\n#endif\n\n#endif\t/* _LINUX_SLAB_H */\n"}, "7": {"id": 7, "path": "/src/include/linux/spinlock.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_SPINLOCK_H\n#define __LINUX_SPINLOCK_H\n\n/*\n * include/linux/spinlock.h - generic spinlock/rwlock declarations\n *\n * here's the role of the various spinlock/rwlock related include files:\n *\n * on SMP builds:\n *\n *  asm/spinlock_types.h: contains the arch_spinlock_t/arch_rwlock_t and the\n *                        initializers\n *\n *  linux/spinlock_types.h:\n *                        defines the generic type and initializers\n *\n *  asm/spinlock.h:       contains the arch_spin_*()/etc. lowlevel\n *                        implementations, mostly inline assembly code\n *\n *   (also included on UP-debug builds:)\n *\n *  linux/spinlock_api_smp.h:\n *                        contains the prototypes for the _spin_*() APIs.\n *\n *  linux/spinlock.h:     builds the final spin_*() APIs.\n *\n * on UP builds:\n *\n *  linux/spinlock_type_up.h:\n *                        contains the generic, simplified UP spinlock type.\n *                        (which is an empty structure on non-debug builds)\n *\n *  linux/spinlock_types.h:\n *                        defines the generic type and initializers\n *\n *  linux/spinlock_up.h:\n *                        contains the arch_spin_*()/etc. version of UP\n *                        builds. (which are NOPs on non-debug, non-preempt\n *                        builds)\n *\n *   (included on UP-non-debug builds:)\n *\n *  linux/spinlock_api_up.h:\n *                        builds the _spin_*() APIs.\n *\n *  linux/spinlock.h:     builds the final spin_*() APIs.\n */\n\n#include <linux/typecheck.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n#include <linux/compiler.h>\n#include <linux/irqflags.h>\n#include <linux/thread_info.h>\n#include <linux/kernel.h>\n#include <linux/stringify.h>\n#include <linux/bottom_half.h>\n#include <linux/lockdep.h>\n#include <asm/barrier.h>\n#include <asm/mmiowb.h>\n\n\n/*\n * Must define these before including other files, inline functions need them\n */\n#define LOCK_SECTION_NAME \".text..lock.\"KBUILD_BASENAME\n\n#define LOCK_SECTION_START(extra)               \\\n        \".subsection 1\\n\\t\"                     \\\n        extra                                   \\\n        \".ifndef \" LOCK_SECTION_NAME \"\\n\\t\"     \\\n        LOCK_SECTION_NAME \":\\n\\t\"               \\\n        \".endif\\n\"\n\n#define LOCK_SECTION_END                        \\\n        \".previous\\n\\t\"\n\n#define __lockfunc __section(\".spinlock.text\")\n\n/*\n * Pull the arch_spinlock_t and arch_rwlock_t definitions:\n */\n#include <linux/spinlock_types.h>\n\n/*\n * Pull the arch_spin*() functions/declarations (UP-nondebug doesn't need them):\n */\n#ifdef CONFIG_SMP\n# include <asm/spinlock.h>\n#else\n# include <linux/spinlock_up.h>\n#endif\n\n#ifdef CONFIG_DEBUG_SPINLOCK\n  extern void __raw_spin_lock_init(raw_spinlock_t *lock, const char *name,\n\t\t\t\t   struct lock_class_key *key, short inner);\n\n# define raw_spin_lock_init(lock)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tstatic struct lock_class_key __key;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__raw_spin_lock_init((lock), #lock, &__key, LD_WAIT_SPIN);\t\\\n} while (0)\n\n#else\n# define raw_spin_lock_init(lock)\t\t\t\t\\\n\tdo { *(lock) = __RAW_SPIN_LOCK_UNLOCKED(lock); } while (0)\n#endif\n\n#define raw_spin_is_locked(lock)\tarch_spin_is_locked(&(lock)->raw_lock)\n\n#ifdef arch_spin_is_contended\n#define raw_spin_is_contended(lock)\tarch_spin_is_contended(&(lock)->raw_lock)\n#else\n#define raw_spin_is_contended(lock)\t(((void)(lock), 0))\n#endif /*arch_spin_is_contended*/\n\n/*\n * smp_mb__after_spinlock() provides the equivalent of a full memory barrier\n * between program-order earlier lock acquisitions and program-order later\n * memory accesses.\n *\n * This guarantees that the following two properties hold:\n *\n *   1) Given the snippet:\n *\n *\t  { X = 0;  Y = 0; }\n *\n *\t  CPU0\t\t\t\tCPU1\n *\n *\t  WRITE_ONCE(X, 1);\t\tWRITE_ONCE(Y, 1);\n *\t  spin_lock(S);\t\t\tsmp_mb();\n *\t  smp_mb__after_spinlock();\tr1 = READ_ONCE(X);\n *\t  r0 = READ_ONCE(Y);\n *\t  spin_unlock(S);\n *\n *      it is forbidden that CPU0 does not observe CPU1's store to Y (r0 = 0)\n *      and CPU1 does not observe CPU0's store to X (r1 = 0); see the comments\n *      preceding the call to smp_mb__after_spinlock() in __schedule() and in\n *      try_to_wake_up().\n *\n *   2) Given the snippet:\n *\n *  { X = 0;  Y = 0; }\n *\n *  CPU0\t\tCPU1\t\t\t\tCPU2\n *\n *  spin_lock(S);\tspin_lock(S);\t\t\tr1 = READ_ONCE(Y);\n *  WRITE_ONCE(X, 1);\tsmp_mb__after_spinlock();\tsmp_rmb();\n *  spin_unlock(S);\tr0 = READ_ONCE(X);\t\tr2 = READ_ONCE(X);\n *\t\t\tWRITE_ONCE(Y, 1);\n *\t\t\tspin_unlock(S);\n *\n *      it is forbidden that CPU0's critical section executes before CPU1's\n *      critical section (r0 = 1), CPU2 observes CPU1's store to Y (r1 = 1)\n *      and CPU2 does not observe CPU0's store to X (r2 = 0); see the comments\n *      preceding the calls to smp_rmb() in try_to_wake_up() for similar\n *      snippets but \"projected\" onto two CPUs.\n *\n * Property (2) upgrades the lock to an RCsc lock.\n *\n * Since most load-store architectures implement ACQUIRE with an smp_mb() after\n * the LL/SC loop, they need no further barriers. Similarly all our TSO\n * architectures imply an smp_mb() for each atomic instruction and equally don't\n * need more.\n *\n * Architectures that can implement ACQUIRE better need to take care.\n */\n#ifndef smp_mb__after_spinlock\n#define smp_mb__after_spinlock()\tdo { } while (0)\n#endif\n\n#ifdef CONFIG_DEBUG_SPINLOCK\n extern void do_raw_spin_lock(raw_spinlock_t *lock) __acquires(lock);\n#define do_raw_spin_lock_flags(lock, flags) do_raw_spin_lock(lock)\n extern int do_raw_spin_trylock(raw_spinlock_t *lock);\n extern void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock);\n#else\nstatic inline void do_raw_spin_lock(raw_spinlock_t *lock) __acquires(lock)\n{\n\t__acquire(lock);\n\tarch_spin_lock(&lock->raw_lock);\n\tmmiowb_spin_lock();\n}\n\n#ifndef arch_spin_lock_flags\n#define arch_spin_lock_flags(lock, flags)\tarch_spin_lock(lock)\n#endif\n\nstatic inline void\ndo_raw_spin_lock_flags(raw_spinlock_t *lock, unsigned long *flags) __acquires(lock)\n{\n\t__acquire(lock);\n\tarch_spin_lock_flags(&lock->raw_lock, *flags);\n\tmmiowb_spin_lock();\n}\n\nstatic inline int do_raw_spin_trylock(raw_spinlock_t *lock)\n{\n\tint ret = arch_spin_trylock(&(lock)->raw_lock);\n\n\tif (ret)\n\t\tmmiowb_spin_lock();\n\n\treturn ret;\n}\n\nstatic inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)\n{\n\tmmiowb_spin_unlock();\n\tarch_spin_unlock(&lock->raw_lock);\n\t__release(lock);\n}\n#endif\n\n/*\n * Define the various spin_lock methods.  Note we define these\n * regardless of whether CONFIG_SMP or CONFIG_PREEMPTION are set. The\n * various methods are defined as nops in the case they are not\n * required.\n */\n#define raw_spin_trylock(lock)\t__cond_lock(lock, _raw_spin_trylock(lock))\n\n#define raw_spin_lock(lock)\t_raw_spin_lock(lock)\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n# define raw_spin_lock_nested(lock, subclass) \\\n\t_raw_spin_lock_nested(lock, subclass)\n\n# define raw_spin_lock_nest_lock(lock, nest_lock)\t\t\t\\\n\t do {\t\t\t\t\t\t\t\t\\\n\t\t typecheck(struct lockdep_map *, &(nest_lock)->dep_map);\\\n\t\t _raw_spin_lock_nest_lock(lock, &(nest_lock)->dep_map);\t\\\n\t } while (0)\n#else\n/*\n * Always evaluate the 'subclass' argument to avoid that the compiler\n * warns about set-but-not-used variables when building with\n * CONFIG_DEBUG_LOCK_ALLOC=n and with W=1.\n */\n# define raw_spin_lock_nested(lock, subclass)\t\t\\\n\t_raw_spin_lock(((void)(subclass), (lock)))\n# define raw_spin_lock_nest_lock(lock, nest_lock)\t_raw_spin_lock(lock)\n#endif\n\n#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)\n\n#define raw_spin_lock_irqsave(lock, flags)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\ttypecheck(unsigned long, flags);\t\\\n\t\tflags = _raw_spin_lock_irqsave(lock);\t\\\n\t} while (0)\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n#define raw_spin_lock_irqsave_nested(lock, flags, subclass)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\ttypecheck(unsigned long, flags);\t\t\t\\\n\t\tflags = _raw_spin_lock_irqsave_nested(lock, subclass);\t\\\n\t} while (0)\n#else\n#define raw_spin_lock_irqsave_nested(lock, flags, subclass)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\ttypecheck(unsigned long, flags);\t\t\t\\\n\t\tflags = _raw_spin_lock_irqsave(lock);\t\t\t\\\n\t} while (0)\n#endif\n\n#else\n\n#define raw_spin_lock_irqsave(lock, flags)\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\ttypecheck(unsigned long, flags);\t\\\n\t\t_raw_spin_lock_irqsave(lock, flags);\t\\\n\t} while (0)\n\n#define raw_spin_lock_irqsave_nested(lock, flags, subclass)\t\\\n\traw_spin_lock_irqsave(lock, flags)\n\n#endif\n\n#define raw_spin_lock_irq(lock)\t\t_raw_spin_lock_irq(lock)\n#define raw_spin_lock_bh(lock)\t\t_raw_spin_lock_bh(lock)\n#define raw_spin_unlock(lock)\t\t_raw_spin_unlock(lock)\n#define raw_spin_unlock_irq(lock)\t_raw_spin_unlock_irq(lock)\n\n#define raw_spin_unlock_irqrestore(lock, flags)\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\ttypecheck(unsigned long, flags);\t\t\\\n\t\t_raw_spin_unlock_irqrestore(lock, flags);\t\\\n\t} while (0)\n#define raw_spin_unlock_bh(lock)\t_raw_spin_unlock_bh(lock)\n\n#define raw_spin_trylock_bh(lock) \\\n\t__cond_lock(lock, _raw_spin_trylock_bh(lock))\n\n#define raw_spin_trylock_irq(lock) \\\n({ \\\n\tlocal_irq_disable(); \\\n\traw_spin_trylock(lock) ? \\\n\t1 : ({ local_irq_enable(); 0;  }); \\\n})\n\n#define raw_spin_trylock_irqsave(lock, flags) \\\n({ \\\n\tlocal_irq_save(flags); \\\n\traw_spin_trylock(lock) ? \\\n\t1 : ({ local_irq_restore(flags); 0; }); \\\n})\n\n/* Include rwlock functions */\n#include <linux/rwlock.h>\n\n/*\n * Pull the _spin_*()/_read_*()/_write_*() functions/declarations:\n */\n#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)\n# include <linux/spinlock_api_smp.h>\n#else\n# include <linux/spinlock_api_up.h>\n#endif\n\n/*\n * Map the spin_lock functions to the raw variants for PREEMPT_RT=n\n */\n\nstatic __always_inline raw_spinlock_t *spinlock_check(spinlock_t *lock)\n{\n\treturn &lock->rlock;\n}\n\n#ifdef CONFIG_DEBUG_SPINLOCK\n\n# define spin_lock_init(lock)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tstatic struct lock_class_key __key;\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t__raw_spin_lock_init(spinlock_check(lock),\t\t\\\n\t\t\t     #lock, &__key, LD_WAIT_CONFIG);\t\\\n} while (0)\n\n#else\n\n# define spin_lock_init(_lock)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n\tspinlock_check(_lock);\t\t\t\\\n\t*(_lock) = __SPIN_LOCK_UNLOCKED(_lock);\t\\\n} while (0)\n\n#endif\n\nstatic __always_inline void spin_lock(spinlock_t *lock)\n{\n\traw_spin_lock(&lock->rlock);\n}\n\nstatic __always_inline void spin_lock_bh(spinlock_t *lock)\n{\n\traw_spin_lock_bh(&lock->rlock);\n}\n\nstatic __always_inline int spin_trylock(spinlock_t *lock)\n{\n\treturn raw_spin_trylock(&lock->rlock);\n}\n\n#define spin_lock_nested(lock, subclass)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\traw_spin_lock_nested(spinlock_check(lock), subclass);\t\\\n} while (0)\n\n#define spin_lock_nest_lock(lock, nest_lock)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\traw_spin_lock_nest_lock(spinlock_check(lock), nest_lock);\t\\\n} while (0)\n\nstatic __always_inline void spin_lock_irq(spinlock_t *lock)\n{\n\traw_spin_lock_irq(&lock->rlock);\n}\n\n#define spin_lock_irqsave(lock, flags)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\traw_spin_lock_irqsave(spinlock_check(lock), flags);\t\\\n} while (0)\n\n#define spin_lock_irqsave_nested(lock, flags, subclass)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\traw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \\\n} while (0)\n\nstatic __always_inline void spin_unlock(spinlock_t *lock)\n{\n\traw_spin_unlock(&lock->rlock);\n}\n\nstatic __always_inline void spin_unlock_bh(spinlock_t *lock)\n{\n\traw_spin_unlock_bh(&lock->rlock);\n}\n\nstatic __always_inline void spin_unlock_irq(spinlock_t *lock)\n{\n\traw_spin_unlock_irq(&lock->rlock);\n}\n\nstatic __always_inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)\n{\n\traw_spin_unlock_irqrestore(&lock->rlock, flags);\n}\n\nstatic __always_inline int spin_trylock_bh(spinlock_t *lock)\n{\n\treturn raw_spin_trylock_bh(&lock->rlock);\n}\n\nstatic __always_inline int spin_trylock_irq(spinlock_t *lock)\n{\n\treturn raw_spin_trylock_irq(&lock->rlock);\n}\n\n#define spin_trylock_irqsave(lock, flags)\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\traw_spin_trylock_irqsave(spinlock_check(lock), flags); \\\n})\n\n/**\n * spin_is_locked() - Check whether a spinlock is locked.\n * @lock: Pointer to the spinlock.\n *\n * This function is NOT required to provide any memory ordering\n * guarantees; it could be used for debugging purposes or, when\n * additional synchronization is needed, accompanied with other\n * constructs (memory barriers) enforcing the synchronization.\n *\n * Returns: 1 if @lock is locked, 0 otherwise.\n *\n * Note that the function only tells you that the spinlock is\n * seen to be locked, not that it is locked on your CPU.\n *\n * Further, on CONFIG_SMP=n builds with CONFIG_DEBUG_SPINLOCK=n,\n * the return value is always 0 (see include/linux/spinlock_up.h).\n * Therefore you should not rely heavily on the return value.\n */\nstatic __always_inline int spin_is_locked(spinlock_t *lock)\n{\n\treturn raw_spin_is_locked(&lock->rlock);\n}\n\nstatic __always_inline int spin_is_contended(spinlock_t *lock)\n{\n\treturn raw_spin_is_contended(&lock->rlock);\n}\n\n#define assert_spin_locked(lock)\tassert_raw_spin_locked(&(lock)->rlock)\n\n/*\n * Pull the atomic_t declaration:\n * (asm-mips/atomic.h needs above definitions)\n */\n#include <linux/atomic.h>\n/**\n * atomic_dec_and_lock - lock on reaching reference count zero\n * @atomic: the atomic counter\n * @lock: the spinlock in question\n *\n * Decrements @atomic by 1.  If the result is 0, returns true and locks\n * @lock.  Returns false for all other cases.\n */\nextern int _atomic_dec_and_lock(atomic_t *atomic, spinlock_t *lock);\n#define atomic_dec_and_lock(atomic, lock) \\\n\t\t__cond_lock(lock, _atomic_dec_and_lock(atomic, lock))\n\nextern int _atomic_dec_and_lock_irqsave(atomic_t *atomic, spinlock_t *lock,\n\t\t\t\t\tunsigned long *flags);\n#define atomic_dec_and_lock_irqsave(atomic, lock, flags) \\\n\t\t__cond_lock(lock, _atomic_dec_and_lock_irqsave(atomic, lock, &(flags)))\n\nint __alloc_bucket_spinlocks(spinlock_t **locks, unsigned int *lock_mask,\n\t\t\t     size_t max_size, unsigned int cpu_mult,\n\t\t\t     gfp_t gfp, const char *name,\n\t\t\t     struct lock_class_key *key);\n\n#define alloc_bucket_spinlocks(locks, lock_mask, max_size, cpu_mult, gfp)    \\\n\t({\t\t\t\t\t\t\t\t     \\\n\t\tstatic struct lock_class_key key;\t\t\t     \\\n\t\tint ret;\t\t\t\t\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\t\tret = __alloc_bucket_spinlocks(locks, lock_mask, max_size,   \\\n\t\t\t\t\t       cpu_mult, gfp, #locks, &key); \\\n\t\tret;\t\t\t\t\t\t\t     \\\n\t})\n\nvoid free_bucket_spinlocks(spinlock_t *locks);\n\n#endif /* __LINUX_SPINLOCK_H */\n"}, "8": {"id": 8, "path": "/src/include/linux/wait.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_WAIT_H\n#define _LINUX_WAIT_H\n/*\n * Linux wait queue related types and methods\n */\n#include <linux/list.h>\n#include <linux/stddef.h>\n#include <linux/spinlock.h>\n\n#include <asm/current.h>\n#include <uapi/linux/wait.h>\n\ntypedef struct wait_queue_entry wait_queue_entry_t;\n\ntypedef int (*wait_queue_func_t)(struct wait_queue_entry *wq_entry, unsigned mode, int flags, void *key);\nint default_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int flags, void *key);\n\n/* wait_queue_entry::flags */\n#define WQ_FLAG_EXCLUSIVE\t0x01\n#define WQ_FLAG_WOKEN\t\t0x02\n#define WQ_FLAG_BOOKMARK\t0x04\n#define WQ_FLAG_CUSTOM\t\t0x08\n#define WQ_FLAG_DONE\t\t0x10\n#define WQ_FLAG_PRIORITY\t0x20\n\n/*\n * A single wait-queue entry structure:\n */\nstruct wait_queue_entry {\n\tunsigned int\t\tflags;\n\tvoid\t\t\t*private;\n\twait_queue_func_t\tfunc;\n\tstruct list_head\tentry;\n};\n\nstruct wait_queue_head {\n\tspinlock_t\t\tlock;\n\tstruct list_head\thead;\n};\ntypedef struct wait_queue_head wait_queue_head_t;\n\nstruct task_struct;\n\n/*\n * Macros for declaration and initialisaton of the datatypes\n */\n\n#define __WAITQUEUE_INITIALIZER(name, tsk) {\t\t\t\t\t\\\n\t.private\t= tsk,\t\t\t\t\t\t\t\\\n\t.func\t\t= default_wake_function,\t\t\t\t\\\n\t.entry\t\t= { NULL, NULL } }\n\n#define DECLARE_WAITQUEUE(name, tsk)\t\t\t\t\t\t\\\n\tstruct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk)\n\n#define __WAIT_QUEUE_HEAD_INITIALIZER(name) {\t\t\t\t\t\\\n\t.lock\t\t= __SPIN_LOCK_UNLOCKED(name.lock),\t\t\t\\\n\t.head\t\t= { &(name).head, &(name).head } }\n\n#define DECLARE_WAIT_QUEUE_HEAD(name) \\\n\tstruct wait_queue_head name = __WAIT_QUEUE_HEAD_INITIALIZER(name)\n\nextern void __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *);\n\n#define init_waitqueue_head(wq_head)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\\\n\t\tstatic struct lock_class_key __key;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\t__init_waitqueue_head((wq_head), #wq_head, &__key);\t\t\\\n\t} while (0)\n\n#ifdef CONFIG_LOCKDEP\n# define __WAIT_QUEUE_HEAD_INIT_ONSTACK(name) \\\n\t({ init_waitqueue_head(&name); name; })\n# define DECLARE_WAIT_QUEUE_HEAD_ONSTACK(name) \\\n\tstruct wait_queue_head name = __WAIT_QUEUE_HEAD_INIT_ONSTACK(name)\n#else\n# define DECLARE_WAIT_QUEUE_HEAD_ONSTACK(name) DECLARE_WAIT_QUEUE_HEAD(name)\n#endif\n\nstatic inline void init_waitqueue_entry(struct wait_queue_entry *wq_entry, struct task_struct *p)\n{\n\twq_entry->flags\t\t= 0;\n\twq_entry->private\t= p;\n\twq_entry->func\t\t= default_wake_function;\n}\n\nstatic inline void\ninit_waitqueue_func_entry(struct wait_queue_entry *wq_entry, wait_queue_func_t func)\n{\n\twq_entry->flags\t\t= 0;\n\twq_entry->private\t= NULL;\n\twq_entry->func\t\t= func;\n}\n\n/**\n * waitqueue_active -- locklessly test for waiters on the queue\n * @wq_head: the waitqueue to test for waiters\n *\n * returns true if the wait list is not empty\n *\n * NOTE: this function is lockless and requires care, incorrect usage _will_\n * lead to sporadic and non-obvious failure.\n *\n * Use either while holding wait_queue_head::lock or when used for wakeups\n * with an extra smp_mb() like::\n *\n *      CPU0 - waker                    CPU1 - waiter\n *\n *                                      for (;;) {\n *      @cond = true;                     prepare_to_wait(&wq_head, &wait, state);\n *      smp_mb();                         // smp_mb() from set_current_state()\n *      if (waitqueue_active(wq_head))         if (@cond)\n *        wake_up(wq_head);                      break;\n *                                        schedule();\n *                                      }\n *                                      finish_wait(&wq_head, &wait);\n *\n * Because without the explicit smp_mb() it's possible for the\n * waitqueue_active() load to get hoisted over the @cond store such that we'll\n * observe an empty wait list while the waiter might not observe @cond.\n *\n * Also note that this 'optimization' trades a spin_lock() for an smp_mb(),\n * which (when the lock is uncontended) are of roughly equal cost.\n */\nstatic inline int waitqueue_active(struct wait_queue_head *wq_head)\n{\n\treturn !list_empty(&wq_head->head);\n}\n\n/**\n * wq_has_single_sleeper - check if there is only one sleeper\n * @wq_head: wait queue head\n *\n * Returns true of wq_head has only one sleeper on the list.\n *\n * Please refer to the comment for waitqueue_active.\n */\nstatic inline bool wq_has_single_sleeper(struct wait_queue_head *wq_head)\n{\n\treturn list_is_singular(&wq_head->head);\n}\n\n/**\n * wq_has_sleeper - check if there are any waiting processes\n * @wq_head: wait queue head\n *\n * Returns true if wq_head has waiting processes\n *\n * Please refer to the comment for waitqueue_active.\n */\nstatic inline bool wq_has_sleeper(struct wait_queue_head *wq_head)\n{\n\t/*\n\t * We need to be sure we are in sync with the\n\t * add_wait_queue modifications to the wait queue.\n\t *\n\t * This memory barrier should be paired with one on the\n\t * waiting side.\n\t */\n\tsmp_mb();\n\treturn waitqueue_active(wq_head);\n}\n\nextern void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);\nextern void add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);\nextern void add_wait_queue_priority(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);\nextern void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);\n\nstatic inline void __add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tstruct list_head *head = &wq_head->head;\n\tstruct wait_queue_entry *wq;\n\n\tlist_for_each_entry(wq, &wq_head->head, entry) {\n\t\tif (!(wq->flags & WQ_FLAG_PRIORITY))\n\t\t\tbreak;\n\t\thead = &wq->entry;\n\t}\n\tlist_add(&wq_entry->entry, head);\n}\n\n/*\n * Used for wake-one threads:\n */\nstatic inline void\n__add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\t__add_wait_queue(wq_head, wq_entry);\n}\n\nstatic inline void __add_wait_queue_entry_tail(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tlist_add_tail(&wq_entry->entry, &wq_head->head);\n}\n\nstatic inline void\n__add_wait_queue_entry_tail_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n}\n\nstatic inline void\n__remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tlist_del(&wq_entry->entry);\n}\n\nvoid __wake_up(struct wait_queue_head *wq_head, unsigned int mode, int nr, void *key);\nvoid __wake_up_locked_key(struct wait_queue_head *wq_head, unsigned int mode, void *key);\nvoid __wake_up_locked_key_bookmark(struct wait_queue_head *wq_head,\n\t\tunsigned int mode, void *key, wait_queue_entry_t *bookmark);\nvoid __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode, void *key);\nvoid __wake_up_locked_sync_key(struct wait_queue_head *wq_head, unsigned int mode, void *key);\nvoid __wake_up_locked(struct wait_queue_head *wq_head, unsigned int mode, int nr);\nvoid __wake_up_sync(struct wait_queue_head *wq_head, unsigned int mode);\n\n#define wake_up(x)\t\t\t__wake_up(x, TASK_NORMAL, 1, NULL)\n#define wake_up_nr(x, nr)\t\t__wake_up(x, TASK_NORMAL, nr, NULL)\n#define wake_up_all(x)\t\t\t__wake_up(x, TASK_NORMAL, 0, NULL)\n#define wake_up_locked(x)\t\t__wake_up_locked((x), TASK_NORMAL, 1)\n#define wake_up_all_locked(x)\t\t__wake_up_locked((x), TASK_NORMAL, 0)\n\n#define wake_up_interruptible(x)\t__wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)\n#define wake_up_interruptible_nr(x, nr)\t__wake_up(x, TASK_INTERRUPTIBLE, nr, NULL)\n#define wake_up_interruptible_all(x)\t__wake_up(x, TASK_INTERRUPTIBLE, 0, NULL)\n#define wake_up_interruptible_sync(x)\t__wake_up_sync((x), TASK_INTERRUPTIBLE)\n\n/*\n * Wakeup macros to be used to report events to the targets.\n */\n#define poll_to_key(m) ((void *)(__force uintptr_t)(__poll_t)(m))\n#define key_to_poll(m) ((__force __poll_t)(uintptr_t)(void *)(m))\n#define wake_up_poll(x, m)\t\t\t\t\t\t\t\\\n\t__wake_up(x, TASK_NORMAL, 1, poll_to_key(m))\n#define wake_up_locked_poll(x, m)\t\t\t\t\t\t\\\n\t__wake_up_locked_key((x), TASK_NORMAL, poll_to_key(m))\n#define wake_up_interruptible_poll(x, m)\t\t\t\t\t\\\n\t__wake_up(x, TASK_INTERRUPTIBLE, 1, poll_to_key(m))\n#define wake_up_interruptible_sync_poll(x, m)\t\t\t\t\t\\\n\t__wake_up_sync_key((x), TASK_INTERRUPTIBLE, poll_to_key(m))\n#define wake_up_interruptible_sync_poll_locked(x, m)\t\t\t\t\\\n\t__wake_up_locked_sync_key((x), TASK_INTERRUPTIBLE, poll_to_key(m))\n\n#define ___wait_cond_timeout(condition)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tbool __cond = (condition);\t\t\t\t\t\t\\\n\tif (__cond && !__ret)\t\t\t\t\t\t\t\\\n\t\t__ret = 1;\t\t\t\t\t\t\t\\\n\t__cond || !__ret;\t\t\t\t\t\t\t\\\n})\n\n#define ___wait_is_interruptible(state)\t\t\t\t\t\t\\\n\t(!__builtin_constant_p(state) ||\t\t\t\t\t\\\n\t\tstate == TASK_INTERRUPTIBLE || state == TASK_KILLABLE)\t\t\\\n\nextern void init_wait_entry(struct wait_queue_entry *wq_entry, int flags);\n\n/*\n * The below macro ___wait_event() has an explicit shadow of the __ret\n * variable when used from the wait_event_*() macros.\n *\n * This is so that both can use the ___wait_cond_timeout() construct\n * to wrap the condition.\n *\n * The type inconsistency of the wait_event_*() __ret variable is also\n * on purpose; we use long where we can return timeout values and int\n * otherwise.\n */\n\n#define ___wait_event(wq_head, condition, state, exclusive, ret, cmd)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\t__label__ __out;\t\t\t\t\t\t\t\\\n\tstruct wait_queue_entry __wq_entry;\t\t\t\t\t\\\n\tlong __ret = ret;\t/* explicit shadow */\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tinit_wait_entry(&__wq_entry, exclusive ? WQ_FLAG_EXCLUSIVE : 0);\t\\\n\tfor (;;) {\t\t\t\t\t\t\t\t\\\n\t\tlong __int = prepare_to_wait_event(&wq_head, &__wq_entry, state);\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (condition)\t\t\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (___wait_is_interruptible(state) && __int) {\t\t\t\\\n\t\t\t__ret = __int;\t\t\t\t\t\t\\\n\t\t\tgoto __out;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\tcmd;\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\tfinish_wait(&wq_head, &__wq_entry);\t\t\t\t\t\\\n__out:\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event(wq_head, condition)\t\t\t\t\t\\\n\t(void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0,\t\\\n\t\t\t    schedule())\n\n/**\n * wait_event - sleep until a condition gets true\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n *\n * The process is put to sleep (TASK_UNINTERRUPTIBLE) until the\n * @condition evaluates to true. The @condition is checked each time\n * the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n */\n#define wait_event(wq_head, condition)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (condition)\t\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\\\n\t__wait_event(wq_head, condition);\t\t\t\t\t\\\n} while (0)\n\n#define __io_wait_event(wq_head, condition)\t\t\t\t\t\\\n\t(void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0,\t\\\n\t\t\t    io_schedule())\n\n/*\n * io_wait_event() -- like wait_event() but with io_schedule()\n */\n#define io_wait_event(wq_head, condition)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (condition)\t\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\\\n\t__io_wait_event(wq_head, condition);\t\t\t\t\t\\\n} while (0)\n\n#define __wait_event_freezable(wq_head, condition)\t\t\t\t\\\n\t___wait_event(wq_head, condition, TASK_INTERRUPTIBLE, 0, 0,\t\t\\\n\t\t\t    freezable_schedule())\n\n/**\n * wait_event_freezable - sleep (or freeze) until a condition gets true\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n *\n * The process is put to sleep (TASK_INTERRUPTIBLE -- so as not to contribute\n * to system load) until the @condition evaluates to true. The\n * @condition is checked each time the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n */\n#define wait_event_freezable(wq_head, condition)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_freezable(wq_head, condition);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_timeout(wq_head, condition, timeout)\t\t\t\\\n\t___wait_event(wq_head, ___wait_cond_timeout(condition),\t\t\t\\\n\t\t      TASK_UNINTERRUPTIBLE, 0, timeout,\t\t\t\t\\\n\t\t      __ret = schedule_timeout(__ret))\n\n/**\n * wait_event_timeout - sleep until a condition gets true or a timeout elapses\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n * @timeout: timeout, in jiffies\n *\n * The process is put to sleep (TASK_UNINTERRUPTIBLE) until the\n * @condition evaluates to true. The @condition is checked each time\n * the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * Returns:\n * 0 if the @condition evaluated to %false after the @timeout elapsed,\n * 1 if the @condition evaluated to %true after the @timeout elapsed,\n * or the remaining jiffies (at least 1) if the @condition evaluated\n * to %true before the @timeout elapsed.\n */\n#define wait_event_timeout(wq_head, condition, timeout)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\t\\\n\t\t__ret = __wait_event_timeout(wq_head, condition, timeout);\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_freezable_timeout(wq_head, condition, timeout)\t\t\\\n\t___wait_event(wq_head, ___wait_cond_timeout(condition),\t\t\t\\\n\t\t      TASK_INTERRUPTIBLE, 0, timeout,\t\t\t\t\\\n\t\t      __ret = freezable_schedule_timeout(__ret))\n\n/*\n * like wait_event_timeout() -- except it uses TASK_INTERRUPTIBLE to avoid\n * increasing load and is freezable.\n */\n#define wait_event_freezable_timeout(wq_head, condition, timeout)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\t\\\n\t\t__ret = __wait_event_freezable_timeout(wq_head, condition, timeout); \\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_exclusive_cmd(wq_head, condition, cmd1, cmd2)\t\t\\\n\t(void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 1, 0,\t\\\n\t\t\t    cmd1; schedule(); cmd2)\n/*\n * Just like wait_event_cmd(), except it sets exclusive flag\n */\n#define wait_event_exclusive_cmd(wq_head, condition, cmd1, cmd2)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tif (condition)\t\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\\\n\t__wait_event_exclusive_cmd(wq_head, condition, cmd1, cmd2);\t\t\\\n} while (0)\n\n#define __wait_event_cmd(wq_head, condition, cmd1, cmd2)\t\t\t\\\n\t(void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0,\t\\\n\t\t\t    cmd1; schedule(); cmd2)\n\n/**\n * wait_event_cmd - sleep until a condition gets true\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n * @cmd1: the command will be executed before sleep\n * @cmd2: the command will be executed after sleep\n *\n * The process is put to sleep (TASK_UNINTERRUPTIBLE) until the\n * @condition evaluates to true. The @condition is checked each time\n * the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n */\n#define wait_event_cmd(wq_head, condition, cmd1, cmd2)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tif (condition)\t\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\\\n\t__wait_event_cmd(wq_head, condition, cmd1, cmd2);\t\t\t\\\n} while (0)\n\n#define __wait_event_interruptible(wq_head, condition)\t\t\t\t\\\n\t___wait_event(wq_head, condition, TASK_INTERRUPTIBLE, 0, 0,\t\t\\\n\t\t      schedule())\n\n/**\n * wait_event_interruptible - sleep until a condition gets true\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n *\n * The process is put to sleep (TASK_INTERRUPTIBLE) until the\n * @condition evaluates to true or a signal is received.\n * The @condition is checked each time the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * The function will return -ERESTARTSYS if it was interrupted by a\n * signal and 0 if @condition evaluated to true.\n */\n#define wait_event_interruptible(wq_head, condition)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_interruptible(wq_head, condition);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_interruptible_timeout(wq_head, condition, timeout)\t\t\\\n\t___wait_event(wq_head, ___wait_cond_timeout(condition),\t\t\t\\\n\t\t      TASK_INTERRUPTIBLE, 0, timeout,\t\t\t\t\\\n\t\t      __ret = schedule_timeout(__ret))\n\n/**\n * wait_event_interruptible_timeout - sleep until a condition gets true or a timeout elapses\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n * @timeout: timeout, in jiffies\n *\n * The process is put to sleep (TASK_INTERRUPTIBLE) until the\n * @condition evaluates to true or a signal is received.\n * The @condition is checked each time the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * Returns:\n * 0 if the @condition evaluated to %false after the @timeout elapsed,\n * 1 if the @condition evaluated to %true after the @timeout elapsed,\n * the remaining jiffies (at least 1) if the @condition evaluated\n * to %true before the @timeout elapsed, or -%ERESTARTSYS if it was\n * interrupted by a signal.\n */\n#define wait_event_interruptible_timeout(wq_head, condition, timeout)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\t\\\n\t\t__ret = __wait_event_interruptible_timeout(wq_head,\t\t\\\n\t\t\t\t\t\tcondition, timeout);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_hrtimeout(wq_head, condition, timeout, state)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tstruct hrtimer_sleeper __t;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\thrtimer_init_sleeper_on_stack(&__t, CLOCK_MONOTONIC,\t\t\t\\\n\t\t\t\t      HRTIMER_MODE_REL);\t\t\t\\\n\tif ((timeout) != KTIME_MAX)\t\t\t\t\t\t\\\n\t\thrtimer_start_range_ns(&__t.timer, timeout,\t\t\t\\\n\t\t\t\t       current->timer_slack_ns,\t\t\t\\\n\t\t\t\t       HRTIMER_MODE_REL);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t__ret = ___wait_event(wq_head, condition, state, 0, 0,\t\t\t\\\n\t\tif (!__t.task) {\t\t\t\t\t\t\\\n\t\t\t__ret = -ETIME;\t\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\t\tschedule());\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\thrtimer_cancel(&__t.timer);\t\t\t\t\t\t\\\n\tdestroy_hrtimer_on_stack(&__t.timer);\t\t\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n/**\n * wait_event_hrtimeout - sleep until a condition gets true or a timeout elapses\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n * @timeout: timeout, as a ktime_t\n *\n * The process is put to sleep (TASK_UNINTERRUPTIBLE) until the\n * @condition evaluates to true or a signal is received.\n * The @condition is checked each time the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * The function returns 0 if @condition became true, or -ETIME if the timeout\n * elapsed.\n */\n#define wait_event_hrtimeout(wq_head, condition, timeout)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition) && (timeout))\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_hrtimeout(wq_head, condition, timeout,\t\\\n\t\t\t\t\t       TASK_UNINTERRUPTIBLE);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n/**\n * wait_event_interruptible_hrtimeout - sleep until a condition gets true or a timeout elapses\n * @wq: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n * @timeout: timeout, as a ktime_t\n *\n * The process is put to sleep (TASK_INTERRUPTIBLE) until the\n * @condition evaluates to true or a signal is received.\n * The @condition is checked each time the waitqueue @wq is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * The function returns 0 if @condition became true, -ERESTARTSYS if it was\n * interrupted by a signal, or -ETIME if the timeout elapsed.\n */\n#define wait_event_interruptible_hrtimeout(wq, condition, timeout)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = 0;\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition) && (timeout))\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_hrtimeout(wq, condition, timeout,\t\t\\\n\t\t\t\t\t       TASK_INTERRUPTIBLE);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_interruptible_exclusive(wq, condition)\t\t\t\\\n\t___wait_event(wq, condition, TASK_INTERRUPTIBLE, 1, 0,\t\t\t\\\n\t\t      schedule())\n\n#define wait_event_interruptible_exclusive(wq, condition)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_interruptible_exclusive(wq, condition);\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_killable_exclusive(wq, condition)\t\t\t\t\\\n\t___wait_event(wq, condition, TASK_KILLABLE, 1, 0,\t\t\t\\\n\t\t      schedule())\n\n#define wait_event_killable_exclusive(wq, condition)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_killable_exclusive(wq, condition);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n\n#define __wait_event_freezable_exclusive(wq, condition)\t\t\t\t\\\n\t___wait_event(wq, condition, TASK_INTERRUPTIBLE, 1, 0,\t\t\t\\\n\t\t\tfreezable_schedule())\n\n#define wait_event_freezable_exclusive(wq, condition)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_freezable_exclusive(wq, condition);\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n/**\n * wait_event_idle - wait for a condition without contributing to system load\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n *\n * The process is put to sleep (TASK_IDLE) until the\n * @condition evaluates to true.\n * The @condition is checked each time the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n */\n#define wait_event_idle(wq_head, condition)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t___wait_event(wq_head, condition, TASK_IDLE, 0, 0, schedule());\t\\\n} while (0)\n\n/**\n * wait_event_idle_exclusive - wait for a condition with contributing to system load\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n *\n * The process is put to sleep (TASK_IDLE) until the\n * @condition evaluates to true.\n * The @condition is checked each time the waitqueue @wq_head is woken up.\n *\n * The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag\n * set thus if other processes wait on the same list, when this\n * process is woken further processes are not considered.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n */\n#define wait_event_idle_exclusive(wq_head, condition)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t___wait_event(wq_head, condition, TASK_IDLE, 1, 0, schedule());\t\\\n} while (0)\n\n#define __wait_event_idle_timeout(wq_head, condition, timeout)\t\t\t\\\n\t___wait_event(wq_head, ___wait_cond_timeout(condition),\t\t\t\\\n\t\t      TASK_IDLE, 0, timeout,\t\t\t\t\t\\\n\t\t      __ret = schedule_timeout(__ret))\n\n/**\n * wait_event_idle_timeout - sleep without load until a condition becomes true or a timeout elapses\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n * @timeout: timeout, in jiffies\n *\n * The process is put to sleep (TASK_IDLE) until the\n * @condition evaluates to true. The @condition is checked each time\n * the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * Returns:\n * 0 if the @condition evaluated to %false after the @timeout elapsed,\n * 1 if the @condition evaluated to %true after the @timeout elapsed,\n * or the remaining jiffies (at least 1) if the @condition evaluated\n * to %true before the @timeout elapsed.\n */\n#define wait_event_idle_timeout(wq_head, condition, timeout)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\t\\\n\t\t__ret = __wait_event_idle_timeout(wq_head, condition, timeout);\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_idle_exclusive_timeout(wq_head, condition, timeout)\t\\\n\t___wait_event(wq_head, ___wait_cond_timeout(condition),\t\t\t\\\n\t\t      TASK_IDLE, 1, timeout,\t\t\t\t\t\\\n\t\t      __ret = schedule_timeout(__ret))\n\n/**\n * wait_event_idle_exclusive_timeout - sleep without load until a condition becomes true or a timeout elapses\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n * @timeout: timeout, in jiffies\n *\n * The process is put to sleep (TASK_IDLE) until the\n * @condition evaluates to true. The @condition is checked each time\n * the waitqueue @wq_head is woken up.\n *\n * The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag\n * set thus if other processes wait on the same list, when this\n * process is woken further processes are not considered.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * Returns:\n * 0 if the @condition evaluated to %false after the @timeout elapsed,\n * 1 if the @condition evaluated to %true after the @timeout elapsed,\n * or the remaining jiffies (at least 1) if the @condition evaluated\n * to %true before the @timeout elapsed.\n */\n#define wait_event_idle_exclusive_timeout(wq_head, condition, timeout)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\t\\\n\t\t__ret = __wait_event_idle_exclusive_timeout(wq_head, condition, timeout);\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\nextern int do_wait_intr(wait_queue_head_t *, wait_queue_entry_t *);\nextern int do_wait_intr_irq(wait_queue_head_t *, wait_queue_entry_t *);\n\n#define __wait_event_interruptible_locked(wq, condition, exclusive, fn)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret;\t\t\t\t\t\t\t\t\\\n\tDEFINE_WAIT(__wait);\t\t\t\t\t\t\t\\\n\tif (exclusive)\t\t\t\t\t\t\t\t\\\n\t\t__wait.flags |= WQ_FLAG_EXCLUSIVE;\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\\\n\t\t__ret = fn(&(wq), &__wait);\t\t\t\t\t\\\n\t\tif (__ret)\t\t\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\t\\\n\t} while (!(condition));\t\t\t\t\t\t\t\\\n\t__remove_wait_queue(&(wq), &__wait);\t\t\t\t\t\\\n\t__set_current_state(TASK_RUNNING);\t\t\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n\n/**\n * wait_event_interruptible_locked - sleep until a condition gets true\n * @wq: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n *\n * The process is put to sleep (TASK_INTERRUPTIBLE) until the\n * @condition evaluates to true or a signal is received.\n * The @condition is checked each time the waitqueue @wq is woken up.\n *\n * It must be called with wq.lock being held.  This spinlock is\n * unlocked while sleeping but @condition testing is done while lock\n * is held and when this macro exits the lock is held.\n *\n * The lock is locked/unlocked using spin_lock()/spin_unlock()\n * functions which must match the way they are locked/unlocked outside\n * of this macro.\n *\n * wake_up_locked() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * The function will return -ERESTARTSYS if it was interrupted by a\n * signal and 0 if @condition evaluated to true.\n */\n#define wait_event_interruptible_locked(wq, condition)\t\t\t\t\\\n\t((condition)\t\t\t\t\t\t\t\t\\\n\t ? 0 : __wait_event_interruptible_locked(wq, condition, 0, do_wait_intr))\n\n/**\n * wait_event_interruptible_locked_irq - sleep until a condition gets true\n * @wq: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n *\n * The process is put to sleep (TASK_INTERRUPTIBLE) until the\n * @condition evaluates to true or a signal is received.\n * The @condition is checked each time the waitqueue @wq is woken up.\n *\n * It must be called with wq.lock being held.  This spinlock is\n * unlocked while sleeping but @condition testing is done while lock\n * is held and when this macro exits the lock is held.\n *\n * The lock is locked/unlocked using spin_lock_irq()/spin_unlock_irq()\n * functions which must match the way they are locked/unlocked outside\n * of this macro.\n *\n * wake_up_locked() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * The function will return -ERESTARTSYS if it was interrupted by a\n * signal and 0 if @condition evaluated to true.\n */\n#define wait_event_interruptible_locked_irq(wq, condition)\t\t\t\\\n\t((condition)\t\t\t\t\t\t\t\t\\\n\t ? 0 : __wait_event_interruptible_locked(wq, condition, 0, do_wait_intr_irq))\n\n/**\n * wait_event_interruptible_exclusive_locked - sleep exclusively until a condition gets true\n * @wq: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n *\n * The process is put to sleep (TASK_INTERRUPTIBLE) until the\n * @condition evaluates to true or a signal is received.\n * The @condition is checked each time the waitqueue @wq is woken up.\n *\n * It must be called with wq.lock being held.  This spinlock is\n * unlocked while sleeping but @condition testing is done while lock\n * is held and when this macro exits the lock is held.\n *\n * The lock is locked/unlocked using spin_lock()/spin_unlock()\n * functions which must match the way they are locked/unlocked outside\n * of this macro.\n *\n * The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag\n * set thus when other process waits process on the list if this\n * process is awaken further processes are not considered.\n *\n * wake_up_locked() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * The function will return -ERESTARTSYS if it was interrupted by a\n * signal and 0 if @condition evaluated to true.\n */\n#define wait_event_interruptible_exclusive_locked(wq, condition)\t\t\\\n\t((condition)\t\t\t\t\t\t\t\t\\\n\t ? 0 : __wait_event_interruptible_locked(wq, condition, 1, do_wait_intr))\n\n/**\n * wait_event_interruptible_exclusive_locked_irq - sleep until a condition gets true\n * @wq: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n *\n * The process is put to sleep (TASK_INTERRUPTIBLE) until the\n * @condition evaluates to true or a signal is received.\n * The @condition is checked each time the waitqueue @wq is woken up.\n *\n * It must be called with wq.lock being held.  This spinlock is\n * unlocked while sleeping but @condition testing is done while lock\n * is held and when this macro exits the lock is held.\n *\n * The lock is locked/unlocked using spin_lock_irq()/spin_unlock_irq()\n * functions which must match the way they are locked/unlocked outside\n * of this macro.\n *\n * The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag\n * set thus when other process waits process on the list if this\n * process is awaken further processes are not considered.\n *\n * wake_up_locked() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * The function will return -ERESTARTSYS if it was interrupted by a\n * signal and 0 if @condition evaluated to true.\n */\n#define wait_event_interruptible_exclusive_locked_irq(wq, condition)\t\t\\\n\t((condition)\t\t\t\t\t\t\t\t\\\n\t ? 0 : __wait_event_interruptible_locked(wq, condition, 1, do_wait_intr_irq))\n\n\n#define __wait_event_killable(wq, condition)\t\t\t\t\t\\\n\t___wait_event(wq, condition, TASK_KILLABLE, 0, 0, schedule())\n\n/**\n * wait_event_killable - sleep until a condition gets true\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n *\n * The process is put to sleep (TASK_KILLABLE) until the\n * @condition evaluates to true or a signal is received.\n * The @condition is checked each time the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * The function will return -ERESTARTSYS if it was interrupted by a\n * signal and 0 if @condition evaluated to true.\n */\n#define wait_event_killable(wq_head, condition)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_killable(wq_head, condition);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_killable_timeout(wq_head, condition, timeout)\t\t\\\n\t___wait_event(wq_head, ___wait_cond_timeout(condition),\t\t\t\\\n\t\t      TASK_KILLABLE, 0, timeout,\t\t\t\t\\\n\t\t      __ret = schedule_timeout(__ret))\n\n/**\n * wait_event_killable_timeout - sleep until a condition gets true or a timeout elapses\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n * @timeout: timeout, in jiffies\n *\n * The process is put to sleep (TASK_KILLABLE) until the\n * @condition evaluates to true or a kill signal is received.\n * The @condition is checked each time the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * Returns:\n * 0 if the @condition evaluated to %false after the @timeout elapsed,\n * 1 if the @condition evaluated to %true after the @timeout elapsed,\n * the remaining jiffies (at least 1) if the @condition evaluated\n * to %true before the @timeout elapsed, or -%ERESTARTSYS if it was\n * interrupted by a kill signal.\n *\n * Only kill signals interrupt this process.\n */\n#define wait_event_killable_timeout(wq_head, condition, timeout)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\t\\\n\t\t__ret = __wait_event_killable_timeout(wq_head,\t\t\t\\\n\t\t\t\t\t\tcondition, timeout);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n\n#define __wait_event_lock_irq(wq_head, condition, lock, cmd)\t\t\t\\\n\t(void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0,\t\\\n\t\t\t    spin_unlock_irq(&lock);\t\t\t\t\\\n\t\t\t    cmd;\t\t\t\t\t\t\\\n\t\t\t    schedule();\t\t\t\t\t\t\\\n\t\t\t    spin_lock_irq(&lock))\n\n/**\n * wait_event_lock_irq_cmd - sleep until a condition gets true. The\n *\t\t\t     condition is checked under the lock. This\n *\t\t\t     is expected to be called with the lock\n *\t\t\t     taken.\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n * @lock: a locked spinlock_t, which will be released before cmd\n *\t  and schedule() and reacquired afterwards.\n * @cmd: a command which is invoked outside the critical section before\n *\t sleep\n *\n * The process is put to sleep (TASK_UNINTERRUPTIBLE) until the\n * @condition evaluates to true. The @condition is checked each time\n * the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * This is supposed to be called while holding the lock. The lock is\n * dropped before invoking the cmd and going to sleep and is reacquired\n * afterwards.\n */\n#define wait_event_lock_irq_cmd(wq_head, condition, lock, cmd)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tif (condition)\t\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\\\n\t__wait_event_lock_irq(wq_head, condition, lock, cmd);\t\t\t\\\n} while (0)\n\n/**\n * wait_event_lock_irq - sleep until a condition gets true. The\n *\t\t\t condition is checked under the lock. This\n *\t\t\t is expected to be called with the lock\n *\t\t\t taken.\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n * @lock: a locked spinlock_t, which will be released before schedule()\n *\t  and reacquired afterwards.\n *\n * The process is put to sleep (TASK_UNINTERRUPTIBLE) until the\n * @condition evaluates to true. The @condition is checked each time\n * the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * This is supposed to be called while holding the lock. The lock is\n * dropped before going to sleep and is reacquired afterwards.\n */\n#define wait_event_lock_irq(wq_head, condition, lock)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tif (condition)\t\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\\\n\t__wait_event_lock_irq(wq_head, condition, lock, );\t\t\t\\\n} while (0)\n\n\n#define __wait_event_interruptible_lock_irq(wq_head, condition, lock, cmd)\t\\\n\t___wait_event(wq_head, condition, TASK_INTERRUPTIBLE, 0, 0,\t\t\\\n\t\t      spin_unlock_irq(&lock);\t\t\t\t\t\\\n\t\t      cmd;\t\t\t\t\t\t\t\\\n\t\t      schedule();\t\t\t\t\t\t\\\n\t\t      spin_lock_irq(&lock))\n\n/**\n * wait_event_interruptible_lock_irq_cmd - sleep until a condition gets true.\n *\t\tThe condition is checked under the lock. This is expected to\n *\t\tbe called with the lock taken.\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n * @lock: a locked spinlock_t, which will be released before cmd and\n *\t  schedule() and reacquired afterwards.\n * @cmd: a command which is invoked outside the critical section before\n *\t sleep\n *\n * The process is put to sleep (TASK_INTERRUPTIBLE) until the\n * @condition evaluates to true or a signal is received. The @condition is\n * checked each time the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * This is supposed to be called while holding the lock. The lock is\n * dropped before invoking the cmd and going to sleep and is reacquired\n * afterwards.\n *\n * The macro will return -ERESTARTSYS if it was interrupted by a signal\n * and 0 if @condition evaluated to true.\n */\n#define wait_event_interruptible_lock_irq_cmd(wq_head, condition, lock, cmd)\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_interruptible_lock_irq(wq_head,\t\t\\\n\t\t\t\t\t\tcondition, lock, cmd);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n/**\n * wait_event_interruptible_lock_irq - sleep until a condition gets true.\n *\t\tThe condition is checked under the lock. This is expected\n *\t\tto be called with the lock taken.\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n * @lock: a locked spinlock_t, which will be released before schedule()\n *\t  and reacquired afterwards.\n *\n * The process is put to sleep (TASK_INTERRUPTIBLE) until the\n * @condition evaluates to true or signal is received. The @condition is\n * checked each time the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * This is supposed to be called while holding the lock. The lock is\n * dropped before going to sleep and is reacquired afterwards.\n *\n * The macro will return -ERESTARTSYS if it was interrupted by a signal\n * and 0 if @condition evaluated to true.\n */\n#define wait_event_interruptible_lock_irq(wq_head, condition, lock)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_interruptible_lock_irq(wq_head,\t\t\\\n\t\t\t\t\t\tcondition, lock,);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_lock_irq_timeout(wq_head, condition, lock, timeout, state)\t\\\n\t___wait_event(wq_head, ___wait_cond_timeout(condition),\t\t\t\\\n\t\t      state, 0, timeout,\t\t\t\t\t\\\n\t\t      spin_unlock_irq(&lock);\t\t\t\t\t\\\n\t\t      __ret = schedule_timeout(__ret);\t\t\t\t\\\n\t\t      spin_lock_irq(&lock));\n\n/**\n * wait_event_interruptible_lock_irq_timeout - sleep until a condition gets\n *\t\ttrue or a timeout elapses. The condition is checked under\n *\t\tthe lock. This is expected to be called with the lock taken.\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n * @lock: a locked spinlock_t, which will be released before schedule()\n *\t  and reacquired afterwards.\n * @timeout: timeout, in jiffies\n *\n * The process is put to sleep (TASK_INTERRUPTIBLE) until the\n * @condition evaluates to true or signal is received. The @condition is\n * checked each time the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * This is supposed to be called while holding the lock. The lock is\n * dropped before going to sleep and is reacquired afterwards.\n *\n * The function returns 0 if the @timeout elapsed, -ERESTARTSYS if it\n * was interrupted by a signal, and the remaining jiffies otherwise\n * if the condition evaluated to true before the timeout elapsed.\n */\n#define wait_event_interruptible_lock_irq_timeout(wq_head, condition, lock,\t\\\n\t\t\t\t\t\t  timeout)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\t\\\n\t\t__ret = __wait_event_lock_irq_timeout(\t\t\t\t\\\n\t\t\t\t\twq_head, condition, lock, timeout,\t\\\n\t\t\t\t\tTASK_INTERRUPTIBLE);\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define wait_event_lock_irq_timeout(wq_head, condition, lock, timeout)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\t\\\n\t\t__ret = __wait_event_lock_irq_timeout(\t\t\t\t\\\n\t\t\t\t\twq_head, condition, lock, timeout,\t\\\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n/*\n * Waitqueues which are removed from the waitqueue_head at wakeup time\n */\nvoid prepare_to_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);\nvoid prepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);\nlong prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);\nvoid finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);\nlong wait_woken(struct wait_queue_entry *wq_entry, unsigned mode, long timeout);\nint woken_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key);\nint autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key);\n\n#define DEFINE_WAIT_FUNC(name, function)\t\t\t\t\t\\\n\tstruct wait_queue_entry name = {\t\t\t\t\t\\\n\t\t.private\t= current,\t\t\t\t\t\\\n\t\t.func\t\t= function,\t\t\t\t\t\\\n\t\t.entry\t\t= LIST_HEAD_INIT((name).entry),\t\t\t\\\n\t}\n\n#define DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)\n\n#define init_wait(wait)\t\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\\\n\t\t(wait)->private = current;\t\t\t\t\t\\\n\t\t(wait)->func = autoremove_wake_function;\t\t\t\\\n\t\tINIT_LIST_HEAD(&(wait)->entry);\t\t\t\t\t\\\n\t\t(wait)->flags = 0;\t\t\t\t\t\t\\\n\t} while (0)\n\nbool try_invoke_on_locked_down_task(struct task_struct *p, bool (*func)(struct task_struct *t, void *arg), void *arg);\n\n#endif /* _LINUX_WAIT_H */\n"}, "9": {"id": 9, "path": "/src/include/linux/minmax.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_MINMAX_H\n#define _LINUX_MINMAX_H\n\n/*\n * min()/max()/clamp() macros must accomplish three things:\n *\n * - avoid multiple evaluations of the arguments (so side-effects like\n *   \"x++\" happen only once) when non-constant.\n * - perform strict type-checking (to generate warnings instead of\n *   nasty runtime surprises). See the \"unnecessary\" pointer comparison\n *   in __typecheck().\n * - retain result as a constant expressions when called with only\n *   constant expressions (to avoid tripping VLA warnings in stack\n *   allocation usage).\n */\n#define __typecheck(x, y) \\\n\t(!!(sizeof((typeof(x) *)1 == (typeof(y) *)1)))\n\n/*\n * This returns a constant expression while determining if an argument is\n * a constant expression, most importantly without evaluating the argument.\n * Glory to Martin Uecker <Martin.Uecker@med.uni-goettingen.de>\n */\n#define __is_constexpr(x) \\\n\t(sizeof(int) == sizeof(*(8 ? ((void *)((long)(x) * 0l)) : (int *)8)))\n\n#define __no_side_effects(x, y) \\\n\t\t(__is_constexpr(x) && __is_constexpr(y))\n\n#define __safe_cmp(x, y) \\\n\t\t(__typecheck(x, y) && __no_side_effects(x, y))\n\n#define __cmp(x, y, op)\t((x) op (y) ? (x) : (y))\n\n#define __cmp_once(x, y, unique_x, unique_y, op) ({\t\\\n\t\ttypeof(x) unique_x = (x);\t\t\\\n\t\ttypeof(y) unique_y = (y);\t\t\\\n\t\t__cmp(unique_x, unique_y, op); })\n\n#define __careful_cmp(x, y, op) \\\n\t__builtin_choose_expr(__safe_cmp(x, y), \\\n\t\t__cmp(x, y, op), \\\n\t\t__cmp_once(x, y, __UNIQUE_ID(__x), __UNIQUE_ID(__y), op))\n\n/**\n * min - return minimum of two values of the same or compatible types\n * @x: first value\n * @y: second value\n */\n#define min(x, y)\t__careful_cmp(x, y, <)\n\n/**\n * max - return maximum of two values of the same or compatible types\n * @x: first value\n * @y: second value\n */\n#define max(x, y)\t__careful_cmp(x, y, >)\n\n/**\n * min3 - return minimum of three values\n * @x: first value\n * @y: second value\n * @z: third value\n */\n#define min3(x, y, z) min((typeof(x))min(x, y), z)\n\n/**\n * max3 - return maximum of three values\n * @x: first value\n * @y: second value\n * @z: third value\n */\n#define max3(x, y, z) max((typeof(x))max(x, y), z)\n\n/**\n * min_not_zero - return the minimum that is _not_ zero, unless both are zero\n * @x: value1\n * @y: value2\n */\n#define min_not_zero(x, y) ({\t\t\t\\\n\ttypeof(x) __x = (x);\t\t\t\\\n\ttypeof(y) __y = (y);\t\t\t\\\n\t__x == 0 ? __y : ((__y == 0) ? __x : min(__x, __y)); })\n\n/**\n * clamp - return a value clamped to a given range with strict typechecking\n * @val: current value\n * @lo: lowest allowable value\n * @hi: highest allowable value\n *\n * This macro does strict typechecking of @lo/@hi to make sure they are of the\n * same type as @val.  See the unnecessary pointer comparisons.\n */\n#define clamp(val, lo, hi) min((typeof(val))max(val, lo), hi)\n\n/*\n * ..and if you can't take the strict\n * types, you can specify one yourself.\n *\n * Or not use min/max/clamp at all, of course.\n */\n\n/**\n * min_t - return minimum of two values, using the specified type\n * @type: data type to use\n * @x: first value\n * @y: second value\n */\n#define min_t(type, x, y)\t__careful_cmp((type)(x), (type)(y), <)\n\n/**\n * max_t - return maximum of two values, using the specified type\n * @type: data type to use\n * @x: first value\n * @y: second value\n */\n#define max_t(type, x, y)\t__careful_cmp((type)(x), (type)(y), >)\n\n/**\n * clamp_t - return a value clamped to a given range using a given type\n * @type: the type of variable to use\n * @val: current value\n * @lo: minimum allowable value\n * @hi: maximum allowable value\n *\n * This macro does no typechecking and uses temporary variables of type\n * @type to make all the comparisons.\n */\n#define clamp_t(type, val, lo, hi) min_t(type, max_t(type, val, lo), hi)\n\n/**\n * clamp_val - return a value clamped to a given range using val's type\n * @val: current value\n * @lo: minimum allowable value\n * @hi: maximum allowable value\n *\n * This macro does no typechecking and uses temporary variables of whatever\n * type the input argument @val is.  This is useful when @val is an unsigned\n * type and @lo and @hi are literals that will otherwise be assigned a signed\n * integer type.\n */\n#define clamp_val(val, lo, hi) clamp_t(typeof(val), val, lo, hi)\n\n/**\n * swap - swap values of @a and @b\n * @a: first value\n * @b: second value\n */\n#define swap(a, b) \\\n\tdo { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)\n\n#endif\t/* _LINUX_MINMAX_H */\n"}, "10": {"id": 10, "path": "/src/include/linux/kernel.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_KERNEL_H\n#define _LINUX_KERNEL_H\n\n#include <stdarg.h>\n#include <linux/limits.h>\n#include <linux/linkage.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/bitops.h>\n#include <linux/log2.h>\n#include <linux/math.h>\n#include <linux/minmax.h>\n#include <linux/typecheck.h>\n#include <linux/printk.h>\n#include <linux/build_bug.h>\n#include <linux/static_call_types.h>\n#include <asm/byteorder.h>\n\n#include <uapi/linux/kernel.h>\n\n#define STACK_MAGIC\t0xdeadbeef\n\n/**\n * REPEAT_BYTE - repeat the value @x multiple times as an unsigned long value\n * @x: value to repeat\n *\n * NOTE: @x is not checked for > 0xff; larger values produce odd results.\n */\n#define REPEAT_BYTE(x)\t((~0ul / 0xff) * (x))\n\n/* @a is a power of 2 value */\n#define ALIGN(x, a)\t\t__ALIGN_KERNEL((x), (a))\n#define ALIGN_DOWN(x, a)\t__ALIGN_KERNEL((x) - ((a) - 1), (a))\n#define __ALIGN_MASK(x, mask)\t__ALIGN_KERNEL_MASK((x), (mask))\n#define PTR_ALIGN(p, a)\t\t((typeof(p))ALIGN((unsigned long)(p), (a)))\n#define PTR_ALIGN_DOWN(p, a)\t((typeof(p))ALIGN_DOWN((unsigned long)(p), (a)))\n#define IS_ALIGNED(x, a)\t\t(((x) & ((typeof(x))(a) - 1)) == 0)\n\n/* generic data direction definitions */\n#define READ\t\t\t0\n#define WRITE\t\t\t1\n\n/**\n * ARRAY_SIZE - get the number of elements in array @arr\n * @arr: array to be sized\n */\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr))\n\n#define u64_to_user_ptr(x) (\t\t\\\n{\t\t\t\t\t\\\n\ttypecheck(u64, (x));\t\t\\\n\t(void __user *)(uintptr_t)(x);\t\\\n}\t\t\t\t\t\\\n)\n\n#define typeof_member(T, m)\ttypeof(((T*)0)->m)\n\n#define _RET_IP_\t\t(unsigned long)__builtin_return_address(0)\n#define _THIS_IP_  ({ __label__ __here; __here: (unsigned long)&&__here; })\n\n/**\n * upper_32_bits - return bits 32-63 of a number\n * @n: the number we're accessing\n *\n * A basic shift-right of a 64- or 32-bit quantity.  Use this to suppress\n * the \"right shift count >= width of type\" warning when that quantity is\n * 32-bits.\n */\n#define upper_32_bits(n) ((u32)(((n) >> 16) >> 16))\n\n/**\n * lower_32_bits - return bits 0-31 of a number\n * @n: the number we're accessing\n */\n#define lower_32_bits(n) ((u32)((n) & 0xffffffff))\n\nstruct completion;\nstruct pt_regs;\nstruct user;\n\n#ifdef CONFIG_PREEMPT_VOLUNTARY\n\nextern int __cond_resched(void);\n# define might_resched() __cond_resched()\n\n#elif defined(CONFIG_PREEMPT_DYNAMIC)\n\nextern int __cond_resched(void);\n\nDECLARE_STATIC_CALL(might_resched, __cond_resched);\n\nstatic __always_inline void might_resched(void)\n{\n\tstatic_call_mod(might_resched)();\n}\n\n#else\n\n# define might_resched() do { } while (0)\n\n#endif /* CONFIG_PREEMPT_* */\n\n#ifdef CONFIG_DEBUG_ATOMIC_SLEEP\nextern void ___might_sleep(const char *file, int line, int preempt_offset);\nextern void __might_sleep(const char *file, int line, int preempt_offset);\nextern void __cant_sleep(const char *file, int line, int preempt_offset);\nextern void __cant_migrate(const char *file, int line);\n\n/**\n * might_sleep - annotation for functions that can sleep\n *\n * this macro will print a stack trace if it is executed in an atomic\n * context (spinlock, irq-handler, ...). Additional sections where blocking is\n * not allowed can be annotated with non_block_start() and non_block_end()\n * pairs.\n *\n * This is a useful debugging help to be able to catch problems early and not\n * be bitten later when the calling function happens to sleep when it is not\n * supposed to.\n */\n# define might_sleep() \\\n\tdo { __might_sleep(__FILE__, __LINE__, 0); might_resched(); } while (0)\n/**\n * cant_sleep - annotation for functions that cannot sleep\n *\n * this macro will print a stack trace if it is executed with preemption enabled\n */\n# define cant_sleep() \\\n\tdo { __cant_sleep(__FILE__, __LINE__, 0); } while (0)\n# define sched_annotate_sleep()\t(current->task_state_change = 0)\n\n/**\n * cant_migrate - annotation for functions that cannot migrate\n *\n * Will print a stack trace if executed in code which is migratable\n */\n# define cant_migrate()\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (IS_ENABLED(CONFIG_SMP))\t\t\t\t\\\n\t\t\t__cant_migrate(__FILE__, __LINE__);\t\t\\\n\t} while (0)\n\n/**\n * non_block_start - annotate the start of section where sleeping is prohibited\n *\n * This is on behalf of the oom reaper, specifically when it is calling the mmu\n * notifiers. The problem is that if the notifier were to block on, for example,\n * mutex_lock() and if the process which holds that mutex were to perform a\n * sleeping memory allocation, the oom reaper is now blocked on completion of\n * that memory allocation. Other blocking calls like wait_event() pose similar\n * issues.\n */\n# define non_block_start() (current->non_block_count++)\n/**\n * non_block_end - annotate the end of section where sleeping is prohibited\n *\n * Closes a section opened by non_block_start().\n */\n# define non_block_end() WARN_ON(current->non_block_count-- == 0)\n#else\n  static inline void ___might_sleep(const char *file, int line,\n\t\t\t\t   int preempt_offset) { }\n  static inline void __might_sleep(const char *file, int line,\n\t\t\t\t   int preempt_offset) { }\n# define might_sleep() do { might_resched(); } while (0)\n# define cant_sleep() do { } while (0)\n# define cant_migrate()\t\tdo { } while (0)\n# define sched_annotate_sleep() do { } while (0)\n# define non_block_start() do { } while (0)\n# define non_block_end() do { } while (0)\n#endif\n\n#define might_sleep_if(cond) do { if (cond) might_sleep(); } while (0)\n\n#if defined(CONFIG_MMU) && \\\n\t(defined(CONFIG_PROVE_LOCKING) || defined(CONFIG_DEBUG_ATOMIC_SLEEP))\n#define might_fault() __might_fault(__FILE__, __LINE__)\nvoid __might_fault(const char *file, int line);\n#else\nstatic inline void might_fault(void) { }\n#endif\n\nextern struct atomic_notifier_head panic_notifier_list;\nextern long (*panic_blink)(int state);\n__printf(1, 2)\nvoid panic(const char *fmt, ...) __noreturn __cold;\nvoid nmi_panic(struct pt_regs *regs, const char *msg);\nextern void oops_enter(void);\nextern void oops_exit(void);\nextern bool oops_may_print(void);\nvoid do_exit(long error_code) __noreturn;\nvoid complete_and_exit(struct completion *, long) __noreturn;\n\n/* Internal, do not use. */\nint __must_check _kstrtoul(const char *s, unsigned int base, unsigned long *res);\nint __must_check _kstrtol(const char *s, unsigned int base, long *res);\n\nint __must_check kstrtoull(const char *s, unsigned int base, unsigned long long *res);\nint __must_check kstrtoll(const char *s, unsigned int base, long long *res);\n\n/**\n * kstrtoul - convert a string to an unsigned long\n * @s: The start of the string. The string must be null-terminated, and may also\n *  include a single newline before its terminating null. The first character\n *  may also be a plus sign, but not a minus sign.\n * @base: The number base to use. The maximum supported base is 16. If base is\n *  given as 0, then the base of the string is automatically detected with the\n *  conventional semantics - If it begins with 0x the number will be parsed as a\n *  hexadecimal (case insensitive), if it otherwise begins with 0, it will be\n *  parsed as an octal number. Otherwise it will be parsed as a decimal.\n * @res: Where to write the result of the conversion on success.\n *\n * Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.\n * Preferred over simple_strtoul(). Return code must be checked.\n*/\nstatic inline int __must_check kstrtoul(const char *s, unsigned int base, unsigned long *res)\n{\n\t/*\n\t * We want to shortcut function call, but\n\t * __builtin_types_compatible_p(unsigned long, unsigned long long) = 0.\n\t */\n\tif (sizeof(unsigned long) == sizeof(unsigned long long) &&\n\t    __alignof__(unsigned long) == __alignof__(unsigned long long))\n\t\treturn kstrtoull(s, base, (unsigned long long *)res);\n\telse\n\t\treturn _kstrtoul(s, base, res);\n}\n\n/**\n * kstrtol - convert a string to a long\n * @s: The start of the string. The string must be null-terminated, and may also\n *  include a single newline before its terminating null. The first character\n *  may also be a plus sign or a minus sign.\n * @base: The number base to use. The maximum supported base is 16. If base is\n *  given as 0, then the base of the string is automatically detected with the\n *  conventional semantics - If it begins with 0x the number will be parsed as a\n *  hexadecimal (case insensitive), if it otherwise begins with 0, it will be\n *  parsed as an octal number. Otherwise it will be parsed as a decimal.\n * @res: Where to write the result of the conversion on success.\n *\n * Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.\n * Preferred over simple_strtol(). Return code must be checked.\n */\nstatic inline int __must_check kstrtol(const char *s, unsigned int base, long *res)\n{\n\t/*\n\t * We want to shortcut function call, but\n\t * __builtin_types_compatible_p(long, long long) = 0.\n\t */\n\tif (sizeof(long) == sizeof(long long) &&\n\t    __alignof__(long) == __alignof__(long long))\n\t\treturn kstrtoll(s, base, (long long *)res);\n\telse\n\t\treturn _kstrtol(s, base, res);\n}\n\nint __must_check kstrtouint(const char *s, unsigned int base, unsigned int *res);\nint __must_check kstrtoint(const char *s, unsigned int base, int *res);\n\nstatic inline int __must_check kstrtou64(const char *s, unsigned int base, u64 *res)\n{\n\treturn kstrtoull(s, base, res);\n}\n\nstatic inline int __must_check kstrtos64(const char *s, unsigned int base, s64 *res)\n{\n\treturn kstrtoll(s, base, res);\n}\n\nstatic inline int __must_check kstrtou32(const char *s, unsigned int base, u32 *res)\n{\n\treturn kstrtouint(s, base, res);\n}\n\nstatic inline int __must_check kstrtos32(const char *s, unsigned int base, s32 *res)\n{\n\treturn kstrtoint(s, base, res);\n}\n\nint __must_check kstrtou16(const char *s, unsigned int base, u16 *res);\nint __must_check kstrtos16(const char *s, unsigned int base, s16 *res);\nint __must_check kstrtou8(const char *s, unsigned int base, u8 *res);\nint __must_check kstrtos8(const char *s, unsigned int base, s8 *res);\nint __must_check kstrtobool(const char *s, bool *res);\n\nint __must_check kstrtoull_from_user(const char __user *s, size_t count, unsigned int base, unsigned long long *res);\nint __must_check kstrtoll_from_user(const char __user *s, size_t count, unsigned int base, long long *res);\nint __must_check kstrtoul_from_user(const char __user *s, size_t count, unsigned int base, unsigned long *res);\nint __must_check kstrtol_from_user(const char __user *s, size_t count, unsigned int base, long *res);\nint __must_check kstrtouint_from_user(const char __user *s, size_t count, unsigned int base, unsigned int *res);\nint __must_check kstrtoint_from_user(const char __user *s, size_t count, unsigned int base, int *res);\nint __must_check kstrtou16_from_user(const char __user *s, size_t count, unsigned int base, u16 *res);\nint __must_check kstrtos16_from_user(const char __user *s, size_t count, unsigned int base, s16 *res);\nint __must_check kstrtou8_from_user(const char __user *s, size_t count, unsigned int base, u8 *res);\nint __must_check kstrtos8_from_user(const char __user *s, size_t count, unsigned int base, s8 *res);\nint __must_check kstrtobool_from_user(const char __user *s, size_t count, bool *res);\n\nstatic inline int __must_check kstrtou64_from_user(const char __user *s, size_t count, unsigned int base, u64 *res)\n{\n\treturn kstrtoull_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtos64_from_user(const char __user *s, size_t count, unsigned int base, s64 *res)\n{\n\treturn kstrtoll_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtou32_from_user(const char __user *s, size_t count, unsigned int base, u32 *res)\n{\n\treturn kstrtouint_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtos32_from_user(const char __user *s, size_t count, unsigned int base, s32 *res)\n{\n\treturn kstrtoint_from_user(s, count, base, res);\n}\n\n/*\n * Use kstrto<foo> instead.\n *\n * NOTE: simple_strto<foo> does not check for the range overflow and,\n *\t depending on the input, may give interesting results.\n *\n * Use these functions if and only if you cannot use kstrto<foo>, because\n * the conversion ends on the first non-digit character, which may be far\n * beyond the supported range. It might be useful to parse the strings like\n * 10x50 or 12:21 without altering original string or temporary buffer in use.\n * Keep in mind above caveat.\n */\n\nextern unsigned long simple_strtoul(const char *,char **,unsigned int);\nextern long simple_strtol(const char *,char **,unsigned int);\nextern unsigned long long simple_strtoull(const char *,char **,unsigned int);\nextern long long simple_strtoll(const char *,char **,unsigned int);\n\nextern int num_to_str(char *buf, int size,\n\t\t      unsigned long long num, unsigned int width);\n\n/* lib/printf utilities */\n\nextern __printf(2, 3) int sprintf(char *buf, const char * fmt, ...);\nextern __printf(2, 0) int vsprintf(char *buf, const char *, va_list);\nextern __printf(3, 4)\nint snprintf(char *buf, size_t size, const char *fmt, ...);\nextern __printf(3, 0)\nint vsnprintf(char *buf, size_t size, const char *fmt, va_list args);\nextern __printf(3, 4)\nint scnprintf(char *buf, size_t size, const char *fmt, ...);\nextern __printf(3, 0)\nint vscnprintf(char *buf, size_t size, const char *fmt, va_list args);\nextern __printf(2, 3) __malloc\nchar *kasprintf(gfp_t gfp, const char *fmt, ...);\nextern __printf(2, 0) __malloc\nchar *kvasprintf(gfp_t gfp, const char *fmt, va_list args);\nextern __printf(2, 0)\nconst char *kvasprintf_const(gfp_t gfp, const char *fmt, va_list args);\n\nextern __scanf(2, 3)\nint sscanf(const char *, const char *, ...);\nextern __scanf(2, 0)\nint vsscanf(const char *, const char *, va_list);\n\nextern int get_option(char **str, int *pint);\nextern char *get_options(const char *str, int nints, int *ints);\nextern unsigned long long memparse(const char *ptr, char **retptr);\nextern bool parse_option_str(const char *str, const char *option);\nextern char *next_arg(char *args, char **param, char **val);\n\nextern int core_kernel_text(unsigned long addr);\nextern int init_kernel_text(unsigned long addr);\nextern int core_kernel_data(unsigned long addr);\nextern int __kernel_text_address(unsigned long addr);\nextern int kernel_text_address(unsigned long addr);\nextern int func_ptr_is_kernel_text(void *ptr);\n\n#ifdef CONFIG_SMP\nextern unsigned int sysctl_oops_all_cpu_backtrace;\n#else\n#define sysctl_oops_all_cpu_backtrace 0\n#endif /* CONFIG_SMP */\n\nextern void bust_spinlocks(int yes);\nextern int panic_timeout;\nextern unsigned long panic_print;\nextern int panic_on_oops;\nextern int panic_on_unrecovered_nmi;\nextern int panic_on_io_nmi;\nextern int panic_on_warn;\nextern unsigned long panic_on_taint;\nextern bool panic_on_taint_nousertaint;\nextern int sysctl_panic_on_rcu_stall;\nextern int sysctl_max_rcu_stall_to_panic;\nextern int sysctl_panic_on_stackoverflow;\n\nextern bool crash_kexec_post_notifiers;\n\n/*\n * panic_cpu is used for synchronizing panic() and crash_kexec() execution. It\n * holds a CPU number which is executing panic() currently. A value of\n * PANIC_CPU_INVALID means no CPU has entered panic() or crash_kexec().\n */\nextern atomic_t panic_cpu;\n#define PANIC_CPU_INVALID\t-1\n\n/*\n * Only to be used by arch init code. If the user over-wrote the default\n * CONFIG_PANIC_TIMEOUT, honor it.\n */\nstatic inline void set_arch_panic_timeout(int timeout, int arch_default_timeout)\n{\n\tif (panic_timeout == arch_default_timeout)\n\t\tpanic_timeout = timeout;\n}\nextern const char *print_tainted(void);\nenum lockdep_ok {\n\tLOCKDEP_STILL_OK,\n\tLOCKDEP_NOW_UNRELIABLE\n};\nextern void add_taint(unsigned flag, enum lockdep_ok);\nextern int test_taint(unsigned flag);\nextern unsigned long get_taint(void);\nextern int root_mountflags;\n\nextern bool early_boot_irqs_disabled;\n\n/*\n * Values used for system_state. Ordering of the states must not be changed\n * as code checks for <, <=, >, >= STATE.\n */\nextern enum system_states {\n\tSYSTEM_BOOTING,\n\tSYSTEM_SCHEDULING,\n\tSYSTEM_RUNNING,\n\tSYSTEM_HALT,\n\tSYSTEM_POWER_OFF,\n\tSYSTEM_RESTART,\n\tSYSTEM_SUSPEND,\n} system_state;\n\n/* This cannot be an enum because some may be used in assembly source. */\n#define TAINT_PROPRIETARY_MODULE\t0\n#define TAINT_FORCED_MODULE\t\t1\n#define TAINT_CPU_OUT_OF_SPEC\t\t2\n#define TAINT_FORCED_RMMOD\t\t3\n#define TAINT_MACHINE_CHECK\t\t4\n#define TAINT_BAD_PAGE\t\t\t5\n#define TAINT_USER\t\t\t6\n#define TAINT_DIE\t\t\t7\n#define TAINT_OVERRIDDEN_ACPI_TABLE\t8\n#define TAINT_WARN\t\t\t9\n#define TAINT_CRAP\t\t\t10\n#define TAINT_FIRMWARE_WORKAROUND\t11\n#define TAINT_OOT_MODULE\t\t12\n#define TAINT_UNSIGNED_MODULE\t\t13\n#define TAINT_SOFTLOCKUP\t\t14\n#define TAINT_LIVEPATCH\t\t\t15\n#define TAINT_AUX\t\t\t16\n#define TAINT_RANDSTRUCT\t\t17\n#define TAINT_FLAGS_COUNT\t\t18\n#define TAINT_FLAGS_MAX\t\t\t((1UL << TAINT_FLAGS_COUNT) - 1)\n\nstruct taint_flag {\n\tchar c_true;\t/* character printed when tainted */\n\tchar c_false;\t/* character printed when not tainted */\n\tbool module;\t/* also show as a per-module taint flag */\n};\n\nextern const struct taint_flag taint_flags[TAINT_FLAGS_COUNT];\n\nextern const char hex_asc[];\n#define hex_asc_lo(x)\thex_asc[((x) & 0x0f)]\n#define hex_asc_hi(x)\thex_asc[((x) & 0xf0) >> 4]\n\nstatic inline char *hex_byte_pack(char *buf, u8 byte)\n{\n\t*buf++ = hex_asc_hi(byte);\n\t*buf++ = hex_asc_lo(byte);\n\treturn buf;\n}\n\nextern const char hex_asc_upper[];\n#define hex_asc_upper_lo(x)\thex_asc_upper[((x) & 0x0f)]\n#define hex_asc_upper_hi(x)\thex_asc_upper[((x) & 0xf0) >> 4]\n\nstatic inline char *hex_byte_pack_upper(char *buf, u8 byte)\n{\n\t*buf++ = hex_asc_upper_hi(byte);\n\t*buf++ = hex_asc_upper_lo(byte);\n\treturn buf;\n}\n\nextern int hex_to_bin(char ch);\nextern int __must_check hex2bin(u8 *dst, const char *src, size_t count);\nextern char *bin2hex(char *dst, const void *src, size_t count);\n\nbool mac_pton(const char *s, u8 *mac);\n\n/*\n * General tracing related utility functions - trace_printk(),\n * tracing_on/tracing_off and tracing_start()/tracing_stop\n *\n * Use tracing_on/tracing_off when you want to quickly turn on or off\n * tracing. It simply enables or disables the recording of the trace events.\n * This also corresponds to the user space /sys/kernel/debug/tracing/tracing_on\n * file, which gives a means for the kernel and userspace to interact.\n * Place a tracing_off() in the kernel where you want tracing to end.\n * From user space, examine the trace, and then echo 1 > tracing_on\n * to continue tracing.\n *\n * tracing_stop/tracing_start has slightly more overhead. It is used\n * by things like suspend to ram where disabling the recording of the\n * trace is not enough, but tracing must actually stop because things\n * like calling smp_processor_id() may crash the system.\n *\n * Most likely, you want to use tracing_on/tracing_off.\n */\n\nenum ftrace_dump_mode {\n\tDUMP_NONE,\n\tDUMP_ALL,\n\tDUMP_ORIG,\n};\n\n#ifdef CONFIG_TRACING\nvoid tracing_on(void);\nvoid tracing_off(void);\nint tracing_is_on(void);\nvoid tracing_snapshot(void);\nvoid tracing_snapshot_alloc(void);\n\nextern void tracing_start(void);\nextern void tracing_stop(void);\n\nstatic inline __printf(1, 2)\nvoid ____trace_printk_check_format(const char *fmt, ...)\n{\n}\n#define __trace_printk_check_format(fmt, args...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\t\\\n\t\t____trace_printk_check_format(fmt, ##args);\t\t\\\n} while (0)\n\n/**\n * trace_printk - printf formatting in the ftrace buffer\n * @fmt: the printf format for printing\n *\n * Note: __trace_printk is an internal function for trace_printk() and\n *       the @ip is passed in via the trace_printk() macro.\n *\n * This function allows a kernel developer to debug fast path sections\n * that printk is not appropriate for. By scattering in various\n * printk like tracing in the code, a developer can quickly see\n * where problems are occurring.\n *\n * This is intended as a debugging tool for the developer only.\n * Please refrain from leaving trace_printks scattered around in\n * your code. (Extra memory is used for special buffers that are\n * allocated when trace_printk() is used.)\n *\n * A little optimization trick is done here. If there's only one\n * argument, there's no need to scan the string for printf formats.\n * The trace_puts() will suffice. But how can we take advantage of\n * using trace_puts() when trace_printk() has only one argument?\n * By stringifying the args and checking the size we can tell\n * whether or not there are args. __stringify((__VA_ARGS__)) will\n * turn into \"()\\0\" with a size of 3 when there are no args, anything\n * else will be bigger. All we need to do is define a string to this,\n * and then take its size and compare to 3. If it's bigger, use\n * do_trace_printk() otherwise, optimize it to trace_puts(). Then just\n * let gcc optimize the rest.\n */\n\n#define trace_printk(fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tchar _______STR[] = __stringify((__VA_ARGS__));\t\\\n\tif (sizeof(_______STR) > 3)\t\t\t\\\n\t\tdo_trace_printk(fmt, ##__VA_ARGS__);\t\\\n\telse\t\t\t\t\t\t\\\n\t\ttrace_puts(fmt);\t\t\t\\\n} while (0)\n\n#define do_trace_printk(fmt, args...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tstatic const char *trace_printk_fmt __used\t\t\t\\\n\t\t__section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t__builtin_constant_p(fmt) ? fmt : NULL;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__trace_printk_check_format(fmt, ##args);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(fmt))\t\t\t\t\t\\\n\t\t__trace_bprintk(_THIS_IP_, trace_printk_fmt, ##args);\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__trace_printk(_THIS_IP_, fmt, ##args);\t\t\t\\\n} while (0)\n\nextern __printf(2, 3)\nint __trace_bprintk(unsigned long ip, const char *fmt, ...);\n\nextern __printf(2, 3)\nint __trace_printk(unsigned long ip, const char *fmt, ...);\n\n/**\n * trace_puts - write a string into the ftrace buffer\n * @str: the string to record\n *\n * Note: __trace_bputs is an internal function for trace_puts and\n *       the @ip is passed in via the trace_puts macro.\n *\n * This is similar to trace_printk() but is made for those really fast\n * paths that a developer wants the least amount of \"Heisenbug\" effects,\n * where the processing of the print format is still too much.\n *\n * This function allows a kernel developer to debug fast path sections\n * that printk is not appropriate for. By scattering in various\n * printk like tracing in the code, a developer can quickly see\n * where problems are occurring.\n *\n * This is intended as a debugging tool for the developer only.\n * Please refrain from leaving trace_puts scattered around in\n * your code. (Extra memory is used for special buffers that are\n * allocated when trace_puts() is used.)\n *\n * Returns: 0 if nothing was written, positive # if string was.\n *  (1 when __trace_bputs is used, strlen(str) when __trace_puts is used)\n */\n\n#define trace_puts(str) ({\t\t\t\t\t\t\\\n\tstatic const char *trace_printk_fmt __used\t\t\t\\\n\t\t__section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t__builtin_constant_p(str) ? str : NULL;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(str))\t\t\t\t\t\\\n\t\t__trace_bputs(_THIS_IP_, trace_printk_fmt);\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__trace_puts(_THIS_IP_, str, strlen(str));\t\t\\\n})\nextern int __trace_bputs(unsigned long ip, const char *str);\nextern int __trace_puts(unsigned long ip, const char *str, int size);\n\nextern void trace_dump_stack(int skip);\n\n/*\n * The double __builtin_constant_p is because gcc will give us an error\n * if we try to allocate the static variable to fmt if it is not a\n * constant. Even with the outer if statement.\n */\n#define ftrace_vprintk(fmt, vargs)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(fmt)) {\t\t\t\t\\\n\t\tstatic const char *trace_printk_fmt __used\t\t\\\n\t\t  __section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t\t__builtin_constant_p(fmt) ? fmt : NULL;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__ftrace_vbprintk(_THIS_IP_, trace_printk_fmt, vargs);\t\\\n\t} else\t\t\t\t\t\t\t\t\\\n\t\t__ftrace_vprintk(_THIS_IP_, fmt, vargs);\t\t\\\n} while (0)\n\nextern __printf(2, 0) int\n__ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap);\n\nextern __printf(2, 0) int\n__ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap);\n\nextern void ftrace_dump(enum ftrace_dump_mode oops_dump_mode);\n#else\nstatic inline void tracing_start(void) { }\nstatic inline void tracing_stop(void) { }\nstatic inline void trace_dump_stack(int skip) { }\n\nstatic inline void tracing_on(void) { }\nstatic inline void tracing_off(void) { }\nstatic inline int tracing_is_on(void) { return 0; }\nstatic inline void tracing_snapshot(void) { }\nstatic inline void tracing_snapshot_alloc(void) { }\n\nstatic inline __printf(1, 2)\nint trace_printk(const char *fmt, ...)\n{\n\treturn 0;\n}\nstatic __printf(1, 0) inline int\nftrace_vprintk(const char *fmt, va_list ap)\n{\n\treturn 0;\n}\nstatic inline void ftrace_dump(enum ftrace_dump_mode oops_dump_mode) { }\n#endif /* CONFIG_TRACING */\n\n/* This counts to 12. Any more, it will return 13th argument. */\n#define __COUNT_ARGS(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _n, X...) _n\n#define COUNT_ARGS(X...) __COUNT_ARGS(, ##X, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)\n\n#define __CONCAT(a, b) a ## b\n#define CONCATENATE(a, b) __CONCAT(a, b)\n\n/**\n * container_of - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n */\n#define container_of(ptr, type, member) ({\t\t\t\t\\\n\tvoid *__mptr = (void *)(ptr);\t\t\t\t\t\\\n\tBUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&\t\\\n\t\t\t !__same_type(*(ptr), void),\t\t\t\\\n\t\t\t \"pointer type mismatch in container_of()\");\t\\\n\t((type *)(__mptr - offsetof(type, member))); })\n\n/**\n * container_of_safe - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n * If IS_ERR_OR_NULL(ptr), ptr is returned unchanged.\n */\n#define container_of_safe(ptr, type, member) ({\t\t\t\t\\\n\tvoid *__mptr = (void *)(ptr);\t\t\t\t\t\\\n\tBUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&\t\\\n\t\t\t !__same_type(*(ptr), void),\t\t\t\\\n\t\t\t \"pointer type mismatch in container_of()\");\t\\\n\tIS_ERR_OR_NULL(__mptr) ? ERR_CAST(__mptr) :\t\t\t\\\n\t\t((type *)(__mptr - offsetof(type, member))); })\n\n/* Rebuild everything on CONFIG_FTRACE_MCOUNT_RECORD */\n#ifdef CONFIG_FTRACE_MCOUNT_RECORD\n# define REBUILD_DUE_TO_FTRACE_MCOUNT_RECORD\n#endif\n\n/* Permissions on a sysfs file: you didn't miss the 0 prefix did you? */\n#define VERIFY_OCTAL_PERMISSIONS(perms)\t\t\t\t\t\t\\\n\t(BUILD_BUG_ON_ZERO((perms) < 0) +\t\t\t\t\t\\\n\t BUILD_BUG_ON_ZERO((perms) > 0777) +\t\t\t\t\t\\\n\t /* USER_READABLE >= GROUP_READABLE >= OTHER_READABLE */\t\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 6) & 4) < (((perms) >> 3) & 4)) +\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 3) & 4) < ((perms) & 4)) +\t\t\\\n\t /* USER_WRITABLE >= GROUP_WRITABLE */\t\t\t\t\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 6) & 2) < (((perms) >> 3) & 2)) +\t\\\n\t /* OTHER_WRITABLE?  Generally considered a bad idea. */\t\t\\\n\t BUILD_BUG_ON_ZERO((perms) & 2) +\t\t\t\t\t\\\n\t (perms))\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 11, "file": 0, "line": 1986}, "message": "Calling 'get_bitmap_from_slot'"}, {"location": {"col": 2, "file": 0, "line": 1960}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1965}, "message": "Calling 'md_bitmap_init_from_disk'"}, {"location": {"col": 6, "file": 0, "line": 1069}, "message": "Assuming 'file' is null"}, {"location": {"col": 6, "file": 0, "line": 1069}, "message": "Left side of '&&' is true"}, {"location": {"col": 15, "file": 0, "line": 1069}, "message": "Assuming field 'offset' is 0"}, {"location": {"col": 2, "file": 0, "line": 1069}, "message": "Taking true branch"}, {"location": {"col": 15, "file": 0, "line": 1073}, "message": "Assuming 'i' is < 'chunks'"}, {"location": {"col": 3, "file": 0, "line": 1073}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 4, "file": 0, "line": 1077}, "message": "Calling 'md_bitmap_set_memory_bits'"}, {"location": {"col": 7, "file": 0, "line": 1671}, "message": "'bmc' is non-null"}, {"location": {"col": 2, "file": 0, "line": 1671}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1675}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 0, "line": 1675}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 1677}, "message": "Calling 'md_bitmap_count_page'"}, {"location": {"col": 2, "file": 0, "line": 1203}, "message": "Calling 'md_bitmap_checkfree'"}, {"location": {"col": 6, "file": 0, "line": 123}, "message": "Assuming field 'count' is 0"}, {"location": {"col": 2, "file": 0, "line": 123}, "message": "Taking false branch"}, {"location": {"col": 23, "file": 0, "line": 128}, "message": "Field 'hijacked' is 0"}, {"location": {"col": 2, "file": 0, "line": 128}, "message": "Taking false branch"}, {"location": {"col": 3, "file": 0, "line": 136}, "message": "Memory is released"}, {"location": {"col": 2, "file": 0, "line": 1203}, "message": "Returning; memory was released"}, {"location": {"col": 3, "file": 0, "line": 1677}, "message": "Returning; memory was released"}, {"location": {"col": 6, "file": 0, "line": 1681}, "message": "'needed' is 1"}, {"location": {"col": 2, "file": 0, "line": 1681}, "message": "Taking true branch"}, {"location": {"col": 8, "file": 0, "line": 1682}, "message": "Use of memory after it is freed"}, {"location": {"col": 8, "file": 0, "line": 1682}, "message": "Use of memory after it is freed"}], "macros": [], "notes": [], "path": "/src/drivers/md/md-bitmap.c", "reportHash": "da377c85ef3efe46317c2bafa5c8dcf7", "checkerName": "clang-analyzer-unix.Malloc", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 0, "line": 2274}, "message": "Calling 'mddev_lock'"}, {"location": {"col": 9, "file": 1, "line": 535}, "message": "Value assigned to field 'pers', which participates in a condition later"}, {"location": {"col": 9, "file": 1, "line": 535}, "message": "Value assigned to field 'recovery', which participates in a condition later"}, {"location": {"col": 9, "file": 1, "line": 535}, "message": "Value assigned to field 'sync_thread', which participates in a condition later"}, {"location": {"col": 9, "file": 1, "line": 535}, "message": "Value assigned to field 'bitmap', which participates in a condition later"}, {"location": {"col": 9, "file": 1, "line": 535}, "message": "Value assigned to field 'file', which participates in a condition later"}, {"location": {"col": 9, "file": 1, "line": 535}, "message": "Value assigned to field 'offset', which participates in a condition later"}, {"location": {"col": 2, "file": 1, "line": 535}, "message": "Returning value, which participates in a condition later"}, {"location": {"col": 7, "file": 0, "line": 2274}, "message": "Returning from 'mddev_lock'"}, {"location": {"col": 6, "file": 0, "line": 2275}, "message": "Assuming 'rv' is 0"}, {"location": {"col": 2, "file": 0, "line": 2275}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 2277}, "message": "Assuming field 'pers' is non-null"}, {"location": {"col": 2, "file": 0, "line": 2277}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 2278}, "message": "Assuming field 'quiesce' is non-null"}, {"location": {"col": 3, "file": 0, "line": 2278}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 2282}, "message": "Assuming field 'recovery' is 0"}, {"location": {"col": 7, "file": 0, "line": 2282}, "message": "Left side of '||' is false"}, {"location": {"col": 26, "file": 0, "line": 2282}, "message": "Assuming field 'sync_thread' is null"}, {"location": {"col": 3, "file": 0, "line": 2282}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 2288}, "message": "Assuming field 'bitmap' is null"}, {"location": {"col": 6, "file": 0, "line": 2288}, "message": "Left side of '||' is false"}, {"location": {"col": 6, "file": 0, "line": 2288}, "message": "Assuming pointer value is null"}, {"location": {"col": 23, "file": 0, "line": 2288}, "message": "Assuming field 'file' is null"}, {"location": {"col": 6, "file": 0, "line": 2288}, "message": "Left side of '||' is false"}, {"location": {"col": 6, "file": 0, "line": 2289}, "message": "Assuming field 'offset' is 0"}, {"location": {"col": 2, "file": 0, "line": 2288}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 2309}, "message": "Assuming the condition is false"}, {"location": {"col": 3, "file": 0, "line": 2309}, "message": "Taking false branch"}, {"location": {"col": 12, "file": 0, "line": 2311}, "message": "Assuming the condition is false"}, {"location": {"col": 8, "file": 0, "line": 2311}, "message": "Taking false branch"}, {"location": {"col": 8, "file": 0, "line": 2316}, "message": "Assuming the condition is true"}, {"location": {"col": 4, "file": 0, "line": 2316}, "message": "Taking true branch"}, {"location": {"col": 8, "file": 0, "line": 2320}, "message": "Assuming 'rv' is 0"}, {"location": {"col": 4, "file": 0, "line": 2320}, "message": "Taking false branch"}, {"location": {"col": 8, "file": 0, "line": 2322}, "message": "Assuming 'offset' is not equal to 0"}, {"location": {"col": 4, "file": 0, "line": 2322}, "message": "Taking false branch"}, {"location": {"col": 8, "file": 0, "line": 2326}, "message": "Assuming field 'external' is not equal to 0"}, {"location": {"col": 41, "file": 0, "line": 2326}, "message": "Left side of '&&' is false"}, {"location": {"col": 15, "file": 0, "line": 2333}, "message": "Field 'pers' is non-null"}, {"location": {"col": 4, "file": 0, "line": 2333}, "message": "Taking true branch"}, {"location": {"col": 14, "file": 0, "line": 2335}, "message": "Calling 'md_bitmap_create'"}, {"location": {"col": 2, "file": 0, "line": 1816}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 2, "line": 50}, "message": "expanded from macro 'BUILD_BUG_ON'"}, {"location": {"col": 37, "file": 2, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 3, "line": 320}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 3, "line": 308}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 3, "file": 3, "line": 300}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 2, "file": 0, "line": 1816}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 2, "line": 50}, "message": "expanded from macro 'BUILD_BUG_ON'"}, {"location": {"col": 37, "file": 2, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 3, "line": 320}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 3, "line": 308}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 2, "file": 3, "line": 298}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 9, "file": 0, "line": 1818}, "message": "'file' is null"}, {"location": {"col": 45, "file": 4, "line": 63}, "message": "expanded from macro 'BUG_ON'"}, {"location": {"col": 42, "file": 5, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 14, "file": 0, "line": 1818}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 0, "line": 1818}, "message": "Taking false branch"}, {"location": {"col": 32, "file": 4, "line": 63}, "message": "expanded from macro 'BUG_ON'"}, {"location": {"col": 2, "file": 0, "line": 1818}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 27, "file": 4, "line": 63}, "message": "expanded from macro 'BUG_ON'"}, {"location": {"col": 6, "file": 0, "line": 1820}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1820}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 1826}, "message": "Calling 'kzalloc'"}, {"location": {"col": 9, "file": 6, "line": 686}, "message": "Calling 'kmalloc'"}, {"location": {"col": 2, "file": 6, "line": 544}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 6, "line": 561}, "message": "Returning pointer, which participates in a condition later"}, {"location": {"col": 9, "file": 6, "line": 686}, "message": "Returning from 'kmalloc'"}, {"location": {"col": 2, "file": 6, "line": 686}, "message": "Returning pointer, which participates in a condition later"}, {"location": {"col": 11, "file": 0, "line": 1826}, "message": "Returning from 'kzalloc'"}, {"location": {"col": 6, "file": 0, "line": 1827}, "message": "Assuming 'bitmap' is non-null"}, {"location": {"col": 2, "file": 0, "line": 1827}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1830}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 34, "file": 7, "line": 344}, "message": "expanded from macro 'spin_lock_init'"}, {"location": {"col": 2, "file": 0, "line": 1832}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 8, "line": 67}, "message": "expanded from macro 'init_waitqueue_head'"}, {"location": {"col": 2, "file": 0, "line": 1833}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 8, "line": 67}, "message": "expanded from macro 'init_waitqueue_head'"}, {"location": {"col": 2, "file": 0, "line": 1834}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 8, "line": 67}, "message": "expanded from macro 'init_waitqueue_head'"}, {"location": {"col": 6, "file": 0, "line": 1839}, "message": "Assuming field 'sd' is null"}, {"location": {"col": 2, "file": 0, "line": 1839}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1841}, "message": "'bm' is null"}, {"location": {"col": 2, "file": 0, "line": 1841}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1848}, "message": "'file' is null"}, {"location": {"col": 2, "file": 0, "line": 1848}, "message": "Taking false branch"}, {"location": {"col": 26, "file": 0, "line": 1857}, "message": "Field 'external' is not equal to 0"}, {"location": {"col": 2, "file": 0, "line": 1857}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1868}, "message": "Assuming field 'chunksize' is not equal to 0"}, {"location": {"col": 7, "file": 0, "line": 1868}, "message": "Left side of '||' is false"}, {"location": {"col": 7, "file": 0, "line": 1869}, "message": "Assuming field 'daemon_sleep' is not equal to 0"}, {"location": {"col": 3, "file": 0, "line": 1868}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1874}, "message": "'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 1874}, "message": "Taking false branch"}, {"location": {"col": 8, "file": 0, "line": 1878}, "message": "Calling 'md_bitmap_resize'"}, {"location": {"col": 22, "file": 0, "line": 2074}, "message": "Field 'file' is null"}, {"location": {"col": 27, "file": 0, "line": 2074}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 2079}, "message": "'chunksize' is not equal to 0"}, {"location": {"col": 2, "file": 0, "line": 2079}, "message": "Taking false branch"}, {"location": {"col": 33, "file": 0, "line": 2111}, "message": "Field 'offset' is not equal to 0"}, {"location": {"col": 40, "file": 0, "line": 2111}, "message": "Left side of '||' is true"}, {"location": {"col": 40, "file": 0, "line": 2113}, "message": "Field 'external' is not equal to 0"}, {"location": {"col": 12, "file": 0, "line": 2114}, "message": "'?' condition is false"}, {"location": {"col": 9, "file": 0, "line": 2112}, "message": "Calling 'md_bitmap_storage_alloc'"}, {"location": {"col": 6, "file": 0, "line": 784}, "message": "'with_super' is 0"}, {"location": {"col": 2, "file": 0, "line": 784}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 792}, "message": "Assuming field 'filemap' is non-null"}, {"location": {"col": 2, "file": 0, "line": 792}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 795}, "message": "'with_super' is 0"}, {"location": {"col": 17, "file": 0, "line": 795}, "message": "Left side of '&&' is false"}, {"location": {"col": 13, "file": 0, "line": 802}, "message": "Field 'sb_page' is null"}, {"location": {"col": 2, "file": 0, "line": 802}, "message": "Taking false branch"}, {"location": {"col": 10, "file": 0, "line": 808}, "message": "Assuming 'pnum' is >= 'num_pages'"}, {"location": {"col": 2, "file": 0, "line": 808}, "message": "Loop condition is false. Execution continues on line 816"}, {"location": {"col": 6, "file": 0, "line": 823}, "message": "Assuming field 'filemap_attr' is non-null"}, {"location": {"col": 2, "file": 0, "line": 823}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 828}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 9, "file": 0, "line": 2112}, "message": "Returning from 'md_bitmap_storage_alloc'"}, {"location": {"col": 6, "file": 0, "line": 2116}, "message": "'ret' is 0"}, {"location": {"col": 2, "file": 0, "line": 2116}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 2123}, "message": "Calling 'kcalloc'"}, {"location": {"col": 9, "file": 6, "line": 625}, "message": "Calling 'kmalloc_array'"}, {"location": {"col": 2, "file": 6, "line": 592}, "message": "Taking false branch"}, {"location": {"col": 30, "file": 6, "line": 594}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 6, "line": 596}, "message": "Returning pointer, which participates in a condition later"}, {"location": {"col": 9, "file": 6, "line": 625}, "message": "Returning from 'kmalloc_array'"}, {"location": {"col": 2, "file": 6, "line": 625}, "message": "Returning pointer, which participates in a condition later"}, {"location": {"col": 11, "file": 0, "line": 2123}, "message": "Returning from 'kcalloc'"}, {"location": {"col": 6, "file": 0, "line": 2125}, "message": "Assuming 'new_bp' is non-null"}, {"location": {"col": 2, "file": 0, "line": 2125}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 2130}, "message": "'init' is 1"}, {"location": {"col": 2, "file": 0, "line": 2130}, "message": "Taking false branch"}, {"location": {"col": 12, "file": 0, "line": 2136}, "message": "Field 'sb_page' is null"}, {"location": {"col": 20, "file": 0, "line": 2136}, "message": "Left side of '&&' is false"}, {"location": {"col": 11, "file": 0, "line": 2153}, "message": "Assuming '__UNIQUE_ID___x474' is >= '__UNIQUE_ID___y475'"}, {"location": {"col": 19, "file": 9, "line": 51}, "message": "expanded from macro 'min'"}, {"location": {"col": 3, "file": 9, "line": 44}, "message": "expanded from macro '__careful_cmp'"}, {"location": {"col": 3, "file": 9, "line": 39}, "message": "expanded from macro '__cmp_once'"}, {"location": {"col": 26, "file": 9, "line": 34}, "message": "expanded from macro '__cmp'"}, {"location": {"col": 11, "file": 0, "line": 2153}, "message": "'?' condition is false"}, {"location": {"col": 19, "file": 9, "line": 51}, "message": "expanded from macro 'min'"}, {"location": {"col": 3, "file": 9, "line": 44}, "message": "expanded from macro '__careful_cmp'"}, {"location": {"col": 3, "file": 9, "line": 39}, "message": "expanded from macro '__cmp_once'"}, {"location": {"col": 26, "file": 9, "line": 34}, "message": "expanded from macro '__cmp'"}, {"location": {"col": 2, "file": 0, "line": 2157}, "message": "Taking false branch"}, {"location": {"col": 18, "file": 0, "line": 2186}, "message": "Assuming 'block' is < 'blocks'"}, {"location": {"col": 2, "file": 0, "line": 2186}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 9, "file": 0, "line": 2191}, "message": "'bmc_old' is non-null"}, {"location": {"col": 9, "file": 0, "line": 2191}, "message": "Left side of '&&' is true"}, {"location": {"col": 7, "file": 0, "line": 2193}, "message": "Assuming 'set' is not equal to 0"}, {"location": {"col": 3, "file": 0, "line": 2193}, "message": "Taking true branch"}, {"location": {"col": 14, "file": 0, "line": 2194}, "message": "Calling 'md_bitmap_get_counter'"}, {"location": {"col": 8, "file": 0, "line": 1366}, "message": "Calling 'md_bitmap_checkpage'"}, {"location": {"col": 6, "file": 0, "line": 57}, "message": "Assuming 'page' is < field 'pages'"}, {"location": {"col": 2, "file": 0, "line": 57}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 65}, "message": "Assuming field 'hijacked' is 0"}, {"location": {"col": 2, "file": 0, "line": 65}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 68}, "message": "Assuming field 'map' is null"}, {"location": {"col": 2, "file": 0, "line": 68}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 71}, "message": "'create' is 1"}, {"location": {"col": 2, "file": 0, "line": 71}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 89}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 33, "file": 10, "line": 170}, "message": "expanded from macro 'sched_annotate_sleep'"}, {"location": {"col": 12, "file": 0, "line": 90}, "message": "Calling 'kzalloc'"}, {"location": {"col": 9, "file": 6, "line": 686}, "message": "Storing uninitialized value"}, {"location": {"col": 12, "file": 0, "line": 90}, "message": "Returning from 'kzalloc'"}, {"location": {"col": 6, "file": 0, "line": 93}, "message": "Assuming 'mappage' is not equal to NULL"}, {"location": {"col": 2, "file": 0, "line": 93}, "message": "Taking false branch"}, {"location": {"col": 13, "file": 0, "line": 102}, "message": "Assuming field 'map' is null"}, {"location": {"col": 13, "file": 0, "line": 102}, "message": "Left side of '||' is false"}, {"location": {"col": 6, "file": 0, "line": 103}, "message": "Assuming field 'hijacked' is 0"}, {"location": {"col": 9, "file": 0, "line": 102}, "message": "Taking false branch"}, {"location": {"col": 8, "file": 0, "line": 1366}, "message": "Returning from 'md_bitmap_checkpage'"}, {"location": {"col": 23, "file": 0, "line": 1368}, "message": "Field 'hijacked' is 0"}, {"location": {"col": 6, "file": 0, "line": 1368}, "message": "Left side of '||' is false"}, {"location": {"col": 23, "file": 0, "line": 1369}, "message": "Field 'map' is not equal to NULL"}, {"location": {"col": 2, "file": 0, "line": 1368}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1376}, "message": "'err' is >= 0"}, {"location": {"col": 2, "file": 0, "line": 1376}, "message": "Taking false branch"}, {"location": {"col": 23, "file": 0, "line": 1381}, "message": "Field 'hijacked' is 0"}, {"location": {"col": 2, "file": 0, "line": 1381}, "message": "Taking false branch"}, {"location": {"col": 14, "file": 0, "line": 2194}, "message": "Returning from 'md_bitmap_get_counter'"}, {"location": {"col": 17, "file": 0, "line": 2195}, "message": "The left operand of '==' is a garbage value"}, {"location": {"col": 17, "file": 0, "line": 2195}, "message": "The left operand of '==' is a garbage value"}], "macros": [], "notes": [], "path": "/src/drivers/md/md-bitmap.c", "reportHash": "71ecdb6b8206e443f5f5a4281f81c31b", "checkerName": "clang-analyzer-core.UndefinedBinaryOperatorResult", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 0, "line": 1986}, "message": "Calling 'get_bitmap_from_slot'"}, {"location": {"col": 11, "file": 0, "line": 1959}, "message": "Calling 'md_bitmap_create'"}, {"location": {"col": 2, "file": 0, "line": 1816}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 2, "line": 50}, "message": "expanded from macro 'BUILD_BUG_ON'"}, {"location": {"col": 37, "file": 2, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 3, "line": 320}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 3, "line": 308}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 3, "file": 3, "line": 300}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 2, "file": 0, "line": 1816}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 2, "line": 50}, "message": "expanded from macro 'BUILD_BUG_ON'"}, {"location": {"col": 37, "file": 2, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 3, "line": 320}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 3, "line": 308}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 2, "file": 3, "line": 298}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 9, "file": 0, "line": 1818}, "message": "Assuming 'file' is null"}, {"location": {"col": 45, "file": 4, "line": 63}, "message": "expanded from macro 'BUG_ON'"}, {"location": {"col": 42, "file": 5, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 14, "file": 0, "line": 1818}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 0, "line": 1818}, "message": "Taking false branch"}, {"location": {"col": 32, "file": 4, "line": 63}, "message": "expanded from macro 'BUG_ON'"}, {"location": {"col": 2, "file": 0, "line": 1818}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 27, "file": 4, "line": 63}, "message": "expanded from macro 'BUG_ON'"}, {"location": {"col": 6, "file": 0, "line": 1820}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1820}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1827}, "message": "Assuming 'bitmap' is non-null"}, {"location": {"col": 2, "file": 0, "line": 1827}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1830}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 34, "file": 7, "line": 344}, "message": "expanded from macro 'spin_lock_init'"}, {"location": {"col": 2, "file": 0, "line": 1832}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 8, "line": 67}, "message": "expanded from macro 'init_waitqueue_head'"}, {"location": {"col": 2, "file": 0, "line": 1833}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 8, "line": 67}, "message": "expanded from macro 'init_waitqueue_head'"}, {"location": {"col": 2, "file": 0, "line": 1834}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 8, "line": 67}, "message": "expanded from macro 'init_waitqueue_head'"}, {"location": {"col": 6, "file": 0, "line": 1839}, "message": "Assuming field 'sd' is null"}, {"location": {"col": 2, "file": 0, "line": 1839}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1841}, "message": "'bm' is null"}, {"location": {"col": 2, "file": 0, "line": 1841}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1848}, "message": "'file' is null"}, {"location": {"col": 2, "file": 0, "line": 1848}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1857}, "message": "Assuming field 'external' is not equal to 0"}, {"location": {"col": 2, "file": 0, "line": 1857}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1868}, "message": "Assuming field 'chunksize' is not equal to 0"}, {"location": {"col": 7, "file": 0, "line": 1868}, "message": "Left side of '||' is false"}, {"location": {"col": 7, "file": 0, "line": 1869}, "message": "Assuming field 'daemon_sleep' is not equal to 0"}, {"location": {"col": 3, "file": 0, "line": 1868}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1874}, "message": "'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 1874}, "message": "Taking false branch"}, {"location": {"col": 8, "file": 0, "line": 1878}, "message": "Calling 'md_bitmap_resize'"}, {"location": {"col": 22, "file": 0, "line": 2074}, "message": "Field 'file' is null"}, {"location": {"col": 27, "file": 0, "line": 2074}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 2079}, "message": "'chunksize' is not equal to 0"}, {"location": {"col": 2, "file": 0, "line": 2079}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 2111}, "message": "Assuming field 'offset' is 0"}, {"location": {"col": 6, "file": 0, "line": 2111}, "message": "Left side of '||' is false"}, {"location": {"col": 70, "file": 0, "line": 2111}, "message": "Field 'file' is null"}, {"location": {"col": 2, "file": 0, "line": 2111}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 2116}, "message": "'ret' is 0"}, {"location": {"col": 2, "file": 0, "line": 2116}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 2125}, "message": "Assuming 'new_bp' is non-null"}, {"location": {"col": 2, "file": 0, "line": 2125}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 2130}, "message": "'init' is 1"}, {"location": {"col": 2, "file": 0, "line": 2130}, "message": "Taking false branch"}, {"location": {"col": 12, "file": 0, "line": 2136}, "message": "Field 'sb_page' is null"}, {"location": {"col": 20, "file": 0, "line": 2136}, "message": "Left side of '&&' is false"}, {"location": {"col": 11, "file": 0, "line": 2153}, "message": "Assuming '__UNIQUE_ID___x474' is >= '__UNIQUE_ID___y475'"}, {"location": {"col": 19, "file": 9, "line": 51}, "message": "expanded from macro 'min'"}, {"location": {"col": 3, "file": 9, "line": 44}, "message": "expanded from macro '__careful_cmp'"}, {"location": {"col": 3, "file": 9, "line": 39}, "message": "expanded from macro '__cmp_once'"}, {"location": {"col": 26, "file": 9, "line": 34}, "message": "expanded from macro '__cmp'"}, {"location": {"col": 11, "file": 0, "line": 2153}, "message": "'?' condition is false"}, {"location": {"col": 19, "file": 9, "line": 51}, "message": "expanded from macro 'min'"}, {"location": {"col": 3, "file": 9, "line": 44}, "message": "expanded from macro '__careful_cmp'"}, {"location": {"col": 3, "file": 9, "line": 39}, "message": "expanded from macro '__cmp_once'"}, {"location": {"col": 26, "file": 9, "line": 34}, "message": "expanded from macro '__cmp'"}, {"location": {"col": 2, "file": 0, "line": 2157}, "message": "Taking false branch"}, {"location": {"col": 18, "file": 0, "line": 2186}, "message": "Assuming 'block' is < 'blocks'"}, {"location": {"col": 2, "file": 0, "line": 2186}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 9, "file": 0, "line": 2191}, "message": "'bmc_old' is non-null"}, {"location": {"col": 9, "file": 0, "line": 2191}, "message": "Left side of '&&' is true"}, {"location": {"col": 7, "file": 0, "line": 2193}, "message": "Assuming 'set' is not equal to 0"}, {"location": {"col": 3, "file": 0, "line": 2193}, "message": "Taking true branch"}, {"location": {"col": 8, "file": 0, "line": 2195}, "message": "Assuming the condition is true"}, {"location": {"col": 4, "file": 0, "line": 2195}, "message": "Taking true branch"}, {"location": {"col": 12, "file": 0, "line": 2200}, "message": "Assuming 'start' is >= 'end'"}, {"location": {"col": 5, "file": 0, "line": 2200}, "message": "Loop condition is false. Execution continues on line 2204"}, {"location": {"col": 5, "file": 0, "line": 2205}, "message": "Calling 'md_bitmap_count_page'"}, {"location": {"col": 2, "file": 0, "line": 1203}, "message": "Calling 'md_bitmap_checkfree'"}, {"location": {"col": 6, "file": 0, "line": 123}, "message": "Assuming field 'count' is 0"}, {"location": {"col": 2, "file": 0, "line": 123}, "message": "Taking false branch"}, {"location": {"col": 23, "file": 0, "line": 128}, "message": "Field 'hijacked' is 0"}, {"location": {"col": 2, "file": 0, "line": 128}, "message": "Taking false branch"}, {"location": {"col": 3, "file": 0, "line": 136}, "message": "Memory is released"}, {"location": {"col": 2, "file": 0, "line": 1203}, "message": "Returning; memory was released"}, {"location": {"col": 5, "file": 0, "line": 2205}, "message": "Returning; memory was released"}, {"location": {"col": 13, "file": 0, "line": 2208}, "message": "Use of memory after it is freed"}, {"location": {"col": 13, "file": 0, "line": 2208}, "message": "Use of memory after it is freed"}], "macros": [], "notes": [], "path": "/src/drivers/md/md-bitmap.c", "reportHash": "d639a511948e139a681feae8c9d2cba5", "checkerName": "clang-analyzer-unix.Malloc", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
