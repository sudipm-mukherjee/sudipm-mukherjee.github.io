<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/kernel/sched/topology.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n * Scheduler topology setup/handling methods\n */\n#include \"sched.h\"\n\nDEFINE_MUTEX(sched_domains_mutex);\n\n/* Protected by sched_domains_mutex: */\nstatic cpumask_var_t sched_domains_tmpmask;\nstatic cpumask_var_t sched_domains_tmpmask2;\n\n#ifdef CONFIG_SCHED_DEBUG\n\nstatic int __init sched_debug_setup(char *str)\n{\n\tsched_debug_enabled = true;\n\n\treturn 0;\n}\nearly_param(\"sched_debug\", sched_debug_setup);\n\nstatic inline bool sched_debug(void)\n{\n\treturn sched_debug_enabled;\n}\n\n#define SD_FLAG(_name, mflags) [__##_name] = { .meta_flags = mflags, .name = #_name },\nconst struct sd_flag_debug sd_flag_debug[] = {\n#include <linux/sched/sd_flags.h>\n};\n#undef SD_FLAG\n\nstatic int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level,\n\t\t\t\t  struct cpumask *groupmask)\n{\n\tstruct sched_group *group = sd->groups;\n\tunsigned long flags = sd->flags;\n\tunsigned int idx;\n\n\tcpumask_clear(groupmask);\n\n\tprintk(KERN_DEBUG \"%*s domain-%d: \", level, \"\", level);\n\tprintk(KERN_CONT \"span=%*pbl level=%s\\n\",\n\t       cpumask_pr_args(sched_domain_span(sd)), sd->name);\n\n\tif (!cpumask_test_cpu(cpu, sched_domain_span(sd))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->span does not contain CPU%d\\n\", cpu);\n\t}\n\tif (group && !cpumask_test_cpu(cpu, sched_group_span(group))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->groups does not contain CPU%d\\n\", cpu);\n\t}\n\n\tfor_each_set_bit(idx, &flags, __SD_FLAG_CNT) {\n\t\tunsigned int flag = BIT(idx);\n\t\tunsigned int meta_flags = sd_flag_debug[idx].meta_flags;\n\n\t\tif ((meta_flags & SDF_SHARED_CHILD) && sd->child &&\n\t\t    !(sd->child->flags & flag))\n\t\t\tprintk(KERN_ERR \"ERROR: flag %s set here but not in child\\n\",\n\t\t\t       sd_flag_debug[idx].name);\n\n\t\tif ((meta_flags & SDF_SHARED_PARENT) && sd->parent &&\n\t\t    !(sd->parent->flags & flag))\n\t\t\tprintk(KERN_ERR \"ERROR: flag %s set here but not in parent\\n\",\n\t\t\t       sd_flag_debug[idx].name);\n\t}\n\n\tprintk(KERN_DEBUG \"%*s groups:\", level + 1, \"\");\n\tdo {\n\t\tif (!group) {\n\t\t\tprintk(\"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: group is NULL\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!cpumask_weight(sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: empty group\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(sd->flags & SD_OVERLAP) &&\n\t\t    cpumask_intersects(groupmask, sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: repeated CPUs\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcpumask_or(groupmask, groupmask, sched_group_span(group));\n\n\t\tprintk(KERN_CONT \" %d:{ span=%*pbl\",\n\t\t\t\tgroup->sgc->id,\n\t\t\t\tcpumask_pr_args(sched_group_span(group)));\n\n\t\tif ((sd->flags & SD_OVERLAP) &&\n\t\t    !cpumask_equal(group_balance_mask(group), sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \" mask=%*pbl\",\n\t\t\t\tcpumask_pr_args(group_balance_mask(group)));\n\t\t}\n\n\t\tif (group->sgc->capacity != SCHED_CAPACITY_SCALE)\n\t\t\tprintk(KERN_CONT \" cap=%lu\", group->sgc->capacity);\n\n\t\tif (group == sd->groups && sd->child &&\n\t\t    !cpumask_equal(sched_domain_span(sd->child),\n\t\t\t\t   sched_group_span(group))) {\n\t\t\tprintk(KERN_ERR \"ERROR: domain->groups does not match domain->child\\n\");\n\t\t}\n\n\t\tprintk(KERN_CONT \" }\");\n\n\t\tgroup = group->next;\n\n\t\tif (group != sd->groups)\n\t\t\tprintk(KERN_CONT \",\");\n\n\t} while (group != sd->groups);\n\tprintk(KERN_CONT \"\\n\");\n\n\tif (!cpumask_equal(sched_domain_span(sd), groupmask))\n\t\tprintk(KERN_ERR \"ERROR: groups don't span domain->span\\n\");\n\n\tif (sd->parent &&\n\t    !cpumask_subset(groupmask, sched_domain_span(sd->parent)))\n\t\tprintk(KERN_ERR \"ERROR: parent span is not a superset of domain->span\\n\");\n\treturn 0;\n}\n\nstatic void sched_domain_debug(struct sched_domain *sd, int cpu)\n{\n\tint level = 0;\n\n\tif (!sched_debug_enabled)\n\t\treturn;\n\n\tif (!sd) {\n\t\tprintk(KERN_DEBUG \"CPU%d attaching NULL sched-domain.\\n\", cpu);\n\t\treturn;\n\t}\n\n\tprintk(KERN_DEBUG \"CPU%d attaching sched-domain(s):\\n\", cpu);\n\n\tfor (;;) {\n\t\tif (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask))\n\t\t\tbreak;\n\t\tlevel++;\n\t\tsd = sd->parent;\n\t\tif (!sd)\n\t\t\tbreak;\n\t}\n}\n#else /* !CONFIG_SCHED_DEBUG */\n\n# define sched_debug_enabled 0\n# define sched_domain_debug(sd, cpu) do { } while (0)\nstatic inline bool sched_debug(void)\n{\n\treturn false;\n}\n#endif /* CONFIG_SCHED_DEBUG */\n\n/* Generate a mask of SD flags with the SDF_NEEDS_GROUPS metaflag */\n#define SD_FLAG(name, mflags) (name * !!((mflags) & SDF_NEEDS_GROUPS)) |\nstatic const unsigned int SD_DEGENERATE_GROUPS_MASK =\n#include <linux/sched/sd_flags.h>\n0;\n#undef SD_FLAG\n\nstatic int sd_degenerate(struct sched_domain *sd)\n{\n\tif (cpumask_weight(sched_domain_span(sd)) == 1)\n\t\treturn 1;\n\n\t/* Following flags need at least 2 groups */\n\tif ((sd->flags & SD_DEGENERATE_GROUPS_MASK) &&\n\t    (sd->groups != sd->groups->next))\n\t\treturn 0;\n\n\t/* Following flags don't use groups */\n\tif (sd->flags & (SD_WAKE_AFFINE))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int\nsd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent)\n{\n\tunsigned long cflags = sd->flags, pflags = parent->flags;\n\n\tif (sd_degenerate(parent))\n\t\treturn 1;\n\n\tif (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent)))\n\t\treturn 0;\n\n\t/* Flags needing groups don't count if only 1 group in parent */\n\tif (parent->groups == parent->groups->next)\n\t\tpflags &= ~SD_DEGENERATE_GROUPS_MASK;\n\n\tif (~cflags & pflags)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n#if defined(CONFIG_ENERGY_MODEL) && defined(CONFIG_CPU_FREQ_GOV_SCHEDUTIL)\nDEFINE_STATIC_KEY_FALSE(sched_energy_present);\nunsigned int sysctl_sched_energy_aware = 1;\nDEFINE_MUTEX(sched_energy_mutex);\nbool sched_energy_update;\n\nvoid rebuild_sched_domains_energy(void)\n{\n\tmutex_lock(&sched_energy_mutex);\n\tsched_energy_update = true;\n\trebuild_sched_domains();\n\tsched_energy_update = false;\n\tmutex_unlock(&sched_energy_mutex);\n}\n\n#ifdef CONFIG_PROC_SYSCTL\nint sched_energy_aware_handler(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret, state;\n\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\tif (!ret && write) {\n\t\tstate = static_branch_unlikely(&sched_energy_present);\n\t\tif (state != sysctl_sched_energy_aware)\n\t\t\trebuild_sched_domains_energy();\n\t}\n\n\treturn ret;\n}\n#endif\n\nstatic void free_pd(struct perf_domain *pd)\n{\n\tstruct perf_domain *tmp;\n\n\twhile (pd) {\n\t\ttmp = pd->next;\n\t\tkfree(pd);\n\t\tpd = tmp;\n\t}\n}\n\nstatic struct perf_domain *find_pd(struct perf_domain *pd, int cpu)\n{\n\twhile (pd) {\n\t\tif (cpumask_test_cpu(cpu, perf_domain_span(pd)))\n\t\t\treturn pd;\n\t\tpd = pd->next;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct perf_domain *pd_init(int cpu)\n{\n\tstruct em_perf_domain *obj = em_cpu_get(cpu);\n\tstruct perf_domain *pd;\n\n\tif (!obj) {\n\t\tif (sched_debug())\n\t\t\tpr_info(\"%s: no EM found for CPU%d\\n\", __func__, cpu);\n\t\treturn NULL;\n\t}\n\n\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn NULL;\n\tpd->em_pd = obj;\n\n\treturn pd;\n}\n\nstatic void perf_domain_debug(const struct cpumask *cpu_map,\n\t\t\t\t\t\tstruct perf_domain *pd)\n{\n\tif (!sched_debug() || !pd)\n\t\treturn;\n\n\tprintk(KERN_DEBUG \"root_domain %*pbl:\", cpumask_pr_args(cpu_map));\n\n\twhile (pd) {\n\t\tprintk(KERN_CONT \" pd%d:{ cpus=%*pbl nr_pstate=%d }\",\n\t\t\t\tcpumask_first(perf_domain_span(pd)),\n\t\t\t\tcpumask_pr_args(perf_domain_span(pd)),\n\t\t\t\tem_pd_nr_perf_states(pd->em_pd));\n\t\tpd = pd->next;\n\t}\n\n\tprintk(KERN_CONT \"\\n\");\n}\n\nstatic void destroy_perf_domain_rcu(struct rcu_head *rp)\n{\n\tstruct perf_domain *pd;\n\n\tpd = container_of(rp, struct perf_domain, rcu);\n\tfree_pd(pd);\n}\n\nstatic void sched_energy_set(bool has_eas)\n{\n\tif (!has_eas && static_branch_unlikely(&sched_energy_present)) {\n\t\tif (sched_debug())\n\t\t\tpr_info(\"%s: stopping EAS\\n\", __func__);\n\t\tstatic_branch_disable_cpuslocked(&sched_energy_present);\n\t} else if (has_eas && !static_branch_unlikely(&sched_energy_present)) {\n\t\tif (sched_debug())\n\t\t\tpr_info(\"%s: starting EAS\\n\", __func__);\n\t\tstatic_branch_enable_cpuslocked(&sched_energy_present);\n\t}\n}\n\n/*\n * EAS can be used on a root domain if it meets all the following conditions:\n *    1. an Energy Model (EM) is available;\n *    2. the SD_ASYM_CPUCAPACITY flag is set in the sched_domain hierarchy.\n *    3. no SMT is detected.\n *    4. the EM complexity is low enough to keep scheduling overheads low;\n *    5. schedutil is driving the frequency of all CPUs of the rd;\n *    6. frequency invariance support is present;\n *\n * The complexity of the Energy Model is defined as:\n *\n *              C = nr_pd * (nr_cpus + nr_ps)\n *\n * with parameters defined as:\n *  - nr_pd:    the number of performance domains\n *  - nr_cpus:  the number of CPUs\n *  - nr_ps:    the sum of the number of performance states of all performance\n *              domains (for example, on a system with 2 performance domains,\n *              with 10 performance states each, nr_ps = 2 * 10 = 20).\n *\n * It is generally not a good idea to use such a model in the wake-up path on\n * very complex platforms because of the associated scheduling overheads. The\n * arbitrary constraint below prevents that. It makes EAS usable up to 16 CPUs\n * with per-CPU DVFS and less than 8 performance states each, for example.\n */\n#define EM_MAX_COMPLEXITY 2048\n\nextern struct cpufreq_governor schedutil_gov;\nstatic bool build_perf_domains(const struct cpumask *cpu_map)\n{\n\tint i, nr_pd = 0, nr_ps = 0, nr_cpus = cpumask_weight(cpu_map);\n\tstruct perf_domain *pd = NULL, *tmp;\n\tint cpu = cpumask_first(cpu_map);\n\tstruct root_domain *rd = cpu_rq(cpu)->rd;\n\tstruct cpufreq_policy *policy;\n\tstruct cpufreq_governor *gov;\n\n\tif (!sysctl_sched_energy_aware)\n\t\tgoto free;\n\n\t/* EAS is enabled for asymmetric CPU capacity topologies. */\n\tif (!per_cpu(sd_asym_cpucapacity, cpu)) {\n\t\tif (sched_debug()) {\n\t\t\tpr_info(\"rd %*pbl: CPUs do not have asymmetric capacities\\n\",\n\t\t\t\t\tcpumask_pr_args(cpu_map));\n\t\t}\n\t\tgoto free;\n\t}\n\n\t/* EAS definitely does *not* handle SMT */\n\tif (sched_smt_active()) {\n\t\tpr_warn(\"rd %*pbl: Disabling EAS, SMT is not supported\\n\",\n\t\t\tcpumask_pr_args(cpu_map));\n\t\tgoto free;\n\t}\n\n\tif (!arch_scale_freq_invariant()) {\n\t\tif (sched_debug()) {\n\t\t\tpr_warn(\"rd %*pbl: Disabling EAS: frequency-invariant load tracking not yet supported\",\n\t\t\t\tcpumask_pr_args(cpu_map));\n\t\t}\n\t\tgoto free;\n\t}\n\n\tfor_each_cpu(i, cpu_map) {\n\t\t/* Skip already covered CPUs. */\n\t\tif (find_pd(pd, i))\n\t\t\tcontinue;\n\n\t\t/* Do not attempt EAS if schedutil is not being used. */\n\t\tpolicy = cpufreq_cpu_get(i);\n\t\tif (!policy)\n\t\t\tgoto free;\n\t\tgov = policy->governor;\n\t\tcpufreq_cpu_put(policy);\n\t\tif (gov != &schedutil_gov) {\n\t\t\tif (rd->pd)\n\t\t\t\tpr_warn(\"rd %*pbl: Disabling EAS, schedutil is mandatory\\n\",\n\t\t\t\t\t\tcpumask_pr_args(cpu_map));\n\t\t\tgoto free;\n\t\t}\n\n\t\t/* Create the new pd and add it to the local list. */\n\t\ttmp = pd_init(i);\n\t\tif (!tmp)\n\t\t\tgoto free;\n\t\ttmp->next = pd;\n\t\tpd = tmp;\n\n\t\t/*\n\t\t * Count performance domains and performance states for the\n\t\t * complexity check.\n\t\t */\n\t\tnr_pd++;\n\t\tnr_ps += em_pd_nr_perf_states(pd->em_pd);\n\t}\n\n\t/* Bail out if the Energy Model complexity is too high. */\n\tif (nr_pd * (nr_ps + nr_cpus) > EM_MAX_COMPLEXITY) {\n\t\tWARN(1, \"rd %*pbl: Failed to start EAS, EM complexity is too high\\n\",\n\t\t\t\t\t\tcpumask_pr_args(cpu_map));\n\t\tgoto free;\n\t}\n\n\tperf_domain_debug(cpu_map, pd);\n\n\t/* Attach the new list of performance domains to the root domain. */\n\ttmp = rd->pd;\n\trcu_assign_pointer(rd->pd, pd);\n\tif (tmp)\n\t\tcall_rcu(&tmp->rcu, destroy_perf_domain_rcu);\n\n\treturn !!pd;\n\nfree:\n\tfree_pd(pd);\n\ttmp = rd->pd;\n\trcu_assign_pointer(rd->pd, NULL);\n\tif (tmp)\n\t\tcall_rcu(&tmp->rcu, destroy_perf_domain_rcu);\n\n\treturn false;\n}\n#else\nstatic void free_pd(struct perf_domain *pd) { }\n#endif /* CONFIG_ENERGY_MODEL && CONFIG_CPU_FREQ_GOV_SCHEDUTIL*/\n\nstatic void free_rootdomain(struct rcu_head *rcu)\n{\n\tstruct root_domain *rd = container_of(rcu, struct root_domain, rcu);\n\n\tcpupri_cleanup(&rd->cpupri);\n\tcpudl_cleanup(&rd->cpudl);\n\tfree_cpumask_var(rd->dlo_mask);\n\tfree_cpumask_var(rd->rto_mask);\n\tfree_cpumask_var(rd->online);\n\tfree_cpumask_var(rd->span);\n\tfree_pd(rd->pd);\n\tkfree(rd);\n}\n\nvoid rq_attach_root(struct rq *rq, struct root_domain *rd)\n{\n\tstruct root_domain *old_rd = NULL;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\n\tif (rq->rd) {\n\t\told_rd = rq->rd;\n\n\t\tif (cpumask_test_cpu(rq->cpu, old_rd->online))\n\t\t\tset_rq_offline(rq);\n\n\t\tcpumask_clear_cpu(rq->cpu, old_rd->span);\n\n\t\t/*\n\t\t * If we dont want to free the old_rd yet then\n\t\t * set old_rd to NULL to skip the freeing later\n\t\t * in this function:\n\t\t */\n\t\tif (!atomic_dec_and_test(&old_rd->refcount))\n\t\t\told_rd = NULL;\n\t}\n\n\tatomic_inc(&rd->refcount);\n\trq->rd = rd;\n\n\tcpumask_set_cpu(rq->cpu, rd->span);\n\tif (cpumask_test_cpu(rq->cpu, cpu_active_mask))\n\t\tset_rq_online(rq);\n\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n\n\tif (old_rd)\n\t\tcall_rcu(&old_rd->rcu, free_rootdomain);\n}\n\nvoid sched_get_rd(struct root_domain *rd)\n{\n\tatomic_inc(&rd->refcount);\n}\n\nvoid sched_put_rd(struct root_domain *rd)\n{\n\tif (!atomic_dec_and_test(&rd->refcount))\n\t\treturn;\n\n\tcall_rcu(&rd->rcu, free_rootdomain);\n}\n\nstatic int init_rootdomain(struct root_domain *rd)\n{\n\tif (!zalloc_cpumask_var(&rd->span, GFP_KERNEL))\n\t\tgoto out;\n\tif (!zalloc_cpumask_var(&rd->online, GFP_KERNEL))\n\t\tgoto free_span;\n\tif (!zalloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL))\n\t\tgoto free_online;\n\tif (!zalloc_cpumask_var(&rd->rto_mask, GFP_KERNEL))\n\t\tgoto free_dlo_mask;\n\n#ifdef HAVE_RT_PUSH_IPI\n\trd->rto_cpu = -1;\n\traw_spin_lock_init(&rd->rto_lock);\n\tinit_irq_work(&rd->rto_push_work, rto_push_irq_work_func);\n#endif\n\n\trd->visit_gen = 0;\n\tinit_dl_bw(&rd->dl_bw);\n\tif (cpudl_init(&rd->cpudl) != 0)\n\t\tgoto free_rto_mask;\n\n\tif (cpupri_init(&rd->cpupri) != 0)\n\t\tgoto free_cpudl;\n\treturn 0;\n\nfree_cpudl:\n\tcpudl_cleanup(&rd->cpudl);\nfree_rto_mask:\n\tfree_cpumask_var(rd->rto_mask);\nfree_dlo_mask:\n\tfree_cpumask_var(rd->dlo_mask);\nfree_online:\n\tfree_cpumask_var(rd->online);\nfree_span:\n\tfree_cpumask_var(rd->span);\nout:\n\treturn -ENOMEM;\n}\n\n/*\n * By default the system creates a single root-domain with all CPUs as\n * members (mimicking the global state we have today).\n */\nstruct root_domain def_root_domain;\n\nvoid init_defrootdomain(void)\n{\n\tinit_rootdomain(&def_root_domain);\n\n\tatomic_set(&def_root_domain.refcount, 1);\n}\n\nstatic struct root_domain *alloc_rootdomain(void)\n{\n\tstruct root_domain *rd;\n\n\trd = kzalloc(sizeof(*rd), GFP_KERNEL);\n\tif (!rd)\n\t\treturn NULL;\n\n\tif (init_rootdomain(rd) != 0) {\n\t\tkfree(rd);\n\t\treturn NULL;\n\t}\n\n\treturn rd;\n}\n\nstatic void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\n\tif (!sg)\n\t\treturn;\n\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\n\t\tif (atomic_dec_and_test(&sg->ref))\n\t\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}\n\nstatic void destroy_sched_domain(struct sched_domain *sd)\n{\n\t/*\n\t * A normal sched domain may have multiple group references, an\n\t * overlapping domain, having private groups, only one.  Iterate,\n\t * dropping group/capacity references, freeing where none remain.\n\t */\n\tfree_sched_groups(sd->groups, 1);\n\n\tif (sd->shared && atomic_dec_and_test(&sd->shared->ref))\n\t\tkfree(sd->shared);\n\tkfree(sd);\n}\n\nstatic void destroy_sched_domains_rcu(struct rcu_head *rcu)\n{\n\tstruct sched_domain *sd = container_of(rcu, struct sched_domain, rcu);\n\n\twhile (sd) {\n\t\tstruct sched_domain *parent = sd->parent;\n\t\tdestroy_sched_domain(sd);\n\t\tsd = parent;\n\t}\n}\n\nstatic void destroy_sched_domains(struct sched_domain *sd)\n{\n\tif (sd)\n\t\tcall_rcu(&sd->rcu, destroy_sched_domains_rcu);\n}\n\n/*\n * Keep a special pointer to the highest sched_domain that has\n * SD_SHARE_PKG_RESOURCE set (Last Level Cache Domain) for this\n * allows us to avoid some pointer chasing select_idle_sibling().\n *\n * Also keep a unique ID per domain (we use the first CPU number in\n * the cpumask of the domain), this allows us to quickly tell if\n * two CPUs are in the same cache domain, see cpus_share_cache().\n */\nDEFINE_PER_CPU(struct sched_domain __rcu *, sd_llc);\nDEFINE_PER_CPU(int, sd_llc_size);\nDEFINE_PER_CPU(int, sd_llc_id);\nDEFINE_PER_CPU(struct sched_domain_shared __rcu *, sd_llc_shared);\nDEFINE_PER_CPU(struct sched_domain __rcu *, sd_numa);\nDEFINE_PER_CPU(struct sched_domain __rcu *, sd_asym_packing);\nDEFINE_PER_CPU(struct sched_domain __rcu *, sd_asym_cpucapacity);\nDEFINE_STATIC_KEY_FALSE(sched_asym_cpucapacity);\n\nstatic void update_top_cache_domain(int cpu)\n{\n\tstruct sched_domain_shared *sds = NULL;\n\tstruct sched_domain *sd;\n\tint id = cpu;\n\tint size = 1;\n\n\tsd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES);\n\tif (sd) {\n\t\tid = cpumask_first(sched_domain_span(sd));\n\t\tsize = cpumask_weight(sched_domain_span(sd));\n\t\tsds = sd->shared;\n\t}\n\n\trcu_assign_pointer(per_cpu(sd_llc, cpu), sd);\n\tper_cpu(sd_llc_size, cpu) = size;\n\tper_cpu(sd_llc_id, cpu) = id;\n\trcu_assign_pointer(per_cpu(sd_llc_shared, cpu), sds);\n\n\tsd = lowest_flag_domain(cpu, SD_NUMA);\n\trcu_assign_pointer(per_cpu(sd_numa, cpu), sd);\n\n\tsd = highest_flag_domain(cpu, SD_ASYM_PACKING);\n\trcu_assign_pointer(per_cpu(sd_asym_packing, cpu), sd);\n\n\tsd = lowest_flag_domain(cpu, SD_ASYM_CPUCAPACITY);\n\trcu_assign_pointer(per_cpu(sd_asym_cpucapacity, cpu), sd);\n}\n\n/*\n * Attach the domain 'sd' to 'cpu' as its base domain. Callers must\n * hold the hotplug lock.\n */\nstatic void\ncpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct sched_domain *tmp;\n\tint numa_distance = 0;\n\n\t/* Remove the sched domains which do not contribute to scheduling. */\n\tfor (tmp = sd; tmp; ) {\n\t\tstruct sched_domain *parent = tmp->parent;\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tif (sd_parent_degenerate(tmp, parent)) {\n\t\t\ttmp->parent = parent->parent;\n\t\t\tif (parent->parent)\n\t\t\t\tparent->parent->child = tmp;\n\t\t\t/*\n\t\t\t * Transfer SD_PREFER_SIBLING down in case of a\n\t\t\t * degenerate parent; the spans match for this\n\t\t\t * so the property transfers.\n\t\t\t */\n\t\t\tif (parent->flags & SD_PREFER_SIBLING)\n\t\t\t\ttmp->flags |= SD_PREFER_SIBLING;\n\t\t\tdestroy_sched_domain(parent);\n\t\t} else\n\t\t\ttmp = tmp->parent;\n\t}\n\n\tif (sd && sd_degenerate(sd)) {\n\t\ttmp = sd;\n\t\tsd = sd->parent;\n\t\tdestroy_sched_domain(tmp);\n\t\tif (sd)\n\t\t\tsd->child = NULL;\n\t}\n\n\tfor (tmp = sd; tmp; tmp = tmp->parent)\n\t\tnuma_distance += !!(tmp->flags & SD_NUMA);\n\n\tsched_domain_debug(sd, cpu);\n\n\trq_attach_root(rq, rd);\n\ttmp = rq->sd;\n\trcu_assign_pointer(rq->sd, sd);\n\tdirty_sched_domain_sysctl(cpu);\n\tdestroy_sched_domains(tmp);\n\n\tupdate_top_cache_domain(cpu);\n}\n\nstruct s_data {\n\tstruct sched_domain * __percpu *sd;\n\tstruct root_domain\t*rd;\n};\n\nenum s_alloc {\n\tsa_rootdomain,\n\tsa_sd,\n\tsa_sd_storage,\n\tsa_none,\n};\n\n/*\n * Return the canonical balance CPU for this group, this is the first CPU\n * of this group that's also in the balance mask.\n *\n * The balance mask are all those CPUs that could actually end up at this\n * group. See build_balance_mask().\n *\n * Also see should_we_balance().\n */\nint group_balance_cpu(struct sched_group *sg)\n{\n\treturn cpumask_first(group_balance_mask(sg));\n}\n\n\n/*\n * NUMA topology (first read the regular topology blurb below)\n *\n * Given a node-distance table, for example:\n *\n *   node   0   1   2   3\n *     0:  10  20  30  20\n *     1:  20  10  20  30\n *     2:  30  20  10  20\n *     3:  20  30  20  10\n *\n * which represents a 4 node ring topology like:\n *\n *   0 ----- 1\n *   |       |\n *   |       |\n *   |       |\n *   3 ----- 2\n *\n * We want to construct domains and groups to represent this. The way we go\n * about doing this is to build the domains on 'hops'. For each NUMA level we\n * construct the mask of all nodes reachable in @level hops.\n *\n * For the above NUMA topology that gives 3 levels:\n *\n * NUMA-2\t0-3\t\t0-3\t\t0-3\t\t0-3\n *  groups:\t{0-1,3},{1-3}\t{0-2},{0,2-3}\t{1-3},{0-1,3}\t{0,2-3},{0-2}\n *\n * NUMA-1\t0-1,3\t\t0-2\t\t1-3\t\t0,2-3\n *  groups:\t{0},{1},{3}\t{0},{1},{2}\t{1},{2},{3}\t{0},{2},{3}\n *\n * NUMA-0\t0\t\t1\t\t2\t\t3\n *\n *\n * As can be seen; things don't nicely line up as with the regular topology.\n * When we iterate a domain in child domain chunks some nodes can be\n * represented multiple times -- hence the \"overlap\" naming for this part of\n * the topology.\n *\n * In order to minimize this overlap, we only build enough groups to cover the\n * domain. For instance Node-0 NUMA-2 would only get groups: 0-1,3 and 1-3.\n *\n * Because:\n *\n *  - the first group of each domain is its child domain; this\n *    gets us the first 0-1,3\n *  - the only uncovered node is 2, who's child domain is 1-3.\n *\n * However, because of the overlap, computing a unique CPU for each group is\n * more complicated. Consider for instance the groups of NODE-1 NUMA-2, both\n * groups include the CPUs of Node-0, while those CPUs would not in fact ever\n * end up at those groups (they would end up in group: 0-1,3).\n *\n * To correct this we have to introduce the group balance mask. This mask\n * will contain those CPUs in the group that can reach this group given the\n * (child) domain tree.\n *\n * With this we can once again compute balance_cpu and sched_group_capacity\n * relations.\n *\n * XXX include words on how balance_cpu is unique and therefore can be\n * used for sched_group_capacity links.\n *\n *\n * Another 'interesting' topology is:\n *\n *   node   0   1   2   3\n *     0:  10  20  20  30\n *     1:  20  10  20  20\n *     2:  20  20  10  20\n *     3:  30  20  20  10\n *\n * Which looks a little like:\n *\n *   0 ----- 1\n *   |     / |\n *   |   /   |\n *   | /     |\n *   2 ----- 3\n *\n * This topology is asymmetric, nodes 1,2 are fully connected, but nodes 0,3\n * are not.\n *\n * This leads to a few particularly weird cases where the sched_domain's are\n * not of the same number for each CPU. Consider:\n *\n * NUMA-2\t0-3\t\t\t\t\t\t0-3\n *  groups:\t{0-2},{1-3}\t\t\t\t\t{1-3},{0-2}\n *\n * NUMA-1\t0-2\t\t0-3\t\t0-3\t\t1-3\n *\n * NUMA-0\t0\t\t1\t\t2\t\t3\n *\n */\n\n\n/*\n * Build the balance mask; it contains only those CPUs that can arrive at this\n * group and should be considered to continue balancing.\n *\n * We do this during the group creation pass, therefore the group information\n * isn't complete yet, however since each group represents a (child) domain we\n * can fully construct this using the sched_domain bits (which are already\n * complete).\n */\nstatic void\nbuild_balance_mask(struct sched_domain *sd, struct sched_group *sg, struct cpumask *mask)\n{\n\tconst struct cpumask *sg_span = sched_group_span(sg);\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(mask);\n\n\tfor_each_cpu(i, sg_span) {\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Can happen in the asymmetric case, where these siblings are\n\t\t * unused. The mask will not be empty because those CPUs that\n\t\t * do have the top domain _should_ span the domain.\n\t\t */\n\t\tif (!sibling->child)\n\t\t\tcontinue;\n\n\t\t/* If we would not end up here, we can't continue from here */\n\t\tif (!cpumask_equal(sg_span, sched_domain_span(sibling->child)))\n\t\t\tcontinue;\n\n\t\tcpumask_set_cpu(i, mask);\n\t}\n\n\t/* We must not have empty masks here */\n\tWARN_ON_ONCE(cpumask_empty(mask));\n}\n\n/*\n * XXX: This creates per-node group entries; since the load-balancer will\n * immediately access remote memory to construct this group's load-balance\n * statistics having the groups node local is of dubious benefit.\n */\nstatic struct sched_group *\nbuild_group_from_child_sched_domain(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *sg;\n\tstruct cpumask *sg_span;\n\n\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\n\tif (!sg)\n\t\treturn NULL;\n\n\tsg_span = sched_group_span(sg);\n\tif (sd->child)\n\t\tcpumask_copy(sg_span, sched_domain_span(sd->child));\n\telse\n\t\tcpumask_copy(sg_span, sched_domain_span(sd));\n\n\tatomic_inc(&sg->ref);\n\treturn sg;\n}\n\nstatic void init_overlap_sched_group(struct sched_domain *sd,\n\t\t\t\t     struct sched_group *sg)\n{\n\tstruct cpumask *mask = sched_domains_tmpmask2;\n\tstruct sd_data *sdd = sd->private;\n\tstruct cpumask *sg_span;\n\tint cpu;\n\n\tbuild_balance_mask(sd, sg, mask);\n\tcpu = cpumask_first_and(sched_group_span(sg), mask);\n\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\tif (atomic_inc_return(&sg->sgc->ref) == 1)\n\t\tcpumask_copy(group_balance_mask(sg), mask);\n\telse\n\t\tWARN_ON_ONCE(!cpumask_equal(group_balance_mask(sg), mask));\n\n\t/*\n\t * Initialize sgc->capacity such that even if we mess up the\n\t * domains and no possible iteration will get us here, we won't\n\t * die on a /0 trap.\n\t */\n\tsg_span = sched_group_span(sg);\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sg_span);\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n}\n\nstatic struct sched_domain *\nfind_descended_sibling(struct sched_domain *sd, struct sched_domain *sibling)\n{\n\t/*\n\t * The proper descendant would be the one whose child won't span out\n\t * of sd\n\t */\n\twhile (sibling->child &&\n\t       !cpumask_subset(sched_domain_span(sibling->child),\n\t\t\t       sched_domain_span(sd)))\n\t\tsibling = sibling->child;\n\n\t/*\n\t * As we are referencing sgc across different topology level, we need\n\t * to go down to skip those sched_domains which don't contribute to\n\t * scheduling because they will be degenerated in cpu_attach_domain\n\t */\n\twhile (sibling->child &&\n\t       cpumask_equal(sched_domain_span(sibling->child),\n\t\t\t     sched_domain_span(sibling)))\n\t\tsibling = sibling->child;\n\n\treturn sibling;\n}\n\nstatic int\nbuild_overlap_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL, *sg;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered = sched_domains_tmpmask;\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct cpumask *sg_span;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Asymmetric node setups can result in situations where the\n\t\t * domain tree is of unequal depth, make sure to skip domains\n\t\t * that already cover the entire range.\n\t\t *\n\t\t * In that case build_sched_domains() will have terminated the\n\t\t * iteration early and our sibling sd spans will be empty.\n\t\t * Domains should always include the CPU they're built on, so\n\t\t * check that.\n\t\t */\n\t\tif (!cpumask_test_cpu(i, sched_domain_span(sibling)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Usually we build sched_group by sibling's child sched_domain\n\t\t * But for machines whose NUMA diameter are 3 or above, we move\n\t\t * to build sched_group by sibling's proper descendant's child\n\t\t * domain because sibling's child sched_domain will span out of\n\t\t * the sched_domain being built as below.\n\t\t *\n\t\t * Smallest diameter=3 topology is:\n\t\t *\n\t\t *   node   0   1   2   3\n\t\t *     0:  10  20  30  40\n\t\t *     1:  20  10  20  30\n\t\t *     2:  30  20  10  20\n\t\t *     3:  40  30  20  10\n\t\t *\n\t\t *   0 --- 1 --- 2 --- 3\n\t\t *\n\t\t * NUMA-3       0-3             N/A             N/A             0-3\n\t\t *  groups:     {0-2},{1-3}                                     {1-3},{0-2}\n\t\t *\n\t\t * NUMA-2       0-2             0-3             0-3             1-3\n\t\t *  groups:     {0-1},{1-3}     {0-2},{2-3}     {1-3},{0-1}     {2-3},{0-2}\n\t\t *\n\t\t * NUMA-1       0-1             0-2             1-3             2-3\n\t\t *  groups:     {0},{1}         {1},{2},{0}     {2},{3},{1}     {3},{2}\n\t\t *\n\t\t * NUMA-0       0               1               2               3\n\t\t *\n\t\t * The NUMA-2 groups for nodes 0 and 3 are obviously buggered, as the\n\t\t * group span isn't a subset of the domain span.\n\t\t */\n\t\tif (sibling->child &&\n\t\t    !cpumask_subset(sched_domain_span(sibling->child), span))\n\t\t\tsibling = find_descended_sibling(sd, sibling);\n\n\t\tsg = build_group_from_child_sched_domain(sibling, cpu);\n\t\tif (!sg)\n\t\t\tgoto fail;\n\n\t\tsg_span = sched_group_span(sg);\n\t\tcpumask_or(covered, covered, sg_span);\n\n\t\tinit_overlap_sched_group(sibling, sg);\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t\tlast->next = first;\n\t}\n\tsd->groups = first;\n\n\treturn 0;\n\nfail:\n\tfree_sched_groups(first, 0);\n\n\treturn -ENOMEM;\n}\n\n\n/*\n * Package topology (also see the load-balance blurb in fair.c)\n *\n * The scheduler builds a tree structure to represent a number of important\n * topology features. By default (default_topology[]) these include:\n *\n *  - Simultaneous multithreading (SMT)\n *  - Multi-Core Cache (MC)\n *  - Package (DIE)\n *\n * Where the last one more or less denotes everything up to a NUMA node.\n *\n * The tree consists of 3 primary data structures:\n *\n *\tsched_domain -> sched_group -> sched_group_capacity\n *\t    ^ ^             ^ ^\n *          `-'             `-'\n *\n * The sched_domains are per-CPU and have a two way link (parent & child) and\n * denote the ever growing mask of CPUs belonging to that level of topology.\n *\n * Each sched_domain has a circular (double) linked list of sched_group's, each\n * denoting the domains of the level below (or individual CPUs in case of the\n * first domain level). The sched_group linked by a sched_domain includes the\n * CPU of that sched_domain [*].\n *\n * Take for instance a 2 threaded, 2 core, 2 cache cluster part:\n *\n * CPU   0   1   2   3   4   5   6   7\n *\n * DIE  [                             ]\n * MC   [             ] [             ]\n * SMT  [     ] [     ] [     ] [     ]\n *\n *  - or -\n *\n * DIE  0-7 0-7 0-7 0-7 0-7 0-7 0-7 0-7\n * MC\t0-3 0-3 0-3 0-3 4-7 4-7 4-7 4-7\n * SMT  0-1 0-1 2-3 2-3 4-5 4-5 6-7 6-7\n *\n * CPU   0   1   2   3   4   5   6   7\n *\n * One way to think about it is: sched_domain moves you up and down among these\n * topology levels, while sched_group moves you sideways through it, at child\n * domain granularity.\n *\n * sched_group_capacity ensures each unique sched_group has shared storage.\n *\n * There are two related construction problems, both require a CPU that\n * uniquely identify each group (for a given domain):\n *\n *  - The first is the balance_cpu (see should_we_balance() and the\n *    load-balance blub in fair.c); for each group we only want 1 CPU to\n *    continue balancing at a higher domain.\n *\n *  - The second is the sched_group_capacity; we want all identical groups\n *    to share a single sched_group_capacity.\n *\n * Since these topologies are exclusive by construction. That is, its\n * impossible for an SMT thread to belong to multiple cores, and cores to\n * be part of multiple caches. There is a very clear and unique location\n * for each CPU in the hierarchy.\n *\n * Therefore computing a unique CPU for each group is trivial (the iteration\n * mask is redundant and set all 1s; all CPUs in a group will end up at _that_\n * group), we can simply pick the first CPU in each group.\n *\n *\n * [*] in other words, the first group of each domain is its child domain.\n */\n\nstatic struct sched_group *get_group(int cpu, struct sd_data *sdd)\n{\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tstruct sched_domain *child = sd->child;\n\tstruct sched_group *sg;\n\tbool already_visited;\n\n\tif (child)\n\t\tcpu = cpumask_first(sched_domain_span(child));\n\n\tsg = *per_cpu_ptr(sdd->sg, cpu);\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\n\t/* Increase refcounts for claim_allocations: */\n\talready_visited = atomic_inc_return(&sg->ref) > 1;\n\t/* sgc visits should follow a similar trend as sg */\n\tWARN_ON(already_visited != (atomic_inc_return(&sg->sgc->ref) > 1));\n\n\t/* If we have already visited that group, it's already initialized. */\n\tif (already_visited)\n\t\treturn sg;\n\n\tif (child) {\n\t\tcpumask_copy(sched_group_span(sg), sched_domain_span(child));\n\t\tcpumask_copy(group_balance_mask(sg), sched_group_span(sg));\n\t} else {\n\t\tcpumask_set_cpu(cpu, sched_group_span(sg));\n\t\tcpumask_set_cpu(cpu, group_balance_mask(sg));\n\t}\n\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sched_group_span(sg));\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n\n\treturn sg;\n}\n\n/*\n * build_sched_groups will build a circular linked list of the groups\n * covered by the given span, will set each group's ->cpumask correctly,\n * and will initialize their ->sgc.\n *\n * Assumes the sched_domain tree is fully constructed\n */\nstatic int\nbuild_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL;\n\tstruct sd_data *sdd = sd->private;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered;\n\tint i;\n\n\tlockdep_assert_held(&sched_domains_mutex);\n\tcovered = sched_domains_tmpmask;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct sched_group *sg;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsg = get_group(i, sdd);\n\n\t\tcpumask_or(covered, covered, sched_group_span(sg));\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t}\n\tlast->next = first;\n\tsd->groups = first;\n\n\treturn 0;\n}\n\n/*\n * Initialize sched groups cpu_capacity.\n *\n * cpu_capacity indicates the capacity of sched group, which is used while\n * distributing the load between different sched groups in a sched domain.\n * Typically cpu_capacity for all the groups in a sched domain will be same\n * unless there are asymmetries in the topology. If there are asymmetries,\n * group having more cpu_capacity will pickup more load compared to the\n * group having less cpu_capacity.\n */\nstatic void init_sched_groups_capacity(int cpu, struct sched_domain *sd)\n{\n\tstruct sched_group *sg = sd->groups;\n\n\tWARN_ON(!sg);\n\n\tdo {\n\t\tint cpu, max_cpu = -1;\n\n\t\tsg->group_weight = cpumask_weight(sched_group_span(sg));\n\n\t\tif (!(sd->flags & SD_ASYM_PACKING))\n\t\t\tgoto next;\n\n\t\tfor_each_cpu(cpu, sched_group_span(sg)) {\n\t\t\tif (max_cpu < 0)\n\t\t\t\tmax_cpu = cpu;\n\t\t\telse if (sched_asym_prefer(cpu, max_cpu))\n\t\t\t\tmax_cpu = cpu;\n\t\t}\n\t\tsg->asym_prefer_cpu = max_cpu;\n\nnext:\n\t\tsg = sg->next;\n\t} while (sg != sd->groups);\n\n\tif (cpu != group_balance_cpu(sg))\n\t\treturn;\n\n\tupdate_group_capacity(sd, cpu);\n}\n\n/*\n * Initializers for schedule domains\n * Non-inlined to reduce accumulated stack pressure in build_sched_domains()\n */\n\nstatic int default_relax_domain_level = -1;\nint sched_domain_level_max;\n\nstatic int __init setup_relax_domain_level(char *str)\n{\n\tif (kstrtoint(str, 0, &default_relax_domain_level))\n\t\tpr_warn(\"Unable to set relax_domain_level\\n\");\n\n\treturn 1;\n}\n__setup(\"relax_domain_level=\", setup_relax_domain_level);\n\nstatic void set_domain_attribute(struct sched_domain *sd,\n\t\t\t\t struct sched_domain_attr *attr)\n{\n\tint request;\n\n\tif (!attr || attr->relax_domain_level < 0) {\n\t\tif (default_relax_domain_level < 0)\n\t\t\treturn;\n\t\trequest = default_relax_domain_level;\n\t} else\n\t\trequest = attr->relax_domain_level;\n\n\tif (sd->level > request) {\n\t\t/* Turn off idle balance on this domain: */\n\t\tsd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);\n\t}\n}\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic void __free_domain_allocs(struct s_data *d, enum s_alloc what,\n\t\t\t\t const struct cpumask *cpu_map)\n{\n\tswitch (what) {\n\tcase sa_rootdomain:\n\t\tif (!atomic_read(&d->rd->refcount))\n\t\t\tfree_rootdomain(&d->rd->rcu);\n\t\tfallthrough;\n\tcase sa_sd:\n\t\tfree_percpu(d->sd);\n\t\tfallthrough;\n\tcase sa_sd_storage:\n\t\t__sdt_free(cpu_map);\n\t\tfallthrough;\n\tcase sa_none:\n\t\tbreak;\n\t}\n}\n\nstatic enum s_alloc\n__visit_domain_allocation_hell(struct s_data *d, const struct cpumask *cpu_map)\n{\n\tmemset(d, 0, sizeof(*d));\n\n\tif (__sdt_alloc(cpu_map))\n\t\treturn sa_sd_storage;\n\td->sd = alloc_percpu(struct sched_domain *);\n\tif (!d->sd)\n\t\treturn sa_sd_storage;\n\td->rd = alloc_rootdomain();\n\tif (!d->rd)\n\t\treturn sa_sd;\n\n\treturn sa_rootdomain;\n}\n\n/*\n * NULL the sd_data elements we've used to build the sched_domain and\n * sched_group structure so that the subsequent __free_domain_allocs()\n * will not free the data we're using.\n */\nstatic void claim_allocations(int cpu, struct sched_domain *sd)\n{\n\tstruct sd_data *sdd = sd->private;\n\n\tWARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd);\n\t*per_cpu_ptr(sdd->sd, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sds, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sds, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sg, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sgc, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sgc, cpu) = NULL;\n}\n\n#ifdef CONFIG_NUMA\nenum numa_topology_type sched_numa_topology_type;\n\nstatic int\t\t\tsched_domains_numa_levels;\nstatic int\t\t\tsched_domains_curr_level;\n\nint\t\t\t\tsched_max_numa_distance;\nstatic int\t\t\t*sched_domains_numa_distance;\nstatic struct cpumask\t\t***sched_domains_numa_masks;\nint __read_mostly\t\tnode_reclaim_distance = RECLAIM_DISTANCE;\n#endif\n\n/*\n * SD_flags allowed in topology descriptions.\n *\n * These flags are purely descriptive of the topology and do not prescribe\n * behaviour. Behaviour is artificial and mapped in the below sd_init()\n * function:\n *\n *   SD_SHARE_CPUCAPACITY   - describes SMT topologies\n *   SD_SHARE_PKG_RESOURCES - describes shared caches\n *   SD_NUMA                - describes NUMA topologies\n *\n * Odd one out, which beside describing the topology has a quirk also\n * prescribes the desired behaviour that goes along with it:\n *\n *   SD_ASYM_PACKING        - describes SMT quirks\n */\n#define TOPOLOGY_SD_FLAGS\t\t\\\n\t(SD_SHARE_CPUCAPACITY\t|\t\\\n\t SD_SHARE_PKG_RESOURCES |\t\\\n\t SD_NUMA\t\t|\t\\\n\t SD_ASYM_PACKING)\n\nstatic struct sched_domain *\nsd_init(struct sched_domain_topology_level *tl,\n\tconst struct cpumask *cpu_map,\n\tstruct sched_domain *child, int dflags, int cpu)\n{\n\tstruct sd_data *sdd = &tl->data;\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tint sd_id, sd_weight, sd_flags = 0;\n\n#ifdef CONFIG_NUMA\n\t/*\n\t * Ugly hack to pass state to sd_numa_mask()...\n\t */\n\tsched_domains_curr_level = tl->numa_level;\n#endif\n\n\tsd_weight = cpumask_weight(tl->mask(cpu));\n\n\tif (tl->sd_flags)\n\t\tsd_flags = (*tl->sd_flags)();\n\tif (WARN_ONCE(sd_flags & ~TOPOLOGY_SD_FLAGS,\n\t\t\t\"wrong sd_flags in topology description\\n\"))\n\t\tsd_flags &= TOPOLOGY_SD_FLAGS;\n\n\t/* Apply detected topology flags */\n\tsd_flags |= dflags;\n\n\t*sd = (struct sched_domain){\n\t\t.min_interval\t\t= sd_weight,\n\t\t.max_interval\t\t= 2*sd_weight,\n\t\t.busy_factor\t\t= 16,\n\t\t.imbalance_pct\t\t= 117,\n\n\t\t.cache_nice_tries\t= 0,\n\n\t\t.flags\t\t\t= 1*SD_BALANCE_NEWIDLE\n\t\t\t\t\t| 1*SD_BALANCE_EXEC\n\t\t\t\t\t| 1*SD_BALANCE_FORK\n\t\t\t\t\t| 0*SD_BALANCE_WAKE\n\t\t\t\t\t| 1*SD_WAKE_AFFINE\n\t\t\t\t\t| 0*SD_SHARE_CPUCAPACITY\n\t\t\t\t\t| 0*SD_SHARE_PKG_RESOURCES\n\t\t\t\t\t| 0*SD_SERIALIZE\n\t\t\t\t\t| 1*SD_PREFER_SIBLING\n\t\t\t\t\t| 0*SD_NUMA\n\t\t\t\t\t| sd_flags\n\t\t\t\t\t,\n\n\t\t.last_balance\t\t= jiffies,\n\t\t.balance_interval\t= sd_weight,\n\t\t.max_newidle_lb_cost\t= 0,\n\t\t.next_decay_max_lb_cost\t= jiffies,\n\t\t.child\t\t\t= child,\n#ifdef CONFIG_SCHED_DEBUG\n\t\t.name\t\t\t= tl->name,\n#endif\n\t};\n\n\tcpumask_and(sched_domain_span(sd), cpu_map, tl->mask(cpu));\n\tsd_id = cpumask_first(sched_domain_span(sd));\n\n\t/*\n\t * Convert topological properties into behaviour.\n\t */\n\n\t/* Don't attempt to spread across CPUs of different capacities. */\n\tif ((sd->flags & SD_ASYM_CPUCAPACITY) && sd->child)\n\t\tsd->child->flags &= ~SD_PREFER_SIBLING;\n\n\tif (sd->flags & SD_SHARE_CPUCAPACITY) {\n\t\tsd->imbalance_pct = 110;\n\n\t} else if (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->imbalance_pct = 117;\n\t\tsd->cache_nice_tries = 1;\n\n#ifdef CONFIG_NUMA\n\t} else if (sd->flags & SD_NUMA) {\n\t\tsd->cache_nice_tries = 2;\n\n\t\tsd->flags &= ~SD_PREFER_SIBLING;\n\t\tsd->flags |= SD_SERIALIZE;\n\t\tif (sched_domains_numa_distance[tl->numa_level] > node_reclaim_distance) {\n\t\t\tsd->flags &= ~(SD_BALANCE_EXEC |\n\t\t\t\t       SD_BALANCE_FORK |\n\t\t\t\t       SD_WAKE_AFFINE);\n\t\t}\n\n#endif\n\t} else {\n\t\tsd->cache_nice_tries = 1;\n\t}\n\n\t/*\n\t * For all levels sharing cache; connect a sched_domain_shared\n\t * instance.\n\t */\n\tif (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->shared = *per_cpu_ptr(sdd->sds, sd_id);\n\t\tatomic_inc(&sd->shared->ref);\n\t\tatomic_set(&sd->shared->nr_busy_cpus, sd_weight);\n\t}\n\n\tsd->private = sdd;\n\n\treturn sd;\n}\n\n/*\n * Topology list, bottom-up.\n */\nstatic struct sched_domain_topology_level default_topology[] = {\n#ifdef CONFIG_SCHED_SMT\n\t{ cpu_smt_mask, cpu_smt_flags, SD_INIT_NAME(SMT) },\n#endif\n#ifdef CONFIG_SCHED_MC\n\t{ cpu_coregroup_mask, cpu_core_flags, SD_INIT_NAME(MC) },\n#endif\n\t{ cpu_cpu_mask, SD_INIT_NAME(DIE) },\n\t{ NULL, },\n};\n\nstatic struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;\n\n#define for_each_sd_topology(tl)\t\t\t\\\n\tfor (tl = sched_domain_topology; tl->mask; tl++)\n\nvoid set_sched_topology(struct sched_domain_topology_level *tl)\n{\n\tif (WARN_ON_ONCE(sched_smp_initialized))\n\t\treturn;\n\n\tsched_domain_topology = tl;\n}\n\n#ifdef CONFIG_NUMA\n\nstatic const struct cpumask *sd_numa_mask(int cpu)\n{\n\treturn sched_domains_numa_masks[sched_domains_curr_level][cpu_to_node(cpu)];\n}\n\nstatic void sched_numa_warn(const char *str)\n{\n\tstatic int done = false;\n\tint i,j;\n\n\tif (done)\n\t\treturn;\n\n\tdone = true;\n\n\tprintk(KERN_WARNING \"ERROR: %s\\n\\n\", str);\n\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tprintk(KERN_WARNING \"  \");\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tprintk(KERN_CONT \"%02d \", node_distance(i,j));\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\tprintk(KERN_WARNING \"\\n\");\n}\n\nbool find_numa_distance(int distance)\n{\n\tint i;\n\n\tif (distance == node_distance(0, 0))\n\t\treturn true;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tif (sched_domains_numa_distance[i] == distance)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * A system can have three types of NUMA topology:\n * NUMA_DIRECT: all nodes are directly connected, or not a NUMA system\n * NUMA_GLUELESS_MESH: some nodes reachable through intermediary nodes\n * NUMA_BACKPLANE: nodes can reach other nodes through a backplane\n *\n * The difference between a glueless mesh topology and a backplane\n * topology lies in whether communication between not directly\n * connected nodes goes through intermediary nodes (where programs\n * could run), or through backplane controllers. This affects\n * placement of programs.\n *\n * The type of topology can be discerned with the following tests:\n * - If the maximum distance between any nodes is 1 hop, the system\n *   is directly connected.\n * - If for two nodes A and B, located N > 1 hops away from each other,\n *   there is an intermediary node C, which is < N hops away from both\n *   nodes A and B, the system is a glueless mesh.\n */\nstatic void init_numa_topology_type(void)\n{\n\tint a, b, c, n;\n\n\tn = sched_max_numa_distance;\n\n\tif (sched_domains_numa_levels <= 2) {\n\t\tsched_numa_topology_type = NUMA_DIRECT;\n\t\treturn;\n\t}\n\n\tfor_each_online_node(a) {\n\t\tfor_each_online_node(b) {\n\t\t\t/* Find two nodes furthest removed from each other. */\n\t\t\tif (node_distance(a, b) < n)\n\t\t\t\tcontinue;\n\n\t\t\t/* Is there an intermediary node between a and b? */\n\t\t\tfor_each_online_node(c) {\n\t\t\t\tif (node_distance(a, c) < n &&\n\t\t\t\t    node_distance(b, c) < n) {\n\t\t\t\t\tsched_numa_topology_type =\n\t\t\t\t\t\t\tNUMA_GLUELESS_MESH;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsched_numa_topology_type = NUMA_BACKPLANE;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n\n#define NR_DISTANCE_VALUES (1 << DISTANCE_BITS)\n\nvoid sched_init_numa(void)\n{\n\tstruct sched_domain_topology_level *tl;\n\tunsigned long *distance_map;\n\tint nr_levels = 0;\n\tint i, j;\n\n\t/*\n\t * O(nr_nodes^2) deduplicating selection sort -- in order to find the\n\t * unique distances in the node_distance() table.\n\t */\n\tdistance_map = bitmap_alloc(NR_DISTANCE_VALUES, GFP_KERNEL);\n\tif (!distance_map)\n\t\treturn;\n\n\tbitmap_zero(distance_map, NR_DISTANCE_VALUES);\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tint distance = node_distance(i, j);\n\n\t\t\tif (distance < LOCAL_DISTANCE || distance >= NR_DISTANCE_VALUES) {\n\t\t\t\tsched_numa_warn(\"Invalid distance value range\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbitmap_set(distance_map, distance, 1);\n\t\t}\n\t}\n\t/*\n\t * We can now figure out how many unique distance values there are and\n\t * allocate memory accordingly.\n\t */\n\tnr_levels = bitmap_weight(distance_map, NR_DISTANCE_VALUES);\n\n\tsched_domains_numa_distance = kcalloc(nr_levels, sizeof(int), GFP_KERNEL);\n\tif (!sched_domains_numa_distance) {\n\t\tbitmap_free(distance_map);\n\t\treturn;\n\t}\n\n\tfor (i = 0, j = 0; i < nr_levels; i++, j++) {\n\t\tj = find_next_bit(distance_map, NR_DISTANCE_VALUES, j);\n\t\tsched_domains_numa_distance[i] = j;\n\t}\n\n\tbitmap_free(distance_map);\n\n\t/*\n\t * 'nr_levels' contains the number of unique distances\n\t *\n\t * The sched_domains_numa_distance[] array includes the actual distance\n\t * numbers.\n\t */\n\n\t/*\n\t * Here, we should temporarily reset sched_domains_numa_levels to 0.\n\t * If it fails to allocate memory for array sched_domains_numa_masks[][],\n\t * the array will contain less then 'nr_levels' members. This could be\n\t * dangerous when we use it to iterate array sched_domains_numa_masks[][]\n\t * in other functions.\n\t *\n\t * We reset it to 'nr_levels' at the end of this function.\n\t */\n\tsched_domains_numa_levels = 0;\n\n\tsched_domains_numa_masks = kzalloc(sizeof(void *) * nr_levels, GFP_KERNEL);\n\tif (!sched_domains_numa_masks)\n\t\treturn;\n\n\t/*\n\t * Now for each level, construct a mask per node which contains all\n\t * CPUs of nodes that are that many hops away from us.\n\t */\n\tfor (i = 0; i < nr_levels; i++) {\n\t\tsched_domains_numa_masks[i] =\n\t\t\tkzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL);\n\t\tif (!sched_domains_numa_masks[i])\n\t\t\treturn;\n\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tstruct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL);\n\t\t\tint k;\n\n\t\t\tif (!mask)\n\t\t\t\treturn;\n\n\t\t\tsched_domains_numa_masks[i][j] = mask;\n\n\t\t\tfor_each_node(k) {\n\t\t\t\tif (sched_debug() && (node_distance(j, k) != node_distance(k, j)))\n\t\t\t\t\tsched_numa_warn(\"Node-distance not symmetric\");\n\n\t\t\t\tif (node_distance(j, k) > sched_domains_numa_distance[i])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcpumask_or(mask, mask, cpumask_of_node(k));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Compute default topology size */\n\tfor (i = 0; sched_domain_topology[i].mask; i++);\n\n\ttl = kzalloc((i + nr_levels + 1) *\n\t\t\tsizeof(struct sched_domain_topology_level), GFP_KERNEL);\n\tif (!tl)\n\t\treturn;\n\n\t/*\n\t * Copy the default topology bits..\n\t */\n\tfor (i = 0; sched_domain_topology[i].mask; i++)\n\t\ttl[i] = sched_domain_topology[i];\n\n\t/*\n\t * Add the NUMA identity distance, aka single NODE.\n\t */\n\ttl[i++] = (struct sched_domain_topology_level){\n\t\t.mask = sd_numa_mask,\n\t\t.numa_level = 0,\n\t\tSD_INIT_NAME(NODE)\n\t};\n\n\t/*\n\t * .. and append 'j' levels of NUMA goodness.\n\t */\n\tfor (j = 1; j < nr_levels; i++, j++) {\n\t\ttl[i] = (struct sched_domain_topology_level){\n\t\t\t.mask = sd_numa_mask,\n\t\t\t.sd_flags = cpu_numa_flags,\n\t\t\t.flags = SDTL_OVERLAP,\n\t\t\t.numa_level = j,\n\t\t\tSD_INIT_NAME(NUMA)\n\t\t};\n\t}\n\n\tsched_domain_topology = tl;\n\n\tsched_domains_numa_levels = nr_levels;\n\tsched_max_numa_distance = sched_domains_numa_distance[nr_levels - 1];\n\n\tinit_numa_topology_type();\n}\n\nvoid sched_domains_numa_masks_set(unsigned int cpu)\n{\n\tint node = cpu_to_node(cpu);\n\tint i, j;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tif (node_distance(j, node) <= sched_domains_numa_distance[i])\n\t\t\t\tcpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t\t}\n\t}\n}\n\nvoid sched_domains_numa_masks_clear(unsigned int cpu)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tcpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t}\n}\n\n/*\n * sched_numa_find_closest() - given the NUMA topology, find the cpu\n *                             closest to @cpu from @cpumask.\n * cpumask: cpumask to find a cpu from\n * cpu: cpu to be close to\n *\n * returns: cpu, or nr_cpu_ids when nothing found.\n */\nint sched_numa_find_closest(const struct cpumask *cpus, int cpu)\n{\n\tint i, j = cpu_to_node(cpu);\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tcpu = cpumask_any_and(cpus, sched_domains_numa_masks[i][j]);\n\t\tif (cpu < nr_cpu_ids)\n\t\t\treturn cpu;\n\t}\n\treturn nr_cpu_ids;\n}\n\n#endif /* CONFIG_NUMA */\n\nstatic int __sdt_alloc(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tsdd->sd = alloc_percpu(struct sched_domain *);\n\t\tif (!sdd->sd)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sds = alloc_percpu(struct sched_domain_shared *);\n\t\tif (!sdd->sds)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sg = alloc_percpu(struct sched_group *);\n\t\tif (!sdd->sg)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sgc = alloc_percpu(struct sched_group_capacity *);\n\t\tif (!sdd->sgc)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\t\t\tstruct sched_domain_shared *sds;\n\t\t\tstruct sched_group *sg;\n\t\t\tstruct sched_group_capacity *sgc;\n\n\t\t\tsd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sd)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sd, j) = sd;\n\n\t\t\tsds = kzalloc_node(sizeof(struct sched_domain_shared),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sds)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sds, j) = sds;\n\n\t\t\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sg)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tsg->next = sg;\n\n\t\t\t*per_cpu_ptr(sdd->sg, j) = sg;\n\n\t\t\tsgc = kzalloc_node(sizeof(struct sched_group_capacity) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sgc)\n\t\t\t\treturn -ENOMEM;\n\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tsgc->id = j;\n#endif\n\n\t\t\t*per_cpu_ptr(sdd->sgc, j) = sgc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void __sdt_free(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\n\t\t\tif (sdd->sd) {\n\t\t\t\tsd = *per_cpu_ptr(sdd->sd, j);\n\t\t\t\tif (sd && (sd->flags & SD_OVERLAP))\n\t\t\t\t\tfree_sched_groups(sd->groups, 0);\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sd, j));\n\t\t\t}\n\n\t\t\tif (sdd->sds)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sds, j));\n\t\t\tif (sdd->sg)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sg, j));\n\t\t\tif (sdd->sgc)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sgc, j));\n\t\t}\n\t\tfree_percpu(sdd->sd);\n\t\tsdd->sd = NULL;\n\t\tfree_percpu(sdd->sds);\n\t\tsdd->sds = NULL;\n\t\tfree_percpu(sdd->sg);\n\t\tsdd->sg = NULL;\n\t\tfree_percpu(sdd->sgc);\n\t\tsdd->sgc = NULL;\n\t}\n}\n\nstatic struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl,\n\t\tconst struct cpumask *cpu_map, struct sched_domain_attr *attr,\n\t\tstruct sched_domain *child, int dflags, int cpu)\n{\n\tstruct sched_domain *sd = sd_init(tl, cpu_map, child, dflags, cpu);\n\n\tif (child) {\n\t\tsd->level = child->level + 1;\n\t\tsched_domain_level_max = max(sched_domain_level_max, sd->level);\n\t\tchild->parent = sd;\n\n\t\tif (!cpumask_subset(sched_domain_span(child),\n\t\t\t\t    sched_domain_span(sd))) {\n\t\t\tpr_err(\"BUG: arch topology borken\\n\");\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tpr_err(\"     the %s domain not a subset of the %s domain\\n\",\n\t\t\t\t\tchild->name, sd->name);\n#endif\n\t\t\t/* Fixup, ensure @sd has at least @child CPUs. */\n\t\t\tcpumask_or(sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(child));\n\t\t}\n\n\t}\n\tset_domain_attribute(sd, attr);\n\n\treturn sd;\n}\n\n/*\n * Ensure topology masks are sane, i.e. there are no conflicts (overlaps) for\n * any two given CPUs at this (non-NUMA) topology level.\n */\nstatic bool topology_span_sane(struct sched_domain_topology_level *tl,\n\t\t\t      const struct cpumask *cpu_map, int cpu)\n{\n\tint i;\n\n\t/* NUMA levels are allowed to overlap */\n\tif (tl->flags & SDTL_OVERLAP)\n\t\treturn true;\n\n\t/*\n\t * Non-NUMA levels cannot partially overlap - they must be either\n\t * completely equal or completely disjoint. Otherwise we can end up\n\t * breaking the sched_group lists - i.e. a later get_group() pass\n\t * breaks the linking done for an earlier span.\n\t */\n\tfor_each_cpu(i, cpu_map) {\n\t\tif (i == cpu)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We should 'and' all those masks with 'cpu_map' to exactly\n\t\t * match the topology we're about to build, but that can only\n\t\t * remove CPUs, which only lessens our ability to detect\n\t\t * overlaps\n\t\t */\n\t\tif (!cpumask_equal(tl->mask(cpu), tl->mask(i)) &&\n\t\t    cpumask_intersects(tl->mask(cpu), tl->mask(i)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/*\n * Find the sched_domain_topology_level where all CPU capacities are visible\n * for all CPUs.\n */\nstatic struct sched_domain_topology_level\n*asym_cpu_capacity_level(const struct cpumask *cpu_map)\n{\n\tint i, j, asym_level = 0;\n\tbool asym = false;\n\tstruct sched_domain_topology_level *tl, *asym_tl = NULL;\n\tunsigned long cap;\n\n\t/* Is there any asymmetry? */\n\tcap = arch_scale_cpu_capacity(cpumask_first(cpu_map));\n\n\tfor_each_cpu(i, cpu_map) {\n\t\tif (arch_scale_cpu_capacity(i) != cap) {\n\t\t\tasym = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!asym)\n\t\treturn NULL;\n\n\t/*\n\t * Examine topology from all CPU's point of views to detect the lowest\n\t * sched_domain_topology_level where a highest capacity CPU is visible\n\t * to everyone.\n\t */\n\tfor_each_cpu(i, cpu_map) {\n\t\tunsigned long max_capacity = arch_scale_cpu_capacity(i);\n\t\tint tl_id = 0;\n\n\t\tfor_each_sd_topology(tl) {\n\t\t\tif (tl_id < asym_level)\n\t\t\t\tgoto next_level;\n\n\t\t\tfor_each_cpu_and(j, tl->mask(i), cpu_map) {\n\t\t\t\tunsigned long capacity;\n\n\t\t\t\tcapacity = arch_scale_cpu_capacity(j);\n\n\t\t\t\tif (capacity <= max_capacity)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmax_capacity = capacity;\n\t\t\t\tasym_level = tl_id;\n\t\t\t\tasym_tl = tl;\n\t\t\t}\nnext_level:\n\t\t\ttl_id++;\n\t\t}\n\t}\n\n\treturn asym_tl;\n}\n\n\n/*\n * Build sched domains for a given set of CPUs and attach the sched domains\n * to the individual CPUs\n */\nstatic int\nbuild_sched_domains(const struct cpumask *cpu_map, struct sched_domain_attr *attr)\n{\n\tenum s_alloc alloc_state = sa_none;\n\tstruct sched_domain *sd;\n\tstruct s_data d;\n\tstruct rq *rq = NULL;\n\tint i, ret = -ENOMEM;\n\tstruct sched_domain_topology_level *tl_asym;\n\tbool has_asym = false;\n\n\tif (WARN_ON(cpumask_empty(cpu_map)))\n\t\tgoto error;\n\n\talloc_state = __visit_domain_allocation_hell(&d, cpu_map);\n\tif (alloc_state != sa_rootdomain)\n\t\tgoto error;\n\n\ttl_asym = asym_cpu_capacity_level(cpu_map);\n\n\t/* Set up domains for CPUs specified by the cpu_map: */\n\tfor_each_cpu(i, cpu_map) {\n\t\tstruct sched_domain_topology_level *tl;\n\t\tint dflags = 0;\n\n\t\tsd = NULL;\n\t\tfor_each_sd_topology(tl) {\n\t\t\tif (tl == tl_asym) {\n\t\t\t\tdflags |= SD_ASYM_CPUCAPACITY;\n\t\t\t\thas_asym = true;\n\t\t\t}\n\n\t\t\tif (WARN_ON(!topology_span_sane(tl, cpu_map, i)))\n\t\t\t\tgoto error;\n\n\t\t\tsd = build_sched_domain(tl, cpu_map, attr, sd, dflags, i);\n\n\t\t\tif (tl == sched_domain_topology)\n\t\t\t\t*per_cpu_ptr(d.sd, i) = sd;\n\t\t\tif (tl->flags & SDTL_OVERLAP)\n\t\t\t\tsd->flags |= SD_OVERLAP;\n\t\t\tif (cpumask_equal(cpu_map, sched_domain_span(sd)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Build the groups for the domains */\n\tfor_each_cpu(i, cpu_map) {\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tsd->span_weight = cpumask_weight(sched_domain_span(sd));\n\t\t\tif (sd->flags & SD_OVERLAP) {\n\t\t\t\tif (build_overlap_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tif (build_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Calculate CPU capacity for physical packages and nodes */\n\tfor (i = nr_cpumask_bits-1; i >= 0; i--) {\n\t\tif (!cpumask_test_cpu(i, cpu_map))\n\t\t\tcontinue;\n\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tclaim_allocations(i, sd);\n\t\t\tinit_sched_groups_capacity(i, sd);\n\t\t}\n\t}\n\n\t/* Attach the domains */\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map) {\n\t\trq = cpu_rq(i);\n\t\tsd = *per_cpu_ptr(d.sd, i);\n\n\t\t/* Use READ_ONCE()/WRITE_ONCE() to avoid load/store tearing: */\n\t\tif (rq->cpu_capacity_orig > READ_ONCE(d.rd->max_cpu_capacity))\n\t\t\tWRITE_ONCE(d.rd->max_cpu_capacity, rq->cpu_capacity_orig);\n\n\t\tcpu_attach_domain(sd, d.rd, i);\n\t}\n\trcu_read_unlock();\n\n\tif (has_asym)\n\t\tstatic_branch_inc_cpuslocked(&sched_asym_cpucapacity);\n\n\tif (rq && sched_debug_enabled) {\n\t\tpr_info(\"root domain span: %*pbl (max cpu_capacity = %lu)\\n\",\n\t\t\tcpumask_pr_args(cpu_map), rq->rd->max_cpu_capacity);\n\t}\n\n\tret = 0;\nerror:\n\t__free_domain_allocs(&d, alloc_state, cpu_map);\n\n\treturn ret;\n}\n\n/* Current sched domains: */\nstatic cpumask_var_t\t\t\t*doms_cur;\n\n/* Number of sched domains in 'doms_cur': */\nstatic int\t\t\t\tndoms_cur;\n\n/* Attribues of custom domains in 'doms_cur' */\nstatic struct sched_domain_attr\t\t*dattr_cur;\n\n/*\n * Special case: If a kmalloc() of a doms_cur partition (array of\n * cpumask) fails, then fallback to a single sched domain,\n * as determined by the single cpumask fallback_doms.\n */\nstatic cpumask_var_t\t\t\tfallback_doms;\n\n/*\n * arch_update_cpu_topology lets virtualized architectures update the\n * CPU core maps. It is supposed to return 1 if the topology changed\n * or 0 if it stayed the same.\n */\nint __weak arch_update_cpu_topology(void)\n{\n\treturn 0;\n}\n\ncpumask_var_t *alloc_sched_domains(unsigned int ndoms)\n{\n\tint i;\n\tcpumask_var_t *doms;\n\n\tdoms = kmalloc_array(ndoms, sizeof(*doms), GFP_KERNEL);\n\tif (!doms)\n\t\treturn NULL;\n\tfor (i = 0; i < ndoms; i++) {\n\t\tif (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {\n\t\t\tfree_sched_domains(doms, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn doms;\n}\n\nvoid free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}\n\n/*\n * Set up scheduler domains and groups.  For now this just excludes isolated\n * CPUs, but could be used to exclude other special cases in the future.\n */\nint sched_init_domains(const struct cpumask *cpu_map)\n{\n\tint err;\n\n\tzalloc_cpumask_var(&sched_domains_tmpmask, GFP_KERNEL);\n\tzalloc_cpumask_var(&sched_domains_tmpmask2, GFP_KERNEL);\n\tzalloc_cpumask_var(&fallback_doms, GFP_KERNEL);\n\n\tarch_update_cpu_topology();\n\tndoms_cur = 1;\n\tdoms_cur = alloc_sched_domains(ndoms_cur);\n\tif (!doms_cur)\n\t\tdoms_cur = &fallback_doms;\n\tcpumask_and(doms_cur[0], cpu_map, housekeeping_cpumask(HK_FLAG_DOMAIN));\n\terr = build_sched_domains(doms_cur[0], NULL);\n\tregister_sched_domain_sysctl();\n\n\treturn err;\n}\n\n/*\n * Detach sched domains from a group of CPUs specified in cpu_map\n * These CPUs will now be attached to the NULL domain\n */\nstatic void detach_destroy_domains(const struct cpumask *cpu_map)\n{\n\tunsigned int cpu = cpumask_any(cpu_map);\n\tint i;\n\n\tif (rcu_access_pointer(per_cpu(sd_asym_cpucapacity, cpu)))\n\t\tstatic_branch_dec_cpuslocked(&sched_asym_cpucapacity);\n\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map)\n\t\tcpu_attach_domain(NULL, &def_root_domain, i);\n\trcu_read_unlock();\n}\n\n/* handle null as \"default\" */\nstatic int dattrs_equal(struct sched_domain_attr *cur, int idx_cur,\n\t\t\tstruct sched_domain_attr *new, int idx_new)\n{\n\tstruct sched_domain_attr tmp;\n\n\t/* Fast path: */\n\tif (!new && !cur)\n\t\treturn 1;\n\n\ttmp = SD_ATTR_INIT;\n\n\treturn !memcmp(cur ? (cur + idx_cur) : &tmp,\n\t\t\tnew ? (new + idx_new) : &tmp,\n\t\t\tsizeof(struct sched_domain_attr));\n}\n\n/*\n * Partition sched domains as specified by the 'ndoms_new'\n * cpumasks in the array doms_new[] of cpumasks. This compares\n * doms_new[] to the current sched domain partitioning, doms_cur[].\n * It destroys each deleted domain and builds each new domain.\n *\n * 'doms_new' is an array of cpumask_var_t's of length 'ndoms_new'.\n * The masks don't intersect (don't overlap.) We should setup one\n * sched domain for each mask. CPUs not in any of the cpumasks will\n * not be load balanced. If the same cpumask appears both in the\n * current 'doms_cur' domains and in the new 'doms_new', we can leave\n * it as it is.\n *\n * The passed in 'doms_new' should be allocated using\n * alloc_sched_domains.  This routine takes ownership of it and will\n * free_sched_domains it when done with it. If the caller failed the\n * alloc call, then it can pass in doms_new == NULL && ndoms_new == 1,\n * and partition_sched_domains() will fallback to the single partition\n * 'fallback_doms', it also forces the domains to be rebuilt.\n *\n * If doms_new == NULL it will be replaced with cpu_online_mask.\n * ndoms_new == 0 is a special case for destroying existing domains,\n * and it will not create the default domain.\n *\n * Call with hotplug lock and sched_domains_mutex held\n */\nvoid partition_sched_domains_locked(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t\t    struct sched_domain_attr *dattr_new)\n{\n\tbool __maybe_unused has_eas = false;\n\tint i, j, n;\n\tint new_topology;\n\n\tlockdep_assert_held(&sched_domains_mutex);\n\n\t/* Always unregister in case we don't destroy any domains: */\n\tunregister_sched_domain_sysctl();\n\n\t/* Let the architecture update CPU core mappings: */\n\tnew_topology = arch_update_cpu_topology();\n\n\tif (!doms_new) {\n\t\tWARN_ON_ONCE(dattr_new);\n\t\tn = 0;\n\t\tdoms_new = alloc_sched_domains(1);\n\t\tif (doms_new) {\n\t\t\tn = 1;\n\t\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t\t}\n\t} else {\n\t\tn = ndoms_new;\n\t}\n\n\t/* Destroy deleted domains: */\n\tfor (i = 0; i < ndoms_cur; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_cur[i], doms_new[j]) &&\n\t\t\t    dattrs_equal(dattr_cur, i, dattr_new, j)) {\n\t\t\t\tstruct root_domain *rd;\n\n\t\t\t\t/*\n\t\t\t\t * This domain won't be destroyed and as such\n\t\t\t\t * its dl_bw->total_bw needs to be cleared.  It\n\t\t\t\t * will be recomputed in function\n\t\t\t\t * update_tasks_root_domain().\n\t\t\t\t */\n\t\t\t\trd = cpu_rq(cpumask_any(doms_cur[i]))->rd;\n\t\t\t\tdl_clear_root_domain(rd);\n\t\t\t\tgoto match1;\n\t\t\t}\n\t\t}\n\t\t/* No match - a current sched domain not in new doms_new[] */\n\t\tdetach_destroy_domains(doms_cur[i]);\nmatch1:\n\t\t;\n\t}\n\n\tn = ndoms_cur;\n\tif (!doms_new) {\n\t\tn = 0;\n\t\tdoms_new = &fallback_doms;\n\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t}\n\n\t/* Build new domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j]) &&\n\t\t\t    dattrs_equal(dattr_new, i, dattr_cur, j))\n\t\t\t\tgoto match2;\n\t\t}\n\t\t/* No match - add a new doms_new */\n\t\tbuild_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL);\nmatch2:\n\t\t;\n\t}\n\n#if defined(CONFIG_ENERGY_MODEL) && defined(CONFIG_CPU_FREQ_GOV_SCHEDUTIL)\n\t/* Build perf. domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !sched_energy_update; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j]) &&\n\t\t\t    cpu_rq(cpumask_first(doms_cur[j]))->rd->pd) {\n\t\t\t\thas_eas = true;\n\t\t\t\tgoto match3;\n\t\t\t}\n\t\t}\n\t\t/* No match - add perf. domains for a new rd */\n\t\thas_eas |= build_perf_domains(doms_new[i]);\nmatch3:\n\t\t;\n\t}\n\tsched_energy_set(has_eas);\n#endif\n\n\t/* Remember the new sched domains: */\n\tif (doms_cur != &fallback_doms)\n\t\tfree_sched_domains(doms_cur, ndoms_cur);\n\n\tkfree(dattr_cur);\n\tdoms_cur = doms_new;\n\tdattr_cur = dattr_new;\n\tndoms_cur = ndoms_new;\n\n\tregister_sched_domain_sysctl();\n}\n\n/*\n * Call with hotplug lock held\n */\nvoid partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t     struct sched_domain_attr *dattr_new)\n{\n\tmutex_lock(&sched_domains_mutex);\n\tpartition_sched_domains_locked(ndoms_new, doms_new, dattr_new);\n\tmutex_unlock(&sched_domains_mutex);\n}\n"}, "1": {"id": 1, "path": "/src/include/asm-generic/bug.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _ASM_GENERIC_BUG_H\n#define _ASM_GENERIC_BUG_H\n\n#include <linux/compiler.h>\n#include <linux/instrumentation.h>\n\n#define CUT_HERE\t\t\"------------[ cut here ]------------\\n\"\n\n#ifdef CONFIG_GENERIC_BUG\n#define BUGFLAG_WARNING\t\t(1 << 0)\n#define BUGFLAG_ONCE\t\t(1 << 1)\n#define BUGFLAG_DONE\t\t(1 << 2)\n#define BUGFLAG_NO_CUT_HERE\t(1 << 3)\t/* CUT_HERE already sent */\n#define BUGFLAG_TAINT(taint)\t((taint) << 8)\n#define BUG_GET_TAINT(bug)\t((bug)->flags >> 8)\n#endif\n\n#ifndef __ASSEMBLY__\n#include <linux/kernel.h>\n\n#ifdef CONFIG_BUG\n\n#ifdef CONFIG_GENERIC_BUG\nstruct bug_entry {\n#ifndef CONFIG_GENERIC_BUG_RELATIVE_POINTERS\n\tunsigned long\tbug_addr;\n#else\n\tsigned int\tbug_addr_disp;\n#endif\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n#ifndef CONFIG_GENERIC_BUG_RELATIVE_POINTERS\n\tconst char\t*file;\n#else\n\tsigned int\tfile_disp;\n#endif\n\tunsigned short\tline;\n#endif\n\tunsigned short\tflags;\n};\n#endif\t/* CONFIG_GENERIC_BUG */\n\n/*\n * Don't use BUG() or BUG_ON() unless there's really no way out; one\n * example might be detecting data structure corruption in the middle\n * of an operation that can't be backed out of.  If the (sub)system\n * can somehow continue operating, perhaps with reduced functionality,\n * it's probably not BUG-worthy.\n *\n * If you're tempted to BUG(), think again:  is completely giving up\n * really the *only* solution?  There are usually better options, where\n * users don't need to reboot ASAP and can mostly shut down cleanly.\n */\n#ifndef HAVE_ARCH_BUG\n#define BUG() do { \\\n\tprintk(\"BUG: failure at %s:%d/%s()!\\n\", __FILE__, __LINE__, __func__); \\\n\tbarrier_before_unreachable(); \\\n\tpanic(\"BUG!\"); \\\n} while (0)\n#endif\n\n#ifndef HAVE_ARCH_BUG_ON\n#define BUG_ON(condition) do { if (unlikely(condition)) BUG(); } while (0)\n#endif\n\n/*\n * WARN(), WARN_ON(), WARN_ON_ONCE, and so on can be used to report\n * significant kernel issues that need prompt attention if they should ever\n * appear at runtime.\n *\n * Do not use these macros when checking for invalid external inputs\n * (e.g. invalid system call arguments, or invalid data coming from\n * network/devices), and on transient conditions like ENOMEM or EAGAIN.\n * These macros should be used for recoverable kernel issues only.\n * For invalid external inputs, transient conditions, etc use\n * pr_err[_once/_ratelimited]() followed by dump_stack(), if necessary.\n * Do not include \"BUG\"/\"WARNING\" in format strings manually to make these\n * conditions distinguishable from kernel issues.\n *\n * Use the versions with printk format strings to provide better diagnostics.\n */\n#ifndef __WARN_FLAGS\nextern __printf(4, 5)\nvoid warn_slowpath_fmt(const char *file, const int line, unsigned taint,\n\t\t       const char *fmt, ...);\n#define __WARN()\t\t__WARN_printf(TAINT_WARN, NULL)\n#define __WARN_printf(taint, arg...) do {\t\t\t\t\\\n\t\tinstrumentation_begin();\t\t\t\t\\\n\t\twarn_slowpath_fmt(__FILE__, __LINE__, taint, arg);\t\\\n\t\tinstrumentation_end();\t\t\t\t\t\\\n\t} while (0)\n#else\nextern __printf(1, 2) void __warn_printk(const char *fmt, ...);\n#define __WARN()\t\t__WARN_FLAGS(BUGFLAG_TAINT(TAINT_WARN))\n#define __WARN_printf(taint, arg...) do {\t\t\t\t\\\n\t\tinstrumentation_begin();\t\t\t\t\\\n\t\t__warn_printk(arg);\t\t\t\t\t\\\n\t\t__WARN_FLAGS(BUGFLAG_NO_CUT_HERE | BUGFLAG_TAINT(taint));\\\n\t\tinstrumentation_end();\t\t\t\t\t\\\n\t} while (0)\n#define WARN_ON_ONCE(condition) ({\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\\\n\t\t__WARN_FLAGS(BUGFLAG_ONCE |\t\t\t\\\n\t\t\t     BUGFLAG_TAINT(TAINT_WARN));\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\\\n})\n#endif\n\n/* used internally by panic.c */\nstruct warn_args;\nstruct pt_regs;\n\nvoid __warn(const char *file, int line, void *caller, unsigned taint,\n\t    struct pt_regs *regs, struct warn_args *args);\n\n#ifndef WARN_ON\n#define WARN_ON(condition) ({\t\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN();\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#ifndef WARN\n#define WARN(condition, format...) ({\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN_printf(TAINT_WARN, format);\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#define WARN_TAINT(condition, taint, format...) ({\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN_printf(taint, format);\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n\n#ifndef WARN_ON_ONCE\n#define WARN_ON_ONCE(condition)\t({\t\t\t\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN_ON(1);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n#endif\n\n#define WARN_ONCE(condition, format...)\t({\t\t\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN(1, format);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n\n#define WARN_TAINT_ONCE(condition, taint, format...)\t({\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN_TAINT(1, taint, format);\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n\n#else /* !CONFIG_BUG */\n#ifndef HAVE_ARCH_BUG\n#define BUG() do {} while (1)\n#endif\n\n#ifndef HAVE_ARCH_BUG_ON\n#define BUG_ON(condition) do { if (unlikely(condition)) BUG(); } while (0)\n#endif\n\n#ifndef HAVE_ARCH_WARN_ON\n#define WARN_ON(condition) ({\t\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#ifndef WARN\n#define WARN(condition, format...) ({\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tno_printk(format);\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#define WARN_ON_ONCE(condition) WARN_ON(condition)\n#define WARN_ONCE(condition, format...) WARN(condition, format)\n#define WARN_TAINT(condition, taint, format...) WARN(condition, format)\n#define WARN_TAINT_ONCE(condition, taint, format...) WARN(condition, format)\n\n#endif\n\n/*\n * WARN_ON_SMP() is for cases that the warning is either\n * meaningless for !SMP or may even cause failures.\n * It can also be used with values that are only defined\n * on SMP:\n *\n * struct foo {\n *  [...]\n * #ifdef CONFIG_SMP\n *\tint bar;\n * #endif\n * };\n *\n * void func(struct foo *zoot)\n * {\n *\tWARN_ON_SMP(!zoot->bar);\n *\n * For CONFIG_SMP, WARN_ON_SMP() should act the same as WARN_ON(),\n * and should be a nop and return false for uniprocessor.\n *\n * if (WARN_ON_SMP(x)) returns true only when CONFIG_SMP is set\n * and x is true.\n */\n#ifdef CONFIG_SMP\n# define WARN_ON_SMP(x)\t\t\tWARN_ON(x)\n#else\n/*\n * Use of ({0;}) because WARN_ON_SMP(x) may be used either as\n * a stand alone line statement or as a condition in an if ()\n * statement.\n * A simple \"0\" would cause gcc to give a \"statement has no effect\"\n * warning.\n */\n# define WARN_ON_SMP(x)\t\t\t({0;})\n#endif\n\n#endif /* __ASSEMBLY__ */\n\n#endif\n"}, "2": {"id": 2, "path": "/src/include/linux/cpumask.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_CPUMASK_H\n#define __LINUX_CPUMASK_H\n\n/*\n * Cpumasks provide a bitmap suitable for representing the\n * set of CPU's in a system, one bit position per CPU number.  In general,\n * only nr_cpu_ids (<= NR_CPUS) bits are valid.\n */\n#include <linux/kernel.h>\n#include <linux/threads.h>\n#include <linux/bitmap.h>\n#include <linux/atomic.h>\n#include <linux/bug.h>\n\n/* Don't assign or return these: may not be this big! */\ntypedef struct cpumask { DECLARE_BITMAP(bits, NR_CPUS); } cpumask_t;\n\n/**\n * cpumask_bits - get the bits in a cpumask\n * @maskp: the struct cpumask *\n *\n * You should only assume nr_cpu_ids bits of this mask are valid.  This is\n * a macro so it's const-correct.\n */\n#define cpumask_bits(maskp) ((maskp)->bits)\n\n/**\n * cpumask_pr_args - printf args to output a cpumask\n * @maskp: cpumask to be printed\n *\n * Can be used to provide arguments for '%*pb[l]' when printing a cpumask.\n */\n#define cpumask_pr_args(maskp)\t\tnr_cpu_ids, cpumask_bits(maskp)\n\n#if NR_CPUS == 1\n#define nr_cpu_ids\t\t1U\n#else\nextern unsigned int nr_cpu_ids;\n#endif\n\n#ifdef CONFIG_CPUMASK_OFFSTACK\n/* Assuming NR_CPUS is huge, a runtime limit is more efficient.  Also,\n * not all bits may be allocated. */\n#define nr_cpumask_bits\tnr_cpu_ids\n#else\n#define nr_cpumask_bits\t((unsigned int)NR_CPUS)\n#endif\n\n/*\n * The following particular system cpumasks and operations manage\n * possible, present, active and online cpus.\n *\n *     cpu_possible_mask- has bit 'cpu' set iff cpu is populatable\n *     cpu_present_mask - has bit 'cpu' set iff cpu is populated\n *     cpu_online_mask  - has bit 'cpu' set iff cpu available to scheduler\n *     cpu_active_mask  - has bit 'cpu' set iff cpu available to migration\n *\n *  If !CONFIG_HOTPLUG_CPU, present == possible, and active == online.\n *\n *  The cpu_possible_mask is fixed at boot time, as the set of CPU id's\n *  that it is possible might ever be plugged in at anytime during the\n *  life of that system boot.  The cpu_present_mask is dynamic(*),\n *  representing which CPUs are currently plugged in.  And\n *  cpu_online_mask is the dynamic subset of cpu_present_mask,\n *  indicating those CPUs available for scheduling.\n *\n *  If HOTPLUG is enabled, then cpu_possible_mask is forced to have\n *  all NR_CPUS bits set, otherwise it is just the set of CPUs that\n *  ACPI reports present at boot.\n *\n *  If HOTPLUG is enabled, then cpu_present_mask varies dynamically,\n *  depending on what ACPI reports as currently plugged in, otherwise\n *  cpu_present_mask is just a copy of cpu_possible_mask.\n *\n *  (*) Well, cpu_present_mask is dynamic in the hotplug case.  If not\n *      hotplug, it's a copy of cpu_possible_mask, hence fixed at boot.\n *\n * Subtleties:\n * 1) UP arch's (NR_CPUS == 1, CONFIG_SMP not defined) hardcode\n *    assumption that their single CPU is online.  The UP\n *    cpu_{online,possible,present}_masks are placebos.  Changing them\n *    will have no useful affect on the following num_*_cpus()\n *    and cpu_*() macros in the UP case.  This ugliness is a UP\n *    optimization - don't waste any instructions or memory references\n *    asking if you're online or how many CPUs there are if there is\n *    only one CPU.\n */\n\nextern struct cpumask __cpu_possible_mask;\nextern struct cpumask __cpu_online_mask;\nextern struct cpumask __cpu_present_mask;\nextern struct cpumask __cpu_active_mask;\n#define cpu_possible_mask ((const struct cpumask *)&__cpu_possible_mask)\n#define cpu_online_mask   ((const struct cpumask *)&__cpu_online_mask)\n#define cpu_present_mask  ((const struct cpumask *)&__cpu_present_mask)\n#define cpu_active_mask   ((const struct cpumask *)&__cpu_active_mask)\n\nextern atomic_t __num_online_cpus;\n\n#if NR_CPUS > 1\n/**\n * num_online_cpus() - Read the number of online CPUs\n *\n * Despite the fact that __num_online_cpus is of type atomic_t, this\n * interface gives only a momentary snapshot and is not protected against\n * concurrent CPU hotplug operations unless invoked from a cpuhp_lock held\n * region.\n */\nstatic inline unsigned int num_online_cpus(void)\n{\n\treturn atomic_read(&__num_online_cpus);\n}\n#define num_possible_cpus()\tcpumask_weight(cpu_possible_mask)\n#define num_present_cpus()\tcpumask_weight(cpu_present_mask)\n#define num_active_cpus()\tcpumask_weight(cpu_active_mask)\n#define cpu_online(cpu)\t\tcpumask_test_cpu((cpu), cpu_online_mask)\n#define cpu_possible(cpu)\tcpumask_test_cpu((cpu), cpu_possible_mask)\n#define cpu_present(cpu)\tcpumask_test_cpu((cpu), cpu_present_mask)\n#define cpu_active(cpu)\t\tcpumask_test_cpu((cpu), cpu_active_mask)\n#else\n#define num_online_cpus()\t1U\n#define num_possible_cpus()\t1U\n#define num_present_cpus()\t1U\n#define num_active_cpus()\t1U\n#define cpu_online(cpu)\t\t((cpu) == 0)\n#define cpu_possible(cpu)\t((cpu) == 0)\n#define cpu_present(cpu)\t((cpu) == 0)\n#define cpu_active(cpu)\t\t((cpu) == 0)\n#endif\n\nextern cpumask_t cpus_booted_once_mask;\n\nstatic inline void cpu_max_bits_warn(unsigned int cpu, unsigned int bits)\n{\n#ifdef CONFIG_DEBUG_PER_CPU_MAPS\n\tWARN_ON_ONCE(cpu >= bits);\n#endif /* CONFIG_DEBUG_PER_CPU_MAPS */\n}\n\n/* verify cpu argument to cpumask_* operators */\nstatic inline unsigned int cpumask_check(unsigned int cpu)\n{\n\tcpu_max_bits_warn(cpu, nr_cpumask_bits);\n\treturn cpu;\n}\n\n#if NR_CPUS == 1\n/* Uniprocessor.  Assume all masks are \"1\". */\nstatic inline unsigned int cpumask_first(const struct cpumask *srcp)\n{\n\treturn 0;\n}\n\nstatic inline unsigned int cpumask_last(const struct cpumask *srcp)\n{\n\treturn 0;\n}\n\n/* Valid inputs for n are -1 and 0. */\nstatic inline unsigned int cpumask_next(int n, const struct cpumask *srcp)\n{\n\treturn n+1;\n}\n\nstatic inline unsigned int cpumask_next_zero(int n, const struct cpumask *srcp)\n{\n\treturn n+1;\n}\n\nstatic inline unsigned int cpumask_next_and(int n,\n\t\t\t\t\t    const struct cpumask *srcp,\n\t\t\t\t\t    const struct cpumask *andp)\n{\n\treturn n+1;\n}\n\nstatic inline unsigned int cpumask_next_wrap(int n, const struct cpumask *mask,\n\t\t\t\t\t     int start, bool wrap)\n{\n\t/* cpu0 unless stop condition, wrap and at cpu0, then nr_cpumask_bits */\n\treturn (wrap && n == 0);\n}\n\n/* cpu must be a valid cpu, ie 0, so there's no other choice. */\nstatic inline unsigned int cpumask_any_but(const struct cpumask *mask,\n\t\t\t\t\t   unsigned int cpu)\n{\n\treturn 1;\n}\n\nstatic inline unsigned int cpumask_local_spread(unsigned int i, int node)\n{\n\treturn 0;\n}\n\nstatic inline int cpumask_any_and_distribute(const struct cpumask *src1p,\n\t\t\t\t\t     const struct cpumask *src2p) {\n\treturn cpumask_next_and(-1, src1p, src2p);\n}\n\nstatic inline int cpumask_any_distribute(const struct cpumask *srcp)\n{\n\treturn cpumask_first(srcp);\n}\n\n#define for_each_cpu(cpu, mask)\t\t\t\\\n\tfor ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask)\n#define for_each_cpu_not(cpu, mask)\t\t\\\n\tfor ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask)\n#define for_each_cpu_wrap(cpu, mask, start)\t\\\n\tfor ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask, (void)(start))\n#define for_each_cpu_and(cpu, mask1, mask2)\t\\\n\tfor ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask1, (void)mask2)\n#else\n/**\n * cpumask_first - get the first cpu in a cpumask\n * @srcp: the cpumask pointer\n *\n * Returns >= nr_cpu_ids if no cpus set.\n */\nstatic inline unsigned int cpumask_first(const struct cpumask *srcp)\n{\n\treturn find_first_bit(cpumask_bits(srcp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_last - get the last CPU in a cpumask\n * @srcp:\t- the cpumask pointer\n *\n * Returns\t>= nr_cpumask_bits if no CPUs set.\n */\nstatic inline unsigned int cpumask_last(const struct cpumask *srcp)\n{\n\treturn find_last_bit(cpumask_bits(srcp), nr_cpumask_bits);\n}\n\nunsigned int __pure cpumask_next(int n, const struct cpumask *srcp);\n\n/**\n * cpumask_next_zero - get the next unset cpu in a cpumask\n * @n: the cpu prior to the place to search (ie. return will be > @n)\n * @srcp: the cpumask pointer\n *\n * Returns >= nr_cpu_ids if no further cpus unset.\n */\nstatic inline unsigned int cpumask_next_zero(int n, const struct cpumask *srcp)\n{\n\t/* -1 is a legal arg here. */\n\tif (n != -1)\n\t\tcpumask_check(n);\n\treturn find_next_zero_bit(cpumask_bits(srcp), nr_cpumask_bits, n+1);\n}\n\nint __pure cpumask_next_and(int n, const struct cpumask *, const struct cpumask *);\nint __pure cpumask_any_but(const struct cpumask *mask, unsigned int cpu);\nunsigned int cpumask_local_spread(unsigned int i, int node);\nint cpumask_any_and_distribute(const struct cpumask *src1p,\n\t\t\t       const struct cpumask *src2p);\nint cpumask_any_distribute(const struct cpumask *srcp);\n\n/**\n * for_each_cpu - iterate over every cpu in a mask\n * @cpu: the (optionally unsigned) integer iterator\n * @mask: the cpumask pointer\n *\n * After the loop, cpu is >= nr_cpu_ids.\n */\n#define for_each_cpu(cpu, mask)\t\t\t\t\\\n\tfor ((cpu) = -1;\t\t\t\t\\\n\t\t(cpu) = cpumask_next((cpu), (mask)),\t\\\n\t\t(cpu) < nr_cpu_ids;)\n\n/**\n * for_each_cpu_not - iterate over every cpu in a complemented mask\n * @cpu: the (optionally unsigned) integer iterator\n * @mask: the cpumask pointer\n *\n * After the loop, cpu is >= nr_cpu_ids.\n */\n#define for_each_cpu_not(cpu, mask)\t\t\t\t\\\n\tfor ((cpu) = -1;\t\t\t\t\t\\\n\t\t(cpu) = cpumask_next_zero((cpu), (mask)),\t\\\n\t\t(cpu) < nr_cpu_ids;)\n\nextern int cpumask_next_wrap(int n, const struct cpumask *mask, int start, bool wrap);\n\n/**\n * for_each_cpu_wrap - iterate over every cpu in a mask, starting at a specified location\n * @cpu: the (optionally unsigned) integer iterator\n * @mask: the cpumask poiter\n * @start: the start location\n *\n * The implementation does not assume any bit in @mask is set (including @start).\n *\n * After the loop, cpu is >= nr_cpu_ids.\n */\n#define for_each_cpu_wrap(cpu, mask, start)\t\t\t\t\t\\\n\tfor ((cpu) = cpumask_next_wrap((start)-1, (mask), (start), false);\t\\\n\t     (cpu) < nr_cpumask_bits;\t\t\t\t\t\t\\\n\t     (cpu) = cpumask_next_wrap((cpu), (mask), (start), true))\n\n/**\n * for_each_cpu_and - iterate over every cpu in both masks\n * @cpu: the (optionally unsigned) integer iterator\n * @mask1: the first cpumask pointer\n * @mask2: the second cpumask pointer\n *\n * This saves a temporary CPU mask in many places.  It is equivalent to:\n *\tstruct cpumask tmp;\n *\tcpumask_and(&tmp, &mask1, &mask2);\n *\tfor_each_cpu(cpu, &tmp)\n *\t\t...\n *\n * After the loop, cpu is >= nr_cpu_ids.\n */\n#define for_each_cpu_and(cpu, mask1, mask2)\t\t\t\t\\\n\tfor ((cpu) = -1;\t\t\t\t\t\t\\\n\t\t(cpu) = cpumask_next_and((cpu), (mask1), (mask2)),\t\\\n\t\t(cpu) < nr_cpu_ids;)\n#endif /* SMP */\n\n#define CPU_BITS_NONE\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t[0 ... BITS_TO_LONGS(NR_CPUS)-1] = 0UL\t\t\t\\\n}\n\n#define CPU_BITS_CPU0\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t[0] =  1UL\t\t\t\t\t\t\\\n}\n\n/**\n * cpumask_set_cpu - set a cpu in a cpumask\n * @cpu: cpu number (< nr_cpu_ids)\n * @dstp: the cpumask pointer\n */\nstatic inline void cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)\n{\n\tset_bit(cpumask_check(cpu), cpumask_bits(dstp));\n}\n\nstatic inline void __cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)\n{\n\t__set_bit(cpumask_check(cpu), cpumask_bits(dstp));\n}\n\n\n/**\n * cpumask_clear_cpu - clear a cpu in a cpumask\n * @cpu: cpu number (< nr_cpu_ids)\n * @dstp: the cpumask pointer\n */\nstatic inline void cpumask_clear_cpu(int cpu, struct cpumask *dstp)\n{\n\tclear_bit(cpumask_check(cpu), cpumask_bits(dstp));\n}\n\nstatic inline void __cpumask_clear_cpu(int cpu, struct cpumask *dstp)\n{\n\t__clear_bit(cpumask_check(cpu), cpumask_bits(dstp));\n}\n\n/**\n * cpumask_test_cpu - test for a cpu in a cpumask\n * @cpu: cpu number (< nr_cpu_ids)\n * @cpumask: the cpumask pointer\n *\n * Returns 1 if @cpu is set in @cpumask, else returns 0\n */\nstatic inline int cpumask_test_cpu(int cpu, const struct cpumask *cpumask)\n{\n\treturn test_bit(cpumask_check(cpu), cpumask_bits((cpumask)));\n}\n\n/**\n * cpumask_test_and_set_cpu - atomically test and set a cpu in a cpumask\n * @cpu: cpu number (< nr_cpu_ids)\n * @cpumask: the cpumask pointer\n *\n * Returns 1 if @cpu is set in old bitmap of @cpumask, else returns 0\n *\n * test_and_set_bit wrapper for cpumasks.\n */\nstatic inline int cpumask_test_and_set_cpu(int cpu, struct cpumask *cpumask)\n{\n\treturn test_and_set_bit(cpumask_check(cpu), cpumask_bits(cpumask));\n}\n\n/**\n * cpumask_test_and_clear_cpu - atomically test and clear a cpu in a cpumask\n * @cpu: cpu number (< nr_cpu_ids)\n * @cpumask: the cpumask pointer\n *\n * Returns 1 if @cpu is set in old bitmap of @cpumask, else returns 0\n *\n * test_and_clear_bit wrapper for cpumasks.\n */\nstatic inline int cpumask_test_and_clear_cpu(int cpu, struct cpumask *cpumask)\n{\n\treturn test_and_clear_bit(cpumask_check(cpu), cpumask_bits(cpumask));\n}\n\n/**\n * cpumask_setall - set all cpus (< nr_cpu_ids) in a cpumask\n * @dstp: the cpumask pointer\n */\nstatic inline void cpumask_setall(struct cpumask *dstp)\n{\n\tbitmap_fill(cpumask_bits(dstp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_clear - clear all cpus (< nr_cpu_ids) in a cpumask\n * @dstp: the cpumask pointer\n */\nstatic inline void cpumask_clear(struct cpumask *dstp)\n{\n\tbitmap_zero(cpumask_bits(dstp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_and - *dstp = *src1p & *src2p\n * @dstp: the cpumask result\n * @src1p: the first input\n * @src2p: the second input\n *\n * If *@dstp is empty, returns 0, else returns 1\n */\nstatic inline int cpumask_and(struct cpumask *dstp,\n\t\t\t       const struct cpumask *src1p,\n\t\t\t       const struct cpumask *src2p)\n{\n\treturn bitmap_and(cpumask_bits(dstp), cpumask_bits(src1p),\n\t\t\t\t       cpumask_bits(src2p), nr_cpumask_bits);\n}\n\n/**\n * cpumask_or - *dstp = *src1p | *src2p\n * @dstp: the cpumask result\n * @src1p: the first input\n * @src2p: the second input\n */\nstatic inline void cpumask_or(struct cpumask *dstp, const struct cpumask *src1p,\n\t\t\t      const struct cpumask *src2p)\n{\n\tbitmap_or(cpumask_bits(dstp), cpumask_bits(src1p),\n\t\t\t\t      cpumask_bits(src2p), nr_cpumask_bits);\n}\n\n/**\n * cpumask_xor - *dstp = *src1p ^ *src2p\n * @dstp: the cpumask result\n * @src1p: the first input\n * @src2p: the second input\n */\nstatic inline void cpumask_xor(struct cpumask *dstp,\n\t\t\t       const struct cpumask *src1p,\n\t\t\t       const struct cpumask *src2p)\n{\n\tbitmap_xor(cpumask_bits(dstp), cpumask_bits(src1p),\n\t\t\t\t       cpumask_bits(src2p), nr_cpumask_bits);\n}\n\n/**\n * cpumask_andnot - *dstp = *src1p & ~*src2p\n * @dstp: the cpumask result\n * @src1p: the first input\n * @src2p: the second input\n *\n * If *@dstp is empty, returns 0, else returns 1\n */\nstatic inline int cpumask_andnot(struct cpumask *dstp,\n\t\t\t\t  const struct cpumask *src1p,\n\t\t\t\t  const struct cpumask *src2p)\n{\n\treturn bitmap_andnot(cpumask_bits(dstp), cpumask_bits(src1p),\n\t\t\t\t\t  cpumask_bits(src2p), nr_cpumask_bits);\n}\n\n/**\n * cpumask_complement - *dstp = ~*srcp\n * @dstp: the cpumask result\n * @srcp: the input to invert\n */\nstatic inline void cpumask_complement(struct cpumask *dstp,\n\t\t\t\t      const struct cpumask *srcp)\n{\n\tbitmap_complement(cpumask_bits(dstp), cpumask_bits(srcp),\n\t\t\t\t\t      nr_cpumask_bits);\n}\n\n/**\n * cpumask_equal - *src1p == *src2p\n * @src1p: the first input\n * @src2p: the second input\n */\nstatic inline bool cpumask_equal(const struct cpumask *src1p,\n\t\t\t\tconst struct cpumask *src2p)\n{\n\treturn bitmap_equal(cpumask_bits(src1p), cpumask_bits(src2p),\n\t\t\t\t\t\t nr_cpumask_bits);\n}\n\n/**\n * cpumask_or_equal - *src1p | *src2p == *src3p\n * @src1p: the first input\n * @src2p: the second input\n * @src3p: the third input\n */\nstatic inline bool cpumask_or_equal(const struct cpumask *src1p,\n\t\t\t\t    const struct cpumask *src2p,\n\t\t\t\t    const struct cpumask *src3p)\n{\n\treturn bitmap_or_equal(cpumask_bits(src1p), cpumask_bits(src2p),\n\t\t\t       cpumask_bits(src3p), nr_cpumask_bits);\n}\n\n/**\n * cpumask_intersects - (*src1p & *src2p) != 0\n * @src1p: the first input\n * @src2p: the second input\n */\nstatic inline bool cpumask_intersects(const struct cpumask *src1p,\n\t\t\t\t     const struct cpumask *src2p)\n{\n\treturn bitmap_intersects(cpumask_bits(src1p), cpumask_bits(src2p),\n\t\t\t\t\t\t      nr_cpumask_bits);\n}\n\n/**\n * cpumask_subset - (*src1p & ~*src2p) == 0\n * @src1p: the first input\n * @src2p: the second input\n *\n * Returns 1 if *@src1p is a subset of *@src2p, else returns 0\n */\nstatic inline int cpumask_subset(const struct cpumask *src1p,\n\t\t\t\t const struct cpumask *src2p)\n{\n\treturn bitmap_subset(cpumask_bits(src1p), cpumask_bits(src2p),\n\t\t\t\t\t\t  nr_cpumask_bits);\n}\n\n/**\n * cpumask_empty - *srcp == 0\n * @srcp: the cpumask to that all cpus < nr_cpu_ids are clear.\n */\nstatic inline bool cpumask_empty(const struct cpumask *srcp)\n{\n\treturn bitmap_empty(cpumask_bits(srcp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_full - *srcp == 0xFFFFFFFF...\n * @srcp: the cpumask to that all cpus < nr_cpu_ids are set.\n */\nstatic inline bool cpumask_full(const struct cpumask *srcp)\n{\n\treturn bitmap_full(cpumask_bits(srcp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_weight - Count of bits in *srcp\n * @srcp: the cpumask to count bits (< nr_cpu_ids) in.\n */\nstatic inline unsigned int cpumask_weight(const struct cpumask *srcp)\n{\n\treturn bitmap_weight(cpumask_bits(srcp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_shift_right - *dstp = *srcp >> n\n * @dstp: the cpumask result\n * @srcp: the input to shift\n * @n: the number of bits to shift by\n */\nstatic inline void cpumask_shift_right(struct cpumask *dstp,\n\t\t\t\t       const struct cpumask *srcp, int n)\n{\n\tbitmap_shift_right(cpumask_bits(dstp), cpumask_bits(srcp), n,\n\t\t\t\t\t       nr_cpumask_bits);\n}\n\n/**\n * cpumask_shift_left - *dstp = *srcp << n\n * @dstp: the cpumask result\n * @srcp: the input to shift\n * @n: the number of bits to shift by\n */\nstatic inline void cpumask_shift_left(struct cpumask *dstp,\n\t\t\t\t      const struct cpumask *srcp, int n)\n{\n\tbitmap_shift_left(cpumask_bits(dstp), cpumask_bits(srcp), n,\n\t\t\t\t\t      nr_cpumask_bits);\n}\n\n/**\n * cpumask_copy - *dstp = *srcp\n * @dstp: the result\n * @srcp: the input cpumask\n */\nstatic inline void cpumask_copy(struct cpumask *dstp,\n\t\t\t\tconst struct cpumask *srcp)\n{\n\tbitmap_copy(cpumask_bits(dstp), cpumask_bits(srcp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_any - pick a \"random\" cpu from *srcp\n * @srcp: the input cpumask\n *\n * Returns >= nr_cpu_ids if no cpus set.\n */\n#define cpumask_any(srcp) cpumask_first(srcp)\n\n/**\n * cpumask_first_and - return the first cpu from *srcp1 & *srcp2\n * @src1p: the first input\n * @src2p: the second input\n *\n * Returns >= nr_cpu_ids if no cpus set in both.  See also cpumask_next_and().\n */\n#define cpumask_first_and(src1p, src2p) cpumask_next_and(-1, (src1p), (src2p))\n\n/**\n * cpumask_any_and - pick a \"random\" cpu from *mask1 & *mask2\n * @mask1: the first input cpumask\n * @mask2: the second input cpumask\n *\n * Returns >= nr_cpu_ids if no cpus set.\n */\n#define cpumask_any_and(mask1, mask2) cpumask_first_and((mask1), (mask2))\n\n/**\n * cpumask_of - the cpumask containing just a given cpu\n * @cpu: the cpu (<= nr_cpu_ids)\n */\n#define cpumask_of(cpu) (get_cpu_mask(cpu))\n\n/**\n * cpumask_parse_user - extract a cpumask from a user string\n * @buf: the buffer to extract from\n * @len: the length of the buffer\n * @dstp: the cpumask to set.\n *\n * Returns -errno, or 0 for success.\n */\nstatic inline int cpumask_parse_user(const char __user *buf, int len,\n\t\t\t\t     struct cpumask *dstp)\n{\n\treturn bitmap_parse_user(buf, len, cpumask_bits(dstp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_parselist_user - extract a cpumask from a user string\n * @buf: the buffer to extract from\n * @len: the length of the buffer\n * @dstp: the cpumask to set.\n *\n * Returns -errno, or 0 for success.\n */\nstatic inline int cpumask_parselist_user(const char __user *buf, int len,\n\t\t\t\t     struct cpumask *dstp)\n{\n\treturn bitmap_parselist_user(buf, len, cpumask_bits(dstp),\n\t\t\t\t     nr_cpumask_bits);\n}\n\n/**\n * cpumask_parse - extract a cpumask from a string\n * @buf: the buffer to extract from\n * @dstp: the cpumask to set.\n *\n * Returns -errno, or 0 for success.\n */\nstatic inline int cpumask_parse(const char *buf, struct cpumask *dstp)\n{\n\treturn bitmap_parse(buf, UINT_MAX, cpumask_bits(dstp), nr_cpumask_bits);\n}\n\n/**\n * cpulist_parse - extract a cpumask from a user string of ranges\n * @buf: the buffer to extract from\n * @dstp: the cpumask to set.\n *\n * Returns -errno, or 0 for success.\n */\nstatic inline int cpulist_parse(const char *buf, struct cpumask *dstp)\n{\n\treturn bitmap_parselist(buf, cpumask_bits(dstp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_size - size to allocate for a 'struct cpumask' in bytes\n */\nstatic inline unsigned int cpumask_size(void)\n{\n\treturn BITS_TO_LONGS(nr_cpumask_bits) * sizeof(long);\n}\n\n/*\n * cpumask_var_t: struct cpumask for stack usage.\n *\n * Oh, the wicked games we play!  In order to make kernel coding a\n * little more difficult, we typedef cpumask_var_t to an array or a\n * pointer: doing &mask on an array is a noop, so it still works.\n *\n * ie.\n *\tcpumask_var_t tmpmask;\n *\tif (!alloc_cpumask_var(&tmpmask, GFP_KERNEL))\n *\t\treturn -ENOMEM;\n *\n *\t  ... use 'tmpmask' like a normal struct cpumask * ...\n *\n *\tfree_cpumask_var(tmpmask);\n *\n *\n * However, one notable exception is there. alloc_cpumask_var() allocates\n * only nr_cpumask_bits bits (in the other hand, real cpumask_t always has\n * NR_CPUS bits). Therefore you don't have to dereference cpumask_var_t.\n *\n *\tcpumask_var_t tmpmask;\n *\tif (!alloc_cpumask_var(&tmpmask, GFP_KERNEL))\n *\t\treturn -ENOMEM;\n *\n *\tvar = *tmpmask;\n *\n * This code makes NR_CPUS length memcopy and brings to a memory corruption.\n * cpumask_copy() provide safe copy functionality.\n *\n * Note that there is another evil here: If you define a cpumask_var_t\n * as a percpu variable then the way to obtain the address of the cpumask\n * structure differently influences what this_cpu_* operation needs to be\n * used. Please use this_cpu_cpumask_var_t in those cases. The direct use\n * of this_cpu_ptr() or this_cpu_read() will lead to failures when the\n * other type of cpumask_var_t implementation is configured.\n *\n * Please also note that __cpumask_var_read_mostly can be used to declare\n * a cpumask_var_t variable itself (not its content) as read mostly.\n */\n#ifdef CONFIG_CPUMASK_OFFSTACK\ntypedef struct cpumask *cpumask_var_t;\n\n#define this_cpu_cpumask_var_ptr(x)\tthis_cpu_read(x)\n#define __cpumask_var_read_mostly\t__read_mostly\n\nbool alloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags, int node);\nbool alloc_cpumask_var(cpumask_var_t *mask, gfp_t flags);\nbool zalloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags, int node);\nbool zalloc_cpumask_var(cpumask_var_t *mask, gfp_t flags);\nvoid alloc_bootmem_cpumask_var(cpumask_var_t *mask);\nvoid free_cpumask_var(cpumask_var_t mask);\nvoid free_bootmem_cpumask_var(cpumask_var_t mask);\n\nstatic inline bool cpumask_available(cpumask_var_t mask)\n{\n\treturn mask != NULL;\n}\n\n#else\ntypedef struct cpumask cpumask_var_t[1];\n\n#define this_cpu_cpumask_var_ptr(x) this_cpu_ptr(x)\n#define __cpumask_var_read_mostly\n\nstatic inline bool alloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)\n{\n\treturn true;\n}\n\nstatic inline bool alloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags,\n\t\t\t\t\t  int node)\n{\n\treturn true;\n}\n\nstatic inline bool zalloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)\n{\n\tcpumask_clear(*mask);\n\treturn true;\n}\n\nstatic inline bool zalloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags,\n\t\t\t\t\t  int node)\n{\n\tcpumask_clear(*mask);\n\treturn true;\n}\n\nstatic inline void alloc_bootmem_cpumask_var(cpumask_var_t *mask)\n{\n}\n\nstatic inline void free_cpumask_var(cpumask_var_t mask)\n{\n}\n\nstatic inline void free_bootmem_cpumask_var(cpumask_var_t mask)\n{\n}\n\nstatic inline bool cpumask_available(cpumask_var_t mask)\n{\n\treturn true;\n}\n#endif /* CONFIG_CPUMASK_OFFSTACK */\n\n/* It's common to want to use cpu_all_mask in struct member initializers,\n * so it has to refer to an address rather than a pointer. */\nextern const DECLARE_BITMAP(cpu_all_bits, NR_CPUS);\n#define cpu_all_mask to_cpumask(cpu_all_bits)\n\n/* First bits of cpu_bit_bitmap are in fact unset. */\n#define cpu_none_mask to_cpumask(cpu_bit_bitmap[0])\n\n#define for_each_possible_cpu(cpu) for_each_cpu((cpu), cpu_possible_mask)\n#define for_each_online_cpu(cpu)   for_each_cpu((cpu), cpu_online_mask)\n#define for_each_present_cpu(cpu)  for_each_cpu((cpu), cpu_present_mask)\n\n/* Wrappers for arch boot code to manipulate normally-constant masks */\nvoid init_cpu_present(const struct cpumask *src);\nvoid init_cpu_possible(const struct cpumask *src);\nvoid init_cpu_online(const struct cpumask *src);\n\nstatic inline void reset_cpu_possible_mask(void)\n{\n\tbitmap_zero(cpumask_bits(&__cpu_possible_mask), NR_CPUS);\n}\n\nstatic inline void\nset_cpu_possible(unsigned int cpu, bool possible)\n{\n\tif (possible)\n\t\tcpumask_set_cpu(cpu, &__cpu_possible_mask);\n\telse\n\t\tcpumask_clear_cpu(cpu, &__cpu_possible_mask);\n}\n\nstatic inline void\nset_cpu_present(unsigned int cpu, bool present)\n{\n\tif (present)\n\t\tcpumask_set_cpu(cpu, &__cpu_present_mask);\n\telse\n\t\tcpumask_clear_cpu(cpu, &__cpu_present_mask);\n}\n\nvoid set_cpu_online(unsigned int cpu, bool online);\n\nstatic inline void\nset_cpu_active(unsigned int cpu, bool active)\n{\n\tif (active)\n\t\tcpumask_set_cpu(cpu, &__cpu_active_mask);\n\telse\n\t\tcpumask_clear_cpu(cpu, &__cpu_active_mask);\n}\n\n\n/**\n * to_cpumask - convert an NR_CPUS bitmap to a struct cpumask *\n * @bitmap: the bitmap\n *\n * There are a few places where cpumask_var_t isn't appropriate and\n * static cpumasks must be used (eg. very early boot), yet we don't\n * expose the definition of 'struct cpumask'.\n *\n * This does the conversion, and can be used as a constant initializer.\n */\n#define to_cpumask(bitmap)\t\t\t\t\t\t\\\n\t((struct cpumask *)(1 ? (bitmap)\t\t\t\t\\\n\t\t\t    : (void *)sizeof(__check_is_bitmap(bitmap))))\n\nstatic inline int __check_is_bitmap(const unsigned long *bitmap)\n{\n\treturn 1;\n}\n\n/*\n * Special-case data structure for \"single bit set only\" constant CPU masks.\n *\n * We pre-generate all the 64 (or 32) possible bit positions, with enough\n * padding to the left and the right, and return the constant pointer\n * appropriately offset.\n */\nextern const unsigned long\n\tcpu_bit_bitmap[BITS_PER_LONG+1][BITS_TO_LONGS(NR_CPUS)];\n\nstatic inline const struct cpumask *get_cpu_mask(unsigned int cpu)\n{\n\tconst unsigned long *p = cpu_bit_bitmap[1 + cpu % BITS_PER_LONG];\n\tp -= cpu / BITS_PER_LONG;\n\treturn to_cpumask(p);\n}\n\n#define cpu_is_offline(cpu)\tunlikely(!cpu_online(cpu))\n\n#if NR_CPUS <= BITS_PER_LONG\n#define CPU_BITS_ALL\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t[BITS_TO_LONGS(NR_CPUS)-1] = BITMAP_LAST_WORD_MASK(NR_CPUS)\t\\\n}\n\n#else /* NR_CPUS > BITS_PER_LONG */\n\n#define CPU_BITS_ALL\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t[0 ... BITS_TO_LONGS(NR_CPUS)-2] = ~0UL,\t\t\\\n\t[BITS_TO_LONGS(NR_CPUS)-1] = BITMAP_LAST_WORD_MASK(NR_CPUS)\t\\\n}\n#endif /* NR_CPUS > BITS_PER_LONG */\n\n/**\n * cpumap_print_to_pagebuf  - copies the cpumask into the buffer either\n *\tas comma-separated list of cpus or hex values of cpumask\n * @list: indicates whether the cpumap must be list\n * @mask: the cpumask to copy\n * @buf: the buffer to copy into\n *\n * Returns the length of the (null-terminated) @buf string, zero if\n * nothing is copied.\n */\nstatic inline ssize_t\ncpumap_print_to_pagebuf(bool list, char *buf, const struct cpumask *mask)\n{\n\treturn bitmap_print_to_pagebuf(list, buf, cpumask_bits(mask),\n\t\t\t\t      nr_cpu_ids);\n}\n\n#if NR_CPUS <= BITS_PER_LONG\n#define CPU_MASK_ALL\t\t\t\t\t\t\t\\\n(cpumask_t) { {\t\t\t\t\t\t\t\t\\\n\t[BITS_TO_LONGS(NR_CPUS)-1] = BITMAP_LAST_WORD_MASK(NR_CPUS)\t\\\n} }\n#else\n#define CPU_MASK_ALL\t\t\t\t\t\t\t\\\n(cpumask_t) { {\t\t\t\t\t\t\t\t\\\n\t[0 ... BITS_TO_LONGS(NR_CPUS)-2] = ~0UL,\t\t\t\\\n\t[BITS_TO_LONGS(NR_CPUS)-1] = BITMAP_LAST_WORD_MASK(NR_CPUS)\t\\\n} }\n#endif /* NR_CPUS > BITS_PER_LONG */\n\n#define CPU_MASK_NONE\t\t\t\t\t\t\t\\\n(cpumask_t) { {\t\t\t\t\t\t\t\t\\\n\t[0 ... BITS_TO_LONGS(NR_CPUS)-1] =  0UL\t\t\t\t\\\n} }\n\n#define CPU_MASK_CPU0\t\t\t\t\t\t\t\\\n(cpumask_t) { {\t\t\t\t\t\t\t\t\\\n\t[0] =  1UL\t\t\t\t\t\t\t\\\n} }\n\n#endif /* __LINUX_CPUMASK_H */\n"}, "3": {"id": 3, "path": "/src/include/linux/percpu-defs.h", "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * linux/percpu-defs.h - basic definitions for percpu areas\n *\n * DO NOT INCLUDE DIRECTLY OUTSIDE PERCPU IMPLEMENTATION PROPER.\n *\n * This file is separate from linux/percpu.h to avoid cyclic inclusion\n * dependency from arch header files.  Only to be included from\n * asm/percpu.h.\n *\n * This file includes macros necessary to declare percpu sections and\n * variables, and definitions of percpu accessors and operations.  It\n * should provide enough percpu features to arch header files even when\n * they can only include asm/percpu.h to avoid cyclic inclusion dependency.\n */\n\n#ifndef _LINUX_PERCPU_DEFS_H\n#define _LINUX_PERCPU_DEFS_H\n\n#ifdef CONFIG_SMP\n\n#ifdef MODULE\n#define PER_CPU_SHARED_ALIGNED_SECTION \"\"\n#define PER_CPU_ALIGNED_SECTION \"\"\n#else\n#define PER_CPU_SHARED_ALIGNED_SECTION \"..shared_aligned\"\n#define PER_CPU_ALIGNED_SECTION \"..shared_aligned\"\n#endif\n#define PER_CPU_FIRST_SECTION \"..first\"\n\n#else\n\n#define PER_CPU_SHARED_ALIGNED_SECTION \"\"\n#define PER_CPU_ALIGNED_SECTION \"..shared_aligned\"\n#define PER_CPU_FIRST_SECTION \"\"\n\n#endif\n\n/*\n * Base implementations of per-CPU variable declarations and definitions, where\n * the section in which the variable is to be placed is provided by the\n * 'sec' argument.  This may be used to affect the parameters governing the\n * variable's storage.\n *\n * NOTE!  The sections for the DECLARE and for the DEFINE must match, lest\n * linkage errors occur due the compiler generating the wrong code to access\n * that section.\n */\n#define __PCPU_ATTRS(sec)\t\t\t\t\t\t\\\n\t__percpu __attribute__((section(PER_CPU_BASE_SECTION sec)))\t\\\n\tPER_CPU_ATTRIBUTES\n\n#define __PCPU_DUMMY_ATTRS\t\t\t\t\t\t\\\n\t__section(\".discard\") __attribute__((unused))\n\n/*\n * s390 and alpha modules require percpu variables to be defined as\n * weak to force the compiler to generate GOT based external\n * references for them.  This is necessary because percpu sections\n * will be located outside of the usually addressable area.\n *\n * This definition puts the following two extra restrictions when\n * defining percpu variables.\n *\n * 1. The symbol must be globally unique, even the static ones.\n * 2. Static percpu variables cannot be defined inside a function.\n *\n * Archs which need weak percpu definitions should define\n * ARCH_NEEDS_WEAK_PER_CPU in asm/percpu.h when necessary.\n *\n * To ensure that the generic code observes the above two\n * restrictions, if CONFIG_DEBUG_FORCE_WEAK_PER_CPU is set weak\n * definition is used for all cases.\n */\n#if defined(ARCH_NEEDS_WEAK_PER_CPU) || defined(CONFIG_DEBUG_FORCE_WEAK_PER_CPU)\n/*\n * __pcpu_scope_* dummy variable is used to enforce scope.  It\n * receives the static modifier when it's used in front of\n * DEFINE_PER_CPU() and will trigger build failure if\n * DECLARE_PER_CPU() is used for the same variable.\n *\n * __pcpu_unique_* dummy variable is used to enforce symbol uniqueness\n * such that hidden weak symbol collision, which will cause unrelated\n * variables to share the same address, can be detected during build.\n */\n#define DECLARE_PER_CPU_SECTION(type, name, sec)\t\t\t\\\n\textern __PCPU_DUMMY_ATTRS char __pcpu_scope_##name;\t\t\\\n\textern __PCPU_ATTRS(sec) __typeof__(type) name\n\n#define DEFINE_PER_CPU_SECTION(type, name, sec)\t\t\t\t\\\n\t__PCPU_DUMMY_ATTRS char __pcpu_scope_##name;\t\t\t\\\n\textern __PCPU_DUMMY_ATTRS char __pcpu_unique_##name;\t\t\\\n\t__PCPU_DUMMY_ATTRS char __pcpu_unique_##name;\t\t\t\\\n\textern __PCPU_ATTRS(sec) __typeof__(type) name;\t\t\t\\\n\t__PCPU_ATTRS(sec) __weak __typeof__(type) name\n#else\n/*\n * Normal declaration and definition macros.\n */\n#define DECLARE_PER_CPU_SECTION(type, name, sec)\t\t\t\\\n\textern __PCPU_ATTRS(sec) __typeof__(type) name\n\n#define DEFINE_PER_CPU_SECTION(type, name, sec)\t\t\t\t\\\n\t__PCPU_ATTRS(sec) __typeof__(type) name\n#endif\n\n/*\n * Variant on the per-CPU variable declaration/definition theme used for\n * ordinary per-CPU variables.\n */\n#define DECLARE_PER_CPU(type, name)\t\t\t\t\t\\\n\tDECLARE_PER_CPU_SECTION(type, name, \"\")\n\n#define DEFINE_PER_CPU(type, name)\t\t\t\t\t\\\n\tDEFINE_PER_CPU_SECTION(type, name, \"\")\n\n/*\n * Declaration/definition used for per-CPU variables that must come first in\n * the set of variables.\n */\n#define DECLARE_PER_CPU_FIRST(type, name)\t\t\t\t\\\n\tDECLARE_PER_CPU_SECTION(type, name, PER_CPU_FIRST_SECTION)\n\n#define DEFINE_PER_CPU_FIRST(type, name)\t\t\t\t\\\n\tDEFINE_PER_CPU_SECTION(type, name, PER_CPU_FIRST_SECTION)\n\n/*\n * Declaration/definition used for per-CPU variables that must be cacheline\n * aligned under SMP conditions so that, whilst a particular instance of the\n * data corresponds to a particular CPU, inefficiencies due to direct access by\n * other CPUs are reduced by preventing the data from unnecessarily spanning\n * cachelines.\n *\n * An example of this would be statistical data, where each CPU's set of data\n * is updated by that CPU alone, but the data from across all CPUs is collated\n * by a CPU processing a read from a proc file.\n */\n#define DECLARE_PER_CPU_SHARED_ALIGNED(type, name)\t\t\t\\\n\tDECLARE_PER_CPU_SECTION(type, name, PER_CPU_SHARED_ALIGNED_SECTION) \\\n\t____cacheline_aligned_in_smp\n\n#define DEFINE_PER_CPU_SHARED_ALIGNED(type, name)\t\t\t\\\n\tDEFINE_PER_CPU_SECTION(type, name, PER_CPU_SHARED_ALIGNED_SECTION) \\\n\t____cacheline_aligned_in_smp\n\n#define DECLARE_PER_CPU_ALIGNED(type, name)\t\t\t\t\\\n\tDECLARE_PER_CPU_SECTION(type, name, PER_CPU_ALIGNED_SECTION)\t\\\n\t____cacheline_aligned\n\n#define DEFINE_PER_CPU_ALIGNED(type, name)\t\t\t\t\\\n\tDEFINE_PER_CPU_SECTION(type, name, PER_CPU_ALIGNED_SECTION)\t\\\n\t____cacheline_aligned\n\n/*\n * Declaration/definition used for per-CPU variables that must be page aligned.\n */\n#define DECLARE_PER_CPU_PAGE_ALIGNED(type, name)\t\t\t\\\n\tDECLARE_PER_CPU_SECTION(type, name, \"..page_aligned\")\t\t\\\n\t__aligned(PAGE_SIZE)\n\n#define DEFINE_PER_CPU_PAGE_ALIGNED(type, name)\t\t\t\t\\\n\tDEFINE_PER_CPU_SECTION(type, name, \"..page_aligned\")\t\t\\\n\t__aligned(PAGE_SIZE)\n\n/*\n * Declaration/definition used for per-CPU variables that must be read mostly.\n */\n#define DECLARE_PER_CPU_READ_MOSTLY(type, name)\t\t\t\\\n\tDECLARE_PER_CPU_SECTION(type, name, \"..read_mostly\")\n\n#define DEFINE_PER_CPU_READ_MOSTLY(type, name)\t\t\t\t\\\n\tDEFINE_PER_CPU_SECTION(type, name, \"..read_mostly\")\n\n/*\n * Declaration/definition used for per-CPU variables that should be accessed\n * as decrypted when memory encryption is enabled in the guest.\n */\n#ifdef CONFIG_AMD_MEM_ENCRYPT\n#define DECLARE_PER_CPU_DECRYPTED(type, name)\t\t\t\t\\\n\tDECLARE_PER_CPU_SECTION(type, name, \"..decrypted\")\n\n#define DEFINE_PER_CPU_DECRYPTED(type, name)\t\t\t\t\\\n\tDEFINE_PER_CPU_SECTION(type, name, \"..decrypted\")\n#else\n#define DEFINE_PER_CPU_DECRYPTED(type, name)\tDEFINE_PER_CPU(type, name)\n#endif\n\n/*\n * Intermodule exports for per-CPU variables.  sparse forgets about\n * address space across EXPORT_SYMBOL(), change EXPORT_SYMBOL() to\n * noop if __CHECKER__.\n */\n#ifndef __CHECKER__\n#define EXPORT_PER_CPU_SYMBOL(var) EXPORT_SYMBOL(var)\n#define EXPORT_PER_CPU_SYMBOL_GPL(var) EXPORT_SYMBOL_GPL(var)\n#else\n#define EXPORT_PER_CPU_SYMBOL(var)\n#define EXPORT_PER_CPU_SYMBOL_GPL(var)\n#endif\n\n/*\n * Accessors and operations.\n */\n#ifndef __ASSEMBLY__\n\n/*\n * __verify_pcpu_ptr() verifies @ptr is a percpu pointer without evaluating\n * @ptr and is invoked once before a percpu area is accessed by all\n * accessors and operations.  This is performed in the generic part of\n * percpu and arch overrides don't need to worry about it; however, if an\n * arch wants to implement an arch-specific percpu accessor or operation,\n * it may use __verify_pcpu_ptr() to verify the parameters.\n *\n * + 0 is required in order to convert the pointer type from a\n * potential array type to a pointer to a single item of the array.\n */\n#define __verify_pcpu_ptr(ptr)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tconst void __percpu *__vpp_verify = (typeof((ptr) + 0))NULL;\t\\\n\t(void)__vpp_verify;\t\t\t\t\t\t\\\n} while (0)\n\n#define per_cpu_sum(var)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(var) __sum = 0;\t\t\t\t\t\t\\\n\tint cpu;\t\t\t\t\t\t\t\\\n\tcompiletime_assert_atomic_type(__sum);\t\t\t\t\\\n\tfor_each_possible_cpu(cpu)\t\t\t\t\t\\\n\t\t__sum += per_cpu(var, cpu);\t\t\t\t\\\n\t__sum;\t\t\t\t\t\t\t\t\\\n})\n\n#ifdef CONFIG_SMP\n\n/*\n * Add an offset to a pointer but keep the pointer as-is.  Use RELOC_HIDE()\n * to prevent the compiler from making incorrect assumptions about the\n * pointer value.  The weird cast keeps both GCC and sparse happy.\n */\n#define SHIFT_PERCPU_PTR(__p, __offset)\t\t\t\t\t\\\n\tRELOC_HIDE((typeof(*(__p)) __kernel __force *)(__p), (__offset))\n\n#define per_cpu_ptr(ptr, cpu)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__verify_pcpu_ptr(ptr);\t\t\t\t\t\t\\\n\tSHIFT_PERCPU_PTR((ptr), per_cpu_offset((cpu)));\t\t\t\\\n})\n\n#define raw_cpu_ptr(ptr)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__verify_pcpu_ptr(ptr);\t\t\t\t\t\t\\\n\tarch_raw_cpu_ptr(ptr);\t\t\t\t\t\t\\\n})\n\n#ifdef CONFIG_DEBUG_PREEMPT\n#define this_cpu_ptr(ptr)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__verify_pcpu_ptr(ptr);\t\t\t\t\t\t\\\n\tSHIFT_PERCPU_PTR(ptr, my_cpu_offset);\t\t\t\t\\\n})\n#else\n#define this_cpu_ptr(ptr) raw_cpu_ptr(ptr)\n#endif\n\n#else\t/* CONFIG_SMP */\n\n#define VERIFY_PERCPU_PTR(__p)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__verify_pcpu_ptr(__p);\t\t\t\t\t\t\\\n\t(typeof(*(__p)) __kernel __force *)(__p);\t\t\t\\\n})\n\n#define per_cpu_ptr(ptr, cpu)\t({ (void)(cpu); VERIFY_PERCPU_PTR(ptr); })\n#define raw_cpu_ptr(ptr)\tper_cpu_ptr(ptr, 0)\n#define this_cpu_ptr(ptr)\traw_cpu_ptr(ptr)\n\n#endif\t/* CONFIG_SMP */\n\n#define per_cpu(var, cpu)\t(*per_cpu_ptr(&(var), cpu))\n\n/*\n * Must be an lvalue. Since @var must be a simple identifier,\n * we force a syntax error here if it isn't.\n */\n#define get_cpu_var(var)\t\t\t\t\t\t\\\n(*({\t\t\t\t\t\t\t\t\t\\\n\tpreempt_disable();\t\t\t\t\t\t\\\n\tthis_cpu_ptr(&var);\t\t\t\t\t\t\\\n}))\n\n/*\n * The weird & is necessary because sparse considers (void)(var) to be\n * a direct dereference of percpu variable (var).\n */\n#define put_cpu_var(var)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t(void)&(var);\t\t\t\t\t\t\t\\\n\tpreempt_enable();\t\t\t\t\t\t\\\n} while (0)\n\n#define get_cpu_ptr(var)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tpreempt_disable();\t\t\t\t\t\t\\\n\tthis_cpu_ptr(var);\t\t\t\t\t\t\\\n})\n\n#define put_cpu_ptr(var)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t(void)(var);\t\t\t\t\t\t\t\\\n\tpreempt_enable();\t\t\t\t\t\t\\\n} while (0)\n\n/*\n * Branching function to split up a function into a set of functions that\n * are called for different scalar sizes of the objects handled.\n */\n\nextern void __bad_size_call_parameter(void);\n\n#ifdef CONFIG_DEBUG_PREEMPT\nextern void __this_cpu_preempt_check(const char *op);\n#else\nstatic inline void __this_cpu_preempt_check(const char *op) { }\n#endif\n\n#define __pcpu_size_call_return(stem, variable)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(variable) pscr_ret__;\t\t\t\t\t\\\n\t__verify_pcpu_ptr(&(variable));\t\t\t\t\t\\\n\tswitch(sizeof(variable)) {\t\t\t\t\t\\\n\tcase 1: pscr_ret__ = stem##1(variable); break;\t\t\t\\\n\tcase 2: pscr_ret__ = stem##2(variable); break;\t\t\t\\\n\tcase 4: pscr_ret__ = stem##4(variable); break;\t\t\t\\\n\tcase 8: pscr_ret__ = stem##8(variable); break;\t\t\t\\\n\tdefault:\t\t\t\t\t\t\t\\\n\t\t__bad_size_call_parameter(); break;\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tpscr_ret__;\t\t\t\t\t\t\t\\\n})\n\n#define __pcpu_size_call_return2(stem, variable, ...)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(variable) pscr2_ret__;\t\t\t\t\t\\\n\t__verify_pcpu_ptr(&(variable));\t\t\t\t\t\\\n\tswitch(sizeof(variable)) {\t\t\t\t\t\\\n\tcase 1: pscr2_ret__ = stem##1(variable, __VA_ARGS__); break;\t\\\n\tcase 2: pscr2_ret__ = stem##2(variable, __VA_ARGS__); break;\t\\\n\tcase 4: pscr2_ret__ = stem##4(variable, __VA_ARGS__); break;\t\\\n\tcase 8: pscr2_ret__ = stem##8(variable, __VA_ARGS__); break;\t\\\n\tdefault:\t\t\t\t\t\t\t\\\n\t\t__bad_size_call_parameter(); break;\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tpscr2_ret__;\t\t\t\t\t\t\t\\\n})\n\n/*\n * Special handling for cmpxchg_double.  cmpxchg_double is passed two\n * percpu variables.  The first has to be aligned to a double word\n * boundary and the second has to follow directly thereafter.\n * We enforce this on all architectures even if they don't support\n * a double cmpxchg instruction, since it's a cheap requirement, and it\n * avoids breaking the requirement for architectures with the instruction.\n */\n#define __pcpu_double_call_return_bool(stem, pcp1, pcp2, ...)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tbool pdcrb_ret__;\t\t\t\t\t\t\\\n\t__verify_pcpu_ptr(&(pcp1));\t\t\t\t\t\\\n\tBUILD_BUG_ON(sizeof(pcp1) != sizeof(pcp2));\t\t\t\\\n\tVM_BUG_ON((unsigned long)(&(pcp1)) % (2 * sizeof(pcp1)));\t\\\n\tVM_BUG_ON((unsigned long)(&(pcp2)) !=\t\t\t\t\\\n\t\t  (unsigned long)(&(pcp1)) + sizeof(pcp1));\t\t\\\n\tswitch(sizeof(pcp1)) {\t\t\t\t\t\t\\\n\tcase 1: pdcrb_ret__ = stem##1(pcp1, pcp2, __VA_ARGS__); break;\t\\\n\tcase 2: pdcrb_ret__ = stem##2(pcp1, pcp2, __VA_ARGS__); break;\t\\\n\tcase 4: pdcrb_ret__ = stem##4(pcp1, pcp2, __VA_ARGS__); break;\t\\\n\tcase 8: pdcrb_ret__ = stem##8(pcp1, pcp2, __VA_ARGS__); break;\t\\\n\tdefault:\t\t\t\t\t\t\t\\\n\t\t__bad_size_call_parameter(); break;\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tpdcrb_ret__;\t\t\t\t\t\t\t\\\n})\n\n#define __pcpu_size_call(stem, variable, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t__verify_pcpu_ptr(&(variable));\t\t\t\t\t\\\n\tswitch(sizeof(variable)) {\t\t\t\t\t\\\n\t\tcase 1: stem##1(variable, __VA_ARGS__);break;\t\t\\\n\t\tcase 2: stem##2(variable, __VA_ARGS__);break;\t\t\\\n\t\tcase 4: stem##4(variable, __VA_ARGS__);break;\t\t\\\n\t\tcase 8: stem##8(variable, __VA_ARGS__);break;\t\t\\\n\t\tdefault: \t\t\t\t\t\t\\\n\t\t\t__bad_size_call_parameter();break;\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n/*\n * this_cpu operations (C) 2008-2013 Christoph Lameter <cl@linux.com>\n *\n * Optimized manipulation for memory allocated through the per cpu\n * allocator or for addresses of per cpu variables.\n *\n * These operation guarantee exclusivity of access for other operations\n * on the *same* processor. The assumption is that per cpu data is only\n * accessed by a single processor instance (the current one).\n *\n * The arch code can provide optimized implementation by defining macros\n * for certain scalar sizes. F.e. provide this_cpu_add_2() to provide per\n * cpu atomic operations for 2 byte sized RMW actions. If arch code does\n * not provide operations for a scalar size then the fallback in the\n * generic code will be used.\n *\n * cmpxchg_double replaces two adjacent scalars at once.  The first two\n * parameters are per cpu variables which have to be of the same size.  A\n * truth value is returned to indicate success or failure (since a double\n * register result is difficult to handle).  There is very limited hardware\n * support for these operations, so only certain sizes may work.\n */\n\n/*\n * Operations for contexts where we do not want to do any checks for\n * preemptions.  Unless strictly necessary, always use [__]this_cpu_*()\n * instead.\n *\n * If there is no other protection through preempt disable and/or disabling\n * interupts then one of these RMW operations can show unexpected behavior\n * because the execution thread was rescheduled on another processor or an\n * interrupt occurred and the same percpu variable was modified from the\n * interrupt context.\n */\n#define raw_cpu_read(pcp)\t\t__pcpu_size_call_return(raw_cpu_read_, pcp)\n#define raw_cpu_write(pcp, val)\t\t__pcpu_size_call(raw_cpu_write_, pcp, val)\n#define raw_cpu_add(pcp, val)\t\t__pcpu_size_call(raw_cpu_add_, pcp, val)\n#define raw_cpu_and(pcp, val)\t\t__pcpu_size_call(raw_cpu_and_, pcp, val)\n#define raw_cpu_or(pcp, val)\t\t__pcpu_size_call(raw_cpu_or_, pcp, val)\n#define raw_cpu_add_return(pcp, val)\t__pcpu_size_call_return2(raw_cpu_add_return_, pcp, val)\n#define raw_cpu_xchg(pcp, nval)\t\t__pcpu_size_call_return2(raw_cpu_xchg_, pcp, nval)\n#define raw_cpu_cmpxchg(pcp, oval, nval) \\\n\t__pcpu_size_call_return2(raw_cpu_cmpxchg_, pcp, oval, nval)\n#define raw_cpu_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2) \\\n\t__pcpu_double_call_return_bool(raw_cpu_cmpxchg_double_, pcp1, pcp2, oval1, oval2, nval1, nval2)\n\n#define raw_cpu_sub(pcp, val)\t\traw_cpu_add(pcp, -(val))\n#define raw_cpu_inc(pcp)\t\traw_cpu_add(pcp, 1)\n#define raw_cpu_dec(pcp)\t\traw_cpu_sub(pcp, 1)\n#define raw_cpu_sub_return(pcp, val)\traw_cpu_add_return(pcp, -(typeof(pcp))(val))\n#define raw_cpu_inc_return(pcp)\t\traw_cpu_add_return(pcp, 1)\n#define raw_cpu_dec_return(pcp)\t\traw_cpu_add_return(pcp, -1)\n\n/*\n * Operations for contexts that are safe from preemption/interrupts.  These\n * operations verify that preemption is disabled.\n */\n#define __this_cpu_read(pcp)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__this_cpu_preempt_check(\"read\");\t\t\t\t\\\n\traw_cpu_read(pcp);\t\t\t\t\t\t\\\n})\n\n#define __this_cpu_write(pcp, val)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__this_cpu_preempt_check(\"write\");\t\t\t\t\\\n\traw_cpu_write(pcp, val);\t\t\t\t\t\\\n})\n\n#define __this_cpu_add(pcp, val)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__this_cpu_preempt_check(\"add\");\t\t\t\t\\\n\traw_cpu_add(pcp, val);\t\t\t\t\t\t\\\n})\n\n#define __this_cpu_and(pcp, val)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__this_cpu_preempt_check(\"and\");\t\t\t\t\\\n\traw_cpu_and(pcp, val);\t\t\t\t\t\t\\\n})\n\n#define __this_cpu_or(pcp, val)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__this_cpu_preempt_check(\"or\");\t\t\t\t\t\\\n\traw_cpu_or(pcp, val);\t\t\t\t\t\t\\\n})\n\n#define __this_cpu_add_return(pcp, val)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__this_cpu_preempt_check(\"add_return\");\t\t\t\t\\\n\traw_cpu_add_return(pcp, val);\t\t\t\t\t\\\n})\n\n#define __this_cpu_xchg(pcp, nval)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__this_cpu_preempt_check(\"xchg\");\t\t\t\t\\\n\traw_cpu_xchg(pcp, nval);\t\t\t\t\t\\\n})\n\n#define __this_cpu_cmpxchg(pcp, oval, nval)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__this_cpu_preempt_check(\"cmpxchg\");\t\t\t\t\\\n\traw_cpu_cmpxchg(pcp, oval, nval);\t\t\t\t\\\n})\n\n#define __this_cpu_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2) \\\n({\t__this_cpu_preempt_check(\"cmpxchg_double\");\t\t\t\\\n\traw_cpu_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2);\t\\\n})\n\n#define __this_cpu_sub(pcp, val)\t__this_cpu_add(pcp, -(typeof(pcp))(val))\n#define __this_cpu_inc(pcp)\t\t__this_cpu_add(pcp, 1)\n#define __this_cpu_dec(pcp)\t\t__this_cpu_sub(pcp, 1)\n#define __this_cpu_sub_return(pcp, val)\t__this_cpu_add_return(pcp, -(typeof(pcp))(val))\n#define __this_cpu_inc_return(pcp)\t__this_cpu_add_return(pcp, 1)\n#define __this_cpu_dec_return(pcp)\t__this_cpu_add_return(pcp, -1)\n\n/*\n * Operations with implied preemption/interrupt protection.  These\n * operations can be used without worrying about preemption or interrupt.\n */\n#define this_cpu_read(pcp)\t\t__pcpu_size_call_return(this_cpu_read_, pcp)\n#define this_cpu_write(pcp, val)\t__pcpu_size_call(this_cpu_write_, pcp, val)\n#define this_cpu_add(pcp, val)\t\t__pcpu_size_call(this_cpu_add_, pcp, val)\n#define this_cpu_and(pcp, val)\t\t__pcpu_size_call(this_cpu_and_, pcp, val)\n#define this_cpu_or(pcp, val)\t\t__pcpu_size_call(this_cpu_or_, pcp, val)\n#define this_cpu_add_return(pcp, val)\t__pcpu_size_call_return2(this_cpu_add_return_, pcp, val)\n#define this_cpu_xchg(pcp, nval)\t__pcpu_size_call_return2(this_cpu_xchg_, pcp, nval)\n#define this_cpu_cmpxchg(pcp, oval, nval) \\\n\t__pcpu_size_call_return2(this_cpu_cmpxchg_, pcp, oval, nval)\n#define this_cpu_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2) \\\n\t__pcpu_double_call_return_bool(this_cpu_cmpxchg_double_, pcp1, pcp2, oval1, oval2, nval1, nval2)\n\n#define this_cpu_sub(pcp, val)\t\tthis_cpu_add(pcp, -(typeof(pcp))(val))\n#define this_cpu_inc(pcp)\t\tthis_cpu_add(pcp, 1)\n#define this_cpu_dec(pcp)\t\tthis_cpu_sub(pcp, 1)\n#define this_cpu_sub_return(pcp, val)\tthis_cpu_add_return(pcp, -(typeof(pcp))(val))\n#define this_cpu_inc_return(pcp)\tthis_cpu_add_return(pcp, 1)\n#define this_cpu_dec_return(pcp)\tthis_cpu_add_return(pcp, -1)\n\n#endif /* __ASSEMBLY__ */\n#endif /* _LINUX_PERCPU_DEFS_H */\n"}, "4": {"id": 4, "path": "/src/include/linux/lockdep.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * Runtime locking correctness validator\n *\n *  Copyright (C) 2006,2007 Red Hat, Inc., Ingo Molnar <mingo@redhat.com>\n *  Copyright (C) 2007 Red Hat, Inc., Peter Zijlstra\n *\n * see Documentation/locking/lockdep-design.rst for more details.\n */\n#ifndef __LINUX_LOCKDEP_H\n#define __LINUX_LOCKDEP_H\n\n#include <linux/lockdep_types.h>\n#include <linux/smp.h>\n#include <asm/percpu.h>\n\nstruct task_struct;\n\n/* for sysctl */\nextern int prove_locking;\nextern int lock_stat;\n\n#ifdef CONFIG_LOCKDEP\n\n#include <linux/linkage.h>\n#include <linux/list.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n\nstatic inline void lockdep_copy_map(struct lockdep_map *to,\n\t\t\t\t    struct lockdep_map *from)\n{\n\tint i;\n\n\t*to = *from;\n\t/*\n\t * Since the class cache can be modified concurrently we could observe\n\t * half pointers (64bit arch using 32bit copy insns). Therefore clear\n\t * the caches and take the performance hit.\n\t *\n\t * XXX it doesn't work well with lockdep_set_class_and_subclass(), since\n\t *     that relies on cache abuse.\n\t */\n\tfor (i = 0; i < NR_LOCKDEP_CACHING_CLASSES; i++)\n\t\tto->class_cache[i] = NULL;\n}\n\n/*\n * Every lock has a list of other locks that were taken after it.\n * We only grow the list, never remove from it:\n */\nstruct lock_list {\n\tstruct list_head\t\tentry;\n\tstruct lock_class\t\t*class;\n\tstruct lock_class\t\t*links_to;\n\tconst struct lock_trace\t\t*trace;\n\tu16\t\t\t\tdistance;\n\t/* bitmap of different dependencies from head to this */\n\tu8\t\t\t\tdep;\n\t/* used by BFS to record whether \"prev -> this\" only has -(*R)-> */\n\tu8\t\t\t\tonly_xr;\n\n\t/*\n\t * The parent field is used to implement breadth-first search, and the\n\t * bit 0 is reused to indicate if the lock has been accessed in BFS.\n\t */\n\tstruct lock_list\t\t*parent;\n};\n\n/**\n * struct lock_chain - lock dependency chain record\n *\n * @irq_context: the same as irq_context in held_lock below\n * @depth:       the number of held locks in this chain\n * @base:        the index in chain_hlocks for this chain\n * @entry:       the collided lock chains in lock_chain hash list\n * @chain_key:   the hash key of this lock_chain\n */\nstruct lock_chain {\n\t/* see BUILD_BUG_ON()s in add_chain_cache() */\n\tunsigned int\t\t\tirq_context :  2,\n\t\t\t\t\tdepth       :  6,\n\t\t\t\t\tbase\t    : 24;\n\t/* 4 byte hole */\n\tstruct hlist_node\t\tentry;\n\tu64\t\t\t\tchain_key;\n};\n\n#define MAX_LOCKDEP_KEYS_BITS\t\t13\n#define MAX_LOCKDEP_KEYS\t\t(1UL << MAX_LOCKDEP_KEYS_BITS)\n#define INITIAL_CHAIN_KEY\t\t-1\n\nstruct held_lock {\n\t/*\n\t * One-way hash of the dependency chain up to this point. We\n\t * hash the hashes step by step as the dependency chain grows.\n\t *\n\t * We use it for dependency-caching and we skip detection\n\t * passes and dependency-updates if there is a cache-hit, so\n\t * it is absolutely critical for 100% coverage of the validator\n\t * to have a unique key value for every unique dependency path\n\t * that can occur in the system, to make a unique hash value\n\t * as likely as possible - hence the 64-bit width.\n\t *\n\t * The task struct holds the current hash value (initialized\n\t * with zero), here we store the previous hash value:\n\t */\n\tu64\t\t\t\tprev_chain_key;\n\tunsigned long\t\t\tacquire_ip;\n\tstruct lockdep_map\t\t*instance;\n\tstruct lockdep_map\t\t*nest_lock;\n#ifdef CONFIG_LOCK_STAT\n\tu64 \t\t\t\twaittime_stamp;\n\tu64\t\t\t\tholdtime_stamp;\n#endif\n\t/*\n\t * class_idx is zero-indexed; it points to the element in\n\t * lock_classes this held lock instance belongs to. class_idx is in\n\t * the range from 0 to (MAX_LOCKDEP_KEYS-1) inclusive.\n\t */\n\tunsigned int\t\t\tclass_idx:MAX_LOCKDEP_KEYS_BITS;\n\t/*\n\t * The lock-stack is unified in that the lock chains of interrupt\n\t * contexts nest ontop of process context chains, but we 'separate'\n\t * the hashes by starting with 0 if we cross into an interrupt\n\t * context, and we also keep do not add cross-context lock\n\t * dependencies - the lock usage graph walking covers that area\n\t * anyway, and we'd just unnecessarily increase the number of\n\t * dependencies otherwise. [Note: hardirq and softirq contexts\n\t * are separated from each other too.]\n\t *\n\t * The following field is used to detect when we cross into an\n\t * interrupt context:\n\t */\n\tunsigned int irq_context:2; /* bit 0 - soft, bit 1 - hard */\n\tunsigned int trylock:1;\t\t\t\t\t\t/* 16 bits */\n\n\tunsigned int read:2;        /* see lock_acquire() comment */\n\tunsigned int check:1;       /* see lock_acquire() comment */\n\tunsigned int hardirqs_off:1;\n\tunsigned int references:12;\t\t\t\t\t/* 32 bits */\n\tunsigned int pin_count;\n};\n\n/*\n * Initialization, self-test and debugging-output methods:\n */\nextern void lockdep_init(void);\nextern void lockdep_reset(void);\nextern void lockdep_reset_lock(struct lockdep_map *lock);\nextern void lockdep_free_key_range(void *start, unsigned long size);\nextern asmlinkage void lockdep_sys_exit(void);\nextern void lockdep_set_selftest_task(struct task_struct *task);\n\nextern void lockdep_init_task(struct task_struct *task);\n\n/*\n * Split the recrursion counter in two to readily detect 'off' vs recursion.\n */\n#define LOCKDEP_RECURSION_BITS\t16\n#define LOCKDEP_OFF\t\t(1U << LOCKDEP_RECURSION_BITS)\n#define LOCKDEP_RECURSION_MASK\t(LOCKDEP_OFF - 1)\n\n/*\n * lockdep_{off,on}() are macros to avoid tracing and kprobes; not inlines due\n * to header dependencies.\n */\n\n#define lockdep_off()\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tcurrent->lockdep_recursion += LOCKDEP_OFF;\t\\\n} while (0)\n\n#define lockdep_on()\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tcurrent->lockdep_recursion -= LOCKDEP_OFF;\t\\\n} while (0)\n\nextern void lockdep_register_key(struct lock_class_key *key);\nextern void lockdep_unregister_key(struct lock_class_key *key);\n\n/*\n * These methods are used by specific locking variants (spinlocks,\n * rwlocks, mutexes and rwsems) to pass init/acquire/release events\n * to lockdep:\n */\n\nextern void lockdep_init_map_type(struct lockdep_map *lock, const char *name,\n\tstruct lock_class_key *key, int subclass, u8 inner, u8 outer, u8 lock_type);\n\nstatic inline void\nlockdep_init_map_waits(struct lockdep_map *lock, const char *name,\n\t\t       struct lock_class_key *key, int subclass, u8 inner, u8 outer)\n{\n\tlockdep_init_map_type(lock, name, key, subclass, inner, LD_WAIT_INV, LD_LOCK_NORMAL);\n}\n\nstatic inline void\nlockdep_init_map_wait(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass, u8 inner)\n{\n\tlockdep_init_map_waits(lock, name, key, subclass, inner, LD_WAIT_INV);\n}\n\nstatic inline void lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t\t     struct lock_class_key *key, int subclass)\n{\n\tlockdep_init_map_wait(lock, name, key, subclass, LD_WAIT_INV);\n}\n\n/*\n * Reinitialize a lock key - for cases where there is special locking or\n * special initialization of locks so that the validator gets the scope\n * of dependencies wrong: they are either too broad (they need a class-split)\n * or they are too narrow (they suffer from a false class-split):\n */\n#define lockdep_set_class(lock, key)\t\t\t\t\\\n\tlockdep_init_map_waits(&(lock)->dep_map, #key, key, 0,\t\\\n\t\t\t       (lock)->dep_map.wait_type_inner,\t\\\n\t\t\t       (lock)->dep_map.wait_type_outer)\n\n#define lockdep_set_class_and_name(lock, key, name)\t\t\\\n\tlockdep_init_map_waits(&(lock)->dep_map, name, key, 0,\t\\\n\t\t\t       (lock)->dep_map.wait_type_inner,\t\\\n\t\t\t       (lock)->dep_map.wait_type_outer)\n\n#define lockdep_set_class_and_subclass(lock, key, sub)\t\t\\\n\tlockdep_init_map_waits(&(lock)->dep_map, #key, key, sub,\\\n\t\t\t       (lock)->dep_map.wait_type_inner,\t\\\n\t\t\t       (lock)->dep_map.wait_type_outer)\n\n#define lockdep_set_subclass(lock, sub)\t\t\t\t\t\\\n\tlockdep_init_map_waits(&(lock)->dep_map, #lock, (lock)->dep_map.key, sub,\\\n\t\t\t       (lock)->dep_map.wait_type_inner,\t\t\\\n\t\t\t       (lock)->dep_map.wait_type_outer)\n\n#define lockdep_set_novalidate_class(lock) \\\n\tlockdep_set_class_and_name(lock, &__lockdep_no_validate__, #lock)\n\n/*\n * Compare locking classes\n */\n#define lockdep_match_class(lock, key) lockdep_match_key(&(lock)->dep_map, key)\n\nstatic inline int lockdep_match_key(struct lockdep_map *lock,\n\t\t\t\t    struct lock_class_key *key)\n{\n\treturn lock->key == key;\n}\n\n/*\n * Acquire a lock.\n *\n * Values for \"read\":\n *\n *   0: exclusive (write) acquire\n *   1: read-acquire (no recursion allowed)\n *   2: read-acquire with same-instance recursion allowed\n *\n * Values for check:\n *\n *   0: simple checks (freeing, held-at-exit-time, etc.)\n *   1: full validation\n */\nextern void lock_acquire(struct lockdep_map *lock, unsigned int subclass,\n\t\t\t int trylock, int read, int check,\n\t\t\t struct lockdep_map *nest_lock, unsigned long ip);\n\nextern void lock_release(struct lockdep_map *lock, unsigned long ip);\n\n/* lock_is_held_type() returns */\n#define LOCK_STATE_UNKNOWN\t-1\n#define LOCK_STATE_NOT_HELD\t0\n#define LOCK_STATE_HELD\t\t1\n\n/*\n * Same \"read\" as for lock_acquire(), except -1 means any.\n */\nextern int lock_is_held_type(const struct lockdep_map *lock, int read);\n\nstatic inline int lock_is_held(const struct lockdep_map *lock)\n{\n\treturn lock_is_held_type(lock, -1);\n}\n\n#define lockdep_is_held(lock)\t\tlock_is_held(&(lock)->dep_map)\n#define lockdep_is_held_type(lock, r)\tlock_is_held_type(&(lock)->dep_map, (r))\n\nextern void lock_set_class(struct lockdep_map *lock, const char *name,\n\t\t\t   struct lock_class_key *key, unsigned int subclass,\n\t\t\t   unsigned long ip);\n\nstatic inline void lock_set_subclass(struct lockdep_map *lock,\n\t\tunsigned int subclass, unsigned long ip)\n{\n\tlock_set_class(lock, lock->name, lock->key, subclass, ip);\n}\n\nextern void lock_downgrade(struct lockdep_map *lock, unsigned long ip);\n\n#define NIL_COOKIE (struct pin_cookie){ .val = 0U, }\n\nextern struct pin_cookie lock_pin_lock(struct lockdep_map *lock);\nextern void lock_repin_lock(struct lockdep_map *lock, struct pin_cookie);\nextern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n\n#define lockdep_depth(tsk)\t(debug_locks ? (tsk)->lockdep_depth : 0)\n\n#define lockdep_assert_held(l)\tdo {\t\t\t\t\t\\\n\t\tWARN_ON(debug_locks &&\t\t\t\t\t\\\n\t\t\tlockdep_is_held(l) == LOCK_STATE_NOT_HELD);\t\\\n\t} while (0)\n\n#define lockdep_assert_not_held(l)\tdo {\t\t\t\t\\\n\t\tWARN_ON(debug_locks &&\t\t\t\t\t\\\n\t\t\tlockdep_is_held(l) == LOCK_STATE_HELD);\t\t\\\n\t} while (0)\n\n#define lockdep_assert_held_write(l)\tdo {\t\t\t\\\n\t\tWARN_ON(debug_locks && !lockdep_is_held_type(l, 0));\t\\\n\t} while (0)\n\n#define lockdep_assert_held_read(l)\tdo {\t\t\t\t\\\n\t\tWARN_ON(debug_locks && !lockdep_is_held_type(l, 1));\t\\\n\t} while (0)\n\n#define lockdep_assert_held_once(l)\tdo {\t\t\t\t\\\n\t\tWARN_ON_ONCE(debug_locks && !lockdep_is_held(l));\t\\\n\t} while (0)\n\n#define lockdep_recursing(tsk)\t((tsk)->lockdep_recursion)\n\n#define lockdep_pin_lock(l)\tlock_pin_lock(&(l)->dep_map)\n#define lockdep_repin_lock(l,c)\tlock_repin_lock(&(l)->dep_map, (c))\n#define lockdep_unpin_lock(l,c)\tlock_unpin_lock(&(l)->dep_map, (c))\n\n#else /* !CONFIG_LOCKDEP */\n\nstatic inline void lockdep_init_task(struct task_struct *task)\n{\n}\n\nstatic inline void lockdep_off(void)\n{\n}\n\nstatic inline void lockdep_on(void)\n{\n}\n\nstatic inline void lockdep_set_selftest_task(struct task_struct *task)\n{\n}\n\n# define lock_acquire(l, s, t, r, c, n, i)\tdo { } while (0)\n# define lock_release(l, i)\t\t\tdo { } while (0)\n# define lock_downgrade(l, i)\t\t\tdo { } while (0)\n# define lock_set_class(l, n, k, s, i)\t\tdo { } while (0)\n# define lock_set_subclass(l, s, i)\t\tdo { } while (0)\n# define lockdep_init()\t\t\t\tdo { } while (0)\n# define lockdep_init_map_type(lock, name, key, sub, inner, outer, type) \\\n\t\tdo { (void)(name); (void)(key); } while (0)\n# define lockdep_init_map_waits(lock, name, key, sub, inner, outer) \\\n\t\tdo { (void)(name); (void)(key); } while (0)\n# define lockdep_init_map_wait(lock, name, key, sub, inner) \\\n\t\tdo { (void)(name); (void)(key); } while (0)\n# define lockdep_init_map(lock, name, key, sub) \\\n\t\tdo { (void)(name); (void)(key); } while (0)\n# define lockdep_set_class(lock, key)\t\tdo { (void)(key); } while (0)\n# define lockdep_set_class_and_name(lock, key, name) \\\n\t\tdo { (void)(key); (void)(name); } while (0)\n#define lockdep_set_class_and_subclass(lock, key, sub) \\\n\t\tdo { (void)(key); } while (0)\n#define lockdep_set_subclass(lock, sub)\t\tdo { } while (0)\n\n#define lockdep_set_novalidate_class(lock) do { } while (0)\n\n/*\n * We don't define lockdep_match_class() and lockdep_match_key() for !LOCKDEP\n * case since the result is not well defined and the caller should rather\n * #ifdef the call himself.\n */\n\n# define lockdep_reset()\t\tdo { debug_locks = 1; } while (0)\n# define lockdep_free_key_range(start, size)\tdo { } while (0)\n# define lockdep_sys_exit() \t\t\tdo { } while (0)\n\nstatic inline void lockdep_register_key(struct lock_class_key *key)\n{\n}\n\nstatic inline void lockdep_unregister_key(struct lock_class_key *key)\n{\n}\n\n#define lockdep_depth(tsk)\t(0)\n\n/*\n * Dummy forward declarations, allow users to write less ifdef-y code\n * and depend on dead code elimination.\n */\nextern int lock_is_held(const void *);\nextern int lockdep_is_held(const void *);\n#define lockdep_is_held_type(l, r)\t\t(1)\n\n#define lockdep_assert_held(l)\t\t\tdo { (void)(l); } while (0)\n#define lockdep_assert_not_held(l)\t\tdo { (void)(l); } while (0)\n#define lockdep_assert_held_write(l)\t\tdo { (void)(l); } while (0)\n#define lockdep_assert_held_read(l)\t\tdo { (void)(l); } while (0)\n#define lockdep_assert_held_once(l)\t\tdo { (void)(l); } while (0)\n\n#define lockdep_recursing(tsk)\t\t\t(0)\n\n#define NIL_COOKIE (struct pin_cookie){ }\n\n#define lockdep_pin_lock(l)\t\t\t({ struct pin_cookie cookie = { }; cookie; })\n#define lockdep_repin_lock(l, c)\t\tdo { (void)(l); (void)(c); } while (0)\n#define lockdep_unpin_lock(l, c)\t\tdo { (void)(l); (void)(c); } while (0)\n\n#endif /* !LOCKDEP */\n\nenum xhlock_context_t {\n\tXHLOCK_HARD,\n\tXHLOCK_SOFT,\n\tXHLOCK_CTX_NR,\n};\n\n#define lockdep_init_map_crosslock(m, n, k, s) do {} while (0)\n/*\n * To initialize a lockdep_map statically use this macro.\n * Note that _name must not be NULL.\n */\n#define STATIC_LOCKDEP_MAP_INIT(_name, _key) \\\n\t{ .name = (_name), .key = (void *)(_key), }\n\nstatic inline void lockdep_invariant_state(bool force) {}\nstatic inline void lockdep_free_task(struct task_struct *task) {}\n\n#ifdef CONFIG_LOCK_STAT\n\nextern void lock_contended(struct lockdep_map *lock, unsigned long ip);\nextern void lock_acquired(struct lockdep_map *lock, unsigned long ip);\n\n#define LOCK_CONTENDED(_lock, try, lock)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (!try(_lock)) {\t\t\t\t\t\\\n\t\tlock_contended(&(_lock)->dep_map, _RET_IP_);\t\\\n\t\tlock(_lock);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tlock_acquired(&(_lock)->dep_map, _RET_IP_);\t\t\t\\\n} while (0)\n\n#define LOCK_CONTENDED_RETURN(_lock, try, lock)\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tint ____err = 0;\t\t\t\t\t\\\n\tif (!try(_lock)) {\t\t\t\t\t\\\n\t\tlock_contended(&(_lock)->dep_map, _RET_IP_);\t\\\n\t\t____err = lock(_lock);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tif (!____err)\t\t\t\t\t\t\\\n\t\tlock_acquired(&(_lock)->dep_map, _RET_IP_);\t\\\n\t____err;\t\t\t\t\t\t\\\n})\n\n#else /* CONFIG_LOCK_STAT */\n\n#define lock_contended(lockdep_map, ip) do {} while (0)\n#define lock_acquired(lockdep_map, ip) do {} while (0)\n\n#define LOCK_CONTENDED(_lock, try, lock) \\\n\tlock(_lock)\n\n#define LOCK_CONTENDED_RETURN(_lock, try, lock) \\\n\tlock(_lock)\n\n#endif /* CONFIG_LOCK_STAT */\n\n#ifdef CONFIG_LOCKDEP\n\n/*\n * On lockdep we dont want the hand-coded irq-enable of\n * _raw_*_lock_flags() code, because lockdep assumes\n * that interrupts are not re-enabled during lock-acquire:\n */\n#define LOCK_CONTENDED_FLAGS(_lock, try, lock, lockfl, flags) \\\n\tLOCK_CONTENDED((_lock), (try), (lock))\n\n#else /* CONFIG_LOCKDEP */\n\n#define LOCK_CONTENDED_FLAGS(_lock, try, lock, lockfl, flags) \\\n\tlockfl((_lock), (flags))\n\n#endif /* CONFIG_LOCKDEP */\n\n#ifdef CONFIG_PROVE_LOCKING\nextern void print_irqtrace_events(struct task_struct *curr);\n#else\nstatic inline void print_irqtrace_events(struct task_struct *curr)\n{\n}\n#endif\n\n/* Variable used to make lockdep treat read_lock() as recursive in selftests */\n#ifdef CONFIG_DEBUG_LOCKING_API_SELFTESTS\nextern unsigned int force_read_lock_recursive;\n#else /* CONFIG_DEBUG_LOCKING_API_SELFTESTS */\n#define force_read_lock_recursive 0\n#endif /* CONFIG_DEBUG_LOCKING_API_SELFTESTS */\n\n#ifdef CONFIG_LOCKDEP\nextern bool read_lock_is_recursive(void);\n#else /* CONFIG_LOCKDEP */\n/* If !LOCKDEP, the value is meaningless */\n#define read_lock_is_recursive() 0\n#endif\n\n/*\n * For trivial one-depth nesting of a lock-class, the following\n * global define can be used. (Subsystems with multiple levels\n * of nesting should define their own lock-nesting subclasses.)\n */\n#define SINGLE_DEPTH_NESTING\t\t\t1\n\n/*\n * Map the dependency ops to NOP or to real lockdep ops, depending\n * on the per lock-class debug mode:\n */\n\n#define lock_acquire_exclusive(l, s, t, n, i)\t\tlock_acquire(l, s, t, 0, 1, n, i)\n#define lock_acquire_shared(l, s, t, n, i)\t\tlock_acquire(l, s, t, 1, 1, n, i)\n#define lock_acquire_shared_recursive(l, s, t, n, i)\tlock_acquire(l, s, t, 2, 1, n, i)\n\n#define spin_acquire(l, s, t, i)\t\tlock_acquire_exclusive(l, s, t, NULL, i)\n#define spin_acquire_nest(l, s, t, n, i)\tlock_acquire_exclusive(l, s, t, n, i)\n#define spin_release(l, i)\t\t\tlock_release(l, i)\n\n#define rwlock_acquire(l, s, t, i)\t\tlock_acquire_exclusive(l, s, t, NULL, i)\n#define rwlock_acquire_read(l, s, t, i)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (read_lock_is_recursive())\t\t\t\t\t\\\n\t\tlock_acquire_shared_recursive(l, s, t, NULL, i);\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tlock_acquire_shared(l, s, t, NULL, i);\t\t\t\\\n} while (0)\n\n#define rwlock_release(l, i)\t\t\tlock_release(l, i)\n\n#define seqcount_acquire(l, s, t, i)\t\tlock_acquire_exclusive(l, s, t, NULL, i)\n#define seqcount_acquire_read(l, s, t, i)\tlock_acquire_shared_recursive(l, s, t, NULL, i)\n#define seqcount_release(l, i)\t\t\tlock_release(l, i)\n\n#define mutex_acquire(l, s, t, i)\t\tlock_acquire_exclusive(l, s, t, NULL, i)\n#define mutex_acquire_nest(l, s, t, n, i)\tlock_acquire_exclusive(l, s, t, n, i)\n#define mutex_release(l, i)\t\t\tlock_release(l, i)\n\n#define rwsem_acquire(l, s, t, i)\t\tlock_acquire_exclusive(l, s, t, NULL, i)\n#define rwsem_acquire_nest(l, s, t, n, i)\tlock_acquire_exclusive(l, s, t, n, i)\n#define rwsem_acquire_read(l, s, t, i)\t\tlock_acquire_shared(l, s, t, NULL, i)\n#define rwsem_release(l, i)\t\t\tlock_release(l, i)\n\n#define lock_map_acquire(l)\t\t\tlock_acquire_exclusive(l, 0, 0, NULL, _THIS_IP_)\n#define lock_map_acquire_read(l)\t\tlock_acquire_shared_recursive(l, 0, 0, NULL, _THIS_IP_)\n#define lock_map_acquire_tryread(l)\t\tlock_acquire_shared_recursive(l, 0, 1, NULL, _THIS_IP_)\n#define lock_map_release(l)\t\t\tlock_release(l, _THIS_IP_)\n\n#ifdef CONFIG_PROVE_LOCKING\n# define might_lock(lock)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\ttypecheck(struct lockdep_map *, &(lock)->dep_map);\t\t\\\n\tlock_acquire(&(lock)->dep_map, 0, 0, 0, 1, NULL, _THIS_IP_);\t\\\n\tlock_release(&(lock)->dep_map, _THIS_IP_);\t\t\t\\\n} while (0)\n# define might_lock_read(lock)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\ttypecheck(struct lockdep_map *, &(lock)->dep_map);\t\t\\\n\tlock_acquire(&(lock)->dep_map, 0, 0, 1, 1, NULL, _THIS_IP_);\t\\\n\tlock_release(&(lock)->dep_map, _THIS_IP_);\t\t\t\\\n} while (0)\n# define might_lock_nested(lock, subclass)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\ttypecheck(struct lockdep_map *, &(lock)->dep_map);\t\t\\\n\tlock_acquire(&(lock)->dep_map, subclass, 0, 1, 1, NULL,\t\t\\\n\t\t     _THIS_IP_);\t\t\t\t\t\\\n\tlock_release(&(lock)->dep_map, _THIS_IP_);\t\t\t\\\n} while (0)\n\nDECLARE_PER_CPU(int, hardirqs_enabled);\nDECLARE_PER_CPU(int, hardirq_context);\nDECLARE_PER_CPU(unsigned int, lockdep_recursion);\n\n#define __lockdep_enabled\t(debug_locks && !this_cpu_read(lockdep_recursion))\n\n#define lockdep_assert_irqs_enabled()\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tWARN_ON_ONCE(__lockdep_enabled && !this_cpu_read(hardirqs_enabled)); \\\n} while (0)\n\n#define lockdep_assert_irqs_disabled()\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tWARN_ON_ONCE(__lockdep_enabled && this_cpu_read(hardirqs_enabled)); \\\n} while (0)\n\n#define lockdep_assert_in_irq()\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tWARN_ON_ONCE(__lockdep_enabled && !this_cpu_read(hardirq_context)); \\\n} while (0)\n\n#define lockdep_assert_preemption_enabled()\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_COUNT)\t&&\t\t\\\n\t\t     __lockdep_enabled\t\t\t&&\t\t\\\n\t\t     (preempt_count() != 0\t\t||\t\t\\\n\t\t      !this_cpu_read(hardirqs_enabled)));\t\t\\\n} while (0)\n\n#define lockdep_assert_preemption_disabled()\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_COUNT)\t&&\t\t\\\n\t\t     __lockdep_enabled\t\t\t&&\t\t\\\n\t\t     (preempt_count() == 0\t\t&&\t\t\\\n\t\t      this_cpu_read(hardirqs_enabled)));\t\t\\\n} while (0)\n\n/*\n * Acceptable for protecting per-CPU resources accessed from BH.\n * Much like in_softirq() - semantics are ambiguous, use carefully.\n */\n#define lockdep_assert_in_softirq()\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tWARN_ON_ONCE(__lockdep_enabled\t\t\t&&\t\t\\\n\t\t     (!in_softirq() || in_irq() || in_nmi()));\t\t\\\n} while (0)\n\n#else\n# define might_lock(lock) do { } while (0)\n# define might_lock_read(lock) do { } while (0)\n# define might_lock_nested(lock, subclass) do { } while (0)\n\n# define lockdep_assert_irqs_enabled() do { } while (0)\n# define lockdep_assert_irqs_disabled() do { } while (0)\n# define lockdep_assert_in_irq() do { } while (0)\n\n# define lockdep_assert_preemption_enabled() do { } while (0)\n# define lockdep_assert_preemption_disabled() do { } while (0)\n# define lockdep_assert_in_softirq() do { } while (0)\n#endif\n\n#ifdef CONFIG_PROVE_RAW_LOCK_NESTING\n\n# define lockdep_assert_RT_in_threaded_ctx() do {\t\t\t\\\n\t\tWARN_ONCE(debug_locks && !current->lockdep_recursion &&\t\\\n\t\t\t  lockdep_hardirq_context() &&\t\t\t\\\n\t\t\t  !(current->hardirq_threaded || current->irq_config),\t\\\n\t\t\t  \"Not in threaded context on PREEMPT_RT as expected\\n\");\t\\\n} while (0)\n\n#else\n\n# define lockdep_assert_RT_in_threaded_ctx() do { } while (0)\n\n#endif\n\n#ifdef CONFIG_LOCKDEP\nvoid lockdep_rcu_suspicious(const char *file, const int line, const char *s);\n#else\nstatic inline void\nlockdep_rcu_suspicious(const char *file, const int line, const char *s)\n{\n}\n#endif\n\n#endif /* __LINUX_LOCKDEP_H */\n"}}, "reports": [{"events": [{"location": {"col": 6, "file": 0, "line": 2067}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 1, "line": 120}, "message": "expanded from macro 'WARN_ON'"}, {"location": {"col": 2, "file": 0, "line": 2067}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 2071}, "message": "'alloc_state' is equal to sa_rootdomain"}, {"location": {"col": 2, "file": 0, "line": 2071}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 2077}, "message": "Assuming 'i' is >= 'nr_cpu_ids'"}, {"location": {"col": 3, "file": 2, "line": 272}, "message": "expanded from macro 'for_each_cpu'"}, {"location": {"col": 2, "file": 0, "line": 2077}, "message": "Loop condition is false. Execution continues on line 2103"}, {"location": {"col": 2, "file": 2, "line": 270}, "message": "expanded from macro 'for_each_cpu'"}, {"location": {"col": 2, "file": 0, "line": 2103}, "message": "Assuming 'i' is < 'nr_cpu_ids'"}, {"location": {"col": 3, "file": 2, "line": 272}, "message": "expanded from macro 'for_each_cpu'"}, {"location": {"col": 2, "file": 0, "line": 2103}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 2, "file": 2, "line": 270}, "message": "expanded from macro 'for_each_cpu'"}, {"location": {"col": 14, "file": 0, "line": 2104}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 3, "line": 245}, "message": "expanded from macro 'per_cpu_ptr'"}, {"location": {"col": 37, "file": 3, "line": 217}, "message": "expanded from macro '__verify_pcpu_ptr'"}, {"location": {"col": 3, "file": 0, "line": 2104}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 8, "file": 0, "line": 2106}, "message": "Assuming the condition is false"}, {"location": {"col": 4, "file": 0, "line": 2106}, "message": "Taking false branch"}, {"location": {"col": 9, "file": 0, "line": 2110}, "message": "Calling 'build_sched_groups'"}, {"location": {"col": 37, "file": 0, "line": 1194}, "message": "'last' initialized to a null pointer value"}, {"location": {"col": 2, "file": 0, "line": 1200}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 34, "file": 4, "line": 406}, "message": "expanded from macro 'lockdep_assert_held'"}, {"location": {"col": 2, "file": 0, "line": 1205}, "message": "Assuming 'i' is >= 64"}, {"location": {"col": 7, "file": 2, "line": 300}, "message": "expanded from macro 'for_each_cpu_wrap'"}, {"location": {"col": 2, "file": 0, "line": 1205}, "message": "Loop condition is false. Execution continues on line 1221"}, {"location": {"col": 2, "file": 2, "line": 299}, "message": "expanded from macro 'for_each_cpu_wrap'"}, {"location": {"col": 13, "file": 0, "line": 1221}, "message": "Access to field 'next' results in a dereference of a null pointer (loaded from variable 'last')"}, {"location": {"col": 13, "file": 0, "line": 1221}, "message": "Access to field 'next' results in a dereference of a null pointer (loaded from variable 'last')"}], "macros": [], "notes": [], "path": "/src/kernel/sched/topology.c", "reportHash": "985ee7a7addd48333b40793ed5ed1944", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
