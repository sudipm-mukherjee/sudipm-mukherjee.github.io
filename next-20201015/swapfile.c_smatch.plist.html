<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/mm/swapfile.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  linux/mm/swapfile.c\n *\n *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds\n *  Swap reorganised 29.12.95, Stephen Tweedie\n */\n\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/slab.h>\n#include <linux/kernel_stat.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/shmem_fs.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/writeback.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/security.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/memcontrol.h>\n#include <linux/poll.h>\n#include <linux/oom.h>\n#include <linux/frontswap.h>\n#include <linux/swapfile.h>\n#include <linux/export.h>\n#include <linux/swap_slots.h>\n#include <linux/sort.h>\n\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/swap_cgroup.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic sector_t map_swap_entry(swp_entry_t, struct block_device**);\n\nDEFINE_SPINLOCK(swap_lock);\nstatic unsigned int nr_swapfiles;\natomic_long_t nr_swap_pages;\n/*\n * Some modules use swappable objects and may try to swap them out under\n * memory pressure (via the shrinker). Before doing so, they may wish to\n * check to see if any swap space is available.\n */\nEXPORT_SYMBOL_GPL(nr_swap_pages);\n/* protected with swap_lock. reading in vm_swap_full() doesn't need lock */\nlong total_swap_pages;\nstatic int least_priority = -1;\n\nstatic const char Bad_file[] = \"Bad swap file entry \";\nstatic const char Unused_file[] = \"Unused swap file entry \";\nstatic const char Bad_offset[] = \"Bad swap offset entry \";\nstatic const char Unused_offset[] = \"Unused swap offset entry \";\n\n/*\n * all active swap_info_structs\n * protected with swap_lock, and ordered by priority.\n */\nPLIST_HEAD(swap_active_head);\n\n/*\n * all available (active, not full) swap_info_structs\n * protected with swap_avail_lock, ordered by priority.\n * This is used by get_swap_page() instead of swap_active_head\n * because swap_active_head includes all swap_info_structs,\n * but get_swap_page() doesn't need to look at full ones.\n * This uses its own lock instead of swap_lock because when a\n * swap_info_struct changes between not-full/full, it needs to\n * add/remove itself to/from this list, but the swap_info_struct->lock\n * is held and the locking order requires swap_lock to be taken\n * before any swap_info_struct->lock.\n */\nstatic struct plist_head *swap_avail_heads;\nstatic DEFINE_SPINLOCK(swap_avail_lock);\n\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstatic DEFINE_MUTEX(swapon_mutex);\n\nstatic DECLARE_WAIT_QUEUE_HEAD(proc_poll_wait);\n/* Activity counter to indicate that a swapon or swapoff has occurred */\nstatic atomic_t proc_poll_event = ATOMIC_INIT(0);\n\natomic_t nr_rotate_swap = ATOMIC_INIT(0);\n\nstatic struct swap_info_struct *swap_type_to_swap_info(int type)\n{\n\tif (type >= READ_ONCE(nr_swapfiles))\n\t\treturn NULL;\n\n\tsmp_rmb();\t/* Pairs with smp_wmb in alloc_swap_info. */\n\treturn READ_ONCE(swap_info[type]);\n}\n\nstatic inline unsigned char swap_count(unsigned char ent)\n{\n\treturn ent & ~SWAP_HAS_CACHE;\t/* may include COUNT_CONTINUED flag */\n}\n\n/* Reclaim the swap entry anyway if possible */\n#define TTRS_ANYWAY\t\t0x1\n/*\n * Reclaim the swap entry if there are no more mappings of the\n * corresponding page\n */\n#define TTRS_UNMAPPED\t\t0x2\n/* Reclaim the swap entry if swap is getting full*/\n#define TTRS_FULL\t\t0x4\n\n/* returns 1 if swap entry is freed */\nstatic int __try_to_reclaim_swap(struct swap_info_struct *si,\n\t\t\t\t unsigned long offset, unsigned long flags)\n{\n\tswp_entry_t entry = swp_entry(si->type, offset);\n\tstruct page *page;\n\tint ret = 0;\n\n\tpage = find_get_page(swap_address_space(entry), offset);\n\tif (!page)\n\t\treturn 0;\n\t/*\n\t * When this function is called from scan_swap_map_slots() and it's\n\t * called by vmscan.c at reclaiming pages. So, we hold a lock on a page,\n\t * here. We have to use trylock for avoiding deadlock. This is a special\n\t * case and you should use try_to_free_swap() with explicit lock_page()\n\t * in usual operations.\n\t */\n\tif (trylock_page(page)) {\n\t\tif ((flags & TTRS_ANYWAY) ||\n\t\t    ((flags & TTRS_UNMAPPED) && !page_mapped(page)) ||\n\t\t    ((flags & TTRS_FULL) && mem_cgroup_swap_full(page)))\n\t\t\tret = try_to_free_swap(page);\n\t\tunlock_page(page);\n\t}\n\tput_page(page);\n\treturn ret;\n}\n\nstatic inline struct swap_extent *first_se(struct swap_info_struct *sis)\n{\n\tstruct rb_node *rb = rb_first(&sis->swap_extent_root);\n\treturn rb_entry(rb, struct swap_extent, rb_node);\n}\n\nstatic inline struct swap_extent *next_se(struct swap_extent *se)\n{\n\tstruct rb_node *rb = rb_next(&se->rb_node);\n\treturn rb ? rb_entry(rb, struct swap_extent, rb_node) : NULL;\n}\n\n/*\n * swapon tell device that all the old swap contents can be discarded,\n * to allow the swap device to optimize its wear-levelling.\n */\nstatic int discard_swap(struct swap_info_struct *si)\n{\n\tstruct swap_extent *se;\n\tsector_t start_block;\n\tsector_t nr_blocks;\n\tint err = 0;\n\n\t/* Do not discard the swap header page! */\n\tse = first_se(si);\n\tstart_block = (se->start_block + 1) << (PAGE_SHIFT - 9);\n\tnr_blocks = ((sector_t)se->nr_pages - 1) << (PAGE_SHIFT - 9);\n\tif (nr_blocks) {\n\t\terr = blkdev_issue_discard(si->bdev, start_block,\n\t\t\t\tnr_blocks, GFP_KERNEL, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcond_resched();\n\t}\n\n\tfor (se = next_se(se); se; se = next_se(se)) {\n\t\tstart_block = se->start_block << (PAGE_SHIFT - 9);\n\t\tnr_blocks = (sector_t)se->nr_pages << (PAGE_SHIFT - 9);\n\n\t\terr = blkdev_issue_discard(si->bdev, start_block,\n\t\t\t\tnr_blocks, GFP_KERNEL, 0);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\treturn err;\t\t/* That will often be -EOPNOTSUPP */\n}\n\nstatic struct swap_extent *\noffset_to_swap_extent(struct swap_info_struct *sis, unsigned long offset)\n{\n\tstruct swap_extent *se;\n\tstruct rb_node *rb;\n\n\trb = sis->swap_extent_root.rb_node;\n\twhile (rb) {\n\t\tse = rb_entry(rb, struct swap_extent, rb_node);\n\t\tif (offset < se->start_page)\n\t\t\trb = rb->rb_left;\n\t\telse if (offset >= se->start_page + se->nr_pages)\n\t\t\trb = rb->rb_right;\n\t\telse\n\t\t\treturn se;\n\t}\n\t/* It *must* be present */\n\tBUG();\n}\n\n/*\n * swap allocation tell device that a cluster of swap can now be discarded,\n * to allow the swap device to optimize its wear-levelling.\n */\nstatic void discard_swap_cluster(struct swap_info_struct *si,\n\t\t\t\t pgoff_t start_page, pgoff_t nr_pages)\n{\n\tstruct swap_extent *se = offset_to_swap_extent(si, start_page);\n\n\twhile (nr_pages) {\n\t\tpgoff_t offset = start_page - se->start_page;\n\t\tsector_t start_block = se->start_block + offset;\n\t\tsector_t nr_blocks = se->nr_pages - offset;\n\n\t\tif (nr_blocks > nr_pages)\n\t\t\tnr_blocks = nr_pages;\n\t\tstart_page += nr_blocks;\n\t\tnr_pages -= nr_blocks;\n\n\t\tstart_block <<= PAGE_SHIFT - 9;\n\t\tnr_blocks <<= PAGE_SHIFT - 9;\n\t\tif (blkdev_issue_discard(si->bdev, start_block,\n\t\t\t\t\tnr_blocks, GFP_NOIO, 0))\n\t\t\tbreak;\n\n\t\tse = next_se(se);\n\t}\n}\n\n#ifdef CONFIG_THP_SWAP\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\n#define swap_entry_size(size)\t(size)\n#else\n#define SWAPFILE_CLUSTER\t256\n\n/*\n * Define swap_entry_size() as constant to let compiler to optimize\n * out some code if !CONFIG_THP_SWAP\n */\n#define swap_entry_size(size)\t1\n#endif\n#define LATENCY_LIMIT\t\t256\n\nstatic inline void cluster_set_flag(struct swap_cluster_info *info,\n\tunsigned int flag)\n{\n\tinfo->flags = flag;\n}\n\nstatic inline unsigned int cluster_count(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}\n\nstatic inline void cluster_set_count(struct swap_cluster_info *info,\n\t\t\t\t     unsigned int c)\n{\n\tinfo->data = c;\n}\n\nstatic inline void cluster_set_count_flag(struct swap_cluster_info *info,\n\t\t\t\t\t unsigned int c, unsigned int f)\n{\n\tinfo->flags = f;\n\tinfo->data = c;\n}\n\nstatic inline unsigned int cluster_next(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}\n\nstatic inline void cluster_set_next(struct swap_cluster_info *info,\n\t\t\t\t    unsigned int n)\n{\n\tinfo->data = n;\n}\n\nstatic inline void cluster_set_next_flag(struct swap_cluster_info *info,\n\t\t\t\t\t unsigned int n, unsigned int f)\n{\n\tinfo->flags = f;\n\tinfo->data = n;\n}\n\nstatic inline bool cluster_is_free(struct swap_cluster_info *info)\n{\n\treturn info->flags & CLUSTER_FLAG_FREE;\n}\n\nstatic inline bool cluster_is_null(struct swap_cluster_info *info)\n{\n\treturn info->flags & CLUSTER_FLAG_NEXT_NULL;\n}\n\nstatic inline void cluster_set_null(struct swap_cluster_info *info)\n{\n\tinfo->flags = CLUSTER_FLAG_NEXT_NULL;\n\tinfo->data = 0;\n}\n\nstatic inline bool cluster_is_huge(struct swap_cluster_info *info)\n{\n\tif (IS_ENABLED(CONFIG_THP_SWAP) && info)\n\t\treturn info->flags & CLUSTER_FLAG_HUGE;\n\treturn false;\n}\n\nstatic inline void cluster_clear_huge(struct swap_cluster_info *info)\n{\n\tif (IS_ENABLED(CONFIG_THP_SWAP) && info)\n\t\tinfo->flags &= ~CLUSTER_FLAG_HUGE;\n}\n\nstatic inline struct swap_cluster_info *lock_cluster(struct swap_info_struct *si,\n\t\t\t\t\t\t     unsigned long offset)\n{\n\tstruct swap_cluster_info *ci;\n\n\tci = si->cluster_info;\n\tif (ci) {\n\t\tci += offset / SWAPFILE_CLUSTER;\n\t\tspin_lock(&ci->lock);\n\t}\n\treturn ci;\n}\n\nstatic inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}\n\n/*\n * Determine the locking method in use for this device.  Return\n * swap_cluster_info if SSD-style cluster-based locking is in place.\n */\nstatic inline struct swap_cluster_info *lock_cluster_or_swap_info(\n\t\tstruct swap_info_struct *si, unsigned long offset)\n{\n\tstruct swap_cluster_info *ci;\n\n\t/* Try to use fine-grained SSD-style locking if available: */\n\tci = lock_cluster(si, offset);\n\t/* Otherwise, fall back to traditional, coarse locking: */\n\tif (!ci)\n\t\tspin_lock(&si->lock);\n\n\treturn ci;\n}\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}\n\nstatic inline unsigned int cluster_list_first(struct swap_cluster_list *list)\n{\n\treturn cluster_next(&list->head);\n}\n\nstatic void cluster_list_init(struct swap_cluster_list *list)\n{\n\tcluster_set_null(&list->head);\n\tcluster_set_null(&list->tail);\n}\n\nstatic void cluster_list_add_tail(struct swap_cluster_list *list,\n\t\t\t\t  struct swap_cluster_info *ci,\n\t\t\t\t  unsigned int idx)\n{\n\tif (cluster_list_empty(list)) {\n\t\tcluster_set_next_flag(&list->head, idx, 0);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t} else {\n\t\tstruct swap_cluster_info *ci_tail;\n\t\tunsigned int tail = cluster_next(&list->tail);\n\n\t\t/*\n\t\t * Nested cluster lock, but both cluster locks are\n\t\t * only acquired when we held swap_info_struct->lock\n\t\t */\n\t\tci_tail = ci + tail;\n\t\tspin_lock_nested(&ci_tail->lock, SINGLE_DEPTH_NESTING);\n\t\tcluster_set_next(ci_tail, idx);\n\t\tspin_unlock(&ci_tail->lock);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t}\n}\n\nstatic unsigned int cluster_list_del_first(struct swap_cluster_list *list,\n\t\t\t\t\t   struct swap_cluster_info *ci)\n{\n\tunsigned int idx;\n\n\tidx = cluster_next(&list->head);\n\tif (cluster_next(&list->tail) == idx) {\n\t\tcluster_set_null(&list->head);\n\t\tcluster_set_null(&list->tail);\n\t} else\n\t\tcluster_set_next_flag(&list->head,\n\t\t\t\t      cluster_next(&ci[idx]), 0);\n\n\treturn idx;\n}\n\n/* Add a cluster to discard list and schedule it to do discard */\nstatic void swap_cluster_schedule_discard(struct swap_info_struct *si,\n\t\tunsigned int idx)\n{\n\t/*\n\t * If scan_swap_map() can't find a free cluster, it will check\n\t * si->swap_map directly. To make sure the discarding cluster isn't\n\t * taken by scan_swap_map(), mark the swap entries bad (occupied). It\n\t * will be cleared after discard\n\t */\n\tmemset(si->swap_map + idx * SWAPFILE_CLUSTER,\n\t\t\tSWAP_MAP_BAD, SWAPFILE_CLUSTER);\n\n\tcluster_list_add_tail(&si->discard_clusters, si->cluster_info, idx);\n\n\tschedule_work(&si->discard_work);\n}\n\nstatic void __free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tstruct swap_cluster_info *ci = si->cluster_info;\n\n\tcluster_set_flag(ci + idx, CLUSTER_FLAG_FREE);\n\tcluster_list_add_tail(&si->free_clusters, ci, idx);\n}\n\n/*\n * Doing discard actually. After a cluster discard is finished, the cluster\n * will be added to free cluster list. caller should hold si->lock.\n*/\nstatic void swap_do_scheduled_discard(struct swap_info_struct *si)\n{\n\tstruct swap_cluster_info *info, *ci;\n\tunsigned int idx;\n\n\tinfo = si->cluster_info;\n\n\twhile (!cluster_list_empty(&si->discard_clusters)) {\n\t\tidx = cluster_list_del_first(&si->discard_clusters, info);\n\t\tspin_unlock(&si->lock);\n\n\t\tdiscard_swap_cluster(si, idx * SWAPFILE_CLUSTER,\n\t\t\t\tSWAPFILE_CLUSTER);\n\n\t\tspin_lock(&si->lock);\n\t\tci = lock_cluster(si, idx * SWAPFILE_CLUSTER);\n\t\t__free_cluster(si, idx);\n\t\tmemset(si->swap_map + idx * SWAPFILE_CLUSTER,\n\t\t\t\t0, SWAPFILE_CLUSTER);\n\t\tunlock_cluster(ci);\n\t}\n}\n\nstatic void swap_discard_work(struct work_struct *work)\n{\n\tstruct swap_info_struct *si;\n\n\tsi = container_of(work, struct swap_info_struct, discard_work);\n\n\tspin_lock(&si->lock);\n\tswap_do_scheduled_discard(si);\n\tspin_unlock(&si->lock);\n}\n\nstatic void alloc_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tstruct swap_cluster_info *ci = si->cluster_info;\n\n\tVM_BUG_ON(cluster_list_first(&si->free_clusters) != idx);\n\tcluster_list_del_first(&si->free_clusters, ci);\n\tcluster_set_count_flag(ci + idx, 0, 0);\n}\n\nstatic void free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tstruct swap_cluster_info *ci = si->cluster_info + idx;\n\n\tVM_BUG_ON(cluster_count(ci) != 0);\n\t/*\n\t * If the swap is discardable, prepare discard the cluster\n\t * instead of free it immediately. The cluster will be freed\n\t * after discard.\n\t */\n\tif ((si->flags & (SWP_WRITEOK | SWP_PAGE_DISCARD)) ==\n\t    (SWP_WRITEOK | SWP_PAGE_DISCARD)) {\n\t\tswap_cluster_schedule_discard(si, idx);\n\t\treturn;\n\t}\n\n\t__free_cluster(si, idx);\n}\n\n/*\n * The cluster corresponding to page_nr will be used. The cluster will be\n * removed from free cluster list and its usage counter will be increased.\n */\nstatic void inc_cluster_info_page(struct swap_info_struct *p,\n\tstruct swap_cluster_info *cluster_info, unsigned long page_nr)\n{\n\tunsigned long idx = page_nr / SWAPFILE_CLUSTER;\n\n\tif (!cluster_info)\n\t\treturn;\n\tif (cluster_is_free(&cluster_info[idx]))\n\t\talloc_cluster(p, idx);\n\n\tVM_BUG_ON(cluster_count(&cluster_info[idx]) >= SWAPFILE_CLUSTER);\n\tcluster_set_count(&cluster_info[idx],\n\t\tcluster_count(&cluster_info[idx]) + 1);\n}\n\n/*\n * The cluster corresponding to page_nr decreases one usage. If the usage\n * counter becomes 0, which means no page in the cluster is in using, we can\n * optionally discard the cluster and add it to free cluster list.\n */\nstatic void dec_cluster_info_page(struct swap_info_struct *p,\n\tstruct swap_cluster_info *cluster_info, unsigned long page_nr)\n{\n\tunsigned long idx = page_nr / SWAPFILE_CLUSTER;\n\n\tif (!cluster_info)\n\t\treturn;\n\n\tVM_BUG_ON(cluster_count(&cluster_info[idx]) == 0);\n\tcluster_set_count(&cluster_info[idx],\n\t\tcluster_count(&cluster_info[idx]) - 1);\n\n\tif (cluster_count(&cluster_info[idx]) == 0)\n\t\tfree_cluster(p, idx);\n}\n\n/*\n * It's possible scan_swap_map() uses a free cluster in the middle of free\n * cluster list. Avoiding such abuse to avoid list corruption.\n */\nstatic bool\nscan_swap_map_ssd_cluster_conflict(struct swap_info_struct *si,\n\tunsigned long offset)\n{\n\tstruct percpu_cluster *percpu_cluster;\n\tbool conflict;\n\n\toffset /= SWAPFILE_CLUSTER;\n\tconflict = !cluster_list_empty(&si->free_clusters) &&\n\t\toffset != cluster_list_first(&si->free_clusters) &&\n\t\tcluster_is_free(&si->cluster_info[offset]);\n\n\tif (!conflict)\n\t\treturn false;\n\n\tpercpu_cluster = this_cpu_ptr(si->percpu_cluster);\n\tcluster_set_null(&percpu_cluster->index);\n\treturn true;\n}\n\n/*\n * Try to get a swap entry from current cpu's swap entry pool (a cluster). This\n * might involve allocating a new cluster for current CPU too.\n */\nstatic bool scan_swap_map_try_ssd_cluster(struct swap_info_struct *si,\n\tunsigned long *offset, unsigned long *scan_base)\n{\n\tstruct percpu_cluster *cluster;\n\tstruct swap_cluster_info *ci;\n\tunsigned long tmp, max;\n\nnew_cluster:\n\tcluster = this_cpu_ptr(si->percpu_cluster);\n\tif (cluster_is_null(&cluster->index)) {\n\t\tif (!cluster_list_empty(&si->free_clusters)) {\n\t\t\tcluster->index = si->free_clusters.head;\n\t\t\tcluster->next = cluster_next(&cluster->index) *\n\t\t\t\t\tSWAPFILE_CLUSTER;\n\t\t} else if (!cluster_list_empty(&si->discard_clusters)) {\n\t\t\t/*\n\t\t\t * we don't have free cluster but have some clusters in\n\t\t\t * discarding, do discard now and reclaim them, then\n\t\t\t * reread cluster_next_cpu since we dropped si->lock\n\t\t\t */\n\t\t\tswap_do_scheduled_discard(si);\n\t\t\t*scan_base = this_cpu_read(*si->cluster_next_cpu);\n\t\t\t*offset = *scan_base;\n\t\t\tgoto new_cluster;\n\t\t} else\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * Other CPUs can use our cluster if they can't find a free cluster,\n\t * check if there is still free entry in the cluster\n\t */\n\ttmp = cluster->next;\n\tmax = min_t(unsigned long, si->max,\n\t\t    (cluster_next(&cluster->index) + 1) * SWAPFILE_CLUSTER);\n\tif (tmp < max) {\n\t\tci = lock_cluster(si, tmp);\n\t\twhile (tmp < max) {\n\t\t\tif (!si->swap_map[tmp])\n\t\t\t\tbreak;\n\t\t\ttmp++;\n\t\t}\n\t\tunlock_cluster(ci);\n\t}\n\tif (tmp >= max) {\n\t\tcluster_set_null(&cluster->index);\n\t\tgoto new_cluster;\n\t}\n\tcluster->next = tmp + 1;\n\t*offset = tmp;\n\t*scan_base = tmp;\n\treturn true;\n}\n\nstatic void __del_from_avail_list(struct swap_info_struct *p)\n{\n\tint nid;\n\n\tfor_each_node(nid)\n\t\tplist_del(&p->avail_lists[nid], &swap_avail_heads[nid]);\n}\n\nstatic void del_from_avail_list(struct swap_info_struct *p)\n{\n\tspin_lock(&swap_avail_lock);\n\t__del_from_avail_list(p);\n\tspin_unlock(&swap_avail_lock);\n}\n\nstatic void swap_range_alloc(struct swap_info_struct *si, unsigned long offset,\n\t\t\t     unsigned int nr_entries)\n{\n\tunsigned int end = offset + nr_entries - 1;\n\n\tif (offset == si->lowest_bit)\n\t\tsi->lowest_bit += nr_entries;\n\tif (end == si->highest_bit)\n\t\tWRITE_ONCE(si->highest_bit, si->highest_bit - nr_entries);\n\tsi->inuse_pages += nr_entries;\n\tif (si->inuse_pages == si->pages) {\n\t\tsi->lowest_bit = si->max;\n\t\tsi->highest_bit = 0;\n\t\tdel_from_avail_list(si);\n\t}\n}\n\nstatic void add_to_avail_list(struct swap_info_struct *p)\n{\n\tint nid;\n\n\tspin_lock(&swap_avail_lock);\n\tfor_each_node(nid) {\n\t\tWARN_ON(!plist_node_empty(&p->avail_lists[nid]));\n\t\tplist_add(&p->avail_lists[nid], &swap_avail_heads[nid]);\n\t}\n\tspin_unlock(&swap_avail_lock);\n}\n\nstatic void swap_range_free(struct swap_info_struct *si, unsigned long offset,\n\t\t\t    unsigned int nr_entries)\n{\n\tunsigned long begin = offset;\n\tunsigned long end = offset + nr_entries - 1;\n\tvoid (*swap_slot_free_notify)(struct block_device *, unsigned long);\n\n\tif (offset < si->lowest_bit)\n\t\tsi->lowest_bit = offset;\n\tif (end > si->highest_bit) {\n\t\tbool was_full = !si->highest_bit;\n\n\t\tWRITE_ONCE(si->highest_bit, end);\n\t\tif (was_full && (si->flags & SWP_WRITEOK))\n\t\t\tadd_to_avail_list(si);\n\t}\n\tatomic_long_add(nr_entries, &nr_swap_pages);\n\tsi->inuse_pages -= nr_entries;\n\tif (si->flags & SWP_BLKDEV)\n\t\tswap_slot_free_notify =\n\t\t\tsi->bdev->bd_disk->fops->swap_slot_free_notify;\n\telse\n\t\tswap_slot_free_notify = NULL;\n\twhile (offset <= end) {\n\t\tarch_swap_invalidate_page(si->type, offset);\n\t\tfrontswap_invalidate_page(si->type, offset);\n\t\tif (swap_slot_free_notify)\n\t\t\tswap_slot_free_notify(si->bdev, offset);\n\t\toffset++;\n\t}\n\tclear_shadow_from_swap_cache(si->type, begin, end);\n}\n\nstatic void set_cluster_next(struct swap_info_struct *si, unsigned long next)\n{\n\tunsigned long prev;\n\n\tif (!(si->flags & SWP_SOLIDSTATE)) {\n\t\tsi->cluster_next = next;\n\t\treturn;\n\t}\n\n\tprev = this_cpu_read(*si->cluster_next_cpu);\n\t/*\n\t * Cross the swap address space size aligned trunk, choose\n\t * another trunk randomly to avoid lock contention on swap\n\t * address space if possible.\n\t */\n\tif ((prev >> SWAP_ADDRESS_SPACE_SHIFT) !=\n\t    (next >> SWAP_ADDRESS_SPACE_SHIFT)) {\n\t\t/* No free swap slots available */\n\t\tif (si->highest_bit <= si->lowest_bit)\n\t\t\treturn;\n\t\tnext = si->lowest_bit +\n\t\t\tprandom_u32_max(si->highest_bit - si->lowest_bit + 1);\n\t\tnext = ALIGN_DOWN(next, SWAP_ADDRESS_SPACE_PAGES);\n\t\tnext = max_t(unsigned int, next, si->lowest_bit);\n\t}\n\tthis_cpu_write(*si->cluster_next_cpu, next);\n}\n\nstatic int scan_swap_map_slots(struct swap_info_struct *si,\n\t\t\t       unsigned char usage, int nr,\n\t\t\t       swp_entry_t slots[])\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset;\n\tunsigned long scan_base;\n\tunsigned long last_in_cluster = 0;\n\tint latency_ration = LATENCY_LIMIT;\n\tint n_ret = 0;\n\tbool scanned_many = false;\n\n\t/*\n\t * We try to cluster swap pages by allocating them sequentially\n\t * in swap.  Once we've allocated SWAPFILE_CLUSTER pages this\n\t * way, however, we resort to first-free allocation, starting\n\t * a new cluster.  This prevents us from scattering swap pages\n\t * all over the entire swap partition, so that we reduce\n\t * overall disk seek times between swap pages.  -- sct\n\t * But we do now try to find an empty cluster.  -Andrea\n\t * And we let swap pages go all over an SSD partition.  Hugh\n\t */\n\n\tsi->flags += SWP_SCANNING;\n\t/*\n\t * Use percpu scan base for SSD to reduce lock contention on\n\t * cluster and swap cache.  For HDD, sequential access is more\n\t * important.\n\t */\n\tif (si->flags & SWP_SOLIDSTATE)\n\t\tscan_base = this_cpu_read(*si->cluster_next_cpu);\n\telse\n\t\tscan_base = si->cluster_next;\n\toffset = scan_base;\n\n\t/* SSD algorithm */\n\tif (si->cluster_info) {\n\t\tif (!scan_swap_map_try_ssd_cluster(si, &offset, &scan_base))\n\t\t\tgoto scan;\n\t} else if (unlikely(!si->cluster_nr--)) {\n\t\tif (si->pages - si->inuse_pages < SWAPFILE_CLUSTER) {\n\t\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t\t\tgoto checks;\n\t\t}\n\n\t\tspin_unlock(&si->lock);\n\n\t\t/*\n\t\t * If seek is expensive, start searching for new cluster from\n\t\t * start of partition, to minimize the span of allocated swap.\n\t\t * If seek is cheap, that is the SWP_SOLIDSTATE si->cluster_info\n\t\t * case, just handled by scan_swap_map_try_ssd_cluster() above.\n\t\t */\n\t\tscan_base = offset = si->lowest_bit;\n\t\tlast_in_cluster = offset + SWAPFILE_CLUSTER - 1;\n\n\t\t/* Locate the first empty (unaligned) cluster */\n\t\tfor (; last_in_cluster <= si->highest_bit; offset++) {\n\t\t\tif (si->swap_map[offset])\n\t\t\t\tlast_in_cluster = offset + SWAPFILE_CLUSTER;\n\t\t\telse if (offset == last_in_cluster) {\n\t\t\t\tspin_lock(&si->lock);\n\t\t\t\toffset -= SWAPFILE_CLUSTER - 1;\n\t\t\t\tsi->cluster_next = offset;\n\t\t\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t\t\t\tgoto checks;\n\t\t\t}\n\t\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\t\tcond_resched();\n\t\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t\t}\n\t\t}\n\n\t\toffset = scan_base;\n\t\tspin_lock(&si->lock);\n\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t}\n\nchecks:\n\tif (si->cluster_info) {\n\t\twhile (scan_swap_map_ssd_cluster_conflict(si, offset)) {\n\t\t/* take a break if we already got some slots */\n\t\t\tif (n_ret)\n\t\t\t\tgoto done;\n\t\t\tif (!scan_swap_map_try_ssd_cluster(si, &offset,\n\t\t\t\t\t\t\t&scan_base))\n\t\t\t\tgoto scan;\n\t\t}\n\t}\n\tif (!(si->flags & SWP_WRITEOK))\n\t\tgoto no_page;\n\tif (!si->highest_bit)\n\t\tgoto no_page;\n\tif (offset > si->highest_bit)\n\t\tscan_base = offset = si->lowest_bit;\n\n\tci = lock_cluster(si, offset);\n\t/* reuse swap entry of cache-only swap if not busy. */\n\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\tint swap_was_freed;\n\t\tunlock_cluster(ci);\n\t\tspin_unlock(&si->lock);\n\t\tswap_was_freed = __try_to_reclaim_swap(si, offset, TTRS_ANYWAY);\n\t\tspin_lock(&si->lock);\n\t\t/* entry was freed successfully, try to use this again */\n\t\tif (swap_was_freed)\n\t\t\tgoto checks;\n\t\tgoto scan; /* check next one */\n\t}\n\n\tif (si->swap_map[offset]) {\n\t\tunlock_cluster(ci);\n\t\tif (!n_ret)\n\t\t\tgoto scan;\n\t\telse\n\t\t\tgoto done;\n\t}\n\tWRITE_ONCE(si->swap_map[offset], usage);\n\tinc_cluster_info_page(si, si->cluster_info, offset);\n\tunlock_cluster(ci);\n\n\tswap_range_alloc(si, offset, 1);\n\tslots[n_ret++] = swp_entry(si->type, offset);\n\n\t/* got enough slots or reach max slots? */\n\tif ((n_ret == nr) || (offset >= si->highest_bit))\n\t\tgoto done;\n\n\t/* search for next available slot */\n\n\t/* time to take a break? */\n\tif (unlikely(--latency_ration < 0)) {\n\t\tif (n_ret)\n\t\t\tgoto done;\n\t\tspin_unlock(&si->lock);\n\t\tcond_resched();\n\t\tspin_lock(&si->lock);\n\t\tlatency_ration = LATENCY_LIMIT;\n\t}\n\n\t/* try to get more slots in cluster */\n\tif (si->cluster_info) {\n\t\tif (scan_swap_map_try_ssd_cluster(si, &offset, &scan_base))\n\t\t\tgoto checks;\n\t} else if (si->cluster_nr && !si->swap_map[++offset]) {\n\t\t/* non-ssd case, still more slots in cluster? */\n\t\t--si->cluster_nr;\n\t\tgoto checks;\n\t}\n\n\t/*\n\t * Even if there's no free clusters available (fragmented),\n\t * try to scan a little more quickly with lock held unless we\n\t * have scanned too many slots already.\n\t */\n\tif (!scanned_many) {\n\t\tunsigned long scan_limit;\n\n\t\tif (offset < scan_base)\n\t\t\tscan_limit = scan_base;\n\t\telse\n\t\t\tscan_limit = si->highest_bit;\n\t\tfor (; offset <= scan_limit && --latency_ration > 0;\n\t\t     offset++) {\n\t\t\tif (!si->swap_map[offset])\n\t\t\t\tgoto checks;\n\t\t}\n\t}\n\ndone:\n\tset_cluster_next(si, offset + 1);\n\tsi->flags -= SWP_SCANNING;\n\treturn n_ret;\n\nscan:\n\tspin_unlock(&si->lock);\n\twhile (++offset <= READ_ONCE(si->highest_bit)) {\n\t\tif (data_race(!si->swap_map[offset])) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (vm_swap_full() &&\n\t\t    READ_ONCE(si->swap_map[offset]) == SWAP_HAS_CACHE) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\tcond_resched();\n\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t\tscanned_many = true;\n\t\t}\n\t}\n\toffset = si->lowest_bit;\n\twhile (offset < scan_base) {\n\t\tif (data_race(!si->swap_map[offset])) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (vm_swap_full() &&\n\t\t    READ_ONCE(si->swap_map[offset]) == SWAP_HAS_CACHE) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\tcond_resched();\n\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t\tscanned_many = true;\n\t\t}\n\t\toffset++;\n\t}\n\tspin_lock(&si->lock);\n\nno_page:\n\tsi->flags -= SWP_SCANNING;\n\treturn n_ret;\n}\n\nstatic int swap_alloc_cluster(struct swap_info_struct *si, swp_entry_t *slot)\n{\n\tunsigned long idx;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset, i;\n\tunsigned char *map;\n\n\t/*\n\t * Should not even be attempting cluster allocations when huge\n\t * page swap is disabled.  Warn and fail the allocation.\n\t */\n\tif (!IS_ENABLED(CONFIG_THP_SWAP)) {\n\t\tVM_WARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (cluster_list_empty(&si->free_clusters))\n\t\treturn 0;\n\n\tidx = cluster_list_first(&si->free_clusters);\n\toffset = idx * SWAPFILE_CLUSTER;\n\tci = lock_cluster(si, offset);\n\talloc_cluster(si, idx);\n\tcluster_set_count_flag(ci, SWAPFILE_CLUSTER, CLUSTER_FLAG_HUGE);\n\n\tmap = si->swap_map + offset;\n\tfor (i = 0; i < SWAPFILE_CLUSTER; i++)\n\t\tmap[i] = SWAP_HAS_CACHE;\n\tunlock_cluster(ci);\n\tswap_range_alloc(si, offset, SWAPFILE_CLUSTER);\n\t*slot = swp_entry(si->type, offset);\n\n\treturn 1;\n}\n\nstatic void swap_free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tunsigned long offset = idx * SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\n\tci = lock_cluster(si, offset);\n\tmemset(si->swap_map + offset, 0, SWAPFILE_CLUSTER);\n\tcluster_set_count_flag(ci, 0, 0);\n\tfree_cluster(si, idx);\n\tunlock_cluster(ci);\n\tswap_range_free(si, offset, SWAPFILE_CLUSTER);\n}\n\nstatic unsigned long scan_swap_map(struct swap_info_struct *si,\n\t\t\t\t   unsigned char usage)\n{\n\tswp_entry_t entry;\n\tint n_ret;\n\n\tn_ret = scan_swap_map_slots(si, usage, 1, &entry);\n\n\tif (n_ret)\n\t\treturn swp_offset(entry);\n\telse\n\t\treturn 0;\n\n}\n\nint get_swap_pages(int n_goal, swp_entry_t swp_entries[], int entry_size)\n{\n\tunsigned long size = swap_entry_size(entry_size);\n\tstruct swap_info_struct *si, *next;\n\tlong avail_pgs;\n\tint n_ret = 0;\n\tint node;\n\n\t/* Only single cluster request supported */\n\tWARN_ON_ONCE(n_goal > 1 && size == SWAPFILE_CLUSTER);\n\n\tavail_pgs = atomic_long_read(&nr_swap_pages) / size;\n\tif (avail_pgs <= 0)\n\t\tgoto noswap;\n\n\tn_goal = min3((long)n_goal, (long)SWAP_BATCH, avail_pgs);\n\n\tatomic_long_sub(n_goal * size, &nr_swap_pages);\n\n\tspin_lock(&swap_avail_lock);\n\nstart_over:\n\tnode = numa_node_id();\n\tplist_for_each_entry_safe(si, next, &swap_avail_heads[node], avail_lists[node]) {\n\t\t/* requeue si to after same-priority siblings */\n\t\tplist_requeue(&si->avail_lists[node], &swap_avail_heads[node]);\n\t\tspin_unlock(&swap_avail_lock);\n\t\tspin_lock(&si->lock);\n\t\tif (!si->highest_bit || !(si->flags & SWP_WRITEOK)) {\n\t\t\tspin_lock(&swap_avail_lock);\n\t\t\tif (plist_node_empty(&si->avail_lists[node])) {\n\t\t\t\tspin_unlock(&si->lock);\n\t\t\t\tgoto nextsi;\n\t\t\t}\n\t\t\tWARN(!si->highest_bit,\n\t\t\t     \"swap_info %d in list but !highest_bit\\n\",\n\t\t\t     si->type);\n\t\t\tWARN(!(si->flags & SWP_WRITEOK),\n\t\t\t     \"swap_info %d in list but !SWP_WRITEOK\\n\",\n\t\t\t     si->type);\n\t\t\t__del_from_avail_list(si);\n\t\t\tspin_unlock(&si->lock);\n\t\t\tgoto nextsi;\n\t\t}\n\t\tif (size == SWAPFILE_CLUSTER) {\n\t\t\tif (si->flags & SWP_BLKDEV)\n\t\t\t\tn_ret = swap_alloc_cluster(si, swp_entries);\n\t\t} else\n\t\t\tn_ret = scan_swap_map_slots(si, SWAP_HAS_CACHE,\n\t\t\t\t\t\t    n_goal, swp_entries);\n\t\tspin_unlock(&si->lock);\n\t\tif (n_ret || size == SWAPFILE_CLUSTER)\n\t\t\tgoto check_out;\n\t\tpr_debug(\"scan_swap_map of si %d failed to find offset\\n\",\n\t\t\tsi->type);\n\n\t\tspin_lock(&swap_avail_lock);\nnextsi:\n\t\t/*\n\t\t * if we got here, it's likely that si was almost full before,\n\t\t * and since scan_swap_map() can drop the si->lock, multiple\n\t\t * callers probably all tried to get a page from the same si\n\t\t * and it filled up before we could get one; or, the si filled\n\t\t * up between us dropping swap_avail_lock and taking si->lock.\n\t\t * Since we dropped the swap_avail_lock, the swap_avail_head\n\t\t * list may have been modified; so if next is still in the\n\t\t * swap_avail_head list then try it, otherwise start over\n\t\t * if we have not gotten any slots.\n\t\t */\n\t\tif (plist_node_empty(&next->avail_lists[node]))\n\t\t\tgoto start_over;\n\t}\n\n\tspin_unlock(&swap_avail_lock);\n\ncheck_out:\n\tif (n_ret < n_goal)\n\t\tatomic_long_add((long)(n_goal - n_ret) * size,\n\t\t\t\t&nr_swap_pages);\nnoswap:\n\treturn n_ret;\n}\n\n/* The only caller of this function is now suspend routine */\nswp_entry_t get_swap_page_of_type(int type)\n{\n\tstruct swap_info_struct *si = swap_type_to_swap_info(type);\n\tpgoff_t offset;\n\n\tif (!si)\n\t\tgoto fail;\n\n\tspin_lock(&si->lock);\n\tif (si->flags & SWP_WRITEOK) {\n\t\tatomic_long_dec(&nr_swap_pages);\n\t\t/* This is called for allocating swap entry, not cache */\n\t\toffset = scan_swap_map(si, 1);\n\t\tif (offset) {\n\t\t\tspin_unlock(&si->lock);\n\t\t\treturn swp_entry(type, offset);\n\t\t}\n\t\tatomic_long_inc(&nr_swap_pages);\n\t}\n\tspin_unlock(&si->lock);\nfail:\n\treturn (swp_entry_t) {0};\n}\n\nstatic struct swap_info_struct *__swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\tunsigned long offset;\n\n\tif (!entry.val)\n\t\tgoto out;\n\tp = swp_swap_info(entry);\n\tif (!p)\n\t\tgoto bad_nofile;\n\tif (data_race(!(p->flags & SWP_USED)))\n\t\tgoto bad_device;\n\toffset = swp_offset(entry);\n\tif (offset >= p->max)\n\t\tgoto bad_offset;\n\treturn p;\n\nbad_offset:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Bad_offset, entry.val);\n\tgoto out;\nbad_device:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_file, entry.val);\n\tgoto out;\nbad_nofile:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Bad_file, entry.val);\nout:\n\treturn NULL;\n}\n\nstatic struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (data_race(!p->swap_map[swp_offset(entry)]))\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\nout:\n\treturn NULL;\n}\n\nstatic struct swap_info_struct *swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\tif (p)\n\t\tspin_lock(&p->lock);\n\treturn p;\n}\n\nstatic struct swap_info_struct *swap_info_get_cont(swp_entry_t entry,\n\t\t\t\t\tstruct swap_info_struct *q)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\n\tif (p != q) {\n\t\tif (q != NULL)\n\t\t\tspin_unlock(&q->lock);\n\t\tif (p != NULL)\n\t\t\tspin_lock(&p->lock);\n\t}\n\treturn p;\n}\n\nstatic unsigned char __swap_entry_free_locked(struct swap_info_struct *p,\n\t\t\t\t\t      unsigned long offset,\n\t\t\t\t\t      unsigned char usage)\n{\n\tunsigned char count;\n\tunsigned char has_cache;\n\n\tcount = p->swap_map[offset];\n\n\thas_cache = count & SWAP_HAS_CACHE;\n\tcount &= ~SWAP_HAS_CACHE;\n\n\tif (usage == SWAP_HAS_CACHE) {\n\t\tVM_BUG_ON(!has_cache);\n\t\thas_cache = 0;\n\t} else if (count == SWAP_MAP_SHMEM) {\n\t\t/*\n\t\t * Or we could insist on shmem.c using a special\n\t\t * swap_shmem_free() and free_shmem_swap_and_cache()...\n\t\t */\n\t\tcount = 0;\n\t} else if ((count & ~COUNT_CONTINUED) <= SWAP_MAP_MAX) {\n\t\tif (count == COUNT_CONTINUED) {\n\t\t\tif (swap_count_continued(p, offset, count))\n\t\t\t\tcount = SWAP_MAP_MAX | COUNT_CONTINUED;\n\t\t\telse\n\t\t\t\tcount = SWAP_MAP_MAX;\n\t\t} else\n\t\t\tcount--;\n\t}\n\n\tusage = count | has_cache;\n\tif (usage)\n\t\tWRITE_ONCE(p->swap_map[offset], usage);\n\telse\n\t\tWRITE_ONCE(p->swap_map[offset], SWAP_HAS_CACHE);\n\n\treturn usage;\n}\n\n/*\n * Check whether swap entry is valid in the swap device.  If so,\n * return pointer to swap_info_struct, and keep the swap entry valid\n * via preventing the swap device from being swapoff, until\n * put_swap_device() is called.  Otherwise return NULL.\n *\n * The entirety of the RCU read critical section must come before the\n * return from or after the call to synchronize_rcu() in\n * enable_swap_info() or swapoff().  So if \"si->flags & SWP_VALID\" is\n * true, the si->map, si->cluster_info, etc. must be valid in the\n * critical section.\n *\n * Notice that swapoff or swapoff+swapon can still happen before the\n * rcu_read_lock() in get_swap_device() or after the rcu_read_unlock()\n * in put_swap_device() if there isn't any other way to prevent\n * swapoff, such as page lock, page table lock, etc.  The caller must\n * be prepared for that.  For example, the following situation is\n * possible.\n *\n *   CPU1\t\t\t\tCPU2\n *   do_swap_page()\n *     ...\t\t\t\tswapoff+swapon\n *     __read_swap_cache_async()\n *       swapcache_prepare()\n *         __swap_duplicate()\n *           // check swap_map\n *     // verify PTE not changed\n *\n * In __swap_duplicate(), the swap_map need to be checked before\n * changing partly because the specified swap entry may be for another\n * swap device which has been swapoff.  And in do_swap_page(), after\n * the page is read from the swap device, the PTE is verified not\n * changed with the page table locked to check whether the swap device\n * has been swapoff or swapoff+swapon.\n */\nstruct swap_info_struct *get_swap_device(swp_entry_t entry)\n{\n\tstruct swap_info_struct *si;\n\tunsigned long offset;\n\n\tif (!entry.val)\n\t\tgoto out;\n\tsi = swp_swap_info(entry);\n\tif (!si)\n\t\tgoto bad_nofile;\n\n\trcu_read_lock();\n\tif (data_race(!(si->flags & SWP_VALID)))\n\t\tgoto unlock_out;\n\toffset = swp_offset(entry);\n\tif (offset >= si->max)\n\t\tgoto unlock_out;\n\n\treturn si;\nbad_nofile:\n\tpr_err(\"%s: %s%08lx\\n\", __func__, Bad_file, entry.val);\nout:\n\treturn NULL;\nunlock_out:\n\trcu_read_unlock();\n\treturn NULL;\n}\n\nstatic unsigned char __swap_entry_free(struct swap_info_struct *p,\n\t\t\t\t       swp_entry_t entry)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset = swp_offset(entry);\n\tunsigned char usage;\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\tusage = __swap_entry_free_locked(p, offset, 1);\n\tunlock_cluster_or_swap_info(p, ci);\n\tif (!usage)\n\t\tfree_swap_slot(entry);\n\n\treturn usage;\n}\n\nstatic void swap_entry_free(struct swap_info_struct *p, swp_entry_t entry)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset = swp_offset(entry);\n\tunsigned char count;\n\n\tci = lock_cluster(p, offset);\n\tcount = p->swap_map[offset];\n\tVM_BUG_ON(count != SWAP_HAS_CACHE);\n\tp->swap_map[offset] = 0;\n\tdec_cluster_info_page(p, p->cluster_info, offset);\n\tunlock_cluster(ci);\n\n\tmem_cgroup_uncharge_swap(entry, 1);\n\tswap_range_free(p, offset, 1);\n}\n\n/*\n * Caller has made sure that the swap device corresponding to entry\n * is still around or has not been recycled.\n */\nvoid swap_free(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\tif (p)\n\t\t__swap_entry_free(p, entry);\n}\n\n/*\n * Called after dropping swapcache to decrease refcnt to swap entries.\n */\nvoid put_swap_page(struct page *page, swp_entry_t entry)\n{\n\tunsigned long offset = swp_offset(entry);\n\tunsigned long idx = offset / SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\tstruct swap_info_struct *si;\n\tunsigned char *map;\n\tunsigned int i, free_entries = 0;\n\tunsigned char val;\n\tint size = swap_entry_size(thp_nr_pages(page));\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (size == SWAPFILE_CLUSTER) {\n\t\tVM_BUG_ON(!cluster_is_huge(ci));\n\t\tmap = si->swap_map + offset;\n\t\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\t\tval = map[i];\n\t\t\tVM_BUG_ON(!(val & SWAP_HAS_CACHE));\n\t\t\tif (val == SWAP_HAS_CACHE)\n\t\t\t\tfree_entries++;\n\t\t}\n\t\tcluster_clear_huge(ci);\n\t\tif (free_entries == SWAPFILE_CLUSTER) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tspin_lock(&si->lock);\n\t\t\tmem_cgroup_uncharge_swap(entry, SWAPFILE_CLUSTER);\n\t\t\tswap_free_cluster(si, idx);\n\t\t\tspin_unlock(&si->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (i = 0; i < size; i++, entry.val++) {\n\t\tif (!__swap_entry_free_locked(si, offset + i, SWAP_HAS_CACHE)) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tfree_swap_slot(entry);\n\t\t\tif (i == size - 1)\n\t\t\t\treturn;\n\t\t\tlock_cluster_or_swap_info(si, offset);\n\t\t}\n\t}\n\tunlock_cluster_or_swap_info(si, ci);\n}\n\n#ifdef CONFIG_THP_SWAP\nint split_swap_cluster(swp_entry_t entry)\n{\n\tstruct swap_info_struct *si;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset = swp_offset(entry);\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn -EBUSY;\n\tci = lock_cluster(si, offset);\n\tcluster_clear_huge(ci);\n\tunlock_cluster(ci);\n\treturn 0;\n}\n#endif\n\nstatic int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}\n\nvoid swapcache_free_entries(swp_entry_t *entries, int n)\n{\n\tstruct swap_info_struct *p, *prev;\n\tint i;\n\n\tif (n <= 0)\n\t\treturn;\n\n\tprev = NULL;\n\tp = NULL;\n\n\t/*\n\t * Sort swap entries by swap device, so each lock is only taken once.\n\t * nr_swapfiles isn't absolutely correct, but the overhead of sort() is\n\t * so low that it isn't necessary to optimize further.\n\t */\n\tif (nr_swapfiles > 1)\n\t\tsort(entries, n, sizeof(entries[0]), swp_entry_cmp, NULL);\n\tfor (i = 0; i < n; ++i) {\n\t\tp = swap_info_get_cont(entries[i], prev);\n\t\tif (p)\n\t\t\tswap_entry_free(p, entries[i]);\n\t\tprev = p;\n\t}\n\tif (p)\n\t\tspin_unlock(&p->lock);\n}\n\n/*\n * How many references to page are currently swapped out?\n * This does not give an exact answer when swap count is continued,\n * but does include the high COUNT_CONTINUED flag to allow for that.\n */\nint page_swapcount(struct page *page)\n{\n\tint count = 0;\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tswp_entry_t entry;\n\tunsigned long offset;\n\n\tentry.val = page_private(page);\n\tp = _swap_info_get(entry);\n\tif (p) {\n\t\toffset = swp_offset(entry);\n\t\tci = lock_cluster_or_swap_info(p, offset);\n\t\tcount = swap_count(p->swap_map[offset]);\n\t\tunlock_cluster_or_swap_info(p, ci);\n\t}\n\treturn count;\n}\n\nint __swap_count(swp_entry_t entry)\n{\n\tstruct swap_info_struct *si;\n\tpgoff_t offset = swp_offset(entry);\n\tint count = 0;\n\n\tsi = get_swap_device(entry);\n\tif (si) {\n\t\tcount = swap_count(si->swap_map[offset]);\n\t\tput_swap_device(si);\n\t}\n\treturn count;\n}\n\nstatic int swap_swapcount(struct swap_info_struct *si, swp_entry_t entry)\n{\n\tint count = 0;\n\tpgoff_t offset = swp_offset(entry);\n\tstruct swap_cluster_info *ci;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tcount = swap_count(si->swap_map[offset]);\n\tunlock_cluster_or_swap_info(si, ci);\n\treturn count;\n}\n\n/*\n * How many references to @entry are currently swapped out?\n * This does not give an exact answer when swap count is continued,\n * but does include the high COUNT_CONTINUED flag to allow for that.\n */\nint __swp_swapcount(swp_entry_t entry)\n{\n\tint count = 0;\n\tstruct swap_info_struct *si;\n\n\tsi = get_swap_device(entry);\n\tif (si) {\n\t\tcount = swap_swapcount(si, entry);\n\t\tput_swap_device(si);\n\t}\n\treturn count;\n}\n\n/*\n * How many references to @entry are currently swapped out?\n * This considers COUNT_CONTINUED so it returns exact answer.\n */\nint swp_swapcount(swp_entry_t entry)\n{\n\tint count, tmp_count, n;\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tstruct page *page;\n\tpgoff_t offset;\n\tunsigned char *map;\n\n\tp = _swap_info_get(entry);\n\tif (!p)\n\t\treturn 0;\n\n\toffset = swp_offset(entry);\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\n\tcount = swap_count(p->swap_map[offset]);\n\tif (!(count & COUNT_CONTINUED))\n\t\tgoto out;\n\n\tcount &= ~COUNT_CONTINUED;\n\tn = SWAP_MAP_MAX + 1;\n\n\tpage = vmalloc_to_page(p->swap_map + offset);\n\toffset &= ~PAGE_MASK;\n\tVM_BUG_ON(page_private(page) != SWP_CONTINUED);\n\n\tdo {\n\t\tpage = list_next_entry(page, lru);\n\t\tmap = kmap_atomic(page);\n\t\ttmp_count = map[offset];\n\t\tkunmap_atomic(map);\n\n\t\tcount += (tmp_count & ~COUNT_CONTINUED) * n;\n\t\tn *= (SWAP_CONT_MAX + 1);\n\t} while (tmp_count & COUNT_CONTINUED);\nout:\n\tunlock_cluster_or_swap_info(p, ci);\n\treturn count;\n}\n\nstatic bool swap_page_trans_huge_swapped(struct swap_info_struct *si,\n\t\t\t\t\t swp_entry_t entry)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned char *map = si->swap_map;\n\tunsigned long roffset = swp_offset(entry);\n\tunsigned long offset = round_down(roffset, SWAPFILE_CLUSTER);\n\tint i;\n\tbool ret = false;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (!ci || !cluster_is_huge(ci)) {\n\t\tif (swap_count(map[roffset]))\n\t\t\tret = true;\n\t\tgoto unlock_out;\n\t}\n\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\tif (swap_count(map[offset + i])) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_out:\n\tunlock_cluster_or_swap_info(si, ci);\n\treturn ret;\n}\n\nstatic bool page_swapped(struct page *page)\n{\n\tswp_entry_t entry;\n\tstruct swap_info_struct *si;\n\n\tif (!IS_ENABLED(CONFIG_THP_SWAP) || likely(!PageTransCompound(page)))\n\t\treturn page_swapcount(page) != 0;\n\n\tpage = compound_head(page);\n\tentry.val = page_private(page);\n\tsi = _swap_info_get(entry);\n\tif (si)\n\t\treturn swap_page_trans_huge_swapped(si, entry);\n\treturn false;\n}\n\nstatic int page_trans_huge_map_swapcount(struct page *page, int *total_mapcount,\n\t\t\t\t\t int *total_swapcount)\n{\n\tint i, map_swapcount, _total_mapcount, _total_swapcount;\n\tunsigned long offset = 0;\n\tstruct swap_info_struct *si;\n\tstruct swap_cluster_info *ci = NULL;\n\tunsigned char *map = NULL;\n\tint mapcount, swapcount = 0;\n\n\t/* hugetlbfs shouldn't call it */\n\tVM_BUG_ON_PAGE(PageHuge(page), page);\n\n\tif (!IS_ENABLED(CONFIG_THP_SWAP) || likely(!PageTransCompound(page))) {\n\t\tmapcount = page_trans_huge_mapcount(page, total_mapcount);\n\t\tif (PageSwapCache(page))\n\t\t\tswapcount = page_swapcount(page);\n\t\tif (total_swapcount)\n\t\t\t*total_swapcount = swapcount;\n\t\treturn mapcount + swapcount;\n\t}\n\n\tpage = compound_head(page);\n\n\t_total_mapcount = _total_swapcount = map_swapcount = 0;\n\tif (PageSwapCache(page)) {\n\t\tswp_entry_t entry;\n\n\t\tentry.val = page_private(page);\n\t\tsi = _swap_info_get(entry);\n\t\tif (si) {\n\t\t\tmap = si->swap_map;\n\t\t\toffset = swp_offset(entry);\n\t\t}\n\t}\n\tif (map)\n\t\tci = lock_cluster(si, offset);\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tmapcount = atomic_read(&page[i]._mapcount) + 1;\n\t\t_total_mapcount += mapcount;\n\t\tif (map) {\n\t\t\tswapcount = swap_count(map[offset + i]);\n\t\t\t_total_swapcount += swapcount;\n\t\t}\n\t\tmap_swapcount = max(map_swapcount, mapcount + swapcount);\n\t}\n\tunlock_cluster(ci);\n\tif (PageDoubleMap(page)) {\n\t\tmap_swapcount -= 1;\n\t\t_total_mapcount -= HPAGE_PMD_NR;\n\t}\n\tmapcount = compound_mapcount(page);\n\tmap_swapcount += mapcount;\n\t_total_mapcount += mapcount;\n\tif (total_mapcount)\n\t\t*total_mapcount = _total_mapcount;\n\tif (total_swapcount)\n\t\t*total_swapcount = _total_swapcount;\n\n\treturn map_swapcount;\n}\n\n/*\n * We can write to an anon page without COW if there are no other references\n * to it.  And as a side-effect, free up its swap: because the old content\n * on disk will never be read, and seeking back there to write new content\n * later would only waste time away from clustering.\n *\n * NOTE: total_map_swapcount should not be relied upon by the caller if\n * reuse_swap_page() returns false, but it may be always overwritten\n * (see the other implementation for CONFIG_SWAP=n).\n */\nbool reuse_swap_page(struct page *page, int *total_map_swapcount)\n{\n\tint count, total_mapcount, total_swapcount;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (unlikely(PageKsm(page)))\n\t\treturn false;\n\tcount = page_trans_huge_map_swapcount(page, &total_mapcount,\n\t\t\t\t\t      &total_swapcount);\n\tif (total_map_swapcount)\n\t\t*total_map_swapcount = total_mapcount + total_swapcount;\n\tif (count == 1 && PageSwapCache(page) &&\n\t    (likely(!PageTransCompound(page)) ||\n\t     /* The remaining swap count will be freed soon */\n\t     total_swapcount == page_swapcount(page))) {\n\t\tif (!PageWriteback(page)) {\n\t\t\tpage = compound_head(page);\n\t\t\tdelete_from_swap_cache(page);\n\t\t\tSetPageDirty(page);\n\t\t} else {\n\t\t\tswp_entry_t entry;\n\t\t\tstruct swap_info_struct *p;\n\n\t\t\tentry.val = page_private(page);\n\t\t\tp = swap_info_get(entry);\n\t\t\tif (p->flags & SWP_STABLE_WRITES) {\n\t\t\t\tspin_unlock(&p->lock);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tspin_unlock(&p->lock);\n\t\t}\n\t}\n\n\treturn count <= 1;\n}\n\n/*\n * If swap is getting full, or if there are no more mappings of this page,\n * then try_to_free_swap is called to free its swap space.\n */\nint try_to_free_swap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!PageSwapCache(page))\n\t\treturn 0;\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tif (page_swapped(page))\n\t\treturn 0;\n\n\t/*\n\t * Once hibernation has begun to create its image of memory,\n\t * there's a danger that one of the calls to try_to_free_swap()\n\t * - most probably a call from __try_to_reclaim_swap() while\n\t * hibernation is allocating its own swap pages for the image,\n\t * but conceivably even a call from memory reclaim - will free\n\t * the swap from a page which has already been recorded in the\n\t * image as a clean swapcache page, and then reuse its swap for\n\t * another page of the image.  On waking from hibernation, the\n\t * original page might be freed under memory pressure, then\n\t * later read back in from swap, now with the wrong data.\n\t *\n\t * Hibernation suspends storage while it is writing the image\n\t * to disk so check that here.\n\t */\n\tif (pm_suspended_storage())\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\tdelete_from_swap_cache(page);\n\tSetPageDirty(page);\n\treturn 1;\n}\n\n/*\n * Free the swap entry like above, but also try to\n * free the page cache entry if it is the last user.\n */\nint free_swap_and_cache(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\tunsigned char count;\n\n\tif (non_swap_entry(entry))\n\t\treturn 1;\n\n\tp = _swap_info_get(entry);\n\tif (p) {\n\t\tcount = __swap_entry_free(p, entry);\n\t\tif (count == SWAP_HAS_CACHE &&\n\t\t    !swap_page_trans_huge_swapped(p, entry))\n\t\t\t__try_to_reclaim_swap(p, swp_offset(entry),\n\t\t\t\t\t      TTRS_UNMAPPED | TTRS_FULL);\n\t}\n\treturn p != NULL;\n}\n\n#ifdef CONFIG_HIBERNATION\n/*\n * Find the swap type that corresponds to given device (if any).\n *\n * @offset - number of the PAGE_SIZE-sized block of the device, starting\n * from 0, in which the swap header is expected to be located.\n *\n * This is needed for the suspend to disk (aka swsusp).\n */\nint swap_type_of(dev_t device, sector_t offset)\n{\n\tint type;\n\n\tif (!device)\n\t\treturn -1;\n\n\tspin_lock(&swap_lock);\n\tfor (type = 0; type < nr_swapfiles; type++) {\n\t\tstruct swap_info_struct *sis = swap_info[type];\n\n\t\tif (!(sis->flags & SWP_WRITEOK))\n\t\t\tcontinue;\n\n\t\tif (device == sis->bdev->bd_dev) {\n\t\t\tstruct swap_extent *se = first_se(sis);\n\n\t\t\tif (se->start_block == offset) {\n\t\t\t\tspin_unlock(&swap_lock);\n\t\t\t\treturn type;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&swap_lock);\n\treturn -ENODEV;\n}\n\nint find_first_swap(dev_t *device)\n{\n\tint type;\n\n\tspin_lock(&swap_lock);\n\tfor (type = 0; type < nr_swapfiles; type++) {\n\t\tstruct swap_info_struct *sis = swap_info[type];\n\n\t\tif (!(sis->flags & SWP_WRITEOK))\n\t\t\tcontinue;\n\t\t*device = sis->bdev->bd_dev;\n\t\tspin_unlock(&swap_lock);\n\t\treturn type;\n\t}\n\tspin_unlock(&swap_lock);\n\treturn -ENODEV;\n}\n\n/*\n * Get the (PAGE_SIZE) block corresponding to given offset on the swapdev\n * corresponding to given index in swap_info (swap type).\n */\nsector_t swapdev_block(int type, pgoff_t offset)\n{\n\tstruct block_device *bdev;\n\tstruct swap_info_struct *si = swap_type_to_swap_info(type);\n\n\tif (!si || !(si->flags & SWP_WRITEOK))\n\t\treturn 0;\n\treturn map_swap_entry(swp_entry(type, offset), &bdev);\n}\n\n/*\n * Return either the total number of swap pages of given type, or the number\n * of free pages of that type (depending on @free)\n *\n * This is needed for software suspend\n */\nunsigned int count_swap_pages(int type, int free)\n{\n\tunsigned int n = 0;\n\n\tspin_lock(&swap_lock);\n\tif ((unsigned int)type < nr_swapfiles) {\n\t\tstruct swap_info_struct *sis = swap_info[type];\n\n\t\tspin_lock(&sis->lock);\n\t\tif (sis->flags & SWP_WRITEOK) {\n\t\t\tn = sis->pages;\n\t\t\tif (free)\n\t\t\t\tn -= sis->inuse_pages;\n\t\t}\n\t\tspin_unlock(&sis->lock);\n\t}\n\tspin_unlock(&swap_lock);\n\treturn n;\n}\n#endif /* CONFIG_HIBERNATION */\n\nstatic inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}\n\n/*\n * No need to decide whether this PTE shares the swap entry with others,\n * just let do_wp_page work it out if a write is requested later - to\n * force COW, vm_page_prot omits write permission from any private vma.\n */\nstatic int unuse_pte(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long addr, swp_entry_t entry, struct page *page)\n{\n\tstruct page *swapcache;\n\tspinlock_t *ptl;\n\tpte_t *pte;\n\tint ret = 1;\n\n\tswapcache = page;\n\tpage = ksm_might_need_to_copy(page, vma, addr);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tif (unlikely(!pte_same_as_swp(*pte, swp_entry_to_pte(entry)))) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdec_mm_counter(vma->vm_mm, MM_SWAPENTS);\n\tinc_mm_counter(vma->vm_mm, MM_ANONPAGES);\n\tget_page(page);\n\tset_pte_at(vma->vm_mm, addr, pte,\n\t\t   pte_mkold(mk_pte(page, vma->vm_page_prot)));\n\tif (page == swapcache) {\n\t\tpage_add_anon_rmap(page, vma, addr, false);\n\t} else { /* ksm created a completely new copy */\n\t\tpage_add_new_anon_rmap(page, vma, addr, false);\n\t\tlru_cache_add_inactive_or_unevictable(page, vma);\n\t}\n\tswap_free(entry);\nout:\n\tpte_unmap_unlock(pte, ptl);\n\tif (page != swapcache) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n\treturn ret;\n}\n\nstatic int unuse_pte_range(struct vm_area_struct *vma, pmd_t *pmd,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned int type, bool frontswap,\n\t\t\tunsigned long *fs_pages_to_unuse)\n{\n\tstruct page *page;\n\tswp_entry_t entry;\n\tpte_t *pte;\n\tstruct swap_info_struct *si;\n\tunsigned long offset;\n\tint ret = 0;\n\tvolatile unsigned char *swap_map;\n\n\tsi = swap_info[type];\n\tpte = pte_offset_map(pmd, addr);\n\tdo {\n\t\tstruct vm_fault vmf;\n\n\t\tif (!is_swap_pte(*pte))\n\t\t\tcontinue;\n\n\t\tentry = pte_to_swp_entry(*pte);\n\t\tif (swp_type(entry) != type)\n\t\t\tcontinue;\n\n\t\toffset = swp_offset(entry);\n\t\tif (frontswap && !frontswap_test(si, offset))\n\t\t\tcontinue;\n\n\t\tpte_unmap(pte);\n\t\tswap_map = &si->swap_map[offset];\n\t\tpage = lookup_swap_cache(entry, vma, addr);\n\t\tif (!page) {\n\t\t\tvmf.vma = vma;\n\t\t\tvmf.address = addr;\n\t\t\tvmf.pmd = pmd;\n\t\t\tpage = swapin_readahead(entry, GFP_HIGHUSER_MOVABLE,\n\t\t\t\t\t\t&vmf);\n\t\t}\n\t\tif (!page) {\n\t\t\tif (*swap_map == 0 || *swap_map == SWAP_MAP_BAD)\n\t\t\t\tgoto try_next;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tlock_page(page);\n\t\twait_on_page_writeback(page);\n\t\tret = unuse_pte(vma, pmd, addr, entry, page);\n\t\tif (ret < 0) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttry_to_free_swap(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (*fs_pages_to_unuse && !--(*fs_pages_to_unuse)) {\n\t\t\tret = FRONTSWAP_PAGES_UNUSED;\n\t\t\tgoto out;\n\t\t}\ntry_next:\n\t\tpte = pte_offset_map(pmd, addr);\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tpte_unmap(pte - 1);\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\nstatic inline int unuse_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned int type, bool frontswap,\n\t\t\t\tunsigned long *fs_pages_to_unuse)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint ret;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tcond_resched();\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tret = unuse_pte_range(vma, pmd, addr, next, type,\n\t\t\t\t      frontswap, fs_pages_to_unuse);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}\n\nstatic inline int unuse_pud_range(struct vm_area_struct *vma, p4d_t *p4d,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned int type, bool frontswap,\n\t\t\t\tunsigned long *fs_pages_to_unuse)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint ret;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tret = unuse_pmd_range(vma, pud, addr, next, type,\n\t\t\t\t      frontswap, fs_pages_to_unuse);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (pud++, addr = next, addr != end);\n\treturn 0;\n}\n\nstatic inline int unuse_p4d_range(struct vm_area_struct *vma, pgd_t *pgd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned int type, bool frontswap,\n\t\t\t\tunsigned long *fs_pages_to_unuse)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tint ret;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tret = unuse_pud_range(vma, p4d, addr, next, type,\n\t\t\t\t      frontswap, fs_pages_to_unuse);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (p4d++, addr = next, addr != end);\n\treturn 0;\n}\n\nstatic int unuse_vma(struct vm_area_struct *vma, unsigned int type,\n\t\t     bool frontswap, unsigned long *fs_pages_to_unuse)\n{\n\tpgd_t *pgd;\n\tunsigned long addr, end, next;\n\tint ret;\n\n\taddr = vma->vm_start;\n\tend = vma->vm_end;\n\n\tpgd = pgd_offset(vma->vm_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tret = unuse_p4d_range(vma, pgd, addr, next, type,\n\t\t\t\t      frontswap, fs_pages_to_unuse);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (pgd++, addr = next, addr != end);\n\treturn 0;\n}\n\nstatic int unuse_mm(struct mm_struct *mm, unsigned int type,\n\t\t    bool frontswap, unsigned long *fs_pages_to_unuse)\n{\n\tstruct vm_area_struct *vma;\n\tint ret = 0;\n\n\tmmap_read_lock(mm);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->anon_vma) {\n\t\t\tret = unuse_vma(vma, type, frontswap,\n\t\t\t\t\tfs_pages_to_unuse);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tcond_resched();\n\t}\n\tmmap_read_unlock(mm);\n\treturn ret;\n}\n\n/*\n * Scan swap_map (or frontswap_map if frontswap parameter is true)\n * from current position to next entry still in use. Return 0\n * if there are no inuse entries after prev till end of the map.\n */\nstatic unsigned int find_next_to_unuse(struct swap_info_struct *si,\n\t\t\t\t\tunsigned int prev, bool frontswap)\n{\n\tunsigned int i;\n\tunsigned char count;\n\n\t/*\n\t * No need for swap_lock here: we're just looking\n\t * for whether an entry is in use, not modifying it; false\n\t * hits are okay, and sys_swapoff() has already prevented new\n\t * allocations from this area (while holding swap_lock).\n\t */\n\tfor (i = prev + 1; i < si->max; i++) {\n\t\tcount = READ_ONCE(si->swap_map[i]);\n\t\tif (count && swap_count(count) != SWAP_MAP_BAD)\n\t\t\tif (!frontswap || frontswap_test(si, i))\n\t\t\t\tbreak;\n\t\tif ((i % LATENCY_LIMIT) == 0)\n\t\t\tcond_resched();\n\t}\n\n\tif (i == si->max)\n\t\ti = 0;\n\n\treturn i;\n}\n\n/*\n * If the boolean frontswap is true, only unuse pages_to_unuse pages;\n * pages_to_unuse==0 means all pages; ignored if frontswap is false\n */\nint try_to_unuse(unsigned int type, bool frontswap,\n\t\t unsigned long pages_to_unuse)\n{\n\tstruct mm_struct *prev_mm;\n\tstruct mm_struct *mm;\n\tstruct list_head *p;\n\tint retval = 0;\n\tstruct swap_info_struct *si = swap_info[type];\n\tstruct page *page;\n\tswp_entry_t entry;\n\tunsigned int i;\n\n\tif (!READ_ONCE(si->inuse_pages))\n\t\treturn 0;\n\n\tif (!frontswap)\n\t\tpages_to_unuse = 0;\n\nretry:\n\tretval = shmem_unuse(type, frontswap, &pages_to_unuse);\n\tif (retval)\n\t\tgoto out;\n\n\tprev_mm = &init_mm;\n\tmmget(prev_mm);\n\n\tspin_lock(&mmlist_lock);\n\tp = &init_mm.mmlist;\n\twhile (READ_ONCE(si->inuse_pages) &&\n\t       !signal_pending(current) &&\n\t       (p = p->next) != &init_mm.mmlist) {\n\n\t\tmm = list_entry(p, struct mm_struct, mmlist);\n\t\tif (!mmget_not_zero(mm))\n\t\t\tcontinue;\n\t\tspin_unlock(&mmlist_lock);\n\t\tmmput(prev_mm);\n\t\tprev_mm = mm;\n\t\tretval = unuse_mm(mm, type, frontswap, &pages_to_unuse);\n\n\t\tif (retval) {\n\t\t\tmmput(prev_mm);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Make sure that we aren't completely killing\n\t\t * interactive performance.\n\t\t */\n\t\tcond_resched();\n\t\tspin_lock(&mmlist_lock);\n\t}\n\tspin_unlock(&mmlist_lock);\n\n\tmmput(prev_mm);\n\n\ti = 0;\n\twhile (READ_ONCE(si->inuse_pages) &&\n\t       !signal_pending(current) &&\n\t       (i = find_next_to_unuse(si, i, frontswap)) != 0) {\n\n\t\tentry = swp_entry(type, i);\n\t\tpage = find_get_page(swap_address_space(entry), i);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * It is conceivable that a racing task removed this page from\n\t\t * swap cache just before we acquired the page lock. The page\n\t\t * might even be back in swap cache on another swap area. But\n\t\t * that is okay, try_to_free_swap() only removes stale pages.\n\t\t */\n\t\tlock_page(page);\n\t\twait_on_page_writeback(page);\n\t\ttry_to_free_swap(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\t/*\n\t\t * For frontswap, we just need to unuse pages_to_unuse, if\n\t\t * it was specified. Need not check frontswap again here as\n\t\t * we already zeroed out pages_to_unuse if not frontswap.\n\t\t */\n\t\tif (pages_to_unuse && --pages_to_unuse == 0)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Lets check again to see if there are still swap entries in the map.\n\t * If yes, we would need to do retry the unuse logic again.\n\t * Under global memory pressure, swap entries can be reinserted back\n\t * into process space after the mmlist loop above passes over them.\n\t *\n\t * Limit the number of retries? No: when mmget_not_zero() above fails,\n\t * that mm is likely to be freeing swap from exit_mmap(), which proceeds\n\t * at its own independent pace; and even shmem_writepage() could have\n\t * been preempted after get_swap_page(), temporarily hiding that swap.\n\t * It's easy and robust (though cpu-intensive) just to keep retrying.\n\t */\n\tif (READ_ONCE(si->inuse_pages)) {\n\t\tif (!signal_pending(current))\n\t\t\tgoto retry;\n\t\tretval = -EINTR;\n\t}\nout:\n\treturn (retval == FRONTSWAP_PAGES_UNUSED) ? 0 : retval;\n}\n\n/*\n * After a successful try_to_unuse, if no swap is now in use, we know\n * we can empty the mmlist.  swap_lock must be held on entry and exit.\n * Note that mmlist_lock nests inside swap_lock, and an mm must be\n * added to the mmlist just after page_duplicate - before would be racy.\n */\nstatic void drain_mmlist(void)\n{\n\tstruct list_head *p, *next;\n\tunsigned int type;\n\n\tfor (type = 0; type < nr_swapfiles; type++)\n\t\tif (swap_info[type]->inuse_pages)\n\t\t\treturn;\n\tspin_lock(&mmlist_lock);\n\tlist_for_each_safe(p, next, &init_mm.mmlist)\n\t\tlist_del_init(p);\n\tspin_unlock(&mmlist_lock);\n}\n\n/*\n * Use this swapdev's extent info to locate the (PAGE_SIZE) block which\n * corresponds to page offset for the specified swap entry.\n * Note that the type of this function is sector_t, but it returns page offset\n * into the bdev, not sector offset.\n */\nstatic sector_t map_swap_entry(swp_entry_t entry, struct block_device **bdev)\n{\n\tstruct swap_info_struct *sis;\n\tstruct swap_extent *se;\n\tpgoff_t offset;\n\n\tsis = swp_swap_info(entry);\n\t*bdev = sis->bdev;\n\n\toffset = swp_offset(entry);\n\tse = offset_to_swap_extent(sis, offset);\n\treturn se->start_block + (offset - se->start_page);\n}\n\n/*\n * Returns the page offset into bdev for the specified page's swap entry.\n */\nsector_t map_swap_page(struct page *page, struct block_device **bdev)\n{\n\tswp_entry_t entry;\n\tentry.val = page_private(page);\n\treturn map_swap_entry(entry, bdev);\n}\n\n/*\n * Free all of a swapdev's extent information\n */\nstatic void destroy_swap_extents(struct swap_info_struct *sis)\n{\n\twhile (!RB_EMPTY_ROOT(&sis->swap_extent_root)) {\n\t\tstruct rb_node *rb = sis->swap_extent_root.rb_node;\n\t\tstruct swap_extent *se = rb_entry(rb, struct swap_extent, rb_node);\n\n\t\trb_erase(rb, &sis->swap_extent_root);\n\t\tkfree(se);\n\t}\n\n\tif (sis->flags & SWP_ACTIVATED) {\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\n\t\tsis->flags &= ~SWP_ACTIVATED;\n\t\tif (mapping->a_ops->swap_deactivate)\n\t\t\tmapping->a_ops->swap_deactivate(swap_file);\n\t}\n}\n\n/*\n * Add a block range (and the corresponding page range) into this swapdev's\n * extent tree.\n *\n * This function rather assumes that it is called in ascending page order.\n */\nint\nadd_swap_extent(struct swap_info_struct *sis, unsigned long start_page,\n\t\tunsigned long nr_pages, sector_t start_block)\n{\n\tstruct rb_node **link = &sis->swap_extent_root.rb_node, *parent = NULL;\n\tstruct swap_extent *se;\n\tstruct swap_extent *new_se;\n\n\t/*\n\t * place the new node at the right most since the\n\t * function is called in ascending page order.\n\t */\n\twhile (*link) {\n\t\tparent = *link;\n\t\tlink = &parent->rb_right;\n\t}\n\n\tif (parent) {\n\t\tse = rb_entry(parent, struct swap_extent, rb_node);\n\t\tBUG_ON(se->start_page + se->nr_pages != start_page);\n\t\tif (se->start_block + se->nr_pages == start_block) {\n\t\t\t/* Merge it */\n\t\t\tse->nr_pages += nr_pages;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* No merge, insert a new extent. */\n\tnew_se = kmalloc(sizeof(*se), GFP_KERNEL);\n\tif (new_se == NULL)\n\t\treturn -ENOMEM;\n\tnew_se->start_page = start_page;\n\tnew_se->nr_pages = nr_pages;\n\tnew_se->start_block = start_block;\n\n\trb_link_node(&new_se->rb_node, parent, link);\n\trb_insert_color(&new_se->rb_node, &sis->swap_extent_root);\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(add_swap_extent);\n\n/*\n * A `swap extent' is a simple thing which maps a contiguous range of pages\n * onto a contiguous range of disk blocks.  An ordered list of swap extents\n * is built at swapon time and is then used at swap_writepage/swap_readpage\n * time for locating where on disk a page belongs.\n *\n * If the swapfile is an S_ISBLK block device, a single extent is installed.\n * This is done so that the main operating code can treat S_ISBLK and S_ISREG\n * swap files identically.\n *\n * Whether the swapdev is an S_ISREG file or an S_ISBLK blockdev, the swap\n * extent list operates in PAGE_SIZE disk blocks.  Both S_ISREG and S_ISBLK\n * swapfiles are handled *identically* after swapon time.\n *\n * For S_ISREG swapfiles, setup_swap_extents() will walk all the file's blocks\n * and will parse them into an ordered extent list, in PAGE_SIZE chunks.  If\n * some stray blocks are found which do not fall within the PAGE_SIZE alignment\n * requirements, they are simply tossed out - we will never use those blocks\n * for swapping.\n *\n * For all swap devices we set S_SWAPFILE across the life of the swapon.  This\n * prevents users from writing to the swap device, which will corrupt memory.\n *\n * The amount of disk space which a single swap extent represents varies.\n * Typically it is in the 1-4 megabyte range.  So we can have hundreds of\n * extents in the list.  To avoid much list walking, we cache the previous\n * search location in `curr_swap_extent', and start new searches from there.\n * This is extremely effective.  The average number of iterations in\n * map_swap_page() has been measured at about 0.3 per page.  - akpm.\n */\nstatic int setup_swap_extents(struct swap_info_struct *sis, sector_t *span)\n{\n\tstruct file *swap_file = sis->swap_file;\n\tstruct address_space *mapping = swap_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tint ret;\n\n\tif (S_ISBLK(inode->i_mode)) {\n\t\tret = add_swap_extent(sis, 0, sis->max, 0);\n\t\t*span = sis->pages;\n\t\treturn ret;\n\t}\n\n\tif (mapping->a_ops->swap_activate) {\n\t\tret = mapping->a_ops->swap_activate(sis, swap_file, span);\n\t\tif (ret >= 0)\n\t\t\tsis->flags |= SWP_ACTIVATED;\n\t\tif (!ret) {\n\t\t\tsis->flags |= SWP_FS_OPS;\n\t\t\tret = add_swap_extent(sis, 0, sis->max, 0);\n\t\t\t*span = sis->pages;\n\t\t}\n\t\treturn ret;\n\t}\n\n\treturn generic_swapfile_activate(sis, swap_file, span);\n}\n\nstatic int swap_node(struct swap_info_struct *p)\n{\n\tstruct block_device *bdev;\n\n\tif (p->bdev)\n\t\tbdev = p->bdev;\n\telse\n\t\tbdev = p->swap_file->f_inode->i_sb->s_bdev;\n\n\treturn bdev ? bdev->bd_disk->node_id : NUMA_NO_NODE;\n}\n\nstatic void setup_swap_info(struct swap_info_struct *p, int prio,\n\t\t\t    unsigned char *swap_map,\n\t\t\t    struct swap_cluster_info *cluster_info)\n{\n\tint i;\n\n\tif (prio >= 0)\n\t\tp->prio = prio;\n\telse\n\t\tp->prio = --least_priority;\n\t/*\n\t * the plist prio is negated because plist ordering is\n\t * low-to-high, while swap ordering is high-to-low\n\t */\n\tp->list.prio = -p->prio;\n\tfor_each_node(i) {\n\t\tif (p->prio >= 0)\n\t\t\tp->avail_lists[i].prio = -p->prio;\n\t\telse {\n\t\t\tif (swap_node(p) == i)\n\t\t\t\tp->avail_lists[i].prio = 1;\n\t\t\telse\n\t\t\t\tp->avail_lists[i].prio = -p->prio;\n\t\t}\n\t}\n\tp->swap_map = swap_map;\n\tp->cluster_info = cluster_info;\n}\n\nstatic void _enable_swap_info(struct swap_info_struct *p)\n{\n\tp->flags |= SWP_WRITEOK | SWP_VALID;\n\tatomic_long_add(p->pages, &nr_swap_pages);\n\ttotal_swap_pages += p->pages;\n\n\tassert_spin_locked(&swap_lock);\n\t/*\n\t * both lists are plists, and thus priority ordered.\n\t * swap_active_head needs to be priority ordered for swapoff(),\n\t * which on removal of any swap_info_struct with an auto-assigned\n\t * (i.e. negative) priority increments the auto-assigned priority\n\t * of any lower-priority swap_info_structs.\n\t * swap_avail_head needs to be priority ordered for get_swap_page(),\n\t * which allocates swap pages from the highest available priority\n\t * swap_info_struct.\n\t */\n\tplist_add(&p->list, &swap_active_head);\n\tadd_to_avail_list(p);\n}\n\nstatic void enable_swap_info(struct swap_info_struct *p, int prio,\n\t\t\t\tunsigned char *swap_map,\n\t\t\t\tstruct swap_cluster_info *cluster_info,\n\t\t\t\tunsigned long *frontswap_map)\n{\n\tfrontswap_init(p->type, frontswap_map);\n\tspin_lock(&swap_lock);\n\tspin_lock(&p->lock);\n\tsetup_swap_info(p, prio, swap_map, cluster_info);\n\tspin_unlock(&p->lock);\n\tspin_unlock(&swap_lock);\n\t/*\n\t * Guarantee swap_map, cluster_info, etc. fields are valid\n\t * between get/put_swap_device() if SWP_VALID bit is set\n\t */\n\tsynchronize_rcu();\n\tspin_lock(&swap_lock);\n\tspin_lock(&p->lock);\n\t_enable_swap_info(p);\n\tspin_unlock(&p->lock);\n\tspin_unlock(&swap_lock);\n}\n\nstatic void reinsert_swap_info(struct swap_info_struct *p)\n{\n\tspin_lock(&swap_lock);\n\tspin_lock(&p->lock);\n\tsetup_swap_info(p, p->prio, p->swap_map, p->cluster_info);\n\t_enable_swap_info(p);\n\tspin_unlock(&p->lock);\n\tspin_unlock(&swap_lock);\n}\n\nbool has_usable_swap(void)\n{\n\tbool ret = true;\n\n\tspin_lock(&swap_lock);\n\tif (plist_head_empty(&swap_active_head))\n\t\tret = false;\n\tspin_unlock(&swap_lock);\n\treturn ret;\n}\n\nSYSCALL_DEFINE1(swapoff, const char __user *, specialfile)\n{\n\tstruct swap_info_struct *p = NULL;\n\tunsigned char *swap_map;\n\tstruct swap_cluster_info *cluster_info;\n\tunsigned long *frontswap_map;\n\tstruct file *swap_file, *victim;\n\tstruct address_space *mapping;\n\tstruct inode *inode;\n\tstruct filename *pathname;\n\tint err, found = 0;\n\tunsigned int old_block_size;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tBUG_ON(!current->mm);\n\n\tpathname = getname(specialfile);\n\tif (IS_ERR(pathname))\n\t\treturn PTR_ERR(pathname);\n\n\tvictim = file_open_name(pathname, O_RDWR|O_LARGEFILE, 0);\n\terr = PTR_ERR(victim);\n\tif (IS_ERR(victim))\n\t\tgoto out;\n\n\tmapping = victim->f_mapping;\n\tspin_lock(&swap_lock);\n\tplist_for_each_entry(p, &swap_active_head, list) {\n\t\tif (p->flags & SWP_WRITEOK) {\n\t\t\tif (p->swap_file->f_mapping == mapping) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!found) {\n\t\terr = -EINVAL;\n\t\tspin_unlock(&swap_lock);\n\t\tgoto out_dput;\n\t}\n\tif (!security_vm_enough_memory_mm(current->mm, p->pages))\n\t\tvm_unacct_memory(p->pages);\n\telse {\n\t\terr = -ENOMEM;\n\t\tspin_unlock(&swap_lock);\n\t\tgoto out_dput;\n\t}\n\tdel_from_avail_list(p);\n\tspin_lock(&p->lock);\n\tif (p->prio < 0) {\n\t\tstruct swap_info_struct *si = p;\n\t\tint nid;\n\n\t\tplist_for_each_entry_continue(si, &swap_active_head, list) {\n\t\t\tsi->prio++;\n\t\t\tsi->list.prio--;\n\t\t\tfor_each_node(nid) {\n\t\t\t\tif (si->avail_lists[nid].prio != 1)\n\t\t\t\t\tsi->avail_lists[nid].prio--;\n\t\t\t}\n\t\t}\n\t\tleast_priority++;\n\t}\n\tplist_del(&p->list, &swap_active_head);\n\tatomic_long_sub(p->pages, &nr_swap_pages);\n\ttotal_swap_pages -= p->pages;\n\tp->flags &= ~SWP_WRITEOK;\n\tspin_unlock(&p->lock);\n\tspin_unlock(&swap_lock);\n\n\tdisable_swap_slots_cache_lock();\n\n\tset_current_oom_origin();\n\terr = try_to_unuse(p->type, false, 0); /* force unuse all pages */\n\tclear_current_oom_origin();\n\n\tif (err) {\n\t\t/* re-insert swap space back into swap_list */\n\t\treinsert_swap_info(p);\n\t\treenable_swap_slots_cache_unlock();\n\t\tgoto out_dput;\n\t}\n\n\treenable_swap_slots_cache_unlock();\n\n\tspin_lock(&swap_lock);\n\tspin_lock(&p->lock);\n\tp->flags &= ~SWP_VALID;\t\t/* mark swap device as invalid */\n\tspin_unlock(&p->lock);\n\tspin_unlock(&swap_lock);\n\t/*\n\t * wait for swap operations protected by get/put_swap_device()\n\t * to complete\n\t */\n\tsynchronize_rcu();\n\n\tflush_work(&p->discard_work);\n\n\tdestroy_swap_extents(p);\n\tif (p->flags & SWP_CONTINUED)\n\t\tfree_swap_count_continuations(p);\n\n\tif (!p->bdev || !blk_queue_nonrot(bdev_get_queue(p->bdev)))\n\t\tatomic_dec(&nr_rotate_swap);\n\n\tmutex_lock(&swapon_mutex);\n\tspin_lock(&swap_lock);\n\tspin_lock(&p->lock);\n\tdrain_mmlist();\n\n\t/* wait for anyone still in scan_swap_map */\n\tp->highest_bit = 0;\t\t/* cuts scans short */\n\twhile (p->flags >= SWP_SCANNING) {\n\t\tspin_unlock(&p->lock);\n\t\tspin_unlock(&swap_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&swap_lock);\n\t\tspin_lock(&p->lock);\n\t}\n\n\tswap_file = p->swap_file;\n\told_block_size = p->old_block_size;\n\tp->swap_file = NULL;\n\tp->max = 0;\n\tswap_map = p->swap_map;\n\tp->swap_map = NULL;\n\tcluster_info = p->cluster_info;\n\tp->cluster_info = NULL;\n\tfrontswap_map = frontswap_map_get(p);\n\tspin_unlock(&p->lock);\n\tspin_unlock(&swap_lock);\n\tarch_swap_invalidate_area(p->type);\n\tfrontswap_invalidate_area(p->type);\n\tfrontswap_map_set(p, NULL);\n\tmutex_unlock(&swapon_mutex);\n\tfree_percpu(p->percpu_cluster);\n\tp->percpu_cluster = NULL;\n\tfree_percpu(p->cluster_next_cpu);\n\tp->cluster_next_cpu = NULL;\n\tvfree(swap_map);\n\tkvfree(cluster_info);\n\tkvfree(frontswap_map);\n\t/* Destroy swap account information */\n\tswap_cgroup_swapoff(p->type);\n\texit_swap_address_space(p->type);\n\n\tinode = mapping->host;\n\tif (S_ISBLK(inode->i_mode)) {\n\t\tstruct block_device *bdev = I_BDEV(inode);\n\n\t\tset_blocksize(bdev, old_block_size);\n\t\tblkdev_put(bdev, FMODE_READ | FMODE_WRITE | FMODE_EXCL);\n\t}\n\n\tinode_lock(inode);\n\tinode->i_flags &= ~S_SWAPFILE;\n\tinode_unlock(inode);\n\tfilp_close(swap_file, NULL);\n\n\t/*\n\t * Clear the SWP_USED flag after all resources are freed so that swapon\n\t * can reuse this swap_info in alloc_swap_info() safely.  It is ok to\n\t * not hold p->lock after we cleared its SWP_WRITEOK.\n\t */\n\tspin_lock(&swap_lock);\n\tp->flags = 0;\n\tspin_unlock(&swap_lock);\n\n\terr = 0;\n\tatomic_inc(&proc_poll_event);\n\twake_up_interruptible(&proc_poll_wait);\n\nout_dput:\n\tfilp_close(victim, NULL);\nout:\n\tputname(pathname);\n\treturn err;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic __poll_t swaps_poll(struct file *file, poll_table *wait)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tpoll_wait(file, &proc_poll_wait, wait);\n\n\tif (seq->poll_event != atomic_read(&proc_poll_event)) {\n\t\tseq->poll_event = atomic_read(&proc_poll_event);\n\t\treturn EPOLLIN | EPOLLRDNORM | EPOLLERR | EPOLLPRI;\n\t}\n\n\treturn EPOLLIN | EPOLLRDNORM;\n}\n\n/* iterator */\nstatic void *swap_start(struct seq_file *swap, loff_t *pos)\n{\n\tstruct swap_info_struct *si;\n\tint type;\n\tloff_t l = *pos;\n\n\tmutex_lock(&swapon_mutex);\n\n\tif (!l)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor (type = 0; (si = swap_type_to_swap_info(type)); type++) {\n\t\tif (!(si->flags & SWP_USED) || !si->swap_map)\n\t\t\tcontinue;\n\t\tif (!--l)\n\t\t\treturn si;\n\t}\n\n\treturn NULL;\n}\n\nstatic void *swap_next(struct seq_file *swap, void *v, loff_t *pos)\n{\n\tstruct swap_info_struct *si = v;\n\tint type;\n\n\tif (v == SEQ_START_TOKEN)\n\t\ttype = 0;\n\telse\n\t\ttype = si->type + 1;\n\n\t++(*pos);\n\tfor (; (si = swap_type_to_swap_info(type)); type++) {\n\t\tif (!(si->flags & SWP_USED) || !si->swap_map)\n\t\t\tcontinue;\n\t\treturn si;\n\t}\n\n\treturn NULL;\n}\n\nstatic void swap_stop(struct seq_file *swap, void *v)\n{\n\tmutex_unlock(&swapon_mutex);\n}\n\nstatic int swap_show(struct seq_file *swap, void *v)\n{\n\tstruct swap_info_struct *si = v;\n\tstruct file *file;\n\tint len;\n\tunsigned int bytes, inuse;\n\n\tif (si == SEQ_START_TOKEN) {\n\t\tseq_puts(swap,\"Filename\\t\\t\\t\\tType\\t\\tSize\\t\\tUsed\\t\\tPriority\\n\");\n\t\treturn 0;\n\t}\n\n\tbytes = si->pages << (PAGE_SHIFT - 10);\n\tinuse = si->inuse_pages << (PAGE_SHIFT - 10);\n\n\tfile = si->swap_file;\n\tlen = seq_file_path(swap, file, \" \\t\\n\\\\\");\n\tseq_printf(swap, \"%*s%s\\t%u\\t%s%u\\t%s%d\\n\",\n\t\t\tlen < 40 ? 40 - len : 1, \" \",\n\t\t\tS_ISBLK(file_inode(file)->i_mode) ?\n\t\t\t\t\"partition\" : \"file\\t\",\n\t\t\tbytes, bytes < 10000000 ? \"\\t\" : \"\",\n\t\t\tinuse, inuse < 10000000 ? \"\\t\" : \"\",\n\t\t\tsi->prio);\n\treturn 0;\n}\n\nstatic const struct seq_operations swaps_op = {\n\t.start =\tswap_start,\n\t.next =\t\tswap_next,\n\t.stop =\t\tswap_stop,\n\t.show =\t\tswap_show\n};\n\nstatic int swaps_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq;\n\tint ret;\n\n\tret = seq_open(file, &swaps_op);\n\tif (ret)\n\t\treturn ret;\n\n\tseq = file->private_data;\n\tseq->poll_event = atomic_read(&proc_poll_event);\n\treturn 0;\n}\n\nstatic const struct proc_ops swaps_proc_ops = {\n\t.proc_flags\t= PROC_ENTRY_PERMANENT,\n\t.proc_open\t= swaps_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= seq_release,\n\t.proc_poll\t= swaps_poll,\n};\n\nstatic int __init procswaps_init(void)\n{\n\tproc_create(\"swaps\", 0, NULL, &swaps_proc_ops);\n\treturn 0;\n}\n__initcall(procswaps_init);\n#endif /* CONFIG_PROC_FS */\n\n#ifdef MAX_SWAPFILES_CHECK\nstatic int __init max_swapfiles_check(void)\n{\n\tMAX_SWAPFILES_CHECK();\n\treturn 0;\n}\nlate_initcall(max_swapfiles_check);\n#endif\n\nstatic struct swap_info_struct *alloc_swap_info(void)\n{\n\tstruct swap_info_struct *p;\n\tunsigned int type;\n\tint i;\n\n\tp = kvzalloc(struct_size(p, avail_lists, nr_node_ids), GFP_KERNEL);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock(&swap_lock);\n\tfor (type = 0; type < nr_swapfiles; type++) {\n\t\tif (!(swap_info[type]->flags & SWP_USED))\n\t\t\tbreak;\n\t}\n\tif (type >= MAX_SWAPFILES) {\n\t\tspin_unlock(&swap_lock);\n\t\tkvfree(p);\n\t\treturn ERR_PTR(-EPERM);\n\t}\n\tif (type >= nr_swapfiles) {\n\t\tp->type = type;\n\t\tWRITE_ONCE(swap_info[type], p);\n\t\t/*\n\t\t * Write swap_info[type] before nr_swapfiles, in case a\n\t\t * racing procfs swap_start() or swap_next() is reading them.\n\t\t * (We never shrink nr_swapfiles, we never free this entry.)\n\t\t */\n\t\tsmp_wmb();\n\t\tWRITE_ONCE(nr_swapfiles, nr_swapfiles + 1);\n\t} else {\n\t\tkvfree(p);\n\t\tp = swap_info[type];\n\t\t/*\n\t\t * Do not memset this entry: a racing procfs swap_next()\n\t\t * would be relying on p->type to remain valid.\n\t\t */\n\t}\n\tp->swap_extent_root = RB_ROOT;\n\tplist_node_init(&p->list, 0);\n\tfor_each_node(i)\n\t\tplist_node_init(&p->avail_lists[i], 0);\n\tp->flags = SWP_USED;\n\tspin_unlock(&swap_lock);\n\tspin_lock_init(&p->lock);\n\tspin_lock_init(&p->cont_lock);\n\n\treturn p;\n}\n\nstatic int claim_swapfile(struct swap_info_struct *p, struct inode *inode)\n{\n\tint error;\n\n\tif (S_ISBLK(inode->i_mode)) {\n\t\tp->bdev = blkdev_get_by_dev(inode->i_rdev,\n\t\t\t\t   FMODE_READ | FMODE_WRITE | FMODE_EXCL, p);\n\t\tif (IS_ERR(p->bdev)) {\n\t\t\terror = PTR_ERR(p->bdev);\n\t\t\tp->bdev = NULL;\n\t\t\treturn error;\n\t\t}\n\t\tp->old_block_size = block_size(p->bdev);\n\t\terror = set_blocksize(p->bdev, PAGE_SIZE);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\t/*\n\t\t * Zoned block devices contain zones that have a sequential\n\t\t * write only restriction.  Hence zoned block devices are not\n\t\t * suitable for swapping.  Disallow them here.\n\t\t */\n\t\tif (blk_queue_is_zoned(p->bdev->bd_disk->queue))\n\t\t\treturn -EINVAL;\n\t\tp->flags |= SWP_BLKDEV;\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tp->bdev = inode->i_sb->s_bdev;\n\t}\n\n\treturn 0;\n}\n\n\n/*\n * Find out how many pages are allowed for a single swap device. There\n * are two limiting factors:\n * 1) the number of bits for the swap offset in the swp_entry_t type, and\n * 2) the number of bits in the swap pte, as defined by the different\n * architectures.\n *\n * In order to find the largest possible bit mask, a swap entry with\n * swap type 0 and swap offset ~0UL is created, encoded to a swap pte,\n * decoded to a swp_entry_t again, and finally the swap offset is\n * extracted.\n *\n * This will mask all the bits from the initial ~0UL mask that can't\n * be encoded in either the swp_entry_t or the architecture definition\n * of a swap pte.\n */\nunsigned long generic_max_swapfile_size(void)\n{\n\treturn swp_offset(pte_to_swp_entry(\n\t\t\tswp_entry_to_pte(swp_entry(0, ~0UL)))) + 1;\n}\n\n/* Can be overridden by an architecture for additional checks. */\n__weak unsigned long max_swapfile_size(void)\n{\n\treturn generic_max_swapfile_size();\n}\n\nstatic unsigned long read_swap_header(struct swap_info_struct *p,\n\t\t\t\t\tunion swap_header *swap_header,\n\t\t\t\t\tstruct inode *inode)\n{\n\tint i;\n\tunsigned long maxpages;\n\tunsigned long swapfilepages;\n\tunsigned long last_page;\n\n\tif (memcmp(\"SWAPSPACE2\", swap_header->magic.magic, 10)) {\n\t\tpr_err(\"Unable to find swap-space signature\\n\");\n\t\treturn 0;\n\t}\n\n\t/* swap partition endianess hack... */\n\tif (swab32(swap_header->info.version) == 1) {\n\t\tswab32s(&swap_header->info.version);\n\t\tswab32s(&swap_header->info.last_page);\n\t\tswab32s(&swap_header->info.nr_badpages);\n\t\tif (swap_header->info.nr_badpages > MAX_SWAP_BADPAGES)\n\t\t\treturn 0;\n\t\tfor (i = 0; i < swap_header->info.nr_badpages; i++)\n\t\t\tswab32s(&swap_header->info.badpages[i]);\n\t}\n\t/* Check the swap header's sub-version */\n\tif (swap_header->info.version != 1) {\n\t\tpr_warn(\"Unable to handle swap header version %d\\n\",\n\t\t\tswap_header->info.version);\n\t\treturn 0;\n\t}\n\n\tp->lowest_bit  = 1;\n\tp->cluster_next = 1;\n\tp->cluster_nr = 0;\n\n\tmaxpages = max_swapfile_size();\n\tlast_page = swap_header->info.last_page;\n\tif (!last_page) {\n\t\tpr_warn(\"Empty swap-file\\n\");\n\t\treturn 0;\n\t}\n\tif (last_page > maxpages) {\n\t\tpr_warn(\"Truncating oversized swap area, only using %luk out of %luk\\n\",\n\t\t\tmaxpages << (PAGE_SHIFT - 10),\n\t\t\tlast_page << (PAGE_SHIFT - 10));\n\t}\n\tif (maxpages > last_page) {\n\t\tmaxpages = last_page + 1;\n\t\t/* p->max is an unsigned int: don't overflow it */\n\t\tif ((unsigned int)maxpages == 0)\n\t\t\tmaxpages = UINT_MAX;\n\t}\n\tp->highest_bit = maxpages - 1;\n\n\tif (!maxpages)\n\t\treturn 0;\n\tswapfilepages = i_size_read(inode) >> PAGE_SHIFT;\n\tif (swapfilepages && maxpages > swapfilepages) {\n\t\tpr_warn(\"Swap area shorter than signature indicates\\n\");\n\t\treturn 0;\n\t}\n\tif (swap_header->info.nr_badpages && S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (swap_header->info.nr_badpages > MAX_SWAP_BADPAGES)\n\t\treturn 0;\n\n\treturn maxpages;\n}\n\n#define SWAP_CLUSTER_INFO_COLS\t\t\t\t\t\t\\\n\tDIV_ROUND_UP(L1_CACHE_BYTES, sizeof(struct swap_cluster_info))\n#define SWAP_CLUSTER_SPACE_COLS\t\t\t\t\t\t\\\n\tDIV_ROUND_UP(SWAP_ADDRESS_SPACE_PAGES, SWAPFILE_CLUSTER)\n#define SWAP_CLUSTER_COLS\t\t\t\t\t\t\\\n\tmax_t(unsigned int, SWAP_CLUSTER_INFO_COLS, SWAP_CLUSTER_SPACE_COLS)\n\nstatic int setup_swap_map_and_extents(struct swap_info_struct *p,\n\t\t\t\t\tunion swap_header *swap_header,\n\t\t\t\t\tunsigned char *swap_map,\n\t\t\t\t\tstruct swap_cluster_info *cluster_info,\n\t\t\t\t\tunsigned long maxpages,\n\t\t\t\t\tsector_t *span)\n{\n\tunsigned int j, k;\n\tunsigned int nr_good_pages;\n\tint nr_extents;\n\tunsigned long nr_clusters = DIV_ROUND_UP(maxpages, SWAPFILE_CLUSTER);\n\tunsigned long col = p->cluster_next / SWAPFILE_CLUSTER % SWAP_CLUSTER_COLS;\n\tunsigned long i, idx;\n\n\tnr_good_pages = maxpages - 1;\t/* omit header page */\n\n\tcluster_list_init(&p->free_clusters);\n\tcluster_list_init(&p->discard_clusters);\n\n\tfor (i = 0; i < swap_header->info.nr_badpages; i++) {\n\t\tunsigned int page_nr = swap_header->info.badpages[i];\n\t\tif (page_nr == 0 || page_nr > swap_header->info.last_page)\n\t\t\treturn -EINVAL;\n\t\tif (page_nr < maxpages) {\n\t\t\tswap_map[page_nr] = SWAP_MAP_BAD;\n\t\t\tnr_good_pages--;\n\t\t\t/*\n\t\t\t * Haven't marked the cluster free yet, no list\n\t\t\t * operation involved\n\t\t\t */\n\t\t\tinc_cluster_info_page(p, cluster_info, page_nr);\n\t\t}\n\t}\n\n\t/* Haven't marked the cluster free yet, no list operation involved */\n\tfor (i = maxpages; i < round_up(maxpages, SWAPFILE_CLUSTER); i++)\n\t\tinc_cluster_info_page(p, cluster_info, i);\n\n\tif (nr_good_pages) {\n\t\tswap_map[0] = SWAP_MAP_BAD;\n\t\t/*\n\t\t * Not mark the cluster free yet, no list\n\t\t * operation involved\n\t\t */\n\t\tinc_cluster_info_page(p, cluster_info, 0);\n\t\tp->max = maxpages;\n\t\tp->pages = nr_good_pages;\n\t\tnr_extents = setup_swap_extents(p, span);\n\t\tif (nr_extents < 0)\n\t\t\treturn nr_extents;\n\t\tnr_good_pages = p->pages;\n\t}\n\tif (!nr_good_pages) {\n\t\tpr_warn(\"Empty swap-file\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cluster_info)\n\t\treturn nr_extents;\n\n\n\t/*\n\t * Reduce false cache line sharing between cluster_info and\n\t * sharing same address space.\n\t */\n\tfor (k = 0; k < SWAP_CLUSTER_COLS; k++) {\n\t\tj = (k + col) % SWAP_CLUSTER_COLS;\n\t\tfor (i = 0; i < DIV_ROUND_UP(nr_clusters, SWAP_CLUSTER_COLS); i++) {\n\t\t\tidx = i * SWAP_CLUSTER_COLS + j;\n\t\t\tif (idx >= nr_clusters)\n\t\t\t\tcontinue;\n\t\t\tif (cluster_count(&cluster_info[idx]))\n\t\t\t\tcontinue;\n\t\t\tcluster_set_flag(&cluster_info[idx], CLUSTER_FLAG_FREE);\n\t\t\tcluster_list_add_tail(&p->free_clusters, cluster_info,\n\t\t\t\t\t      idx);\n\t\t}\n\t}\n\treturn nr_extents;\n}\n\n/*\n * Helper to sys_swapon determining if a given swap\n * backing device queue supports DISCARD operations.\n */\nstatic bool swap_discardable(struct swap_info_struct *si)\n{\n\tstruct request_queue *q = bdev_get_queue(si->bdev);\n\n\tif (!q || !blk_queue_discard(q))\n\t\treturn false;\n\n\treturn true;\n}\n\nSYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)\n{\n\tstruct swap_info_struct *p;\n\tstruct filename *name;\n\tstruct file *swap_file = NULL;\n\tstruct address_space *mapping;\n\tint prio;\n\tint error;\n\tunion swap_header *swap_header;\n\tint nr_extents;\n\tsector_t span;\n\tunsigned long maxpages;\n\tunsigned char *swap_map = NULL;\n\tstruct swap_cluster_info *cluster_info = NULL;\n\tunsigned long *frontswap_map = NULL;\n\tstruct page *page = NULL;\n\tstruct inode *inode = NULL;\n\tbool inced_nr_rotate_swap = false;\n\n\tif (swap_flags & ~SWAP_FLAGS_VALID)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!swap_avail_heads)\n\t\treturn -ENOMEM;\n\n\tp = alloc_swap_info();\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tINIT_WORK(&p->discard_work, swap_discard_work);\n\n\tname = getname(specialfile);\n\tif (IS_ERR(name)) {\n\t\terror = PTR_ERR(name);\n\t\tname = NULL;\n\t\tgoto bad_swap;\n\t}\n\tswap_file = file_open_name(name, O_RDWR|O_LARGEFILE, 0);\n\tif (IS_ERR(swap_file)) {\n\t\terror = PTR_ERR(swap_file);\n\t\tswap_file = NULL;\n\t\tgoto bad_swap;\n\t}\n\n\tp->swap_file = swap_file;\n\tmapping = swap_file->f_mapping;\n\tinode = mapping->host;\n\n\terror = claim_swapfile(p, inode);\n\tif (unlikely(error))\n\t\tgoto bad_swap;\n\n\tinode_lock(inode);\n\tif (IS_SWAPFILE(inode)) {\n\t\terror = -EBUSY;\n\t\tgoto bad_swap_unlock_inode;\n\t}\n\n\t/*\n\t * Read the swap header.\n\t */\n\tif (!mapping->a_ops->readpage) {\n\t\terror = -EINVAL;\n\t\tgoto bad_swap_unlock_inode;\n\t}\n\tpage = read_mapping_page(mapping, 0, swap_file);\n\tif (IS_ERR(page)) {\n\t\terror = PTR_ERR(page);\n\t\tgoto bad_swap_unlock_inode;\n\t}\n\tswap_header = kmap(page);\n\n\tmaxpages = read_swap_header(p, swap_header, inode);\n\tif (unlikely(!maxpages)) {\n\t\terror = -EINVAL;\n\t\tgoto bad_swap_unlock_inode;\n\t}\n\n\t/* OK, set up the swap map and apply the bad block list */\n\tswap_map = vzalloc(maxpages);\n\tif (!swap_map) {\n\t\terror = -ENOMEM;\n\t\tgoto bad_swap_unlock_inode;\n\t}\n\n\tif (p->bdev && blk_queue_stable_writes(p->bdev->bd_disk->queue))\n\t\tp->flags |= SWP_STABLE_WRITES;\n\n\tif (p->bdev && p->bdev->bd_disk->fops->rw_page)\n\t\tp->flags |= SWP_SYNCHRONOUS_IO;\n\n\tif (p->bdev && blk_queue_nonrot(bdev_get_queue(p->bdev))) {\n\t\tint cpu;\n\t\tunsigned long ci, nr_cluster;\n\n\t\tp->flags |= SWP_SOLIDSTATE;\n\t\tp->cluster_next_cpu = alloc_percpu(unsigned int);\n\t\tif (!p->cluster_next_cpu) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto bad_swap_unlock_inode;\n\t\t}\n\t\t/*\n\t\t * select a random position to start with to help wear leveling\n\t\t * SSD\n\t\t */\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tper_cpu(*p->cluster_next_cpu, cpu) =\n\t\t\t\t1 + prandom_u32_max(p->highest_bit);\n\t\t}\n\t\tnr_cluster = DIV_ROUND_UP(maxpages, SWAPFILE_CLUSTER);\n\n\t\tcluster_info = kvcalloc(nr_cluster, sizeof(*cluster_info),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!cluster_info) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto bad_swap_unlock_inode;\n\t\t}\n\n\t\tfor (ci = 0; ci < nr_cluster; ci++)\n\t\t\tspin_lock_init(&((cluster_info + ci)->lock));\n\n\t\tp->percpu_cluster = alloc_percpu(struct percpu_cluster);\n\t\tif (!p->percpu_cluster) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto bad_swap_unlock_inode;\n\t\t}\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct percpu_cluster *cluster;\n\t\t\tcluster = per_cpu_ptr(p->percpu_cluster, cpu);\n\t\t\tcluster_set_null(&cluster->index);\n\t\t}\n\t} else {\n\t\tatomic_inc(&nr_rotate_swap);\n\t\tinced_nr_rotate_swap = true;\n\t}\n\n\terror = swap_cgroup_swapon(p->type, maxpages);\n\tif (error)\n\t\tgoto bad_swap_unlock_inode;\n\n\tnr_extents = setup_swap_map_and_extents(p, swap_header, swap_map,\n\t\tcluster_info, maxpages, &span);\n\tif (unlikely(nr_extents < 0)) {\n\t\terror = nr_extents;\n\t\tgoto bad_swap_unlock_inode;\n\t}\n\t/* frontswap enabled? set up bit-per-page map for frontswap */\n\tif (IS_ENABLED(CONFIG_FRONTSWAP))\n\t\tfrontswap_map = kvcalloc(BITS_TO_LONGS(maxpages),\n\t\t\t\t\t sizeof(long),\n\t\t\t\t\t GFP_KERNEL);\n\n\tif (p->bdev &&(swap_flags & SWAP_FLAG_DISCARD) && swap_discardable(p)) {\n\t\t/*\n\t\t * When discard is enabled for swap with no particular\n\t\t * policy flagged, we set all swap discard flags here in\n\t\t * order to sustain backward compatibility with older\n\t\t * swapon(8) releases.\n\t\t */\n\t\tp->flags |= (SWP_DISCARDABLE | SWP_AREA_DISCARD |\n\t\t\t     SWP_PAGE_DISCARD);\n\n\t\t/*\n\t\t * By flagging sys_swapon, a sysadmin can tell us to\n\t\t * either do single-time area discards only, or to just\n\t\t * perform discards for released swap page-clusters.\n\t\t * Now it's time to adjust the p->flags accordingly.\n\t\t */\n\t\tif (swap_flags & SWAP_FLAG_DISCARD_ONCE)\n\t\t\tp->flags &= ~SWP_PAGE_DISCARD;\n\t\telse if (swap_flags & SWAP_FLAG_DISCARD_PAGES)\n\t\t\tp->flags &= ~SWP_AREA_DISCARD;\n\n\t\t/* issue a swapon-time discard if it's still required */\n\t\tif (p->flags & SWP_AREA_DISCARD) {\n\t\t\tint err = discard_swap(p);\n\t\t\tif (unlikely(err))\n\t\t\t\tpr_err(\"swapon: discard_swap(%p): %d\\n\",\n\t\t\t\t\tp, err);\n\t\t}\n\t}\n\n\terror = init_swap_address_space(p->type, maxpages);\n\tif (error)\n\t\tgoto bad_swap_unlock_inode;\n\n\t/*\n\t * Flush any pending IO and dirty mappings before we start using this\n\t * swap device.\n\t */\n\tinode->i_flags |= S_SWAPFILE;\n\terror = inode_drain_writes(inode);\n\tif (error) {\n\t\tinode->i_flags &= ~S_SWAPFILE;\n\t\tgoto free_swap_address_space;\n\t}\n\n\tmutex_lock(&swapon_mutex);\n\tprio = -1;\n\tif (swap_flags & SWAP_FLAG_PREFER)\n\t\tprio =\n\t\t  (swap_flags & SWAP_FLAG_PRIO_MASK) >> SWAP_FLAG_PRIO_SHIFT;\n\tenable_swap_info(p, prio, swap_map, cluster_info, frontswap_map);\n\n\tpr_info(\"Adding %uk swap on %s.  Priority:%d extents:%d across:%lluk %s%s%s%s%s\\n\",\n\t\tp->pages<<(PAGE_SHIFT-10), name->name, p->prio,\n\t\tnr_extents, (unsigned long long)span<<(PAGE_SHIFT-10),\n\t\t(p->flags & SWP_SOLIDSTATE) ? \"SS\" : \"\",\n\t\t(p->flags & SWP_DISCARDABLE) ? \"D\" : \"\",\n\t\t(p->flags & SWP_AREA_DISCARD) ? \"s\" : \"\",\n\t\t(p->flags & SWP_PAGE_DISCARD) ? \"c\" : \"\",\n\t\t(frontswap_map) ? \"FS\" : \"\");\n\n\tmutex_unlock(&swapon_mutex);\n\tatomic_inc(&proc_poll_event);\n\twake_up_interruptible(&proc_poll_wait);\n\n\terror = 0;\n\tgoto out;\nfree_swap_address_space:\n\texit_swap_address_space(p->type);\nbad_swap_unlock_inode:\n\tinode_unlock(inode);\nbad_swap:\n\tfree_percpu(p->percpu_cluster);\n\tp->percpu_cluster = NULL;\n\tfree_percpu(p->cluster_next_cpu);\n\tp->cluster_next_cpu = NULL;\n\tif (inode && S_ISBLK(inode->i_mode) && p->bdev) {\n\t\tset_blocksize(p->bdev, p->old_block_size);\n\t\tblkdev_put(p->bdev, FMODE_READ | FMODE_WRITE | FMODE_EXCL);\n\t}\n\tinode = NULL;\n\tdestroy_swap_extents(p);\n\tswap_cgroup_swapoff(p->type);\n\tspin_lock(&swap_lock);\n\tp->swap_file = NULL;\n\tp->flags = 0;\n\tspin_unlock(&swap_lock);\n\tvfree(swap_map);\n\tkvfree(cluster_info);\n\tkvfree(frontswap_map);\n\tif (inced_nr_rotate_swap)\n\t\tatomic_dec(&nr_rotate_swap);\n\tif (swap_file)\n\t\tfilp_close(swap_file, NULL);\nout:\n\tif (page && !IS_ERR(page)) {\n\t\tkunmap(page);\n\t\tput_page(page);\n\t}\n\tif (name)\n\t\tputname(name);\n\tif (inode)\n\t\tinode_unlock(inode);\n\tif (!error)\n\t\tenable_swap_slots_cache();\n\treturn error;\n}\n\nvoid si_swapinfo(struct sysinfo *val)\n{\n\tunsigned int type;\n\tunsigned long nr_to_be_unused = 0;\n\n\tspin_lock(&swap_lock);\n\tfor (type = 0; type < nr_swapfiles; type++) {\n\t\tstruct swap_info_struct *si = swap_info[type];\n\n\t\tif ((si->flags & SWP_USED) && !(si->flags & SWP_WRITEOK))\n\t\t\tnr_to_be_unused += si->inuse_pages;\n\t}\n\tval->freeswap = atomic_long_read(&nr_swap_pages) + nr_to_be_unused;\n\tval->totalswap = total_swap_pages + nr_to_be_unused;\n\tspin_unlock(&swap_lock);\n}\n\n/*\n * Verify that a swap entry is valid and increment its swap map count.\n *\n * Returns error code in following case.\n * - success -> 0\n * - swp_entry is invalid -> EINVAL\n * - swp_entry is migration entry -> EINVAL\n * - swap-cache reference is requested but there is already one. -> EEXIST\n * - swap-cache reference is requested but the entry is not used. -> ENOENT\n * - swap-mapped reference requested but needs continued swap count. -> ENOMEM\n */\nstatic int __swap_duplicate(swp_entry_t entry, unsigned char usage)\n{\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset;\n\tunsigned char count;\n\tunsigned char has_cache;\n\tint err = -EINVAL;\n\n\tp = get_swap_device(entry);\n\tif (!p)\n\t\tgoto out;\n\n\toffset = swp_offset(entry);\n\tci = lock_cluster_or_swap_info(p, offset);\n\n\tcount = p->swap_map[offset];\n\n\t/*\n\t * swapin_readahead() doesn't check if a swap entry is valid, so the\n\t * swap entry could be SWAP_MAP_BAD. Check here with lock held.\n\t */\n\tif (unlikely(swap_count(count) == SWAP_MAP_BAD)) {\n\t\terr = -ENOENT;\n\t\tgoto unlock_out;\n\t}\n\n\thas_cache = count & SWAP_HAS_CACHE;\n\tcount &= ~SWAP_HAS_CACHE;\n\terr = 0;\n\n\tif (usage == SWAP_HAS_CACHE) {\n\n\t\t/* set SWAP_HAS_CACHE if there is no cache and entry is used */\n\t\tif (!has_cache && count)\n\t\t\thas_cache = SWAP_HAS_CACHE;\n\t\telse if (has_cache)\t\t/* someone else added cache */\n\t\t\terr = -EEXIST;\n\t\telse\t\t\t\t/* no users remaining */\n\t\t\terr = -ENOENT;\n\n\t} else if (count || has_cache) {\n\n\t\tif ((count & ~COUNT_CONTINUED) < SWAP_MAP_MAX)\n\t\t\tcount += usage;\n\t\telse if ((count & ~COUNT_CONTINUED) > SWAP_MAP_MAX)\n\t\t\terr = -EINVAL;\n\t\telse if (swap_count_continued(p, offset, count))\n\t\t\tcount = COUNT_CONTINUED;\n\t\telse\n\t\t\terr = -ENOMEM;\n\t} else\n\t\terr = -ENOENT;\t\t\t/* unused swap entry */\n\n\tWRITE_ONCE(p->swap_map[offset], count | has_cache);\n\nunlock_out:\n\tunlock_cluster_or_swap_info(p, ci);\nout:\n\tif (p)\n\t\tput_swap_device(p);\n\treturn err;\n}\n\n/*\n * Help swapoff by noting that swap entry belongs to shmem/tmpfs\n * (in which case its reference count is never incremented).\n */\nvoid swap_shmem_alloc(swp_entry_t entry)\n{\n\t__swap_duplicate(entry, SWAP_MAP_SHMEM);\n}\n\n/*\n * Increase reference count of swap entry by 1.\n * Returns 0 for success, or -ENOMEM if a swap_count_continuation is required\n * but could not be atomically allocated.  Returns 0, just as if it succeeded,\n * if __swap_duplicate() fails for another reason (-EINVAL or -ENOENT), which\n * might occur if a page table entry has got corrupted.\n */\nint swap_duplicate(swp_entry_t entry)\n{\n\tint err = 0;\n\n\twhile (!err && __swap_duplicate(entry, 1) == -ENOMEM)\n\t\terr = add_swap_count_continuation(entry, GFP_ATOMIC);\n\treturn err;\n}\n\n/*\n * @entry: swap entry for which we allocate swap cache.\n *\n * Called when allocating swap cache for existing swap entry,\n * This can return error codes. Returns 0 at success.\n * -EEXIST means there is a swap cache.\n * Note: return code is different from swap_duplicate().\n */\nint swapcache_prepare(swp_entry_t entry)\n{\n\treturn __swap_duplicate(entry, SWAP_HAS_CACHE);\n}\n\nstruct swap_info_struct *swp_swap_info(swp_entry_t entry)\n{\n\treturn swap_type_to_swap_info(swp_type(entry));\n}\n\nstruct swap_info_struct *page_swap_info(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\treturn swp_swap_info(entry);\n}\n\n/*\n * out-of-line __page_file_ methods to avoid include hell.\n */\nstruct address_space *__page_file_mapping(struct page *page)\n{\n\treturn page_swap_info(page)->swap_file->f_mapping;\n}\nEXPORT_SYMBOL_GPL(__page_file_mapping);\n\npgoff_t __page_file_index(struct page *page)\n{\n\tswp_entry_t swap = { .val = page_private(page) };\n\treturn swp_offset(swap);\n}\nEXPORT_SYMBOL_GPL(__page_file_index);\n\n/*\n * add_swap_count_continuation - called when a swap count is duplicated\n * beyond SWAP_MAP_MAX, it allocates a new page and links that to the entry's\n * page of the original vmalloc'ed swap_map, to hold the continuation count\n * (for that entry and for its neighbouring PAGE_SIZE swap entries).  Called\n * again when count is duplicated beyond SWAP_MAP_MAX * SWAP_CONT_MAX, etc.\n *\n * These continuation pages are seldom referenced: the common paths all work\n * on the original swap_map, only referring to a continuation page when the\n * low \"digit\" of a count is incremented or decremented through SWAP_MAP_MAX.\n *\n * add_swap_count_continuation(, GFP_ATOMIC) can be called while holding\n * page table locks; if it fails, add_swap_count_continuation(, GFP_KERNEL)\n * can be called after dropping locks.\n */\nint add_swap_count_continuation(swp_entry_t entry, gfp_t gfp_mask)\n{\n\tstruct swap_info_struct *si;\n\tstruct swap_cluster_info *ci;\n\tstruct page *head;\n\tstruct page *page;\n\tstruct page *list_page;\n\tpgoff_t offset;\n\tunsigned char count;\n\tint ret = 0;\n\n\t/*\n\t * When debugging, it's easier to use __GFP_ZERO here; but it's better\n\t * for latency not to zero a page while GFP_ATOMIC and holding locks.\n\t */\n\tpage = alloc_page(gfp_mask | __GFP_HIGHMEM);\n\n\tsi = get_swap_device(entry);\n\tif (!si) {\n\t\t/*\n\t\t * An acceptable race has occurred since the failing\n\t\t * __swap_duplicate(): the swap device may be swapoff\n\t\t */\n\t\tgoto outer;\n\t}\n\tspin_lock(&si->lock);\n\n\toffset = swp_offset(entry);\n\n\tci = lock_cluster(si, offset);\n\n\tcount = si->swap_map[offset] & ~SWAP_HAS_CACHE;\n\n\tif ((count & ~COUNT_CONTINUED) != SWAP_MAP_MAX) {\n\t\t/*\n\t\t * The higher the swap count, the more likely it is that tasks\n\t\t * will race to add swap count continuation: we need to avoid\n\t\t * over-provisioning.\n\t\t */\n\t\tgoto out;\n\t}\n\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We are fortunate that although vmalloc_to_page uses pte_offset_map,\n\t * no architecture is using highmem pages for kernel page tables: so it\n\t * will not corrupt the GFP_ATOMIC caller's atomic page table kmaps.\n\t */\n\thead = vmalloc_to_page(si->swap_map + offset);\n\toffset &= ~PAGE_MASK;\n\n\tspin_lock(&si->cont_lock);\n\t/*\n\t * Page allocation does not initialize the page's lru field,\n\t * but it does always reset its private field.\n\t */\n\tif (!page_private(head)) {\n\t\tBUG_ON(count & COUNT_CONTINUED);\n\t\tINIT_LIST_HEAD(&head->lru);\n\t\tset_page_private(head, SWP_CONTINUED);\n\t\tsi->flags |= SWP_CONTINUED;\n\t}\n\n\tlist_for_each_entry(list_page, &head->lru, lru) {\n\t\tunsigned char *map;\n\n\t\t/*\n\t\t * If the previous map said no continuation, but we've found\n\t\t * a continuation page, free our allocation and use this one.\n\t\t */\n\t\tif (!(count & COUNT_CONTINUED))\n\t\t\tgoto out_unlock_cont;\n\n\t\tmap = kmap_atomic(list_page) + offset;\n\t\tcount = *map;\n\t\tkunmap_atomic(map);\n\n\t\t/*\n\t\t * If this continuation count now has some space in it,\n\t\t * free our allocation and use this one.\n\t\t */\n\t\tif ((count & ~COUNT_CONTINUED) != SWAP_CONT_MAX)\n\t\t\tgoto out_unlock_cont;\n\t}\n\n\tlist_add_tail(&page->lru, &head->lru);\n\tpage = NULL;\t\t\t/* now it's attached, don't free it */\nout_unlock_cont:\n\tspin_unlock(&si->cont_lock);\nout:\n\tunlock_cluster(ci);\n\tspin_unlock(&si->lock);\n\tput_swap_device(si);\nouter:\n\tif (page)\n\t\t__free_page(page);\n\treturn ret;\n}\n\n/*\n * swap_count_continued - when the original swap_map count is incremented\n * from SWAP_MAP_MAX, check if there is already a continuation page to carry\n * into, carry if so, or else fail until a new continuation page is allocated;\n * when the original swap_map count is decremented from 0 with continuation,\n * borrow from the continuation and report whether it still holds more.\n * Called while __swap_duplicate() or swap_entry_free() holds swap or cluster\n * lock.\n */\nstatic bool swap_count_continued(struct swap_info_struct *si,\n\t\t\t\t pgoff_t offset, unsigned char count)\n{\n\tstruct page *head;\n\tstruct page *page;\n\tunsigned char *map;\n\tbool ret;\n\n\thead = vmalloc_to_page(si->swap_map + offset);\n\tif (page_private(head) != SWP_CONTINUED) {\n\t\tBUG_ON(count & COUNT_CONTINUED);\n\t\treturn false;\t\t/* need to add count continuation */\n\t}\n\n\tspin_lock(&si->cont_lock);\n\toffset &= ~PAGE_MASK;\n\tpage = list_next_entry(head, lru);\n\tmap = kmap_atomic(page) + offset;\n\n\tif (count == SWAP_MAP_MAX)\t/* initial increment from swap_map */\n\t\tgoto init_map;\t\t/* jump over SWAP_CONT_MAX checks */\n\n\tif (count == (SWAP_MAP_MAX | COUNT_CONTINUED)) { /* incrementing */\n\t\t/*\n\t\t * Think of how you add 1 to 999\n\t\t */\n\t\twhile (*map == (SWAP_CONT_MAX | COUNT_CONTINUED)) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_next_entry(page, lru);\n\t\t\tBUG_ON(page == head);\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t}\n\t\tif (*map == SWAP_CONT_MAX) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_next_entry(page, lru);\n\t\t\tif (page == head) {\n\t\t\t\tret = false;\t/* add count continuation */\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmap = kmap_atomic(page) + offset;\ninit_map:\t\t*map = 0;\t\t/* we didn't zero the page */\n\t\t}\n\t\t*map += 1;\n\t\tkunmap_atomic(map);\n\t\twhile ((page = list_prev_entry(page, lru)) != head) {\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t\t*map = COUNT_CONTINUED;\n\t\t\tkunmap_atomic(map);\n\t\t}\n\t\tret = true;\t\t\t/* incremented */\n\n\t} else {\t\t\t\t/* decrementing */\n\t\t/*\n\t\t * Think of how you subtract 1 from 1000\n\t\t */\n\t\tBUG_ON(count != COUNT_CONTINUED);\n\t\twhile (*map == COUNT_CONTINUED) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_next_entry(page, lru);\n\t\t\tBUG_ON(page == head);\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t}\n\t\tBUG_ON(*map == 0);\n\t\t*map -= 1;\n\t\tif (*map == 0)\n\t\t\tcount = 0;\n\t\tkunmap_atomic(map);\n\t\twhile ((page = list_prev_entry(page, lru)) != head) {\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t\t*map = SWAP_CONT_MAX | count;\n\t\t\tcount = COUNT_CONTINUED;\n\t\t\tkunmap_atomic(map);\n\t\t}\n\t\tret = count == COUNT_CONTINUED;\n\t}\nout:\n\tspin_unlock(&si->cont_lock);\n\treturn ret;\n}\n\n/*\n * free_swap_count_continuations - swapoff free all the continuation pages\n * appended to the swap_map, after swap_map is quiesced, before vfree'ing it.\n */\nstatic void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}\n\n#if defined(CONFIG_MEMCG) && defined(CONFIG_BLK_CGROUP)\nvoid cgroup_throttle_swaprate(struct page *page, gfp_t gfp_mask)\n{\n\tstruct swap_info_struct *si, *next;\n\tint nid = page_to_nid(page);\n\n\tif (!(gfp_mask & __GFP_IO))\n\t\treturn;\n\n\tif (!blk_cgroup_congested())\n\t\treturn;\n\n\t/*\n\t * We've already scheduled a throttle, avoid taking the global swap\n\t * lock.\n\t */\n\tif (current->throttle_queue)\n\t\treturn;\n\n\tspin_lock(&swap_avail_lock);\n\tplist_for_each_entry_safe(si, next, &swap_avail_heads[nid],\n\t\t\t\t  avail_lists[nid]) {\n\t\tif (si->bdev) {\n\t\t\tblkcg_schedule_throttle(bdev_get_queue(si->bdev), true);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&swap_avail_lock);\n}\n#endif\n\nstatic int __init swapfile_init(void)\n{\n\tint nid;\n\n\tswap_avail_heads = kmalloc_array(nr_node_ids, sizeof(struct plist_head),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!swap_avail_heads) {\n\t\tpr_emerg(\"Not enough memory for swap heads, swap is disabled\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor_each_node(nid)\n\t\tplist_head_init(&swap_avail_heads[nid]);\n\n\treturn 0;\n}\nsubsys_initcall(swapfile_init);\n"}}, "reports": [{"events": [{"location": {"col": -1, "file": 0, "line": 1398}, "message": "put_swap_page() error: double locked 'si->lock' (orig line 1385)"}], "macros": [], "notes": [], "path": "/src/mm/swapfile.c", "reportHash": "5890dae74ad39edc6dd238fbefe6bc8f", "checkerName": "smatch", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": -1, "file": 0, "line": 1411}, "message": "put_swap_page() error: double locked 'si->lock' (orig line 1385)"}], "macros": [], "notes": [], "path": "/src/mm/swapfile.c", "reportHash": "28025a53460617f458a89c13c75a8d22", "checkerName": "smatch", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": -1, "file": 0, "line": 3356}, "message": "__do_sys_swapon() warn: should 'p->pages << (12 - 10)' be a 64 bit type?"}], "macros": [], "notes": [], "path": "/src/mm/swapfile.c", "reportHash": "82cc6610fda381aea56278ab04b41e3b", "checkerName": "smatch", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
