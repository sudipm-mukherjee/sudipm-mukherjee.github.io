<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/net/wireless/ath/ath10k/mac.c", "content": "// SPDX-License-Identifier: ISC\n/*\n * Copyright (c) 2005-2011 Atheros Communications Inc.\n * Copyright (c) 2011-2017 Qualcomm Atheros, Inc.\n * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.\n */\n\n#include \"mac.h\"\n\n#include <net/cfg80211.h>\n#include <net/mac80211.h>\n#include <linux/etherdevice.h>\n#include <linux/acpi.h>\n#include <linux/of.h>\n#include <linux/bitfield.h>\n\n#include \"hif.h\"\n#include \"core.h\"\n#include \"debug.h\"\n#include \"wmi.h\"\n#include \"htt.h\"\n#include \"txrx.h\"\n#include \"testmode.h\"\n#include \"wmi-tlv.h\"\n#include \"wmi-ops.h\"\n#include \"wow.h\"\n\n/*********/\n/* Rates */\n/*********/\n\nstatic struct ieee80211_rate ath10k_rates[] = {\n\t{ .bitrate = 10,\n\t  .hw_value = ATH10K_HW_RATE_CCK_LP_1M },\n\t{ .bitrate = 20,\n\t  .hw_value = ATH10K_HW_RATE_CCK_LP_2M,\n\t  .hw_value_short = ATH10K_HW_RATE_CCK_SP_2M,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55,\n\t  .hw_value = ATH10K_HW_RATE_CCK_LP_5_5M,\n\t  .hw_value_short = ATH10K_HW_RATE_CCK_SP_5_5M,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110,\n\t  .hw_value = ATH10K_HW_RATE_CCK_LP_11M,\n\t  .hw_value_short = ATH10K_HW_RATE_CCK_SP_11M,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\n\t{ .bitrate = 60, .hw_value = ATH10K_HW_RATE_OFDM_6M },\n\t{ .bitrate = 90, .hw_value = ATH10K_HW_RATE_OFDM_9M },\n\t{ .bitrate = 120, .hw_value = ATH10K_HW_RATE_OFDM_12M },\n\t{ .bitrate = 180, .hw_value = ATH10K_HW_RATE_OFDM_18M },\n\t{ .bitrate = 240, .hw_value = ATH10K_HW_RATE_OFDM_24M },\n\t{ .bitrate = 360, .hw_value = ATH10K_HW_RATE_OFDM_36M },\n\t{ .bitrate = 480, .hw_value = ATH10K_HW_RATE_OFDM_48M },\n\t{ .bitrate = 540, .hw_value = ATH10K_HW_RATE_OFDM_54M },\n};\n\nstatic struct ieee80211_rate ath10k_rates_rev2[] = {\n\t{ .bitrate = 10,\n\t  .hw_value = ATH10K_HW_RATE_REV2_CCK_LP_1M },\n\t{ .bitrate = 20,\n\t  .hw_value = ATH10K_HW_RATE_REV2_CCK_LP_2M,\n\t  .hw_value_short = ATH10K_HW_RATE_REV2_CCK_SP_2M,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55,\n\t  .hw_value = ATH10K_HW_RATE_REV2_CCK_LP_5_5M,\n\t  .hw_value_short = ATH10K_HW_RATE_REV2_CCK_SP_5_5M,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110,\n\t  .hw_value = ATH10K_HW_RATE_REV2_CCK_LP_11M,\n\t  .hw_value_short = ATH10K_HW_RATE_REV2_CCK_SP_11M,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\n\t{ .bitrate = 60, .hw_value = ATH10K_HW_RATE_OFDM_6M },\n\t{ .bitrate = 90, .hw_value = ATH10K_HW_RATE_OFDM_9M },\n\t{ .bitrate = 120, .hw_value = ATH10K_HW_RATE_OFDM_12M },\n\t{ .bitrate = 180, .hw_value = ATH10K_HW_RATE_OFDM_18M },\n\t{ .bitrate = 240, .hw_value = ATH10K_HW_RATE_OFDM_24M },\n\t{ .bitrate = 360, .hw_value = ATH10K_HW_RATE_OFDM_36M },\n\t{ .bitrate = 480, .hw_value = ATH10K_HW_RATE_OFDM_48M },\n\t{ .bitrate = 540, .hw_value = ATH10K_HW_RATE_OFDM_54M },\n};\n\nstatic const struct cfg80211_sar_freq_ranges ath10k_sar_freq_ranges[] = {\n\t{.start_freq = 2402, .end_freq = 2494 },\n\t{.start_freq = 5170, .end_freq = 5875 },\n};\n\nstatic const struct cfg80211_sar_capa ath10k_sar_capa = {\n\t.type = NL80211_SAR_TYPE_POWER,\n\t.num_freq_ranges = (ARRAY_SIZE(ath10k_sar_freq_ranges)),\n\t.freq_ranges = &ath10k_sar_freq_ranges[0],\n};\n\n#define ATH10K_MAC_FIRST_OFDM_RATE_IDX 4\n\n#define ath10k_a_rates (ath10k_rates + ATH10K_MAC_FIRST_OFDM_RATE_IDX)\n#define ath10k_a_rates_size (ARRAY_SIZE(ath10k_rates) - \\\n\t\t\t     ATH10K_MAC_FIRST_OFDM_RATE_IDX)\n#define ath10k_g_rates (ath10k_rates + 0)\n#define ath10k_g_rates_size (ARRAY_SIZE(ath10k_rates))\n\n#define ath10k_g_rates_rev2 (ath10k_rates_rev2 + 0)\n#define ath10k_g_rates_rev2_size (ARRAY_SIZE(ath10k_rates_rev2))\n\n#define ath10k_wmi_legacy_rates ath10k_rates\n\nstatic bool ath10k_mac_bitrate_is_cck(int bitrate)\n{\n\tswitch (bitrate) {\n\tcase 10:\n\tcase 20:\n\tcase 55:\n\tcase 110:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic u8 ath10k_mac_bitrate_to_rate(int bitrate)\n{\n\treturn DIV_ROUND_UP(bitrate, 5) |\n\t       (ath10k_mac_bitrate_is_cck(bitrate) ? BIT(7) : 0);\n}\n\nu8 ath10k_mac_hw_rate_to_idx(const struct ieee80211_supported_band *sband,\n\t\t\t     u8 hw_rate, bool cck)\n{\n\tconst struct ieee80211_rate *rate;\n\tint i;\n\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\trate = &sband->bitrates[i];\n\n\t\tif (ath10k_mac_bitrate_is_cck(rate->bitrate) != cck)\n\t\t\tcontinue;\n\n\t\tif (rate->hw_value == hw_rate)\n\t\t\treturn i;\n\t\telse if (rate->flags & IEEE80211_RATE_SHORT_PREAMBLE &&\n\t\t\t rate->hw_value_short == hw_rate)\n\t\t\treturn i;\n\t}\n\n\treturn 0;\n}\n\nu8 ath10k_mac_bitrate_to_idx(const struct ieee80211_supported_band *sband,\n\t\t\t     u32 bitrate)\n{\n\tint i;\n\n\tfor (i = 0; i < sband->n_bitrates; i++)\n\t\tif (sband->bitrates[i].bitrate == bitrate)\n\t\t\treturn i;\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_get_rate_hw_value(int bitrate)\n{\n\tint i;\n\tu8 hw_value_prefix = 0;\n\n\tif (ath10k_mac_bitrate_is_cck(bitrate))\n\t\thw_value_prefix = WMI_RATE_PREAMBLE_CCK << 6;\n\n\tfor (i = 0; i < ARRAY_SIZE(ath10k_rates); i++) {\n\t\tif (ath10k_rates[i].bitrate == bitrate)\n\t\t\treturn hw_value_prefix | ath10k_rates[i].hw_value;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ath10k_mac_get_max_vht_mcs_map(u16 mcs_map, int nss)\n{\n\tswitch ((mcs_map >> (2 * nss)) & 0x3) {\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_7: return BIT(8) - 1;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_8: return BIT(9) - 1;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_9: return BIT(10) - 1;\n\t}\n\treturn 0;\n}\n\nstatic u32\nath10k_mac_max_ht_nss(const u8 ht_mcs_mask[IEEE80211_HT_MCS_MASK_LEN])\n{\n\tint nss;\n\n\tfor (nss = IEEE80211_HT_MCS_MASK_LEN - 1; nss >= 0; nss--)\n\t\tif (ht_mcs_mask[nss])\n\t\t\treturn nss + 1;\n\n\treturn 1;\n}\n\nstatic u32\nath10k_mac_max_vht_nss(const u16 vht_mcs_mask[NL80211_VHT_NSS_MAX])\n{\n\tint nss;\n\n\tfor (nss = NL80211_VHT_NSS_MAX - 1; nss >= 0; nss--)\n\t\tif (vht_mcs_mask[nss])\n\t\t\treturn nss + 1;\n\n\treturn 1;\n}\n\nint ath10k_mac_ext_resource_config(struct ath10k *ar, u32 val)\n{\n\tenum wmi_host_platform_type platform_type;\n\tint ret;\n\n\tif (test_bit(WMI_SERVICE_TX_MODE_DYNAMIC, ar->wmi.svc_map))\n\t\tplatform_type = WMI_HOST_PLATFORM_LOW_PERF;\n\telse\n\t\tplatform_type = WMI_HOST_PLATFORM_HIGH_PERF;\n\n\tret = ath10k_wmi_ext_resource_config(ar, platform_type, val);\n\n\tif (ret && ret != -EOPNOTSUPP) {\n\t\tath10k_warn(ar, \"failed to configure ext resource: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n/**********/\n/* Crypto */\n/**********/\n\nstatic int ath10k_send_key(struct ath10k_vif *arvif,\n\t\t\t   struct ieee80211_key_conf *key,\n\t\t\t   enum set_key_cmd cmd,\n\t\t\t   const u8 *macaddr, u32 flags)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct wmi_vdev_install_key_arg arg = {\n\t\t.vdev_id = arvif->vdev_id,\n\t\t.key_idx = key->keyidx,\n\t\t.key_len = key->keylen,\n\t\t.key_data = key->key,\n\t\t.key_flags = flags,\n\t\t.macaddr = macaddr,\n\t};\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\targ.key_cipher = ar->wmi_key_cipher[WMI_CIPHER_AES_CCM];\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV_MGMT;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\targ.key_cipher = ar->wmi_key_cipher[WMI_CIPHER_TKIP];\n\t\targ.key_txmic_len = 8;\n\t\targ.key_rxmic_len = 8;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\targ.key_cipher = ar->wmi_key_cipher[WMI_CIPHER_WEP];\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\targ.key_cipher = ar->wmi_key_cipher[WMI_CIPHER_AES_CCM];\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\targ.key_cipher = ar->wmi_key_cipher[WMI_CIPHER_AES_GCM];\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV_MGMT;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\tdefault:\n\t\tath10k_warn(ar, \"cipher %d is not supported\\n\", key->cipher);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags))\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\n\tif (cmd == DISABLE_KEY) {\n\t\targ.key_cipher = ar->wmi_key_cipher[WMI_CIPHER_NONE];\n\t\targ.key_data = NULL;\n\t}\n\n\treturn ath10k_wmi_vdev_install_key(arvif->ar, &arg);\n}\n\nstatic int ath10k_install_key(struct ath10k_vif *arvif,\n\t\t\t      struct ieee80211_key_conf *key,\n\t\t\t      enum set_key_cmd cmd,\n\t\t\t      const u8 *macaddr, u32 flags)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tint ret;\n\tunsigned long time_left;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\treinit_completion(&ar->install_key_done);\n\n\tif (arvif->nohwcrypt)\n\t\treturn 1;\n\n\tret = ath10k_send_key(arvif, key, cmd, macaddr, flags);\n\tif (ret)\n\t\treturn ret;\n\n\ttime_left = wait_for_completion_timeout(&ar->install_key_done, 3 * HZ);\n\tif (time_left == 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int ath10k_install_peer_wep_keys(struct ath10k_vif *arvif,\n\t\t\t\t\tconst u8 *addr)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ath10k_peer *peer;\n\tint ret;\n\tint i;\n\tu32 flags;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (WARN_ON(arvif->vif->type != NL80211_IFTYPE_AP &&\n\t\t    arvif->vif->type != NL80211_IFTYPE_ADHOC &&\n\t\t    arvif->vif->type != NL80211_IFTYPE_MESH_POINT))\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&ar->data_lock);\n\tpeer = ath10k_peer_find(ar, arvif->vdev_id, addr);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (!peer)\n\t\treturn -ENOENT;\n\n\tfor (i = 0; i < ARRAY_SIZE(arvif->wep_keys); i++) {\n\t\tif (arvif->wep_keys[i] == NULL)\n\t\t\tcontinue;\n\n\t\tswitch (arvif->vif->type) {\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\tflags = WMI_KEY_PAIRWISE;\n\n\t\t\tif (arvif->def_wep_key_idx == i)\n\t\t\t\tflags |= WMI_KEY_TX_USAGE;\n\n\t\t\tret = ath10k_install_key(arvif, arvif->wep_keys[i],\n\t\t\t\t\t\t SET_KEY, addr, flags);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tret = ath10k_install_key(arvif, arvif->wep_keys[i],\n\t\t\t\t\t\t SET_KEY, addr,\n\t\t\t\t\t\t WMI_KEY_PAIRWISE);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tret = ath10k_install_key(arvif, arvif->wep_keys[i],\n\t\t\t\t\t\t SET_KEY, addr, WMI_KEY_GROUP);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tpeer->keys[i] = arvif->wep_keys[i];\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n\n\t/* In some cases (notably with static WEP IBSS with multiple keys)\n\t * multicast Tx becomes broken. Both pairwise and groupwise keys are\n\t * installed already. Using WMI_KEY_TX_USAGE in different combinations\n\t * didn't seem help. Using def_keyid vdev parameter seems to be\n\t * effective so use that.\n\t *\n\t * FIXME: Revisit. Perhaps this can be done in a less hacky way.\n\t */\n\tif (arvif->vif->type != NL80211_IFTYPE_ADHOC)\n\t\treturn 0;\n\n\tif (arvif->def_wep_key_idx == -1)\n\t\treturn 0;\n\n\tret = ath10k_wmi_vdev_set_param(arvif->ar,\n\t\t\t\t\tarvif->vdev_id,\n\t\t\t\t\tarvif->ar->wmi.vdev_param->def_keyid,\n\t\t\t\t\tarvif->def_wep_key_idx);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to re-set def wpa key idxon vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_clear_peer_keys(struct ath10k_vif *arvif,\n\t\t\t\t  const u8 *addr)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ath10k_peer *peer;\n\tint first_errno = 0;\n\tint ret;\n\tint i;\n\tu32 flags = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tpeer = ath10k_peer_find(ar, arvif->vdev_id, addr);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (!peer)\n\t\treturn -ENOENT;\n\n\tfor (i = 0; i < ARRAY_SIZE(peer->keys); i++) {\n\t\tif (peer->keys[i] == NULL)\n\t\t\tcontinue;\n\n\t\t/* key flags are not required to delete the key */\n\t\tret = ath10k_install_key(arvif, peer->keys[i],\n\t\t\t\t\t DISABLE_KEY, addr, flags);\n\t\tif (ret < 0 && first_errno == 0)\n\t\t\tfirst_errno = ret;\n\n\t\tif (ret < 0)\n\t\t\tath10k_warn(ar, \"failed to remove peer wep key %d: %d\\n\",\n\t\t\t\t    i, ret);\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tpeer->keys[i] = NULL;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n\n\treturn first_errno;\n}\n\nbool ath10k_mac_is_peer_wep_key_set(struct ath10k *ar, const u8 *addr,\n\t\t\t\t    u8 keyidx)\n{\n\tstruct ath10k_peer *peer;\n\tint i;\n\n\tlockdep_assert_held(&ar->data_lock);\n\n\t/* We don't know which vdev this peer belongs to,\n\t * since WMI doesn't give us that information.\n\t *\n\t * FIXME: multi-bss needs to be handled.\n\t */\n\tpeer = ath10k_peer_find(ar, 0, addr);\n\tif (!peer)\n\t\treturn false;\n\n\tfor (i = 0; i < ARRAY_SIZE(peer->keys); i++) {\n\t\tif (peer->keys[i] && peer->keys[i]->keyidx == keyidx)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int ath10k_clear_vdev_key(struct ath10k_vif *arvif,\n\t\t\t\t struct ieee80211_key_conf *key)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ath10k_peer *peer;\n\tu8 addr[ETH_ALEN];\n\tint first_errno = 0;\n\tint ret;\n\tint i;\n\tu32 flags = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tfor (;;) {\n\t\t/* since ath10k_install_key we can't hold data_lock all the\n\t\t * time, so we try to remove the keys incrementally\n\t\t */\n\t\tspin_lock_bh(&ar->data_lock);\n\t\ti = 0;\n\t\tlist_for_each_entry(peer, &ar->peers, list) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(peer->keys); i++) {\n\t\t\t\tif (peer->keys[i] == key) {\n\t\t\t\t\tether_addr_copy(addr, peer->addr);\n\t\t\t\t\tpeer->keys[i] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i < ARRAY_SIZE(peer->keys))\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_bh(&ar->data_lock);\n\n\t\tif (i == ARRAY_SIZE(peer->keys))\n\t\t\tbreak;\n\t\t/* key flags are not required to delete the key */\n\t\tret = ath10k_install_key(arvif, key, DISABLE_KEY, addr, flags);\n\t\tif (ret < 0 && first_errno == 0)\n\t\t\tfirst_errno = ret;\n\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to remove key for %pM: %d\\n\",\n\t\t\t\t    addr, ret);\n\t}\n\n\treturn first_errno;\n}\n\nstatic int ath10k_mac_vif_update_wep_key(struct ath10k_vif *arvif,\n\t\t\t\t\t struct ieee80211_key_conf *key)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ath10k_peer *peer;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(peer, &ar->peers, list) {\n\t\tif (ether_addr_equal(peer->addr, arvif->vif->addr))\n\t\t\tcontinue;\n\n\t\tif (ether_addr_equal(peer->addr, arvif->bssid))\n\t\t\tcontinue;\n\n\t\tif (peer->keys[key->keyidx] == key)\n\t\t\tcontinue;\n\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vif vdev %i update key %i needs update\\n\",\n\t\t\t   arvif->vdev_id, key->keyidx);\n\n\t\tret = ath10k_install_peer_wep_keys(arvif, peer->addr);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to update wep keys on vdev %i for peer %pM: %d\\n\",\n\t\t\t\t    arvif->vdev_id, peer->addr, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*********************/\n/* General utilities */\n/*********************/\n\nstatic inline enum wmi_phy_mode\nchan_to_phymode(const struct cfg80211_chan_def *chandef)\n{\n\tenum wmi_phy_mode phymode = MODE_UNKNOWN;\n\n\tswitch (chandef->chan->band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tswitch (chandef->width) {\n\t\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\t\tif (chandef->chan->flags & IEEE80211_CHAN_NO_OFDM)\n\t\t\t\tphymode = MODE_11B;\n\t\t\telse\n\t\t\t\tphymode = MODE_11G;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_20:\n\t\t\tphymode = MODE_11NG_HT20;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_40:\n\t\t\tphymode = MODE_11NG_HT40;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphymode = MODE_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tswitch (chandef->width) {\n\t\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\t\tphymode = MODE_11A;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_20:\n\t\t\tphymode = MODE_11NA_HT20;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_40:\n\t\t\tphymode = MODE_11NA_HT40;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_80:\n\t\t\tphymode = MODE_11AC_VHT80;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_160:\n\t\t\tphymode = MODE_11AC_VHT160;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_80P80:\n\t\t\tphymode = MODE_11AC_VHT80_80;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphymode = MODE_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tWARN_ON(phymode == MODE_UNKNOWN);\n\treturn phymode;\n}\n\nstatic u8 ath10k_parse_mpdudensity(u8 mpdudensity)\n{\n/*\n * 802.11n D2.0 defined values for \"Minimum MPDU Start Spacing\":\n *   0 for no restriction\n *   1 for 1/4 us\n *   2 for 1/2 us\n *   3 for 1 us\n *   4 for 2 us\n *   5 for 4 us\n *   6 for 8 us\n *   7 for 16 us\n */\n\tswitch (mpdudensity) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\t/* Our lower layer calculations limit our precision to\n\t * 1 microsecond\n\t */\n\t\treturn 1;\n\tcase 4:\n\t\treturn 2;\n\tcase 5:\n\t\treturn 4;\n\tcase 6:\n\t\treturn 8;\n\tcase 7:\n\t\treturn 16;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint ath10k_mac_vif_chan(struct ieee80211_vif *vif,\n\t\t\tstruct cfg80211_chan_def *def)\n{\n\tstruct ieee80211_chanctx_conf *conf;\n\n\trcu_read_lock();\n\tconf = rcu_dereference(vif->chanctx_conf);\n\tif (!conf) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t*def = conf->def;\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic void ath10k_mac_num_chanctxs_iter(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_chanctx_conf *conf,\n\t\t\t\t\t void *data)\n{\n\tint *num = data;\n\n\t(*num)++;\n}\n\nstatic int ath10k_mac_num_chanctxs(struct ath10k *ar)\n{\n\tint num = 0;\n\n\tieee80211_iter_chan_contexts_atomic(ar->hw,\n\t\t\t\t\t    ath10k_mac_num_chanctxs_iter,\n\t\t\t\t\t    &num);\n\n\treturn num;\n}\n\nstatic void\nath10k_mac_get_any_chandef_iter(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_chanctx_conf *conf,\n\t\t\t\tvoid *data)\n{\n\tstruct cfg80211_chan_def **def = data;\n\n\t*def = &conf->def;\n}\n\nstatic void ath10k_wait_for_peer_delete_done(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t\t     const u8 *addr)\n{\n\tunsigned long time_left;\n\tint ret;\n\n\tif (test_bit(WMI_SERVICE_SYNC_DELETE_CMDS, ar->wmi.svc_map)) {\n\t\tret = ath10k_wait_for_peer_deleted(ar, vdev_id, addr);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed wait for peer deleted\");\n\t\t\treturn;\n\t\t}\n\n\t\ttime_left = wait_for_completion_timeout(&ar->peer_delete_done,\n\t\t\t\t\t\t\t5 * HZ);\n\t\tif (!time_left)\n\t\t\tath10k_warn(ar, \"Timeout in receiving peer delete response\\n\");\n\t}\n}\n\nstatic int ath10k_peer_create(struct ath10k *ar,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      u32 vdev_id,\n\t\t\t      const u8 *addr,\n\t\t\t      enum wmi_peer_type peer_type)\n{\n\tstruct ath10k_vif *arvif;\n\tstruct ath10k_peer *peer;\n\tint num_peers = 0;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tnum_peers = ar->num_peers;\n\n\t/* Each vdev consumes a peer entry as well */\n\tlist_for_each_entry(arvif, &ar->arvifs, list)\n\t\tnum_peers++;\n\n\tif (num_peers >= ar->max_num_peers)\n\t\treturn -ENOBUFS;\n\n\tret = ath10k_wmi_peer_create(ar, vdev_id, addr, peer_type);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to create wmi peer %pM on vdev %i: %i\\n\",\n\t\t\t    addr, vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_wait_for_peer_created(ar, vdev_id, addr);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to wait for created wmi peer %pM on vdev %i: %i\\n\",\n\t\t\t    addr, vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tpeer = ath10k_peer_find(ar, vdev_id, addr);\n\tif (!peer) {\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\tath10k_warn(ar, \"failed to find peer %pM on vdev %i after creation\\n\",\n\t\t\t    addr, vdev_id);\n\t\tath10k_wait_for_peer_delete_done(ar, vdev_id, addr);\n\t\treturn -ENOENT;\n\t}\n\n\tpeer->vif = vif;\n\tpeer->sta = sta;\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\tar->num_peers++;\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_set_kickout(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tu32 param;\n\tint ret;\n\n\tparam = ar->wmi.pdev_param->sta_kickout_th;\n\tret = ath10k_wmi_pdev_set_param(ar, param,\n\t\t\t\t\tATH10K_KICKOUT_THRESHOLD);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set kickout threshold on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tparam = ar->wmi.vdev_param->ap_keepalive_min_idle_inactive_time_secs;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, param,\n\t\t\t\t\tATH10K_KEEPALIVE_MIN_IDLE);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set keepalive minimum idle time on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tparam = ar->wmi.vdev_param->ap_keepalive_max_idle_inactive_time_secs;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, param,\n\t\t\t\t\tATH10K_KEEPALIVE_MAX_IDLE);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set keepalive maximum idle time on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tparam = ar->wmi.vdev_param->ap_keepalive_max_unresponsive_time_secs;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, param,\n\t\t\t\t\tATH10K_KEEPALIVE_MAX_UNRESPONSIVE);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set keepalive maximum unresponsive time on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_set_rts(struct ath10k_vif *arvif, u32 value)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tu32 vdev_param;\n\n\tvdev_param = ar->wmi.vdev_param->rts_threshold;\n\treturn ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param, value);\n}\n\nstatic int ath10k_peer_delete(struct ath10k *ar, u32 vdev_id, const u8 *addr)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_wmi_peer_delete(ar, vdev_id, addr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath10k_wait_for_peer_deleted(ar, vdev_id, addr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (test_bit(WMI_SERVICE_SYNC_DELETE_CMDS, ar->wmi.svc_map)) {\n\t\tunsigned long time_left;\n\n\t\ttime_left = wait_for_completion_timeout\n\t\t\t    (&ar->peer_delete_done, 5 * HZ);\n\n\t\tif (!time_left) {\n\t\t\tath10k_warn(ar, \"Timeout in receiving peer delete response\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\tar->num_peers--;\n\n\treturn 0;\n}\n\nstatic void ath10k_peer_cleanup(struct ath10k *ar, u32 vdev_id)\n{\n\tstruct ath10k_peer *peer, *tmp;\n\tint peer_id;\n\tint i;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tlist_for_each_entry_safe(peer, tmp, &ar->peers, list) {\n\t\tif (peer->vdev_id != vdev_id)\n\t\t\tcontinue;\n\n\t\tath10k_warn(ar, \"removing stale peer %pM from vdev_id %d\\n\",\n\t\t\t    peer->addr, vdev_id);\n\n\t\tfor_each_set_bit(peer_id, peer->peer_ids,\n\t\t\t\t ATH10K_MAX_NUM_PEER_IDS) {\n\t\t\tar->peer_map[peer_id] = NULL;\n\t\t}\n\n\t\t/* Double check that peer is properly un-referenced from\n\t\t * the peer_map\n\t\t */\n\t\tfor (i = 0; i < ARRAY_SIZE(ar->peer_map); i++) {\n\t\t\tif (ar->peer_map[i] == peer) {\n\t\t\t\tath10k_warn(ar, \"removing stale peer_map entry for %pM (ptr %pK idx %d)\\n\",\n\t\t\t\t\t    peer->addr, peer, i);\n\t\t\t\tar->peer_map[i] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tlist_del(&peer->list);\n\t\tkfree(peer);\n\t\tar->num_peers--;\n\t}\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nstatic void ath10k_peer_cleanup_all(struct ath10k *ar)\n{\n\tstruct ath10k_peer *peer, *tmp;\n\tint i;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tlist_for_each_entry_safe(peer, tmp, &ar->peers, list) {\n\t\tlist_del(&peer->list);\n\t\tkfree(peer);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ar->peer_map); i++)\n\t\tar->peer_map[i] = NULL;\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\tar->num_peers = 0;\n\tar->num_stations = 0;\n}\n\nstatic int ath10k_mac_tdls_peer_update(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t       struct ieee80211_sta *sta,\n\t\t\t\t       enum wmi_tdls_peer_state state)\n{\n\tint ret;\n\tstruct wmi_tdls_peer_update_cmd_arg arg = {};\n\tstruct wmi_tdls_peer_capab_arg cap = {};\n\tstruct wmi_channel_arg chan_arg = {};\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\targ.vdev_id = vdev_id;\n\targ.peer_state = state;\n\tether_addr_copy(arg.addr, sta->addr);\n\n\tcap.peer_max_sp = sta->max_sp;\n\tcap.peer_uapsd_queues = sta->uapsd_queues;\n\n\tif (state == WMI_TDLS_PEER_STATE_CONNECTED &&\n\t    !sta->tdls_initiator)\n\t\tcap.is_peer_responder = 1;\n\n\tret = ath10k_wmi_tdls_peer_update(ar, &arg, &cap, &chan_arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to update tdls peer %pM on vdev %i: %i\\n\",\n\t\t\t    arg.addr, vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n/************************/\n/* Interface management */\n/************************/\n\nvoid ath10k_mac_vif_beacon_free(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->data_lock);\n\n\tif (!arvif->beacon)\n\t\treturn;\n\n\tif (!arvif->beacon_buf)\n\t\tdma_unmap_single(ar->dev, ATH10K_SKB_CB(arvif->beacon)->paddr,\n\t\t\t\t arvif->beacon->len, DMA_TO_DEVICE);\n\n\tif (WARN_ON(arvif->beacon_state != ATH10K_BEACON_SCHEDULED &&\n\t\t    arvif->beacon_state != ATH10K_BEACON_SENT))\n\t\treturn;\n\n\tdev_kfree_skb_any(arvif->beacon);\n\n\tarvif->beacon = NULL;\n\tarvif->beacon_state = ATH10K_BEACON_SCHEDULED;\n}\n\nstatic void ath10k_mac_vif_beacon_cleanup(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->data_lock);\n\n\tath10k_mac_vif_beacon_free(arvif);\n\n\tif (arvif->beacon_buf) {\n\t\tdma_free_coherent(ar->dev, IEEE80211_MAX_FRAME_LEN,\n\t\t\t\t  arvif->beacon_buf, arvif->beacon_paddr);\n\t\tarvif->beacon_buf = NULL;\n\t}\n}\n\nstatic inline int ath10k_vdev_setup_sync(struct ath10k *ar)\n{\n\tunsigned long time_left;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (test_bit(ATH10K_FLAG_CRASH_FLUSH, &ar->dev_flags))\n\t\treturn -ESHUTDOWN;\n\n\ttime_left = wait_for_completion_timeout(&ar->vdev_setup_done,\n\t\t\t\t\t\tATH10K_VDEV_SETUP_TIMEOUT_HZ);\n\tif (time_left == 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn ar->last_wmi_vdev_start_status;\n}\n\nstatic int ath10k_monitor_vdev_start(struct ath10k *ar, int vdev_id)\n{\n\tstruct cfg80211_chan_def *chandef = NULL;\n\tstruct ieee80211_channel *channel = NULL;\n\tstruct wmi_vdev_start_request_arg arg = {};\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tieee80211_iter_chan_contexts_atomic(ar->hw,\n\t\t\t\t\t    ath10k_mac_get_any_chandef_iter,\n\t\t\t\t\t    &chandef);\n\tif (WARN_ON_ONCE(!chandef))\n\t\treturn -ENOENT;\n\n\tchannel = chandef->chan;\n\n\targ.vdev_id = vdev_id;\n\targ.channel.freq = channel->center_freq;\n\targ.channel.band_center_freq1 = chandef->center_freq1;\n\targ.channel.band_center_freq2 = chandef->center_freq2;\n\n\t/* TODO setup this dynamically, what in case we\n\t * don't have any vifs?\n\t */\n\targ.channel.mode = chan_to_phymode(chandef);\n\targ.channel.chan_radar =\n\t\t\t!!(channel->flags & IEEE80211_CHAN_RADAR);\n\n\targ.channel.min_power = 0;\n\targ.channel.max_power = channel->max_power * 2;\n\targ.channel.max_reg_power = channel->max_reg_power * 2;\n\targ.channel.max_antenna_gain = channel->max_antenna_gain * 2;\n\n\treinit_completion(&ar->vdev_setup_done);\n\treinit_completion(&ar->vdev_delete_done);\n\n\tret = ath10k_wmi_vdev_start(ar, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to request monitor vdev %i start: %d\\n\",\n\t\t\t    vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_vdev_setup_sync(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to synchronize setup for monitor vdev %i start: %d\\n\",\n\t\t\t    vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_wmi_vdev_up(ar, vdev_id, 0, ar->mac_addr);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to put up monitor vdev %i: %d\\n\",\n\t\t\t    vdev_id, ret);\n\t\tgoto vdev_stop;\n\t}\n\n\tar->monitor_vdev_id = vdev_id;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac monitor vdev %i started\\n\",\n\t\t   ar->monitor_vdev_id);\n\treturn 0;\n\nvdev_stop:\n\tret = ath10k_wmi_vdev_stop(ar, ar->monitor_vdev_id);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to stop monitor vdev %i after start failure: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\n\treturn ret;\n}\n\nstatic int ath10k_monitor_vdev_stop(struct ath10k *ar)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_wmi_vdev_down(ar, ar->monitor_vdev_id);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to put down monitor vdev %i: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\n\treinit_completion(&ar->vdev_setup_done);\n\treinit_completion(&ar->vdev_delete_done);\n\n\tret = ath10k_wmi_vdev_stop(ar, ar->monitor_vdev_id);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to request monitor vdev %i stop: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\n\tret = ath10k_vdev_setup_sync(ar);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to synchronize monitor vdev %i stop: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac monitor vdev %i stopped\\n\",\n\t\t   ar->monitor_vdev_id);\n\treturn ret;\n}\n\nstatic int ath10k_monitor_vdev_create(struct ath10k *ar)\n{\n\tint bit, ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (ar->free_vdev_map == 0) {\n\t\tath10k_warn(ar, \"failed to find free vdev id for monitor vdev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbit = __ffs64(ar->free_vdev_map);\n\n\tar->monitor_vdev_id = bit;\n\n\tret = ath10k_wmi_vdev_create(ar, ar->monitor_vdev_id,\n\t\t\t\t     WMI_VDEV_TYPE_MONITOR,\n\t\t\t\t     0, ar->mac_addr);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to request monitor vdev %i creation: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tar->free_vdev_map &= ~(1LL << ar->monitor_vdev_id);\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac monitor vdev %d created\\n\",\n\t\t   ar->monitor_vdev_id);\n\n\treturn 0;\n}\n\nstatic int ath10k_monitor_vdev_delete(struct ath10k *ar)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_wmi_vdev_delete(ar, ar->monitor_vdev_id);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to request wmi monitor vdev %i removal: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tar->free_vdev_map |= 1LL << ar->monitor_vdev_id;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac monitor vdev %d deleted\\n\",\n\t\t   ar->monitor_vdev_id);\n\treturn ret;\n}\n\nstatic int ath10k_monitor_start(struct ath10k *ar)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_monitor_vdev_create(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to create monitor vdev: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_monitor_vdev_start(ar, ar->monitor_vdev_id);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to start monitor vdev: %d\\n\", ret);\n\t\tath10k_monitor_vdev_delete(ar);\n\t\treturn ret;\n\t}\n\n\tar->monitor_started = true;\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac monitor started\\n\");\n\n\treturn 0;\n}\n\nstatic int ath10k_monitor_stop(struct ath10k *ar)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_monitor_vdev_stop(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to stop monitor vdev: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_monitor_vdev_delete(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to delete monitor vdev: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tar->monitor_started = false;\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac monitor stopped\\n\");\n\n\treturn 0;\n}\n\nstatic bool ath10k_mac_monitor_vdev_is_needed(struct ath10k *ar)\n{\n\tint num_ctx;\n\n\t/* At least one chanctx is required to derive a channel to start\n\t * monitor vdev on.\n\t */\n\tnum_ctx = ath10k_mac_num_chanctxs(ar);\n\tif (num_ctx == 0)\n\t\treturn false;\n\n\t/* If there's already an existing special monitor interface then don't\n\t * bother creating another monitor vdev.\n\t */\n\tif (ar->monitor_arvif)\n\t\treturn false;\n\n\treturn ar->monitor ||\n\t       (!test_bit(ATH10K_FW_FEATURE_ALLOWS_MESH_BCAST,\n\t\t\t  ar->running_fw->fw_file.fw_features) &&\n\t\t(ar->filter_flags & FIF_OTHER_BSS)) ||\n\t       test_bit(ATH10K_CAC_RUNNING, &ar->dev_flags);\n}\n\nstatic bool ath10k_mac_monitor_vdev_is_allowed(struct ath10k *ar)\n{\n\tint num_ctx;\n\n\tnum_ctx = ath10k_mac_num_chanctxs(ar);\n\n\t/* FIXME: Current interface combinations and cfg80211/mac80211 code\n\t * shouldn't allow this but make sure to prevent handling the following\n\t * case anyway since multi-channel DFS hasn't been tested at all.\n\t */\n\tif (test_bit(ATH10K_CAC_RUNNING, &ar->dev_flags) && num_ctx > 1)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int ath10k_monitor_recalc(struct ath10k *ar)\n{\n\tbool needed;\n\tbool allowed;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tneeded = ath10k_mac_monitor_vdev_is_needed(ar);\n\tallowed = ath10k_mac_monitor_vdev_is_allowed(ar);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac monitor recalc started? %d needed? %d allowed? %d\\n\",\n\t\t   ar->monitor_started, needed, allowed);\n\n\tif (WARN_ON(needed && !allowed)) {\n\t\tif (ar->monitor_started) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac monitor stopping disallowed monitor\\n\");\n\n\t\t\tret = ath10k_monitor_stop(ar);\n\t\t\tif (ret)\n\t\t\t\tath10k_warn(ar, \"failed to stop disallowed monitor: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\t/* not serious */\n\t\t}\n\n\t\treturn -EPERM;\n\t}\n\n\tif (needed == ar->monitor_started)\n\t\treturn 0;\n\n\tif (needed)\n\t\treturn ath10k_monitor_start(ar);\n\telse\n\t\treturn ath10k_monitor_stop(ar);\n}\n\nstatic bool ath10k_mac_can_set_cts_prot(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (!arvif->is_started) {\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"defer cts setup, vdev is not ready yet\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int ath10k_mac_set_cts_prot(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tu32 vdev_param;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tvdev_param = ar->wmi.vdev_param->protection_mode;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %d cts_protection %d\\n\",\n\t\t   arvif->vdev_id, arvif->use_cts_prot);\n\n\treturn ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t arvif->use_cts_prot ? 1 : 0);\n}\n\nstatic int ath10k_recalc_rtscts_prot(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tu32 vdev_param, rts_cts = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tvdev_param = ar->wmi.vdev_param->enable_rtscts;\n\n\trts_cts |= SM(WMI_RTSCTS_ENABLED, WMI_RTSCTS_SET);\n\n\tif (arvif->num_legacy_stations > 0)\n\t\trts_cts |= SM(WMI_RTSCTS_ACROSS_SW_RETRIES,\n\t\t\t      WMI_RTSCTS_PROFILE);\n\telse\n\t\trts_cts |= SM(WMI_RTSCTS_FOR_SECOND_RATESERIES,\n\t\t\t      WMI_RTSCTS_PROFILE);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %d recalc rts/cts prot %d\\n\",\n\t\t   arvif->vdev_id, rts_cts);\n\n\treturn ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t rts_cts);\n}\n\nstatic int ath10k_start_cac(struct ath10k *ar)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tset_bit(ATH10K_CAC_RUNNING, &ar->dev_flags);\n\n\tret = ath10k_monitor_recalc(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to start monitor (cac): %d\\n\", ret);\n\t\tclear_bit(ATH10K_CAC_RUNNING, &ar->dev_flags);\n\t\treturn ret;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac cac start monitor vdev %d\\n\",\n\t\t   ar->monitor_vdev_id);\n\n\treturn 0;\n}\n\nstatic int ath10k_stop_cac(struct ath10k *ar)\n{\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\t/* CAC is not running - do nothing */\n\tif (!test_bit(ATH10K_CAC_RUNNING, &ar->dev_flags))\n\t\treturn 0;\n\n\tclear_bit(ATH10K_CAC_RUNNING, &ar->dev_flags);\n\tath10k_monitor_stop(ar);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac cac finished\\n\");\n\n\treturn 0;\n}\n\nstatic void ath10k_mac_has_radar_iter(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_chanctx_conf *conf,\n\t\t\t\t      void *data)\n{\n\tbool *ret = data;\n\n\tif (!*ret && conf->radar_enabled)\n\t\t*ret = true;\n}\n\nstatic bool ath10k_mac_has_radar_enabled(struct ath10k *ar)\n{\n\tbool has_radar = false;\n\n\tieee80211_iter_chan_contexts_atomic(ar->hw,\n\t\t\t\t\t    ath10k_mac_has_radar_iter,\n\t\t\t\t\t    &has_radar);\n\n\treturn has_radar;\n}\n\nstatic void ath10k_recalc_radar_detection(struct ath10k *ar)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tath10k_stop_cac(ar);\n\n\tif (!ath10k_mac_has_radar_enabled(ar))\n\t\treturn;\n\n\tif (ar->num_started_vdevs > 0)\n\t\treturn;\n\n\tret = ath10k_start_cac(ar);\n\tif (ret) {\n\t\t/*\n\t\t * Not possible to start CAC on current channel so starting\n\t\t * radiation is not allowed, make this channel DFS_UNAVAILABLE\n\t\t * by indicating that radar was detected.\n\t\t */\n\t\tath10k_warn(ar, \"failed to start CAC: %d\\n\", ret);\n\t\tieee80211_radar_detected(ar->hw);\n\t}\n}\n\nstatic int ath10k_vdev_stop(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\treinit_completion(&ar->vdev_setup_done);\n\treinit_completion(&ar->vdev_delete_done);\n\n\tret = ath10k_wmi_vdev_stop(ar, arvif->vdev_id);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to stop WMI vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_vdev_setup_sync(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to synchronize setup for vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tWARN_ON(ar->num_started_vdevs == 0);\n\n\tif (ar->num_started_vdevs != 0) {\n\t\tar->num_started_vdevs--;\n\t\tath10k_recalc_radar_detection(ar);\n\t}\n\n\treturn ret;\n}\n\nstatic int ath10k_vdev_start_restart(struct ath10k_vif *arvif,\n\t\t\t\t     const struct cfg80211_chan_def *chandef,\n\t\t\t\t     bool restart)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct wmi_vdev_start_request_arg arg = {};\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\treinit_completion(&ar->vdev_setup_done);\n\treinit_completion(&ar->vdev_delete_done);\n\n\targ.vdev_id = arvif->vdev_id;\n\targ.dtim_period = arvif->dtim_period;\n\targ.bcn_intval = arvif->beacon_interval;\n\n\targ.channel.freq = chandef->chan->center_freq;\n\targ.channel.band_center_freq1 = chandef->center_freq1;\n\targ.channel.band_center_freq2 = chandef->center_freq2;\n\targ.channel.mode = chan_to_phymode(chandef);\n\n\targ.channel.min_power = 0;\n\targ.channel.max_power = chandef->chan->max_power * 2;\n\targ.channel.max_reg_power = chandef->chan->max_reg_power * 2;\n\targ.channel.max_antenna_gain = chandef->chan->max_antenna_gain * 2;\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_AP) {\n\t\targ.ssid = arvif->u.ap.ssid;\n\t\targ.ssid_len = arvif->u.ap.ssid_len;\n\t\targ.hidden_ssid = arvif->u.ap.hidden_ssid;\n\n\t\t/* For now allow DFS for AP mode */\n\t\targ.channel.chan_radar =\n\t\t\t!!(chandef->chan->flags & IEEE80211_CHAN_RADAR);\n\t} else if (arvif->vdev_type == WMI_VDEV_TYPE_IBSS) {\n\t\targ.ssid = arvif->vif->bss_conf.ssid;\n\t\targ.ssid_len = arvif->vif->bss_conf.ssid_len;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac vdev %d start center_freq %d phymode %s\\n\",\n\t\t   arg.vdev_id, arg.channel.freq,\n\t\t   ath10k_wmi_phymode_str(arg.channel.mode));\n\n\tif (restart)\n\t\tret = ath10k_wmi_vdev_restart(ar, &arg);\n\telse\n\t\tret = ath10k_wmi_vdev_start(ar, &arg);\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to start WMI vdev %i: %d\\n\",\n\t\t\t    arg.vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_vdev_setup_sync(ar);\n\tif (ret) {\n\t\tath10k_warn(ar,\n\t\t\t    \"failed to synchronize setup for vdev %i restart %d: %d\\n\",\n\t\t\t    arg.vdev_id, restart, ret);\n\t\treturn ret;\n\t}\n\n\tar->num_started_vdevs++;\n\tath10k_recalc_radar_detection(ar);\n\n\treturn ret;\n}\n\nstatic int ath10k_vdev_start(struct ath10k_vif *arvif,\n\t\t\t     const struct cfg80211_chan_def *def)\n{\n\treturn ath10k_vdev_start_restart(arvif, def, false);\n}\n\nstatic int ath10k_vdev_restart(struct ath10k_vif *arvif,\n\t\t\t       const struct cfg80211_chan_def *def)\n{\n\treturn ath10k_vdev_start_restart(arvif, def, true);\n}\n\nstatic int ath10k_mac_setup_bcn_p2p_ie(struct ath10k_vif *arvif,\n\t\t\t\t       struct sk_buff *bcn)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ieee80211_mgmt *mgmt;\n\tconst u8 *p2p_ie;\n\tint ret;\n\n\tif (arvif->vif->type != NL80211_IFTYPE_AP || !arvif->vif->p2p)\n\t\treturn 0;\n\n\tmgmt = (void *)bcn->data;\n\tp2p_ie = cfg80211_find_vendor_ie(WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P,\n\t\t\t\t\t mgmt->u.beacon.variable,\n\t\t\t\t\t bcn->len - (mgmt->u.beacon.variable -\n\t\t\t\t\t\t     bcn->data));\n\tif (!p2p_ie)\n\t\treturn -ENOENT;\n\n\tret = ath10k_wmi_p2p_go_bcn_ie(ar, arvif->vdev_id, p2p_ie);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to submit p2p go bcn ie for vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_remove_vendor_ie(struct sk_buff *skb, unsigned int oui,\n\t\t\t\t       u8 oui_type, size_t ie_offset)\n{\n\tsize_t len;\n\tconst u8 *next;\n\tconst u8 *end;\n\tu8 *ie;\n\n\tif (WARN_ON(skb->len < ie_offset))\n\t\treturn -EINVAL;\n\n\tie = (u8 *)cfg80211_find_vendor_ie(oui, oui_type,\n\t\t\t\t\t   skb->data + ie_offset,\n\t\t\t\t\t   skb->len - ie_offset);\n\tif (!ie)\n\t\treturn -ENOENT;\n\n\tlen = ie[1] + 2;\n\tend = skb->data + skb->len;\n\tnext = ie + len;\n\n\tif (WARN_ON(next > end))\n\t\treturn -EINVAL;\n\n\tmemmove(ie, next, end - next);\n\tskb_trim(skb, skb->len - len);\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_setup_bcn_tmpl(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ieee80211_hw *hw = ar->hw;\n\tstruct ieee80211_vif *vif = arvif->vif;\n\tstruct ieee80211_mutable_offsets offs = {};\n\tstruct sk_buff *bcn;\n\tint ret;\n\n\tif (!test_bit(WMI_SERVICE_BEACON_OFFLOAD, ar->wmi.svc_map))\n\t\treturn 0;\n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_AP &&\n\t    arvif->vdev_type != WMI_VDEV_TYPE_IBSS)\n\t\treturn 0;\n\n\tbcn = ieee80211_beacon_get_template(hw, vif, &offs);\n\tif (!bcn) {\n\t\tath10k_warn(ar, \"failed to get beacon template from mac80211\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tret = ath10k_mac_setup_bcn_p2p_ie(arvif, bcn);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to setup p2p go bcn ie: %d\\n\", ret);\n\t\tkfree_skb(bcn);\n\t\treturn ret;\n\t}\n\n\t/* P2P IE is inserted by firmware automatically (as configured above)\n\t * so remove it from the base beacon template to avoid duplicate P2P\n\t * IEs in beacon frames.\n\t */\n\tath10k_mac_remove_vendor_ie(bcn, WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P,\n\t\t\t\t    offsetof(struct ieee80211_mgmt,\n\t\t\t\t\t     u.beacon.variable));\n\n\tret = ath10k_wmi_bcn_tmpl(ar, arvif->vdev_id, offs.tim_offset, bcn, 0,\n\t\t\t\t  0, NULL, 0);\n\tkfree_skb(bcn);\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to submit beacon template command: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_setup_prb_tmpl(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ieee80211_hw *hw = ar->hw;\n\tstruct ieee80211_vif *vif = arvif->vif;\n\tstruct sk_buff *prb;\n\tint ret;\n\n\tif (!test_bit(WMI_SERVICE_BEACON_OFFLOAD, ar->wmi.svc_map))\n\t\treturn 0;\n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_AP)\n\t\treturn 0;\n\n\t /* For mesh, probe response and beacon share the same template */\n\tif (ieee80211_vif_is_mesh(vif))\n\t\treturn 0;\n\n\tprb = ieee80211_proberesp_get(hw, vif);\n\tif (!prb) {\n\t\tath10k_warn(ar, \"failed to get probe resp template from mac80211\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tret = ath10k_wmi_prb_tmpl(ar, arvif->vdev_id, prb);\n\tkfree_skb(prb);\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to submit probe resp template command: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_vif_fix_hidden_ssid(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct cfg80211_chan_def def;\n\tint ret;\n\n\t/* When originally vdev is started during assign_vif_chanctx() some\n\t * information is missing, notably SSID. Firmware revisions with beacon\n\t * offloading require the SSID to be provided during vdev (re)start to\n\t * handle hidden SSID properly.\n\t *\n\t * Vdev restart must be done after vdev has been both started and\n\t * upped. Otherwise some firmware revisions (at least 10.2) fail to\n\t * deliver vdev restart response event causing timeouts during vdev\n\t * syncing in ath10k.\n\t *\n\t * Note: The vdev down/up and template reinstallation could be skipped\n\t * since only wmi-tlv firmware are known to have beacon offload and\n\t * wmi-tlv doesn't seem to misbehave like 10.2 wrt vdev restart\n\t * response delivery. It's probably more robust to keep it as is.\n\t */\n\tif (!test_bit(WMI_SERVICE_BEACON_OFFLOAD, ar->wmi.svc_map))\n\t\treturn 0;\n\n\tif (WARN_ON(!arvif->is_started))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(!arvif->is_up))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(ath10k_mac_vif_chan(arvif->vif, &def)))\n\t\treturn -EINVAL;\n\n\tret = ath10k_wmi_vdev_down(ar, arvif->vdev_id);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to bring down ap vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\t/* Vdev down reset beacon & presp templates. Reinstall them. Otherwise\n\t * firmware will crash upon vdev up.\n\t */\n\n\tret = ath10k_mac_setup_bcn_tmpl(arvif);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to update beacon template: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_mac_setup_prb_tmpl(arvif);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to update presp template: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_vdev_restart(arvif, &def);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to restart ap vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_wmi_vdev_up(arvif->ar, arvif->vdev_id, arvif->aid,\n\t\t\t\t arvif->bssid);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to bring up ap vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath10k_control_beaconing(struct ath10k_vif *arvif,\n\t\t\t\t     struct ieee80211_bss_conf *info)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tint ret = 0;\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tif (!info->enable_beacon) {\n\t\tret = ath10k_wmi_vdev_down(ar, arvif->vdev_id);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to down vdev_id %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\n\t\tarvif->is_up = false;\n\n\t\tspin_lock_bh(&arvif->ar->data_lock);\n\t\tath10k_mac_vif_beacon_free(arvif);\n\t\tspin_unlock_bh(&arvif->ar->data_lock);\n\n\t\treturn;\n\t}\n\n\tarvif->tx_seq_no = 0x1000;\n\n\tarvif->aid = 0;\n\tether_addr_copy(arvif->bssid, info->bssid);\n\n\tret = ath10k_wmi_vdev_up(arvif->ar, arvif->vdev_id, arvif->aid,\n\t\t\t\t arvif->bssid);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to bring up vdev %d: %i\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn;\n\t}\n\n\tarvif->is_up = true;\n\n\tret = ath10k_mac_vif_fix_hidden_ssid(arvif);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to fix hidden ssid for vdev %i, expect trouble: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %d up\\n\", arvif->vdev_id);\n}\n\nstatic void ath10k_control_ibss(struct ath10k_vif *arvif,\n\t\t\t\tstruct ieee80211_bss_conf *info,\n\t\t\t\tconst u8 self_peer[ETH_ALEN])\n{\n\tstruct ath10k *ar = arvif->ar;\n\tu32 vdev_param;\n\tint ret = 0;\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tif (!info->ibss_joined) {\n\t\tif (is_zero_ether_addr(arvif->bssid))\n\t\t\treturn;\n\n\t\teth_zero_addr(arvif->bssid);\n\n\t\treturn;\n\t}\n\n\tvdev_param = arvif->ar->wmi.vdev_param->atim_window;\n\tret = ath10k_wmi_vdev_set_param(arvif->ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\tATH10K_DEFAULT_ATIM);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to set IBSS ATIM for vdev %d: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n}\n\nstatic int ath10k_mac_vif_recalc_ps_wake_threshold(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tu32 param;\n\tu32 value;\n\tint ret;\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tif (arvif->u.sta.uapsd)\n\t\tvalue = WMI_STA_PS_TX_WAKE_THRESHOLD_NEVER;\n\telse\n\t\tvalue = WMI_STA_PS_TX_WAKE_THRESHOLD_ALWAYS;\n\n\tparam = WMI_STA_PS_PARAM_TX_WAKE_THRESHOLD;\n\tret = ath10k_wmi_set_sta_ps_param(ar, arvif->vdev_id, param, value);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to submit ps wake threshold %u on vdev %i: %d\\n\",\n\t\t\t    value, arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_vif_recalc_ps_poll_count(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tu32 param;\n\tu32 value;\n\tint ret;\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tif (arvif->u.sta.uapsd)\n\t\tvalue = WMI_STA_PS_PSPOLL_COUNT_UAPSD;\n\telse\n\t\tvalue = WMI_STA_PS_PSPOLL_COUNT_NO_MAX;\n\n\tparam = WMI_STA_PS_PARAM_PSPOLL_COUNT;\n\tret = ath10k_wmi_set_sta_ps_param(ar, arvif->vdev_id,\n\t\t\t\t\t  param, value);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to submit ps poll count %u on vdev %i: %d\\n\",\n\t\t\t    value, arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_num_vifs_started(struct ath10k *ar)\n{\n\tstruct ath10k_vif *arvif;\n\tint num = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list)\n\t\tif (arvif->is_started)\n\t\t\tnum++;\n\n\treturn num;\n}\n\nstatic int ath10k_mac_vif_setup_ps(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ieee80211_vif *vif = arvif->vif;\n\tstruct ieee80211_conf *conf = &ar->hw->conf;\n\tenum wmi_sta_powersave_param param;\n\tenum wmi_sta_ps_mode psmode;\n\tint ret;\n\tint ps_timeout;\n\tbool enable_ps;\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tif (arvif->vif->type != NL80211_IFTYPE_STATION)\n\t\treturn 0;\n\n\tenable_ps = arvif->ps;\n\n\tif (enable_ps && ath10k_mac_num_vifs_started(ar) > 1 &&\n\t    !test_bit(ATH10K_FW_FEATURE_MULTI_VIF_PS_SUPPORT,\n\t\t      ar->running_fw->fw_file.fw_features)) {\n\t\tath10k_warn(ar, \"refusing to enable ps on vdev %i: not supported by fw\\n\",\n\t\t\t    arvif->vdev_id);\n\t\tenable_ps = false;\n\t}\n\n\tif (!arvif->is_started) {\n\t\t/* mac80211 can update vif powersave state while disconnected.\n\t\t * Firmware doesn't behave nicely and consumes more power than\n\t\t * necessary if PS is disabled on a non-started vdev. Hence\n\t\t * force-enable PS for non-running vdevs.\n\t\t */\n\t\tpsmode = WMI_STA_PS_MODE_ENABLED;\n\t} else if (enable_ps) {\n\t\tpsmode = WMI_STA_PS_MODE_ENABLED;\n\t\tparam = WMI_STA_PS_PARAM_INACTIVITY_TIME;\n\n\t\tps_timeout = conf->dynamic_ps_timeout;\n\t\tif (ps_timeout == 0) {\n\t\t\t/* Firmware doesn't like 0 */\n\t\t\tps_timeout = ieee80211_tu_to_usec(\n\t\t\t\tvif->bss_conf.beacon_int) / 1000;\n\t\t}\n\n\t\tret = ath10k_wmi_set_sta_ps_param(ar, arvif->vdev_id, param,\n\t\t\t\t\t\t  ps_timeout);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set inactivity time for vdev %d: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tpsmode = WMI_STA_PS_MODE_DISABLED;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %d psmode %s\\n\",\n\t\t   arvif->vdev_id, psmode ? \"enable\" : \"disable\");\n\n\tret = ath10k_wmi_set_psmode(ar, arvif->vdev_id, psmode);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set PS Mode %d for vdev %d: %d\\n\",\n\t\t\t    psmode, arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_vif_disable_keepalive(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct wmi_sta_keepalive_arg arg = {};\n\tint ret;\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_STA)\n\t\treturn 0;\n\n\tif (!test_bit(WMI_SERVICE_STA_KEEP_ALIVE, ar->wmi.svc_map))\n\t\treturn 0;\n\n\t/* Some firmware revisions have a bug and ignore the `enabled` field.\n\t * Instead use the interval to disable the keepalive.\n\t */\n\targ.vdev_id = arvif->vdev_id;\n\targ.enabled = 1;\n\targ.method = WMI_STA_KEEPALIVE_METHOD_NULL_FRAME;\n\targ.interval = WMI_STA_KEEPALIVE_INTERVAL_DISABLE;\n\n\tret = ath10k_wmi_sta_keepalive(ar, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to submit keepalive on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath10k_mac_vif_ap_csa_count_down(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ieee80211_vif *vif = arvif->vif;\n\tint ret;\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tif (WARN_ON(!test_bit(WMI_SERVICE_BEACON_OFFLOAD, ar->wmi.svc_map)))\n\t\treturn;\n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_AP)\n\t\treturn;\n\n\tif (!vif->csa_active)\n\t\treturn;\n\n\tif (!arvif->is_up)\n\t\treturn;\n\n\tif (!ieee80211_beacon_cntdwn_is_complete(vif)) {\n\t\tieee80211_beacon_update_cntdwn(vif);\n\n\t\tret = ath10k_mac_setup_bcn_tmpl(arvif);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to update bcn tmpl during csa: %d\\n\",\n\t\t\t\t    ret);\n\n\t\tret = ath10k_mac_setup_prb_tmpl(arvif);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to update prb tmpl during csa: %d\\n\",\n\t\t\t\t    ret);\n\t} else {\n\t\tieee80211_csa_finish(vif);\n\t}\n}\n\nstatic void ath10k_mac_vif_ap_csa_work(struct work_struct *work)\n{\n\tstruct ath10k_vif *arvif = container_of(work, struct ath10k_vif,\n\t\t\t\t\t\tap_csa_work);\n\tstruct ath10k *ar = arvif->ar;\n\n\tmutex_lock(&ar->conf_mutex);\n\tath10k_mac_vif_ap_csa_count_down(arvif);\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic void ath10k_mac_handle_beacon_iter(void *data, u8 *mac,\n\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct sk_buff *skb = data;\n\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tif (!ether_addr_equal(mgmt->bssid, vif->bss_conf.bssid))\n\t\treturn;\n\n\tcancel_delayed_work(&arvif->connection_loss_work);\n}\n\nvoid ath10k_mac_handle_beacon(struct ath10k *ar, struct sk_buff *skb)\n{\n\tieee80211_iterate_active_interfaces_atomic(ar->hw,\n\t\t\t\t\t\t   ATH10K_ITER_NORMAL_FLAGS,\n\t\t\t\t\t\t   ath10k_mac_handle_beacon_iter,\n\t\t\t\t\t\t   skb);\n}\n\nstatic void ath10k_mac_handle_beacon_miss_iter(void *data, u8 *mac,\n\t\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tu32 *vdev_id = data;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ieee80211_hw *hw = ar->hw;\n\n\tif (arvif->vdev_id != *vdev_id)\n\t\treturn;\n\n\tif (!arvif->is_up)\n\t\treturn;\n\n\tieee80211_beacon_loss(vif);\n\n\t/* Firmware doesn't report beacon loss events repeatedly. If AP probe\n\t * (done by mac80211) succeeds but beacons do not resume then it\n\t * doesn't make sense to continue operation. Queue connection loss work\n\t * which can be cancelled when beacon is received.\n\t */\n\tieee80211_queue_delayed_work(hw, &arvif->connection_loss_work,\n\t\t\t\t     ATH10K_CONNECTION_LOSS_HZ);\n}\n\nvoid ath10k_mac_handle_beacon_miss(struct ath10k *ar, u32 vdev_id)\n{\n\tieee80211_iterate_active_interfaces_atomic(ar->hw,\n\t\t\t\t\t\t   ATH10K_ITER_NORMAL_FLAGS,\n\t\t\t\t\t\t   ath10k_mac_handle_beacon_miss_iter,\n\t\t\t\t\t\t   &vdev_id);\n}\n\nstatic void ath10k_mac_vif_sta_connection_loss_work(struct work_struct *work)\n{\n\tstruct ath10k_vif *arvif = container_of(work, struct ath10k_vif,\n\t\t\t\t\t\tconnection_loss_work.work);\n\tstruct ieee80211_vif *vif = arvif->vif;\n\n\tif (!arvif->is_up)\n\t\treturn;\n\n\tieee80211_connection_loss(vif);\n}\n\n/**********************/\n/* Station management */\n/**********************/\n\nstatic u32 ath10k_peer_assoc_h_listen_intval(struct ath10k *ar,\n\t\t\t\t\t     struct ieee80211_vif *vif)\n{\n\t/* Some firmware revisions have unstable STA powersave when listen\n\t * interval is set too high (e.g. 5). The symptoms are firmware doesn't\n\t * generate NullFunc frames properly even if buffered frames have been\n\t * indicated in Beacon TIM. Firmware would seldom wake up to pull\n\t * buffered frames. Often pinging the device from AP would simply fail.\n\t *\n\t * As a workaround set it to 1.\n\t */\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\treturn 1;\n\n\treturn ar->hw->conf.listen_interval;\n}\n\nstatic void ath10k_peer_assoc_h_basic(struct ath10k *ar,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct wmi_peer_assoc_complete_arg *arg)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tu32 aid;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\taid = vif->bss_conf.aid;\n\telse\n\t\taid = sta->aid;\n\n\tether_addr_copy(arg->addr, sta->addr);\n\targ->vdev_id = arvif->vdev_id;\n\targ->peer_aid = aid;\n\targ->peer_flags |= arvif->ar->wmi.peer_flags->auth;\n\targ->peer_listen_intval = ath10k_peer_assoc_h_listen_intval(ar, vif);\n\targ->peer_num_spatial_streams = 1;\n\targ->peer_caps = vif->bss_conf.assoc_capability;\n}\n\nstatic void ath10k_peer_assoc_h_crypto(struct ath10k *ar,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_sta *sta,\n\t\t\t\t       struct wmi_peer_assoc_complete_arg *arg)\n{\n\tstruct ieee80211_bss_conf *info = &vif->bss_conf;\n\tstruct cfg80211_chan_def def;\n\tstruct cfg80211_bss *bss;\n\tconst u8 *rsnie = NULL;\n\tconst u8 *wpaie = NULL;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (WARN_ON(ath10k_mac_vif_chan(vif, &def)))\n\t\treturn;\n\n\tbss = cfg80211_get_bss(ar->hw->wiphy, def.chan, info->bssid,\n\t\t\t       info->ssid_len ? info->ssid : NULL, info->ssid_len,\n\t\t\t       IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);\n\tif (bss) {\n\t\tconst struct cfg80211_bss_ies *ies;\n\n\t\trcu_read_lock();\n\t\trsnie = ieee80211_bss_get_ie(bss, WLAN_EID_RSN);\n\n\t\ties = rcu_dereference(bss->ies);\n\n\t\twpaie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t\tWLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t\ties->data,\n\t\t\t\t\t\ties->len);\n\t\trcu_read_unlock();\n\t\tcfg80211_put_bss(ar->hw->wiphy, bss);\n\t}\n\n\t/* FIXME: base on RSN IE/WPA IE is a correct idea? */\n\tif (rsnie || wpaie) {\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI, \"%s: rsn ie found\\n\", __func__);\n\t\targ->peer_flags |= ar->wmi.peer_flags->need_ptk_4_way;\n\t}\n\n\tif (wpaie) {\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI, \"%s: wpa ie found\\n\", __func__);\n\t\targ->peer_flags |= ar->wmi.peer_flags->need_gtk_2_way;\n\t}\n\n\tif (sta->mfp &&\n\t    test_bit(ATH10K_FW_FEATURE_MFP_SUPPORT,\n\t\t     ar->running_fw->fw_file.fw_features)) {\n\t\targ->peer_flags |= ar->wmi.peer_flags->pmf;\n\t}\n}\n\nstatic void ath10k_peer_assoc_h_rates(struct ath10k *ar,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct wmi_peer_assoc_complete_arg *arg)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct wmi_rate_set_arg *rateset = &arg->peer_legacy_rates;\n\tstruct cfg80211_chan_def def;\n\tconst struct ieee80211_supported_band *sband;\n\tconst struct ieee80211_rate *rates;\n\tenum nl80211_band band;\n\tu32 ratemask;\n\tu8 rate;\n\tint i;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (WARN_ON(ath10k_mac_vif_chan(vif, &def)))\n\t\treturn;\n\n\tband = def.chan->band;\n\tsband = ar->hw->wiphy->bands[band];\n\tratemask = sta->supp_rates[band];\n\tratemask &= arvif->bitrate_mask.control[band].legacy;\n\trates = sband->bitrates;\n\n\trateset->num_rates = 0;\n\n\tfor (i = 0; i < 32; i++, ratemask >>= 1, rates++) {\n\t\tif (!(ratemask & 1))\n\t\t\tcontinue;\n\n\t\trate = ath10k_mac_bitrate_to_rate(rates->bitrate);\n\t\trateset->rates[rateset->num_rates] = rate;\n\t\trateset->num_rates++;\n\t}\n}\n\nstatic bool\nath10k_peer_assoc_h_ht_masked(const u8 ht_mcs_mask[IEEE80211_HT_MCS_MASK_LEN])\n{\n\tint nss;\n\n\tfor (nss = 0; nss < IEEE80211_HT_MCS_MASK_LEN; nss++)\n\t\tif (ht_mcs_mask[nss])\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nath10k_peer_assoc_h_vht_masked(const u16 vht_mcs_mask[NL80211_VHT_NSS_MAX])\n{\n\tint nss;\n\n\tfor (nss = 0; nss < NL80211_VHT_NSS_MAX; nss++)\n\t\tif (vht_mcs_mask[nss])\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic void ath10k_peer_assoc_h_ht(struct ath10k *ar,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   struct wmi_peer_assoc_complete_arg *arg)\n{\n\tconst struct ieee80211_sta_ht_cap *ht_cap = &sta->ht_cap;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct cfg80211_chan_def def;\n\tenum nl80211_band band;\n\tconst u8 *ht_mcs_mask;\n\tconst u16 *vht_mcs_mask;\n\tint i, n;\n\tu8 max_nss;\n\tu32 stbc;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (WARN_ON(ath10k_mac_vif_chan(vif, &def)))\n\t\treturn;\n\n\tif (!ht_cap->ht_supported)\n\t\treturn;\n\n\tband = def.chan->band;\n\tht_mcs_mask = arvif->bitrate_mask.control[band].ht_mcs;\n\tvht_mcs_mask = arvif->bitrate_mask.control[band].vht_mcs;\n\n\tif (ath10k_peer_assoc_h_ht_masked(ht_mcs_mask) &&\n\t    ath10k_peer_assoc_h_vht_masked(vht_mcs_mask))\n\t\treturn;\n\n\targ->peer_flags |= ar->wmi.peer_flags->ht;\n\targ->peer_max_mpdu = (1 << (IEEE80211_HT_MAX_AMPDU_FACTOR +\n\t\t\t\t    ht_cap->ampdu_factor)) - 1;\n\n\targ->peer_mpdu_density =\n\t\tath10k_parse_mpdudensity(ht_cap->ampdu_density);\n\n\targ->peer_ht_caps = ht_cap->cap;\n\targ->peer_rate_caps |= WMI_RC_HT_FLAG;\n\n\tif (ht_cap->cap & IEEE80211_HT_CAP_LDPC_CODING)\n\t\targ->peer_flags |= ar->wmi.peer_flags->ldbc;\n\n\tif (sta->bandwidth >= IEEE80211_STA_RX_BW_40) {\n\t\targ->peer_flags |= ar->wmi.peer_flags->bw40;\n\t\targ->peer_rate_caps |= WMI_RC_CW40_FLAG;\n\t}\n\n\tif (arvif->bitrate_mask.control[band].gi != NL80211_TXRATE_FORCE_LGI) {\n\t\tif (ht_cap->cap & IEEE80211_HT_CAP_SGI_20)\n\t\t\targ->peer_rate_caps |= WMI_RC_SGI_FLAG;\n\n\t\tif (ht_cap->cap & IEEE80211_HT_CAP_SGI_40)\n\t\t\targ->peer_rate_caps |= WMI_RC_SGI_FLAG;\n\t}\n\n\tif (ht_cap->cap & IEEE80211_HT_CAP_TX_STBC) {\n\t\targ->peer_rate_caps |= WMI_RC_TX_STBC_FLAG;\n\t\targ->peer_flags |= ar->wmi.peer_flags->stbc;\n\t}\n\n\tif (ht_cap->cap & IEEE80211_HT_CAP_RX_STBC) {\n\t\tstbc = ht_cap->cap & IEEE80211_HT_CAP_RX_STBC;\n\t\tstbc = stbc >> IEEE80211_HT_CAP_RX_STBC_SHIFT;\n\t\tstbc = stbc << WMI_RC_RX_STBC_FLAG_S;\n\t\targ->peer_rate_caps |= stbc;\n\t\targ->peer_flags |= ar->wmi.peer_flags->stbc;\n\t}\n\n\tif (ht_cap->mcs.rx_mask[1] && ht_cap->mcs.rx_mask[2])\n\t\targ->peer_rate_caps |= WMI_RC_TS_FLAG;\n\telse if (ht_cap->mcs.rx_mask[1])\n\t\targ->peer_rate_caps |= WMI_RC_DS_FLAG;\n\n\tfor (i = 0, n = 0, max_nss = 0; i < IEEE80211_HT_MCS_MASK_LEN * 8; i++)\n\t\tif ((ht_cap->mcs.rx_mask[i / 8] & BIT(i % 8)) &&\n\t\t    (ht_mcs_mask[i / 8] & BIT(i % 8))) {\n\t\t\tmax_nss = (i / 8) + 1;\n\t\t\targ->peer_ht_rates.rates[n++] = i;\n\t\t}\n\n\t/*\n\t * This is a workaround for HT-enabled STAs which break the spec\n\t * and have no HT capabilities RX mask (no HT RX MCS map).\n\t *\n\t * As per spec, in section 20.3.5 Modulation and coding scheme (MCS),\n\t * MCS 0 through 7 are mandatory in 20MHz with 800 ns GI at all STAs.\n\t *\n\t * Firmware asserts if such situation occurs.\n\t */\n\tif (n == 0) {\n\t\targ->peer_ht_rates.num_rates = 8;\n\t\tfor (i = 0; i < arg->peer_ht_rates.num_rates; i++)\n\t\t\targ->peer_ht_rates.rates[i] = i;\n\t} else {\n\t\targ->peer_ht_rates.num_rates = n;\n\t\targ->peer_num_spatial_streams = min(sta->rx_nss, max_nss);\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac ht peer %pM mcs cnt %d nss %d\\n\",\n\t\t   arg->addr,\n\t\t   arg->peer_ht_rates.num_rates,\n\t\t   arg->peer_num_spatial_streams);\n}\n\nstatic int ath10k_peer_assoc_qos_ap(struct ath10k *ar,\n\t\t\t\t    struct ath10k_vif *arvif,\n\t\t\t\t    struct ieee80211_sta *sta)\n{\n\tu32 uapsd = 0;\n\tu32 max_sp = 0;\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (sta->wme && sta->uapsd_queues) {\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac uapsd_queues 0x%x max_sp %d\\n\",\n\t\t\t   sta->uapsd_queues, sta->max_sp);\n\n\t\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO)\n\t\t\tuapsd |= WMI_AP_PS_UAPSD_AC3_DELIVERY_EN |\n\t\t\t\t WMI_AP_PS_UAPSD_AC3_TRIGGER_EN;\n\t\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VI)\n\t\t\tuapsd |= WMI_AP_PS_UAPSD_AC2_DELIVERY_EN |\n\t\t\t\t WMI_AP_PS_UAPSD_AC2_TRIGGER_EN;\n\t\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BK)\n\t\t\tuapsd |= WMI_AP_PS_UAPSD_AC1_DELIVERY_EN |\n\t\t\t\t WMI_AP_PS_UAPSD_AC1_TRIGGER_EN;\n\t\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BE)\n\t\t\tuapsd |= WMI_AP_PS_UAPSD_AC0_DELIVERY_EN |\n\t\t\t\t WMI_AP_PS_UAPSD_AC0_TRIGGER_EN;\n\n\t\tif (sta->max_sp < MAX_WMI_AP_PS_PEER_PARAM_MAX_SP)\n\t\t\tmax_sp = sta->max_sp;\n\n\t\tret = ath10k_wmi_set_ap_ps_param(ar, arvif->vdev_id,\n\t\t\t\t\t\t sta->addr,\n\t\t\t\t\t\t WMI_AP_PS_PEER_PARAM_UAPSD,\n\t\t\t\t\t\t uapsd);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set ap ps peer param uapsd for vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ath10k_wmi_set_ap_ps_param(ar, arvif->vdev_id,\n\t\t\t\t\t\t sta->addr,\n\t\t\t\t\t\t WMI_AP_PS_PEER_PARAM_MAX_SP,\n\t\t\t\t\t\t max_sp);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set ap ps peer param max sp for vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* TODO setup this based on STA listen interval and\n\t\t * beacon interval. Currently we don't know\n\t\t * sta->listen_interval - mac80211 patch required.\n\t\t * Currently use 10 seconds\n\t\t */\n\t\tret = ath10k_wmi_set_ap_ps_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\t\t WMI_AP_PS_PEER_PARAM_AGEOUT_TIME,\n\t\t\t\t\t\t 10);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set ap ps peer param ageout time for vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic u16\nath10k_peer_assoc_h_vht_limit(u16 tx_mcs_set,\n\t\t\t      const u16 vht_mcs_limit[NL80211_VHT_NSS_MAX])\n{\n\tint idx_limit;\n\tint nss;\n\tu16 mcs_map;\n\tu16 mcs;\n\n\tfor (nss = 0; nss < NL80211_VHT_NSS_MAX; nss++) {\n\t\tmcs_map = ath10k_mac_get_max_vht_mcs_map(tx_mcs_set, nss) &\n\t\t\t  vht_mcs_limit[nss];\n\n\t\tif (mcs_map)\n\t\t\tidx_limit = fls(mcs_map) - 1;\n\t\telse\n\t\t\tidx_limit = -1;\n\n\t\tswitch (idx_limit) {\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\tdefault:\n\t\t\t/* see ath10k_mac_can_set_bitrate_mask() */\n\t\t\tWARN_ON(1);\n\t\t\tfallthrough;\n\t\tcase -1:\n\t\t\tmcs = IEEE80211_VHT_MCS_NOT_SUPPORTED;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tmcs = IEEE80211_VHT_MCS_SUPPORT_0_7;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tmcs = IEEE80211_VHT_MCS_SUPPORT_0_8;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tmcs = IEEE80211_VHT_MCS_SUPPORT_0_9;\n\t\t\tbreak;\n\t\t}\n\n\t\ttx_mcs_set &= ~(0x3 << (nss * 2));\n\t\ttx_mcs_set |= mcs << (nss * 2);\n\t}\n\n\treturn tx_mcs_set;\n}\n\nstatic u32 get_160mhz_nss_from_maxrate(int rate)\n{\n\tu32 nss;\n\n\tswitch (rate) {\n\tcase 780:\n\t\tnss = 1;\n\t\tbreak;\n\tcase 1560:\n\t\tnss = 2;\n\t\tbreak;\n\tcase 2106:\n\t\tnss = 3; /* not support MCS9 from spec*/\n\t\tbreak;\n\tcase 3120:\n\t\tnss = 4;\n\t\tbreak;\n\tdefault:\n\t\t nss = 1;\n\t}\n\n\treturn nss;\n}\n\nstatic void ath10k_peer_assoc_h_vht(struct ath10k *ar,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t    struct wmi_peer_assoc_complete_arg *arg)\n{\n\tconst struct ieee80211_sta_vht_cap *vht_cap = &sta->vht_cap;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_hw_params *hw = &ar->hw_params;\n\tstruct cfg80211_chan_def def;\n\tenum nl80211_band band;\n\tconst u16 *vht_mcs_mask;\n\tu8 ampdu_factor;\n\tu8 max_nss, vht_mcs;\n\tint i;\n\n\tif (WARN_ON(ath10k_mac_vif_chan(vif, &def)))\n\t\treturn;\n\n\tif (!vht_cap->vht_supported)\n\t\treturn;\n\n\tband = def.chan->band;\n\tvht_mcs_mask = arvif->bitrate_mask.control[band].vht_mcs;\n\n\tif (ath10k_peer_assoc_h_vht_masked(vht_mcs_mask))\n\t\treturn;\n\n\targ->peer_flags |= ar->wmi.peer_flags->vht;\n\n\tif (def.chan->band == NL80211_BAND_2GHZ)\n\t\targ->peer_flags |= ar->wmi.peer_flags->vht_2g;\n\n\targ->peer_vht_caps = vht_cap->cap;\n\n\tampdu_factor = (vht_cap->cap &\n\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK) >>\n\t\t       IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT;\n\n\t/* Workaround: Some Netgear/Linksys 11ac APs set Rx A-MPDU factor to\n\t * zero in VHT IE. Using it would result in degraded throughput.\n\t * arg->peer_max_mpdu at this point contains HT max_mpdu so keep\n\t * it if VHT max_mpdu is smaller.\n\t */\n\targ->peer_max_mpdu = max(arg->peer_max_mpdu,\n\t\t\t\t (1U << (IEEE80211_HT_MAX_AMPDU_FACTOR +\n\t\t\t\t\tampdu_factor)) - 1);\n\n\tif (sta->bandwidth == IEEE80211_STA_RX_BW_80)\n\t\targ->peer_flags |= ar->wmi.peer_flags->bw80;\n\n\tif (sta->bandwidth == IEEE80211_STA_RX_BW_160)\n\t\targ->peer_flags |= ar->wmi.peer_flags->bw160;\n\n\t/* Calculate peer NSS capability from VHT capabilities if STA\n\t * supports VHT.\n\t */\n\tfor (i = 0, max_nss = 0, vht_mcs = 0; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tvht_mcs = __le16_to_cpu(vht_cap->vht_mcs.rx_mcs_map) >>\n\t\t\t  (2 * i) & 3;\n\n\t\tif ((vht_mcs != IEEE80211_VHT_MCS_NOT_SUPPORTED) &&\n\t\t    vht_mcs_mask[i])\n\t\t\tmax_nss = i + 1;\n\t}\n\targ->peer_num_spatial_streams = min(sta->rx_nss, max_nss);\n\targ->peer_vht_rates.rx_max_rate =\n\t\t__le16_to_cpu(vht_cap->vht_mcs.rx_highest);\n\targ->peer_vht_rates.rx_mcs_set =\n\t\t__le16_to_cpu(vht_cap->vht_mcs.rx_mcs_map);\n\targ->peer_vht_rates.tx_max_rate =\n\t\t__le16_to_cpu(vht_cap->vht_mcs.tx_highest);\n\targ->peer_vht_rates.tx_mcs_set = ath10k_peer_assoc_h_vht_limit(\n\t\t__le16_to_cpu(vht_cap->vht_mcs.tx_mcs_map), vht_mcs_mask);\n\n\t/* Configure bandwidth-NSS mapping to FW\n\t * for the chip's tx chains setting on 160Mhz bw\n\t */\n\tif (arg->peer_phymode == MODE_11AC_VHT160 ||\n\t    arg->peer_phymode == MODE_11AC_VHT80_80) {\n\t\tu32 rx_nss;\n\t\tu32 max_rate;\n\n\t\tmax_rate = arg->peer_vht_rates.rx_max_rate;\n\t\trx_nss = get_160mhz_nss_from_maxrate(max_rate);\n\n\t\tif (rx_nss == 0)\n\t\t\trx_nss = arg->peer_num_spatial_streams;\n\t\telse\n\t\t\trx_nss = min(arg->peer_num_spatial_streams, rx_nss);\n\n\t\tmax_rate = hw->vht160_mcs_tx_highest;\n\t\trx_nss = min(rx_nss, get_160mhz_nss_from_maxrate(max_rate));\n\n\t\targ->peer_bw_rxnss_override =\n\t\t\tFIELD_PREP(WMI_PEER_NSS_MAP_ENABLE, 1) |\n\t\t\tFIELD_PREP(WMI_PEER_NSS_160MHZ_MASK, (rx_nss - 1));\n\n\t\tif (arg->peer_phymode == MODE_11AC_VHT80_80) {\n\t\t\targ->peer_bw_rxnss_override |=\n\t\t\tFIELD_PREP(WMI_PEER_NSS_80_80MHZ_MASK, (rx_nss - 1));\n\t\t}\n\t}\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac vht peer %pM max_mpdu %d flags 0x%x peer_rx_nss_override 0x%x\\n\",\n\t\t   sta->addr, arg->peer_max_mpdu,\n\t\t   arg->peer_flags, arg->peer_bw_rxnss_override);\n}\n\nstatic void ath10k_peer_assoc_h_qos(struct ath10k *ar,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t    struct wmi_peer_assoc_complete_arg *arg)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\n\tswitch (arvif->vdev_type) {\n\tcase WMI_VDEV_TYPE_AP:\n\t\tif (sta->wme)\n\t\t\targ->peer_flags |= arvif->ar->wmi.peer_flags->qos;\n\n\t\tif (sta->wme && sta->uapsd_queues) {\n\t\t\targ->peer_flags |= arvif->ar->wmi.peer_flags->apsd;\n\t\t\targ->peer_rate_caps |= WMI_RC_UAPSD_FLAG;\n\t\t}\n\t\tbreak;\n\tcase WMI_VDEV_TYPE_STA:\n\t\tif (sta->wme)\n\t\t\targ->peer_flags |= arvif->ar->wmi.peer_flags->qos;\n\t\tbreak;\n\tcase WMI_VDEV_TYPE_IBSS:\n\t\tif (sta->wme)\n\t\t\targ->peer_flags |= arvif->ar->wmi.peer_flags->qos;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac peer %pM qos %d\\n\",\n\t\t   sta->addr, !!(arg->peer_flags &\n\t\t   arvif->ar->wmi.peer_flags->qos));\n}\n\nstatic bool ath10k_mac_sta_has_ofdm_only(struct ieee80211_sta *sta)\n{\n\treturn sta->supp_rates[NL80211_BAND_2GHZ] >>\n\t       ATH10K_MAC_FIRST_OFDM_RATE_IDX;\n}\n\nstatic enum wmi_phy_mode ath10k_mac_get_phymode_vht(struct ath10k *ar,\n\t\t\t\t\t\t    struct ieee80211_sta *sta)\n{\n\tif (sta->bandwidth == IEEE80211_STA_RX_BW_160) {\n\t\tswitch (sta->vht_cap.cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) {\n\t\tcase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ:\n\t\t\treturn MODE_11AC_VHT160;\n\t\tcase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ:\n\t\t\treturn MODE_11AC_VHT80_80;\n\t\tdefault:\n\t\t\t/* not sure if this is a valid case? */\n\t\t\treturn MODE_11AC_VHT160;\n\t\t}\n\t}\n\n\tif (sta->bandwidth == IEEE80211_STA_RX_BW_80)\n\t\treturn MODE_11AC_VHT80;\n\n\tif (sta->bandwidth == IEEE80211_STA_RX_BW_40)\n\t\treturn MODE_11AC_VHT40;\n\n\tif (sta->bandwidth == IEEE80211_STA_RX_BW_20)\n\t\treturn MODE_11AC_VHT20;\n\n\treturn MODE_UNKNOWN;\n}\n\nstatic void ath10k_peer_assoc_h_phymode(struct ath10k *ar,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tstruct wmi_peer_assoc_complete_arg *arg)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct cfg80211_chan_def def;\n\tenum nl80211_band band;\n\tconst u8 *ht_mcs_mask;\n\tconst u16 *vht_mcs_mask;\n\tenum wmi_phy_mode phymode = MODE_UNKNOWN;\n\n\tif (WARN_ON(ath10k_mac_vif_chan(vif, &def)))\n\t\treturn;\n\n\tband = def.chan->band;\n\tht_mcs_mask = arvif->bitrate_mask.control[band].ht_mcs;\n\tvht_mcs_mask = arvif->bitrate_mask.control[band].vht_mcs;\n\n\tswitch (band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tif (sta->vht_cap.vht_supported &&\n\t\t    !ath10k_peer_assoc_h_vht_masked(vht_mcs_mask)) {\n\t\t\tif (sta->bandwidth == IEEE80211_STA_RX_BW_40)\n\t\t\t\tphymode = MODE_11AC_VHT40;\n\t\t\telse\n\t\t\t\tphymode = MODE_11AC_VHT20;\n\t\t} else if (sta->ht_cap.ht_supported &&\n\t\t\t   !ath10k_peer_assoc_h_ht_masked(ht_mcs_mask)) {\n\t\t\tif (sta->bandwidth == IEEE80211_STA_RX_BW_40)\n\t\t\t\tphymode = MODE_11NG_HT40;\n\t\t\telse\n\t\t\t\tphymode = MODE_11NG_HT20;\n\t\t} else if (ath10k_mac_sta_has_ofdm_only(sta)) {\n\t\t\tphymode = MODE_11G;\n\t\t} else {\n\t\t\tphymode = MODE_11B;\n\t\t}\n\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\t/*\n\t\t * Check VHT first.\n\t\t */\n\t\tif (sta->vht_cap.vht_supported &&\n\t\t    !ath10k_peer_assoc_h_vht_masked(vht_mcs_mask)) {\n\t\t\tphymode = ath10k_mac_get_phymode_vht(ar, sta);\n\t\t} else if (sta->ht_cap.ht_supported &&\n\t\t\t   !ath10k_peer_assoc_h_ht_masked(ht_mcs_mask)) {\n\t\t\tif (sta->bandwidth >= IEEE80211_STA_RX_BW_40)\n\t\t\t\tphymode = MODE_11NA_HT40;\n\t\t\telse\n\t\t\t\tphymode = MODE_11NA_HT20;\n\t\t} else {\n\t\t\tphymode = MODE_11A;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac peer %pM phymode %s\\n\",\n\t\t   sta->addr, ath10k_wmi_phymode_str(phymode));\n\n\targ->peer_phymode = phymode;\n\tWARN_ON(phymode == MODE_UNKNOWN);\n}\n\nstatic int ath10k_peer_assoc_prepare(struct ath10k *ar,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t     struct wmi_peer_assoc_complete_arg *arg)\n{\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tmemset(arg, 0, sizeof(*arg));\n\n\tath10k_peer_assoc_h_basic(ar, vif, sta, arg);\n\tath10k_peer_assoc_h_crypto(ar, vif, sta, arg);\n\tath10k_peer_assoc_h_rates(ar, vif, sta, arg);\n\tath10k_peer_assoc_h_ht(ar, vif, sta, arg);\n\tath10k_peer_assoc_h_phymode(ar, vif, sta, arg);\n\tath10k_peer_assoc_h_vht(ar, vif, sta, arg);\n\tath10k_peer_assoc_h_qos(ar, vif, sta, arg);\n\n\treturn 0;\n}\n\nstatic const u32 ath10k_smps_map[] = {\n\t[WLAN_HT_CAP_SM_PS_STATIC] = WMI_PEER_SMPS_STATIC,\n\t[WLAN_HT_CAP_SM_PS_DYNAMIC] = WMI_PEER_SMPS_DYNAMIC,\n\t[WLAN_HT_CAP_SM_PS_INVALID] = WMI_PEER_SMPS_PS_NONE,\n\t[WLAN_HT_CAP_SM_PS_DISABLED] = WMI_PEER_SMPS_PS_NONE,\n};\n\nstatic int ath10k_setup_peer_smps(struct ath10k *ar, struct ath10k_vif *arvif,\n\t\t\t\t  const u8 *addr,\n\t\t\t\t  const struct ieee80211_sta_ht_cap *ht_cap)\n{\n\tint smps;\n\n\tif (!ht_cap->ht_supported)\n\t\treturn 0;\n\n\tsmps = ht_cap->cap & IEEE80211_HT_CAP_SM_PS;\n\tsmps >>= IEEE80211_HT_CAP_SM_PS_SHIFT;\n\n\tif (smps >= ARRAY_SIZE(ath10k_smps_map))\n\t\treturn -EINVAL;\n\n\treturn ath10k_wmi_peer_set_param(ar, arvif->vdev_id, addr,\n\t\t\t\t\t ar->wmi.peer_param->smps_state,\n\t\t\t\t\t ath10k_smps_map[smps]);\n}\n\nstatic int ath10k_mac_vif_recalc_txbf(struct ath10k *ar,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta_vht_cap vht_cap)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tint ret;\n\tu32 param;\n\tu32 value;\n\n\tif (ath10k_wmi_get_txbf_conf_scheme(ar) != WMI_TXBF_CONF_AFTER_ASSOC)\n\t\treturn 0;\n\n\tif (!(ar->vht_cap_info &\n\t      (IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\n\t       IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE |\n\t       IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |\n\t       IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE)))\n\t\treturn 0;\n\n\tparam = ar->wmi.vdev_param->txbf;\n\tvalue = 0;\n\n\tif (WARN_ON(param == WMI_VDEV_PARAM_UNSUPPORTED))\n\t\treturn 0;\n\n\t/* The following logic is correct. If a remote STA advertises support\n\t * for being a beamformer then we should enable us being a beamformee.\n\t */\n\n\tif (ar->vht_cap_info &\n\t    (IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\n\t     IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE)) {\n\t\tif (vht_cap.cap & IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE)\n\t\t\tvalue |= WMI_VDEV_PARAM_TXBF_SU_TX_BFEE;\n\n\t\tif (vht_cap.cap & IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE)\n\t\t\tvalue |= WMI_VDEV_PARAM_TXBF_MU_TX_BFEE;\n\t}\n\n\tif (ar->vht_cap_info &\n\t    (IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |\n\t     IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE)) {\n\t\tif (vht_cap.cap & IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE)\n\t\t\tvalue |= WMI_VDEV_PARAM_TXBF_SU_TX_BFER;\n\n\t\tif (vht_cap.cap & IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE)\n\t\t\tvalue |= WMI_VDEV_PARAM_TXBF_MU_TX_BFER;\n\t}\n\n\tif (value & WMI_VDEV_PARAM_TXBF_MU_TX_BFEE)\n\t\tvalue |= WMI_VDEV_PARAM_TXBF_SU_TX_BFEE;\n\n\tif (value & WMI_VDEV_PARAM_TXBF_MU_TX_BFER)\n\t\tvalue |= WMI_VDEV_PARAM_TXBF_SU_TX_BFER;\n\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, param, value);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to submit vdev param txbf 0x%x: %d\\n\",\n\t\t\t    value, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic bool ath10k_mac_is_connected(struct ath10k *ar)\n{\n\tstruct ath10k_vif *arvif;\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tif (arvif->is_up && arvif->vdev_type == WMI_VDEV_TYPE_STA)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int ath10k_mac_txpower_setup(struct ath10k *ar, int txpower)\n{\n\tint ret;\n\tu32 param;\n\tint tx_power_2g, tx_power_5g;\n\tbool connected;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\t/* ath10k internally uses unit of 0.5 dBm so multiply by 2 */\n\ttx_power_2g = txpower * 2;\n\ttx_power_5g = txpower * 2;\n\n\tconnected = ath10k_mac_is_connected(ar);\n\n\tif (connected && ar->tx_power_2g_limit)\n\t\tif (tx_power_2g > ar->tx_power_2g_limit)\n\t\t\ttx_power_2g = ar->tx_power_2g_limit;\n\n\tif (connected && ar->tx_power_5g_limit)\n\t\tif (tx_power_5g > ar->tx_power_5g_limit)\n\t\t\ttx_power_5g = ar->tx_power_5g_limit;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac txpower 2g: %d, 5g: %d\\n\",\n\t\t   tx_power_2g, tx_power_5g);\n\n\tparam = ar->wmi.pdev_param->txpower_limit2g;\n\tret = ath10k_wmi_pdev_set_param(ar, param, tx_power_2g);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set 2g txpower %d: %d\\n\",\n\t\t\t    tx_power_2g, ret);\n\t\treturn ret;\n\t}\n\n\tparam = ar->wmi.pdev_param->txpower_limit5g;\n\tret = ath10k_wmi_pdev_set_param(ar, param, tx_power_5g);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set 5g txpower %d: %d\\n\",\n\t\t\t    tx_power_5g, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_txpower_recalc(struct ath10k *ar)\n{\n\tstruct ath10k_vif *arvif;\n\tint ret, txpower = -1;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\t/* txpower not initialized yet? */\n\t\tif (arvif->txpower == INT_MIN)\n\t\t\tcontinue;\n\n\t\tif (txpower == -1)\n\t\t\ttxpower = arvif->txpower;\n\t\telse\n\t\t\ttxpower = min(txpower, arvif->txpower);\n\t}\n\n\tif (txpower == -1)\n\t\treturn 0;\n\n\tret = ath10k_mac_txpower_setup(ar, txpower);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to setup tx power %d: %d\\n\",\n\t\t\t    txpower, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_set_sar_power(struct ath10k *ar)\n{\n\tif (!ar->hw_params.dynamic_sar_support)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!ath10k_mac_is_connected(ar))\n\t\treturn 0;\n\n\t/* if connected, then arvif->txpower must be valid */\n\treturn ath10k_mac_txpower_recalc(ar);\n}\n\nstatic int ath10k_mac_set_sar_specs(struct ieee80211_hw *hw,\n\t\t\t\t    const struct cfg80211_sar_specs *sar)\n{\n\tconst struct cfg80211_sar_sub_specs *sub_specs;\n\tstruct ath10k *ar = hw->priv;\n\tu32 i;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (!ar->hw_params.dynamic_sar_support) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err;\n\t}\n\n\tif (!sar || sar->type != NL80211_SAR_TYPE_POWER ||\n\t    sar->num_sub_specs == 0) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tsub_specs = sar->sub_specs;\n\n\t/* 0dbm is not a practical value for ath10k, so use 0\n\t * as no SAR limitation on it.\n\t */\n\tar->tx_power_2g_limit = 0;\n\tar->tx_power_5g_limit = 0;\n\n\t/* note the power is in 0.25dbm unit, while ath10k uses\n\t * 0.5dbm unit.\n\t */\n\tfor (i = 0; i < sar->num_sub_specs; i++) {\n\t\tif (sub_specs->freq_range_index == 0)\n\t\t\tar->tx_power_2g_limit = sub_specs->power / 2;\n\t\telse if (sub_specs->freq_range_index == 1)\n\t\t\tar->tx_power_5g_limit = sub_specs->power / 2;\n\n\t\tsub_specs++;\n\t}\n\n\tret = ath10k_mac_set_sar_power(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set sar power: %d\", ret);\n\t\tgoto err;\n\t}\n\nerr:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\n/* can be called only in mac80211 callbacks due to `key_count` usage */\nstatic void ath10k_bss_assoc(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_bss_conf *bss_conf)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ieee80211_sta_ht_cap ht_cap;\n\tstruct ieee80211_sta_vht_cap vht_cap;\n\tstruct wmi_peer_assoc_complete_arg peer_arg;\n\tstruct ieee80211_sta *ap_sta;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %i assoc bssid %pM aid %d\\n\",\n\t\t   arvif->vdev_id, arvif->bssid, arvif->aid);\n\n\trcu_read_lock();\n\n\tap_sta = ieee80211_find_sta(vif, bss_conf->bssid);\n\tif (!ap_sta) {\n\t\tath10k_warn(ar, \"failed to find station entry for bss %pM vdev %i\\n\",\n\t\t\t    bss_conf->bssid, arvif->vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* ap_sta must be accessed only within rcu section which must be left\n\t * before calling ath10k_setup_peer_smps() which might sleep.\n\t */\n\tht_cap = ap_sta->ht_cap;\n\tvht_cap = ap_sta->vht_cap;\n\n\tret = ath10k_peer_assoc_prepare(ar, vif, ap_sta, &peer_arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to prepare peer assoc for %pM vdev %i: %d\\n\",\n\t\t\t    bss_conf->bssid, arvif->vdev_id, ret);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\trcu_read_unlock();\n\n\tret = ath10k_wmi_peer_assoc(ar, &peer_arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to run peer assoc for %pM vdev %i: %d\\n\",\n\t\t\t    bss_conf->bssid, arvif->vdev_id, ret);\n\t\treturn;\n\t}\n\n\tret = ath10k_setup_peer_smps(ar, arvif, bss_conf->bssid, &ht_cap);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to setup peer SMPS for vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn;\n\t}\n\n\tret = ath10k_mac_vif_recalc_txbf(ar, vif, vht_cap);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to recalc txbf for vdev %i on bss %pM: %d\\n\",\n\t\t\t    arvif->vdev_id, bss_conf->bssid, ret);\n\t\treturn;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac vdev %d up (associated) bssid %pM aid %d\\n\",\n\t\t   arvif->vdev_id, bss_conf->bssid, bss_conf->aid);\n\n\tWARN_ON(arvif->is_up);\n\n\tarvif->aid = bss_conf->aid;\n\tether_addr_copy(arvif->bssid, bss_conf->bssid);\n\n\tret = ath10k_wmi_pdev_set_param(ar,\n\t\t\t\t\tar->wmi.pdev_param->peer_stats_info_enable, 1);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to enable peer stats info: %d\\n\", ret);\n\n\tret = ath10k_wmi_vdev_up(ar, arvif->vdev_id, arvif->aid, arvif->bssid);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set vdev %d up: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn;\n\t}\n\n\tarvif->is_up = true;\n\n\tath10k_mac_set_sar_power(ar);\n\n\t/* Workaround: Some firmware revisions (tested with qca6174\n\t * WLAN.RM.2.0-00073) have buggy powersave state machine and must be\n\t * poked with peer param command.\n\t */\n\tret = ath10k_wmi_peer_set_param(ar, arvif->vdev_id, arvif->bssid,\n\t\t\t\t\tar->wmi.peer_param->dummy_var, 1);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to poke peer %pM param for ps workaround on vdev %i: %d\\n\",\n\t\t\t    arvif->bssid, arvif->vdev_id, ret);\n\t\treturn;\n\t}\n}\n\nstatic void ath10k_bss_disassoc(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ieee80211_sta_vht_cap vht_cap = {};\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %i disassoc bssid %pM\\n\",\n\t\t   arvif->vdev_id, arvif->bssid);\n\n\tret = ath10k_wmi_vdev_down(ar, arvif->vdev_id);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to down vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\n\tarvif->def_wep_key_idx = -1;\n\n\tret = ath10k_mac_vif_recalc_txbf(ar, vif, vht_cap);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to recalc txbf for vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn;\n\t}\n\n\tarvif->is_up = false;\n\n\tath10k_mac_txpower_recalc(ar);\n\n\tcancel_delayed_work_sync(&arvif->connection_loss_work);\n}\n\nstatic int ath10k_new_peer_tid_config(struct ath10k *ar,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct ath10k_vif *arvif)\n{\n\tstruct wmi_per_peer_per_tid_cfg_arg arg = {};\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tbool config_apply;\n\tint ret, i;\n\n\tfor (i = 0; i < ATH10K_TID_MAX; i++) {\n\t\tconfig_apply = false;\n\t\tif (arvif->retry_long[i] || arvif->ampdu[i] ||\n\t\t    arvif->rate_ctrl[i] || arvif->rtscts[i]) {\n\t\t\tconfig_apply = true;\n\t\t\targ.tid = i;\n\t\t\targ.vdev_id = arvif->vdev_id;\n\t\t\targ.retry_count = arvif->retry_long[i];\n\t\t\targ.aggr_control = arvif->ampdu[i];\n\t\t\targ.rate_ctrl = arvif->rate_ctrl[i];\n\t\t\targ.rcode_flags = arvif->rate_code[i];\n\n\t\t\tif (arvif->rtscts[i])\n\t\t\t\targ.ext_tid_cfg_bitmap =\n\t\t\t\t\tWMI_EXT_TID_RTS_CTS_CONFIG;\n\t\t\telse\n\t\t\t\targ.ext_tid_cfg_bitmap = 0;\n\n\t\t\targ.rtscts_ctrl = arvif->rtscts[i];\n\t\t}\n\n\t\tif (arvif->noack[i]) {\n\t\t\targ.ack_policy = arvif->noack[i];\n\t\t\targ.rate_ctrl = WMI_TID_CONFIG_RATE_CONTROL_DEFAULT_LOWEST_RATE;\n\t\t\targ.aggr_control = WMI_TID_CONFIG_AGGR_CONTROL_DISABLE;\n\t\t\tconfig_apply = true;\n\t\t}\n\n\t\t/* Assign default value(-1) to newly connected station.\n\t\t * This is to identify station specific tid configuration not\n\t\t * configured for the station.\n\t\t */\n\t\tarsta->retry_long[i] = -1;\n\t\tarsta->noack[i] = -1;\n\t\tarsta->ampdu[i] = -1;\n\n\t\tif (!config_apply)\n\t\t\tcontinue;\n\n\t\tether_addr_copy(arg.peer_macaddr.addr, sta->addr);\n\n\t\tret = ath10k_wmi_set_per_peer_per_tid_cfg(ar, &arg);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set per tid retry/aggr config for sta %pM: %d\\n\",\n\t\t\t\t    sta->addr, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmemset(&arg, 0, sizeof(arg));\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_station_assoc(struct ath10k *ar,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tbool reassoc)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct wmi_peer_assoc_complete_arg peer_arg;\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_peer_assoc_prepare(ar, vif, sta, &peer_arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to prepare WMI peer assoc for %pM vdev %i: %i\\n\",\n\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_wmi_peer_assoc(ar, &peer_arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to run peer assoc for STA %pM vdev %i: %d\\n\",\n\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\t/* Re-assoc is run only to update supported rates for given station. It\n\t * doesn't make much sense to reconfigure the peer completely.\n\t */\n\tif (!reassoc) {\n\t\tret = ath10k_setup_peer_smps(ar, arvif, sta->addr,\n\t\t\t\t\t     &sta->ht_cap);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to setup peer SMPS for vdev %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ath10k_peer_assoc_qos_ap(ar, arvif, sta);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set qos params for STA %pM for vdev %i: %d\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!sta->wme) {\n\t\t\tarvif->num_legacy_stations++;\n\t\t\tret  = ath10k_recalc_rtscts_prot(arvif);\n\t\t\tif (ret) {\n\t\t\t\tath10k_warn(ar, \"failed to recalculate rts/cts prot for vdev %d: %d\\n\",\n\t\t\t\t\t    arvif->vdev_id, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/* Plumb cached keys only for static WEP */\n\t\tif ((arvif->def_wep_key_idx != -1) && (!sta->tdls)) {\n\t\t\tret = ath10k_install_peer_wep_keys(arvif, sta->addr);\n\t\t\tif (ret) {\n\t\t\t\tath10k_warn(ar, \"failed to install peer wep keys for vdev %i: %d\\n\",\n\t\t\t\t\t    arvif->vdev_id, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!test_bit(WMI_SERVICE_PEER_TID_CONFIGS_SUPPORT, ar->wmi.svc_map))\n\t\treturn ret;\n\n\treturn ath10k_new_peer_tid_config(ar, sta, arvif);\n}\n\nstatic int ath10k_station_disassoc(struct ath10k *ar,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (!sta->wme) {\n\t\tarvif->num_legacy_stations--;\n\t\tret = ath10k_recalc_rtscts_prot(arvif);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to recalculate rts/cts prot for vdev %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = ath10k_clear_peer_keys(arvif, sta->addr);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to clear all peer wep keys for vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n/**************/\n/* Regulatory */\n/**************/\n\nstatic int ath10k_update_channel_list(struct ath10k *ar)\n{\n\tstruct ieee80211_hw *hw = ar->hw;\n\tstruct ieee80211_supported_band **bands;\n\tenum nl80211_band band;\n\tstruct ieee80211_channel *channel;\n\tstruct wmi_scan_chan_list_arg arg = {0};\n\tstruct wmi_channel_arg *ch;\n\tbool passive;\n\tint len;\n\tint ret;\n\tint i;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tbands = hw->wiphy->bands;\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tif (!bands[band])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < bands[band]->n_channels; i++) {\n\t\t\tif (bands[band]->channels[i].flags &\n\t\t\t    IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\targ.n_channels++;\n\t\t}\n\t}\n\n\tlen = sizeof(struct wmi_channel_arg) * arg.n_channels;\n\targ.channels = kzalloc(len, GFP_KERNEL);\n\tif (!arg.channels)\n\t\treturn -ENOMEM;\n\n\tch = arg.channels;\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tif (!bands[band])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < bands[band]->n_channels; i++) {\n\t\t\tchannel = &bands[band]->channels[i];\n\n\t\t\tif (channel->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\tch->allow_ht = true;\n\n\t\t\t/* FIXME: when should we really allow VHT? */\n\t\t\tch->allow_vht = true;\n\n\t\t\tch->allow_ibss =\n\t\t\t\t!(channel->flags & IEEE80211_CHAN_NO_IR);\n\n\t\t\tch->ht40plus =\n\t\t\t\t!(channel->flags & IEEE80211_CHAN_NO_HT40PLUS);\n\n\t\t\tch->chan_radar =\n\t\t\t\t!!(channel->flags & IEEE80211_CHAN_RADAR);\n\n\t\t\tpassive = channel->flags & IEEE80211_CHAN_NO_IR;\n\t\t\tch->passive = passive;\n\n\t\t\t/* the firmware is ignoring the \"radar\" flag of the\n\t\t\t * channel and is scanning actively using Probe Requests\n\t\t\t * on \"Radar detection\"/DFS channels which are not\n\t\t\t * marked as \"available\"\n\t\t\t */\n\t\t\tch->passive |= ch->chan_radar;\n\n\t\t\tch->freq = channel->center_freq;\n\t\t\tch->band_center_freq1 = channel->center_freq;\n\t\t\tch->min_power = 0;\n\t\t\tch->max_power = channel->max_power * 2;\n\t\t\tch->max_reg_power = channel->max_reg_power * 2;\n\t\t\tch->max_antenna_gain = channel->max_antenna_gain * 2;\n\t\t\tch->reg_class_id = 0; /* FIXME */\n\n\t\t\t/* FIXME: why use only legacy modes, why not any\n\t\t\t * HT/VHT modes? Would that even make any\n\t\t\t * difference?\n\t\t\t */\n\t\t\tif (channel->band == NL80211_BAND_2GHZ)\n\t\t\t\tch->mode = MODE_11G;\n\t\t\telse\n\t\t\t\tch->mode = MODE_11A;\n\n\t\t\tif (WARN_ON_ONCE(ch->mode == MODE_UNKNOWN))\n\t\t\t\tcontinue;\n\n\t\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t\t   \"mac channel [%zd/%d] freq %d maxpower %d regpower %d antenna %d mode %d\\n\",\n\t\t\t\t    ch - arg.channels, arg.n_channels,\n\t\t\t\t   ch->freq, ch->max_power, ch->max_reg_power,\n\t\t\t\t   ch->max_antenna_gain, ch->mode);\n\n\t\t\tch++;\n\t\t}\n\t}\n\n\tret = ath10k_wmi_scan_chan_list(ar, &arg);\n\tkfree(arg.channels);\n\n\treturn ret;\n}\n\nstatic enum wmi_dfs_region\nath10k_mac_get_dfs_region(enum nl80211_dfs_regions dfs_region)\n{\n\tswitch (dfs_region) {\n\tcase NL80211_DFS_UNSET:\n\t\treturn WMI_UNINIT_DFS_DOMAIN;\n\tcase NL80211_DFS_FCC:\n\t\treturn WMI_FCC_DFS_DOMAIN;\n\tcase NL80211_DFS_ETSI:\n\t\treturn WMI_ETSI_DFS_DOMAIN;\n\tcase NL80211_DFS_JP:\n\t\treturn WMI_MKK4_DFS_DOMAIN;\n\t}\n\treturn WMI_UNINIT_DFS_DOMAIN;\n}\n\nstatic void ath10k_regd_update(struct ath10k *ar)\n{\n\tstruct reg_dmn_pair_mapping *regpair;\n\tint ret;\n\tenum wmi_dfs_region wmi_dfs_reg;\n\tenum nl80211_dfs_regions nl_dfs_reg;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_update_channel_list(ar);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to update channel list: %d\\n\", ret);\n\n\tregpair = ar->ath_common.regulatory.regpair;\n\n\tif (IS_ENABLED(CONFIG_ATH10K_DFS_CERTIFIED) && ar->dfs_detector) {\n\t\tnl_dfs_reg = ar->dfs_detector->region;\n\t\twmi_dfs_reg = ath10k_mac_get_dfs_region(nl_dfs_reg);\n\t} else {\n\t\twmi_dfs_reg = WMI_UNINIT_DFS_DOMAIN;\n\t}\n\n\t/* Target allows setting up per-band regdomain but ath_common provides\n\t * a combined one only\n\t */\n\tret = ath10k_wmi_pdev_set_regdomain(ar,\n\t\t\t\t\t    regpair->reg_domain,\n\t\t\t\t\t    regpair->reg_domain, /* 2ghz */\n\t\t\t\t\t    regpair->reg_domain, /* 5ghz */\n\t\t\t\t\t    regpair->reg_2ghz_ctl,\n\t\t\t\t\t    regpair->reg_5ghz_ctl,\n\t\t\t\t\t    wmi_dfs_reg);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to set pdev regdomain: %d\\n\", ret);\n}\n\nstatic void ath10k_mac_update_channel_list(struct ath10k *ar,\n\t\t\t\t\t   struct ieee80211_supported_band *band)\n{\n\tint i;\n\n\tif (ar->low_5ghz_chan && ar->high_5ghz_chan) {\n\t\tfor (i = 0; i < band->n_channels; i++) {\n\t\t\tif (band->channels[i].center_freq < ar->low_5ghz_chan ||\n\t\t\t    band->channels[i].center_freq > ar->high_5ghz_chan)\n\t\t\t\tband->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_DISABLED;\n\t\t}\n\t}\n}\n\nstatic void ath10k_reg_notifier(struct wiphy *wiphy,\n\t\t\t\tstruct regulatory_request *request)\n{\n\tstruct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);\n\tstruct ath10k *ar = hw->priv;\n\tbool result;\n\n\tath_reg_notifier_apply(wiphy, request, &ar->ath_common.regulatory);\n\n\tif (IS_ENABLED(CONFIG_ATH10K_DFS_CERTIFIED) && ar->dfs_detector) {\n\t\tath10k_dbg(ar, ATH10K_DBG_REGULATORY, \"dfs region 0x%x\\n\",\n\t\t\t   request->dfs_region);\n\t\tresult = ar->dfs_detector->set_dfs_domain(ar->dfs_detector,\n\t\t\t\t\t\t\t  request->dfs_region);\n\t\tif (!result)\n\t\t\tath10k_warn(ar, \"DFS region 0x%X not supported, will trigger radar for every pulse\\n\",\n\t\t\t\t    request->dfs_region);\n\t}\n\n\tmutex_lock(&ar->conf_mutex);\n\tif (ar->state == ATH10K_STATE_ON)\n\t\tath10k_regd_update(ar);\n\tmutex_unlock(&ar->conf_mutex);\n\n\tif (ar->phy_capability & WHAL_WLAN_11A_CAPABILITY)\n\t\tath10k_mac_update_channel_list(ar,\n\t\t\t\t\t       ar->hw->wiphy->bands[NL80211_BAND_5GHZ]);\n}\n\nstatic void ath10k_stop_radar_confirmation(struct ath10k *ar)\n{\n\tspin_lock_bh(&ar->data_lock);\n\tar->radar_conf_state = ATH10K_RADAR_CONFIRMATION_STOPPED;\n\tspin_unlock_bh(&ar->data_lock);\n\n\tcancel_work_sync(&ar->radar_confirmation_work);\n}\n\n/***************/\n/* TX handlers */\n/***************/\n\nenum ath10k_mac_tx_path {\n\tATH10K_MAC_TX_HTT,\n\tATH10K_MAC_TX_HTT_MGMT,\n\tATH10K_MAC_TX_WMI_MGMT,\n\tATH10K_MAC_TX_UNKNOWN,\n};\n\nvoid ath10k_mac_tx_lock(struct ath10k *ar, int reason)\n{\n\tlockdep_assert_held(&ar->htt.tx_lock);\n\n\tWARN_ON(reason >= ATH10K_TX_PAUSE_MAX);\n\tar->tx_paused |= BIT(reason);\n\tieee80211_stop_queues(ar->hw);\n}\n\nstatic void ath10k_mac_tx_unlock_iter(void *data, u8 *mac,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct ath10k *ar = data;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\n\tif (arvif->tx_paused)\n\t\treturn;\n\n\tieee80211_wake_queue(ar->hw, arvif->vdev_id);\n}\n\nvoid ath10k_mac_tx_unlock(struct ath10k *ar, int reason)\n{\n\tlockdep_assert_held(&ar->htt.tx_lock);\n\n\tWARN_ON(reason >= ATH10K_TX_PAUSE_MAX);\n\tar->tx_paused &= ~BIT(reason);\n\n\tif (ar->tx_paused)\n\t\treturn;\n\n\tieee80211_iterate_active_interfaces_atomic(ar->hw,\n\t\t\t\t\t\t   ATH10K_ITER_RESUME_FLAGS,\n\t\t\t\t\t\t   ath10k_mac_tx_unlock_iter,\n\t\t\t\t\t\t   ar);\n\n\tieee80211_wake_queue(ar->hw, ar->hw->offchannel_tx_hw_queue);\n}\n\nvoid ath10k_mac_vif_tx_lock(struct ath10k_vif *arvif, int reason)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->htt.tx_lock);\n\n\tWARN_ON(reason >= BITS_PER_LONG);\n\tarvif->tx_paused |= BIT(reason);\n\tieee80211_stop_queue(ar->hw, arvif->vdev_id);\n}\n\nvoid ath10k_mac_vif_tx_unlock(struct ath10k_vif *arvif, int reason)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->htt.tx_lock);\n\n\tWARN_ON(reason >= BITS_PER_LONG);\n\tarvif->tx_paused &= ~BIT(reason);\n\n\tif (ar->tx_paused)\n\t\treturn;\n\n\tif (arvif->tx_paused)\n\t\treturn;\n\n\tieee80211_wake_queue(ar->hw, arvif->vdev_id);\n}\n\nstatic void ath10k_mac_vif_handle_tx_pause(struct ath10k_vif *arvif,\n\t\t\t\t\t   enum wmi_tlv_tx_pause_id pause_id,\n\t\t\t\t\t   enum wmi_tlv_tx_pause_action action)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->htt.tx_lock);\n\n\tswitch (action) {\n\tcase WMI_TLV_TX_PAUSE_ACTION_STOP:\n\t\tath10k_mac_vif_tx_lock(arvif, pause_id);\n\t\tbreak;\n\tcase WMI_TLV_TX_PAUSE_ACTION_WAKE:\n\t\tath10k_mac_vif_tx_unlock(arvif, pause_id);\n\t\tbreak;\n\tdefault:\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"received unknown tx pause action %d on vdev %i, ignoring\\n\",\n\t\t\t    action, arvif->vdev_id);\n\t\tbreak;\n\t}\n}\n\nstruct ath10k_mac_tx_pause {\n\tu32 vdev_id;\n\tenum wmi_tlv_tx_pause_id pause_id;\n\tenum wmi_tlv_tx_pause_action action;\n};\n\nstatic void ath10k_mac_handle_tx_pause_iter(void *data, u8 *mac,\n\t\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_mac_tx_pause *arg = data;\n\n\tif (arvif->vdev_id != arg->vdev_id)\n\t\treturn;\n\n\tath10k_mac_vif_handle_tx_pause(arvif, arg->pause_id, arg->action);\n}\n\nvoid ath10k_mac_handle_tx_pause_vdev(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t     enum wmi_tlv_tx_pause_id pause_id,\n\t\t\t\t     enum wmi_tlv_tx_pause_action action)\n{\n\tstruct ath10k_mac_tx_pause arg = {\n\t\t.vdev_id = vdev_id,\n\t\t.pause_id = pause_id,\n\t\t.action = action,\n\t};\n\n\tspin_lock_bh(&ar->htt.tx_lock);\n\tieee80211_iterate_active_interfaces_atomic(ar->hw,\n\t\t\t\t\t\t   ATH10K_ITER_RESUME_FLAGS,\n\t\t\t\t\t\t   ath10k_mac_handle_tx_pause_iter,\n\t\t\t\t\t\t   &arg);\n\tspin_unlock_bh(&ar->htt.tx_lock);\n}\n\nstatic enum ath10k_hw_txrx_mode\nath10k_mac_tx_h_get_txmode(struct ath10k *ar,\n\t\t\t   struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta,\n\t\t\t   struct sk_buff *skb)\n{\n\tconst struct ieee80211_hdr *hdr = (void *)skb->data;\n\tconst struct ath10k_skb_cb *skb_cb = ATH10K_SKB_CB(skb);\n\t__le16 fc = hdr->frame_control;\n\n\tif (!vif || vif->type == NL80211_IFTYPE_MONITOR)\n\t\treturn ATH10K_HW_TXRX_RAW;\n\n\tif (ieee80211_is_mgmt(fc))\n\t\treturn ATH10K_HW_TXRX_MGMT;\n\n\t/* Workaround:\n\t *\n\t * NullFunc frames are mostly used to ping if a client or AP are still\n\t * reachable and responsive. This implies tx status reports must be\n\t * accurate - otherwise either mac80211 or userspace (e.g. hostapd) can\n\t * come to a conclusion that the other end disappeared and tear down\n\t * BSS connection or it can never disconnect from BSS/client (which is\n\t * the case).\n\t *\n\t * Firmware with HTT older than 3.0 delivers incorrect tx status for\n\t * NullFunc frames to driver. However there's a HTT Mgmt Tx command\n\t * which seems to deliver correct tx reports for NullFunc frames. The\n\t * downside of using it is it ignores client powersave state so it can\n\t * end up disconnecting sleeping clients in AP mode. It should fix STA\n\t * mode though because AP don't sleep.\n\t */\n\tif (ar->htt.target_version_major < 3 &&\n\t    (ieee80211_is_nullfunc(fc) || ieee80211_is_qos_nullfunc(fc)) &&\n\t    !test_bit(ATH10K_FW_FEATURE_HAS_WMI_MGMT_TX,\n\t\t      ar->running_fw->fw_file.fw_features))\n\t\treturn ATH10K_HW_TXRX_MGMT;\n\n\t/* Workaround:\n\t *\n\t * Some wmi-tlv firmwares for qca6174 have broken Tx key selection for\n\t * NativeWifi txmode - it selects AP key instead of peer key. It seems\n\t * to work with Ethernet txmode so use it.\n\t *\n\t * FIXME: Check if raw mode works with TDLS.\n\t */\n\tif (ieee80211_is_data_present(fc) && sta && sta->tdls)\n\t\treturn ATH10K_HW_TXRX_ETHERNET;\n\n\tif (test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags) ||\n\t    skb_cb->flags & ATH10K_SKB_F_RAW_TX)\n\t\treturn ATH10K_HW_TXRX_RAW;\n\n\treturn ATH10K_HW_TXRX_NATIVE_WIFI;\n}\n\nstatic bool ath10k_tx_h_use_hwcrypto(struct ieee80211_vif *vif,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tconst struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tconst struct ieee80211_hdr *hdr = (void *)skb->data;\n\tconst u32 mask = IEEE80211_TX_INTFL_DONT_ENCRYPT |\n\t\t\t IEEE80211_TX_CTL_INJECTED;\n\n\tif (!ieee80211_has_protected(hdr->frame_control))\n\t\treturn false;\n\n\tif ((info->flags & mask) == mask)\n\t\treturn false;\n\n\tif (vif)\n\t\treturn !((struct ath10k_vif *)vif->drv_priv)->nohwcrypt;\n\n\treturn true;\n}\n\n/* HTT Tx uses Native Wifi tx mode which expects 802.11 frames without QoS\n * Control in the header.\n */\nstatic void ath10k_tx_h_nwifi(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct ath10k_skb_cb *cb = ATH10K_SKB_CB(skb);\n\tu8 *qos_ctl;\n\n\tif (!ieee80211_is_data_qos(hdr->frame_control))\n\t\treturn;\n\n\tqos_ctl = ieee80211_get_qos_ctl(hdr);\n\tmemmove(skb->data + IEEE80211_QOS_CTL_LEN,\n\t\tskb->data, (void *)qos_ctl - (void *)skb->data);\n\tskb_pull(skb, IEEE80211_QOS_CTL_LEN);\n\n\t/* Some firmware revisions don't handle sending QoS NullFunc well.\n\t * These frames are mainly used for CQM purposes so it doesn't really\n\t * matter whether QoS NullFunc or NullFunc are sent.\n\t */\n\thdr = (void *)skb->data;\n\tif (ieee80211_is_qos_nullfunc(hdr->frame_control))\n\t\tcb->flags &= ~ATH10K_SKB_F_QOS;\n\n\thdr->frame_control &= ~__cpu_to_le16(IEEE80211_STYPE_QOS_DATA);\n}\n\nstatic void ath10k_tx_h_8023(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr;\n\tstruct rfc1042_hdr *rfc1042;\n\tstruct ethhdr *eth;\n\tsize_t hdrlen;\n\tu8 da[ETH_ALEN];\n\tu8 sa[ETH_ALEN];\n\t__be16 type;\n\n\thdr = (void *)skb->data;\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\trfc1042 = (void *)skb->data + hdrlen;\n\n\tether_addr_copy(da, ieee80211_get_DA(hdr));\n\tether_addr_copy(sa, ieee80211_get_SA(hdr));\n\ttype = rfc1042->snap_type;\n\n\tskb_pull(skb, hdrlen + sizeof(*rfc1042));\n\tskb_push(skb, sizeof(*eth));\n\n\teth = (void *)skb->data;\n\tether_addr_copy(eth->h_dest, da);\n\tether_addr_copy(eth->h_source, sa);\n\teth->h_proto = type;\n}\n\nstatic void ath10k_tx_h_add_p2p_noa_ie(struct ath10k *ar,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\n\t/* This is case only for P2P_GO */\n\tif (vif->type != NL80211_IFTYPE_AP || !vif->p2p)\n\t\treturn;\n\n\tif (unlikely(ieee80211_is_probe_resp(hdr->frame_control))) {\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tif (arvif->u.ap.noa_data)\n\t\t\tif (!pskb_expand_head(skb, 0, arvif->u.ap.noa_len,\n\t\t\t\t\t      GFP_ATOMIC))\n\t\t\t\tskb_put_data(skb, arvif->u.ap.noa_data,\n\t\t\t\t\t     arvif->u.ap.noa_len);\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n}\n\nstatic void ath10k_mac_tx_h_fill_cb(struct ath10k *ar,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_txq *txq,\n\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t    struct sk_buff *skb, u16 airtime)\n{\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct ath10k_skb_cb *cb = ATH10K_SKB_CB(skb);\n\tconst struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tbool is_data = ieee80211_is_data(hdr->frame_control) ||\n\t\t\tieee80211_is_data_qos(hdr->frame_control);\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_sta *arsta;\n\tu8 tid, *qos_ctl;\n\tbool noack = false;\n\n\tcb->flags = 0;\n\tif (!ath10k_tx_h_use_hwcrypto(vif, skb))\n\t\tcb->flags |= ATH10K_SKB_F_NO_HWCRYPT;\n\n\tif (ieee80211_is_mgmt(hdr->frame_control))\n\t\tcb->flags |= ATH10K_SKB_F_MGMT;\n\n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tcb->flags |= ATH10K_SKB_F_QOS;\n\t\tqos_ctl = ieee80211_get_qos_ctl(hdr);\n\t\ttid = (*qos_ctl) & IEEE80211_QOS_CTL_TID_MASK;\n\n\t\tif (arvif->noack[tid] == WMI_PEER_TID_CONFIG_NOACK)\n\t\t\tnoack = true;\n\n\t\tif (sta) {\n\t\t\tarsta = (struct ath10k_sta *)sta->drv_priv;\n\n\t\t\tif (arsta->noack[tid] == WMI_PEER_TID_CONFIG_NOACK)\n\t\t\t\tnoack = true;\n\n\t\t\tif (arsta->noack[tid] == WMI_PEER_TID_CONFIG_ACK)\n\t\t\t\tnoack = false;\n\t\t}\n\n\t\tif (noack)\n\t\t\tcb->flags |= ATH10K_SKB_F_NOACK_TID;\n\t}\n\n\t/* Data frames encrypted in software will be posted to firmware\n\t * with tx encap mode set to RAW. Ex: Multicast traffic generated\n\t * for a specific VLAN group will always be encrypted in software.\n\t */\n\tif (is_data && ieee80211_has_protected(hdr->frame_control) &&\n\t    !info->control.hw_key) {\n\t\tcb->flags |= ATH10K_SKB_F_NO_HWCRYPT;\n\t\tcb->flags |= ATH10K_SKB_F_RAW_TX;\n\t}\n\n\tcb->vif = vif;\n\tcb->txq = txq;\n\tcb->airtime_est = airtime;\n\tif (sta) {\n\t\tarsta = (struct ath10k_sta *)sta->drv_priv;\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tcb->ucast_cipher = arsta->ucast_cipher;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n}\n\nbool ath10k_mac_tx_frm_has_freq(struct ath10k *ar)\n{\n\t/* FIXME: Not really sure since when the behaviour changed. At some\n\t * point new firmware stopped requiring creation of peer entries for\n\t * offchannel tx (and actually creating them causes issues with wmi-htc\n\t * tx credit replenishment and reliability). Assuming it's at least 3.4\n\t * because that's when the `freq` was introduced to TX_FRM HTT command.\n\t */\n\treturn (ar->htt.target_version_major >= 3 &&\n\t\tar->htt.target_version_minor >= 4 &&\n\t\tar->running_fw->fw_file.htt_op_version == ATH10K_FW_HTT_OP_VERSION_TLV);\n}\n\nstatic int ath10k_mac_tx_wmi_mgmt(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct sk_buff_head *q = &ar->wmi_mgmt_tx_queue;\n\n\tif (skb_queue_len_lockless(q) >= ATH10K_MAX_NUM_MGMT_PENDING) {\n\t\tath10k_warn(ar, \"wmi mgmt tx queue is full\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tskb_queue_tail(q, skb);\n\tieee80211_queue_work(ar->hw, &ar->wmi_mgmt_tx_work);\n\n\treturn 0;\n}\n\nstatic enum ath10k_mac_tx_path\nath10k_mac_tx_h_get_txpath(struct ath10k *ar,\n\t\t\t   struct sk_buff *skb,\n\t\t\t   enum ath10k_hw_txrx_mode txmode)\n{\n\tswitch (txmode) {\n\tcase ATH10K_HW_TXRX_RAW:\n\tcase ATH10K_HW_TXRX_NATIVE_WIFI:\n\tcase ATH10K_HW_TXRX_ETHERNET:\n\t\treturn ATH10K_MAC_TX_HTT;\n\tcase ATH10K_HW_TXRX_MGMT:\n\t\tif (test_bit(ATH10K_FW_FEATURE_HAS_WMI_MGMT_TX,\n\t\t\t     ar->running_fw->fw_file.fw_features) ||\n\t\t\t     test_bit(WMI_SERVICE_MGMT_TX_WMI,\n\t\t\t\t      ar->wmi.svc_map))\n\t\t\treturn ATH10K_MAC_TX_WMI_MGMT;\n\t\telse if (ar->htt.target_version_major >= 3)\n\t\t\treturn ATH10K_MAC_TX_HTT;\n\t\telse\n\t\t\treturn ATH10K_MAC_TX_HTT_MGMT;\n\t}\n\n\treturn ATH10K_MAC_TX_UNKNOWN;\n}\n\nstatic int ath10k_mac_tx_submit(struct ath10k *ar,\n\t\t\t\tenum ath10k_hw_txrx_mode txmode,\n\t\t\t\tenum ath10k_mac_tx_path txpath,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct ath10k_htt *htt = &ar->htt;\n\tint ret = -EINVAL;\n\n\tswitch (txpath) {\n\tcase ATH10K_MAC_TX_HTT:\n\t\tret = ath10k_htt_tx(htt, txmode, skb);\n\t\tbreak;\n\tcase ATH10K_MAC_TX_HTT_MGMT:\n\t\tret = ath10k_htt_mgmt_tx(htt, skb);\n\t\tbreak;\n\tcase ATH10K_MAC_TX_WMI_MGMT:\n\t\tret = ath10k_mac_tx_wmi_mgmt(ar, skb);\n\t\tbreak;\n\tcase ATH10K_MAC_TX_UNKNOWN:\n\t\tWARN_ON_ONCE(1);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to transmit packet, dropping: %d\\n\",\n\t\t\t    ret);\n\t\tieee80211_free_txskb(ar->hw, skb);\n\t}\n\n\treturn ret;\n}\n\n/* This function consumes the sk_buff regardless of return value as far as\n * caller is concerned so no freeing is necessary afterwards.\n */\nstatic int ath10k_mac_tx(struct ath10k *ar,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t enum ath10k_hw_txrx_mode txmode,\n\t\t\t enum ath10k_mac_tx_path txpath,\n\t\t\t struct sk_buff *skb, bool noque_offchan)\n{\n\tstruct ieee80211_hw *hw = ar->hw;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tconst struct ath10k_skb_cb *skb_cb = ATH10K_SKB_CB(skb);\n\tint ret;\n\n\t/* We should disable CCK RATE due to P2P */\n\tif (info->flags & IEEE80211_TX_CTL_NO_CCK_RATE)\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"IEEE80211_TX_CTL_NO_CCK_RATE\\n\");\n\n\tswitch (txmode) {\n\tcase ATH10K_HW_TXRX_MGMT:\n\tcase ATH10K_HW_TXRX_NATIVE_WIFI:\n\t\tath10k_tx_h_nwifi(hw, skb);\n\t\tath10k_tx_h_add_p2p_noa_ie(ar, vif, skb);\n\t\tath10k_tx_h_seq_no(vif, skb);\n\t\tbreak;\n\tcase ATH10K_HW_TXRX_ETHERNET:\n\t\tath10k_tx_h_8023(skb);\n\t\tbreak;\n\tcase ATH10K_HW_TXRX_RAW:\n\t\tif (!test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags) &&\n\t\t    !(skb_cb->flags & ATH10K_SKB_F_RAW_TX)) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tieee80211_free_txskb(hw, skb);\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\tif (!noque_offchan && info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) {\n\t\tif (!ath10k_mac_tx_frm_has_freq(ar)) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac queued offchannel skb %pK len %d\\n\",\n\t\t\t\t   skb, skb->len);\n\n\t\t\tskb_queue_tail(&ar->offchan_tx_queue, skb);\n\t\t\tieee80211_queue_work(hw, &ar->offchan_tx_work);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = ath10k_mac_tx_submit(ar, txmode, txpath, skb);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to submit frame: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid ath10k_offchan_tx_purge(struct ath10k *ar)\n{\n\tstruct sk_buff *skb;\n\n\tfor (;;) {\n\t\tskb = skb_dequeue(&ar->offchan_tx_queue);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tieee80211_free_txskb(ar->hw, skb);\n\t}\n}\n\nvoid ath10k_offchan_tx_work(struct work_struct *work)\n{\n\tstruct ath10k *ar = container_of(work, struct ath10k, offchan_tx_work);\n\tstruct ath10k_peer *peer;\n\tstruct ath10k_vif *arvif;\n\tenum ath10k_hw_txrx_mode txmode;\n\tenum ath10k_mac_tx_path txpath;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_sta *sta;\n\tstruct sk_buff *skb;\n\tconst u8 *peer_addr;\n\tint vdev_id;\n\tint ret;\n\tunsigned long time_left;\n\tbool tmp_peer_created = false;\n\n\t/* FW requirement: We must create a peer before FW will send out\n\t * an offchannel frame. Otherwise the frame will be stuck and\n\t * never transmitted. We delete the peer upon tx completion.\n\t * It is unlikely that a peer for offchannel tx will already be\n\t * present. However it may be in some rare cases so account for that.\n\t * Otherwise we might remove a legitimate peer and break stuff.\n\t */\n\n\tfor (;;) {\n\t\tskb = skb_dequeue(&ar->offchan_tx_queue);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tmutex_lock(&ar->conf_mutex);\n\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac offchannel skb %pK len %d\\n\",\n\t\t\t   skb, skb->len);\n\n\t\thdr = (struct ieee80211_hdr *)skb->data;\n\t\tpeer_addr = ieee80211_get_DA(hdr);\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tvdev_id = ar->scan.vdev_id;\n\t\tpeer = ath10k_peer_find(ar, vdev_id, peer_addr);\n\t\tspin_unlock_bh(&ar->data_lock);\n\n\t\tif (peer)\n\t\t\tath10k_warn(ar, \"peer %pM on vdev %d already present\\n\",\n\t\t\t\t    peer_addr, vdev_id);\n\n\t\tif (!peer) {\n\t\t\tret = ath10k_peer_create(ar, NULL, NULL, vdev_id,\n\t\t\t\t\t\t peer_addr,\n\t\t\t\t\t\t WMI_PEER_TYPE_DEFAULT);\n\t\t\tif (ret)\n\t\t\t\tath10k_warn(ar, \"failed to create peer %pM on vdev %d: %d\\n\",\n\t\t\t\t\t    peer_addr, vdev_id, ret);\n\t\t\ttmp_peer_created = (ret == 0);\n\t\t}\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\treinit_completion(&ar->offchan_tx_completed);\n\t\tar->offchan_tx_skb = skb;\n\t\tspin_unlock_bh(&ar->data_lock);\n\n\t\t/* It's safe to access vif and sta - conf_mutex guarantees that\n\t\t * sta_state() and remove_interface() are locked exclusively\n\t\t * out wrt to this offchannel worker.\n\t\t */\n\t\tarvif = ath10k_get_arvif(ar, vdev_id);\n\t\tif (arvif) {\n\t\t\tvif = arvif->vif;\n\t\t\tsta = ieee80211_find_sta(vif, peer_addr);\n\t\t} else {\n\t\t\tvif = NULL;\n\t\t\tsta = NULL;\n\t\t}\n\n\t\ttxmode = ath10k_mac_tx_h_get_txmode(ar, vif, sta, skb);\n\t\ttxpath = ath10k_mac_tx_h_get_txpath(ar, skb, txmode);\n\n\t\tret = ath10k_mac_tx(ar, vif, txmode, txpath, skb, true);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to transmit offchannel frame: %d\\n\",\n\t\t\t\t    ret);\n\t\t\t/* not serious */\n\t\t}\n\n\t\ttime_left =\n\t\twait_for_completion_timeout(&ar->offchan_tx_completed, 3 * HZ);\n\t\tif (time_left == 0)\n\t\t\tath10k_warn(ar, \"timed out waiting for offchannel skb %pK, len: %d\\n\",\n\t\t\t\t    skb, skb->len);\n\n\t\tif (!peer && tmp_peer_created) {\n\t\t\tret = ath10k_peer_delete(ar, vdev_id, peer_addr);\n\t\t\tif (ret)\n\t\t\t\tath10k_warn(ar, \"failed to delete peer %pM on vdev %d: %d\\n\",\n\t\t\t\t\t    peer_addr, vdev_id, ret);\n\t\t}\n\n\t\tmutex_unlock(&ar->conf_mutex);\n\t}\n}\n\nvoid ath10k_mgmt_over_wmi_tx_purge(struct ath10k *ar)\n{\n\tstruct sk_buff *skb;\n\n\tfor (;;) {\n\t\tskb = skb_dequeue(&ar->wmi_mgmt_tx_queue);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tieee80211_free_txskb(ar->hw, skb);\n\t}\n}\n\nvoid ath10k_mgmt_over_wmi_tx_work(struct work_struct *work)\n{\n\tstruct ath10k *ar = container_of(work, struct ath10k, wmi_mgmt_tx_work);\n\tstruct sk_buff *skb;\n\tdma_addr_t paddr;\n\tint ret;\n\n\tfor (;;) {\n\t\tskb = skb_dequeue(&ar->wmi_mgmt_tx_queue);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tif (test_bit(ATH10K_FW_FEATURE_MGMT_TX_BY_REF,\n\t\t\t     ar->running_fw->fw_file.fw_features)) {\n\t\t\tpaddr = dma_map_single(ar->dev, skb->data,\n\t\t\t\t\t       skb->len, DMA_TO_DEVICE);\n\t\t\tif (dma_mapping_error(ar->dev, paddr)) {\n\t\t\t\tieee80211_free_txskb(ar->hw, skb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tret = ath10k_wmi_mgmt_tx_send(ar, skb, paddr);\n\t\t\tif (ret) {\n\t\t\t\tath10k_warn(ar, \"failed to transmit management frame by ref via WMI: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\t/* remove this msdu from idr tracking */\n\t\t\t\tath10k_wmi_cleanup_mgmt_tx_send(ar, skb);\n\n\t\t\t\tdma_unmap_single(ar->dev, paddr, skb->len,\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\tieee80211_free_txskb(ar->hw, skb);\n\t\t\t}\n\t\t} else {\n\t\t\tret = ath10k_wmi_mgmt_tx(ar, skb);\n\t\t\tif (ret) {\n\t\t\t\tath10k_warn(ar, \"failed to transmit management frame via WMI: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\tieee80211_free_txskb(ar->hw, skb);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void ath10k_mac_txq_init(struct ieee80211_txq *txq)\n{\n\tstruct ath10k_txq *artxq;\n\n\tif (!txq)\n\t\treturn;\n\n\tartxq = (void *)txq->drv_priv;\n\tINIT_LIST_HEAD(&artxq->list);\n}\n\nstatic void ath10k_mac_txq_unref(struct ath10k *ar, struct ieee80211_txq *txq)\n{\n\tstruct ath10k_skb_cb *cb;\n\tstruct sk_buff *msdu;\n\tint msdu_id;\n\n\tif (!txq)\n\t\treturn;\n\n\tspin_lock_bh(&ar->htt.tx_lock);\n\tidr_for_each_entry(&ar->htt.pending_tx, msdu, msdu_id) {\n\t\tcb = ATH10K_SKB_CB(msdu);\n\t\tif (cb->txq == txq)\n\t\t\tcb->txq = NULL;\n\t}\n\tspin_unlock_bh(&ar->htt.tx_lock);\n}\n\nstruct ieee80211_txq *ath10k_mac_txq_lookup(struct ath10k *ar,\n\t\t\t\t\t    u16 peer_id,\n\t\t\t\t\t    u8 tid)\n{\n\tstruct ath10k_peer *peer;\n\n\tlockdep_assert_held(&ar->data_lock);\n\n\tpeer = ar->peer_map[peer_id];\n\tif (!peer)\n\t\treturn NULL;\n\n\tif (peer->removed)\n\t\treturn NULL;\n\n\tif (peer->sta)\n\t\treturn peer->sta->txq[tid];\n\telse if (peer->vif)\n\t\treturn peer->vif->txq;\n\telse\n\t\treturn NULL;\n}\n\nstatic bool ath10k_mac_tx_can_push(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_txq *txq)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_txq *artxq = (void *)txq->drv_priv;\n\n\t/* No need to get locks */\n\tif (ar->htt.tx_q_state.mode == HTT_TX_MODE_SWITCH_PUSH)\n\t\treturn true;\n\n\tif (ar->htt.num_pending_tx < ar->htt.tx_q_state.num_push_allowed)\n\t\treturn true;\n\n\tif (artxq->num_fw_queued < artxq->num_push_allowed)\n\t\treturn true;\n\n\treturn false;\n}\n\n/* Return estimated airtime in microsecond, which is calculated using last\n * reported TX rate. This is just a rough estimation because host driver has no\n * knowledge of the actual transmit rate, retries or aggregation. If actual\n * airtime can be reported by firmware, then delta between estimated and actual\n * airtime can be adjusted from deficit.\n */\n#define IEEE80211_ATF_OVERHEAD\t\t100\t/* IFS + some slot time */\n#define IEEE80211_ATF_OVERHEAD_IFS\t16\t/* IFS only */\nstatic u16 ath10k_mac_update_airtime(struct ath10k *ar,\n\t\t\t\t     struct ieee80211_txq *txq,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ath10k_sta *arsta;\n\tu32 pktlen;\n\tu16 airtime = 0;\n\n\tif (!txq || !txq->sta)\n\t\treturn airtime;\n\n\tif (test_bit(WMI_SERVICE_REPORT_AIRTIME, ar->wmi.svc_map))\n\t\treturn airtime;\n\n\tspin_lock_bh(&ar->data_lock);\n\tarsta = (struct ath10k_sta *)txq->sta->drv_priv;\n\n\tpktlen = skb->len + 38; /* Assume MAC header 30, SNAP 8 for most case */\n\tif (arsta->last_tx_bitrate) {\n\t\t/* airtime in us, last_tx_bitrate in 100kbps */\n\t\tairtime = (pktlen * 8 * (1000 / 100))\n\t\t\t\t/ arsta->last_tx_bitrate;\n\t\t/* overhead for media access time and IFS */\n\t\tairtime += IEEE80211_ATF_OVERHEAD_IFS;\n\t} else {\n\t\t/* This is mostly for throttle excessive BC/MC frames, and the\n\t\t * airtime/rate doesn't need be exact. Airtime of BC/MC frames\n\t\t * in 2G get some discount, which helps prevent very low rate\n\t\t * frames from being blocked for too long.\n\t\t */\n\t\tairtime = (pktlen * 8 * (1000 / 100)) / 60; /* 6M */\n\t\tairtime += IEEE80211_ATF_OVERHEAD;\n\t}\n\tspin_unlock_bh(&ar->data_lock);\n\n\treturn airtime;\n}\n\nint ath10k_mac_tx_push_txq(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_txq *txq)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_htt *htt = &ar->htt;\n\tstruct ath10k_txq *artxq = (void *)txq->drv_priv;\n\tstruct ieee80211_vif *vif = txq->vif;\n\tstruct ieee80211_sta *sta = txq->sta;\n\tenum ath10k_hw_txrx_mode txmode;\n\tenum ath10k_mac_tx_path txpath;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tsize_t skb_len;\n\tbool is_mgmt, is_presp;\n\tint ret;\n\tu16 airtime;\n\n\tspin_lock_bh(&ar->htt.tx_lock);\n\tret = ath10k_htt_tx_inc_pending(htt);\n\tspin_unlock_bh(&ar->htt.tx_lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\tskb = ieee80211_tx_dequeue_ni(hw, txq);\n\tif (!skb) {\n\t\tspin_lock_bh(&ar->htt.tx_lock);\n\t\tath10k_htt_tx_dec_pending(htt);\n\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\n\t\treturn -ENOENT;\n\t}\n\n\tairtime = ath10k_mac_update_airtime(ar, txq, skb);\n\tath10k_mac_tx_h_fill_cb(ar, vif, txq, sta, skb, airtime);\n\n\tskb_len = skb->len;\n\ttxmode = ath10k_mac_tx_h_get_txmode(ar, vif, sta, skb);\n\ttxpath = ath10k_mac_tx_h_get_txpath(ar, skb, txmode);\n\tis_mgmt = (txpath == ATH10K_MAC_TX_HTT_MGMT);\n\n\tif (is_mgmt) {\n\t\thdr = (struct ieee80211_hdr *)skb->data;\n\t\tis_presp = ieee80211_is_probe_resp(hdr->frame_control);\n\n\t\tspin_lock_bh(&ar->htt.tx_lock);\n\t\tret = ath10k_htt_tx_mgmt_inc_pending(htt, is_mgmt, is_presp);\n\n\t\tif (ret) {\n\t\t\tath10k_htt_tx_dec_pending(htt);\n\t\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\t\t\treturn ret;\n\t\t}\n\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\t}\n\n\tret = ath10k_mac_tx(ar, vif, txmode, txpath, skb, false);\n\tif (unlikely(ret)) {\n\t\tath10k_warn(ar, \"failed to push frame: %d\\n\", ret);\n\n\t\tspin_lock_bh(&ar->htt.tx_lock);\n\t\tath10k_htt_tx_dec_pending(htt);\n\t\tif (is_mgmt)\n\t\t\tath10k_htt_tx_mgmt_dec_pending(htt);\n\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\n\t\treturn ret;\n\t}\n\n\tspin_lock_bh(&ar->htt.tx_lock);\n\tartxq->num_fw_queued++;\n\tspin_unlock_bh(&ar->htt.tx_lock);\n\n\treturn skb_len;\n}\n\nstatic int ath10k_mac_schedule_txq(struct ieee80211_hw *hw, u32 ac)\n{\n\tstruct ieee80211_txq *txq;\n\tint ret = 0;\n\n\tieee80211_txq_schedule_start(hw, ac);\n\twhile ((txq = ieee80211_next_txq(hw, ac))) {\n\t\twhile (ath10k_mac_tx_can_push(hw, txq)) {\n\t\t\tret = ath10k_mac_tx_push_txq(hw, txq);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tieee80211_return_txq(hw, txq, false);\n\t\tath10k_htt_tx_txq_update(hw, txq);\n\t\tif (ret == -EBUSY)\n\t\t\tbreak;\n\t}\n\tieee80211_txq_schedule_end(hw, ac);\n\n\treturn ret;\n}\n\nvoid ath10k_mac_tx_push_pending(struct ath10k *ar)\n{\n\tstruct ieee80211_hw *hw = ar->hw;\n\tu32 ac;\n\n\tif (ar->htt.tx_q_state.mode != HTT_TX_MODE_SWITCH_PUSH)\n\t\treturn;\n\n\tif (ar->htt.num_pending_tx >= (ar->htt.max_num_pending_tx / 2))\n\t\treturn;\n\n\trcu_read_lock();\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tif (ath10k_mac_schedule_txq(hw, ac) == -EBUSY)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(ath10k_mac_tx_push_pending);\n\n/************/\n/* Scanning */\n/************/\n\nvoid __ath10k_scan_finish(struct ath10k *ar)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH10K_SCAN_IDLE:\n\t\tbreak;\n\tcase ATH10K_SCAN_RUNNING:\n\tcase ATH10K_SCAN_ABORTING:\n\t\tif (!ar->scan.is_roc) {\n\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t.aborted = (ar->scan.state ==\n\t\t\t\t\t    ATH10K_SCAN_ABORTING),\n\t\t\t};\n\n\t\t\tieee80211_scan_completed(ar->hw, &info);\n\t\t} else if (ar->scan.roc_notify) {\n\t\t\tieee80211_remain_on_channel_expired(ar->hw);\n\t\t}\n\t\tfallthrough;\n\tcase ATH10K_SCAN_STARTING:\n\t\tar->scan.state = ATH10K_SCAN_IDLE;\n\t\tar->scan_channel = NULL;\n\t\tar->scan.roc_freq = 0;\n\t\tath10k_offchan_tx_purge(ar);\n\t\tcancel_delayed_work(&ar->scan.timeout);\n\t\tcomplete(&ar->scan.completed);\n\t\tbreak;\n\t}\n}\n\nvoid ath10k_scan_finish(struct ath10k *ar)\n{\n\tspin_lock_bh(&ar->data_lock);\n\t__ath10k_scan_finish(ar);\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nstatic int ath10k_scan_stop(struct ath10k *ar)\n{\n\tstruct wmi_stop_scan_arg arg = {\n\t\t.req_id = 1, /* FIXME */\n\t\t.req_type = WMI_SCAN_STOP_ONE,\n\t\t.u.scan_id = ATH10K_SCAN_ID,\n\t};\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_wmi_stop_scan(ar, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to stop wmi scan: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = wait_for_completion_timeout(&ar->scan.completed, 3 * HZ);\n\tif (ret == 0) {\n\t\tath10k_warn(ar, \"failed to receive scan abortion completion: timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t} else if (ret > 0) {\n\t\tret = 0;\n\t}\n\nout:\n\t/* Scan state should be updated upon scan completion but in case\n\t * firmware fails to deliver the event (for whatever reason) it is\n\t * desired to clean up scan state anyway. Firmware may have just\n\t * dropped the scan completion event delivery due to transport pipe\n\t * being overflown with data and/or it can recover on its own before\n\t * next scan request is submitted.\n\t */\n\tspin_lock_bh(&ar->data_lock);\n\tif (ar->scan.state != ATH10K_SCAN_IDLE)\n\t\t__ath10k_scan_finish(ar);\n\tspin_unlock_bh(&ar->data_lock);\n\n\treturn ret;\n}\n\nstatic void ath10k_scan_abort(struct ath10k *ar)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH10K_SCAN_IDLE:\n\t\t/* This can happen if timeout worker kicked in and called\n\t\t * abortion while scan completion was being processed.\n\t\t */\n\t\tbreak;\n\tcase ATH10K_SCAN_STARTING:\n\tcase ATH10K_SCAN_ABORTING:\n\t\tath10k_warn(ar, \"refusing scan abortion due to invalid scan state: %s (%d)\\n\",\n\t\t\t    ath10k_scan_state_str(ar->scan.state),\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH10K_SCAN_RUNNING:\n\t\tar->scan.state = ATH10K_SCAN_ABORTING;\n\t\tspin_unlock_bh(&ar->data_lock);\n\n\t\tret = ath10k_scan_stop(ar);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to abort scan: %d\\n\", ret);\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tbreak;\n\t}\n\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nvoid ath10k_scan_timeout_work(struct work_struct *work)\n{\n\tstruct ath10k *ar = container_of(work, struct ath10k,\n\t\t\t\t\t scan.timeout.work);\n\n\tmutex_lock(&ar->conf_mutex);\n\tath10k_scan_abort(ar);\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic int ath10k_start_scan(struct ath10k *ar,\n\t\t\t     const struct wmi_start_scan_arg *arg)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_wmi_start_scan(ar, arg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_for_completion_timeout(&ar->scan.started, 1 * HZ);\n\tif (ret == 0) {\n\t\tret = ath10k_scan_stop(ar);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to stop scan: %d\\n\", ret);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t/* If we failed to start the scan, return error code at\n\t * this point.  This is probably due to some issue in the\n\t * firmware, but no need to wedge the driver due to that...\n\t */\n\tspin_lock_bh(&ar->data_lock);\n\tif (ar->scan.state == ATH10K_SCAN_IDLE) {\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock_bh(&ar->data_lock);\n\n\treturn 0;\n}\n\n/**********************/\n/* mac80211 callbacks */\n/**********************/\n\nstatic void ath10k_mac_op_tx(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_tx_control *control,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_htt *htt = &ar->htt;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct ieee80211_sta *sta = control->sta;\n\tstruct ieee80211_txq *txq = NULL;\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tenum ath10k_hw_txrx_mode txmode;\n\tenum ath10k_mac_tx_path txpath;\n\tbool is_htt;\n\tbool is_mgmt;\n\tbool is_presp;\n\tint ret;\n\tu16 airtime;\n\n\tairtime = ath10k_mac_update_airtime(ar, txq, skb);\n\tath10k_mac_tx_h_fill_cb(ar, vif, txq, sta, skb, airtime);\n\n\ttxmode = ath10k_mac_tx_h_get_txmode(ar, vif, sta, skb);\n\ttxpath = ath10k_mac_tx_h_get_txpath(ar, skb, txmode);\n\tis_htt = (txpath == ATH10K_MAC_TX_HTT ||\n\t\t  txpath == ATH10K_MAC_TX_HTT_MGMT);\n\tis_mgmt = (txpath == ATH10K_MAC_TX_HTT_MGMT);\n\n\tif (is_htt) {\n\t\tspin_lock_bh(&ar->htt.tx_lock);\n\t\tis_presp = ieee80211_is_probe_resp(hdr->frame_control);\n\n\t\tret = ath10k_htt_tx_inc_pending(htt);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to increase tx pending count: %d, dropping\\n\",\n\t\t\t\t    ret);\n\t\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\t\t\tieee80211_free_txskb(ar->hw, skb);\n\t\t\treturn;\n\t\t}\n\n\t\tret = ath10k_htt_tx_mgmt_inc_pending(htt, is_mgmt, is_presp);\n\t\tif (ret) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"failed to increase tx mgmt pending count: %d, dropping\\n\",\n\t\t\t\t   ret);\n\t\t\tath10k_htt_tx_dec_pending(htt);\n\t\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\t\t\tieee80211_free_txskb(ar->hw, skb);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\t}\n\n\tret = ath10k_mac_tx(ar, vif, txmode, txpath, skb, false);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to transmit frame: %d\\n\", ret);\n\t\tif (is_htt) {\n\t\t\tspin_lock_bh(&ar->htt.tx_lock);\n\t\t\tath10k_htt_tx_dec_pending(htt);\n\t\t\tif (is_mgmt)\n\t\t\t\tath10k_htt_tx_mgmt_dec_pending(htt);\n\t\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\t\t}\n\t\treturn;\n\t}\n}\n\nstatic void ath10k_mac_op_wake_tx_queue(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_txq *txq)\n{\n\tstruct ath10k *ar = hw->priv;\n\tint ret;\n\tu8 ac;\n\n\tath10k_htt_tx_txq_update(hw, txq);\n\tif (ar->htt.tx_q_state.mode != HTT_TX_MODE_SWITCH_PUSH)\n\t\treturn;\n\n\tac = txq->ac;\n\tieee80211_txq_schedule_start(hw, ac);\n\ttxq = ieee80211_next_txq(hw, ac);\n\tif (!txq)\n\t\tgoto out;\n\n\twhile (ath10k_mac_tx_can_push(hw, txq)) {\n\t\tret = ath10k_mac_tx_push_txq(hw, txq);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tieee80211_return_txq(hw, txq, false);\n\tath10k_htt_tx_txq_update(hw, txq);\nout:\n\tieee80211_txq_schedule_end(hw, ac);\n}\n\n/* Must not be called with conf_mutex held as workers can use that also. */\nvoid ath10k_drain_tx(struct ath10k *ar)\n{\n\t/* make sure rcu-protected mac80211 tx path itself is drained */\n\tsynchronize_net();\n\n\tath10k_offchan_tx_purge(ar);\n\tath10k_mgmt_over_wmi_tx_purge(ar);\n\n\tcancel_work_sync(&ar->offchan_tx_work);\n\tcancel_work_sync(&ar->wmi_mgmt_tx_work);\n}\n\nvoid ath10k_halt(struct ath10k *ar)\n{\n\tstruct ath10k_vif *arvif;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tclear_bit(ATH10K_CAC_RUNNING, &ar->dev_flags);\n\tar->filter_flags = 0;\n\tar->monitor = false;\n\tar->monitor_arvif = NULL;\n\n\tif (ar->monitor_started)\n\t\tath10k_monitor_stop(ar);\n\n\tar->monitor_started = false;\n\tar->tx_paused = 0;\n\n\tath10k_scan_finish(ar);\n\tath10k_peer_cleanup_all(ar);\n\tath10k_stop_radar_confirmation(ar);\n\tath10k_core_stop(ar);\n\tath10k_hif_power_down(ar);\n\n\tspin_lock_bh(&ar->data_lock);\n\tlist_for_each_entry(arvif, &ar->arvifs, list)\n\t\tath10k_mac_vif_beacon_cleanup(arvif);\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nstatic int ath10k_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)\n{\n\tstruct ath10k *ar = hw->priv;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\t*tx_ant = ar->cfg_tx_chainmask;\n\t*rx_ant = ar->cfg_rx_chainmask;\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn 0;\n}\n\nstatic bool ath10k_check_chain_mask(struct ath10k *ar, u32 cm, const char *dbg)\n{\n\t/* It is not clear that allowing gaps in chainmask\n\t * is helpful.  Probably it will not do what user\n\t * is hoping for, so warn in that case.\n\t */\n\tif (cm == 15 || cm == 7 || cm == 3 || cm == 1 || cm == 0)\n\t\treturn true;\n\n\tath10k_warn(ar, \"mac %s antenna chainmask is invalid: 0x%x.  Suggested values: 15, 7, 3, 1 or 0.\\n\",\n\t\t    dbg, cm);\n\treturn false;\n}\n\nstatic int ath10k_mac_get_vht_cap_bf_sts(struct ath10k *ar)\n{\n\tint nsts = ar->vht_cap_info;\n\n\tnsts &= IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK;\n\tnsts >>= IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT;\n\n\t/* If firmware does not deliver to host number of space-time\n\t * streams supported, assume it support up to 4 BF STS and return\n\t * the value for VHT CAP: nsts-1)\n\t */\n\tif (nsts == 0)\n\t\treturn 3;\n\n\treturn nsts;\n}\n\nstatic int ath10k_mac_get_vht_cap_bf_sound_dim(struct ath10k *ar)\n{\n\tint sound_dim = ar->vht_cap_info;\n\n\tsound_dim &= IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK;\n\tsound_dim >>= IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT;\n\n\t/* If the sounding dimension is not advertised by the firmware,\n\t * let's use a default value of 1\n\t */\n\tif (sound_dim == 0)\n\t\treturn 1;\n\n\treturn sound_dim;\n}\n\nstatic struct ieee80211_sta_vht_cap ath10k_create_vht_cap(struct ath10k *ar)\n{\n\tstruct ieee80211_sta_vht_cap vht_cap = {0};\n\tstruct ath10k_hw_params *hw = &ar->hw_params;\n\tu16 mcs_map;\n\tu32 val;\n\tint i;\n\n\tvht_cap.vht_supported = 1;\n\tvht_cap.cap = ar->vht_cap_info;\n\n\tif (ar->vht_cap_info & (IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\n\t\t\t\tIEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE)) {\n\t\tval = ath10k_mac_get_vht_cap_bf_sts(ar);\n\t\tval <<= IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT;\n\t\tval &= IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK;\n\n\t\tvht_cap.cap |= val;\n\t}\n\n\tif (ar->vht_cap_info & (IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |\n\t\t\t\tIEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE)) {\n\t\tval = ath10k_mac_get_vht_cap_bf_sound_dim(ar);\n\t\tval <<= IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT;\n\t\tval &= IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK;\n\n\t\tvht_cap.cap |= val;\n\t}\n\n\tmcs_map = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tif ((i < ar->num_rf_chains) && (ar->cfg_tx_chainmask & BIT(i)))\n\t\t\tmcs_map |= IEEE80211_VHT_MCS_SUPPORT_0_9 << (i * 2);\n\t\telse\n\t\t\tmcs_map |= IEEE80211_VHT_MCS_NOT_SUPPORTED << (i * 2);\n\t}\n\n\tif (ar->cfg_tx_chainmask <= 1)\n\t\tvht_cap.cap &= ~IEEE80211_VHT_CAP_TXSTBC;\n\n\tvht_cap.vht_mcs.rx_mcs_map = cpu_to_le16(mcs_map);\n\tvht_cap.vht_mcs.tx_mcs_map = cpu_to_le16(mcs_map);\n\n\t/* If we are supporting 160Mhz or 80+80, then the NIC may be able to do\n\t * a restricted NSS for 160 or 80+80 vs what it can do for 80Mhz.  Give\n\t * user-space a clue if that is the case.\n\t */\n\tif ((vht_cap.cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) &&\n\t    (hw->vht160_mcs_rx_highest != 0 ||\n\t     hw->vht160_mcs_tx_highest != 0)) {\n\t\tvht_cap.vht_mcs.rx_highest = cpu_to_le16(hw->vht160_mcs_rx_highest);\n\t\tvht_cap.vht_mcs.tx_highest = cpu_to_le16(hw->vht160_mcs_tx_highest);\n\t}\n\n\treturn vht_cap;\n}\n\nstatic struct ieee80211_sta_ht_cap ath10k_get_ht_cap(struct ath10k *ar)\n{\n\tint i;\n\tstruct ieee80211_sta_ht_cap ht_cap = {0};\n\n\tif (!(ar->ht_cap_info & WMI_HT_CAP_ENABLED))\n\t\treturn ht_cap;\n\n\tht_cap.ht_supported = 1;\n\tht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\tht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_8;\n\tht_cap.cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\tht_cap.cap |= IEEE80211_HT_CAP_DSSSCCK40;\n\tht_cap.cap |=\n\t\tWLAN_HT_CAP_SM_PS_DISABLED << IEEE80211_HT_CAP_SM_PS_SHIFT;\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_HT20_SGI)\n\t\tht_cap.cap |= IEEE80211_HT_CAP_SGI_20;\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_HT40_SGI)\n\t\tht_cap.cap |= IEEE80211_HT_CAP_SGI_40;\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_DYNAMIC_SMPS) {\n\t\tu32 smps;\n\n\t\tsmps   = WLAN_HT_CAP_SM_PS_DYNAMIC;\n\t\tsmps <<= IEEE80211_HT_CAP_SM_PS_SHIFT;\n\n\t\tht_cap.cap |= smps;\n\t}\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_TX_STBC && (ar->cfg_tx_chainmask > 1))\n\t\tht_cap.cap |= IEEE80211_HT_CAP_TX_STBC;\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_RX_STBC) {\n\t\tu32 stbc;\n\n\t\tstbc   = ar->ht_cap_info;\n\t\tstbc  &= WMI_HT_CAP_RX_STBC;\n\t\tstbc >>= WMI_HT_CAP_RX_STBC_MASK_SHIFT;\n\t\tstbc <<= IEEE80211_HT_CAP_RX_STBC_SHIFT;\n\t\tstbc  &= IEEE80211_HT_CAP_RX_STBC;\n\n\t\tht_cap.cap |= stbc;\n\t}\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_LDPC || (ar->ht_cap_info &\n\t    WMI_HT_CAP_RX_LDPC && (ar->ht_cap_info & WMI_HT_CAP_TX_LDPC)))\n\t\tht_cap.cap |= IEEE80211_HT_CAP_LDPC_CODING;\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_L_SIG_TXOP_PROT)\n\t\tht_cap.cap |= IEEE80211_HT_CAP_LSIG_TXOP_PROT;\n\n\t/* max AMSDU is implicitly taken from vht_cap_info */\n\tif (ar->vht_cap_info & WMI_VHT_CAP_MAX_MPDU_LEN_MASK)\n\t\tht_cap.cap |= IEEE80211_HT_CAP_MAX_AMSDU;\n\n\tfor (i = 0; i < ar->num_rf_chains; i++) {\n\t\tif (ar->cfg_rx_chainmask & BIT(i))\n\t\t\tht_cap.mcs.rx_mask[i] = 0xFF;\n\t}\n\n\tht_cap.mcs.tx_params |= IEEE80211_HT_MCS_TX_DEFINED;\n\n\treturn ht_cap;\n}\n\nstatic void ath10k_mac_setup_ht_vht_cap(struct ath10k *ar)\n{\n\tstruct ieee80211_supported_band *band;\n\tstruct ieee80211_sta_vht_cap vht_cap;\n\tstruct ieee80211_sta_ht_cap ht_cap;\n\n\tht_cap = ath10k_get_ht_cap(ar);\n\tvht_cap = ath10k_create_vht_cap(ar);\n\n\tif (ar->phy_capability & WHAL_WLAN_11G_CAPABILITY) {\n\t\tband = &ar->mac.sbands[NL80211_BAND_2GHZ];\n\t\tband->ht_cap = ht_cap;\n\t}\n\tif (ar->phy_capability & WHAL_WLAN_11A_CAPABILITY) {\n\t\tband = &ar->mac.sbands[NL80211_BAND_5GHZ];\n\t\tband->ht_cap = ht_cap;\n\t\tband->vht_cap = vht_cap;\n\t}\n}\n\nstatic int __ath10k_set_antenna(struct ath10k *ar, u32 tx_ant, u32 rx_ant)\n{\n\tint ret;\n\tbool is_valid_tx_chain_mask, is_valid_rx_chain_mask;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tis_valid_tx_chain_mask = ath10k_check_chain_mask(ar, tx_ant, \"tx\");\n\tis_valid_rx_chain_mask = ath10k_check_chain_mask(ar, rx_ant, \"rx\");\n\n\tif (!is_valid_tx_chain_mask || !is_valid_rx_chain_mask)\n\t\treturn -EINVAL;\n\n\tar->cfg_tx_chainmask = tx_ant;\n\tar->cfg_rx_chainmask = rx_ant;\n\n\tif ((ar->state != ATH10K_STATE_ON) &&\n\t    (ar->state != ATH10K_STATE_RESTARTED))\n\t\treturn 0;\n\n\tret = ath10k_wmi_pdev_set_param(ar, ar->wmi.pdev_param->tx_chain_mask,\n\t\t\t\t\ttx_ant);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set tx-chainmask: %d, req 0x%x\\n\",\n\t\t\t    ret, tx_ant);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_wmi_pdev_set_param(ar, ar->wmi.pdev_param->rx_chain_mask,\n\t\t\t\t\trx_ant);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set rx-chainmask: %d, req 0x%x\\n\",\n\t\t\t    ret, rx_ant);\n\t\treturn ret;\n\t}\n\n\t/* Reload HT/VHT capability */\n\tath10k_mac_setup_ht_vht_cap(ar);\n\n\treturn 0;\n}\n\nstatic int ath10k_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)\n{\n\tstruct ath10k *ar = hw->priv;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\tret = __ath10k_set_antenna(ar, tx_ant, rx_ant);\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int __ath10k_fetch_bb_timing_dt(struct ath10k *ar,\n\t\t\t\t       struct wmi_bb_timing_cfg_arg *bb_timing)\n{\n\tstruct device_node *node;\n\tconst char *fem_name;\n\tint ret;\n\n\tnode = ar->dev->of_node;\n\tif (!node)\n\t\treturn -ENOENT;\n\n\tret = of_property_read_string_index(node, \"ext-fem-name\", 0, &fem_name);\n\tif (ret)\n\t\treturn -ENOENT;\n\n\t/*\n\t * If external Front End module used in hardware, then default base band timing\n\t * parameter cannot be used since they were fine tuned for reference hardware,\n\t * so choosing different value suitable for that external FEM.\n\t */\n\tif (!strcmp(\"microsemi-lx5586\", fem_name)) {\n\t\tbb_timing->bb_tx_timing = 0x00;\n\t\tbb_timing->bb_xpa_timing = 0x0101;\n\t} else {\n\t\treturn -ENOENT;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot bb_tx_timing 0x%x bb_xpa_timing 0x%x\\n\",\n\t\t   bb_timing->bb_tx_timing, bb_timing->bb_xpa_timing);\n\treturn 0;\n}\n\nstatic int ath10k_mac_rfkill_config(struct ath10k *ar)\n{\n\tu32 param;\n\tint ret;\n\n\tif (ar->hw_values->rfkill_pin == 0) {\n\t\tath10k_warn(ar, \"ath10k does not support hardware rfkill with this device\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac rfkill_pin %d rfkill_cfg %d rfkill_on_level %d\",\n\t\t   ar->hw_values->rfkill_pin, ar->hw_values->rfkill_cfg,\n\t\t   ar->hw_values->rfkill_on_level);\n\n\tparam = FIELD_PREP(WMI_TLV_RFKILL_CFG_RADIO_LEVEL,\n\t\t\t   ar->hw_values->rfkill_on_level) |\n\t\tFIELD_PREP(WMI_TLV_RFKILL_CFG_GPIO_PIN_NUM,\n\t\t\t   ar->hw_values->rfkill_pin) |\n\t\tFIELD_PREP(WMI_TLV_RFKILL_CFG_PIN_AS_GPIO,\n\t\t\t   ar->hw_values->rfkill_cfg);\n\n\tret = ath10k_wmi_pdev_set_param(ar,\n\t\t\t\t\tar->wmi.pdev_param->rfkill_config,\n\t\t\t\t\tparam);\n\tif (ret) {\n\t\tath10k_warn(ar,\n\t\t\t    \"failed to set rfkill config 0x%x: %d\\n\",\n\t\t\t    param, ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint ath10k_mac_rfkill_enable_radio(struct ath10k *ar, bool enable)\n{\n\tenum wmi_tlv_rfkill_enable_radio param;\n\tint ret;\n\n\tif (enable)\n\t\tparam = WMI_TLV_RFKILL_ENABLE_RADIO_ON;\n\telse\n\t\tparam = WMI_TLV_RFKILL_ENABLE_RADIO_OFF;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac rfkill enable %d\", param);\n\n\tret = ath10k_wmi_pdev_set_param(ar, ar->wmi.pdev_param->rfkill_enable,\n\t\t\t\t\tparam);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set rfkill enable param %d: %d\\n\",\n\t\t\t    param, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_start(struct ieee80211_hw *hw)\n{\n\tstruct ath10k *ar = hw->priv;\n\tu32 param;\n\tint ret = 0;\n\tstruct wmi_bb_timing_cfg_arg bb_timing = {0};\n\n\t/*\n\t * This makes sense only when restarting hw. It is harmless to call\n\t * unconditionally. This is necessary to make sure no HTT/WMI tx\n\t * commands will be submitted while restarting.\n\t */\n\tath10k_drain_tx(ar);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tswitch (ar->state) {\n\tcase ATH10K_STATE_OFF:\n\t\tar->state = ATH10K_STATE_ON;\n\t\tbreak;\n\tcase ATH10K_STATE_RESTARTING:\n\t\tar->state = ATH10K_STATE_RESTARTED;\n\t\tbreak;\n\tcase ATH10K_STATE_ON:\n\tcase ATH10K_STATE_RESTARTED:\n\tcase ATH10K_STATE_WEDGED:\n\t\tWARN_ON(1);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\tcase ATH10K_STATE_UTF:\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tif (ar->hw_rfkill_on) {\n\t\tar->hw_rfkill_on = false;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\tgoto err;\n\t}\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\tret = ath10k_hif_power_up(ar, ATH10K_FIRMWARE_MODE_NORMAL);\n\tif (ret) {\n\t\tath10k_err(ar, \"Could not init hif: %d\\n\", ret);\n\t\tgoto err_off;\n\t}\n\n\tret = ath10k_core_start(ar, ATH10K_FIRMWARE_MODE_NORMAL,\n\t\t\t\t&ar->normal_mode_fw);\n\tif (ret) {\n\t\tath10k_err(ar, \"Could not init core: %d\\n\", ret);\n\t\tgoto err_power_down;\n\t}\n\n\tif (ar->sys_cap_info & WMI_TLV_SYS_CAP_INFO_RFKILL) {\n\t\tret = ath10k_mac_rfkill_config(ar);\n\t\tif (ret && ret != -EOPNOTSUPP) {\n\t\t\tath10k_warn(ar, \"failed to configure rfkill: %d\", ret);\n\t\t\tgoto err_core_stop;\n\t\t}\n\t}\n\n\tparam = ar->wmi.pdev_param->pmf_qos;\n\tret = ath10k_wmi_pdev_set_param(ar, param, 1);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to enable PMF QOS: %d\\n\", ret);\n\t\tgoto err_core_stop;\n\t}\n\n\tparam = ar->wmi.pdev_param->dynamic_bw;\n\tret = ath10k_wmi_pdev_set_param(ar, param, 1);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to enable dynamic BW: %d\\n\", ret);\n\t\tgoto err_core_stop;\n\t}\n\n\tif (test_bit(WMI_SERVICE_SPOOF_MAC_SUPPORT, ar->wmi.svc_map)) {\n\t\tret = ath10k_wmi_scan_prob_req_oui(ar, ar->mac_addr);\n\t\tif (ret) {\n\t\t\tath10k_err(ar, \"failed to set prob req oui: %i\\n\", ret);\n\t\t\tgoto err_core_stop;\n\t\t}\n\t}\n\n\tif (test_bit(WMI_SERVICE_ADAPTIVE_OCS, ar->wmi.svc_map)) {\n\t\tret = ath10k_wmi_adaptive_qcs(ar, true);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to enable adaptive qcs: %d\\n\",\n\t\t\t\t    ret);\n\t\t\tgoto err_core_stop;\n\t\t}\n\t}\n\n\tif (test_bit(WMI_SERVICE_BURST, ar->wmi.svc_map)) {\n\t\tparam = ar->wmi.pdev_param->burst_enable;\n\t\tret = ath10k_wmi_pdev_set_param(ar, param, 0);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to disable burst: %d\\n\", ret);\n\t\t\tgoto err_core_stop;\n\t\t}\n\t}\n\n\tparam = ar->wmi.pdev_param->idle_ps_config;\n\tret = ath10k_wmi_pdev_set_param(ar, param, 1);\n\tif (ret && ret != -EOPNOTSUPP) {\n\t\tath10k_warn(ar, \"failed to enable idle_ps_config: %d\\n\", ret);\n\t\tgoto err_core_stop;\n\t}\n\n\t__ath10k_set_antenna(ar, ar->cfg_tx_chainmask, ar->cfg_rx_chainmask);\n\n\t/*\n\t * By default FW set ARP frames ac to voice (6). In that case ARP\n\t * exchange is not working properly for UAPSD enabled AP. ARP requests\n\t * which arrives with access category 0 are processed by network stack\n\t * and send back with access category 0, but FW changes access category\n\t * to 6. Set ARP frames access category to best effort (0) solves\n\t * this problem.\n\t */\n\n\tparam = ar->wmi.pdev_param->arp_ac_override;\n\tret = ath10k_wmi_pdev_set_param(ar, param, 0);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set arp ac override parameter: %d\\n\",\n\t\t\t    ret);\n\t\tgoto err_core_stop;\n\t}\n\n\tif (test_bit(ATH10K_FW_FEATURE_SUPPORTS_ADAPTIVE_CCA,\n\t\t     ar->running_fw->fw_file.fw_features)) {\n\t\tret = ath10k_wmi_pdev_enable_adaptive_cca(ar, 1,\n\t\t\t\t\t\t\t  WMI_CCA_DETECT_LEVEL_AUTO,\n\t\t\t\t\t\t\t  WMI_CCA_DETECT_MARGIN_AUTO);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to enable adaptive cca: %d\\n\",\n\t\t\t\t    ret);\n\t\t\tgoto err_core_stop;\n\t\t}\n\t}\n\n\tparam = ar->wmi.pdev_param->ani_enable;\n\tret = ath10k_wmi_pdev_set_param(ar, param, 1);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to enable ani by default: %d\\n\",\n\t\t\t    ret);\n\t\tgoto err_core_stop;\n\t}\n\n\tar->ani_enabled = true;\n\n\tif (ath10k_peer_stats_enabled(ar)) {\n\t\tparam = ar->wmi.pdev_param->peer_stats_update_period;\n\t\tret = ath10k_wmi_pdev_set_param(ar, param,\n\t\t\t\t\t\tPEER_DEFAULT_STATS_UPDATE_PERIOD);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"failed to set peer stats period : %d\\n\",\n\t\t\t\t    ret);\n\t\t\tgoto err_core_stop;\n\t\t}\n\t}\n\n\tparam = ar->wmi.pdev_param->enable_btcoex;\n\tif (test_bit(WMI_SERVICE_COEX_GPIO, ar->wmi.svc_map) &&\n\t    test_bit(ATH10K_FW_FEATURE_BTCOEX_PARAM,\n\t\t     ar->running_fw->fw_file.fw_features) &&\n\t    ar->coex_support) {\n\t\tret = ath10k_wmi_pdev_set_param(ar, param, 0);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"failed to set btcoex param: %d\\n\", ret);\n\t\t\tgoto err_core_stop;\n\t\t}\n\t\tclear_bit(ATH10K_FLAG_BTCOEX, &ar->dev_flags);\n\t}\n\n\tif (test_bit(WMI_SERVICE_BB_TIMING_CONFIG_SUPPORT, ar->wmi.svc_map)) {\n\t\tret = __ath10k_fetch_bb_timing_dt(ar, &bb_timing);\n\t\tif (!ret) {\n\t\t\tret = ath10k_wmi_pdev_bb_timing(ar, &bb_timing);\n\t\t\tif (ret) {\n\t\t\t\tath10k_warn(ar,\n\t\t\t\t\t    \"failed to set bb timings: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\tgoto err_core_stop;\n\t\t\t}\n\t\t}\n\t}\n\n\tar->num_started_vdevs = 0;\n\tath10k_regd_update(ar);\n\n\tath10k_spectral_start(ar);\n\tath10k_thermal_set_throttling(ar);\n\n\tar->radar_conf_state = ATH10K_RADAR_CONFIRMATION_IDLE;\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn 0;\n\nerr_core_stop:\n\tath10k_core_stop(ar);\n\nerr_power_down:\n\tath10k_hif_power_down(ar);\n\nerr_off:\n\tar->state = ATH10K_STATE_OFF;\n\nerr:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic void ath10k_stop(struct ieee80211_hw *hw)\n{\n\tstruct ath10k *ar = hw->priv;\n\n\tath10k_drain_tx(ar);\n\n\tmutex_lock(&ar->conf_mutex);\n\tif (ar->state != ATH10K_STATE_OFF) {\n\t\tif (!ar->hw_rfkill_on)\n\t\t\tath10k_halt(ar);\n\t\tar->state = ATH10K_STATE_OFF;\n\t}\n\tmutex_unlock(&ar->conf_mutex);\n\n\tcancel_work_sync(&ar->set_coverage_class_work);\n\tcancel_delayed_work_sync(&ar->scan.timeout);\n\tcancel_work_sync(&ar->restart_work);\n}\n\nstatic int ath10k_config_ps(struct ath10k *ar)\n{\n\tstruct ath10k_vif *arvif;\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tret = ath10k_mac_vif_setup_ps(arvif);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to setup powersave: %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int ath10k_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tint ret = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (changed & IEEE80211_CONF_CHANGE_PS)\n\t\tath10k_config_ps(ar);\n\n\tif (changed & IEEE80211_CONF_CHANGE_MONITOR) {\n\t\tar->monitor = conf->flags & IEEE80211_CONF_MONITOR;\n\t\tret = ath10k_monitor_recalc(ar);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to recalc monitor: %d\\n\", ret);\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic u32 get_nss_from_chainmask(u16 chain_mask)\n{\n\tif ((chain_mask & 0xf) == 0xf)\n\t\treturn 4;\n\telse if ((chain_mask & 0x7) == 0x7)\n\t\treturn 3;\n\telse if ((chain_mask & 0x3) == 0x3)\n\t\treturn 2;\n\treturn 1;\n}\n\nstatic int ath10k_mac_set_txbf_conf(struct ath10k_vif *arvif)\n{\n\tu32 value = 0;\n\tstruct ath10k *ar = arvif->ar;\n\tint nsts;\n\tint sound_dim;\n\n\tif (ath10k_wmi_get_txbf_conf_scheme(ar) != WMI_TXBF_CONF_BEFORE_ASSOC)\n\t\treturn 0;\n\n\tnsts = ath10k_mac_get_vht_cap_bf_sts(ar);\n\tif (ar->vht_cap_info & (IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\n\t\t\t\tIEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE))\n\t\tvalue |= SM(nsts, WMI_TXBF_STS_CAP_OFFSET);\n\n\tsound_dim = ath10k_mac_get_vht_cap_bf_sound_dim(ar);\n\tif (ar->vht_cap_info & (IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |\n\t\t\t\tIEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE))\n\t\tvalue |= SM(sound_dim, WMI_BF_SOUND_DIM_OFFSET);\n\n\tif (!value)\n\t\treturn 0;\n\n\tif (ar->vht_cap_info & IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE)\n\t\tvalue |= WMI_VDEV_PARAM_TXBF_SU_TX_BFER;\n\n\tif (ar->vht_cap_info & IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE)\n\t\tvalue |= (WMI_VDEV_PARAM_TXBF_MU_TX_BFER |\n\t\t\t  WMI_VDEV_PARAM_TXBF_SU_TX_BFER);\n\n\tif (ar->vht_cap_info & IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE)\n\t\tvalue |= WMI_VDEV_PARAM_TXBF_SU_TX_BFEE;\n\n\tif (ar->vht_cap_info & IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE)\n\t\tvalue |= (WMI_VDEV_PARAM_TXBF_MU_TX_BFEE |\n\t\t\t  WMI_VDEV_PARAM_TXBF_SU_TX_BFEE);\n\n\treturn ath10k_wmi_vdev_set_param(ar, arvif->vdev_id,\n\t\t\t\t\t ar->wmi.vdev_param->txbf, value);\n}\n\n/*\n * TODO:\n * Figure out how to handle WMI_VDEV_SUBTYPE_P2P_DEVICE,\n * because we will send mgmt frames without CCK. This requirement\n * for P2P_FIND/GO_NEG should be handled by checking CCK flag\n * in the TX packet.\n */\nstatic int ath10k_add_interface(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_peer *peer;\n\tenum wmi_sta_powersave_param param;\n\tint ret = 0;\n\tu32 value;\n\tint bit;\n\tint i;\n\tu32 vdev_param;\n\n\tvif->driver_flags |= IEEE80211_VIF_SUPPORTS_UAPSD;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tmemset(arvif, 0, sizeof(*arvif));\n\tath10k_mac_txq_init(vif->txq);\n\n\tarvif->ar = ar;\n\tarvif->vif = vif;\n\n\tINIT_LIST_HEAD(&arvif->list);\n\tINIT_WORK(&arvif->ap_csa_work, ath10k_mac_vif_ap_csa_work);\n\tINIT_DELAYED_WORK(&arvif->connection_loss_work,\n\t\t\t  ath10k_mac_vif_sta_connection_loss_work);\n\n\tfor (i = 0; i < ARRAY_SIZE(arvif->bitrate_mask.control); i++) {\n\t\tarvif->bitrate_mask.control[i].legacy = 0xffffffff;\n\t\tmemset(arvif->bitrate_mask.control[i].ht_mcs, 0xff,\n\t\t       sizeof(arvif->bitrate_mask.control[i].ht_mcs));\n\t\tmemset(arvif->bitrate_mask.control[i].vht_mcs, 0xff,\n\t\t       sizeof(arvif->bitrate_mask.control[i].vht_mcs));\n\t}\n\n\tif (ar->num_peers >= ar->max_num_peers) {\n\t\tath10k_warn(ar, \"refusing vdev creation due to insufficient peer entry resources in firmware\\n\");\n\t\tret = -ENOBUFS;\n\t\tgoto err;\n\t}\n\n\tif (ar->free_vdev_map == 0) {\n\t\tath10k_warn(ar, \"Free vdev map is empty, no more interfaces allowed.\\n\");\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\tbit = __ffs64(ar->free_vdev_map);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac create vdev %i map %llx\\n\",\n\t\t   bit, ar->free_vdev_map);\n\n\tarvif->vdev_id = bit;\n\tarvif->vdev_subtype =\n\t\tath10k_wmi_get_vdev_subtype(ar, WMI_VDEV_SUBTYPE_NONE);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tarvif->vdev_type = WMI_VDEV_TYPE_STA;\n\t\tarvif->vdev_subtype = ath10k_wmi_get_vdev_subtype\n\t\t\t\t\t(ar, WMI_VDEV_SUBTYPE_P2P_DEVICE);\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NL80211_IFTYPE_STATION:\n\t\tarvif->vdev_type = WMI_VDEV_TYPE_STA;\n\t\tif (vif->p2p)\n\t\t\tarvif->vdev_subtype = ath10k_wmi_get_vdev_subtype\n\t\t\t\t\t(ar, WMI_VDEV_SUBTYPE_P2P_CLIENT);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tarvif->vdev_type = WMI_VDEV_TYPE_IBSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (test_bit(WMI_SERVICE_MESH_11S, ar->wmi.svc_map)) {\n\t\t\tarvif->vdev_subtype = ath10k_wmi_get_vdev_subtype\n\t\t\t\t\t\t(ar, WMI_VDEV_SUBTYPE_MESH_11S);\n\t\t} else if (!test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags)) {\n\t\t\tret = -EINVAL;\n\t\t\tath10k_warn(ar, \"must load driver with rawmode=1 to add mesh interfaces\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tarvif->vdev_type = WMI_VDEV_TYPE_AP;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tarvif->vdev_type = WMI_VDEV_TYPE_AP;\n\n\t\tif (vif->p2p)\n\t\t\tarvif->vdev_subtype = ath10k_wmi_get_vdev_subtype\n\t\t\t\t\t\t(ar, WMI_VDEV_SUBTYPE_P2P_GO);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tarvif->vdev_type = WMI_VDEV_TYPE_MONITOR;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\t/* Using vdev_id as queue number will make it very easy to do per-vif\n\t * tx queue locking. This shouldn't wrap due to interface combinations\n\t * but do a modulo for correctness sake and prevent using offchannel tx\n\t * queues for regular vif tx.\n\t */\n\tvif->cab_queue = arvif->vdev_id % (IEEE80211_MAX_QUEUES - 1);\n\tfor (i = 0; i < ARRAY_SIZE(vif->hw_queue); i++)\n\t\tvif->hw_queue[i] = arvif->vdev_id % (IEEE80211_MAX_QUEUES - 1);\n\n\t/* Some firmware revisions don't wait for beacon tx completion before\n\t * sending another SWBA event. This could lead to hardware using old\n\t * (freed) beacon data in some cases, e.g. tx credit starvation\n\t * combined with missed TBTT. This is very rare.\n\t *\n\t * On non-IOMMU-enabled hosts this could be a possible security issue\n\t * because hw could beacon some random data on the air.  On\n\t * IOMMU-enabled hosts DMAR faults would occur in most cases and target\n\t * device would crash.\n\t *\n\t * Since there are no beacon tx completions (implicit nor explicit)\n\t * propagated to host the only workaround for this is to allocate a\n\t * DMA-coherent buffer for a lifetime of a vif and use it for all\n\t * beacon tx commands. Worst case for this approach is some beacons may\n\t * become corrupted, e.g. have garbled IEs or out-of-date TIM bitmap.\n\t */\n\tif (vif->type == NL80211_IFTYPE_ADHOC ||\n\t    vif->type == NL80211_IFTYPE_MESH_POINT ||\n\t    vif->type == NL80211_IFTYPE_AP) {\n\t\tarvif->beacon_buf = dma_alloc_coherent(ar->dev,\n\t\t\t\t\t\t       IEEE80211_MAX_FRAME_LEN,\n\t\t\t\t\t\t       &arvif->beacon_paddr,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\tif (!arvif->beacon_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tath10k_warn(ar, \"failed to allocate beacon buffer: %d\\n\",\n\t\t\t\t    ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tif (test_bit(ATH10K_FLAG_HW_CRYPTO_DISABLED, &ar->dev_flags))\n\t\tarvif->nohwcrypt = true;\n\n\tif (arvif->nohwcrypt &&\n\t    !test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags)) {\n\t\tath10k_warn(ar, \"cryptmode module param needed for sw crypto\\n\");\n\t\tgoto err;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev create %d (add interface) type %d subtype %d bcnmode %s\\n\",\n\t\t   arvif->vdev_id, arvif->vdev_type, arvif->vdev_subtype,\n\t\t   arvif->beacon_buf ? \"single-buf\" : \"per-skb\");\n\n\tret = ath10k_wmi_vdev_create(ar, arvif->vdev_id, arvif->vdev_type,\n\t\t\t\t     arvif->vdev_subtype, vif->addr);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to create WMI vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto err;\n\t}\n\n\tif (test_bit(WMI_SERVICE_VDEV_DISABLE_4_ADDR_SRC_LRN_SUPPORT,\n\t\t     ar->wmi.svc_map)) {\n\t\tvdev_param = ar->wmi.vdev_param->disable_4addr_src_lrn;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t\tWMI_VDEV_DISABLE_4_ADDR_SRC_LRN);\n\t\tif (ret && ret != -EOPNOTSUPP) {\n\t\t\tath10k_warn(ar, \"failed to disable 4addr src lrn vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t}\n\t}\n\n\tar->free_vdev_map &= ~(1LL << arvif->vdev_id);\n\tspin_lock_bh(&ar->data_lock);\n\tlist_add(&arvif->list, &ar->arvifs);\n\tspin_unlock_bh(&ar->data_lock);\n\n\t/* It makes no sense to have firmware do keepalives. mac80211 already\n\t * takes care of this with idle connection polling.\n\t */\n\tret = ath10k_mac_vif_disable_keepalive(arvif);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to disable keepalive on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto err_vdev_delete;\n\t}\n\n\tarvif->def_wep_key_idx = -1;\n\n\tvdev_param = ar->wmi.vdev_param->tx_encap_type;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\tATH10K_HW_TXRX_NATIVE_WIFI);\n\t/* 10.X firmware does not support this VDEV parameter. Do not warn */\n\tif (ret && ret != -EOPNOTSUPP) {\n\t\tath10k_warn(ar, \"failed to set vdev %i TX encapsulation: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto err_vdev_delete;\n\t}\n\n\t/* Configuring number of spatial stream for monitor interface is causing\n\t * target assert in qca9888 and qca6174.\n\t */\n\tif (ar->cfg_tx_chainmask && (vif->type != NL80211_IFTYPE_MONITOR)) {\n\t\tu16 nss = get_nss_from_chainmask(ar->cfg_tx_chainmask);\n\n\t\tvdev_param = ar->wmi.vdev_param->nss;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t\tnss);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set vdev %i chainmask 0x%x, nss %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ar->cfg_tx_chainmask, nss,\n\t\t\t\t    ret);\n\t\t\tgoto err_vdev_delete;\n\t\t}\n\t}\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_AP ||\n\t    arvif->vdev_type == WMI_VDEV_TYPE_IBSS) {\n\t\tret = ath10k_peer_create(ar, vif, NULL, arvif->vdev_id,\n\t\t\t\t\t vif->addr, WMI_PEER_TYPE_DEFAULT);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to create vdev %i peer for AP/IBSS: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_vdev_delete;\n\t\t}\n\n\t\tspin_lock_bh(&ar->data_lock);\n\n\t\tpeer = ath10k_peer_find(ar, arvif->vdev_id, vif->addr);\n\t\tif (!peer) {\n\t\t\tath10k_warn(ar, \"failed to lookup peer %pM on vdev %i\\n\",\n\t\t\t\t    vif->addr, arvif->vdev_id);\n\t\t\tspin_unlock_bh(&ar->data_lock);\n\t\t\tret = -ENOENT;\n\t\t\tgoto err_peer_delete;\n\t\t}\n\n\t\tarvif->peer_id = find_first_bit(peer->peer_ids,\n\t\t\t\t\t\tATH10K_MAX_NUM_PEER_IDS);\n\n\t\tspin_unlock_bh(&ar->data_lock);\n\t} else {\n\t\tarvif->peer_id = HTT_INVALID_PEERID;\n\t}\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_AP) {\n\t\tret = ath10k_mac_set_kickout(arvif);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set vdev %i kickout parameters: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_peer_delete;\n\t\t}\n\t}\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_STA) {\n\t\tparam = WMI_STA_PS_PARAM_RX_WAKE_POLICY;\n\t\tvalue = WMI_STA_PS_RX_WAKE_POLICY_WAKE;\n\t\tret = ath10k_wmi_set_sta_ps_param(ar, arvif->vdev_id,\n\t\t\t\t\t\t  param, value);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set vdev %i RX wake policy: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_peer_delete;\n\t\t}\n\n\t\tret = ath10k_mac_vif_recalc_ps_wake_threshold(arvif);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to recalc ps wake threshold on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_peer_delete;\n\t\t}\n\n\t\tret = ath10k_mac_vif_recalc_ps_poll_count(arvif);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to recalc ps poll count on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_peer_delete;\n\t\t}\n\t}\n\n\tret = ath10k_mac_set_txbf_conf(arvif);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set txbf for vdev %d: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto err_peer_delete;\n\t}\n\n\tret = ath10k_mac_set_rts(arvif, ar->hw->wiphy->rts_threshold);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set rts threshold for vdev %d: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto err_peer_delete;\n\t}\n\n\tarvif->txpower = vif->bss_conf.txpower;\n\tret = ath10k_mac_txpower_recalc(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to recalc tx power: %d\\n\", ret);\n\t\tgoto err_peer_delete;\n\t}\n\n\tif (test_bit(WMI_SERVICE_RTT_RESPONDER_ROLE, ar->wmi.svc_map)) {\n\t\tvdev_param = ar->wmi.vdev_param->rtt_responder_role;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t\tarvif->ftm_responder);\n\n\t\t/* It is harmless to not set FTM role. Do not warn */\n\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\tath10k_warn(ar, \"failed to set vdev %i FTM Responder: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR) {\n\t\tar->monitor_arvif = arvif;\n\t\tret = ath10k_monitor_recalc(ar);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to recalc monitor: %d\\n\", ret);\n\t\t\tgoto err_peer_delete;\n\t\t}\n\t}\n\n\tspin_lock_bh(&ar->htt.tx_lock);\n\tif (!ar->tx_paused)\n\t\tieee80211_wake_queue(ar->hw, arvif->vdev_id);\n\tspin_unlock_bh(&ar->htt.tx_lock);\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn 0;\n\nerr_peer_delete:\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_AP ||\n\t    arvif->vdev_type == WMI_VDEV_TYPE_IBSS) {\n\t\tath10k_wmi_peer_delete(ar, arvif->vdev_id, vif->addr);\n\t\tath10k_wait_for_peer_delete_done(ar, arvif->vdev_id,\n\t\t\t\t\t\t vif->addr);\n\t}\n\nerr_vdev_delete:\n\tath10k_wmi_vdev_delete(ar, arvif->vdev_id);\n\tar->free_vdev_map |= 1LL << arvif->vdev_id;\n\tspin_lock_bh(&ar->data_lock);\n\tlist_del(&arvif->list);\n\tspin_unlock_bh(&ar->data_lock);\n\nerr:\n\tif (arvif->beacon_buf) {\n\t\tdma_free_coherent(ar->dev, IEEE80211_MAX_FRAME_LEN,\n\t\t\t\t  arvif->beacon_buf, arvif->beacon_paddr);\n\t\tarvif->beacon_buf = NULL;\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic void ath10k_mac_vif_tx_unlock_all(struct ath10k_vif *arvif)\n{\n\tint i;\n\n\tfor (i = 0; i < BITS_PER_LONG; i++)\n\t\tath10k_mac_vif_tx_unlock(arvif, i);\n}\n\nstatic void ath10k_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_peer *peer;\n\tunsigned long time_left;\n\tint ret;\n\tint i;\n\n\tcancel_work_sync(&arvif->ap_csa_work);\n\tcancel_delayed_work_sync(&arvif->connection_loss_work);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tret = ath10k_spectral_vif_stop(arvif);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to stop spectral for vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\n\tar->free_vdev_map |= 1LL << arvif->vdev_id;\n\tspin_lock_bh(&ar->data_lock);\n\tlist_del(&arvif->list);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_AP ||\n\t    arvif->vdev_type == WMI_VDEV_TYPE_IBSS) {\n\t\tret = ath10k_wmi_peer_delete(arvif->ar, arvif->vdev_id,\n\t\t\t\t\t     vif->addr);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to submit AP/IBSS self-peer removal on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\n\t\tath10k_wait_for_peer_delete_done(ar, arvif->vdev_id,\n\t\t\t\t\t\t vif->addr);\n\t\tkfree(arvif->u.ap.noa_data);\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %i delete (remove interface)\\n\",\n\t\t   arvif->vdev_id);\n\n\tret = ath10k_wmi_vdev_delete(ar, arvif->vdev_id);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to delete WMI vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\n\tif (test_bit(WMI_SERVICE_SYNC_DELETE_CMDS, ar->wmi.svc_map)) {\n\t\ttime_left = wait_for_completion_timeout(&ar->vdev_delete_done,\n\t\t\t\t\t\t\tATH10K_VDEV_DELETE_TIMEOUT_HZ);\n\t\tif (time_left == 0) {\n\t\t\tath10k_warn(ar, \"Timeout in receiving vdev delete response\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Some firmware revisions don't notify host about self-peer removal\n\t * until after associated vdev is deleted.\n\t */\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_AP ||\n\t    arvif->vdev_type == WMI_VDEV_TYPE_IBSS) {\n\t\tret = ath10k_wait_for_peer_deleted(ar, arvif->vdev_id,\n\t\t\t\t\t\t   vif->addr);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to remove AP self-peer on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tar->num_peers--;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\tfor (i = 0; i < ARRAY_SIZE(ar->peer_map); i++) {\n\t\tpeer = ar->peer_map[i];\n\t\tif (!peer)\n\t\t\tcontinue;\n\n\t\tif (peer->vif == vif) {\n\t\t\tath10k_warn(ar, \"found vif peer %pM entry on vdev %i after it was supposedly removed\\n\",\n\t\t\t\t    vif->addr, arvif->vdev_id);\n\t\t\tpeer->vif = NULL;\n\t\t}\n\t}\n\n\t/* Clean this up late, less opportunity for firmware to access\n\t * DMA memory we have deleted.\n\t */\n\tath10k_mac_vif_beacon_cleanup(arvif);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tath10k_peer_cleanup(ar, arvif->vdev_id);\n\tath10k_mac_txq_unref(ar, vif->txq);\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR) {\n\t\tar->monitor_arvif = NULL;\n\t\tret = ath10k_monitor_recalc(ar);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to recalc monitor: %d\\n\", ret);\n\t}\n\n\tret = ath10k_mac_txpower_recalc(ar);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to recalc tx power: %d\\n\", ret);\n\n\tspin_lock_bh(&ar->htt.tx_lock);\n\tath10k_mac_vif_tx_unlock_all(arvif);\n\tspin_unlock_bh(&ar->htt.tx_lock);\n\n\tath10k_mac_txq_unref(ar, vif->txq);\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n}\n\n/*\n * FIXME: Has to be verified.\n */\n#define SUPPORTED_FILTERS\t\t\t\\\n\t(FIF_ALLMULTI |\t\t\t\t\\\n\tFIF_CONTROL |\t\t\t\t\\\n\tFIF_PSPOLL |\t\t\t\t\\\n\tFIF_OTHER_BSS |\t\t\t\t\\\n\tFIF_BCN_PRBRESP_PROMISC |\t\t\\\n\tFIF_PROBE_REQ |\t\t\t\t\\\n\tFIF_FCSFAIL)\n\nstatic void ath10k_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t    unsigned int changed_flags,\n\t\t\t\t    unsigned int *total_flags,\n\t\t\t\t    u64 multicast)\n{\n\tstruct ath10k *ar = hw->priv;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tchanged_flags &= SUPPORTED_FILTERS;\n\t*total_flags &= SUPPORTED_FILTERS;\n\tar->filter_flags = *total_flags;\n\n\tret = ath10k_monitor_recalc(ar);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to recalc monitor: %d\\n\", ret);\n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic void ath10k_recalculate_mgmt_rate(struct ath10k *ar,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct cfg80211_chan_def *def)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tconst struct ieee80211_supported_band *sband;\n\tu8 basic_rate_idx;\n\tint hw_rate_code;\n\tu32 vdev_param;\n\tu16 bitrate;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tsband = ar->hw->wiphy->bands[def->chan->band];\n\tbasic_rate_idx = ffs(vif->bss_conf.basic_rates) - 1;\n\tbitrate = sband->bitrates[basic_rate_idx].bitrate;\n\n\thw_rate_code = ath10k_mac_get_rate_hw_value(bitrate);\n\tif (hw_rate_code < 0) {\n\t\tath10k_warn(ar, \"bitrate not supported %d\\n\", bitrate);\n\t\treturn;\n\t}\n\n\tvdev_param = ar->wmi.vdev_param->mgmt_rate;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\thw_rate_code);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to set mgmt tx rate %d\\n\", ret);\n}\n\nstatic void ath10k_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_bss_conf *info,\n\t\t\t\t    u32 changed)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct cfg80211_chan_def def;\n\tu32 vdev_param, pdev_param, slottime, preamble;\n\tu16 bitrate, hw_value;\n\tu8 rate, rateidx;\n\tint ret = 0, mcast_rate;\n\tenum nl80211_band band;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (changed & BSS_CHANGED_IBSS)\n\t\tath10k_control_ibss(arvif, info, vif->addr);\n\n\tif (changed & BSS_CHANGED_BEACON_INT) {\n\t\tarvif->beacon_interval = info->beacon_int;\n\t\tvdev_param = ar->wmi.vdev_param->beacon_interval;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t\tarvif->beacon_interval);\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t\t   \"mac vdev %d beacon_interval %d\\n\",\n\t\t\t   arvif->vdev_id, arvif->beacon_interval);\n\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to set beacon interval for vdev %d: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON) {\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t\t   \"vdev %d set beacon tx mode to staggered\\n\",\n\t\t\t   arvif->vdev_id);\n\n\t\tpdev_param = ar->wmi.pdev_param->beacon_tx_mode;\n\t\tret = ath10k_wmi_pdev_set_param(ar, pdev_param,\n\t\t\t\t\t\tWMI_BEACON_STAGGERED_MODE);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to set beacon mode for vdev %d: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\n\t\tret = ath10k_mac_setup_bcn_tmpl(arvif);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to update beacon template: %d\\n\",\n\t\t\t\t    ret);\n\n\t\tif (ieee80211_vif_is_mesh(vif)) {\n\t\t\t/* mesh doesn't use SSID but firmware needs it */\n\t\t\tstrncpy(arvif->u.ap.ssid, \"mesh\",\n\t\t\t\tsizeof(arvif->u.ap.ssid));\n\t\t\tarvif->u.ap.ssid_len = 4;\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_AP_PROBE_RESP) {\n\t\tret = ath10k_mac_setup_prb_tmpl(arvif);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to setup probe resp template on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (changed & (BSS_CHANGED_BEACON_INFO | BSS_CHANGED_BEACON)) {\n\t\tarvif->dtim_period = info->dtim_period;\n\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t\t   \"mac vdev %d dtim_period %d\\n\",\n\t\t\t   arvif->vdev_id, arvif->dtim_period);\n\n\t\tvdev_param = ar->wmi.vdev_param->dtim_period;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t\tarvif->dtim_period);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to set dtim period for vdev %d: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (changed & BSS_CHANGED_SSID &&\n\t    vif->type == NL80211_IFTYPE_AP) {\n\t\tarvif->u.ap.ssid_len = info->ssid_len;\n\t\tif (info->ssid_len)\n\t\t\tmemcpy(arvif->u.ap.ssid, info->ssid, info->ssid_len);\n\t\tarvif->u.ap.hidden_ssid = info->hidden_ssid;\n\t}\n\n\tif (changed & BSS_CHANGED_BSSID && !is_zero_ether_addr(info->bssid))\n\t\tether_addr_copy(arvif->bssid, info->bssid);\n\n\tif (changed & BSS_CHANGED_FTM_RESPONDER &&\n\t    arvif->ftm_responder != info->ftm_responder &&\n\t    test_bit(WMI_SERVICE_RTT_RESPONDER_ROLE, ar->wmi.svc_map)) {\n\t\tarvif->ftm_responder = info->ftm_responder;\n\n\t\tvdev_param = ar->wmi.vdev_param->rtt_responder_role;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t\tarvif->ftm_responder);\n\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t\t   \"mac vdev %d ftm_responder %d:ret %d\\n\",\n\t\t\t   arvif->vdev_id, arvif->ftm_responder, ret);\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED)\n\t\tath10k_control_beaconing(arvif, info);\n\n\tif (changed & BSS_CHANGED_ERP_CTS_PROT) {\n\t\tarvif->use_cts_prot = info->use_cts_prot;\n\n\t\tret = ath10k_recalc_rtscts_prot(arvif);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to recalculate rts/cts prot for vdev %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\n\t\tif (ath10k_mac_can_set_cts_prot(arvif)) {\n\t\t\tret = ath10k_mac_set_cts_prot(arvif);\n\t\t\tif (ret)\n\t\t\t\tath10k_warn(ar, \"failed to set cts protection for vdev %d: %d\\n\",\n\t\t\t\t\t    arvif->vdev_id, ret);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tif (info->use_short_slot)\n\t\t\tslottime = WMI_VDEV_SLOT_TIME_SHORT; /* 9us */\n\n\t\telse\n\t\t\tslottime = WMI_VDEV_SLOT_TIME_LONG; /* 20us */\n\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %d slot_time %d\\n\",\n\t\t\t   arvif->vdev_id, slottime);\n\n\t\tvdev_param = ar->wmi.vdev_param->slot_time;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t\tslottime);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to set erp slot for vdev %d: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\tif (info->use_short_preamble)\n\t\t\tpreamble = WMI_VDEV_PREAMBLE_SHORT;\n\t\telse\n\t\t\tpreamble = WMI_VDEV_PREAMBLE_LONG;\n\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t\t   \"mac vdev %d preamble %dn\",\n\t\t\t   arvif->vdev_id, preamble);\n\n\t\tvdev_param = ar->wmi.vdev_param->preamble;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t\tpreamble);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to set preamble for vdev %d: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\tif (info->assoc) {\n\t\t\t/* Workaround: Make sure monitor vdev is not running\n\t\t\t * when associating to prevent some firmware revisions\n\t\t\t * (e.g. 10.1 and 10.2) from crashing.\n\t\t\t */\n\t\t\tif (ar->monitor_started)\n\t\t\t\tath10k_monitor_stop(ar);\n\t\t\tath10k_bss_assoc(hw, vif, info);\n\t\t\tath10k_monitor_recalc(ar);\n\t\t} else {\n\t\t\tath10k_bss_disassoc(hw, vif);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_TXPOWER) {\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev_id %i txpower %d\\n\",\n\t\t\t   arvif->vdev_id, info->txpower);\n\n\t\tarvif->txpower = info->txpower;\n\t\tret = ath10k_mac_txpower_recalc(ar);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to recalc tx power: %d\\n\", ret);\n\t}\n\n\tif (changed & BSS_CHANGED_PS) {\n\t\tarvif->ps = vif->bss_conf.ps;\n\n\t\tret = ath10k_config_ps(ar);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to setup ps on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (changed & BSS_CHANGED_MCAST_RATE &&\n\t    !ath10k_mac_vif_chan(arvif->vif, &def)) {\n\t\tband = def.chan->band;\n\t\tmcast_rate = vif->bss_conf.mcast_rate[band];\n\t\tif (mcast_rate > 0)\n\t\t\trateidx = mcast_rate - 1;\n\t\telse\n\t\t\trateidx = ffs(vif->bss_conf.basic_rates) - 1;\n\n\t\tif (ar->phy_capability & WHAL_WLAN_11A_CAPABILITY)\n\t\t\trateidx += ATH10K_MAC_FIRST_OFDM_RATE_IDX;\n\n\t\tbitrate = ath10k_wmi_legacy_rates[rateidx].bitrate;\n\t\thw_value = ath10k_wmi_legacy_rates[rateidx].hw_value;\n\t\tif (ath10k_mac_bitrate_is_cck(bitrate))\n\t\t\tpreamble = WMI_RATE_PREAMBLE_CCK;\n\t\telse\n\t\t\tpreamble = WMI_RATE_PREAMBLE_OFDM;\n\n\t\trate = ATH10K_HW_RATECODE(hw_value, 0, preamble);\n\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t\t   \"mac vdev %d mcast_rate %x\\n\",\n\t\t\t   arvif->vdev_id, rate);\n\n\t\tvdev_param = ar->wmi.vdev_param->mcast_data_rate;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id,\n\t\t\t\t\t\tvdev_param, rate);\n\t\tif (ret)\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"failed to set mcast rate on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id,  ret);\n\n\t\tvdev_param = ar->wmi.vdev_param->bcast_data_rate;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id,\n\t\t\t\t\t\tvdev_param, rate);\n\t\tif (ret)\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"failed to set bcast rate on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id,  ret);\n\t}\n\n\tif (changed & BSS_CHANGED_BASIC_RATES &&\n\t    !ath10k_mac_vif_chan(arvif->vif, &def))\n\t\tath10k_recalculate_mgmt_rate(ar, vif, &def);\n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic void ath10k_mac_op_set_coverage_class(struct ieee80211_hw *hw, s16 value)\n{\n\tstruct ath10k *ar = hw->priv;\n\n\t/* This function should never be called if setting the coverage class\n\t * is not supported on this hardware.\n\t */\n\tif (!ar->hw_params.hw_ops->set_coverage_class) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\tar->hw_params.hw_ops->set_coverage_class(ar, value);\n}\n\nstruct ath10k_mac_tdls_iter_data {\n\tu32 num_tdls_stations;\n\tstruct ieee80211_vif *curr_vif;\n};\n\nstatic void ath10k_mac_tdls_vif_stations_count_iter(void *data,\n\t\t\t\t\t\t    struct ieee80211_sta *sta)\n{\n\tstruct ath10k_mac_tdls_iter_data *iter_data = data;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ieee80211_vif *sta_vif = arsta->arvif->vif;\n\n\tif (sta->tdls && sta_vif == iter_data->curr_vif)\n\t\titer_data->num_tdls_stations++;\n}\n\nstatic int ath10k_mac_tdls_vif_stations_count(struct ieee80211_hw *hw,\n\t\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct ath10k_mac_tdls_iter_data data = {};\n\n\tdata.curr_vif = vif;\n\n\tieee80211_iterate_stations_atomic(hw,\n\t\t\t\t\t  ath10k_mac_tdls_vif_stations_count_iter,\n\t\t\t\t\t  &data);\n\treturn data.num_tdls_stations;\n}\n\nstatic int ath10k_hw_scan(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_scan_request *hw_req)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct cfg80211_scan_request *req = &hw_req->req;\n\tstruct wmi_start_scan_arg arg;\n\tint ret = 0;\n\tint i;\n\tu32 scan_timeout;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ath10k_mac_tdls_vif_stations_count(hw, vif) > 0) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\tswitch (ar->scan.state) {\n\tcase ATH10K_SCAN_IDLE:\n\t\treinit_completion(&ar->scan.started);\n\t\treinit_completion(&ar->scan.completed);\n\t\tar->scan.state = ATH10K_SCAN_STARTING;\n\t\tar->scan.is_roc = false;\n\t\tar->scan.vdev_id = arvif->vdev_id;\n\t\tret = 0;\n\t\tbreak;\n\tcase ATH10K_SCAN_STARTING:\n\tcase ATH10K_SCAN_RUNNING:\n\tcase ATH10K_SCAN_ABORTING:\n\t\tret = -EBUSY;\n\t\tbreak;\n\t}\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (ret)\n\t\tgoto exit;\n\n\tmemset(&arg, 0, sizeof(arg));\n\tath10k_wmi_start_scan_init(ar, &arg);\n\targ.vdev_id = arvif->vdev_id;\n\targ.scan_id = ATH10K_SCAN_ID;\n\n\tif (req->ie_len) {\n\t\targ.ie_len = req->ie_len;\n\t\tmemcpy(arg.ie, req->ie, arg.ie_len);\n\t}\n\n\tif (req->n_ssids) {\n\t\targ.n_ssids = req->n_ssids;\n\t\tfor (i = 0; i < arg.n_ssids; i++) {\n\t\t\targ.ssids[i].len  = req->ssids[i].ssid_len;\n\t\t\targ.ssids[i].ssid = req->ssids[i].ssid;\n\t\t}\n\t} else {\n\t\targ.scan_ctrl_flags |= WMI_SCAN_FLAG_PASSIVE;\n\t}\n\n\tif (req->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {\n\t\targ.scan_ctrl_flags |=  WMI_SCAN_ADD_SPOOFED_MAC_IN_PROBE_REQ;\n\t\tether_addr_copy(arg.mac_addr.addr, req->mac_addr);\n\t\tether_addr_copy(arg.mac_mask.addr, req->mac_addr_mask);\n\t}\n\n\tif (req->n_channels) {\n\t\targ.n_channels = req->n_channels;\n\t\tfor (i = 0; i < arg.n_channels; i++)\n\t\t\targ.channels[i] = req->channels[i]->center_freq;\n\t}\n\n\t/* if duration is set, default dwell times will be overwritten */\n\tif (req->duration) {\n\t\targ.dwell_time_active = req->duration;\n\t\targ.dwell_time_passive = req->duration;\n\t\targ.burst_duration_ms = req->duration;\n\n\t\tscan_timeout = min_t(u32, arg.max_rest_time *\n\t\t\t\t(arg.n_channels - 1) + (req->duration +\n\t\t\t\tATH10K_SCAN_CHANNEL_SWITCH_WMI_EVT_OVERHEAD) *\n\t\t\t\targ.n_channels, arg.max_scan_time + 200);\n\n\t} else {\n\t\t/* Add a 200ms margin to account for event/command processing */\n\t\tscan_timeout = arg.max_scan_time + 200;\n\t}\n\n\tret = ath10k_start_scan(ar, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to start hw scan: %d\\n\", ret);\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tar->scan.state = ATH10K_SCAN_IDLE;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n\n\tieee80211_queue_delayed_work(ar->hw, &ar->scan.timeout,\n\t\t\t\t     msecs_to_jiffies(scan_timeout));\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic void ath10k_cancel_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct ath10k *ar = hw->priv;\n\n\tmutex_lock(&ar->conf_mutex);\n\tath10k_scan_abort(ar);\n\tmutex_unlock(&ar->conf_mutex);\n\n\tcancel_delayed_work_sync(&ar->scan.timeout);\n}\n\nstatic void ath10k_set_key_h_def_keyidx(struct ath10k *ar,\n\t\t\t\t\tstruct ath10k_vif *arvif,\n\t\t\t\t\tenum set_key_cmd cmd,\n\t\t\t\t\tstruct ieee80211_key_conf *key)\n{\n\tu32 vdev_param = arvif->ar->wmi.vdev_param->def_keyid;\n\tint ret;\n\n\t/* 10.1 firmware branch requires default key index to be set to group\n\t * key index after installing it. Otherwise FW/HW Txes corrupted\n\t * frames with multi-vif APs. This is not required for main firmware\n\t * branch (e.g. 636).\n\t *\n\t * This is also needed for 636 fw for IBSS-RSN to work more reliably.\n\t *\n\t * FIXME: It remains unknown if this is required for multi-vif STA\n\t * interfaces on 10.1.\n\t */\n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_AP &&\n\t    arvif->vdev_type != WMI_VDEV_TYPE_IBSS)\n\t\treturn;\n\n\tif (key->cipher == WLAN_CIPHER_SUITE_WEP40)\n\t\treturn;\n\n\tif (key->cipher == WLAN_CIPHER_SUITE_WEP104)\n\t\treturn;\n\n\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\n\t\treturn;\n\n\tif (cmd != SET_KEY)\n\t\treturn;\n\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\tkey->keyidx);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to set vdev %i group key as default key: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n}\n\nstatic int ath10k_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t  struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t\t  struct ieee80211_key_conf *key)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_sta *arsta;\n\tstruct ath10k_peer *peer;\n\tconst u8 *peer_addr;\n\tbool is_wep = key->cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t\t      key->cipher == WLAN_CIPHER_SUITE_WEP104;\n\tint ret = 0;\n\tint ret2;\n\tu32 flags = 0;\n\tu32 flags2;\n\n\t/* this one needs to be done in software */\n\tif (key->cipher == WLAN_CIPHER_SUITE_AES_CMAC ||\n\t    key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_128 ||\n\t    key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_256 ||\n\t    key->cipher == WLAN_CIPHER_SUITE_BIP_CMAC_256)\n\t\treturn 1;\n\n\tif (arvif->nohwcrypt)\n\t\treturn 1;\n\n\tif (key->keyidx > WMI_MAX_KEY_INDEX)\n\t\treturn -ENOSPC;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (sta) {\n\t\tarsta = (struct ath10k_sta *)sta->drv_priv;\n\t\tpeer_addr = sta->addr;\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tarsta->ucast_cipher = key->cipher;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t} else if (arvif->vdev_type == WMI_VDEV_TYPE_STA) {\n\t\tpeer_addr = vif->bss_conf.bssid;\n\t} else {\n\t\tpeer_addr = vif->addr;\n\t}\n\n\tkey->hw_key_idx = key->keyidx;\n\n\tif (is_wep) {\n\t\tif (cmd == SET_KEY)\n\t\t\tarvif->wep_keys[key->keyidx] = key;\n\t\telse\n\t\t\tarvif->wep_keys[key->keyidx] = NULL;\n\t}\n\n\t/* the peer should not disappear in mid-way (unless FW goes awry) since\n\t * we already hold conf_mutex. we just make sure its there now.\n\t */\n\tspin_lock_bh(&ar->data_lock);\n\tpeer = ath10k_peer_find(ar, arvif->vdev_id, peer_addr);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (!peer) {\n\t\tif (cmd == SET_KEY) {\n\t\t\tath10k_warn(ar, \"failed to install key for non-existent peer %pM\\n\",\n\t\t\t\t    peer_addr);\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto exit;\n\t\t} else {\n\t\t\t/* if the peer doesn't exist there is no key to disable anymore */\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\n\t\tflags |= WMI_KEY_PAIRWISE;\n\telse\n\t\tflags |= WMI_KEY_GROUP;\n\n\tif (is_wep) {\n\t\tif (cmd == DISABLE_KEY)\n\t\t\tath10k_clear_vdev_key(arvif, key);\n\n\t\t/* When WEP keys are uploaded it's possible that there are\n\t\t * stations associated already (e.g. when merging) without any\n\t\t * keys. Static WEP needs an explicit per-peer key upload.\n\t\t */\n\t\tif (vif->type == NL80211_IFTYPE_ADHOC &&\n\t\t    cmd == SET_KEY)\n\t\t\tath10k_mac_vif_update_wep_key(arvif, key);\n\n\t\t/* 802.1x never sets the def_wep_key_idx so each set_key()\n\t\t * call changes default tx key.\n\t\t *\n\t\t * Static WEP sets def_wep_key_idx via .set_default_unicast_key\n\t\t * after first set_key().\n\t\t */\n\t\tif (cmd == SET_KEY && arvif->def_wep_key_idx == -1)\n\t\t\tflags |= WMI_KEY_TX_USAGE;\n\t}\n\n\tret = ath10k_install_key(arvif, key, cmd, peer_addr, flags);\n\tif (ret) {\n\t\tWARN_ON(ret > 0);\n\t\tath10k_warn(ar, \"failed to install key for vdev %i peer %pM: %d\\n\",\n\t\t\t    arvif->vdev_id, peer_addr, ret);\n\t\tgoto exit;\n\t}\n\n\t/* mac80211 sets static WEP keys as groupwise while firmware requires\n\t * them to be installed twice as both pairwise and groupwise.\n\t */\n\tif (is_wep && !sta && vif->type == NL80211_IFTYPE_STATION) {\n\t\tflags2 = flags;\n\t\tflags2 &= ~WMI_KEY_GROUP;\n\t\tflags2 |= WMI_KEY_PAIRWISE;\n\n\t\tret = ath10k_install_key(arvif, key, cmd, peer_addr, flags2);\n\t\tif (ret) {\n\t\t\tWARN_ON(ret > 0);\n\t\t\tath10k_warn(ar, \"failed to install (ucast) key for vdev %i peer %pM: %d\\n\",\n\t\t\t\t    arvif->vdev_id, peer_addr, ret);\n\t\t\tret2 = ath10k_install_key(arvif, key, DISABLE_KEY,\n\t\t\t\t\t\t  peer_addr, flags);\n\t\t\tif (ret2) {\n\t\t\t\tWARN_ON(ret2 > 0);\n\t\t\t\tath10k_warn(ar, \"failed to disable (mcast) key for vdev %i peer %pM: %d\\n\",\n\t\t\t\t\t    arvif->vdev_id, peer_addr, ret2);\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tath10k_set_key_h_def_keyidx(ar, arvif, cmd, key);\n\n\tspin_lock_bh(&ar->data_lock);\n\tpeer = ath10k_peer_find(ar, arvif->vdev_id, peer_addr);\n\tif (peer && cmd == SET_KEY)\n\t\tpeer->keys[key->keyidx] = key;\n\telse if (peer && cmd == DISABLE_KEY)\n\t\tpeer->keys[key->keyidx] = NULL;\n\telse if (peer == NULL)\n\t\t/* impossible unless FW goes crazy */\n\t\tath10k_warn(ar, \"Peer %pM disappeared!\\n\", peer_addr);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (sta && sta->tdls)\n\t\tath10k_wmi_peer_set_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\t  ar->wmi.peer_param->authorize, 1);\n\telse if (sta && cmd == SET_KEY && (key->flags & IEEE80211_KEY_FLAG_PAIRWISE))\n\t\tath10k_wmi_peer_set_param(ar, arvif->vdev_id, peer_addr,\n\t\t\t\t\t  ar->wmi.peer_param->authorize, 1);\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic void ath10k_set_default_unicast_key(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   int keyidx)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tint ret;\n\n\tmutex_lock(&arvif->ar->conf_mutex);\n\n\tif (arvif->ar->state != ATH10K_STATE_ON)\n\t\tgoto unlock;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %d set keyidx %d\\n\",\n\t\t   arvif->vdev_id, keyidx);\n\n\tret = ath10k_wmi_vdev_set_param(arvif->ar,\n\t\t\t\t\tarvif->vdev_id,\n\t\t\t\t\tarvif->ar->wmi.vdev_param->def_keyid,\n\t\t\t\t\tkeyidx);\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to update wep key index for vdev %d: %d\\n\",\n\t\t\t    arvif->vdev_id,\n\t\t\t    ret);\n\t\tgoto unlock;\n\t}\n\n\tarvif->def_wep_key_idx = keyidx;\n\nunlock:\n\tmutex_unlock(&arvif->ar->conf_mutex);\n}\n\nstatic void ath10k_sta_rc_update_wk(struct work_struct *wk)\n{\n\tstruct ath10k *ar;\n\tstruct ath10k_vif *arvif;\n\tstruct ath10k_sta *arsta;\n\tstruct ieee80211_sta *sta;\n\tstruct cfg80211_chan_def def;\n\tenum nl80211_band band;\n\tconst u8 *ht_mcs_mask;\n\tconst u16 *vht_mcs_mask;\n\tu32 changed, bw, nss, smps;\n\tint err;\n\n\tarsta = container_of(wk, struct ath10k_sta, update_wk);\n\tsta = container_of((void *)arsta, struct ieee80211_sta, drv_priv);\n\tarvif = arsta->arvif;\n\tar = arvif->ar;\n\n\tif (WARN_ON(ath10k_mac_vif_chan(arvif->vif, &def)))\n\t\treturn;\n\n\tband = def.chan->band;\n\tht_mcs_mask = arvif->bitrate_mask.control[band].ht_mcs;\n\tvht_mcs_mask = arvif->bitrate_mask.control[band].vht_mcs;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tchanged = arsta->changed;\n\tarsta->changed = 0;\n\n\tbw = arsta->bw;\n\tnss = arsta->nss;\n\tsmps = arsta->smps;\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tnss = max_t(u32, 1, nss);\n\tnss = min(nss, max(ath10k_mac_max_ht_nss(ht_mcs_mask),\n\t\t\t   ath10k_mac_max_vht_nss(vht_mcs_mask)));\n\n\tif (changed & IEEE80211_RC_BW_CHANGED) {\n\t\tenum wmi_phy_mode mode;\n\n\t\tmode = chan_to_phymode(&def);\n\t\tath10k_dbg(ar, ATH10K_DBG_STA, \"mac update sta %pM peer bw %d phymode %d\\n\",\n\t\t\t   sta->addr, bw, mode);\n\n\t\terr = ath10k_wmi_peer_set_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\t\tar->wmi.peer_param->phymode, mode);\n\t\tif (err) {\n\t\t\tath10k_warn(ar, \"failed to update STA %pM peer phymode %d: %d\\n\",\n\t\t\t\t    sta->addr, mode, err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\terr = ath10k_wmi_peer_set_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\t\tar->wmi.peer_param->chan_width, bw);\n\t\tif (err)\n\t\t\tath10k_warn(ar, \"failed to update STA %pM peer bw %d: %d\\n\",\n\t\t\t\t    sta->addr, bw, err);\n\t}\n\n\tif (changed & IEEE80211_RC_NSS_CHANGED) {\n\t\tath10k_dbg(ar, ATH10K_DBG_STA, \"mac update sta %pM nss %d\\n\",\n\t\t\t   sta->addr, nss);\n\n\t\terr = ath10k_wmi_peer_set_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\t\tar->wmi.peer_param->nss, nss);\n\t\tif (err)\n\t\t\tath10k_warn(ar, \"failed to update STA %pM nss %d: %d\\n\",\n\t\t\t\t    sta->addr, nss, err);\n\t}\n\n\tif (changed & IEEE80211_RC_SMPS_CHANGED) {\n\t\tath10k_dbg(ar, ATH10K_DBG_STA, \"mac update sta %pM smps %d\\n\",\n\t\t\t   sta->addr, smps);\n\n\t\terr = ath10k_wmi_peer_set_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\t\tar->wmi.peer_param->smps_state, smps);\n\t\tif (err)\n\t\t\tath10k_warn(ar, \"failed to update STA %pM smps %d: %d\\n\",\n\t\t\t\t    sta->addr, smps, err);\n\t}\n\n\tif (changed & IEEE80211_RC_SUPP_RATES_CHANGED) {\n\t\tath10k_dbg(ar, ATH10K_DBG_STA, \"mac update sta %pM supp rates\\n\",\n\t\t\t   sta->addr);\n\n\t\terr = ath10k_station_assoc(ar, arvif->vif, sta, true);\n\t\tif (err)\n\t\t\tath10k_warn(ar, \"failed to reassociate station: %pM\\n\",\n\t\t\t\t    sta->addr);\n\t}\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic int ath10k_mac_inc_num_stations(struct ath10k_vif *arvif,\n\t\t\t\t       struct ieee80211_sta *sta)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_STA && !sta->tdls)\n\t\treturn 0;\n\n\tif (ar->num_stations >= ar->max_num_stations)\n\t\treturn -ENOBUFS;\n\n\tar->num_stations++;\n\n\treturn 0;\n}\n\nstatic void ath10k_mac_dec_num_stations(struct ath10k_vif *arvif,\n\t\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_STA && !sta->tdls)\n\t\treturn;\n\n\tar->num_stations--;\n}\n\nstatic int ath10k_sta_set_txpwr(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tint ret = 0;\n\ts16 txpwr;\n\n\tif (sta->txpwr.type == NL80211_TX_POWER_AUTOMATIC) {\n\t\ttxpwr = 0;\n\t} else {\n\t\ttxpwr = sta->txpwr.power;\n\t\tif (!txpwr)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (txpwr > ATH10K_TX_POWER_MAX_VAL || txpwr < ATH10K_TX_POWER_MIN_VAL)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tret = ath10k_wmi_peer_set_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\tar->wmi.peer_param->use_fixed_power, txpwr);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set tx power for station ret: %d\\n\",\n\t\t\t    ret);\n\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstruct ath10k_mac_iter_tid_conf_data {\n\tstruct ieee80211_vif *curr_vif;\n\tstruct ath10k *ar;\n\tbool reset_config;\n};\n\nstatic bool\nath10k_mac_bitrate_mask_has_single_rate(struct ath10k *ar,\n\t\t\t\t\tenum nl80211_band band,\n\t\t\t\t\tconst struct cfg80211_bitrate_mask *mask,\n\t\t\t\t\tint *vht_num_rates)\n{\n\tint num_rates = 0;\n\tint i, tmp;\n\n\tnum_rates += hweight32(mask->control[band].legacy);\n\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].ht_mcs); i++)\n\t\tnum_rates += hweight8(mask->control[band].ht_mcs[i]);\n\n\t*vht_num_rates = 0;\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].vht_mcs); i++) {\n\t\ttmp = hweight16(mask->control[band].vht_mcs[i]);\n\t\tnum_rates += tmp;\n\t\t*vht_num_rates += tmp;\n\t}\n\n\treturn num_rates == 1;\n}\n\nstatic int\nath10k_mac_bitrate_mask_get_single_rate(struct ath10k *ar,\n\t\t\t\t\tenum nl80211_band band,\n\t\t\t\t\tconst struct cfg80211_bitrate_mask *mask,\n\t\t\t\t\tu8 *rate, u8 *nss, bool vht_only)\n{\n\tint rate_idx;\n\tint i;\n\tu16 bitrate;\n\tu8 preamble;\n\tu8 hw_rate;\n\n\tif (vht_only)\n\t\tgoto next;\n\n\tif (hweight32(mask->control[band].legacy) == 1) {\n\t\trate_idx = ffs(mask->control[band].legacy) - 1;\n\n\t\tif (ar->phy_capability & WHAL_WLAN_11A_CAPABILITY)\n\t\t\trate_idx += ATH10K_MAC_FIRST_OFDM_RATE_IDX;\n\n\t\thw_rate = ath10k_wmi_legacy_rates[rate_idx].hw_value;\n\t\tbitrate = ath10k_wmi_legacy_rates[rate_idx].bitrate;\n\n\t\tif (ath10k_mac_bitrate_is_cck(bitrate))\n\t\t\tpreamble = WMI_RATE_PREAMBLE_CCK;\n\t\telse\n\t\t\tpreamble = WMI_RATE_PREAMBLE_OFDM;\n\n\t\t*nss = 1;\n\t\t*rate = preamble << 6 |\n\t\t\t(*nss - 1) << 4 |\n\t\t\thw_rate << 0;\n\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].ht_mcs); i++) {\n\t\tif (hweight8(mask->control[band].ht_mcs[i]) == 1) {\n\t\t\t*nss = i + 1;\n\t\t\t*rate = WMI_RATE_PREAMBLE_HT << 6 |\n\t\t\t\t(*nss - 1) << 4 |\n\t\t\t\t(ffs(mask->control[band].ht_mcs[i]) - 1);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\nnext:\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].vht_mcs); i++) {\n\t\tif (hweight16(mask->control[band].vht_mcs[i]) == 1) {\n\t\t\t*nss = i + 1;\n\t\t\t*rate = WMI_RATE_PREAMBLE_VHT << 6 |\n\t\t\t\t(*nss - 1) << 4 |\n\t\t\t\t(ffs(mask->control[band].vht_mcs[i]) - 1);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ath10k_mac_validate_rate_mask(struct ath10k *ar,\n\t\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t\t u32 rate_ctrl_flag, u8 nss)\n{\n\tif (nss > sta->rx_nss) {\n\t\tath10k_warn(ar, \"Invalid nss field, configured %u limit %u\\n\",\n\t\t\t    nss, sta->rx_nss);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ATH10K_HW_PREAMBLE(rate_ctrl_flag) == WMI_RATE_PREAMBLE_VHT) {\n\t\tif (!sta->vht_cap.vht_supported) {\n\t\t\tath10k_warn(ar, \"Invalid VHT rate for sta %pM\\n\",\n\t\t\t\t    sta->addr);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (ATH10K_HW_PREAMBLE(rate_ctrl_flag) == WMI_RATE_PREAMBLE_HT) {\n\t\tif (!sta->ht_cap.ht_supported || sta->vht_cap.vht_supported) {\n\t\t\tath10k_warn(ar, \"Invalid HT rate for sta %pM\\n\",\n\t\t\t\t    sta->addr);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (sta->ht_cap.ht_supported || sta->vht_cap.vht_supported)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nath10k_mac_tid_bitrate_config(struct ath10k *ar,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      u32 *rate_ctrl_flag, u8 *rate_ctrl,\n\t\t\t      enum nl80211_tx_rate_setting txrate_type,\n\t\t\t      const struct cfg80211_bitrate_mask *mask)\n{\n\tstruct cfg80211_chan_def def;\n\tenum nl80211_band band;\n\tu8 nss, rate;\n\tint vht_num_rates, ret;\n\n\tif (WARN_ON(ath10k_mac_vif_chan(vif, &def)))\n\t\treturn -EINVAL;\n\n\tif (txrate_type == NL80211_TX_RATE_AUTOMATIC) {\n\t\t*rate_ctrl = WMI_TID_CONFIG_RATE_CONTROL_AUTO;\n\t\t*rate_ctrl_flag = 0;\n\t\treturn 0;\n\t}\n\n\tband = def.chan->band;\n\n\tif (!ath10k_mac_bitrate_mask_has_single_rate(ar, band, mask,\n\t\t\t\t\t\t     &vht_num_rates)) {\n\t\treturn -EINVAL;\n\t}\n\n\tret = ath10k_mac_bitrate_mask_get_single_rate(ar, band, mask,\n\t\t\t\t\t\t      &rate, &nss, false);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to get single rate: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\t*rate_ctrl_flag = rate;\n\n\tif (sta && ath10k_mac_validate_rate_mask(ar, sta, *rate_ctrl_flag, nss))\n\t\treturn -EINVAL;\n\n\tif (txrate_type == NL80211_TX_RATE_FIXED)\n\t\t*rate_ctrl = WMI_TID_CONFIG_RATE_CONTROL_FIXED_RATE;\n\telse if (txrate_type == NL80211_TX_RATE_LIMITED &&\n\t\t (test_bit(WMI_SERVICE_EXT_PEER_TID_CONFIGS_SUPPORT,\n\t\t\t   ar->wmi.svc_map)))\n\t\t*rate_ctrl = WMI_PEER_TID_CONFIG_RATE_UPPER_CAP;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_set_tid_config(struct ath10k *ar, struct ieee80211_sta *sta,\n\t\t\t\t     struct ieee80211_vif *vif, u32 changed,\n\t\t\t\t     struct wmi_per_peer_per_tid_cfg_arg *arg)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_sta *arsta;\n\tint ret;\n\n\tif (sta) {\n\t\tif (!sta->wme)\n\t\t\treturn -ENOTSUPP;\n\n\t\tarsta = (struct ath10k_sta *)sta->drv_priv;\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_NOACK)) {\n\t\t\tif ((arsta->retry_long[arg->tid] > 0 ||\n\t\t\t     arsta->rate_code[arg->tid] > 0 ||\n\t\t\t     arsta->ampdu[arg->tid] ==\n\t\t\t\t\tWMI_TID_CONFIG_AGGR_CONTROL_ENABLE) &&\n\t\t\t     arg->ack_policy == WMI_PEER_TID_CONFIG_NOACK) {\n\t\t\t\tchanged &= ~BIT(NL80211_TID_CONFIG_ATTR_NOACK);\n\t\t\t\targ->ack_policy = 0;\n\t\t\t\targ->aggr_control = 0;\n\t\t\t\targ->rate_ctrl = 0;\n\t\t\t\targ->rcode_flags = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL)) {\n\t\t\tif (arsta->noack[arg->tid] == WMI_PEER_TID_CONFIG_NOACK ||\n\t\t\t    arvif->noack[arg->tid] == WMI_PEER_TID_CONFIG_NOACK) {\n\t\t\t\targ->aggr_control = 0;\n\t\t\t\tchanged &= ~BIT(NL80211_TID_CONFIG_ATTR_RETRY_LONG);\n\t\t\t}\n\t\t}\n\n\t\tif (changed & (BIT(NL80211_TID_CONFIG_ATTR_TX_RATE) |\n\t\t    BIT(NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE))) {\n\t\t\tif (arsta->noack[arg->tid] == WMI_PEER_TID_CONFIG_NOACK ||\n\t\t\t    arvif->noack[arg->tid] == WMI_PEER_TID_CONFIG_NOACK) {\n\t\t\t\targ->rate_ctrl = 0;\n\t\t\t\targ->rcode_flags = 0;\n\t\t\t}\n\t\t}\n\n\t\tether_addr_copy(arg->peer_macaddr.addr, sta->addr);\n\n\t\tret = ath10k_wmi_set_per_peer_per_tid_cfg(ar, arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Store the configured parameters in success case */\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_NOACK)) {\n\t\t\tarsta->noack[arg->tid] = arg->ack_policy;\n\t\t\targ->ack_policy = 0;\n\t\t\targ->aggr_control = 0;\n\t\t\targ->rate_ctrl = 0;\n\t\t\targ->rcode_flags = 0;\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_RETRY_LONG)) {\n\t\t\tarsta->retry_long[arg->tid] = arg->retry_count;\n\t\t\targ->retry_count = 0;\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL)) {\n\t\t\tarsta->ampdu[arg->tid] = arg->aggr_control;\n\t\t\targ->aggr_control = 0;\n\t\t}\n\n\t\tif (changed & (BIT(NL80211_TID_CONFIG_ATTR_TX_RATE) |\n\t\t    BIT(NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE))) {\n\t\t\tarsta->rate_ctrl[arg->tid] = arg->rate_ctrl;\n\t\t\targ->rate_ctrl = 0;\n\t\t\targ->rcode_flags = 0;\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL)) {\n\t\t\tarsta->rtscts[arg->tid] = arg->rtscts_ctrl;\n\t\t\targ->ext_tid_cfg_bitmap = 0;\n\t\t}\n\t} else {\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_NOACK)) {\n\t\t\tif ((arvif->retry_long[arg->tid] ||\n\t\t\t     arvif->rate_code[arg->tid] ||\n\t\t\t     arvif->ampdu[arg->tid] ==\n\t\t\t\t\tWMI_TID_CONFIG_AGGR_CONTROL_ENABLE) &&\n\t\t\t     arg->ack_policy == WMI_PEER_TID_CONFIG_NOACK) {\n\t\t\t\tchanged &= ~BIT(NL80211_TID_CONFIG_ATTR_NOACK);\n\t\t\t} else {\n\t\t\t\tarvif->noack[arg->tid] = arg->ack_policy;\n\t\t\t\tarvif->ampdu[arg->tid] = arg->aggr_control;\n\t\t\t\tarvif->rate_ctrl[arg->tid] = arg->rate_ctrl;\n\t\t\t}\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_RETRY_LONG)) {\n\t\t\tif (arvif->noack[arg->tid] == WMI_PEER_TID_CONFIG_NOACK)\n\t\t\t\tchanged &= ~BIT(NL80211_TID_CONFIG_ATTR_RETRY_LONG);\n\t\t\telse\n\t\t\t\tarvif->retry_long[arg->tid] = arg->retry_count;\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL)) {\n\t\t\tif (arvif->noack[arg->tid] == WMI_PEER_TID_CONFIG_NOACK)\n\t\t\t\tchanged &= ~BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL);\n\t\t\telse\n\t\t\t\tarvif->ampdu[arg->tid] = arg->aggr_control;\n\t\t}\n\n\t\tif (changed & (BIT(NL80211_TID_CONFIG_ATTR_TX_RATE) |\n\t\t    BIT(NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE))) {\n\t\t\tif (arvif->noack[arg->tid] == WMI_PEER_TID_CONFIG_NOACK) {\n\t\t\t\tchanged &= ~(BIT(NL80211_TID_CONFIG_ATTR_TX_RATE) |\n\t\t\t\t\t     BIT(NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE));\n\t\t\t} else {\n\t\t\t\tarvif->rate_ctrl[arg->tid] = arg->rate_ctrl;\n\t\t\t\tarvif->rate_code[arg->tid] = arg->rcode_flags;\n\t\t\t}\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL)) {\n\t\t\tarvif->rtscts[arg->tid] = arg->rtscts_ctrl;\n\t\t\targ->ext_tid_cfg_bitmap = 0;\n\t\t}\n\n\t\tif (changed)\n\t\t\tarvif->tid_conf_changed[arg->tid] |= changed;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nath10k_mac_parse_tid_config(struct ath10k *ar,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct cfg80211_tid_cfg *tid_conf,\n\t\t\t    struct wmi_per_peer_per_tid_cfg_arg *arg)\n{\n\tu32 changed = tid_conf->mask;\n\tint ret = 0, i = 0;\n\n\tif (!changed)\n\t\treturn -EINVAL;\n\n\twhile (i < ATH10K_TID_MAX) {\n\t\tif (!(tid_conf->tids & BIT(i))) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\targ->tid = i;\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_NOACK)) {\n\t\t\tif (tid_conf->noack == NL80211_TID_CONFIG_ENABLE) {\n\t\t\t\targ->ack_policy = WMI_PEER_TID_CONFIG_NOACK;\n\t\t\t\targ->rate_ctrl =\n\t\t\t\tWMI_TID_CONFIG_RATE_CONTROL_DEFAULT_LOWEST_RATE;\n\t\t\t\targ->aggr_control =\n\t\t\t\t\tWMI_TID_CONFIG_AGGR_CONTROL_DISABLE;\n\t\t\t} else {\n\t\t\t\targ->ack_policy =\n\t\t\t\t\tWMI_PEER_TID_CONFIG_ACK;\n\t\t\t\targ->rate_ctrl =\n\t\t\t\t\tWMI_TID_CONFIG_RATE_CONTROL_AUTO;\n\t\t\t\targ->aggr_control =\n\t\t\t\t\tWMI_TID_CONFIG_AGGR_CONTROL_ENABLE;\n\t\t\t}\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_RETRY_LONG))\n\t\t\targ->retry_count = tid_conf->retry_long;\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL)) {\n\t\t\tif (tid_conf->noack == NL80211_TID_CONFIG_ENABLE)\n\t\t\t\targ->aggr_control = WMI_TID_CONFIG_AGGR_CONTROL_ENABLE;\n\t\t\telse\n\t\t\t\targ->aggr_control = WMI_TID_CONFIG_AGGR_CONTROL_DISABLE;\n\t\t}\n\n\t\tif (changed & (BIT(NL80211_TID_CONFIG_ATTR_TX_RATE) |\n\t\t    BIT(NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE))) {\n\t\t\tret = ath10k_mac_tid_bitrate_config(ar, vif, sta,\n\t\t\t\t\t\t\t    &arg->rcode_flags,\n\t\t\t\t\t\t\t    &arg->rate_ctrl,\n\t\t\t\t\t\t\t    tid_conf->txrate_type,\n\t\t\t\t\t\t\t&tid_conf->txrate_mask);\n\t\t\tif (ret) {\n\t\t\t\tath10k_warn(ar, \"failed to configure bitrate mask %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\targ->rcode_flags = 0;\n\t\t\t\targ->rate_ctrl = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL)) {\n\t\t\tif (tid_conf->rtscts)\n\t\t\t\targ->rtscts_ctrl = tid_conf->rtscts;\n\n\t\t\targ->ext_tid_cfg_bitmap = WMI_EXT_TID_RTS_CTS_CONFIG;\n\t\t}\n\n\t\tret = ath10k_mac_set_tid_config(ar, sta, vif, changed, arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\ti++;\n\t}\n\n\treturn ret;\n}\n\nstatic int ath10k_mac_reset_tid_config(struct ath10k *ar,\n\t\t\t\t       struct ieee80211_sta *sta,\n\t\t\t\t       struct ath10k_vif *arvif,\n\t\t\t\t       u8 tids)\n{\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct wmi_per_peer_per_tid_cfg_arg arg;\n\tint ret = 0, i = 0;\n\n\targ.vdev_id = arvif->vdev_id;\n\twhile (i < ATH10K_TID_MAX) {\n\t\tif (!(tids & BIT(i))) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\targ.tid = i;\n\t\targ.ack_policy = WMI_PEER_TID_CONFIG_ACK;\n\t\targ.retry_count = ATH10K_MAX_RETRY_COUNT;\n\t\targ.rate_ctrl = WMI_TID_CONFIG_RATE_CONTROL_AUTO;\n\t\targ.aggr_control = WMI_TID_CONFIG_AGGR_CONTROL_ENABLE;\n\t\targ.rtscts_ctrl = WMI_TID_CONFIG_RTSCTS_CONTROL_ENABLE;\n\t\targ.ext_tid_cfg_bitmap = WMI_EXT_TID_RTS_CTS_CONFIG;\n\n\t\tether_addr_copy(arg.peer_macaddr.addr, sta->addr);\n\n\t\tret = ath10k_wmi_set_per_peer_per_tid_cfg(ar, &arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!arvif->tids_rst) {\n\t\t\tarsta->retry_long[i] = -1;\n\t\t\tarsta->noack[i] = -1;\n\t\t\tarsta->ampdu[i] = -1;\n\t\t\tarsta->rate_code[i] = -1;\n\t\t\tarsta->rate_ctrl[i] = 0;\n\t\t\tarsta->rtscts[i] = -1;\n\t\t} else {\n\t\t\tarvif->retry_long[i] = 0;\n\t\t\tarvif->noack[i] = 0;\n\t\t\tarvif->ampdu[i] = 0;\n\t\t\tarvif->rate_code[i] = 0;\n\t\t\tarvif->rate_ctrl[i] = 0;\n\t\t\tarvif->rtscts[i] = 0;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn ret;\n}\n\nstatic void ath10k_sta_tid_cfg_wk(struct work_struct *wk)\n{\n\tstruct wmi_per_peer_per_tid_cfg_arg arg = {};\n\tstruct ieee80211_sta *sta;\n\tstruct ath10k_sta *arsta;\n\tstruct ath10k_vif *arvif;\n\tstruct ath10k *ar;\n\tbool config_apply;\n\tint ret, i;\n\tu32 changed;\n\tu8 nss;\n\n\tarsta = container_of(wk, struct ath10k_sta, tid_config_wk);\n\tsta = container_of((void *)arsta, struct ieee80211_sta, drv_priv);\n\tarvif = arsta->arvif;\n\tar = arvif->ar;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (arvif->tids_rst) {\n\t\tret = ath10k_mac_reset_tid_config(ar, sta, arvif,\n\t\t\t\t\t\t  arvif->tids_rst);\n\t\tgoto exit;\n\t}\n\n\tether_addr_copy(arg.peer_macaddr.addr, sta->addr);\n\n\tfor (i = 0; i < ATH10K_TID_MAX; i++) {\n\t\tconfig_apply = false;\n\t\tchanged = arvif->tid_conf_changed[i];\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_NOACK)) {\n\t\t\tif (arsta->noack[i] != -1) {\n\t\t\t\targ.ack_policy  = 0;\n\t\t\t} else {\n\t\t\t\tconfig_apply = true;\n\t\t\t\targ.ack_policy = arvif->noack[i];\n\t\t\t\targ.aggr_control = arvif->ampdu[i];\n\t\t\t\targ.rate_ctrl = arvif->rate_ctrl[i];\n\t\t\t}\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_RETRY_LONG)) {\n\t\t\tif (arsta->retry_long[i] != -1 ||\n\t\t\t    arsta->noack[i] == WMI_PEER_TID_CONFIG_NOACK ||\n\t\t\t    arvif->noack[i] == WMI_PEER_TID_CONFIG_NOACK) {\n\t\t\t\targ.retry_count = 0;\n\t\t\t} else {\n\t\t\t\targ.retry_count = arvif->retry_long[i];\n\t\t\t\tconfig_apply = true;\n\t\t\t}\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL)) {\n\t\t\tif (arsta->ampdu[i] != -1 ||\n\t\t\t    arsta->noack[i] == WMI_PEER_TID_CONFIG_NOACK ||\n\t\t\t    arvif->noack[i] == WMI_PEER_TID_CONFIG_NOACK) {\n\t\t\t\targ.aggr_control = 0;\n\t\t\t} else {\n\t\t\t\targ.aggr_control = arvif->ampdu[i];\n\t\t\t\tconfig_apply = true;\n\t\t\t}\n\t\t}\n\n\t\tif (changed & (BIT(NL80211_TID_CONFIG_ATTR_TX_RATE) |\n\t\t    BIT(NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE))) {\n\t\t\tnss = ATH10K_HW_NSS(arvif->rate_code[i]);\n\t\t\tret = ath10k_mac_validate_rate_mask(ar, sta,\n\t\t\t\t\t\t\t    arvif->rate_code[i],\n\t\t\t\t\t\t\t    nss);\n\t\t\tif (ret &&\n\t\t\t    arvif->rate_ctrl[i] > WMI_TID_CONFIG_RATE_CONTROL_AUTO) {\n\t\t\t\targ.rate_ctrl = 0;\n\t\t\t\targ.rcode_flags = 0;\n\t\t\t}\n\n\t\t\tif (arsta->rate_ctrl[i] >\n\t\t\t    WMI_TID_CONFIG_RATE_CONTROL_AUTO ||\n\t\t\t    arsta->noack[i] == WMI_PEER_TID_CONFIG_NOACK ||\n\t\t\t    arvif->noack[i] == WMI_PEER_TID_CONFIG_NOACK) {\n\t\t\t\targ.rate_ctrl = 0;\n\t\t\t\targ.rcode_flags = 0;\n\t\t\t} else {\n\t\t\t\targ.rate_ctrl = arvif->rate_ctrl[i];\n\t\t\t\targ.rcode_flags = arvif->rate_code[i];\n\t\t\t\tconfig_apply = true;\n\t\t\t}\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL)) {\n\t\t\tif (arsta->rtscts[i]) {\n\t\t\t\targ.rtscts_ctrl = 0;\n\t\t\t\targ.ext_tid_cfg_bitmap = 0;\n\t\t\t} else {\n\t\t\t\targ.rtscts_ctrl = arvif->rtscts[i] - 1;\n\t\t\t\targ.ext_tid_cfg_bitmap =\n\t\t\t\t\tWMI_EXT_TID_RTS_CTS_CONFIG;\n\t\t\t\tconfig_apply = true;\n\t\t\t}\n\t\t}\n\n\t\targ.tid = i;\n\n\t\tif (config_apply) {\n\t\t\tret = ath10k_wmi_set_per_peer_per_tid_cfg(ar, &arg);\n\t\t\tif (ret)\n\t\t\t\tath10k_warn(ar, \"failed to set per tid config for sta %pM: %d\\n\",\n\t\t\t\t\t    sta->addr, ret);\n\t\t}\n\n\t\targ.ack_policy  = 0;\n\t\targ.retry_count  = 0;\n\t\targ.aggr_control  = 0;\n\t\targ.rate_ctrl = 0;\n\t\targ.rcode_flags = 0;\n\t}\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic void ath10k_mac_vif_stations_tid_conf(void *data,\n\t\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k_mac_iter_tid_conf_data *iter_data = data;\n\tstruct ieee80211_vif *sta_vif = arsta->arvif->vif;\n\n\tif (sta_vif != iter_data->curr_vif || !sta->wme)\n\t\treturn;\n\n\tieee80211_queue_work(iter_data->ar->hw, &arsta->tid_config_wk);\n}\n\nstatic int ath10k_sta_state(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    enum ieee80211_sta_state old_state,\n\t\t\t    enum ieee80211_sta_state new_state)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k_peer *peer;\n\tint ret = 0;\n\tint i;\n\n\tif (old_state == IEEE80211_STA_NOTEXIST &&\n\t    new_state == IEEE80211_STA_NONE) {\n\t\tmemset(arsta, 0, sizeof(*arsta));\n\t\tarsta->arvif = arvif;\n\t\tarsta->peer_ps_state = WMI_PEER_PS_STATE_DISABLED;\n\t\tINIT_WORK(&arsta->update_wk, ath10k_sta_rc_update_wk);\n\t\tINIT_WORK(&arsta->tid_config_wk, ath10k_sta_tid_cfg_wk);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(sta->txq); i++)\n\t\t\tath10k_mac_txq_init(sta->txq[i]);\n\t}\n\n\t/* cancel must be done outside the mutex to avoid deadlock */\n\tif ((old_state == IEEE80211_STA_NONE &&\n\t     new_state == IEEE80211_STA_NOTEXIST)) {\n\t\tcancel_work_sync(&arsta->update_wk);\n\t\tcancel_work_sync(&arsta->tid_config_wk);\n\t}\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (old_state == IEEE80211_STA_NOTEXIST &&\n\t    new_state == IEEE80211_STA_NONE) {\n\t\t/*\n\t\t * New station addition.\n\t\t */\n\t\tenum wmi_peer_type peer_type = WMI_PEER_TYPE_DEFAULT;\n\t\tu32 num_tdls_stations;\n\n\t\tath10k_dbg(ar, ATH10K_DBG_STA,\n\t\t\t   \"mac vdev %d peer create %pM (new sta) sta %d / %d peer %d / %d\\n\",\n\t\t\t   arvif->vdev_id, sta->addr,\n\t\t\t   ar->num_stations + 1, ar->max_num_stations,\n\t\t\t   ar->num_peers + 1, ar->max_num_peers);\n\n\t\tnum_tdls_stations = ath10k_mac_tdls_vif_stations_count(hw, vif);\n\n\t\tif (sta->tdls) {\n\t\t\tif (num_tdls_stations >= ar->max_num_tdls_vdevs) {\n\t\t\t\tath10k_warn(ar, \"vdev %i exceeded maximum number of tdls vdevs %i\\n\",\n\t\t\t\t\t    arvif->vdev_id,\n\t\t\t\t\t    ar->max_num_tdls_vdevs);\n\t\t\t\tret = -ELNRNG;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tpeer_type = WMI_PEER_TYPE_TDLS;\n\t\t}\n\n\t\tret = ath10k_mac_inc_num_stations(arvif, sta);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"refusing to associate station: too many connected already (%d)\\n\",\n\t\t\t\t    ar->max_num_stations);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (ath10k_debug_is_extd_tx_stats_enabled(ar)) {\n\t\t\tarsta->tx_stats = kzalloc(sizeof(*arsta->tx_stats),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!arsta->tx_stats) {\n\t\t\t\tath10k_mac_dec_num_stations(arvif, sta);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tret = ath10k_peer_create(ar, vif, sta, arvif->vdev_id,\n\t\t\t\t\t sta->addr, peer_type);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to add peer %pM for vdev %d when adding a new sta: %i\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t\t\tath10k_mac_dec_num_stations(arvif, sta);\n\t\t\tkfree(arsta->tx_stats);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tspin_lock_bh(&ar->data_lock);\n\n\t\tpeer = ath10k_peer_find(ar, arvif->vdev_id, sta->addr);\n\t\tif (!peer) {\n\t\t\tath10k_warn(ar, \"failed to lookup peer %pM on vdev %i\\n\",\n\t\t\t\t    vif->addr, arvif->vdev_id);\n\t\t\tspin_unlock_bh(&ar->data_lock);\n\t\t\tath10k_peer_delete(ar, arvif->vdev_id, sta->addr);\n\t\t\tath10k_mac_dec_num_stations(arvif, sta);\n\t\t\tkfree(arsta->tx_stats);\n\t\t\tret = -ENOENT;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tarsta->peer_id = find_first_bit(peer->peer_ids,\n\t\t\t\t\t\tATH10K_MAX_NUM_PEER_IDS);\n\n\t\tspin_unlock_bh(&ar->data_lock);\n\n\t\tif (!sta->tdls)\n\t\t\tgoto exit;\n\n\t\tret = ath10k_wmi_update_fw_tdls_state(ar, arvif->vdev_id,\n\t\t\t\t\t\t      WMI_TDLS_ENABLE_ACTIVE);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to update fw tdls state on vdev %i: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tath10k_peer_delete(ar, arvif->vdev_id,\n\t\t\t\t\t   sta->addr);\n\t\t\tath10k_mac_dec_num_stations(arvif, sta);\n\t\t\tkfree(arsta->tx_stats);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = ath10k_mac_tdls_peer_update(ar, arvif->vdev_id, sta,\n\t\t\t\t\t\t  WMI_TDLS_PEER_STATE_PEERING);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"failed to update tdls peer %pM for vdev %d when adding a new sta: %i\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t\t\tath10k_peer_delete(ar, arvif->vdev_id, sta->addr);\n\t\t\tath10k_mac_dec_num_stations(arvif, sta);\n\t\t\tkfree(arsta->tx_stats);\n\n\t\t\tif (num_tdls_stations != 0)\n\t\t\t\tgoto exit;\n\t\t\tath10k_wmi_update_fw_tdls_state(ar, arvif->vdev_id,\n\t\t\t\t\t\t\tWMI_TDLS_DISABLE);\n\t\t}\n\t} else if ((old_state == IEEE80211_STA_NONE &&\n\t\t    new_state == IEEE80211_STA_NOTEXIST)) {\n\t\t/*\n\t\t * Existing station deletion.\n\t\t */\n\t\tath10k_dbg(ar, ATH10K_DBG_STA,\n\t\t\t   \"mac vdev %d peer delete %pM sta %pK (sta gone)\\n\",\n\t\t\t   arvif->vdev_id, sta->addr, sta);\n\n\t\tif (sta->tdls) {\n\t\t\tret = ath10k_mac_tdls_peer_update(ar, arvif->vdev_id,\n\t\t\t\t\t\t\t  sta,\n\t\t\t\t\t\t\t  WMI_TDLS_PEER_STATE_TEARDOWN);\n\t\t\tif (ret)\n\t\t\t\tath10k_warn(ar, \"failed to update tdls peer state for %pM state %d: %i\\n\",\n\t\t\t\t\t    sta->addr,\n\t\t\t\t\t    WMI_TDLS_PEER_STATE_TEARDOWN, ret);\n\t\t}\n\n\t\tret = ath10k_peer_delete(ar, arvif->vdev_id, sta->addr);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to delete peer %pM for vdev %d: %i\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\n\t\tath10k_mac_dec_num_stations(arvif, sta);\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tfor (i = 0; i < ARRAY_SIZE(ar->peer_map); i++) {\n\t\t\tpeer = ar->peer_map[i];\n\t\t\tif (!peer)\n\t\t\t\tcontinue;\n\n\t\t\tif (peer->sta == sta) {\n\t\t\t\tath10k_warn(ar, \"found sta peer %pM (ptr %pK id %d) entry on vdev %i after it was supposedly removed\\n\",\n\t\t\t\t\t    sta->addr, peer, i, arvif->vdev_id);\n\t\t\t\tpeer->sta = NULL;\n\n\t\t\t\t/* Clean up the peer object as well since we\n\t\t\t\t * must have failed to do this above.\n\t\t\t\t */\n\t\t\t\tlist_del(&peer->list);\n\t\t\t\tar->peer_map[i] = NULL;\n\t\t\t\tkfree(peer);\n\t\t\t\tar->num_peers--;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&ar->data_lock);\n\n\t\tif (ath10k_debug_is_extd_tx_stats_enabled(ar)) {\n\t\t\tkfree(arsta->tx_stats);\n\t\t\tarsta->tx_stats = NULL;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(sta->txq); i++)\n\t\t\tath10k_mac_txq_unref(ar, sta->txq[i]);\n\n\t\tif (!sta->tdls)\n\t\t\tgoto exit;\n\n\t\tif (ath10k_mac_tdls_vif_stations_count(hw, vif))\n\t\t\tgoto exit;\n\n\t\t/* This was the last tdls peer in current vif */\n\t\tret = ath10k_wmi_update_fw_tdls_state(ar, arvif->vdev_id,\n\t\t\t\t\t\t      WMI_TDLS_DISABLE);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to update fw tdls state on vdev %i: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t}\n\t} else if (old_state == IEEE80211_STA_AUTH &&\n\t\t   new_state == IEEE80211_STA_ASSOC &&\n\t\t   (vif->type == NL80211_IFTYPE_AP ||\n\t\t    vif->type == NL80211_IFTYPE_MESH_POINT ||\n\t\t    vif->type == NL80211_IFTYPE_ADHOC)) {\n\t\t/*\n\t\t * New association.\n\t\t */\n\t\tath10k_dbg(ar, ATH10K_DBG_STA, \"mac sta %pM associated\\n\",\n\t\t\t   sta->addr);\n\n\t\tret = ath10k_station_assoc(ar, vif, sta, false);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to associate station %pM for vdev %i: %i\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t} else if (old_state == IEEE80211_STA_ASSOC &&\n\t\t   new_state == IEEE80211_STA_AUTHORIZED &&\n\t\t   sta->tdls) {\n\t\t/*\n\t\t * Tdls station authorized.\n\t\t */\n\t\tath10k_dbg(ar, ATH10K_DBG_STA, \"mac tdls sta %pM authorized\\n\",\n\t\t\t   sta->addr);\n\n\t\tret = ath10k_station_assoc(ar, vif, sta, false);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to associate tdls station %pM for vdev %i: %i\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = ath10k_mac_tdls_peer_update(ar, arvif->vdev_id, sta,\n\t\t\t\t\t\t  WMI_TDLS_PEER_STATE_CONNECTED);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to update tdls peer %pM for vdev %i: %i\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t} else if (old_state == IEEE80211_STA_ASSOC &&\n\t\t    new_state == IEEE80211_STA_AUTH &&\n\t\t    (vif->type == NL80211_IFTYPE_AP ||\n\t\t     vif->type == NL80211_IFTYPE_MESH_POINT ||\n\t\t     vif->type == NL80211_IFTYPE_ADHOC)) {\n\t\t/*\n\t\t * Disassociation.\n\t\t */\n\t\tath10k_dbg(ar, ATH10K_DBG_STA, \"mac sta %pM disassociated\\n\",\n\t\t\t   sta->addr);\n\n\t\tret = ath10k_station_disassoc(ar, vif, sta);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to disassociate station: %pM vdev %i: %i\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t}\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath10k_conf_tx_uapsd(struct ath10k *ar, struct ieee80211_vif *vif,\n\t\t\t\tu16 ac, bool enable)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct wmi_sta_uapsd_auto_trig_arg arg = {};\n\tu32 prio = 0, acc = 0;\n\tu32 value = 0;\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_STA)\n\t\treturn 0;\n\n\tswitch (ac) {\n\tcase IEEE80211_AC_VO:\n\t\tvalue = WMI_STA_PS_UAPSD_AC3_DELIVERY_EN |\n\t\t\tWMI_STA_PS_UAPSD_AC3_TRIGGER_EN;\n\t\tprio = 7;\n\t\tacc = 3;\n\t\tbreak;\n\tcase IEEE80211_AC_VI:\n\t\tvalue = WMI_STA_PS_UAPSD_AC2_DELIVERY_EN |\n\t\t\tWMI_STA_PS_UAPSD_AC2_TRIGGER_EN;\n\t\tprio = 5;\n\t\tacc = 2;\n\t\tbreak;\n\tcase IEEE80211_AC_BE:\n\t\tvalue = WMI_STA_PS_UAPSD_AC1_DELIVERY_EN |\n\t\t\tWMI_STA_PS_UAPSD_AC1_TRIGGER_EN;\n\t\tprio = 2;\n\t\tacc = 1;\n\t\tbreak;\n\tcase IEEE80211_AC_BK:\n\t\tvalue = WMI_STA_PS_UAPSD_AC0_DELIVERY_EN |\n\t\t\tWMI_STA_PS_UAPSD_AC0_TRIGGER_EN;\n\t\tprio = 0;\n\t\tacc = 0;\n\t\tbreak;\n\t}\n\n\tif (enable)\n\t\tarvif->u.sta.uapsd |= value;\n\telse\n\t\tarvif->u.sta.uapsd &= ~value;\n\n\tret = ath10k_wmi_set_sta_ps_param(ar, arvif->vdev_id,\n\t\t\t\t\t  WMI_STA_PS_PARAM_UAPSD,\n\t\t\t\t\t  arvif->u.sta.uapsd);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set uapsd params: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tif (arvif->u.sta.uapsd)\n\t\tvalue = WMI_STA_PS_RX_WAKE_POLICY_POLL_UAPSD;\n\telse\n\t\tvalue = WMI_STA_PS_RX_WAKE_POLICY_WAKE;\n\n\tret = ath10k_wmi_set_sta_ps_param(ar, arvif->vdev_id,\n\t\t\t\t\t  WMI_STA_PS_PARAM_RX_WAKE_POLICY,\n\t\t\t\t\t  value);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to set rx wake param: %d\\n\", ret);\n\n\tret = ath10k_mac_vif_recalc_ps_wake_threshold(arvif);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to recalc ps wake threshold on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_mac_vif_recalc_ps_poll_count(arvif);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to recalc ps poll count on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tif (test_bit(WMI_SERVICE_STA_UAPSD_BASIC_AUTO_TRIG, ar->wmi.svc_map) ||\n\t    test_bit(WMI_SERVICE_STA_UAPSD_VAR_AUTO_TRIG, ar->wmi.svc_map)) {\n\t\t/* Only userspace can make an educated decision when to send\n\t\t * trigger frame. The following effectively disables u-UAPSD\n\t\t * autotrigger in firmware (which is enabled by default\n\t\t * provided the autotrigger service is available).\n\t\t */\n\n\t\targ.wmm_ac = acc;\n\t\targ.user_priority = prio;\n\t\targ.service_interval = 0;\n\t\targ.suspend_interval = WMI_STA_UAPSD_MAX_INTERVAL_MSEC;\n\t\targ.delay_interval = WMI_STA_UAPSD_MAX_INTERVAL_MSEC;\n\n\t\tret = ath10k_wmi_vdev_sta_uapsd(ar, arvif->vdev_id,\n\t\t\t\t\t\tarvif->bssid, &arg, 1);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set uapsd auto trigger %d\\n\",\n\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic int ath10k_conf_tx(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_vif *vif, u16 ac,\n\t\t\t  const struct ieee80211_tx_queue_params *params)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct wmi_wmm_params_arg *p = NULL;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tswitch (ac) {\n\tcase IEEE80211_AC_VO:\n\t\tp = &arvif->wmm_params.ac_vo;\n\t\tbreak;\n\tcase IEEE80211_AC_VI:\n\t\tp = &arvif->wmm_params.ac_vi;\n\t\tbreak;\n\tcase IEEE80211_AC_BE:\n\t\tp = &arvif->wmm_params.ac_be;\n\t\tbreak;\n\tcase IEEE80211_AC_BK:\n\t\tp = &arvif->wmm_params.ac_bk;\n\t\tbreak;\n\t}\n\n\tif (WARN_ON(!p)) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tp->cwmin = params->cw_min;\n\tp->cwmax = params->cw_max;\n\tp->aifs = params->aifs;\n\n\t/*\n\t * The channel time duration programmed in the HW is in absolute\n\t * microseconds, while mac80211 gives the txop in units of\n\t * 32 microseconds.\n\t */\n\tp->txop = params->txop * 32;\n\n\tif (ar->wmi.ops->gen_vdev_wmm_conf) {\n\t\tret = ath10k_wmi_vdev_wmm_conf(ar, arvif->vdev_id,\n\t\t\t\t\t       &arvif->wmm_params);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set vdev wmm params on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\t/* This won't work well with multi-interface cases but it's\n\t\t * better than nothing.\n\t\t */\n\t\tret = ath10k_wmi_pdev_set_wmm_params(ar, &arvif->wmm_params);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set wmm params: %d\\n\", ret);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tret = ath10k_conf_tx_uapsd(ar, vif, ac, params->uapsd);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to set sta uapsd: %d\\n\", ret);\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath10k_remain_on_channel(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_channel *chan,\n\t\t\t\t    int duration,\n\t\t\t\t    enum ieee80211_roc_type type)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct wmi_start_scan_arg arg;\n\tint ret = 0;\n\tu32 scan_time_msec;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ath10k_mac_tdls_vif_stations_count(hw, vif) > 0) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\tswitch (ar->scan.state) {\n\tcase ATH10K_SCAN_IDLE:\n\t\treinit_completion(&ar->scan.started);\n\t\treinit_completion(&ar->scan.completed);\n\t\treinit_completion(&ar->scan.on_channel);\n\t\tar->scan.state = ATH10K_SCAN_STARTING;\n\t\tar->scan.is_roc = true;\n\t\tar->scan.vdev_id = arvif->vdev_id;\n\t\tar->scan.roc_freq = chan->center_freq;\n\t\tar->scan.roc_notify = true;\n\t\tret = 0;\n\t\tbreak;\n\tcase ATH10K_SCAN_STARTING:\n\tcase ATH10K_SCAN_RUNNING:\n\tcase ATH10K_SCAN_ABORTING:\n\t\tret = -EBUSY;\n\t\tbreak;\n\t}\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (ret)\n\t\tgoto exit;\n\n\tscan_time_msec = ar->hw->wiphy->max_remain_on_channel_duration * 2;\n\n\tmemset(&arg, 0, sizeof(arg));\n\tath10k_wmi_start_scan_init(ar, &arg);\n\targ.vdev_id = arvif->vdev_id;\n\targ.scan_id = ATH10K_SCAN_ID;\n\targ.n_channels = 1;\n\targ.channels[0] = chan->center_freq;\n\targ.dwell_time_active = scan_time_msec;\n\targ.dwell_time_passive = scan_time_msec;\n\targ.max_scan_time = scan_time_msec;\n\targ.scan_ctrl_flags |= WMI_SCAN_FLAG_PASSIVE;\n\targ.scan_ctrl_flags |= WMI_SCAN_FILTER_PROBE_REQ;\n\targ.burst_duration_ms = duration;\n\n\tret = ath10k_start_scan(ar, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to start roc scan: %d\\n\", ret);\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tar->scan.state = ATH10K_SCAN_IDLE;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\tgoto exit;\n\t}\n\n\tret = wait_for_completion_timeout(&ar->scan.on_channel, 3 * HZ);\n\tif (ret == 0) {\n\t\tath10k_warn(ar, \"failed to switch to channel for roc scan\\n\");\n\n\t\tret = ath10k_scan_stop(ar);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to stop scan: %d\\n\", ret);\n\n\t\tret = -ETIMEDOUT;\n\t\tgoto exit;\n\t}\n\n\tieee80211_queue_delayed_work(ar->hw, &ar->scan.timeout,\n\t\t\t\t     msecs_to_jiffies(duration));\n\n\tret = 0;\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath10k_cancel_remain_on_channel(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct ath10k *ar = hw->priv;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tar->scan.roc_notify = false;\n\tspin_unlock_bh(&ar->data_lock);\n\n\tath10k_scan_abort(ar);\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\tcancel_delayed_work_sync(&ar->scan.timeout);\n\n\treturn 0;\n}\n\n/*\n * Both RTS and Fragmentation threshold are interface-specific\n * in ath10k, but device-specific in mac80211.\n */\n\nstatic int ath10k_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif;\n\tint ret = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %d rts threshold %d\\n\",\n\t\t\t   arvif->vdev_id, value);\n\n\t\tret = ath10k_mac_set_rts(arvif, value);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set rts threshold for vdev %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic int ath10k_mac_op_set_frag_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\t/* Even though there's a WMI enum for fragmentation threshold no known\n\t * firmware actually implements it. Moreover it is not possible to rely\n\t * frame fragmentation to mac80211 because firmware clears the \"more\n\t * fragments\" bit in frame control making it impossible for remote\n\t * devices to reassemble frames.\n\t *\n\t * Hence implement a dummy callback just to say fragmentation isn't\n\t * supported. This effectively prevents mac80211 from doing frame\n\t * fragmentation in software.\n\t */\n\treturn -EOPNOTSUPP;\n}\n\nvoid ath10k_mac_wait_tx_complete(struct ath10k *ar)\n{\n\tbool skip;\n\tlong time_left;\n\n\t/* mac80211 doesn't care if we really xmit queued frames or not\n\t * we'll collect those frames either way if we stop/delete vdevs\n\t */\n\n\tif (ar->state == ATH10K_STATE_WEDGED)\n\t\treturn;\n\n\ttime_left = wait_event_timeout(ar->htt.empty_tx_wq, ({\n\t\t\tbool empty;\n\n\t\t\tspin_lock_bh(&ar->htt.tx_lock);\n\t\t\tempty = (ar->htt.num_pending_tx == 0);\n\t\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\n\t\t\tskip = (ar->state == ATH10K_STATE_WEDGED) ||\n\t\t\t       test_bit(ATH10K_FLAG_CRASH_FLUSH,\n\t\t\t\t\t&ar->dev_flags);\n\n\t\t\t(empty || skip);\n\t\t}), ATH10K_FLUSH_TIMEOUT_HZ);\n\n\tif (time_left == 0 || skip)\n\t\tath10k_warn(ar, \"failed to flush transmit queue (skip %i ar-state %i): %ld\\n\",\n\t\t\t    skip, ar->state, time_left);\n}\n\nstatic void ath10k_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t u32 queues, bool drop)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif;\n\tu32 bitmap;\n\n\tif (drop) {\n\t\tif (vif && vif->type == NL80211_IFTYPE_STATION) {\n\t\t\tbitmap = ~(1 << WMI_MGMT_TID);\n\t\t\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\t\t\tif (arvif->vdev_type == WMI_VDEV_TYPE_STA)\n\t\t\t\t\tath10k_wmi_peer_flush(ar, arvif->vdev_id,\n\t\t\t\t\t\t\t      arvif->bssid, bitmap);\n\t\t\t}\n\t\t\tath10k_htt_flush_tx(&ar->htt);\n\t\t}\n\t\treturn;\n\t}\n\n\tmutex_lock(&ar->conf_mutex);\n\tath10k_mac_wait_tx_complete(ar);\n\tmutex_unlock(&ar->conf_mutex);\n}\n\n/* TODO: Implement this function properly\n * For now it is needed to reply to Probe Requests in IBSS mode.\n * Propably we need this information from FW.\n */\nstatic int ath10k_tx_last_beacon(struct ieee80211_hw *hw)\n{\n\treturn 1;\n}\n\nstatic void ath10k_reconfig_complete(struct ieee80211_hw *hw,\n\t\t\t\t     enum ieee80211_reconfig_type reconfig_type)\n{\n\tstruct ath10k *ar = hw->priv;\n\n\tif (reconfig_type != IEEE80211_RECONFIG_TYPE_RESTART)\n\t\treturn;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\t/* If device failed to restart it will be in a different state, e.g.\n\t * ATH10K_STATE_WEDGED\n\t */\n\tif (ar->state == ATH10K_STATE_RESTARTED) {\n\t\tath10k_info(ar, \"device successfully recovered\\n\");\n\t\tar->state = ATH10K_STATE_ON;\n\t\tieee80211_wake_queues(ar->hw);\n\t\tclear_bit(ATH10K_FLAG_RESTARTING, &ar->dev_flags);\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic void\nath10k_mac_update_bss_chan_survey(struct ath10k *ar,\n\t\t\t\t  struct ieee80211_channel *channel)\n{\n\tint ret;\n\tenum wmi_bss_survey_req_type type = WMI_BSS_SURVEY_REQ_TYPE_READ;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (!test_bit(WMI_SERVICE_BSS_CHANNEL_INFO_64, ar->wmi.svc_map) ||\n\t    (ar->rx_channel != channel))\n\t\treturn;\n\n\tif (ar->scan.state != ATH10K_SCAN_IDLE) {\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"ignoring bss chan info request while scanning..\\n\");\n\t\treturn;\n\t}\n\n\treinit_completion(&ar->bss_survey_done);\n\n\tret = ath10k_wmi_pdev_bss_chan_info_request(ar, type);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to send pdev bss chan info request\\n\");\n\t\treturn;\n\t}\n\n\tret = wait_for_completion_timeout(&ar->bss_survey_done, 3 * HZ);\n\tif (!ret) {\n\t\tath10k_warn(ar, \"bss channel survey timed out\\n\");\n\t\treturn;\n\t}\n}\n\nstatic int ath10k_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t\t     struct survey_info *survey)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ieee80211_supported_band *sband;\n\tstruct survey_info *ar_survey = &ar->survey[idx];\n\tint ret = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tsband = hw->wiphy->bands[NL80211_BAND_2GHZ];\n\tif (sband && idx >= sband->n_channels) {\n\t\tidx -= sband->n_channels;\n\t\tsband = NULL;\n\t}\n\n\tif (!sband)\n\t\tsband = hw->wiphy->bands[NL80211_BAND_5GHZ];\n\n\tif (!sband || idx >= sband->n_channels) {\n\t\tret = -ENOENT;\n\t\tgoto exit;\n\t}\n\n\tath10k_mac_update_bss_chan_survey(ar, &sband->channels[idx]);\n\n\tspin_lock_bh(&ar->data_lock);\n\tmemcpy(survey, ar_survey, sizeof(*survey));\n\tspin_unlock_bh(&ar->data_lock);\n\n\tsurvey->channel = &sband->channels[idx];\n\n\tif (ar->rx_channel == survey->channel)\n\t\tsurvey->filled |= SURVEY_INFO_IN_USE;\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic bool\nath10k_mac_bitrate_mask_get_single_nss(struct ath10k *ar,\n\t\t\t\t       enum nl80211_band band,\n\t\t\t\t       const struct cfg80211_bitrate_mask *mask,\n\t\t\t\t       int *nss)\n{\n\tstruct ieee80211_supported_band *sband = &ar->mac.sbands[band];\n\tu16 vht_mcs_map = le16_to_cpu(sband->vht_cap.vht_mcs.tx_mcs_map);\n\tu8 ht_nss_mask = 0;\n\tu8 vht_nss_mask = 0;\n\tint i;\n\n\tif (mask->control[band].legacy)\n\t\treturn false;\n\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].ht_mcs); i++) {\n\t\tif (mask->control[band].ht_mcs[i] == 0)\n\t\t\tcontinue;\n\t\telse if (mask->control[band].ht_mcs[i] ==\n\t\t\t sband->ht_cap.mcs.rx_mask[i])\n\t\t\tht_nss_mask |= BIT(i);\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].vht_mcs); i++) {\n\t\tif (mask->control[band].vht_mcs[i] == 0)\n\t\t\tcontinue;\n\t\telse if (mask->control[band].vht_mcs[i] ==\n\t\t\t ath10k_mac_get_max_vht_mcs_map(vht_mcs_map, i))\n\t\t\tvht_nss_mask |= BIT(i);\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tif (ht_nss_mask != vht_nss_mask)\n\t\treturn false;\n\n\tif (ht_nss_mask == 0)\n\t\treturn false;\n\n\tif (BIT(fls(ht_nss_mask)) - 1 != ht_nss_mask)\n\t\treturn false;\n\n\t*nss = fls(ht_nss_mask);\n\n\treturn true;\n}\n\nstatic int ath10k_mac_set_fixed_rate_params(struct ath10k_vif *arvif,\n\t\t\t\t\t    u8 rate, u8 nss, u8 sgi, u8 ldpc)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tu32 vdev_param;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac set fixed rate params vdev %i rate 0x%02x nss %u sgi %u\\n\",\n\t\t   arvif->vdev_id, rate, nss, sgi);\n\n\tvdev_param = ar->wmi.vdev_param->fixed_rate;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param, rate);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set fixed rate param 0x%02x: %d\\n\",\n\t\t\t    rate, ret);\n\t\treturn ret;\n\t}\n\n\tvdev_param = ar->wmi.vdev_param->nss;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param, nss);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set nss param %d: %d\\n\", nss, ret);\n\t\treturn ret;\n\t}\n\n\tvdev_param = ar->wmi.vdev_param->sgi;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param, sgi);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set sgi param %d: %d\\n\", sgi, ret);\n\t\treturn ret;\n\t}\n\n\tvdev_param = ar->wmi.vdev_param->ldpc;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param, ldpc);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set ldpc param %d: %d\\n\", ldpc, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nath10k_mac_can_set_bitrate_mask(struct ath10k *ar,\n\t\t\t\tenum nl80211_band band,\n\t\t\t\tconst struct cfg80211_bitrate_mask *mask,\n\t\t\t\tbool allow_pfr)\n{\n\tint i;\n\tu16 vht_mcs;\n\n\t/* Due to firmware limitation in WMI_PEER_ASSOC_CMDID it is impossible\n\t * to express all VHT MCS rate masks. Effectively only the following\n\t * ranges can be used: none, 0-7, 0-8 and 0-9.\n\t */\n\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tvht_mcs = mask->control[band].vht_mcs[i];\n\n\t\tswitch (vht_mcs) {\n\t\tcase 0:\n\t\tcase BIT(8) - 1:\n\t\tcase BIT(9) - 1:\n\t\tcase BIT(10) - 1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!allow_pfr)\n\t\t\t\tath10k_warn(ar, \"refusing bitrate mask with missing 0-7 VHT MCS rates\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool ath10k_mac_set_vht_bitrate_mask_fixup(struct ath10k *ar,\n\t\t\t\t\t\t  struct ath10k_vif *arvif,\n\t\t\t\t\t\t  struct ieee80211_sta *sta)\n{\n\tint err;\n\tu8 rate = arvif->vht_pfr;\n\n\t/* skip non vht and multiple rate peers */\n\tif (!sta->vht_cap.vht_supported || arvif->vht_num_rates != 1)\n\t\treturn false;\n\n\terr = ath10k_wmi_peer_set_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\tWMI_PEER_PARAM_FIXED_RATE, rate);\n\tif (err)\n\t\tath10k_warn(ar, \"failed to enable STA %pM peer fixed rate: %d\\n\",\n\t\t\t    sta->addr, err);\n\n\treturn true;\n}\n\nstatic void ath10k_mac_set_bitrate_mask_iter(void *data,\n\t\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct ath10k_vif *arvif = data;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k *ar = arvif->ar;\n\n\tif (arsta->arvif != arvif)\n\t\treturn;\n\n\tif (ath10k_mac_set_vht_bitrate_mask_fixup(ar, arvif, sta))\n\t\treturn;\n\n\tspin_lock_bh(&ar->data_lock);\n\tarsta->changed |= IEEE80211_RC_SUPP_RATES_CHANGED;\n\tspin_unlock_bh(&ar->data_lock);\n\n\tieee80211_queue_work(ar->hw, &arsta->update_wk);\n}\n\nstatic void ath10k_mac_clr_bitrate_mask_iter(void *data,\n\t\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct ath10k_vif *arvif = data;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k *ar = arvif->ar;\n\tint err;\n\n\t/* clear vht peers only */\n\tif (arsta->arvif != arvif || !sta->vht_cap.vht_supported)\n\t\treturn;\n\n\terr = ath10k_wmi_peer_set_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\tWMI_PEER_PARAM_FIXED_RATE,\n\t\t\t\t\tWMI_FIXED_RATE_NONE);\n\tif (err)\n\t\tath10k_warn(ar, \"failed to clear STA %pM peer fixed rate: %d\\n\",\n\t\t\t    sta->addr, err);\n}\n\nstatic int ath10k_mac_op_set_bitrate_mask(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  const struct cfg80211_bitrate_mask *mask)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct cfg80211_chan_def def;\n\tstruct ath10k *ar = arvif->ar;\n\tenum nl80211_band band;\n\tconst u8 *ht_mcs_mask;\n\tconst u16 *vht_mcs_mask;\n\tu8 rate;\n\tu8 nss;\n\tu8 sgi;\n\tu8 ldpc;\n\tint single_nss;\n\tint ret;\n\tint vht_num_rates, allow_pfr;\n\tu8 vht_pfr;\n\tbool update_bitrate_mask = true;\n\n\tif (ath10k_mac_vif_chan(vif, &def))\n\t\treturn -EPERM;\n\n\tband = def.chan->band;\n\tht_mcs_mask = mask->control[band].ht_mcs;\n\tvht_mcs_mask = mask->control[band].vht_mcs;\n\tldpc = !!(ar->ht_cap_info & WMI_HT_CAP_LDPC);\n\n\tsgi = mask->control[band].gi;\n\tif (sgi == NL80211_TXRATE_FORCE_LGI)\n\t\treturn -EINVAL;\n\n\tallow_pfr = test_bit(ATH10K_FW_FEATURE_PEER_FIXED_RATE,\n\t\t\t     ar->normal_mode_fw.fw_file.fw_features);\n\tif (allow_pfr) {\n\t\tmutex_lock(&ar->conf_mutex);\n\t\tieee80211_iterate_stations_atomic(ar->hw,\n\t\t\t\t\t\t  ath10k_mac_clr_bitrate_mask_iter,\n\t\t\t\t\t\t  arvif);\n\t\tmutex_unlock(&ar->conf_mutex);\n\t}\n\n\tif (ath10k_mac_bitrate_mask_has_single_rate(ar, band, mask,\n\t\t\t\t\t\t    &vht_num_rates)) {\n\t\tret = ath10k_mac_bitrate_mask_get_single_rate(ar, band, mask,\n\t\t\t\t\t\t\t      &rate, &nss,\n\t\t\t\t\t\t\t      false);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to get single rate for vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t} else if (ath10k_mac_bitrate_mask_get_single_nss(ar, band, mask,\n\t\t\t\t\t\t\t  &single_nss)) {\n\t\trate = WMI_FIXED_RATE_NONE;\n\t\tnss = single_nss;\n\t} else {\n\t\trate = WMI_FIXED_RATE_NONE;\n\t\tnss = min(ar->num_rf_chains,\n\t\t\t  max(ath10k_mac_max_ht_nss(ht_mcs_mask),\n\t\t\t      ath10k_mac_max_vht_nss(vht_mcs_mask)));\n\n\t\tif (!ath10k_mac_can_set_bitrate_mask(ar, band, mask,\n\t\t\t\t\t\t     allow_pfr)) {\n\t\t\tu8 vht_nss;\n\n\t\t\tif (!allow_pfr || vht_num_rates != 1)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* Reach here, firmware supports peer fixed rate and has\n\t\t\t * single vht rate, and don't update vif birate_mask, as\n\t\t\t * the rate only for specific peer.\n\t\t\t */\n\t\t\tath10k_mac_bitrate_mask_get_single_rate(ar, band, mask,\n\t\t\t\t\t\t\t\t&vht_pfr,\n\t\t\t\t\t\t\t\t&vht_nss,\n\t\t\t\t\t\t\t\ttrue);\n\t\t\tupdate_bitrate_mask = false;\n\t\t} else {\n\t\t\tvht_pfr = 0;\n\t\t}\n\n\t\tmutex_lock(&ar->conf_mutex);\n\n\t\tif (update_bitrate_mask)\n\t\t\tarvif->bitrate_mask = *mask;\n\t\tarvif->vht_num_rates = vht_num_rates;\n\t\tarvif->vht_pfr = vht_pfr;\n\t\tieee80211_iterate_stations_atomic(ar->hw,\n\t\t\t\t\t\t  ath10k_mac_set_bitrate_mask_iter,\n\t\t\t\t\t\t  arvif);\n\n\t\tmutex_unlock(&ar->conf_mutex);\n\t}\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tret = ath10k_mac_set_fixed_rate_params(arvif, rate, nss, sgi, ldpc);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set fixed rate params on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto exit;\n\t}\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic void ath10k_sta_rc_update(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t u32 changed)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_peer *peer;\n\tu32 bw, smps;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tpeer = ath10k_peer_find(ar, arvif->vdev_id, sta->addr);\n\tif (!peer) {\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\tath10k_warn(ar, \"mac sta rc update failed to find peer %pM on vdev %i\\n\",\n\t\t\t    sta->addr, arvif->vdev_id);\n\t\treturn;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_STA,\n\t\t   \"mac sta rc update for %pM changed %08x bw %d nss %d smps %d\\n\",\n\t\t   sta->addr, changed, sta->bandwidth, sta->rx_nss,\n\t\t   sta->smps_mode);\n\n\tif (changed & IEEE80211_RC_BW_CHANGED) {\n\t\tbw = WMI_PEER_CHWIDTH_20MHZ;\n\n\t\tswitch (sta->bandwidth) {\n\t\tcase IEEE80211_STA_RX_BW_20:\n\t\t\tbw = WMI_PEER_CHWIDTH_20MHZ;\n\t\t\tbreak;\n\t\tcase IEEE80211_STA_RX_BW_40:\n\t\t\tbw = WMI_PEER_CHWIDTH_40MHZ;\n\t\t\tbreak;\n\t\tcase IEEE80211_STA_RX_BW_80:\n\t\t\tbw = WMI_PEER_CHWIDTH_80MHZ;\n\t\t\tbreak;\n\t\tcase IEEE80211_STA_RX_BW_160:\n\t\t\tbw = WMI_PEER_CHWIDTH_160MHZ;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath10k_warn(ar, \"Invalid bandwidth %d in rc update for %pM\\n\",\n\t\t\t\t    sta->bandwidth, sta->addr);\n\t\t\tbw = WMI_PEER_CHWIDTH_20MHZ;\n\t\t\tbreak;\n\t\t}\n\n\t\tarsta->bw = bw;\n\t}\n\n\tif (changed & IEEE80211_RC_NSS_CHANGED)\n\t\tarsta->nss = sta->rx_nss;\n\n\tif (changed & IEEE80211_RC_SMPS_CHANGED) {\n\t\tsmps = WMI_PEER_SMPS_PS_NONE;\n\n\t\tswitch (sta->smps_mode) {\n\t\tcase IEEE80211_SMPS_AUTOMATIC:\n\t\tcase IEEE80211_SMPS_OFF:\n\t\t\tsmps = WMI_PEER_SMPS_PS_NONE;\n\t\t\tbreak;\n\t\tcase IEEE80211_SMPS_STATIC:\n\t\t\tsmps = WMI_PEER_SMPS_STATIC;\n\t\t\tbreak;\n\t\tcase IEEE80211_SMPS_DYNAMIC:\n\t\t\tsmps = WMI_PEER_SMPS_DYNAMIC;\n\t\t\tbreak;\n\t\tcase IEEE80211_SMPS_NUM_MODES:\n\t\t\tath10k_warn(ar, \"Invalid smps %d in sta rc update for %pM\\n\",\n\t\t\t\t    sta->smps_mode, sta->addr);\n\t\t\tsmps = WMI_PEER_SMPS_PS_NONE;\n\t\t\tbreak;\n\t\t}\n\n\t\tarsta->smps = smps;\n\t}\n\n\tarsta->changed |= changed;\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\tieee80211_queue_work(hw, &arsta->update_wk);\n}\n\nstatic void ath10k_offset_tsf(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, s64 tsf_offset)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tu32 offset, vdev_param;\n\tint ret;\n\n\tif (tsf_offset < 0) {\n\t\tvdev_param = ar->wmi.vdev_param->dec_tsf;\n\t\toffset = -tsf_offset;\n\t} else {\n\t\tvdev_param = ar->wmi.vdev_param->inc_tsf;\n\t\toffset = tsf_offset;\n\t}\n\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id,\n\t\t\t\t\tvdev_param, offset);\n\n\tif (ret && ret != -EOPNOTSUPP)\n\t\tath10k_warn(ar, \"failed to set tsf offset %d cmd %d: %d\\n\",\n\t\t\t    offset, vdev_param, ret);\n}\n\nstatic int ath10k_ampdu_action(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_ampdu_params *params)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac ampdu vdev_id %i sta %pM tid %u action %d\\n\",\n\t\t   arvif->vdev_id, sta->addr, tid, action);\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\t/* HTT AddBa/DelBa events trigger mac80211 Rx BA session\n\t\t * creation/removal. Do we need to verify this?\n\t\t */\n\t\treturn 0;\n\tcase IEEE80211_AMPDU_TX_START:\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\t/* Firmware offloads Tx aggregation entirely so deny mac80211\n\t\t * Tx aggregation requests.\n\t\t */\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void\nath10k_mac_update_rx_channel(struct ath10k *ar,\n\t\t\t     struct ieee80211_chanctx_conf *ctx,\n\t\t\t     struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t     int n_vifs)\n{\n\tstruct cfg80211_chan_def *def = NULL;\n\n\t/* Both locks are required because ar->rx_channel is modified. This\n\t * allows readers to hold either lock.\n\t */\n\tlockdep_assert_held(&ar->conf_mutex);\n\tlockdep_assert_held(&ar->data_lock);\n\n\tWARN_ON(ctx && vifs);\n\tWARN_ON(vifs && !n_vifs);\n\n\t/* FIXME: Sort of an optimization and a workaround. Peers and vifs are\n\t * on a linked list now. Doing a lookup peer -> vif -> chanctx for each\n\t * ppdu on Rx may reduce performance on low-end systems. It should be\n\t * possible to make tables/hashmaps to speed the lookup up (be vary of\n\t * cpu data cache lines though regarding sizes) but to keep the initial\n\t * implementation simple and less intrusive fallback to the slow lookup\n\t * only for multi-channel cases. Single-channel cases will remain to\n\t * use the old channel derival and thus performance should not be\n\t * affected much.\n\t */\n\trcu_read_lock();\n\tif (!ctx && ath10k_mac_num_chanctxs(ar) == 1) {\n\t\tieee80211_iter_chan_contexts_atomic(ar->hw,\n\t\t\t\t\t\t    ath10k_mac_get_any_chandef_iter,\n\t\t\t\t\t\t    &def);\n\n\t\tif (vifs)\n\t\t\tdef = &vifs[0].new_ctx->def;\n\n\t\tar->rx_channel = def->chan;\n\t} else if ((ctx && ath10k_mac_num_chanctxs(ar) == 0) ||\n\t\t   (ctx && (ar->state == ATH10K_STATE_RESTARTED))) {\n\t\t/* During driver restart due to firmware assert, since mac80211\n\t\t * already has valid channel context for given radio, channel\n\t\t * context iteration return num_chanctx > 0. So fix rx_channel\n\t\t * when restart is in progress.\n\t\t */\n\t\tar->rx_channel = ctx->def.chan;\n\t} else {\n\t\tar->rx_channel = NULL;\n\t}\n\trcu_read_unlock();\n}\n\nstatic void\nath10k_mac_update_vif_chan(struct ath10k *ar,\n\t\t\t   struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t   int n_vifs)\n{\n\tstruct ath10k_vif *arvif;\n\tint ret;\n\tint i;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\t/* First stop monitor interface. Some FW versions crash if there's a\n\t * lone monitor interface.\n\t */\n\tif (ar->monitor_started)\n\t\tath10k_monitor_stop(ar);\n\n\tfor (i = 0; i < n_vifs; i++) {\n\t\tarvif = (void *)vifs[i].vif->drv_priv;\n\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t\t   \"mac chanctx switch vdev_id %i freq %u->%u width %d->%d\\n\",\n\t\t\t   arvif->vdev_id,\n\t\t\t   vifs[i].old_ctx->def.chan->center_freq,\n\t\t\t   vifs[i].new_ctx->def.chan->center_freq,\n\t\t\t   vifs[i].old_ctx->def.width,\n\t\t\t   vifs[i].new_ctx->def.width);\n\n\t\tif (WARN_ON(!arvif->is_started))\n\t\t\tcontinue;\n\n\t\tif (WARN_ON(!arvif->is_up))\n\t\t\tcontinue;\n\n\t\tret = ath10k_wmi_vdev_down(ar, arvif->vdev_id);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to down vdev %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t/* All relevant vdevs are downed and associated channel resources\n\t * should be available for the channel switch now.\n\t */\n\n\tspin_lock_bh(&ar->data_lock);\n\tath10k_mac_update_rx_channel(ar, NULL, vifs, n_vifs);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tfor (i = 0; i < n_vifs; i++) {\n\t\tarvif = (void *)vifs[i].vif->drv_priv;\n\n\t\tif (WARN_ON(!arvif->is_started))\n\t\t\tcontinue;\n\n\t\tif (WARN_ON(!arvif->is_up))\n\t\t\tcontinue;\n\n\t\tret = ath10k_mac_setup_bcn_tmpl(arvif);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to update bcn tmpl during csa: %d\\n\",\n\t\t\t\t    ret);\n\n\t\tret = ath10k_mac_setup_prb_tmpl(arvif);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to update prb tmpl during csa: %d\\n\",\n\t\t\t\t    ret);\n\n\t\tret = ath10k_vdev_restart(arvif, &vifs[i].new_ctx->def);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to restart vdev %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = ath10k_wmi_vdev_up(arvif->ar, arvif->vdev_id, arvif->aid,\n\t\t\t\t\t arvif->bssid);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to bring vdev up %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tath10k_monitor_recalc(ar);\n}\n\nstatic int\nath10k_mac_op_add_chanctx(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct ath10k *ar = hw->priv;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac chanctx add freq %u width %d ptr %pK\\n\",\n\t\t   ctx->def.chan->center_freq, ctx->def.width, ctx);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tath10k_mac_update_rx_channel(ar, ctx, NULL, 0);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tath10k_recalc_radar_detection(ar);\n\tath10k_monitor_recalc(ar);\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn 0;\n}\n\nstatic void\nath10k_mac_op_remove_chanctx(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct ath10k *ar = hw->priv;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac chanctx remove freq %u width %d ptr %pK\\n\",\n\t\t   ctx->def.chan->center_freq, ctx->def.width, ctx);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tath10k_mac_update_rx_channel(ar, NULL, NULL, 0);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tath10k_recalc_radar_detection(ar);\n\tath10k_monitor_recalc(ar);\n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstruct ath10k_mac_change_chanctx_arg {\n\tstruct ieee80211_chanctx_conf *ctx;\n\tstruct ieee80211_vif_chanctx_switch *vifs;\n\tint n_vifs;\n\tint next_vif;\n};\n\nstatic void\nath10k_mac_change_chanctx_cnt_iter(void *data, u8 *mac,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct ath10k_mac_change_chanctx_arg *arg = data;\n\n\tif (rcu_access_pointer(vif->chanctx_conf) != arg->ctx)\n\t\treturn;\n\n\targ->n_vifs++;\n}\n\nstatic void\nath10k_mac_change_chanctx_fill_iter(void *data, u8 *mac,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct ath10k_mac_change_chanctx_arg *arg = data;\n\tstruct ieee80211_chanctx_conf *ctx;\n\n\tctx = rcu_access_pointer(vif->chanctx_conf);\n\tif (ctx != arg->ctx)\n\t\treturn;\n\n\tif (WARN_ON(arg->next_vif == arg->n_vifs))\n\t\treturn;\n\n\targ->vifs[arg->next_vif].vif = vif;\n\targ->vifs[arg->next_vif].old_ctx = ctx;\n\targ->vifs[arg->next_vif].new_ctx = ctx;\n\targ->next_vif++;\n}\n\nstatic void\nath10k_mac_op_change_chanctx(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_chanctx_conf *ctx,\n\t\t\t     u32 changed)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_mac_change_chanctx_arg arg = { .ctx = ctx };\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac chanctx change freq %u width %d ptr %pK changed %x\\n\",\n\t\t   ctx->def.chan->center_freq, ctx->def.width, ctx, changed);\n\n\t/* This shouldn't really happen because channel switching should use\n\t * switch_vif_chanctx().\n\t */\n\tif (WARN_ON(changed & IEEE80211_CHANCTX_CHANGE_CHANNEL))\n\t\tgoto unlock;\n\n\tif (changed & IEEE80211_CHANCTX_CHANGE_WIDTH) {\n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\t\t\thw,\n\t\t\t\t\tATH10K_ITER_NORMAL_FLAGS,\n\t\t\t\t\tath10k_mac_change_chanctx_cnt_iter,\n\t\t\t\t\t&arg);\n\t\tif (arg.n_vifs == 0)\n\t\t\tgoto radar;\n\n\t\targ.vifs = kcalloc(arg.n_vifs, sizeof(arg.vifs[0]),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!arg.vifs)\n\t\t\tgoto radar;\n\n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\t\t\thw,\n\t\t\t\t\tATH10K_ITER_NORMAL_FLAGS,\n\t\t\t\t\tath10k_mac_change_chanctx_fill_iter,\n\t\t\t\t\t&arg);\n\t\tath10k_mac_update_vif_chan(ar, arg.vifs, arg.n_vifs);\n\t\tkfree(arg.vifs);\n\t}\n\nradar:\n\tath10k_recalc_radar_detection(ar);\n\n\t/* FIXME: How to configure Rx chains properly? */\n\n\t/* No other actions are actually necessary. Firmware maintains channel\n\t * definitions per vdev internally and there's no host-side channel\n\t * context abstraction to configure, e.g. channel width.\n\t */\n\nunlock:\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic int\nath10k_mac_op_assign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac chanctx assign ptr %pK vdev_id %i\\n\",\n\t\t   ctx, arvif->vdev_id);\n\n\tif (WARN_ON(arvif->is_started)) {\n\t\tmutex_unlock(&ar->conf_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tret = ath10k_vdev_start(arvif, &ctx->def);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to start vdev %i addr %pM on freq %d: %d\\n\",\n\t\t\t    arvif->vdev_id, vif->addr,\n\t\t\t    ctx->def.chan->center_freq, ret);\n\t\tgoto err;\n\t}\n\n\tarvif->is_started = true;\n\n\tret = ath10k_mac_vif_setup_ps(arvif);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to update vdev %i ps: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto err_stop;\n\t}\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR) {\n\t\tret = ath10k_wmi_vdev_up(ar, arvif->vdev_id, 0, vif->addr);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to up monitor vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_stop;\n\t\t}\n\n\t\tarvif->is_up = true;\n\t}\n\n\tif (ath10k_mac_can_set_cts_prot(arvif)) {\n\t\tret = ath10k_mac_set_cts_prot(arvif);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to set cts protection for vdev %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (ath10k_peer_stats_enabled(ar) &&\n\t    ar->hw_params.tx_stats_over_pktlog) {\n\t\tar->pktlog_filter |= ATH10K_PKTLOG_PEER_STATS;\n\t\tret = ath10k_wmi_pdev_pktlog_enable(ar,\n\t\t\t\t\t\t    ar->pktlog_filter);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to enable pktlog %d\\n\", ret);\n\t\t\tgoto err_stop;\n\t\t}\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn 0;\n\nerr_stop:\n\tath10k_vdev_stop(arvif);\n\tarvif->is_started = false;\n\tath10k_mac_vif_setup_ps(arvif);\n\nerr:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic void\nath10k_mac_op_unassign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac chanctx unassign ptr %pK vdev_id %i\\n\",\n\t\t   ctx, arvif->vdev_id);\n\n\tWARN_ON(!arvif->is_started);\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR) {\n\t\tWARN_ON(!arvif->is_up);\n\n\t\tret = ath10k_wmi_vdev_down(ar, arvif->vdev_id);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to down monitor vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\n\t\tarvif->is_up = false;\n\t}\n\n\tret = ath10k_vdev_stop(arvif);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to stop vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\n\tarvif->is_started = false;\n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic int\nath10k_mac_op_switch_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t\t int n_vifs,\n\t\t\t\t enum ieee80211_chanctx_switch_mode mode)\n{\n\tstruct ath10k *ar = hw->priv;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac chanctx switch n_vifs %d mode %d\\n\",\n\t\t   n_vifs, mode);\n\tath10k_mac_update_vif_chan(ar, vifs, n_vifs);\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn 0;\n}\n\nstatic void ath10k_mac_op_sta_pre_rcu_remove(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct ath10k *ar;\n\tstruct ath10k_peer *peer;\n\n\tar = hw->priv;\n\n\tlist_for_each_entry(peer, &ar->peers, list)\n\t\tif (peer->sta == sta)\n\t\t\tpeer->removed = true;\n}\n\n/* HT MCS parameters with Nss = 1 */\nstatic const struct ath10k_index_ht_data_rate_type supported_ht_mcs_rate_nss1[] = {\n\t/* MCS  L20   L40   S20  S40 */\n\t{0,  { 65,  135,  72,  150} },\n\t{1,  { 130, 270,  144, 300} },\n\t{2,  { 195, 405,  217, 450} },\n\t{3,  { 260, 540,  289, 600} },\n\t{4,  { 390, 810,  433, 900} },\n\t{5,  { 520, 1080, 578, 1200} },\n\t{6,  { 585, 1215, 650, 1350} },\n\t{7,  { 650, 1350, 722, 1500} }\n};\n\n/* HT MCS parameters with Nss = 2 */\nstatic const struct ath10k_index_ht_data_rate_type supported_ht_mcs_rate_nss2[] = {\n\t/* MCS  L20    L40   S20   S40 */\n\t{0,  {130,  270,  144,  300} },\n\t{1,  {260,  540,  289,  600} },\n\t{2,  {390,  810,  433,  900} },\n\t{3,  {520,  1080, 578,  1200} },\n\t{4,  {780,  1620, 867,  1800} },\n\t{5,  {1040, 2160, 1156, 2400} },\n\t{6,  {1170, 2430, 1300, 2700} },\n\t{7,  {1300, 2700, 1444, 3000} }\n};\n\n/* MCS parameters with Nss = 1 */\nstatic const struct ath10k_index_vht_data_rate_type supported_vht_mcs_rate_nss1[] = {\n\t/* MCS  L80    S80     L40   S40    L20   S20 */\n\t{0,  {293,  325},  {135,  150},  {65,   72} },\n\t{1,  {585,  650},  {270,  300},  {130,  144} },\n\t{2,  {878,  975},  {405,  450},  {195,  217} },\n\t{3,  {1170, 1300}, {540,  600},  {260,  289} },\n\t{4,  {1755, 1950}, {810,  900},  {390,  433} },\n\t{5,  {2340, 2600}, {1080, 1200}, {520,  578} },\n\t{6,  {2633, 2925}, {1215, 1350}, {585,  650} },\n\t{7,  {2925, 3250}, {1350, 1500}, {650,  722} },\n\t{8,  {3510, 3900}, {1620, 1800}, {780,  867} },\n\t{9,  {3900, 4333}, {1800, 2000}, {780,  867} }\n};\n\n/*MCS parameters with Nss = 2 */\nstatic const struct ath10k_index_vht_data_rate_type supported_vht_mcs_rate_nss2[] = {\n\t/* MCS  L80    S80     L40   S40    L20   S20 */\n\t{0,  {585,  650},  {270,  300},  {130,  144} },\n\t{1,  {1170, 1300}, {540,  600},  {260,  289} },\n\t{2,  {1755, 1950}, {810,  900},  {390,  433} },\n\t{3,  {2340, 2600}, {1080, 1200}, {520,  578} },\n\t{4,  {3510, 3900}, {1620, 1800}, {780,  867} },\n\t{5,  {4680, 5200}, {2160, 2400}, {1040, 1156} },\n\t{6,  {5265, 5850}, {2430, 2700}, {1170, 1300} },\n\t{7,  {5850, 6500}, {2700, 3000}, {1300, 1444} },\n\t{8,  {7020, 7800}, {3240, 3600}, {1560, 1733} },\n\t{9,  {7800, 8667}, {3600, 4000}, {1560, 1733} }\n};\n\nstatic void ath10k_mac_get_rate_flags_ht(struct ath10k *ar, u32 rate, u8 nss, u8 mcs,\n\t\t\t\t\t u8 *flags, u8 *bw)\n{\n\tstruct ath10k_index_ht_data_rate_type *mcs_rate;\n\tu8 index;\n\tsize_t len_nss1 = ARRAY_SIZE(supported_ht_mcs_rate_nss1);\n\tsize_t len_nss2 = ARRAY_SIZE(supported_ht_mcs_rate_nss2);\n\n\tif (mcs >= (len_nss1 + len_nss2)) {\n\t\tath10k_warn(ar, \"not supported mcs %d in current rate table\", mcs);\n\t\treturn;\n\t}\n\n\tmcs_rate = (struct ath10k_index_ht_data_rate_type *)\n\t\t   ((nss == 1) ? &supported_ht_mcs_rate_nss1 :\n\t\t   &supported_ht_mcs_rate_nss2);\n\n\tif (mcs >= len_nss1)\n\t\tindex = mcs - len_nss1;\n\telse\n\t\tindex = mcs;\n\n\tif (rate == mcs_rate[index].supported_rate[0]) {\n\t\t*bw = RATE_INFO_BW_20;\n\t} else if (rate == mcs_rate[index].supported_rate[1]) {\n\t\t*bw |= RATE_INFO_BW_40;\n\t} else if (rate == mcs_rate[index].supported_rate[2]) {\n\t\t*bw |= RATE_INFO_BW_20;\n\t\t*flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t} else if (rate == mcs_rate[index].supported_rate[3]) {\n\t\t*bw |= RATE_INFO_BW_40;\n\t\t*flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t} else {\n\t\tath10k_warn(ar, \"invalid ht params rate %d 100kbps nss %d mcs %d\",\n\t\t\t    rate, nss, mcs);\n\t}\n}\n\nstatic void ath10k_mac_get_rate_flags_vht(struct ath10k *ar, u32 rate, u8 nss, u8 mcs,\n\t\t\t\t\t  u8 *flags, u8 *bw)\n{\n\tstruct ath10k_index_vht_data_rate_type *mcs_rate;\n\n\tmcs_rate = (struct ath10k_index_vht_data_rate_type *)\n\t\t   ((nss == 1) ? &supported_vht_mcs_rate_nss1 :\n\t\t   &supported_vht_mcs_rate_nss2);\n\n\tif (rate == mcs_rate[mcs].supported_VHT80_rate[0]) {\n\t\t*bw = RATE_INFO_BW_80;\n\t} else if (rate == mcs_rate[mcs].supported_VHT80_rate[1]) {\n\t\t*bw = RATE_INFO_BW_80;\n\t\t*flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t} else if (rate == mcs_rate[mcs].supported_VHT40_rate[0]) {\n\t\t*bw = RATE_INFO_BW_40;\n\t} else if (rate == mcs_rate[mcs].supported_VHT40_rate[1]) {\n\t\t*bw = RATE_INFO_BW_40;\n\t\t*flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t} else if (rate == mcs_rate[mcs].supported_VHT20_rate[0]) {\n\t\t*bw = RATE_INFO_BW_20;\n\t} else if (rate == mcs_rate[mcs].supported_VHT20_rate[1]) {\n\t\t*bw = RATE_INFO_BW_20;\n\t\t*flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t} else {\n\t\tath10k_warn(ar, \"invalid vht params rate %d 100kbps nss %d mcs %d\",\n\t\t\t    rate, nss, mcs);\n\t}\n}\n\nstatic void ath10k_mac_get_rate_flags(struct ath10k *ar, u32 rate,\n\t\t\t\t      enum ath10k_phy_mode mode, u8 nss, u8 mcs,\n\t\t\t\t      u8 *flags, u8 *bw)\n{\n\tif (mode == ATH10K_PHY_MODE_HT) {\n\t\t*flags = RATE_INFO_FLAGS_MCS;\n\t\tath10k_mac_get_rate_flags_ht(ar, rate, nss, mcs, flags, bw);\n\t} else if (mode == ATH10K_PHY_MODE_VHT) {\n\t\t*flags = RATE_INFO_FLAGS_VHT_MCS;\n\t\tath10k_mac_get_rate_flags_vht(ar, rate, nss, mcs, flags, bw);\n\t}\n}\n\nstatic void ath10k_mac_parse_bitrate(struct ath10k *ar, u32 rate_code,\n\t\t\t\t     u32 bitrate_kbps, struct rate_info *rate)\n{\n\tenum ath10k_phy_mode mode = ATH10K_PHY_MODE_LEGACY;\n\tenum wmi_rate_preamble preamble = WMI_TLV_GET_HW_RC_PREAM_V1(rate_code);\n\tu8 nss = WMI_TLV_GET_HW_RC_NSS_V1(rate_code) + 1;\n\tu8 mcs = WMI_TLV_GET_HW_RC_RATE_V1(rate_code);\n\tu8 flags = 0, bw = 0;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac parse rate code 0x%x bitrate %d kbps\\n\",\n\t\t   rate_code, bitrate_kbps);\n\n\tif (preamble == WMI_RATE_PREAMBLE_HT)\n\t\tmode = ATH10K_PHY_MODE_HT;\n\telse if (preamble == WMI_RATE_PREAMBLE_VHT)\n\t\tmode = ATH10K_PHY_MODE_VHT;\n\n\tath10k_mac_get_rate_flags(ar, bitrate_kbps / 100, mode, nss, mcs, &flags, &bw);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac parse bitrate preamble %d mode %d nss %d mcs %d flags %x bw %d\\n\",\n\t\t   preamble, mode, nss, mcs, flags, bw);\n\n\trate->flags = flags;\n\trate->bw = bw;\n\trate->legacy = bitrate_kbps / 100;\n\trate->nss = nss;\n\trate->mcs = mcs;\n}\n\nstatic void ath10k_mac_sta_get_peer_stats_info(struct ath10k *ar,\n\t\t\t\t\t       struct ieee80211_sta *sta,\n\t\t\t\t\t       struct station_info *sinfo)\n{\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k_peer *peer;\n\tunsigned long time_left;\n\tint ret;\n\n\tif (!(ar->hw_params.supports_peer_stats_info &&\n\t      arsta->arvif->vdev_type == WMI_VDEV_TYPE_STA))\n\t\treturn;\n\n\tspin_lock_bh(&ar->data_lock);\n\tpeer = ath10k_peer_find(ar, arsta->arvif->vdev_id, sta->addr);\n\tspin_unlock_bh(&ar->data_lock);\n\tif (!peer)\n\t\treturn;\n\n\treinit_completion(&ar->peer_stats_info_complete);\n\n\tret = ath10k_wmi_request_peer_stats_info(ar,\n\t\t\t\t\t\t arsta->arvif->vdev_id,\n\t\t\t\t\t\t WMI_REQUEST_ONE_PEER_STATS_INFO,\n\t\t\t\t\t\t arsta->arvif->bssid,\n\t\t\t\t\t\t 0);\n\tif (ret && ret != -EOPNOTSUPP) {\n\t\tath10k_warn(ar, \"could not request peer stats info: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&ar->peer_stats_info_complete, 3 * HZ);\n\tif (time_left == 0) {\n\t\tath10k_warn(ar, \"timed out waiting peer stats info\\n\");\n\t\treturn;\n\t}\n\n\tif (arsta->rx_rate_code != 0 && arsta->rx_bitrate_kbps != 0) {\n\t\tath10k_mac_parse_bitrate(ar, arsta->rx_rate_code,\n\t\t\t\t\t arsta->rx_bitrate_kbps,\n\t\t\t\t\t &sinfo->rxrate);\n\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BITRATE);\n\t\tarsta->rx_rate_code = 0;\n\t\tarsta->rx_bitrate_kbps = 0;\n\t}\n\n\tif (arsta->tx_rate_code != 0 && arsta->tx_bitrate_kbps != 0) {\n\t\tath10k_mac_parse_bitrate(ar, arsta->tx_rate_code,\n\t\t\t\t\t arsta->tx_bitrate_kbps,\n\t\t\t\t\t &sinfo->txrate);\n\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\t\tarsta->tx_rate_code = 0;\n\t\tarsta->tx_bitrate_kbps = 0;\n\t}\n}\n\nstatic void ath10k_sta_statistics(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  struct station_info *sinfo)\n{\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k *ar = arsta->arvif->ar;\n\n\tif (!ath10k_peer_stats_enabled(ar))\n\t\treturn;\n\n\tmutex_lock(&ar->conf_mutex);\n\tath10k_debug_fw_stats_request(ar);\n\tmutex_unlock(&ar->conf_mutex);\n\n\tsinfo->rx_duration = arsta->rx_duration;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_DURATION);\n\n\tif (arsta->txrate.legacy || arsta->txrate.nss) {\n\t\tif (arsta->txrate.legacy) {\n\t\t\tsinfo->txrate.legacy = arsta->txrate.legacy;\n\t\t} else {\n\t\t\tsinfo->txrate.mcs = arsta->txrate.mcs;\n\t\t\tsinfo->txrate.nss = arsta->txrate.nss;\n\t\t\tsinfo->txrate.bw = arsta->txrate.bw;\n\t\t}\n\t\tsinfo->txrate.flags = arsta->txrate.flags;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\t}\n\n\tif (ar->htt.disable_tx_comp) {\n\t\tsinfo->tx_failed = arsta->tx_failed;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);\n\t}\n\n\tsinfo->tx_retries = arsta->tx_retries;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_RETRIES);\n\n\tath10k_mac_sta_get_peer_stats_info(ar, sta, sinfo);\n}\n\nstatic int ath10k_mac_op_set_tid_config(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tstruct cfg80211_tid_config *tid_config)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_mac_iter_tid_conf_data data = {};\n\tstruct wmi_per_peer_per_tid_cfg_arg arg = {};\n\tint ret, i;\n\n\tmutex_lock(&ar->conf_mutex);\n\targ.vdev_id = arvif->vdev_id;\n\n\tarvif->tids_rst = 0;\n\tmemset(arvif->tid_conf_changed, 0, sizeof(arvif->tid_conf_changed));\n\n\tfor (i = 0; i < tid_config->n_tid_conf; i++) {\n\t\tret = ath10k_mac_parse_tid_config(ar, sta, vif,\n\t\t\t\t\t\t  &tid_config->tid_conf[i],\n\t\t\t\t\t\t  &arg);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\tret = 0;\n\n\tif (sta)\n\t\tgoto exit;\n\n\tarvif->tids_rst = 0;\n\tdata.curr_vif = vif;\n\tdata.ar = ar;\n\n\tieee80211_iterate_stations_atomic(hw, ath10k_mac_vif_stations_tid_conf,\n\t\t\t\t\t  &data);\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath10k_mac_op_reset_tid_config(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t\t  u8 tids)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_mac_iter_tid_conf_data data = {};\n\tstruct ath10k *ar = hw->priv;\n\tint ret = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (sta) {\n\t\tarvif->tids_rst = 0;\n\t\tret = ath10k_mac_reset_tid_config(ar, sta, arvif, tids);\n\t\tgoto exit;\n\t}\n\n\tarvif->tids_rst = tids;\n\tdata.curr_vif = vif;\n\tdata.ar = ar;\n\tieee80211_iterate_stations_atomic(hw, ath10k_mac_vif_stations_tid_conf,\n\t\t\t\t\t  &data);\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic const struct ieee80211_ops ath10k_ops = {\n\t.tx\t\t\t\t= ath10k_mac_op_tx,\n\t.wake_tx_queue\t\t\t= ath10k_mac_op_wake_tx_queue,\n\t.start\t\t\t\t= ath10k_start,\n\t.stop\t\t\t\t= ath10k_stop,\n\t.config\t\t\t\t= ath10k_config,\n\t.add_interface\t\t\t= ath10k_add_interface,\n\t.remove_interface\t\t= ath10k_remove_interface,\n\t.configure_filter\t\t= ath10k_configure_filter,\n\t.bss_info_changed\t\t= ath10k_bss_info_changed,\n\t.set_coverage_class\t\t= ath10k_mac_op_set_coverage_class,\n\t.hw_scan\t\t\t= ath10k_hw_scan,\n\t.cancel_hw_scan\t\t\t= ath10k_cancel_hw_scan,\n\t.set_key\t\t\t= ath10k_set_key,\n\t.set_default_unicast_key        = ath10k_set_default_unicast_key,\n\t.sta_state\t\t\t= ath10k_sta_state,\n\t.sta_set_txpwr\t\t\t= ath10k_sta_set_txpwr,\n\t.conf_tx\t\t\t= ath10k_conf_tx,\n\t.remain_on_channel\t\t= ath10k_remain_on_channel,\n\t.cancel_remain_on_channel\t= ath10k_cancel_remain_on_channel,\n\t.set_rts_threshold\t\t= ath10k_set_rts_threshold,\n\t.set_frag_threshold\t\t= ath10k_mac_op_set_frag_threshold,\n\t.flush\t\t\t\t= ath10k_flush,\n\t.tx_last_beacon\t\t\t= ath10k_tx_last_beacon,\n\t.set_antenna\t\t\t= ath10k_set_antenna,\n\t.get_antenna\t\t\t= ath10k_get_antenna,\n\t.reconfig_complete\t\t= ath10k_reconfig_complete,\n\t.get_survey\t\t\t= ath10k_get_survey,\n\t.set_bitrate_mask\t\t= ath10k_mac_op_set_bitrate_mask,\n\t.sta_rc_update\t\t\t= ath10k_sta_rc_update,\n\t.offset_tsf\t\t\t= ath10k_offset_tsf,\n\t.ampdu_action\t\t\t= ath10k_ampdu_action,\n\t.get_et_sset_count\t\t= ath10k_debug_get_et_sset_count,\n\t.get_et_stats\t\t\t= ath10k_debug_get_et_stats,\n\t.get_et_strings\t\t\t= ath10k_debug_get_et_strings,\n\t.add_chanctx\t\t\t= ath10k_mac_op_add_chanctx,\n\t.remove_chanctx\t\t\t= ath10k_mac_op_remove_chanctx,\n\t.change_chanctx\t\t\t= ath10k_mac_op_change_chanctx,\n\t.assign_vif_chanctx\t\t= ath10k_mac_op_assign_vif_chanctx,\n\t.unassign_vif_chanctx\t\t= ath10k_mac_op_unassign_vif_chanctx,\n\t.switch_vif_chanctx\t\t= ath10k_mac_op_switch_vif_chanctx,\n\t.sta_pre_rcu_remove\t\t= ath10k_mac_op_sta_pre_rcu_remove,\n\t.sta_statistics\t\t\t= ath10k_sta_statistics,\n\t.set_tid_config\t\t\t= ath10k_mac_op_set_tid_config,\n\t.reset_tid_config\t\t= ath10k_mac_op_reset_tid_config,\n\n\tCFG80211_TESTMODE_CMD(ath10k_tm_cmd)\n\n#ifdef CONFIG_PM\n\t.suspend\t\t\t= ath10k_wow_op_suspend,\n\t.resume\t\t\t\t= ath10k_wow_op_resume,\n\t.set_wakeup\t\t\t= ath10k_wow_op_set_wakeup,\n#endif\n#ifdef CONFIG_MAC80211_DEBUGFS\n\t.sta_add_debugfs\t\t= ath10k_sta_add_debugfs,\n#endif\n\t.set_sar_specs\t\t\t= ath10k_mac_set_sar_specs,\n};\n\n#define CHAN2G(_channel, _freq, _flags) { \\\n\t.band\t\t\t= NL80211_BAND_2GHZ, \\\n\t.hw_value\t\t= (_channel), \\\n\t.center_freq\t\t= (_freq), \\\n\t.flags\t\t\t= (_flags), \\\n\t.max_antenna_gain\t= 0, \\\n\t.max_power\t\t= 30, \\\n}\n\n#define CHAN5G(_channel, _freq, _flags) { \\\n\t.band\t\t\t= NL80211_BAND_5GHZ, \\\n\t.hw_value\t\t= (_channel), \\\n\t.center_freq\t\t= (_freq), \\\n\t.flags\t\t\t= (_flags), \\\n\t.max_antenna_gain\t= 0, \\\n\t.max_power\t\t= 30, \\\n}\n\nstatic const struct ieee80211_channel ath10k_2ghz_channels[] = {\n\tCHAN2G(1, 2412, 0),\n\tCHAN2G(2, 2417, 0),\n\tCHAN2G(3, 2422, 0),\n\tCHAN2G(4, 2427, 0),\n\tCHAN2G(5, 2432, 0),\n\tCHAN2G(6, 2437, 0),\n\tCHAN2G(7, 2442, 0),\n\tCHAN2G(8, 2447, 0),\n\tCHAN2G(9, 2452, 0),\n\tCHAN2G(10, 2457, 0),\n\tCHAN2G(11, 2462, 0),\n\tCHAN2G(12, 2467, 0),\n\tCHAN2G(13, 2472, 0),\n\tCHAN2G(14, 2484, 0),\n};\n\nstatic const struct ieee80211_channel ath10k_5ghz_channels[] = {\n\tCHAN5G(36, 5180, 0),\n\tCHAN5G(40, 5200, 0),\n\tCHAN5G(44, 5220, 0),\n\tCHAN5G(48, 5240, 0),\n\tCHAN5G(52, 5260, 0),\n\tCHAN5G(56, 5280, 0),\n\tCHAN5G(60, 5300, 0),\n\tCHAN5G(64, 5320, 0),\n\tCHAN5G(100, 5500, 0),\n\tCHAN5G(104, 5520, 0),\n\tCHAN5G(108, 5540, 0),\n\tCHAN5G(112, 5560, 0),\n\tCHAN5G(116, 5580, 0),\n\tCHAN5G(120, 5600, 0),\n\tCHAN5G(124, 5620, 0),\n\tCHAN5G(128, 5640, 0),\n\tCHAN5G(132, 5660, 0),\n\tCHAN5G(136, 5680, 0),\n\tCHAN5G(140, 5700, 0),\n\tCHAN5G(144, 5720, 0),\n\tCHAN5G(149, 5745, 0),\n\tCHAN5G(153, 5765, 0),\n\tCHAN5G(157, 5785, 0),\n\tCHAN5G(161, 5805, 0),\n\tCHAN5G(165, 5825, 0),\n\tCHAN5G(169, 5845, 0),\n\tCHAN5G(173, 5865, 0),\n\t/* If you add more, you may need to change ATH10K_MAX_5G_CHAN */\n\t/* And you will definitely need to change ATH10K_NUM_CHANS in core.h */\n};\n\nstruct ath10k *ath10k_mac_create(size_t priv_size)\n{\n\tstruct ieee80211_hw *hw;\n\tstruct ieee80211_ops *ops;\n\tstruct ath10k *ar;\n\n\tops = kmemdup(&ath10k_ops, sizeof(ath10k_ops), GFP_KERNEL);\n\tif (!ops)\n\t\treturn NULL;\n\n\thw = ieee80211_alloc_hw(sizeof(struct ath10k) + priv_size, ops);\n\tif (!hw) {\n\t\tkfree(ops);\n\t\treturn NULL;\n\t}\n\n\tar = hw->priv;\n\tar->hw = hw;\n\tar->ops = ops;\n\n\treturn ar;\n}\n\nvoid ath10k_mac_destroy(struct ath10k *ar)\n{\n\tstruct ieee80211_ops *ops = ar->ops;\n\n\tieee80211_free_hw(ar->hw);\n\tkfree(ops);\n}\n\nstatic const struct ieee80211_iface_limit ath10k_if_limits[] = {\n\t{\n\t\t.max\t= 8,\n\t\t.types\t= BIT(NL80211_IFTYPE_STATION)\n\t\t\t| BIT(NL80211_IFTYPE_P2P_CLIENT)\n\t},\n\t{\n\t\t.max\t= 3,\n\t\t.types\t= BIT(NL80211_IFTYPE_P2P_GO)\n\t},\n\t{\n\t\t.max\t= 1,\n\t\t.types\t= BIT(NL80211_IFTYPE_P2P_DEVICE)\n\t},\n\t{\n\t\t.max\t= 7,\n\t\t.types\t= BIT(NL80211_IFTYPE_AP)\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t| BIT(NL80211_IFTYPE_MESH_POINT)\n#endif\n\t},\n};\n\nstatic const struct ieee80211_iface_limit ath10k_10x_if_limits[] = {\n\t{\n\t\t.max\t= 8,\n\t\t.types\t= BIT(NL80211_IFTYPE_AP)\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t| BIT(NL80211_IFTYPE_MESH_POINT)\n#endif\n\t},\n\t{\n\t\t.max\t= 1,\n\t\t.types\t= BIT(NL80211_IFTYPE_STATION)\n\t},\n};\n\nstatic const struct ieee80211_iface_combination ath10k_if_comb[] = {\n\t{\n\t\t.limits = ath10k_if_limits,\n\t\t.n_limits = ARRAY_SIZE(ath10k_if_limits),\n\t\t.max_interfaces = 8,\n\t\t.num_different_channels = 1,\n\t\t.beacon_int_infra_match = true,\n\t},\n};\n\nstatic const struct ieee80211_iface_combination ath10k_10x_if_comb[] = {\n\t{\n\t\t.limits = ath10k_10x_if_limits,\n\t\t.n_limits = ARRAY_SIZE(ath10k_10x_if_limits),\n\t\t.max_interfaces = 8,\n\t\t.num_different_channels = 1,\n\t\t.beacon_int_infra_match = true,\n\t\t.beacon_int_min_gcd = 1,\n#ifdef CONFIG_ATH10K_DFS_CERTIFIED\n\t\t.radar_detect_widths =\tBIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_40) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_80),\n#endif\n\t},\n};\n\nstatic const struct ieee80211_iface_limit ath10k_tlv_if_limit[] = {\n\t{\n\t\t.max = 2,\n\t\t.types = BIT(NL80211_IFTYPE_STATION),\n\t},\n\t{\n\t\t.max = 2,\n\t\t.types = BIT(NL80211_IFTYPE_AP) |\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t BIT(NL80211_IFTYPE_MESH_POINT) |\n#endif\n\t\t\t BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t BIT(NL80211_IFTYPE_P2P_GO),\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_P2P_DEVICE),\n\t},\n};\n\nstatic const struct ieee80211_iface_limit ath10k_tlv_qcs_if_limit[] = {\n\t{\n\t\t.max = 2,\n\t\t.types = BIT(NL80211_IFTYPE_STATION),\n\t},\n\t{\n\t\t.max = 2,\n\t\t.types = BIT(NL80211_IFTYPE_P2P_CLIENT),\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_AP) |\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t BIT(NL80211_IFTYPE_MESH_POINT) |\n#endif\n\t\t\t BIT(NL80211_IFTYPE_P2P_GO),\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_P2P_DEVICE),\n\t},\n};\n\nstatic const struct ieee80211_iface_limit ath10k_tlv_if_limit_ibss[] = {\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_STATION),\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_ADHOC),\n\t},\n};\n\n/* FIXME: This is not thouroughly tested. These combinations may over- or\n * underestimate hw/fw capabilities.\n */\nstatic struct ieee80211_iface_combination ath10k_tlv_if_comb[] = {\n\t{\n\t\t.limits = ath10k_tlv_if_limit,\n\t\t.num_different_channels = 1,\n\t\t.max_interfaces = 4,\n\t\t.n_limits = ARRAY_SIZE(ath10k_tlv_if_limit),\n\t},\n\t{\n\t\t.limits = ath10k_tlv_if_limit_ibss,\n\t\t.num_different_channels = 1,\n\t\t.max_interfaces = 2,\n\t\t.n_limits = ARRAY_SIZE(ath10k_tlv_if_limit_ibss),\n\t},\n};\n\nstatic struct ieee80211_iface_combination ath10k_tlv_qcs_if_comb[] = {\n\t{\n\t\t.limits = ath10k_tlv_if_limit,\n\t\t.num_different_channels = 1,\n\t\t.max_interfaces = 4,\n\t\t.n_limits = ARRAY_SIZE(ath10k_tlv_if_limit),\n\t},\n\t{\n\t\t.limits = ath10k_tlv_qcs_if_limit,\n\t\t.num_different_channels = 2,\n\t\t.max_interfaces = 4,\n\t\t.n_limits = ARRAY_SIZE(ath10k_tlv_qcs_if_limit),\n\t},\n\t{\n\t\t.limits = ath10k_tlv_if_limit_ibss,\n\t\t.num_different_channels = 1,\n\t\t.max_interfaces = 2,\n\t\t.n_limits = ARRAY_SIZE(ath10k_tlv_if_limit_ibss),\n\t},\n};\n\nstatic const struct ieee80211_iface_limit ath10k_10_4_if_limits[] = {\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_STATION),\n\t},\n\t{\n\t\t.max\t= 16,\n\t\t.types\t= BIT(NL80211_IFTYPE_AP)\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t| BIT(NL80211_IFTYPE_MESH_POINT)\n#endif\n\t},\n};\n\nstatic const struct ieee80211_iface_combination ath10k_10_4_if_comb[] = {\n\t{\n\t\t.limits = ath10k_10_4_if_limits,\n\t\t.n_limits = ARRAY_SIZE(ath10k_10_4_if_limits),\n\t\t.max_interfaces = 16,\n\t\t.num_different_channels = 1,\n\t\t.beacon_int_infra_match = true,\n\t\t.beacon_int_min_gcd = 1,\n#ifdef CONFIG_ATH10K_DFS_CERTIFIED\n\t\t.radar_detect_widths =\tBIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_40) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_80) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_80P80) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_160),\n#endif\n\t},\n};\n\nstatic const struct\nieee80211_iface_combination ath10k_10_4_bcn_int_if_comb[] = {\n\t{\n\t\t.limits = ath10k_10_4_if_limits,\n\t\t.n_limits = ARRAY_SIZE(ath10k_10_4_if_limits),\n\t\t.max_interfaces = 16,\n\t\t.num_different_channels = 1,\n\t\t.beacon_int_infra_match = true,\n\t\t.beacon_int_min_gcd = 100,\n#ifdef CONFIG_ATH10K_DFS_CERTIFIED\n\t\t.radar_detect_widths =  BIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_40) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_80) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_80P80) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_160),\n#endif\n\t},\n};\n\nstatic void ath10k_get_arvif_iter(void *data, u8 *mac,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct ath10k_vif_iter *arvif_iter = data;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\n\tif (arvif->vdev_id == arvif_iter->vdev_id)\n\t\tarvif_iter->arvif = arvif;\n}\n\nstruct ath10k_vif *ath10k_get_arvif(struct ath10k *ar, u32 vdev_id)\n{\n\tstruct ath10k_vif_iter arvif_iter;\n\n\tmemset(&arvif_iter, 0, sizeof(struct ath10k_vif_iter));\n\tarvif_iter.vdev_id = vdev_id;\n\n\tieee80211_iterate_active_interfaces_atomic(ar->hw,\n\t\t\t\t\t\t   ATH10K_ITER_RESUME_FLAGS,\n\t\t\t\t\t\t   ath10k_get_arvif_iter,\n\t\t\t\t\t\t   &arvif_iter);\n\tif (!arvif_iter.arvif) {\n\t\tath10k_warn(ar, \"No VIF found for vdev %d\\n\", vdev_id);\n\t\treturn NULL;\n\t}\n\n\treturn arvif_iter.arvif;\n}\n\n#define WRD_METHOD \"WRDD\"\n#define WRDD_WIFI  (0x07)\n\nstatic u32 ath10k_mac_wrdd_get_mcc(struct ath10k *ar, union acpi_object *wrdd)\n{\n\tunion acpi_object *mcc_pkg;\n\tunion acpi_object *domain_type;\n\tunion acpi_object *mcc_value;\n\tu32 i;\n\n\tif (wrdd->type != ACPI_TYPE_PACKAGE ||\n\t    wrdd->package.count < 2 ||\n\t    wrdd->package.elements[0].type != ACPI_TYPE_INTEGER ||\n\t    wrdd->package.elements[0].integer.value != 0) {\n\t\tath10k_warn(ar, \"ignoring malformed/unsupported wrdd structure\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (i = 1; i < wrdd->package.count; ++i) {\n\t\tmcc_pkg = &wrdd->package.elements[i];\n\n\t\tif (mcc_pkg->type != ACPI_TYPE_PACKAGE)\n\t\t\tcontinue;\n\t\tif (mcc_pkg->package.count < 2)\n\t\t\tcontinue;\n\t\tif (mcc_pkg->package.elements[0].type != ACPI_TYPE_INTEGER ||\n\t\t    mcc_pkg->package.elements[1].type != ACPI_TYPE_INTEGER)\n\t\t\tcontinue;\n\n\t\tdomain_type = &mcc_pkg->package.elements[0];\n\t\tif (domain_type->integer.value != WRDD_WIFI)\n\t\t\tcontinue;\n\n\t\tmcc_value = &mcc_pkg->package.elements[1];\n\t\treturn mcc_value->integer.value;\n\t}\n\treturn 0;\n}\n\nstatic int ath10k_mac_get_wrdd_regulatory(struct ath10k *ar, u16 *rd)\n{\n\tacpi_handle root_handle;\n\tacpi_handle handle;\n\tstruct acpi_buffer wrdd = {ACPI_ALLOCATE_BUFFER, NULL};\n\tacpi_status status;\n\tu32 alpha2_code;\n\tchar alpha2[3];\n\n\troot_handle = ACPI_HANDLE(ar->dev);\n\tif (!root_handle)\n\t\treturn -EOPNOTSUPP;\n\n\tstatus = acpi_get_handle(root_handle, (acpi_string)WRD_METHOD, &handle);\n\tif (ACPI_FAILURE(status)) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"failed to get wrd method %d\\n\", status);\n\t\treturn -EIO;\n\t}\n\n\tstatus = acpi_evaluate_object(handle, NULL, NULL, &wrdd);\n\tif (ACPI_FAILURE(status)) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"failed to call wrdc %d\\n\", status);\n\t\treturn -EIO;\n\t}\n\n\talpha2_code = ath10k_mac_wrdd_get_mcc(ar, wrdd.pointer);\n\tkfree(wrdd.pointer);\n\tif (!alpha2_code)\n\t\treturn -EIO;\n\n\talpha2[0] = (alpha2_code >> 8) & 0xff;\n\talpha2[1] = (alpha2_code >> 0) & 0xff;\n\talpha2[2] = '\\0';\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"regulatory hint from WRDD (alpha2-code): %s\\n\", alpha2);\n\n\t*rd = ath_regd_find_country_by_name(alpha2);\n\tif (*rd == 0xffff)\n\t\treturn -EIO;\n\n\t*rd |= COUNTRY_ERD_FLAG;\n\treturn 0;\n}\n\nstatic int ath10k_mac_init_rd(struct ath10k *ar)\n{\n\tint ret;\n\tu16 rd;\n\n\tret = ath10k_mac_get_wrdd_regulatory(ar, &rd);\n\tif (ret) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"fallback to eeprom programmed regulatory settings\\n\");\n\t\trd = ar->hw_eeprom_rd;\n\t}\n\n\tar->ath_common.regulatory.current_rd = rd;\n\treturn 0;\n}\n\nint ath10k_mac_register(struct ath10k *ar)\n{\n\tstatic const u32 cipher_suites[] = {\n\t\tWLAN_CIPHER_SUITE_WEP40,\n\t\tWLAN_CIPHER_SUITE_WEP104,\n\t\tWLAN_CIPHER_SUITE_TKIP,\n\t\tWLAN_CIPHER_SUITE_CCMP,\n\n\t\t/* Do not add hardware supported ciphers before this line.\n\t\t * Allow software encryption for all chips. Don't forget to\n\t\t * update n_cipher_suites below.\n\t\t */\n\t\tWLAN_CIPHER_SUITE_AES_CMAC,\n\t\tWLAN_CIPHER_SUITE_BIP_CMAC_256,\n\t\tWLAN_CIPHER_SUITE_BIP_GMAC_128,\n\t\tWLAN_CIPHER_SUITE_BIP_GMAC_256,\n\n\t\t/* Only QCA99x0 and QCA4019 varients support GCMP-128, GCMP-256\n\t\t * and CCMP-256 in hardware.\n\t\t */\n\t\tWLAN_CIPHER_SUITE_GCMP,\n\t\tWLAN_CIPHER_SUITE_GCMP_256,\n\t\tWLAN_CIPHER_SUITE_CCMP_256,\n\t};\n\tstruct ieee80211_supported_band *band;\n\tvoid *channels;\n\tint ret;\n\n\tif (!is_valid_ether_addr(ar->mac_addr)) {\n\t\tath10k_warn(ar, \"invalid MAC address; choosing random\\n\");\n\t\teth_random_addr(ar->mac_addr);\n\t}\n\tSET_IEEE80211_PERM_ADDR(ar->hw, ar->mac_addr);\n\n\tSET_IEEE80211_DEV(ar->hw, ar->dev);\n\n\tBUILD_BUG_ON((ARRAY_SIZE(ath10k_2ghz_channels) +\n\t\t      ARRAY_SIZE(ath10k_5ghz_channels)) !=\n\t\t     ATH10K_NUM_CHANS);\n\n\tif (ar->phy_capability & WHAL_WLAN_11G_CAPABILITY) {\n\t\tchannels = kmemdup(ath10k_2ghz_channels,\n\t\t\t\t   sizeof(ath10k_2ghz_channels),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!channels) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tband = &ar->mac.sbands[NL80211_BAND_2GHZ];\n\t\tband->n_channels = ARRAY_SIZE(ath10k_2ghz_channels);\n\t\tband->channels = channels;\n\n\t\tif (ar->hw_params.cck_rate_map_rev2) {\n\t\t\tband->n_bitrates = ath10k_g_rates_rev2_size;\n\t\t\tband->bitrates = ath10k_g_rates_rev2;\n\t\t} else {\n\t\t\tband->n_bitrates = ath10k_g_rates_size;\n\t\t\tband->bitrates = ath10k_g_rates;\n\t\t}\n\n\t\tar->hw->wiphy->bands[NL80211_BAND_2GHZ] = band;\n\t}\n\n\tif (ar->phy_capability & WHAL_WLAN_11A_CAPABILITY) {\n\t\tchannels = kmemdup(ath10k_5ghz_channels,\n\t\t\t\t   sizeof(ath10k_5ghz_channels),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!channels) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tband = &ar->mac.sbands[NL80211_BAND_5GHZ];\n\t\tband->n_channels = ARRAY_SIZE(ath10k_5ghz_channels);\n\t\tband->channels = channels;\n\t\tband->n_bitrates = ath10k_a_rates_size;\n\t\tband->bitrates = ath10k_a_rates;\n\t\tar->hw->wiphy->bands[NL80211_BAND_5GHZ] = band;\n\t}\n\n\twiphy_read_of_freq_limits(ar->hw->wiphy);\n\tath10k_mac_setup_ht_vht_cap(ar);\n\n\tar->hw->wiphy->interface_modes =\n\t\tBIT(NL80211_IFTYPE_STATION) |\n\t\tBIT(NL80211_IFTYPE_AP) |\n\t\tBIT(NL80211_IFTYPE_MESH_POINT);\n\n\tar->hw->wiphy->available_antennas_rx = ar->cfg_rx_chainmask;\n\tar->hw->wiphy->available_antennas_tx = ar->cfg_tx_chainmask;\n\n\tif (!test_bit(ATH10K_FW_FEATURE_NO_P2P, ar->normal_mode_fw.fw_file.fw_features))\n\t\tar->hw->wiphy->interface_modes |=\n\t\t\tBIT(NL80211_IFTYPE_P2P_DEVICE) |\n\t\t\tBIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\tBIT(NL80211_IFTYPE_P2P_GO);\n\n\tieee80211_hw_set(ar->hw, SIGNAL_DBM);\n\n\tif (!test_bit(ATH10K_FW_FEATURE_NO_PS,\n\t\t      ar->running_fw->fw_file.fw_features)) {\n\t\tieee80211_hw_set(ar->hw, SUPPORTS_PS);\n\t\tieee80211_hw_set(ar->hw, SUPPORTS_DYNAMIC_PS);\n\t}\n\n\tieee80211_hw_set(ar->hw, MFP_CAPABLE);\n\tieee80211_hw_set(ar->hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(ar->hw, HAS_RATE_CONTROL);\n\tieee80211_hw_set(ar->hw, AP_LINK_PS);\n\tieee80211_hw_set(ar->hw, SPECTRUM_MGMT);\n\tieee80211_hw_set(ar->hw, SUPPORT_FAST_XMIT);\n\tieee80211_hw_set(ar->hw, CONNECTION_MONITOR);\n\tieee80211_hw_set(ar->hw, SUPPORTS_PER_STA_GTK);\n\tieee80211_hw_set(ar->hw, WANT_MONITOR_VIF);\n\tieee80211_hw_set(ar->hw, CHANCTX_STA_CSA);\n\tieee80211_hw_set(ar->hw, QUEUE_CONTROL);\n\tieee80211_hw_set(ar->hw, SUPPORTS_TX_FRAG);\n\tieee80211_hw_set(ar->hw, REPORTS_LOW_ACK);\n\n\tif (!test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags))\n\t\tieee80211_hw_set(ar->hw, SW_CRYPTO_CONTROL);\n\n\tar->hw->wiphy->features |= NL80211_FEATURE_STATIC_SMPS;\n\tar->hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_DYNAMIC_SMPS)\n\t\tar->hw->wiphy->features |= NL80211_FEATURE_DYNAMIC_SMPS;\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_ENABLED) {\n\t\tieee80211_hw_set(ar->hw, AMPDU_AGGREGATION);\n\t\tieee80211_hw_set(ar->hw, TX_AMPDU_SETUP_IN_HW);\n\t}\n\n\tar->hw->wiphy->max_scan_ssids = WLAN_SCAN_PARAMS_MAX_SSID;\n\tar->hw->wiphy->max_scan_ie_len = WLAN_SCAN_PARAMS_MAX_IE_LEN;\n\n\tif (test_bit(WMI_SERVICE_NLO, ar->wmi.svc_map)) {\n\t\tar->hw->wiphy->max_sched_scan_ssids = WMI_PNO_MAX_SUPP_NETWORKS;\n\t\tar->hw->wiphy->max_match_sets = WMI_PNO_MAX_SUPP_NETWORKS;\n\t\tar->hw->wiphy->max_sched_scan_ie_len = WMI_PNO_MAX_IE_LENGTH;\n\t\tar->hw->wiphy->max_sched_scan_plans = WMI_PNO_MAX_SCHED_SCAN_PLANS;\n\t\tar->hw->wiphy->max_sched_scan_plan_interval =\n\t\t\tWMI_PNO_MAX_SCHED_SCAN_PLAN_INT;\n\t\tar->hw->wiphy->max_sched_scan_plan_iterations =\n\t\t\tWMI_PNO_MAX_SCHED_SCAN_PLAN_ITRNS;\n\t\tar->hw->wiphy->features |= NL80211_FEATURE_ND_RANDOM_MAC_ADDR;\n\t}\n\n\tar->hw->vif_data_size = sizeof(struct ath10k_vif);\n\tar->hw->sta_data_size = sizeof(struct ath10k_sta);\n\tar->hw->txq_data_size = sizeof(struct ath10k_txq);\n\n\tar->hw->max_listen_interval = ATH10K_MAX_HW_LISTEN_INTERVAL;\n\n\tif (test_bit(WMI_SERVICE_BEACON_OFFLOAD, ar->wmi.svc_map)) {\n\t\tar->hw->wiphy->flags |= WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD;\n\n\t\t/* Firmware delivers WPS/P2P Probe Requests frames to driver so\n\t\t * that userspace (e.g. wpa_supplicant/hostapd) can generate\n\t\t * correct Probe Responses. This is more of a hack advert..\n\t\t */\n\t\tar->hw->wiphy->probe_resp_offload |=\n\t\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS |\n\t\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2 |\n\t\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P;\n\t}\n\n\tif (test_bit(WMI_SERVICE_TDLS, ar->wmi.svc_map) ||\n\t    test_bit(WMI_SERVICE_TDLS_EXPLICIT_MODE_ONLY, ar->wmi.svc_map)) {\n\t\tar->hw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;\n\t\tif (test_bit(WMI_SERVICE_TDLS_WIDER_BANDWIDTH, ar->wmi.svc_map))\n\t\t\tieee80211_hw_set(ar->hw, TDLS_WIDER_BW);\n\t}\n\n\tif (test_bit(WMI_SERVICE_TDLS_UAPSD_BUFFER_STA, ar->wmi.svc_map))\n\t\tieee80211_hw_set(ar->hw, SUPPORTS_TDLS_BUFFER_STA);\n\n\tar->hw->wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\n\tar->hw->wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;\n\tar->hw->wiphy->max_remain_on_channel_duration = 5000;\n\n\tar->hw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;\n\tar->hw->wiphy->features |= NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE |\n\t\t\t\t   NL80211_FEATURE_AP_SCAN;\n\n\tar->hw->wiphy->max_ap_assoc_sta = ar->max_num_stations;\n\n\tret = ath10k_wow_init(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to init wow: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\twiphy_ext_feature_set(ar->hw->wiphy, NL80211_EXT_FEATURE_VHT_IBSS);\n\twiphy_ext_feature_set(ar->hw->wiphy,\n\t\t\t      NL80211_EXT_FEATURE_SET_SCAN_DWELL);\n\twiphy_ext_feature_set(ar->hw->wiphy, NL80211_EXT_FEATURE_AQL);\n\n\tif (test_bit(WMI_SERVICE_TX_DATA_ACK_RSSI, ar->wmi.svc_map) ||\n\t    test_bit(WMI_SERVICE_HTT_MGMT_TX_COMP_VALID_FLAGS, ar->wmi.svc_map))\n\t\twiphy_ext_feature_set(ar->hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT);\n\n\tif (ath10k_peer_stats_enabled(ar) ||\n\t    test_bit(WMI_SERVICE_REPORT_AIRTIME, ar->wmi.svc_map))\n\t\twiphy_ext_feature_set(ar->hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_AIRTIME_FAIRNESS);\n\n\tif (test_bit(WMI_SERVICE_RTT_RESPONDER_ROLE, ar->wmi.svc_map))\n\t\twiphy_ext_feature_set(ar->hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER);\n\n\tif (test_bit(WMI_SERVICE_TX_PWR_PER_PEER, ar->wmi.svc_map))\n\t\twiphy_ext_feature_set(ar->hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_STA_TX_PWR);\n\n\tif (test_bit(WMI_SERVICE_PEER_TID_CONFIGS_SUPPORT, ar->wmi.svc_map)) {\n\t\tar->hw->wiphy->tid_config_support.vif |=\n\t\t\t\tBIT(NL80211_TID_CONFIG_ATTR_NOACK) |\n\t\t\t\tBIT(NL80211_TID_CONFIG_ATTR_RETRY_SHORT) |\n\t\t\t\tBIT(NL80211_TID_CONFIG_ATTR_RETRY_LONG) |\n\t\t\t\tBIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL) |\n\t\t\t\tBIT(NL80211_TID_CONFIG_ATTR_TX_RATE) |\n\t\t\t\tBIT(NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE);\n\n\t\tif (test_bit(WMI_SERVICE_EXT_PEER_TID_CONFIGS_SUPPORT,\n\t\t\t     ar->wmi.svc_map)) {\n\t\t\tar->hw->wiphy->tid_config_support.vif |=\n\t\t\t\tBIT(NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL);\n\t\t}\n\n\t\tar->hw->wiphy->tid_config_support.peer =\n\t\t\t\tar->hw->wiphy->tid_config_support.vif;\n\t\tar->hw->wiphy->max_data_retry_count = ATH10K_MAX_RETRY_COUNT;\n\t} else {\n\t\tar->ops->set_tid_config = NULL;\n\t}\n\t/*\n\t * on LL hardware queues are managed entirely by the FW\n\t * so we only advertise to mac we can do the queues thing\n\t */\n\tar->hw->queues = IEEE80211_MAX_QUEUES;\n\n\t/* vdev_ids are used as hw queue numbers. Make sure offchan tx queue is\n\t * something that vdev_ids can't reach so that we don't stop the queue\n\t * accidentally.\n\t */\n\tar->hw->offchannel_tx_hw_queue = IEEE80211_MAX_QUEUES - 1;\n\n\tswitch (ar->running_fw->fw_file.wmi_op_version) {\n\tcase ATH10K_FW_WMI_OP_VERSION_MAIN:\n\t\tar->hw->wiphy->iface_combinations = ath10k_if_comb;\n\t\tar->hw->wiphy->n_iface_combinations =\n\t\t\tARRAY_SIZE(ath10k_if_comb);\n\t\tar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_TLV:\n\t\tif (test_bit(WMI_SERVICE_ADAPTIVE_OCS, ar->wmi.svc_map)) {\n\t\t\tar->hw->wiphy->iface_combinations =\n\t\t\t\tath10k_tlv_qcs_if_comb;\n\t\t\tar->hw->wiphy->n_iface_combinations =\n\t\t\t\tARRAY_SIZE(ath10k_tlv_qcs_if_comb);\n\t\t} else {\n\t\t\tar->hw->wiphy->iface_combinations = ath10k_tlv_if_comb;\n\t\t\tar->hw->wiphy->n_iface_combinations =\n\t\t\t\tARRAY_SIZE(ath10k_tlv_if_comb);\n\t\t}\n\t\tar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_10_1:\n\tcase ATH10K_FW_WMI_OP_VERSION_10_2:\n\tcase ATH10K_FW_WMI_OP_VERSION_10_2_4:\n\t\tar->hw->wiphy->iface_combinations = ath10k_10x_if_comb;\n\t\tar->hw->wiphy->n_iface_combinations =\n\t\t\tARRAY_SIZE(ath10k_10x_if_comb);\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_10_4:\n\t\tar->hw->wiphy->iface_combinations = ath10k_10_4_if_comb;\n\t\tar->hw->wiphy->n_iface_combinations =\n\t\t\tARRAY_SIZE(ath10k_10_4_if_comb);\n\t\tif (test_bit(WMI_SERVICE_VDEV_DIFFERENT_BEACON_INTERVAL_SUPPORT,\n\t\t\t     ar->wmi.svc_map)) {\n\t\t\tar->hw->wiphy->iface_combinations =\n\t\t\t\tath10k_10_4_bcn_int_if_comb;\n\t\t\tar->hw->wiphy->n_iface_combinations =\n\t\t\t\tARRAY_SIZE(ath10k_10_4_bcn_int_if_comb);\n\t\t}\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_UNSET:\n\tcase ATH10K_FW_WMI_OP_VERSION_MAX:\n\t\tWARN_ON(1);\n\t\tret = -EINVAL;\n\t\tgoto err_free;\n\t}\n\n\tif (ar->hw_params.dynamic_sar_support)\n\t\tar->hw->wiphy->sar_capa = &ath10k_sar_capa;\n\n\tif (!test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags))\n\t\tar->hw->netdev_features = NETIF_F_HW_CSUM;\n\n\tif (IS_ENABLED(CONFIG_ATH10K_DFS_CERTIFIED)) {\n\t\t/* Init ath dfs pattern detector */\n\t\tar->ath_common.debug_mask = ATH_DBG_DFS;\n\t\tar->dfs_detector = dfs_pattern_detector_init(&ar->ath_common,\n\t\t\t\t\t\t\t     NL80211_DFS_UNSET);\n\n\t\tif (!ar->dfs_detector)\n\t\t\tath10k_warn(ar, \"failed to initialise DFS pattern detector\\n\");\n\t}\n\n\tret = ath10k_mac_init_rd(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to derive regdom: %d\\n\", ret);\n\t\tgoto err_dfs_detector_exit;\n\t}\n\n\t/* Disable set_coverage_class for chipsets that do not support it. */\n\tif (!ar->hw_params.hw_ops->set_coverage_class)\n\t\tar->ops->set_coverage_class = NULL;\n\n\tret = ath_regd_init(&ar->ath_common.regulatory, ar->hw->wiphy,\n\t\t\t    ath10k_reg_notifier);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to initialise regulatory: %i\\n\", ret);\n\t\tgoto err_dfs_detector_exit;\n\t}\n\n\tif (test_bit(WMI_SERVICE_SPOOF_MAC_SUPPORT, ar->wmi.svc_map)) {\n\t\tar->hw->wiphy->features |=\n\t\t\tNL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;\n\t}\n\n\tar->hw->wiphy->cipher_suites = cipher_suites;\n\n\t/* QCA988x and QCA6174 family chips do not support CCMP-256, GCMP-128\n\t * and GCMP-256 ciphers in hardware. Fetch number of ciphers supported\n\t * from chip specific hw_param table.\n\t */\n\tif (!ar->hw_params.n_cipher_suites ||\n\t    ar->hw_params.n_cipher_suites > ARRAY_SIZE(cipher_suites)) {\n\t\tath10k_err(ar, \"invalid hw_params.n_cipher_suites %d\\n\",\n\t\t\t   ar->hw_params.n_cipher_suites);\n\t\tar->hw_params.n_cipher_suites = 8;\n\t}\n\tar->hw->wiphy->n_cipher_suites = ar->hw_params.n_cipher_suites;\n\n\twiphy_ext_feature_set(ar->hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\tar->hw->weight_multiplier = ATH10K_AIRTIME_WEIGHT_MULTIPLIER;\n\n\tret = ieee80211_register_hw(ar->hw);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to register ieee80211: %d\\n\", ret);\n\t\tgoto err_dfs_detector_exit;\n\t}\n\n\tif (test_bit(WMI_SERVICE_PER_PACKET_SW_ENCRYPT, ar->wmi.svc_map)) {\n\t\tar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_AP_VLAN);\n\t\tar->hw->wiphy->software_iftypes |= BIT(NL80211_IFTYPE_AP_VLAN);\n\t}\n\n\tif (!ath_is_world_regd(&ar->ath_common.regulatory)) {\n\t\tret = regulatory_hint(ar->hw->wiphy,\n\t\t\t\t      ar->ath_common.regulatory.alpha2);\n\t\tif (ret)\n\t\t\tgoto err_unregister;\n\t}\n\n\treturn 0;\n\nerr_unregister:\n\tieee80211_unregister_hw(ar->hw);\n\nerr_dfs_detector_exit:\n\tif (IS_ENABLED(CONFIG_ATH10K_DFS_CERTIFIED) && ar->dfs_detector)\n\t\tar->dfs_detector->exit(ar->dfs_detector);\n\nerr_free:\n\tkfree(ar->mac.sbands[NL80211_BAND_2GHZ].channels);\n\tkfree(ar->mac.sbands[NL80211_BAND_5GHZ].channels);\n\n\tSET_IEEE80211_DEV(ar->hw, NULL);\n\treturn ret;\n}\n\nvoid ath10k_mac_unregister(struct ath10k *ar)\n{\n\tieee80211_unregister_hw(ar->hw);\n\n\tif (IS_ENABLED(CONFIG_ATH10K_DFS_CERTIFIED) && ar->dfs_detector)\n\t\tar->dfs_detector->exit(ar->dfs_detector);\n\n\tkfree(ar->mac.sbands[NL80211_BAND_2GHZ].channels);\n\tkfree(ar->mac.sbands[NL80211_BAND_5GHZ].channels);\n\n\tSET_IEEE80211_DEV(ar->hw, NULL);\n}\n"}}, "reports": [{"events": [{"location": {"col": 22, "file": 0, "line": 510}, "message": "ERROR: invalid reference to the index variable of the iterator on line 496"}], "macros": [], "notes": [], "path": "/src/drivers/net/wireless/ath/ath10k/mac.c", "reportHash": "25b9e5f4008cbc82ddc17165937cab13", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
