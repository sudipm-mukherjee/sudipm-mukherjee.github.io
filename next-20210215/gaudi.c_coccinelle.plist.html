<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/misc/habanalabs/gaudi/gaudi.c", "content": "// SPDX-License-Identifier: GPL-2.0\n\n/*\n * Copyright 2016-2020 HabanaLabs, Ltd.\n * All Rights Reserved.\n */\n\n#include \"gaudiP.h\"\n#include \"../include/hw_ip/mmu/mmu_general.h\"\n#include \"../include/hw_ip/mmu/mmu_v1_1.h\"\n#include \"../include/gaudi/gaudi_masks.h\"\n#include \"../include/gaudi/gaudi_fw_if.h\"\n#include \"../include/gaudi/gaudi_reg_map.h\"\n#include \"../include/gaudi/gaudi_async_ids_map_extended.h\"\n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/firmware.h>\n#include <linux/hwmon.h>\n#include <linux/iommu.h>\n#include <linux/seq_file.h>\n\n/*\n * Gaudi security scheme:\n *\n * 1. Host is protected by:\n *        - Range registers\n *        - MMU\n *\n * 2. DDR is protected by:\n *        - Range registers (protect the first 512MB)\n *\n * 3. Configuration is protected by:\n *        - Range registers\n *        - Protection bits\n *\n * MMU is always enabled.\n *\n * QMAN DMA channels 0,1 (PCI DMAN):\n *     - DMA is not secured.\n *     - PQ and CQ are secured.\n *     - CP is secured: The driver needs to parse CB but WREG should be allowed\n *                      because of TDMA (tensor DMA). Hence, WREG is always not\n *                      secured.\n *\n * When the driver needs to use DMA it will check that Gaudi is idle, set DMA\n * channel 0 to be secured, execute the DMA and change it back to not secured.\n * Currently, the driver doesn't use the DMA while there are compute jobs\n * running.\n *\n * The current use cases for the driver to use the DMA are:\n *     - Clear SRAM on context switch (happens on context switch when device is\n *       idle)\n *     - MMU page tables area clear (happens on init)\n *\n * QMAN DMA 2-7, TPC, MME, NIC:\n * PQ is secured and is located on the Host (HBM CON TPC3 bug)\n * CQ, CP and the engine are not secured\n *\n */\n\n#define GAUDI_BOOT_FIT_FILE\t\"habanalabs/gaudi/gaudi-boot-fit.itb\"\n#define GAUDI_LINUX_FW_FILE\t\"habanalabs/gaudi/gaudi-fit.itb\"\n#define GAUDI_TPC_FW_FILE\t\"habanalabs/gaudi/gaudi_tpc.bin\"\n\n#define GAUDI_DMA_POOL_BLK_SIZE\t\t0x100 /* 256 bytes */\n\n#define GAUDI_RESET_TIMEOUT_MSEC\t2000\t\t/* 2000ms */\n#define GAUDI_RESET_WAIT_MSEC\t\t1\t\t/* 1ms */\n#define GAUDI_CPU_RESET_WAIT_MSEC\t200\t\t/* 200ms */\n#define GAUDI_TEST_QUEUE_WAIT_USEC\t100000\t\t/* 100ms */\n\n#define GAUDI_PLDM_RESET_WAIT_MSEC\t1000\t\t/* 1s */\n#define GAUDI_PLDM_HRESET_TIMEOUT_MSEC\t20000\t\t/* 20s */\n#define GAUDI_PLDM_TEST_QUEUE_WAIT_USEC\t1000000\t\t/* 1s */\n#define GAUDI_PLDM_MMU_TIMEOUT_USEC\t(MMU_CONFIG_TIMEOUT_USEC * 100)\n#define GAUDI_PLDM_QMAN0_TIMEOUT_USEC\t(HL_DEVICE_TIMEOUT_USEC * 30)\n#define GAUDI_PLDM_TPC_KERNEL_WAIT_USEC\t(HL_DEVICE_TIMEOUT_USEC * 30)\n#define GAUDI_BOOT_FIT_REQ_TIMEOUT_USEC\t1000000\t\t/* 1s */\n#define GAUDI_MSG_TO_CPU_TIMEOUT_USEC\t4000000\t\t/* 4s */\n\n#define GAUDI_QMAN0_FENCE_VAL\t\t0x72E91AB9\n\n#define GAUDI_MAX_STRING_LEN\t\t20\n\n#define GAUDI_CB_POOL_CB_CNT\t\t512\n#define GAUDI_CB_POOL_CB_SIZE\t\t0x20000 /* 128KB */\n\n#define GAUDI_ALLOC_CPU_MEM_RETRY_CNT\t3\n\n#define GAUDI_NUM_OF_TPC_INTR_CAUSE\t20\n\n#define GAUDI_NUM_OF_QM_ERR_CAUSE\t16\n\n#define GAUDI_NUM_OF_QM_ARB_ERR_CAUSE\t3\n\n#define GAUDI_ARB_WDT_TIMEOUT\t\t0x1000000\n\n#define GAUDI_CLK_GATE_DEBUGFS_MASK\t(\\\n\t\tBIT(GAUDI_ENGINE_ID_MME_0) |\\\n\t\tBIT(GAUDI_ENGINE_ID_MME_2) |\\\n\t\tGENMASK_ULL(GAUDI_ENGINE_ID_TPC_7, GAUDI_ENGINE_ID_TPC_0))\n\n#define HBM_SCRUBBING_TIMEOUT_US\t1000000 /* 1s */\n\n#define GAUDI_PLL_MAX 10\n\nstatic const char gaudi_irq_name[GAUDI_MSI_ENTRIES][GAUDI_MAX_STRING_LEN] = {\n\t\t\"gaudi cq 0_0\", \"gaudi cq 0_1\", \"gaudi cq 0_2\", \"gaudi cq 0_3\",\n\t\t\"gaudi cq 1_0\", \"gaudi cq 1_1\", \"gaudi cq 1_2\", \"gaudi cq 1_3\",\n\t\t\"gaudi cq 5_0\", \"gaudi cq 5_1\", \"gaudi cq 5_2\", \"gaudi cq 5_3\",\n\t\t\"gaudi cpu eq\"\n};\n\nstatic const u8 gaudi_dma_assignment[GAUDI_DMA_MAX] = {\n\t[GAUDI_PCI_DMA_1] = GAUDI_ENGINE_ID_DMA_0,\n\t[GAUDI_PCI_DMA_2] = GAUDI_ENGINE_ID_DMA_1,\n\t[GAUDI_HBM_DMA_1] = GAUDI_ENGINE_ID_DMA_2,\n\t[GAUDI_HBM_DMA_2] = GAUDI_ENGINE_ID_DMA_3,\n\t[GAUDI_HBM_DMA_3] = GAUDI_ENGINE_ID_DMA_4,\n\t[GAUDI_HBM_DMA_4] = GAUDI_ENGINE_ID_DMA_5,\n\t[GAUDI_HBM_DMA_5] = GAUDI_ENGINE_ID_DMA_6,\n\t[GAUDI_HBM_DMA_6] = GAUDI_ENGINE_ID_DMA_7\n};\n\nstatic const u8 gaudi_cq_assignment[NUMBER_OF_CMPLT_QUEUES] = {\n\t[0] = GAUDI_QUEUE_ID_DMA_0_0,\n\t[1] = GAUDI_QUEUE_ID_DMA_0_1,\n\t[2] = GAUDI_QUEUE_ID_DMA_0_2,\n\t[3] = GAUDI_QUEUE_ID_DMA_0_3,\n\t[4] = GAUDI_QUEUE_ID_DMA_1_0,\n\t[5] = GAUDI_QUEUE_ID_DMA_1_1,\n\t[6] = GAUDI_QUEUE_ID_DMA_1_2,\n\t[7] = GAUDI_QUEUE_ID_DMA_1_3,\n};\n\nstatic const u16 gaudi_packet_sizes[MAX_PACKET_ID] = {\n\t[PACKET_WREG_32]\t= sizeof(struct packet_wreg32),\n\t[PACKET_WREG_BULK]\t= sizeof(struct packet_wreg_bulk),\n\t[PACKET_MSG_LONG]\t= sizeof(struct packet_msg_long),\n\t[PACKET_MSG_SHORT]\t= sizeof(struct packet_msg_short),\n\t[PACKET_CP_DMA]\t\t= sizeof(struct packet_cp_dma),\n\t[PACKET_REPEAT]\t\t= sizeof(struct packet_repeat),\n\t[PACKET_MSG_PROT]\t= sizeof(struct packet_msg_prot),\n\t[PACKET_FENCE]\t\t= sizeof(struct packet_fence),\n\t[PACKET_LIN_DMA]\t= sizeof(struct packet_lin_dma),\n\t[PACKET_NOP]\t\t= sizeof(struct packet_nop),\n\t[PACKET_STOP]\t\t= sizeof(struct packet_stop),\n\t[PACKET_ARB_POINT]\t= sizeof(struct packet_arb_point),\n\t[PACKET_WAIT]\t\t= sizeof(struct packet_wait),\n\t[PACKET_LOAD_AND_EXE]\t= sizeof(struct packet_load_and_exe)\n};\n\nstatic inline bool validate_packet_id(enum packet_id id)\n{\n\tswitch (id) {\n\tcase PACKET_WREG_32:\n\tcase PACKET_WREG_BULK:\n\tcase PACKET_MSG_LONG:\n\tcase PACKET_MSG_SHORT:\n\tcase PACKET_CP_DMA:\n\tcase PACKET_REPEAT:\n\tcase PACKET_MSG_PROT:\n\tcase PACKET_FENCE:\n\tcase PACKET_LIN_DMA:\n\tcase PACKET_NOP:\n\tcase PACKET_STOP:\n\tcase PACKET_ARB_POINT:\n\tcase PACKET_WAIT:\n\tcase PACKET_LOAD_AND_EXE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const char * const\ngaudi_tpc_interrupts_cause[GAUDI_NUM_OF_TPC_INTR_CAUSE] = {\n\t\"tpc_address_exceed_slm\",\n\t\"tpc_div_by_0\",\n\t\"tpc_spu_mac_overflow\",\n\t\"tpc_spu_addsub_overflow\",\n\t\"tpc_spu_abs_overflow\",\n\t\"tpc_spu_fp_dst_nan_inf\",\n\t\"tpc_spu_fp_dst_denorm\",\n\t\"tpc_vpu_mac_overflow\",\n\t\"tpc_vpu_addsub_overflow\",\n\t\"tpc_vpu_abs_overflow\",\n\t\"tpc_vpu_fp_dst_nan_inf\",\n\t\"tpc_vpu_fp_dst_denorm\",\n\t\"tpc_assertions\",\n\t\"tpc_illegal_instruction\",\n\t\"tpc_pc_wrap_around\",\n\t\"tpc_qm_sw_err\",\n\t\"tpc_hbw_rresp_err\",\n\t\"tpc_hbw_bresp_err\",\n\t\"tpc_lbw_rresp_err\",\n\t\"tpc_lbw_bresp_err\"\n};\n\nstatic const char * const\ngaudi_qman_error_cause[GAUDI_NUM_OF_QM_ERR_CAUSE] = {\n\t\"PQ AXI HBW error\",\n\t\"CQ AXI HBW error\",\n\t\"CP AXI HBW error\",\n\t\"CP error due to undefined OPCODE\",\n\t\"CP encountered STOP OPCODE\",\n\t\"CP AXI LBW error\",\n\t\"CP WRREG32 or WRBULK returned error\",\n\t\"N/A\",\n\t\"FENCE 0 inc over max value and clipped\",\n\t\"FENCE 1 inc over max value and clipped\",\n\t\"FENCE 2 inc over max value and clipped\",\n\t\"FENCE 3 inc over max value and clipped\",\n\t\"FENCE 0 dec under min value and clipped\",\n\t\"FENCE 1 dec under min value and clipped\",\n\t\"FENCE 2 dec under min value and clipped\",\n\t\"FENCE 3 dec under min value and clipped\"\n};\n\nstatic const char * const\ngaudi_qman_arb_error_cause[GAUDI_NUM_OF_QM_ARB_ERR_CAUSE] = {\n\t\"Choice push while full error\",\n\t\"Choice Q watchdog error\",\n\t\"MSG AXI LBW returned with error\"\n};\n\nenum gaudi_sm_sei_cause {\n\tGAUDI_SM_SEI_SO_OVERFLOW,\n\tGAUDI_SM_SEI_LBW_4B_UNALIGNED,\n\tGAUDI_SM_SEI_AXI_RESPONSE_ERR\n};\n\nstatic enum hl_queue_type gaudi_queue_type[GAUDI_QUEUE_ID_SIZE] = {\n\tQUEUE_TYPE_EXT, /* GAUDI_QUEUE_ID_DMA_0_0 */\n\tQUEUE_TYPE_EXT, /* GAUDI_QUEUE_ID_DMA_0_1 */\n\tQUEUE_TYPE_EXT, /* GAUDI_QUEUE_ID_DMA_0_2 */\n\tQUEUE_TYPE_EXT, /* GAUDI_QUEUE_ID_DMA_0_3 */\n\tQUEUE_TYPE_EXT, /* GAUDI_QUEUE_ID_DMA_1_0 */\n\tQUEUE_TYPE_EXT, /* GAUDI_QUEUE_ID_DMA_1_1 */\n\tQUEUE_TYPE_EXT, /* GAUDI_QUEUE_ID_DMA_1_2 */\n\tQUEUE_TYPE_EXT, /* GAUDI_QUEUE_ID_DMA_1_3 */\n\tQUEUE_TYPE_CPU, /* GAUDI_QUEUE_ID_CPU_PQ */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_2_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_2_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_2_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_2_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_3_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_3_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_3_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_3_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_4_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_4_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_4_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_4_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_5_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_5_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_5_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_5_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_6_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_6_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_6_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_6_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_7_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_7_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_7_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_DMA_7_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_MME_0_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_MME_0_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_MME_0_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_MME_0_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_MME_1_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_MME_1_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_MME_1_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_MME_1_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_0_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_0_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_0_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_0_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_1_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_1_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_1_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_1_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_2_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_2_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_2_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_2_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_3_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_3_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_3_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_3_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_4_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_4_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_4_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_4_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_5_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_5_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_5_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_5_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_6_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_6_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_6_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_6_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_7_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_7_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_7_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_TPC_7_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_0_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_0_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_0_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_0_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_1_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_1_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_1_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_1_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_2_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_2_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_2_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_2_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_3_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_3_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_3_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_3_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_4_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_4_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_4_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_4_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_5_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_5_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_5_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_5_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_6_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_6_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_6_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_6_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_7_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_7_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_7_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_7_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_8_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_8_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_8_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_8_3 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_9_0 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_9_1 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_9_2 */\n\tQUEUE_TYPE_INT, /* GAUDI_QUEUE_ID_NIC_9_3 */\n};\n\nstruct ecc_info_extract_params {\n\tu64 block_address;\n\tu32 num_memories;\n\tbool derr;\n\tbool disable_clock_gating;\n};\n\nstatic int gaudi_mmu_update_asid_hop0_addr(struct hl_device *hdev, u32 asid,\n\t\t\t\t\t\t\t\tu64 phys_addr);\nstatic int gaudi_send_job_on_qman0(struct hl_device *hdev,\n\t\t\t\t\tstruct hl_cs_job *job);\nstatic int gaudi_memset_device_memory(struct hl_device *hdev, u64 addr,\n\t\t\t\t\tu32 size, u64 val);\nstatic int gaudi_memset_registers(struct hl_device *hdev, u64 reg_base,\n\t\t\t\t\tu32 num_regs, u32 val);\nstatic int gaudi_schedule_register_memset(struct hl_device *hdev,\n\t\tu32 hw_queue_id, u64 reg_base, u32 num_regs, u32 val);\nstatic int gaudi_run_tpc_kernel(struct hl_device *hdev, u64 tpc_kernel,\n\t\t\t\tu32 tpc_id);\nstatic int gaudi_mmu_clear_pgt_range(struct hl_device *hdev);\nstatic int gaudi_cpucp_info_get(struct hl_device *hdev);\nstatic void gaudi_disable_clock_gating(struct hl_device *hdev);\nstatic void gaudi_mmu_prepare(struct hl_device *hdev, u32 asid);\nstatic u32 gaudi_gen_signal_cb(struct hl_device *hdev, void *data, u16 sob_id,\n\t\t\t\tu32 size, bool eb);\nstatic u32 gaudi_gen_wait_cb(struct hl_device *hdev,\n\t\t\t\tstruct hl_gen_wait_properties *prop);\n\nstatic inline enum hl_collective_mode\nget_collective_mode(struct hl_device *hdev, u32 queue_id)\n{\n\tif (gaudi_queue_type[queue_id] == QUEUE_TYPE_EXT)\n\t\treturn HL_COLLECTIVE_MASTER;\n\n\tif (queue_id >= GAUDI_QUEUE_ID_DMA_5_0 &&\n\t\t\tqueue_id <= GAUDI_QUEUE_ID_DMA_5_3)\n\t\treturn HL_COLLECTIVE_SLAVE;\n\n\tif (queue_id >= GAUDI_QUEUE_ID_TPC_7_0 &&\n\t\t\tqueue_id <= GAUDI_QUEUE_ID_TPC_7_3)\n\t\treturn HL_COLLECTIVE_SLAVE;\n\n\tif (queue_id >= GAUDI_QUEUE_ID_NIC_0_0 &&\n\t\t\tqueue_id <= GAUDI_QUEUE_ID_NIC_9_3)\n\t\treturn HL_COLLECTIVE_SLAVE;\n\n\treturn HL_COLLECTIVE_NOT_SUPPORTED;\n}\n\nstatic int gaudi_get_fixed_properties(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu32 num_sync_stream_queues = 0;\n\tint i;\n\n\tprop->max_queues = GAUDI_QUEUE_ID_SIZE;\n\tprop->hw_queues_props = kcalloc(prop->max_queues,\n\t\t\tsizeof(struct hw_queue_properties),\n\t\t\tGFP_KERNEL);\n\n\tif (!prop->hw_queues_props)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0 ; i < prop->max_queues ; i++) {\n\t\tif (gaudi_queue_type[i] == QUEUE_TYPE_EXT) {\n\t\t\tprop->hw_queues_props[i].type = QUEUE_TYPE_EXT;\n\t\t\tprop->hw_queues_props[i].driver_only = 0;\n\t\t\tprop->hw_queues_props[i].supports_sync_stream = 1;\n\t\t\tprop->hw_queues_props[i].cb_alloc_flags =\n\t\t\t\tCB_ALLOC_KERNEL;\n\t\t\tnum_sync_stream_queues++;\n\t\t} else if (gaudi_queue_type[i] == QUEUE_TYPE_CPU) {\n\t\t\tprop->hw_queues_props[i].type = QUEUE_TYPE_CPU;\n\t\t\tprop->hw_queues_props[i].driver_only = 1;\n\t\t\tprop->hw_queues_props[i].supports_sync_stream = 0;\n\t\t\tprop->hw_queues_props[i].cb_alloc_flags =\n\t\t\t\tCB_ALLOC_KERNEL;\n\t\t} else if (gaudi_queue_type[i] == QUEUE_TYPE_INT) {\n\t\t\tprop->hw_queues_props[i].type = QUEUE_TYPE_INT;\n\t\t\tprop->hw_queues_props[i].driver_only = 0;\n\t\t\tprop->hw_queues_props[i].supports_sync_stream = 0;\n\t\t\tprop->hw_queues_props[i].cb_alloc_flags =\n\t\t\t\tCB_ALLOC_USER;\n\n\t\t}\n\t\tprop->hw_queues_props[i].collective_mode =\n\t\t\t\t\t\tget_collective_mode(hdev, i);\n\t}\n\n\tprop->completion_queues_count = NUMBER_OF_CMPLT_QUEUES;\n\tprop->collective_first_sob = 0;\n\tprop->collective_first_mon = 0;\n\n\t/* 2 SOBs per internal queue stream are reserved for collective */\n\tprop->sync_stream_first_sob =\n\t\t\tALIGN(NUMBER_OF_SOBS_IN_GRP, HL_MAX_SOBS_PER_MONITOR)\n\t\t\t* QMAN_STREAMS * HL_RSVD_SOBS;\n\n\t/* 1 monitor per internal queue stream are reserved for collective\n\t * 2 monitors per external queue stream are reserved for collective\n\t */\n\tprop->sync_stream_first_mon =\n\t\t\t(NUMBER_OF_COLLECTIVE_QUEUES * QMAN_STREAMS) +\n\t\t\t(NUMBER_OF_EXT_HW_QUEUES * 2);\n\n\tprop->dram_base_address = DRAM_PHYS_BASE;\n\tprop->dram_size = GAUDI_HBM_SIZE_32GB;\n\tprop->dram_end_address = prop->dram_base_address +\n\t\t\t\t\tprop->dram_size;\n\tprop->dram_user_base_address = DRAM_BASE_ADDR_USER;\n\n\tprop->sram_base_address = SRAM_BASE_ADDR;\n\tprop->sram_size = SRAM_SIZE;\n\tprop->sram_end_address = prop->sram_base_address +\n\t\t\t\t\tprop->sram_size;\n\tprop->sram_user_base_address = prop->sram_base_address +\n\t\t\t\t\tSRAM_USER_BASE_OFFSET;\n\n\tprop->mmu_pgt_addr = MMU_PAGE_TABLES_ADDR;\n\tif (hdev->pldm)\n\t\tprop->mmu_pgt_size = 0x800000; /* 8MB */\n\telse\n\t\tprop->mmu_pgt_size = MMU_PAGE_TABLES_SIZE;\n\tprop->mmu_pte_size = HL_PTE_SIZE;\n\tprop->mmu_hop_table_size = HOP_TABLE_SIZE;\n\tprop->mmu_hop0_tables_total_size = HOP0_TABLES_TOTAL_SIZE;\n\tprop->dram_page_size = PAGE_SIZE_2MB;\n\tprop->dram_supports_virtual_memory = false;\n\n\tprop->pmmu.hop0_shift = HOP0_SHIFT;\n\tprop->pmmu.hop1_shift = HOP1_SHIFT;\n\tprop->pmmu.hop2_shift = HOP2_SHIFT;\n\tprop->pmmu.hop3_shift = HOP3_SHIFT;\n\tprop->pmmu.hop4_shift = HOP4_SHIFT;\n\tprop->pmmu.hop0_mask = HOP0_MASK;\n\tprop->pmmu.hop1_mask = HOP1_MASK;\n\tprop->pmmu.hop2_mask = HOP2_MASK;\n\tprop->pmmu.hop3_mask = HOP3_MASK;\n\tprop->pmmu.hop4_mask = HOP4_MASK;\n\tprop->pmmu.start_addr = VA_HOST_SPACE_START;\n\tprop->pmmu.end_addr =\n\t\t\t(VA_HOST_SPACE_START + VA_HOST_SPACE_SIZE / 2) - 1;\n\tprop->pmmu.page_size = PAGE_SIZE_4KB;\n\tprop->pmmu.num_hops = MMU_ARCH_5_HOPS;\n\n\t/* PMMU and HPMMU are the same except of page size */\n\tmemcpy(&prop->pmmu_huge, &prop->pmmu, sizeof(prop->pmmu));\n\tprop->pmmu_huge.page_size = PAGE_SIZE_2MB;\n\n\t/* shifts and masks are the same in PMMU and DMMU */\n\tmemcpy(&prop->dmmu, &prop->pmmu, sizeof(prop->pmmu));\n\tprop->dmmu.start_addr = (VA_HOST_SPACE_START + VA_HOST_SPACE_SIZE / 2);\n\tprop->dmmu.end_addr = VA_HOST_SPACE_END;\n\tprop->dmmu.page_size = PAGE_SIZE_2MB;\n\n\tprop->cfg_size = CFG_SIZE;\n\tprop->max_asid = MAX_ASID;\n\tprop->num_of_events = GAUDI_EVENT_SIZE;\n\tprop->tpc_enabled_mask = TPC_ENABLED_MASK;\n\n\tprop->max_power_default = MAX_POWER_DEFAULT_PCI;\n\n\tprop->cb_pool_cb_cnt = GAUDI_CB_POOL_CB_CNT;\n\tprop->cb_pool_cb_size = GAUDI_CB_POOL_CB_SIZE;\n\n\tprop->pcie_dbi_base_address = mmPCIE_DBI_BASE;\n\tprop->pcie_aux_dbi_reg_addr = CFG_BASE + mmPCIE_AUX_DBI;\n\n\tstrncpy(prop->cpucp_info.card_name, GAUDI_DEFAULT_CARD_NAME,\n\t\t\t\t\tCARD_NAME_MAX_LEN);\n\n\tprop->max_pending_cs = GAUDI_MAX_PENDING_CS;\n\n\tprop->first_available_user_sob[HL_GAUDI_WS_DCORE] =\n\t\t\tprop->sync_stream_first_sob +\n\t\t\t(num_sync_stream_queues * HL_RSVD_SOBS);\n\tprop->first_available_user_mon[HL_GAUDI_WS_DCORE] =\n\t\t\tprop->sync_stream_first_mon +\n\t\t\t(num_sync_stream_queues * HL_RSVD_MONS);\n\n\tprop->first_available_user_msix_interrupt = USHRT_MAX;\n\n\tfor (i = 0 ; i < HL_MAX_DCORES ; i++)\n\t\tprop->first_available_cq[i] = USHRT_MAX;\n\n\t/* disable fw security for now, set it in a later stage */\n\tprop->fw_security_disabled = true;\n\tprop->fw_security_status_valid = false;\n\tprop->hard_reset_done_by_fw = false;\n\n\treturn 0;\n}\n\nstatic int gaudi_pci_bars_map(struct hl_device *hdev)\n{\n\tstatic const char * const name[] = {\"SRAM\", \"CFG\", \"HBM\"};\n\tbool is_wc[3] = {false, false, true};\n\tint rc;\n\n\trc = hl_pci_bars_map(hdev, name, is_wc);\n\tif (rc)\n\t\treturn rc;\n\n\thdev->rmmio = hdev->pcie_bar[CFG_BAR_ID] +\n\t\t\t(CFG_BASE - SPI_FLASH_BASE_ADDR);\n\n\treturn 0;\n}\n\nstatic u64 gaudi_set_hbm_bar_base(struct hl_device *hdev, u64 addr)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tstruct hl_inbound_pci_region pci_region;\n\tu64 old_addr = addr;\n\tint rc;\n\n\tif ((gaudi) && (gaudi->hbm_bar_cur_addr == addr))\n\t\treturn old_addr;\n\n\t/* Inbound Region 2 - Bar 4 - Point to HBM */\n\tpci_region.mode = PCI_BAR_MATCH_MODE;\n\tpci_region.bar = HBM_BAR_ID;\n\tpci_region.addr = addr;\n\trc = hl_pci_set_inbound_region(hdev, 2, &pci_region);\n\tif (rc)\n\t\treturn U64_MAX;\n\n\tif (gaudi) {\n\t\told_addr = gaudi->hbm_bar_cur_addr;\n\t\tgaudi->hbm_bar_cur_addr = addr;\n\t}\n\n\treturn old_addr;\n}\n\nstatic int gaudi_init_iatu(struct hl_device *hdev)\n{\n\tstruct hl_inbound_pci_region inbound_region;\n\tstruct hl_outbound_pci_region outbound_region;\n\tint rc;\n\n\t/* Inbound Region 0 - Bar 0 - Point to SRAM + CFG */\n\tinbound_region.mode = PCI_BAR_MATCH_MODE;\n\tinbound_region.bar = SRAM_BAR_ID;\n\tinbound_region.addr = SRAM_BASE_ADDR;\n\trc = hl_pci_set_inbound_region(hdev, 0, &inbound_region);\n\tif (rc)\n\t\tgoto done;\n\n\t/* Inbound Region 1 - Bar 2 - Point to SPI FLASH */\n\tinbound_region.mode = PCI_BAR_MATCH_MODE;\n\tinbound_region.bar = CFG_BAR_ID;\n\tinbound_region.addr = SPI_FLASH_BASE_ADDR;\n\trc = hl_pci_set_inbound_region(hdev, 1, &inbound_region);\n\tif (rc)\n\t\tgoto done;\n\n\t/* Inbound Region 2 - Bar 4 - Point to HBM */\n\tinbound_region.mode = PCI_BAR_MATCH_MODE;\n\tinbound_region.bar = HBM_BAR_ID;\n\tinbound_region.addr = DRAM_PHYS_BASE;\n\trc = hl_pci_set_inbound_region(hdev, 2, &inbound_region);\n\tif (rc)\n\t\tgoto done;\n\n\thdev->asic_funcs->set_dma_mask_from_fw(hdev);\n\n\t/* Outbound Region 0 - Point to Host */\n\toutbound_region.addr = HOST_PHYS_BASE;\n\toutbound_region.size = HOST_PHYS_SIZE;\n\trc = hl_pci_set_outbound_region(hdev, &outbound_region);\n\ndone:\n\treturn rc;\n}\n\nstatic enum hl_device_hw_state gaudi_get_hw_state(struct hl_device *hdev)\n{\n\treturn RREG32(mmHW_STATE);\n}\n\nstatic int gaudi_early_init(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct pci_dev *pdev = hdev->pdev;\n\tint rc;\n\n\trc = gaudi_get_fixed_properties(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to get fixed properties\\n\");\n\t\treturn rc;\n\t}\n\n\t/* Check BAR sizes */\n\tif (pci_resource_len(pdev, SRAM_BAR_ID) != SRAM_BAR_SIZE) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Not \" HL_NAME \"? BAR %d size %llu, expecting %llu\\n\",\n\t\t\tSRAM_BAR_ID,\n\t\t\t(unsigned long long) pci_resource_len(pdev,\n\t\t\t\t\t\t\tSRAM_BAR_ID),\n\t\t\tSRAM_BAR_SIZE);\n\t\trc = -ENODEV;\n\t\tgoto free_queue_props;\n\t}\n\n\tif (pci_resource_len(pdev, CFG_BAR_ID) != CFG_BAR_SIZE) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Not \" HL_NAME \"? BAR %d size %llu, expecting %llu\\n\",\n\t\t\tCFG_BAR_ID,\n\t\t\t(unsigned long long) pci_resource_len(pdev,\n\t\t\t\t\t\t\t\tCFG_BAR_ID),\n\t\t\tCFG_BAR_SIZE);\n\t\trc = -ENODEV;\n\t\tgoto free_queue_props;\n\t}\n\n\tprop->dram_pci_bar_size = pci_resource_len(pdev, HBM_BAR_ID);\n\n\trc = hl_pci_init(hdev);\n\tif (rc)\n\t\tgoto free_queue_props;\n\n\t/* Before continuing in the initialization, we need to read the preboot\n\t * version to determine whether we run with a security-enabled firmware\n\t */\n\trc = hl_fw_read_preboot_status(hdev, mmPSOC_GLOBAL_CONF_CPU_BOOT_STATUS,\n\t\t\tmmCPU_BOOT_DEV_STS0, mmCPU_BOOT_ERR0,\n\t\t\tGAUDI_BOOT_FIT_REQ_TIMEOUT_USEC);\n\tif (rc) {\n\t\tif (hdev->reset_on_preboot_fail)\n\t\t\thdev->asic_funcs->hw_fini(hdev, true);\n\t\tgoto pci_fini;\n\t}\n\n\tif (gaudi_get_hw_state(hdev) == HL_DEVICE_HW_STATE_DIRTY) {\n\t\tdev_info(hdev->dev,\n\t\t\t\"H/W state is dirty, must reset before initializing\\n\");\n\t\thdev->asic_funcs->hw_fini(hdev, true);\n\t}\n\n\treturn 0;\n\npci_fini:\n\thl_pci_fini(hdev);\nfree_queue_props:\n\tkfree(hdev->asic_prop.hw_queues_props);\n\treturn rc;\n}\n\nstatic int gaudi_early_fini(struct hl_device *hdev)\n{\n\tkfree(hdev->asic_prop.hw_queues_props);\n\thl_pci_fini(hdev);\n\n\treturn 0;\n}\n\n/**\n * gaudi_fetch_psoc_frequency - Fetch PSOC frequency values\n *\n * @hdev: pointer to hl_device structure\n *\n */\nstatic int gaudi_fetch_psoc_frequency(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu32 nr = 0, nf = 0, od = 0, div_fctr = 0, pll_clk, div_sel;\n\tu16 pll_freq_arr[HL_PLL_NUM_OUTPUTS], freq;\n\tint rc;\n\n\tif (hdev->asic_prop.fw_security_disabled) {\n\t\t/* Backward compatibility */\n\t\tdiv_fctr = RREG32(mmPSOC_CPU_PLL_DIV_FACTOR_2);\n\t\tdiv_sel = RREG32(mmPSOC_CPU_PLL_DIV_SEL_2);\n\t\tnr = RREG32(mmPSOC_CPU_PLL_NR);\n\t\tnf = RREG32(mmPSOC_CPU_PLL_NF);\n\t\tod = RREG32(mmPSOC_CPU_PLL_OD);\n\n\t\tif (div_sel == DIV_SEL_REF_CLK ||\n\t\t\t\tdiv_sel == DIV_SEL_DIVIDED_REF) {\n\t\t\tif (div_sel == DIV_SEL_REF_CLK)\n\t\t\t\tfreq = PLL_REF_CLK;\n\t\t\telse\n\t\t\t\tfreq = PLL_REF_CLK / (div_fctr + 1);\n\t\t} else if (div_sel == DIV_SEL_PLL_CLK ||\n\t\t\tdiv_sel == DIV_SEL_DIVIDED_PLL) {\n\t\t\tpll_clk = PLL_REF_CLK * (nf + 1) /\n\t\t\t\t\t((nr + 1) * (od + 1));\n\t\t\tif (div_sel == DIV_SEL_PLL_CLK)\n\t\t\t\tfreq = pll_clk;\n\t\t\telse\n\t\t\t\tfreq = pll_clk / (div_fctr + 1);\n\t\t} else {\n\t\t\tdev_warn(hdev->dev,\n\t\t\t\t\"Received invalid div select value: %d\",\n\t\t\t\tdiv_sel);\n\t\t\tfreq = 0;\n\t\t}\n\t} else {\n\t\trc = hl_fw_cpucp_pll_info_get(hdev, CPU_PLL, pll_freq_arr);\n\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tfreq = pll_freq_arr[2];\n\t}\n\n\tprop->psoc_timestamp_frequency = freq;\n\tprop->psoc_pci_pll_nr = nr;\n\tprop->psoc_pci_pll_nf = nf;\n\tprop->psoc_pci_pll_od = od;\n\tprop->psoc_pci_pll_div_factor = div_fctr;\n\n\treturn 0;\n}\n\nstatic int _gaudi_init_tpc_mem(struct hl_device *hdev,\n\t\tdma_addr_t tpc_kernel_src_addr, u32 tpc_kernel_size)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct packet_lin_dma *init_tpc_mem_pkt;\n\tstruct hl_cs_job *job;\n\tstruct hl_cb *cb;\n\tu64 dst_addr;\n\tu32 cb_size, ctl;\n\tu8 tpc_id;\n\tint rc;\n\n\tcb = hl_cb_kernel_create(hdev, PAGE_SIZE, false);\n\tif (!cb)\n\t\treturn -EFAULT;\n\n\tinit_tpc_mem_pkt = cb->kernel_address;\n\tcb_size = sizeof(*init_tpc_mem_pkt);\n\tmemset(init_tpc_mem_pkt, 0, cb_size);\n\n\tinit_tpc_mem_pkt->tsize = cpu_to_le32(tpc_kernel_size);\n\n\tctl = FIELD_PREP(GAUDI_PKT_CTL_OPCODE_MASK, PACKET_LIN_DMA);\n\tctl |= FIELD_PREP(GAUDI_PKT_LIN_DMA_CTL_LIN_MASK, 1);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_RB_MASK, 1);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_MB_MASK, 1);\n\n\tinit_tpc_mem_pkt->ctl = cpu_to_le32(ctl);\n\n\tinit_tpc_mem_pkt->src_addr = cpu_to_le64(tpc_kernel_src_addr);\n\tdst_addr = (prop->sram_user_base_address &\n\t\t\tGAUDI_PKT_LIN_DMA_DST_ADDR_MASK) >>\n\t\t\tGAUDI_PKT_LIN_DMA_DST_ADDR_SHIFT;\n\tinit_tpc_mem_pkt->dst_addr |= cpu_to_le64(dst_addr);\n\n\tjob = hl_cs_allocate_job(hdev, QUEUE_TYPE_EXT, true);\n\tif (!job) {\n\t\tdev_err(hdev->dev, \"Failed to allocate a new job\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto release_cb;\n\t}\n\n\tjob->id = 0;\n\tjob->user_cb = cb;\n\tatomic_inc(&job->user_cb->cs_cnt);\n\tjob->user_cb_size = cb_size;\n\tjob->hw_queue_id = GAUDI_QUEUE_ID_DMA_0_0;\n\tjob->patched_cb = job->user_cb;\n\tjob->job_cb_size = job->user_cb_size + sizeof(struct packet_msg_prot);\n\n\thl_debugfs_add_job(hdev, job);\n\n\trc = gaudi_send_job_on_qman0(hdev, job);\n\n\tif (rc)\n\t\tgoto free_job;\n\n\tfor (tpc_id = 0 ; tpc_id < TPC_NUMBER_OF_ENGINES ; tpc_id++) {\n\t\trc = gaudi_run_tpc_kernel(hdev, dst_addr, tpc_id);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\nfree_job:\n\thl_userptr_delete_list(hdev, &job->userptr_list);\n\thl_debugfs_remove_job(hdev, job);\n\tkfree(job);\n\tatomic_dec(&cb->cs_cnt);\n\nrelease_cb:\n\thl_cb_put(cb);\n\thl_cb_destroy(hdev, &hdev->kernel_cb_mgr, cb->id << PAGE_SHIFT);\n\n\treturn rc;\n}\n\n/*\n * gaudi_init_tpc_mem() - Initialize TPC memories.\n * @hdev: Pointer to hl_device structure.\n *\n * Copy TPC kernel fw from firmware file and run it to initialize TPC memories.\n *\n * Return: 0 for success, negative value for error.\n */\nstatic int gaudi_init_tpc_mem(struct hl_device *hdev)\n{\n\tconst struct firmware *fw;\n\tsize_t fw_size;\n\tvoid *cpu_addr;\n\tdma_addr_t dma_handle;\n\tint rc, count = 5;\n\nagain:\n\trc = request_firmware(&fw, GAUDI_TPC_FW_FILE, hdev->dev);\n\tif (rc == -EINTR && count-- > 0) {\n\t\tmsleep(50);\n\t\tgoto again;\n\t}\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to load firmware file %s\\n\",\n\t\t\t\tGAUDI_TPC_FW_FILE);\n\t\tgoto out;\n\t}\n\n\tfw_size = fw->size;\n\tcpu_addr = hdev->asic_funcs->asic_dma_alloc_coherent(hdev, fw_size,\n\t\t\t&dma_handle, GFP_KERNEL | __GFP_ZERO);\n\tif (!cpu_addr) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate %zu of dma memory for TPC kernel\\n\",\n\t\t\tfw_size);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(cpu_addr, fw->data, fw_size);\n\n\trc = _gaudi_init_tpc_mem(hdev, dma_handle, fw_size);\n\n\thdev->asic_funcs->asic_dma_free_coherent(hdev, fw->size, cpu_addr,\n\t\t\tdma_handle);\n\nout:\n\trelease_firmware(fw);\n\treturn rc;\n}\n\nstatic void gaudi_collective_map_sobs(struct hl_device *hdev, u32 stream)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tstruct gaudi_collective_properties *prop = &gaudi->collective_props;\n\tstruct hl_hw_queue *q;\n\tu32 i, sob_id, sob_group_id, queue_id;\n\n\t/* Iterate through SOB groups and assign a SOB for each slave queue */\n\tsob_group_id =\n\t\tstream * HL_RSVD_SOBS + prop->curr_sob_group_idx[stream];\n\tsob_id = prop->hw_sob_group[sob_group_id].base_sob_id;\n\n\tqueue_id = GAUDI_QUEUE_ID_NIC_0_0 + stream;\n\tfor (i = 0 ; i < NIC_NUMBER_OF_ENGINES ; i++) {\n\t\tq = &hdev->kernel_queues[queue_id + (4 * i)];\n\t\tq->sync_stream_prop.collective_sob_id = sob_id + i;\n\t}\n\n\t/* Both DMA5 and TPC7 use the same resources since only a single\n\t * engine need to participate in the reduction process\n\t */\n\tqueue_id = GAUDI_QUEUE_ID_DMA_5_0 + stream;\n\tq = &hdev->kernel_queues[queue_id];\n\tq->sync_stream_prop.collective_sob_id =\n\t\t\tsob_id + NIC_NUMBER_OF_ENGINES;\n\n\tqueue_id = GAUDI_QUEUE_ID_TPC_7_0 + stream;\n\tq = &hdev->kernel_queues[queue_id];\n\tq->sync_stream_prop.collective_sob_id =\n\t\t\tsob_id + NIC_NUMBER_OF_ENGINES;\n}\n\nstatic void gaudi_sob_group_hw_reset(struct kref *ref)\n{\n\tstruct gaudi_hw_sob_group *hw_sob_group =\n\t\tcontainer_of(ref, struct gaudi_hw_sob_group, kref);\n\tstruct hl_device *hdev = hw_sob_group->hdev;\n\tu64 base_addr;\n\tint rc;\n\n\tbase_addr = CFG_BASE + mmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_SOB_OBJ_0 +\n\t\t\thw_sob_group->base_sob_id * 4;\n\trc = gaudi_schedule_register_memset(hdev, hw_sob_group->queue_id,\n\t\t\tbase_addr, NUMBER_OF_SOBS_IN_GRP, 0);\n\tif (rc)\n\t\tdev_err(hdev->dev,\n\t\t\t\"failed resetting sob group - sob base %u, count %u\",\n\t\t\thw_sob_group->base_sob_id, NUMBER_OF_SOBS_IN_GRP);\n\n\tkref_init(&hw_sob_group->kref);\n}\n\nstatic void gaudi_sob_group_reset_error(struct kref *ref)\n{\n\tstruct gaudi_hw_sob_group *hw_sob_group =\n\t\tcontainer_of(ref, struct gaudi_hw_sob_group, kref);\n\tstruct hl_device *hdev = hw_sob_group->hdev;\n\n\tdev_crit(hdev->dev,\n\t\t\"SOB release shouldn't be called here, base_sob_id: %d\\n\",\n\t\thw_sob_group->base_sob_id);\n}\n\nstatic int gaudi_collective_init(struct hl_device *hdev)\n{\n\tu32 i, master_monitor_sobs, sob_id, reserved_sobs_per_group;\n\tstruct gaudi_collective_properties *prop;\n\tstruct gaudi_device *gaudi;\n\n\tgaudi = hdev->asic_specific;\n\tprop = &gaudi->collective_props;\n\tsob_id = hdev->asic_prop.collective_first_sob;\n\n\t/* First sob in group must be aligned to HL_MAX_SOBS_PER_MONITOR */\n\treserved_sobs_per_group =\n\t\tALIGN(NUMBER_OF_SOBS_IN_GRP, HL_MAX_SOBS_PER_MONITOR);\n\n\t/* Init SOB groups */\n\tfor (i = 0 ; i < NUM_SOB_GROUPS; i++) {\n\t\tprop->hw_sob_group[i].hdev = hdev;\n\t\tprop->hw_sob_group[i].base_sob_id = sob_id;\n\t\tsob_id += reserved_sobs_per_group;\n\t\tgaudi_sob_group_hw_reset(&prop->hw_sob_group[i].kref);\n\t}\n\n\tfor (i = 0 ; i < QMAN_STREAMS; i++) {\n\t\tprop->next_sob_group_val[i] = 1;\n\t\tprop->curr_sob_group_idx[i] = 0;\n\t\tgaudi_collective_map_sobs(hdev, i);\n\t}\n\n\tprop->mstr_sob_mask[0] = 0;\n\tmaster_monitor_sobs = HL_MAX_SOBS_PER_MONITOR;\n\tfor (i = 0 ; i < master_monitor_sobs ; i++)\n\t\tif (gaudi->hw_cap_initialized & BIT(HW_CAP_NIC_SHIFT + i))\n\t\t\tprop->mstr_sob_mask[0] |= BIT(i);\n\n\tprop->mstr_sob_mask[1] = 0;\n\tmaster_monitor_sobs =\n\t\tNIC_NUMBER_OF_ENGINES - HL_MAX_SOBS_PER_MONITOR;\n\tfor (i = 0 ; i < master_monitor_sobs; i++) {\n\t\tif (gaudi->hw_cap_initialized & BIT(HW_CAP_NIC_SHIFT + i))\n\t\t\tprop->mstr_sob_mask[1] |= BIT(i);\n\t}\n\n\t/* Set collective engine bit */\n\tprop->mstr_sob_mask[1] |= BIT(i);\n\n\treturn 0;\n}\n\nstatic void gaudi_reset_sob_group(struct hl_device *hdev, u16 sob_group)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tstruct gaudi_collective_properties *cprop = &gaudi->collective_props;\n\n\tkref_put(&cprop->hw_sob_group[sob_group].kref,\n\t\t\t\t\tgaudi_sob_group_hw_reset);\n}\n\nstatic void gaudi_collective_master_init_job(struct hl_device *hdev,\n\t\tstruct hl_cs_job *job, u32 stream, u32 sob_group_offset)\n{\n\tu32 master_sob_base, master_monitor, queue_id, cb_size = 0;\n\tstruct gaudi_collective_properties *cprop;\n\tstruct hl_gen_wait_properties wait_prop;\n\tstruct hl_sync_stream_properties *prop;\n\tstruct gaudi_device *gaudi;\n\n\tgaudi = hdev->asic_specific;\n\tcprop = &gaudi->collective_props;\n\tqueue_id = job->hw_queue_id;\n\tprop = &hdev->kernel_queues[queue_id].sync_stream_prop;\n\n\tmaster_sob_base =\n\t\tcprop->hw_sob_group[sob_group_offset].base_sob_id;\n\tmaster_monitor = prop->collective_mstr_mon_id[0];\n\n\tcprop->hw_sob_group[sob_group_offset].queue_id = queue_id;\n\n\tdev_dbg(hdev->dev,\n\t\t\"Generate master wait CBs, sob %d (mask %#x), val:0x%x, mon %u, q %d\\n\",\n\t\tmaster_sob_base, cprop->mstr_sob_mask[0],\n\t\tcprop->next_sob_group_val[stream],\n\t\tmaster_monitor, queue_id);\n\n\twait_prop.data = (void *) job->patched_cb;\n\twait_prop.sob_base = master_sob_base;\n\twait_prop.sob_mask = cprop->mstr_sob_mask[0];\n\twait_prop.sob_val = cprop->next_sob_group_val[stream];\n\twait_prop.mon_id = master_monitor;\n\twait_prop.q_idx = queue_id;\n\twait_prop.size = cb_size;\n\tcb_size += gaudi_gen_wait_cb(hdev, &wait_prop);\n\n\tmaster_sob_base += HL_MAX_SOBS_PER_MONITOR;\n\tmaster_monitor = prop->collective_mstr_mon_id[1];\n\n\tdev_dbg(hdev->dev,\n\t\t\"Generate master wait CBs, sob %d (mask %#x), val:0x%x, mon %u, q %d\\n\",\n\t\tmaster_sob_base, cprop->mstr_sob_mask[1],\n\t\tcprop->next_sob_group_val[stream],\n\t\tmaster_monitor, queue_id);\n\n\twait_prop.sob_base = master_sob_base;\n\twait_prop.sob_mask = cprop->mstr_sob_mask[1];\n\twait_prop.mon_id = master_monitor;\n\twait_prop.size = cb_size;\n\tcb_size += gaudi_gen_wait_cb(hdev, &wait_prop);\n}\n\nstatic void gaudi_collective_slave_init_job(struct hl_device *hdev,\n\t\tstruct hl_cs_job *job, struct hl_cs_compl *cs_cmpl)\n{\n\tstruct hl_gen_wait_properties wait_prop;\n\tstruct hl_sync_stream_properties *prop;\n\tu32 queue_id, cb_size = 0;\n\n\tqueue_id = job->hw_queue_id;\n\tprop = &hdev->kernel_queues[queue_id].sync_stream_prop;\n\n\t/* Add to wait CBs using slave monitor */\n\twait_prop.data = (void *) job->user_cb;\n\twait_prop.sob_base = cs_cmpl->hw_sob->sob_id;\n\twait_prop.sob_mask = 0x1;\n\twait_prop.sob_val = cs_cmpl->sob_val;\n\twait_prop.mon_id = prop->collective_slave_mon_id;\n\twait_prop.q_idx = queue_id;\n\twait_prop.size = cb_size;\n\n\tdev_dbg(hdev->dev,\n\t\t\"Generate slave wait CB, sob %d, val:0x%x, mon %d, q %d\\n\",\n\t\tcs_cmpl->hw_sob->sob_id, cs_cmpl->sob_val,\n\t\tprop->collective_slave_mon_id, queue_id);\n\n\tcb_size += gaudi_gen_wait_cb(hdev, &wait_prop);\n\n\tdev_dbg(hdev->dev,\n\t\t\"generate signal CB, sob_id: %d, sob val: 1, q_idx: %d\\n\",\n\t\tprop->collective_sob_id, queue_id);\n\n\tcb_size += gaudi_gen_signal_cb(hdev, job->user_cb,\n\t\t\tprop->collective_sob_id, cb_size, false);\n}\n\nstatic void gaudi_collective_wait_init_cs(struct hl_cs *cs)\n{\n\tstruct hl_cs_compl *signal_cs_cmpl =\n\t\tcontainer_of(cs->signal_fence, struct hl_cs_compl, base_fence);\n\tstruct hl_cs_compl *cs_cmpl =\n\t\tcontainer_of(cs->fence, struct hl_cs_compl, base_fence);\n\tstruct gaudi_collective_properties *cprop;\n\tu32 stream, queue_id, sob_group_offset;\n\tstruct gaudi_device *gaudi;\n\tstruct hl_device *hdev;\n\tstruct hl_cs_job *job;\n\tstruct hl_ctx *ctx;\n\n\tctx = cs->ctx;\n\thdev = ctx->hdev;\n\tgaudi = hdev->asic_specific;\n\tcprop = &gaudi->collective_props;\n\n\t/* copy the SOB id and value of the signal CS */\n\tcs_cmpl->hw_sob = signal_cs_cmpl->hw_sob;\n\tcs_cmpl->sob_val = signal_cs_cmpl->sob_val;\n\n\t/* Calculate the stream from collective master queue (1st job) */\n\tjob = list_first_entry(&cs->job_list, struct hl_cs_job, cs_node);\n\tstream = job->hw_queue_id % 4;\n\tsob_group_offset =\n\t\tstream * HL_RSVD_SOBS + cprop->curr_sob_group_idx[stream];\n\n\tlist_for_each_entry(job, &cs->job_list, cs_node) {\n\t\tqueue_id = job->hw_queue_id;\n\n\t\tif (hdev->kernel_queues[queue_id].collective_mode ==\n\t\t\t\tHL_COLLECTIVE_MASTER)\n\t\t\tgaudi_collective_master_init_job(hdev, job, stream,\n\t\t\t\t\t\tsob_group_offset);\n\t\telse\n\t\t\tgaudi_collective_slave_init_job(hdev, job, cs_cmpl);\n\t}\n\n\tcs_cmpl->sob_group = sob_group_offset;\n\n\t/* Handle sob group kref and wraparound */\n\tkref_get(&cprop->hw_sob_group[sob_group_offset].kref);\n\tcprop->next_sob_group_val[stream]++;\n\n\tif (cprop->next_sob_group_val[stream] == HL_MAX_SOB_VAL) {\n\t\t/*\n\t\t * Decrement as we reached the max value.\n\t\t * The release function won't be called here as we've\n\t\t * just incremented the refcount.\n\t\t */\n\t\tkref_put(&cprop->hw_sob_group[sob_group_offset].kref,\n\t\t\t\tgaudi_sob_group_reset_error);\n\t\tcprop->next_sob_group_val[stream] = 1;\n\t\t/* only two SOBs are currently in use */\n\t\tcprop->curr_sob_group_idx[stream] =\n\t\t\t(cprop->curr_sob_group_idx[stream] + 1) &\n\t\t\t\t\t\t\t(HL_RSVD_SOBS - 1);\n\n\t\tgaudi_collective_map_sobs(hdev, stream);\n\n\t\tdev_dbg(hdev->dev, \"switched to SOB group %d, stream: %d\\n\",\n\t\t\t\tcprop->curr_sob_group_idx[stream], stream);\n\t}\n\n\t/* Increment kref since all slave queues are now waiting on it */\n\tkref_get(&cs_cmpl->hw_sob->kref);\n\t/*\n\t * Must put the signal fence after the SOB refcnt increment so\n\t * the SOB refcnt won't turn 0 and reset the SOB before the\n\t * wait CS was submitted.\n\t */\n\tmb();\n\thl_fence_put(cs->signal_fence);\n\tcs->signal_fence = NULL;\n}\n\nstatic int gaudi_collective_wait_create_job(struct hl_device *hdev,\n\t\tstruct hl_ctx *ctx, struct hl_cs *cs,\n\t\tenum hl_collective_mode mode, u32 queue_id, u32 wait_queue_id)\n{\n\tstruct hw_queue_properties *hw_queue_prop;\n\tstruct hl_cs_counters_atomic *cntr;\n\tstruct hl_cs_job *job;\n\tstruct hl_cb *cb;\n\tu32 cb_size;\n\tbool patched_cb;\n\n\tcntr = &hdev->aggregated_cs_counters;\n\n\tif (mode == HL_COLLECTIVE_MASTER) {\n\t\t/* CB size of collective master queue contains\n\t\t * 4 msg short packets for monitor 1 configuration\n\t\t * 1 fence packet\n\t\t * 4 msg short packets for monitor 2 configuration\n\t\t * 1 fence packet\n\t\t * 2 msg prot packets for completion and MSI-X\n\t\t */\n\t\tcb_size = sizeof(struct packet_msg_short) * 8 +\n\t\t\t\tsizeof(struct packet_fence) * 2 +\n\t\t\t\tsizeof(struct packet_msg_prot) * 2;\n\t\tpatched_cb = true;\n\t} else {\n\t\t/* CB size of collective slave queues contains\n\t\t * 4 msg short packets for monitor configuration\n\t\t * 1 fence packet\n\t\t * 1 additional msg short packet for sob signal\n\t\t */\n\t\tcb_size = sizeof(struct packet_msg_short) * 5 +\n\t\t\t\tsizeof(struct packet_fence);\n\t\tpatched_cb = false;\n\t}\n\n\thw_queue_prop = &hdev->asic_prop.hw_queues_props[queue_id];\n\tjob = hl_cs_allocate_job(hdev, hw_queue_prop->type, true);\n\tif (!job) {\n\t\tatomic64_inc(&ctx->cs_counters.out_of_mem_drop_cnt);\n\t\tatomic64_inc(&cntr->out_of_mem_drop_cnt);\n\t\tdev_err(hdev->dev, \"Failed to allocate a new job\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Allocate internal mapped CB for non patched CBs */\n\tcb = hl_cb_kernel_create(hdev, cb_size,\n\t\t\thdev->mmu_enable && !patched_cb);\n\tif (!cb) {\n\t\tatomic64_inc(&ctx->cs_counters.out_of_mem_drop_cnt);\n\t\tatomic64_inc(&cntr->out_of_mem_drop_cnt);\n\t\tkfree(job);\n\t\treturn -EFAULT;\n\t}\n\n\tjob->id = 0;\n\tjob->cs = cs;\n\tjob->user_cb = cb;\n\tatomic_inc(&job->user_cb->cs_cnt);\n\tjob->user_cb_size = cb_size;\n\tjob->hw_queue_id = queue_id;\n\n\t/*\n\t * No need in parsing, user CB is the patched CB.\n\t * We call hl_cb_destroy() out of two reasons - we don't need\n\t * the CB in the CB idr anymore and to decrement its refcount as\n\t * it was incremented inside hl_cb_kernel_create().\n\t */\n\tif (patched_cb)\n\t\tjob->patched_cb = job->user_cb;\n\telse\n\t\tjob->patched_cb = NULL;\n\n\tjob->job_cb_size = job->user_cb_size;\n\thl_cb_destroy(hdev, &hdev->kernel_cb_mgr, cb->id << PAGE_SHIFT);\n\n\t/* increment refcount as for external queues we get completion */\n\tif (hw_queue_prop->type == QUEUE_TYPE_EXT)\n\t\tcs_get(cs);\n\n\tcs->jobs_in_queue_cnt[job->hw_queue_id]++;\n\n\tlist_add_tail(&job->cs_node, &cs->job_list);\n\n\thl_debugfs_add_job(hdev, job);\n\n\treturn 0;\n}\n\nstatic int gaudi_collective_wait_create_jobs(struct hl_device *hdev,\n\t\tstruct hl_ctx *ctx, struct hl_cs *cs, u32 wait_queue_id,\n\t\tu32 collective_engine_id)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tstruct hw_queue_properties *hw_queue_prop;\n\tu32 queue_id, collective_queue, num_jobs;\n\tu32 stream, nic_queue, nic_idx = 0;\n\tbool skip;\n\tint i, rc = 0;\n\n\t/* Verify wait queue id is configured as master */\n\thw_queue_prop = &hdev->asic_prop.hw_queues_props[wait_queue_id];\n\tif (!(hw_queue_prop->collective_mode == HL_COLLECTIVE_MASTER)) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Queue %d is not configured as collective master\\n\",\n\t\t\twait_queue_id);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Verify engine id is supported */\n\tif (collective_engine_id != GAUDI_ENGINE_ID_DMA_5 &&\n\t\t\tcollective_engine_id != GAUDI_ENGINE_ID_TPC_7) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Collective wait does not support engine %u\\n\",\n\t\t\tcollective_engine_id);\n\t\treturn -EINVAL;\n\t}\n\n\tstream = wait_queue_id % 4;\n\n\tif (collective_engine_id == GAUDI_ENGINE_ID_DMA_5)\n\t\tcollective_queue = GAUDI_QUEUE_ID_DMA_5_0 + stream;\n\telse\n\t\tcollective_queue = GAUDI_QUEUE_ID_TPC_7_0 + stream;\n\n\tnum_jobs = NUMBER_OF_SOBS_IN_GRP + 1;\n\tnic_queue = GAUDI_QUEUE_ID_NIC_0_0 + stream;\n\n\t/* First job goes to the collective master queue, it will wait for\n\t * the collective slave queues to finish execution.\n\t * The synchronization is done using two monitors:\n\t * First monitor for NICs 0-7, second monitor for NICs 8-9 and the\n\t * reduction engine (DMA5/TPC7).\n\t *\n\t * Rest of the jobs goes to the collective slave queues which will\n\t * all wait for the user to signal sob 'cs_cmpl->sob_val'.\n\t */\n\tfor (i = 0 ; i < num_jobs ; i++) {\n\t\tif (i == 0) {\n\t\t\tqueue_id = wait_queue_id;\n\t\t\trc = gaudi_collective_wait_create_job(hdev, ctx, cs,\n\t\t\t\tHL_COLLECTIVE_MASTER, queue_id, wait_queue_id);\n\t\t} else {\n\t\t\tif (nic_idx < NIC_NUMBER_OF_ENGINES) {\n\t\t\t\tif (gaudi->hw_cap_initialized &\n\t\t\t\t\tBIT(HW_CAP_NIC_SHIFT + nic_idx))\n\t\t\t\t\tskip = false;\n\t\t\t\telse\n\t\t\t\t\tskip = true;\n\n\t\t\t\tqueue_id = nic_queue;\n\t\t\t\tnic_queue += 4;\n\t\t\t\tnic_idx++;\n\n\t\t\t\tif (skip)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tqueue_id = collective_queue;\n\t\t\t}\n\n\t\t\trc = gaudi_collective_wait_create_job(hdev, ctx, cs,\n\t\t\t\tHL_COLLECTIVE_SLAVE, queue_id, wait_queue_id);\n\t\t}\n\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn rc;\n}\n\nstatic int gaudi_late_init(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tint rc;\n\n\trc = gaudi->cpucp_info_get(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to get cpucp info\\n\");\n\t\treturn rc;\n\t}\n\n\tif ((hdev->card_type == cpucp_card_type_pci) &&\n\t\t\t(hdev->nic_ports_mask & 0x3)) {\n\t\tdev_info(hdev->dev,\n\t\t\t\"PCI card detected, only 8 ports are enabled\\n\");\n\t\thdev->nic_ports_mask &= ~0x3;\n\n\t\t/* Stop and disable unused NIC QMANs */\n\t\tWREG32(mmNIC0_QM0_GLBL_CFG1, NIC0_QM0_GLBL_CFG1_PQF_STOP_MASK |\n\t\t\t\t\tNIC0_QM0_GLBL_CFG1_CQF_STOP_MASK |\n\t\t\t\t\tNIC0_QM0_GLBL_CFG1_CP_STOP_MASK);\n\n\t\tWREG32(mmNIC0_QM1_GLBL_CFG1, NIC0_QM0_GLBL_CFG1_PQF_STOP_MASK |\n\t\t\t\t\tNIC0_QM0_GLBL_CFG1_CQF_STOP_MASK |\n\t\t\t\t\tNIC0_QM0_GLBL_CFG1_CP_STOP_MASK);\n\n\t\tWREG32(mmNIC0_QM0_GLBL_CFG0, 0);\n\t\tWREG32(mmNIC0_QM1_GLBL_CFG0, 0);\n\n\t\tgaudi->hw_cap_initialized &= ~(HW_CAP_NIC0 | HW_CAP_NIC1);\n\t}\n\n\trc = hl_fw_send_pci_access_msg(hdev, CPUCP_PACKET_ENABLE_PCI_ACCESS);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to enable PCI access from CPU\\n\");\n\t\treturn rc;\n\t}\n\n\trc = gaudi_fetch_psoc_frequency(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to fetch psoc frequency\\n\");\n\t\tgoto disable_pci_access;\n\t}\n\n\trc = gaudi_mmu_clear_pgt_range(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to clear MMU page tables range\\n\");\n\t\tgoto disable_pci_access;\n\t}\n\n\trc = gaudi_init_tpc_mem(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to initialize TPC memories\\n\");\n\t\tgoto disable_pci_access;\n\t}\n\n\trc = gaudi_collective_init(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to init collective\\n\");\n\t\tgoto disable_pci_access;\n\t}\n\n\treturn 0;\n\ndisable_pci_access:\n\thl_fw_send_pci_access_msg(hdev, CPUCP_PACKET_DISABLE_PCI_ACCESS);\n\n\treturn rc;\n}\n\nstatic void gaudi_late_fini(struct hl_device *hdev)\n{\n\tconst struct hwmon_channel_info **channel_info_arr;\n\tint i = 0;\n\n\tif (!hdev->hl_chip_info->info)\n\t\treturn;\n\n\tchannel_info_arr = hdev->hl_chip_info->info;\n\n\twhile (channel_info_arr[i]) {\n\t\tkfree(channel_info_arr[i]->config);\n\t\tkfree(channel_info_arr[i]);\n\t\ti++;\n\t}\n\n\tkfree(channel_info_arr);\n\n\thdev->hl_chip_info->info = NULL;\n}\n\nstatic int gaudi_alloc_cpu_accessible_dma_mem(struct hl_device *hdev)\n{\n\tdma_addr_t dma_addr_arr[GAUDI_ALLOC_CPU_MEM_RETRY_CNT] = {}, end_addr;\n\tvoid *virt_addr_arr[GAUDI_ALLOC_CPU_MEM_RETRY_CNT] = {};\n\tint i, j, rc = 0;\n\n\t/*\n\t * The device CPU works with 40-bits addresses, while bit 39 must be set\n\t * to '1' when accessing the host.\n\t * Bits 49:39 of the full host address are saved for a later\n\t * configuration of the HW to perform extension to 50 bits.\n\t * Because there is a single HW register that holds the extension bits,\n\t * these bits must be identical in all allocated range.\n\t */\n\n\tfor (i = 0 ; i < GAUDI_ALLOC_CPU_MEM_RETRY_CNT ; i++) {\n\t\tvirt_addr_arr[i] =\n\t\t\thdev->asic_funcs->asic_dma_alloc_coherent(hdev,\n\t\t\t\t\t\tHL_CPU_ACCESSIBLE_MEM_SIZE,\n\t\t\t\t\t\t&dma_addr_arr[i],\n\t\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\t\tif (!virt_addr_arr[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto free_dma_mem_arr;\n\t\t}\n\n\t\tend_addr = dma_addr_arr[i] + HL_CPU_ACCESSIBLE_MEM_SIZE - 1;\n\t\tif (GAUDI_CPU_PCI_MSB_ADDR(dma_addr_arr[i]) ==\n\t\t\t\tGAUDI_CPU_PCI_MSB_ADDR(end_addr))\n\t\t\tbreak;\n\t}\n\n\tif (i == GAUDI_ALLOC_CPU_MEM_RETRY_CNT) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"MSB of CPU accessible DMA memory are not identical in all range\\n\");\n\t\trc = -EFAULT;\n\t\tgoto free_dma_mem_arr;\n\t}\n\n\thdev->cpu_accessible_dma_mem = virt_addr_arr[i];\n\thdev->cpu_accessible_dma_address = dma_addr_arr[i];\n\thdev->cpu_pci_msb_addr =\n\t\tGAUDI_CPU_PCI_MSB_ADDR(hdev->cpu_accessible_dma_address);\n\n\tif (hdev->asic_prop.fw_security_disabled)\n\t\tGAUDI_PCI_TO_CPU_ADDR(hdev->cpu_accessible_dma_address);\n\nfree_dma_mem_arr:\n\tfor (j = 0 ; j < i ; j++)\n\t\thdev->asic_funcs->asic_dma_free_coherent(hdev,\n\t\t\t\t\t\tHL_CPU_ACCESSIBLE_MEM_SIZE,\n\t\t\t\t\t\tvirt_addr_arr[j],\n\t\t\t\t\t\tdma_addr_arr[j]);\n\n\treturn rc;\n}\n\nstatic void gaudi_free_internal_qmans_pq_mem(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tstruct gaudi_internal_qman_info *q;\n\tu32 i;\n\n\tfor (i = 0 ; i < GAUDI_QUEUE_ID_SIZE ; i++) {\n\t\tq = &gaudi->internal_qmans[i];\n\t\tif (!q->pq_kernel_addr)\n\t\t\tcontinue;\n\t\thdev->asic_funcs->asic_dma_free_coherent(hdev, q->pq_size,\n\t\t\t\t\t\t\tq->pq_kernel_addr,\n\t\t\t\t\t\t\tq->pq_dma_addr);\n\t}\n}\n\nstatic int gaudi_alloc_internal_qmans_pq_mem(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tstruct gaudi_internal_qman_info *q;\n\tint rc, i;\n\n\tfor (i = 0 ; i < GAUDI_QUEUE_ID_SIZE ; i++) {\n\t\tif (gaudi_queue_type[i] != QUEUE_TYPE_INT)\n\t\t\tcontinue;\n\n\t\tq = &gaudi->internal_qmans[i];\n\n\t\tswitch (i) {\n\t\tcase GAUDI_QUEUE_ID_DMA_2_0 ... GAUDI_QUEUE_ID_DMA_7_3:\n\t\t\tq->pq_size = HBM_DMA_QMAN_SIZE_IN_BYTES;\n\t\t\tbreak;\n\t\tcase GAUDI_QUEUE_ID_MME_0_0 ... GAUDI_QUEUE_ID_MME_1_3:\n\t\t\tq->pq_size = MME_QMAN_SIZE_IN_BYTES;\n\t\t\tbreak;\n\t\tcase GAUDI_QUEUE_ID_TPC_0_0 ... GAUDI_QUEUE_ID_TPC_7_3:\n\t\t\tq->pq_size = TPC_QMAN_SIZE_IN_BYTES;\n\t\t\tbreak;\n\t\tcase GAUDI_QUEUE_ID_NIC_0_0 ... GAUDI_QUEUE_ID_NIC_9_3:\n\t\t\tq->pq_size = NIC_QMAN_SIZE_IN_BYTES;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(hdev->dev, \"Bad internal queue index %d\", i);\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_internal_qmans_pq_mem;\n\t\t}\n\n\t\tq->pq_kernel_addr = hdev->asic_funcs->asic_dma_alloc_coherent(\n\t\t\t\t\t\thdev, q->pq_size,\n\t\t\t\t\t\t&q->pq_dma_addr,\n\t\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\t\tif (!q->pq_kernel_addr) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto free_internal_qmans_pq_mem;\n\t\t}\n\t}\n\n\treturn 0;\n\nfree_internal_qmans_pq_mem:\n\tgaudi_free_internal_qmans_pq_mem(hdev);\n\treturn rc;\n}\n\nstatic int gaudi_sw_init(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi;\n\tu32 i, event_id = 0;\n\tint rc;\n\n\t/* Allocate device structure */\n\tgaudi = kzalloc(sizeof(*gaudi), GFP_KERNEL);\n\tif (!gaudi)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0 ; i < ARRAY_SIZE(gaudi_irq_map_table) ; i++) {\n\t\tif (gaudi_irq_map_table[i].valid) {\n\t\t\tif (event_id == GAUDI_EVENT_SIZE) {\n\t\t\t\tdev_err(hdev->dev,\n\t\t\t\t\t\"Event array exceeds the limit of %u events\\n\",\n\t\t\t\t\tGAUDI_EVENT_SIZE);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto free_gaudi_device;\n\t\t\t}\n\n\t\t\tgaudi->events[event_id++] =\n\t\t\t\t\tgaudi_irq_map_table[i].fc_id;\n\t\t}\n\t}\n\n\tgaudi->cpucp_info_get = gaudi_cpucp_info_get;\n\n\tgaudi->max_freq_value = GAUDI_MAX_CLK_FREQ;\n\n\thdev->asic_specific = gaudi;\n\n\t/* Create DMA pool for small allocations */\n\thdev->dma_pool = dma_pool_create(dev_name(hdev->dev),\n\t\t\t&hdev->pdev->dev, GAUDI_DMA_POOL_BLK_SIZE, 8, 0);\n\tif (!hdev->dma_pool) {\n\t\tdev_err(hdev->dev, \"failed to create DMA pool\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto free_gaudi_device;\n\t}\n\n\trc = gaudi_alloc_cpu_accessible_dma_mem(hdev);\n\tif (rc)\n\t\tgoto free_dma_pool;\n\n\thdev->cpu_accessible_dma_pool = gen_pool_create(ilog2(32), -1);\n\tif (!hdev->cpu_accessible_dma_pool) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to create CPU accessible DMA pool\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto free_cpu_dma_mem;\n\t}\n\n\trc = gen_pool_add(hdev->cpu_accessible_dma_pool,\n\t\t\t\t(uintptr_t) hdev->cpu_accessible_dma_mem,\n\t\t\t\tHL_CPU_ACCESSIBLE_MEM_SIZE, -1);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to add memory to CPU accessible DMA pool\\n\");\n\t\trc = -EFAULT;\n\t\tgoto free_cpu_accessible_dma_pool;\n\t}\n\n\trc = gaudi_alloc_internal_qmans_pq_mem(hdev);\n\tif (rc)\n\t\tgoto free_cpu_accessible_dma_pool;\n\n\tspin_lock_init(&gaudi->hw_queues_lock);\n\tmutex_init(&gaudi->clk_gate_mutex);\n\n\thdev->supports_sync_stream = true;\n\thdev->supports_coresight = true;\n\thdev->supports_staged_submission = true;\n\n\treturn 0;\n\nfree_cpu_accessible_dma_pool:\n\tgen_pool_destroy(hdev->cpu_accessible_dma_pool);\nfree_cpu_dma_mem:\n\tif (hdev->asic_prop.fw_security_disabled)\n\t\tGAUDI_CPU_TO_PCI_ADDR(hdev->cpu_accessible_dma_address,\n\t\t\t\t\thdev->cpu_pci_msb_addr);\n\thdev->asic_funcs->asic_dma_free_coherent(hdev,\n\t\t\tHL_CPU_ACCESSIBLE_MEM_SIZE,\n\t\t\thdev->cpu_accessible_dma_mem,\n\t\t\thdev->cpu_accessible_dma_address);\nfree_dma_pool:\n\tdma_pool_destroy(hdev->dma_pool);\nfree_gaudi_device:\n\tkfree(gaudi);\n\treturn rc;\n}\n\nstatic int gaudi_sw_fini(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tgaudi_free_internal_qmans_pq_mem(hdev);\n\n\tgen_pool_destroy(hdev->cpu_accessible_dma_pool);\n\n\tif (hdev->asic_prop.fw_security_disabled)\n\t\tGAUDI_CPU_TO_PCI_ADDR(hdev->cpu_accessible_dma_address,\n\t\t\t\t\thdev->cpu_pci_msb_addr);\n\n\thdev->asic_funcs->asic_dma_free_coherent(hdev,\n\t\t\tHL_CPU_ACCESSIBLE_MEM_SIZE,\n\t\t\thdev->cpu_accessible_dma_mem,\n\t\t\thdev->cpu_accessible_dma_address);\n\n\tdma_pool_destroy(hdev->dma_pool);\n\n\tmutex_destroy(&gaudi->clk_gate_mutex);\n\n\tkfree(gaudi);\n\n\treturn 0;\n}\n\nstatic irqreturn_t gaudi_irq_handler_single(int irq, void *arg)\n{\n\tstruct hl_device *hdev = arg;\n\tint i;\n\n\tif (hdev->disabled)\n\t\treturn IRQ_HANDLED;\n\n\tfor (i = 0 ; i < hdev->asic_prop.completion_queues_count ; i++)\n\t\thl_irq_handler_cq(irq, &hdev->completion_queue[i]);\n\n\thl_irq_handler_eq(irq, &hdev->event_queue);\n\n\treturn IRQ_HANDLED;\n}\n\n/*\n * For backward compatibility, new MSI interrupts should be set after the\n * existing CPU and NIC interrupts.\n */\nstatic int gaudi_pci_irq_vector(struct hl_device *hdev, unsigned int nr,\n\t\t\t\tbool cpu_eq)\n{\n\tint msi_vec;\n\n\tif ((nr != GAUDI_EVENT_QUEUE_MSI_IDX) && (cpu_eq))\n\t\tdev_crit(hdev->dev, \"CPU EQ must use IRQ %d\\n\",\n\t\t\t\tGAUDI_EVENT_QUEUE_MSI_IDX);\n\n\tmsi_vec = ((nr < GAUDI_EVENT_QUEUE_MSI_IDX) || (cpu_eq)) ? nr :\n\t\t\t(nr + NIC_NUMBER_OF_ENGINES + 1);\n\n\treturn pci_irq_vector(hdev->pdev, msi_vec);\n}\n\nstatic int gaudi_enable_msi_single(struct hl_device *hdev)\n{\n\tint rc, irq;\n\n\tdev_dbg(hdev->dev, \"Working in single MSI IRQ mode\\n\");\n\n\tirq = gaudi_pci_irq_vector(hdev, 0, false);\n\trc = request_irq(irq, gaudi_irq_handler_single, 0,\n\t\t\t\"gaudi single msi\", hdev);\n\tif (rc)\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to request single MSI IRQ\\n\");\n\n\treturn rc;\n}\n\nstatic int gaudi_enable_msi_multi(struct hl_device *hdev)\n{\n\tint cq_cnt = hdev->asic_prop.completion_queues_count;\n\tint rc, i, irq_cnt_init, irq;\n\n\tfor (i = 0, irq_cnt_init = 0 ; i < cq_cnt ; i++, irq_cnt_init++) {\n\t\tirq = gaudi_pci_irq_vector(hdev, i, false);\n\t\trc = request_irq(irq, hl_irq_handler_cq, 0, gaudi_irq_name[i],\n\t\t\t\t&hdev->completion_queue[i]);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev, \"Failed to request IRQ %d\", irq);\n\t\t\tgoto free_irqs;\n\t\t}\n\t}\n\n\tirq = gaudi_pci_irq_vector(hdev, GAUDI_EVENT_QUEUE_MSI_IDX, true);\n\trc = request_irq(irq, hl_irq_handler_eq, 0, gaudi_irq_name[cq_cnt],\n\t\t\t\t&hdev->event_queue);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to request IRQ %d\", irq);\n\t\tgoto free_irqs;\n\t}\n\n\treturn 0;\n\nfree_irqs:\n\tfor (i = 0 ; i < irq_cnt_init ; i++)\n\t\tfree_irq(gaudi_pci_irq_vector(hdev, i, false),\n\t\t\t\t&hdev->completion_queue[i]);\n\treturn rc;\n}\n\nstatic int gaudi_enable_msi(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tint rc;\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_MSI)\n\t\treturn 0;\n\n\trc = pci_alloc_irq_vectors(hdev->pdev, 1, GAUDI_MSI_ENTRIES,\n\t\t\t\t\tPCI_IRQ_MSI);\n\tif (rc < 0) {\n\t\tdev_err(hdev->dev, \"MSI: Failed to enable support %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (rc < NUMBER_OF_INTERRUPTS) {\n\t\tgaudi->multi_msi_mode = false;\n\t\trc = gaudi_enable_msi_single(hdev);\n\t} else {\n\t\tgaudi->multi_msi_mode = true;\n\t\trc = gaudi_enable_msi_multi(hdev);\n\t}\n\n\tif (rc)\n\t\tgoto free_pci_irq_vectors;\n\n\tgaudi->hw_cap_initialized |= HW_CAP_MSI;\n\n\treturn 0;\n\nfree_pci_irq_vectors:\n\tpci_free_irq_vectors(hdev->pdev);\n\treturn rc;\n}\n\nstatic void gaudi_sync_irqs(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tint i, cq_cnt = hdev->asic_prop.completion_queues_count;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_MSI))\n\t\treturn;\n\n\t/* Wait for all pending IRQs to be finished */\n\tif (gaudi->multi_msi_mode) {\n\t\tfor (i = 0 ; i < cq_cnt ; i++)\n\t\t\tsynchronize_irq(gaudi_pci_irq_vector(hdev, i, false));\n\n\t\tsynchronize_irq(gaudi_pci_irq_vector(hdev,\n\t\t\t\t\t\tGAUDI_EVENT_QUEUE_MSI_IDX,\n\t\t\t\t\t\ttrue));\n\t} else {\n\t\tsynchronize_irq(gaudi_pci_irq_vector(hdev, 0, false));\n\t}\n}\n\nstatic void gaudi_disable_msi(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tint i, irq, cq_cnt = hdev->asic_prop.completion_queues_count;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_MSI))\n\t\treturn;\n\n\tgaudi_sync_irqs(hdev);\n\n\tif (gaudi->multi_msi_mode) {\n\t\tirq = gaudi_pci_irq_vector(hdev, GAUDI_EVENT_QUEUE_MSI_IDX,\n\t\t\t\t\t\ttrue);\n\t\tfree_irq(irq, &hdev->event_queue);\n\n\t\tfor (i = 0 ; i < cq_cnt ; i++) {\n\t\t\tirq = gaudi_pci_irq_vector(hdev, i, false);\n\t\t\tfree_irq(irq, &hdev->completion_queue[i]);\n\t\t}\n\t} else {\n\t\tfree_irq(gaudi_pci_irq_vector(hdev, 0, false), hdev);\n\t}\n\n\tpci_free_irq_vectors(hdev->pdev);\n\n\tgaudi->hw_cap_initialized &= ~HW_CAP_MSI;\n}\n\nstatic void gaudi_init_scrambler_sram(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!hdev->asic_prop.fw_security_disabled)\n\t\treturn;\n\n\tif (hdev->asic_prop.fw_security_status_valid &&\n\t\t\t(hdev->asic_prop.fw_app_security_map &\n\t\t\t\t\tCPU_BOOT_DEV_STS0_SRAM_SCR_EN))\n\t\treturn;\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_SRAM_SCRAMBLER)\n\t\treturn;\n\n\tif (!hdev->sram_scrambler_enable)\n\t\treturn;\n\n\tWREG32(mmNIF_RTR_CTRL_0_SCRAM_SRAM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_1_SCRAM_SRAM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_2_SCRAM_SRAM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_3_SCRAM_SRAM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_4_SCRAM_SRAM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_5_SCRAM_SRAM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_6_SCRAM_SRAM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_7_SCRAM_SRAM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_SRAM_EN_VAL_SHIFT);\n\n\tWREG32(mmSIF_RTR_CTRL_0_SCRAM_SRAM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_1_SCRAM_SRAM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_2_SCRAM_SRAM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_3_SCRAM_SRAM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_4_SCRAM_SRAM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_5_SCRAM_SRAM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_6_SCRAM_SRAM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_7_SCRAM_SRAM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_SRAM_EN_VAL_SHIFT);\n\n\tWREG32(mmDMA_IF_E_N_DOWN_CH0_SCRAM_SRAM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_E_N_DOWN_CH1_SCRAM_SRAM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_E_S_DOWN_CH0_SCRAM_SRAM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_E_S_DOWN_CH1_SCRAM_SRAM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_W_N_DOWN_CH0_SCRAM_SRAM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_W_N_DOWN_CH1_SCRAM_SRAM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_W_S_DOWN_CH0_SCRAM_SRAM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_SCRAM_SRAM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_W_S_DOWN_CH1_SCRAM_SRAM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_SCRAM_SRAM_EN_VAL_SHIFT);\n\n\tgaudi->hw_cap_initialized |= HW_CAP_SRAM_SCRAMBLER;\n}\n\nstatic void gaudi_init_scrambler_hbm(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!hdev->asic_prop.fw_security_disabled)\n\t\treturn;\n\n\tif (hdev->asic_prop.fw_security_status_valid &&\n\t\t\t(hdev->asic_prop.fw_boot_cpu_security_map &\n\t\t\t\t\tCPU_BOOT_DEV_STS0_DRAM_SCR_EN))\n\t\treturn;\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_HBM_SCRAMBLER)\n\t\treturn;\n\n\tif (!hdev->dram_scrambler_enable)\n\t\treturn;\n\n\tWREG32(mmNIF_RTR_CTRL_0_SCRAM_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_1_SCRAM_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_2_SCRAM_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_3_SCRAM_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_4_SCRAM_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_5_SCRAM_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_6_SCRAM_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_7_SCRAM_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_HBM_EN_VAL_SHIFT);\n\n\tWREG32(mmSIF_RTR_CTRL_0_SCRAM_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_1_SCRAM_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_2_SCRAM_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_3_SCRAM_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_4_SCRAM_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_5_SCRAM_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_6_SCRAM_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_7_SCRAM_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_SCRAM_HBM_EN_VAL_SHIFT);\n\n\tWREG32(mmDMA_IF_E_N_DOWN_CH0_SCRAM_HBM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_E_N_DOWN_CH1_SCRAM_HBM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_E_S_DOWN_CH0_SCRAM_HBM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_E_S_DOWN_CH1_SCRAM_HBM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_W_N_DOWN_CH0_SCRAM_HBM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_W_N_DOWN_CH1_SCRAM_HBM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_W_S_DOWN_CH0_SCRAM_HBM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_SCRAM_HBM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_W_S_DOWN_CH1_SCRAM_HBM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_SCRAM_HBM_EN_VAL_SHIFT);\n\n\tgaudi->hw_cap_initialized |= HW_CAP_HBM_SCRAMBLER;\n}\n\nstatic void gaudi_init_e2e(struct hl_device *hdev)\n{\n\tif (!hdev->asic_prop.fw_security_disabled)\n\t\treturn;\n\n\tif (hdev->asic_prop.fw_security_status_valid &&\n\t\t\t(hdev->asic_prop.fw_boot_cpu_security_map &\n\t\t\t\t\tCPU_BOOT_DEV_STS0_E2E_CRED_EN))\n\t\treturn;\n\n\tWREG32(mmSIF_RTR_CTRL_0_E2E_HBM_WR_SIZE, 247 >> 3);\n\tWREG32(mmSIF_RTR_CTRL_0_E2E_HBM_RD_SIZE, 785 >> 3);\n\tWREG32(mmSIF_RTR_CTRL_0_E2E_PCI_WR_SIZE, 49);\n\tWREG32(mmSIF_RTR_CTRL_0_E2E_PCI_RD_SIZE, 101);\n\n\tWREG32(mmSIF_RTR_CTRL_1_E2E_HBM_WR_SIZE, 275 >> 3);\n\tWREG32(mmSIF_RTR_CTRL_1_E2E_HBM_RD_SIZE, 614 >> 3);\n\tWREG32(mmSIF_RTR_CTRL_1_E2E_PCI_WR_SIZE, 1);\n\tWREG32(mmSIF_RTR_CTRL_1_E2E_PCI_RD_SIZE, 39);\n\n\tWREG32(mmSIF_RTR_CTRL_2_E2E_HBM_WR_SIZE, 1);\n\tWREG32(mmSIF_RTR_CTRL_2_E2E_HBM_RD_SIZE, 1);\n\tWREG32(mmSIF_RTR_CTRL_2_E2E_PCI_WR_SIZE, 1);\n\tWREG32(mmSIF_RTR_CTRL_2_E2E_PCI_RD_SIZE, 32);\n\n\tWREG32(mmSIF_RTR_CTRL_3_E2E_HBM_WR_SIZE, 176 >> 3);\n\tWREG32(mmSIF_RTR_CTRL_3_E2E_HBM_RD_SIZE, 32 >> 3);\n\tWREG32(mmSIF_RTR_CTRL_3_E2E_PCI_WR_SIZE, 19);\n\tWREG32(mmSIF_RTR_CTRL_3_E2E_PCI_RD_SIZE, 32);\n\n\tWREG32(mmSIF_RTR_CTRL_4_E2E_HBM_WR_SIZE, 176 >> 3);\n\tWREG32(mmSIF_RTR_CTRL_4_E2E_HBM_RD_SIZE, 32 >> 3);\n\tWREG32(mmSIF_RTR_CTRL_4_E2E_PCI_WR_SIZE, 19);\n\tWREG32(mmSIF_RTR_CTRL_4_E2E_PCI_RD_SIZE, 32);\n\n\tWREG32(mmSIF_RTR_CTRL_5_E2E_HBM_WR_SIZE, 1);\n\tWREG32(mmSIF_RTR_CTRL_5_E2E_HBM_RD_SIZE, 1);\n\tWREG32(mmSIF_RTR_CTRL_5_E2E_PCI_WR_SIZE, 1);\n\tWREG32(mmSIF_RTR_CTRL_5_E2E_PCI_RD_SIZE, 32);\n\n\tWREG32(mmSIF_RTR_CTRL_6_E2E_HBM_WR_SIZE, 275 >> 3);\n\tWREG32(mmSIF_RTR_CTRL_6_E2E_HBM_RD_SIZE, 614 >> 3);\n\tWREG32(mmSIF_RTR_CTRL_6_E2E_PCI_WR_SIZE, 1);\n\tWREG32(mmSIF_RTR_CTRL_6_E2E_PCI_RD_SIZE, 39);\n\n\tWREG32(mmSIF_RTR_CTRL_7_E2E_HBM_WR_SIZE, 297 >> 3);\n\tWREG32(mmSIF_RTR_CTRL_7_E2E_HBM_RD_SIZE, 908 >> 3);\n\tWREG32(mmSIF_RTR_CTRL_7_E2E_PCI_WR_SIZE, 19);\n\tWREG32(mmSIF_RTR_CTRL_7_E2E_PCI_RD_SIZE, 19);\n\n\tWREG32(mmNIF_RTR_CTRL_0_E2E_HBM_WR_SIZE, 318 >> 3);\n\tWREG32(mmNIF_RTR_CTRL_0_E2E_HBM_RD_SIZE, 956 >> 3);\n\tWREG32(mmNIF_RTR_CTRL_0_E2E_PCI_WR_SIZE, 79);\n\tWREG32(mmNIF_RTR_CTRL_0_E2E_PCI_RD_SIZE, 163);\n\n\tWREG32(mmNIF_RTR_CTRL_1_E2E_HBM_WR_SIZE, 275 >> 3);\n\tWREG32(mmNIF_RTR_CTRL_1_E2E_HBM_RD_SIZE, 614 >> 3);\n\tWREG32(mmNIF_RTR_CTRL_1_E2E_PCI_WR_SIZE, 1);\n\tWREG32(mmNIF_RTR_CTRL_1_E2E_PCI_RD_SIZE, 39);\n\n\tWREG32(mmNIF_RTR_CTRL_2_E2E_HBM_WR_SIZE, 1);\n\tWREG32(mmNIF_RTR_CTRL_2_E2E_HBM_RD_SIZE, 1);\n\tWREG32(mmNIF_RTR_CTRL_2_E2E_PCI_WR_SIZE, 1);\n\tWREG32(mmNIF_RTR_CTRL_2_E2E_PCI_RD_SIZE, 32);\n\n\tWREG32(mmNIF_RTR_CTRL_3_E2E_HBM_WR_SIZE, 176 >> 3);\n\tWREG32(mmNIF_RTR_CTRL_3_E2E_HBM_RD_SIZE, 32 >> 3);\n\tWREG32(mmNIF_RTR_CTRL_3_E2E_PCI_WR_SIZE, 19);\n\tWREG32(mmNIF_RTR_CTRL_3_E2E_PCI_RD_SIZE, 32);\n\n\tWREG32(mmNIF_RTR_CTRL_4_E2E_HBM_WR_SIZE, 176 >> 3);\n\tWREG32(mmNIF_RTR_CTRL_4_E2E_HBM_RD_SIZE, 32 >> 3);\n\tWREG32(mmNIF_RTR_CTRL_4_E2E_PCI_WR_SIZE, 19);\n\tWREG32(mmNIF_RTR_CTRL_4_E2E_PCI_RD_SIZE, 32);\n\n\tWREG32(mmNIF_RTR_CTRL_5_E2E_HBM_WR_SIZE, 1);\n\tWREG32(mmNIF_RTR_CTRL_5_E2E_HBM_RD_SIZE, 1);\n\tWREG32(mmNIF_RTR_CTRL_5_E2E_PCI_WR_SIZE, 1);\n\tWREG32(mmNIF_RTR_CTRL_5_E2E_PCI_RD_SIZE, 32);\n\n\tWREG32(mmNIF_RTR_CTRL_6_E2E_HBM_WR_SIZE, 275 >> 3);\n\tWREG32(mmNIF_RTR_CTRL_6_E2E_HBM_RD_SIZE, 614 >> 3);\n\tWREG32(mmNIF_RTR_CTRL_6_E2E_PCI_WR_SIZE, 1);\n\tWREG32(mmNIF_RTR_CTRL_6_E2E_PCI_RD_SIZE, 39);\n\n\tWREG32(mmNIF_RTR_CTRL_7_E2E_HBM_WR_SIZE, 318 >> 3);\n\tWREG32(mmNIF_RTR_CTRL_7_E2E_HBM_RD_SIZE, 956 >> 3);\n\tWREG32(mmNIF_RTR_CTRL_7_E2E_PCI_WR_SIZE, 79);\n\tWREG32(mmNIF_RTR_CTRL_7_E2E_PCI_RD_SIZE, 79);\n\n\tWREG32(mmDMA_IF_E_N_DOWN_CH0_E2E_HBM_WR_SIZE, 344 >> 3);\n\tWREG32(mmDMA_IF_E_N_DOWN_CH0_E2E_HBM_RD_SIZE, 1000 >> 3);\n\tWREG32(mmDMA_IF_E_N_DOWN_CH0_E2E_PCI_WR_SIZE, 162);\n\tWREG32(mmDMA_IF_E_N_DOWN_CH0_E2E_PCI_RD_SIZE, 338);\n\n\tWREG32(mmDMA_IF_E_N_DOWN_CH1_E2E_HBM_WR_SIZE, 344 >> 3);\n\tWREG32(mmDMA_IF_E_N_DOWN_CH1_E2E_HBM_RD_SIZE, 1000 >> 3);\n\tWREG32(mmDMA_IF_E_N_DOWN_CH1_E2E_PCI_WR_SIZE, 162);\n\tWREG32(mmDMA_IF_E_N_DOWN_CH1_E2E_PCI_RD_SIZE, 338);\n\n\tWREG32(mmDMA_IF_E_S_DOWN_CH0_E2E_HBM_WR_SIZE, 344 >> 3);\n\tWREG32(mmDMA_IF_E_S_DOWN_CH0_E2E_HBM_RD_SIZE, 1000 >> 3);\n\tWREG32(mmDMA_IF_E_S_DOWN_CH0_E2E_PCI_WR_SIZE, 162);\n\tWREG32(mmDMA_IF_E_S_DOWN_CH0_E2E_PCI_RD_SIZE, 338);\n\n\tWREG32(mmDMA_IF_E_S_DOWN_CH1_E2E_HBM_WR_SIZE, 344 >> 3);\n\tWREG32(mmDMA_IF_E_S_DOWN_CH1_E2E_HBM_RD_SIZE, 1000 >> 3);\n\tWREG32(mmDMA_IF_E_S_DOWN_CH1_E2E_PCI_WR_SIZE, 162);\n\tWREG32(mmDMA_IF_E_S_DOWN_CH1_E2E_PCI_RD_SIZE, 338);\n\n\tWREG32(mmDMA_IF_W_N_DOWN_CH0_E2E_HBM_WR_SIZE, 344 >> 3);\n\tWREG32(mmDMA_IF_W_N_DOWN_CH0_E2E_HBM_RD_SIZE, 1000 >> 3);\n\tWREG32(mmDMA_IF_W_N_DOWN_CH0_E2E_PCI_WR_SIZE, 162);\n\tWREG32(mmDMA_IF_W_N_DOWN_CH0_E2E_PCI_RD_SIZE, 338);\n\n\tWREG32(mmDMA_IF_W_N_DOWN_CH1_E2E_HBM_WR_SIZE, 344 >> 3);\n\tWREG32(mmDMA_IF_W_N_DOWN_CH1_E2E_HBM_RD_SIZE, 1000 >> 3);\n\tWREG32(mmDMA_IF_W_N_DOWN_CH1_E2E_PCI_WR_SIZE, 162);\n\tWREG32(mmDMA_IF_W_N_DOWN_CH1_E2E_PCI_RD_SIZE, 338);\n\n\tWREG32(mmDMA_IF_W_S_DOWN_CH0_E2E_HBM_WR_SIZE, 344 >> 3);\n\tWREG32(mmDMA_IF_W_S_DOWN_CH0_E2E_HBM_RD_SIZE, 1000 >> 3);\n\tWREG32(mmDMA_IF_W_S_DOWN_CH0_E2E_PCI_WR_SIZE, 162);\n\tWREG32(mmDMA_IF_W_S_DOWN_CH0_E2E_PCI_RD_SIZE, 338);\n\n\tWREG32(mmDMA_IF_W_S_DOWN_CH1_E2E_HBM_WR_SIZE, 344 >> 3);\n\tWREG32(mmDMA_IF_W_S_DOWN_CH1_E2E_HBM_RD_SIZE, 1000 >> 3);\n\tWREG32(mmDMA_IF_W_S_DOWN_CH1_E2E_PCI_WR_SIZE, 162);\n\tWREG32(mmDMA_IF_W_S_DOWN_CH1_E2E_PCI_RD_SIZE, 338);\n\n\tif (!hdev->dram_scrambler_enable) {\n\t\tWREG32(mmSIF_RTR_CTRL_0_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmSIF_RTR_CTRL_0_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmSIF_RTR_CTRL_0_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmSIF_RTR_CTRL_0_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmSIF_RTR_CTRL_1_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmSIF_RTR_CTRL_1_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmSIF_RTR_CTRL_1_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmSIF_RTR_CTRL_1_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmSIF_RTR_CTRL_2_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmSIF_RTR_CTRL_2_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmSIF_RTR_CTRL_2_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmSIF_RTR_CTRL_2_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmSIF_RTR_CTRL_3_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmSIF_RTR_CTRL_3_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmSIF_RTR_CTRL_3_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmSIF_RTR_CTRL_3_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmSIF_RTR_CTRL_4_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmSIF_RTR_CTRL_4_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmSIF_RTR_CTRL_4_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmSIF_RTR_CTRL_4_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmSIF_RTR_CTRL_5_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmSIF_RTR_CTRL_5_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmSIF_RTR_CTRL_5_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmSIF_RTR_CTRL_5_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmSIF_RTR_CTRL_6_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmSIF_RTR_CTRL_6_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmSIF_RTR_CTRL_6_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmSIF_RTR_CTRL_6_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmSIF_RTR_CTRL_7_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmSIF_RTR_CTRL_7_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmSIF_RTR_CTRL_7_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmSIF_RTR_CTRL_7_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmNIF_RTR_CTRL_0_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmNIF_RTR_CTRL_0_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmNIF_RTR_CTRL_0_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmNIF_RTR_CTRL_0_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmNIF_RTR_CTRL_1_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmNIF_RTR_CTRL_1_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmNIF_RTR_CTRL_1_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmNIF_RTR_CTRL_1_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmNIF_RTR_CTRL_2_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmNIF_RTR_CTRL_2_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmNIF_RTR_CTRL_2_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmNIF_RTR_CTRL_2_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmNIF_RTR_CTRL_3_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmNIF_RTR_CTRL_3_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmNIF_RTR_CTRL_3_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmNIF_RTR_CTRL_3_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmNIF_RTR_CTRL_4_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmNIF_RTR_CTRL_4_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmNIF_RTR_CTRL_4_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmNIF_RTR_CTRL_4_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmNIF_RTR_CTRL_5_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmNIF_RTR_CTRL_5_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmNIF_RTR_CTRL_5_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmNIF_RTR_CTRL_5_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmNIF_RTR_CTRL_6_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmNIF_RTR_CTRL_6_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmNIF_RTR_CTRL_6_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmNIF_RTR_CTRL_6_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmNIF_RTR_CTRL_7_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmNIF_RTR_CTRL_7_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmNIF_RTR_CTRL_7_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmNIF_RTR_CTRL_7_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmDMA_IF_E_N_DOWN_CH0_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmDMA_IF_E_N_DOWN_CH0_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmDMA_IF_E_N_DOWN_CH0_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmDMA_IF_E_N_DOWN_CH0_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmDMA_IF_E_N_DOWN_CH1_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmDMA_IF_E_N_DOWN_CH1_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmDMA_IF_E_N_DOWN_CH1_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmDMA_IF_E_N_DOWN_CH1_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmDMA_IF_E_S_DOWN_CH0_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmDMA_IF_E_S_DOWN_CH0_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmDMA_IF_E_S_DOWN_CH0_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmDMA_IF_E_S_DOWN_CH0_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmDMA_IF_E_S_DOWN_CH1_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmDMA_IF_E_S_DOWN_CH1_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmDMA_IF_E_S_DOWN_CH1_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmDMA_IF_E_S_DOWN_CH1_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmDMA_IF_W_N_DOWN_CH0_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmDMA_IF_W_N_DOWN_CH0_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmDMA_IF_W_N_DOWN_CH0_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmDMA_IF_W_N_DOWN_CH0_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmDMA_IF_W_N_DOWN_CH1_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmDMA_IF_W_N_DOWN_CH1_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmDMA_IF_W_N_DOWN_CH1_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmDMA_IF_W_N_DOWN_CH1_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmDMA_IF_W_S_DOWN_CH0_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmDMA_IF_W_S_DOWN_CH0_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmDMA_IF_W_S_DOWN_CH0_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmDMA_IF_W_S_DOWN_CH0_NL_HBM_PC_SEL_3, 0x20);\n\n\t\tWREG32(mmDMA_IF_W_S_DOWN_CH1_NL_HBM_SEL_0, 0x21);\n\t\tWREG32(mmDMA_IF_W_S_DOWN_CH1_NL_HBM_SEL_1, 0x22);\n\t\tWREG32(mmDMA_IF_W_S_DOWN_CH1_NL_HBM_OFFSET_18, 0x1F);\n\t\tWREG32(mmDMA_IF_W_S_DOWN_CH1_NL_HBM_PC_SEL_3, 0x20);\n\t}\n\n\tWREG32(mmSIF_RTR_CTRL_0_E2E_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_0_E2E_PCI_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmSIF_RTR_CTRL_1_E2E_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_1_E2E_PCI_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmSIF_RTR_CTRL_2_E2E_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_2_E2E_PCI_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmSIF_RTR_CTRL_3_E2E_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_3_E2E_PCI_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmSIF_RTR_CTRL_4_E2E_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_4_E2E_PCI_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmSIF_RTR_CTRL_5_E2E_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_5_E2E_PCI_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmSIF_RTR_CTRL_6_E2E_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_6_E2E_PCI_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmSIF_RTR_CTRL_7_E2E_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmSIF_RTR_CTRL_7_E2E_PCI_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmNIF_RTR_CTRL_0_E2E_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_0_E2E_PCI_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmNIF_RTR_CTRL_1_E2E_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_1_E2E_PCI_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmNIF_RTR_CTRL_2_E2E_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_2_E2E_PCI_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmNIF_RTR_CTRL_3_E2E_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_3_E2E_PCI_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmNIF_RTR_CTRL_4_E2E_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_4_E2E_PCI_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmNIF_RTR_CTRL_5_E2E_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_5_E2E_PCI_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmNIF_RTR_CTRL_6_E2E_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_6_E2E_PCI_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmNIF_RTR_CTRL_7_E2E_HBM_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmNIF_RTR_CTRL_7_E2E_PCI_EN,\n\t\t\t1 << IF_RTR_CTRL_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmDMA_IF_E_N_DOWN_CH0_E2E_HBM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_E_N_DOWN_CH0_E2E_PCI_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmDMA_IF_E_N_DOWN_CH1_E2E_HBM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_E_N_DOWN_CH1_E2E_PCI_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmDMA_IF_E_S_DOWN_CH0_E2E_HBM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_E_S_DOWN_CH0_E2E_PCI_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmDMA_IF_E_S_DOWN_CH1_E2E_HBM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_E_S_DOWN_CH1_E2E_PCI_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmDMA_IF_W_N_DOWN_CH0_E2E_HBM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_W_N_DOWN_CH0_E2E_PCI_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmDMA_IF_W_N_DOWN_CH1_E2E_HBM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_W_N_DOWN_CH1_E2E_PCI_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmDMA_IF_W_S_DOWN_CH0_E2E_HBM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_W_S_DOWN_CH0_E2E_PCI_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_E2E_PCI_EN_VAL_SHIFT);\n\n\tWREG32(mmDMA_IF_W_S_DOWN_CH1_E2E_HBM_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_E2E_HBM_EN_VAL_SHIFT);\n\tWREG32(mmDMA_IF_W_S_DOWN_CH1_E2E_PCI_EN,\n\t\t\t1 << DMA_IF_DOWN_CHX_E2E_PCI_EN_VAL_SHIFT);\n}\n\nstatic void gaudi_init_hbm_cred(struct hl_device *hdev)\n{\n\tuint32_t hbm0_wr, hbm1_wr, hbm0_rd, hbm1_rd;\n\n\tif (!hdev->asic_prop.fw_security_disabled)\n\t\treturn;\n\n\tif (hdev->asic_prop.fw_security_status_valid &&\n\t\t\t(hdev->asic_prop.fw_boot_cpu_security_map &\n\t\t\t\t\tCPU_BOOT_DEV_STS0_HBM_CRED_EN))\n\t\treturn;\n\n\thbm0_wr = 0x33333333;\n\thbm0_rd = 0x77777777;\n\thbm1_wr = 0x55555555;\n\thbm1_rd = 0xDDDDDDDD;\n\n\tWREG32(mmDMA_IF_E_N_HBM0_WR_CRED_CNT, hbm0_wr);\n\tWREG32(mmDMA_IF_E_N_HBM1_WR_CRED_CNT, hbm1_wr);\n\tWREG32(mmDMA_IF_E_N_HBM0_RD_CRED_CNT, hbm0_rd);\n\tWREG32(mmDMA_IF_E_N_HBM1_RD_CRED_CNT, hbm1_rd);\n\n\tWREG32(mmDMA_IF_E_S_HBM0_WR_CRED_CNT, hbm0_wr);\n\tWREG32(mmDMA_IF_E_S_HBM1_WR_CRED_CNT, hbm1_wr);\n\tWREG32(mmDMA_IF_E_S_HBM0_RD_CRED_CNT, hbm0_rd);\n\tWREG32(mmDMA_IF_E_S_HBM1_RD_CRED_CNT, hbm1_rd);\n\n\tWREG32(mmDMA_IF_W_N_HBM0_WR_CRED_CNT, hbm0_wr);\n\tWREG32(mmDMA_IF_W_N_HBM1_WR_CRED_CNT, hbm1_wr);\n\tWREG32(mmDMA_IF_W_N_HBM0_RD_CRED_CNT, hbm0_rd);\n\tWREG32(mmDMA_IF_W_N_HBM1_RD_CRED_CNT, hbm1_rd);\n\n\tWREG32(mmDMA_IF_W_S_HBM0_WR_CRED_CNT, hbm0_wr);\n\tWREG32(mmDMA_IF_W_S_HBM1_WR_CRED_CNT, hbm1_wr);\n\tWREG32(mmDMA_IF_W_S_HBM0_RD_CRED_CNT, hbm0_rd);\n\tWREG32(mmDMA_IF_W_S_HBM1_RD_CRED_CNT, hbm1_rd);\n\n\tWREG32(mmDMA_IF_E_N_HBM_CRED_EN_0,\n\t\t\t(1 << DMA_IF_HBM_CRED_EN_READ_CREDIT_EN_SHIFT) |\n\t\t\t(1 << DMA_IF_HBM_CRED_EN_WRITE_CREDIT_EN_SHIFT));\n\tWREG32(mmDMA_IF_E_S_HBM_CRED_EN_0,\n\t\t\t(1 << DMA_IF_HBM_CRED_EN_READ_CREDIT_EN_SHIFT) |\n\t\t\t(1 << DMA_IF_HBM_CRED_EN_WRITE_CREDIT_EN_SHIFT));\n\tWREG32(mmDMA_IF_W_N_HBM_CRED_EN_0,\n\t\t\t(1 << DMA_IF_HBM_CRED_EN_READ_CREDIT_EN_SHIFT) |\n\t\t\t(1 << DMA_IF_HBM_CRED_EN_WRITE_CREDIT_EN_SHIFT));\n\tWREG32(mmDMA_IF_W_S_HBM_CRED_EN_0,\n\t\t\t(1 << DMA_IF_HBM_CRED_EN_READ_CREDIT_EN_SHIFT) |\n\t\t\t(1 << DMA_IF_HBM_CRED_EN_WRITE_CREDIT_EN_SHIFT));\n\n\tWREG32(mmDMA_IF_E_N_HBM_CRED_EN_1,\n\t\t\t(1 << DMA_IF_HBM_CRED_EN_READ_CREDIT_EN_SHIFT) |\n\t\t\t(1 << DMA_IF_HBM_CRED_EN_WRITE_CREDIT_EN_SHIFT));\n\tWREG32(mmDMA_IF_E_S_HBM_CRED_EN_1,\n\t\t\t(1 << DMA_IF_HBM_CRED_EN_READ_CREDIT_EN_SHIFT) |\n\t\t\t(1 << DMA_IF_HBM_CRED_EN_WRITE_CREDIT_EN_SHIFT));\n\tWREG32(mmDMA_IF_W_N_HBM_CRED_EN_1,\n\t\t\t(1 << DMA_IF_HBM_CRED_EN_READ_CREDIT_EN_SHIFT) |\n\t\t\t(1 << DMA_IF_HBM_CRED_EN_WRITE_CREDIT_EN_SHIFT));\n\tWREG32(mmDMA_IF_W_S_HBM_CRED_EN_1,\n\t\t\t(1 << DMA_IF_HBM_CRED_EN_READ_CREDIT_EN_SHIFT) |\n\t\t\t(1 << DMA_IF_HBM_CRED_EN_WRITE_CREDIT_EN_SHIFT));\n}\n\nstatic void gaudi_init_golden_registers(struct hl_device *hdev)\n{\n\tu32 tpc_offset;\n\tint tpc_id, i;\n\n\tgaudi_init_e2e(hdev);\n\tgaudi_init_hbm_cred(hdev);\n\n\tfor (tpc_id = 0, tpc_offset = 0;\n\t\t\t\ttpc_id < TPC_NUMBER_OF_ENGINES;\n\t\t\t\ttpc_id++, tpc_offset += TPC_CFG_OFFSET) {\n\t\t/* Mask all arithmetic interrupts from TPC */\n\t\tWREG32(mmTPC0_CFG_TPC_INTR_MASK + tpc_offset, 0x8FFF);\n\t\t/* Set 16 cache lines */\n\t\tWREG32_FIELD(TPC0_CFG_MSS_CONFIG, tpc_offset,\n\t\t\t\tICACHE_FETCH_LINE_NUM, 2);\n\t}\n\n\t/* Make sure 1st 128 bytes in SRAM are 0 for Tensor DMA */\n\tfor (i = 0 ; i < 128 ; i += 8)\n\t\twriteq(0, hdev->pcie_bar[SRAM_BAR_ID] + i);\n\n\tWREG32(mmMME0_CTRL_EUS_ROLLUP_CNT_ADD, 3);\n\tWREG32(mmMME1_CTRL_EUS_ROLLUP_CNT_ADD, 3);\n\tWREG32(mmMME2_CTRL_EUS_ROLLUP_CNT_ADD, 3);\n\tWREG32(mmMME3_CTRL_EUS_ROLLUP_CNT_ADD, 3);\n}\n\nstatic void gaudi_init_pci_dma_qman(struct hl_device *hdev, int dma_id,\n\t\t\t\t\tint qman_id, dma_addr_t qman_pq_addr)\n{\n\tu32 mtr_base_en_lo, mtr_base_en_hi, mtr_base_ws_lo, mtr_base_ws_hi;\n\tu32 so_base_en_lo, so_base_en_hi, so_base_ws_lo, so_base_ws_hi;\n\tu32 q_off, dma_qm_offset;\n\tu32 dma_qm_err_cfg;\n\n\tdma_qm_offset = dma_id * DMA_QMAN_OFFSET;\n\n\tmtr_base_en_lo = lower_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tmtr_base_en_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tso_base_en_lo = lower_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\tso_base_en_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\tmtr_base_ws_lo = lower_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tmtr_base_ws_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tso_base_ws_lo = lower_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\tso_base_ws_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\n\tq_off = dma_qm_offset + qman_id * 4;\n\n\tWREG32(mmDMA0_QM_PQ_BASE_LO_0 + q_off, lower_32_bits(qman_pq_addr));\n\tWREG32(mmDMA0_QM_PQ_BASE_HI_0 + q_off, upper_32_bits(qman_pq_addr));\n\n\tWREG32(mmDMA0_QM_PQ_SIZE_0 + q_off, ilog2(HL_QUEUE_LENGTH));\n\tWREG32(mmDMA0_QM_PQ_PI_0 + q_off, 0);\n\tWREG32(mmDMA0_QM_PQ_CI_0 + q_off, 0);\n\n\tWREG32(mmDMA0_QM_CP_LDMA_TSIZE_OFFSET_0 + q_off, QMAN_LDMA_SIZE_OFFSET);\n\tWREG32(mmDMA0_QM_CP_LDMA_SRC_BASE_LO_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_LDMA_SRC_OFFSET);\n\tWREG32(mmDMA0_QM_CP_LDMA_DST_BASE_LO_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_LDMA_DST_OFFSET);\n\n\tWREG32(mmDMA0_QM_CP_MSG_BASE0_ADDR_LO_0 + q_off, mtr_base_en_lo);\n\tWREG32(mmDMA0_QM_CP_MSG_BASE0_ADDR_HI_0 + q_off, mtr_base_en_hi);\n\tWREG32(mmDMA0_QM_CP_MSG_BASE1_ADDR_LO_0 + q_off, so_base_en_lo);\n\tWREG32(mmDMA0_QM_CP_MSG_BASE1_ADDR_HI_0 + q_off, so_base_en_hi);\n\tWREG32(mmDMA0_QM_CP_MSG_BASE2_ADDR_LO_0 + q_off, mtr_base_ws_lo);\n\tWREG32(mmDMA0_QM_CP_MSG_BASE2_ADDR_HI_0 + q_off, mtr_base_ws_hi);\n\tWREG32(mmDMA0_QM_CP_MSG_BASE3_ADDR_LO_0 + q_off, so_base_ws_lo);\n\tWREG32(mmDMA0_QM_CP_MSG_BASE3_ADDR_HI_0 + q_off, so_base_ws_hi);\n\n\tWREG32(mmDMA0_QM_CP_BARRIER_CFG_0 + q_off, 0x100);\n\n\t/* The following configuration is needed only once per QMAN */\n\tif (qman_id == 0) {\n\t\t/* Configure RAZWI IRQ */\n\t\tdma_qm_err_cfg = PCI_DMA_QMAN_GLBL_ERR_CFG_MSG_EN_MASK;\n\t\tif (hdev->stop_on_err) {\n\t\t\tdma_qm_err_cfg |=\n\t\t\t\tPCI_DMA_QMAN_GLBL_ERR_CFG_STOP_ON_ERR_EN_MASK;\n\t\t}\n\n\t\tWREG32(mmDMA0_QM_GLBL_ERR_CFG + dma_qm_offset, dma_qm_err_cfg);\n\t\tWREG32(mmDMA0_QM_GLBL_ERR_ADDR_LO + dma_qm_offset,\n\t\t\tlower_32_bits(CFG_BASE +\n\t\t\t\t\tmmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR));\n\t\tWREG32(mmDMA0_QM_GLBL_ERR_ADDR_HI + dma_qm_offset,\n\t\t\tupper_32_bits(CFG_BASE +\n\t\t\t\t\tmmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR));\n\t\tWREG32(mmDMA0_QM_GLBL_ERR_WDATA + dma_qm_offset,\n\t\t\tgaudi_irq_map_table[GAUDI_EVENT_DMA0_QM].cpu_id +\n\t\t\t\t\t\t\t\t\tdma_id);\n\n\t\tWREG32(mmDMA0_QM_ARB_ERR_MSG_EN + dma_qm_offset,\n\t\t\t\tQM_ARB_ERR_MSG_EN_MASK);\n\n\t\t/* Increase ARB WDT to support streams architecture */\n\t\tWREG32(mmDMA0_QM_ARB_SLV_CHOISE_WDT + dma_qm_offset,\n\t\t\t\tGAUDI_ARB_WDT_TIMEOUT);\n\n\t\tWREG32(mmDMA0_QM_GLBL_PROT + dma_qm_offset,\n\t\t\t\tQMAN_EXTERNAL_MAKE_TRUSTED);\n\n\t\tWREG32(mmDMA0_QM_GLBL_CFG1 + dma_qm_offset, 0);\n\t}\n}\n\nstatic void gaudi_init_dma_core(struct hl_device *hdev, int dma_id)\n{\n\tu32 dma_offset = dma_id * DMA_CORE_OFFSET;\n\tu32 dma_err_cfg = 1 << DMA0_CORE_ERR_CFG_ERR_MSG_EN_SHIFT;\n\n\t/* Set to maximum possible according to physical size */\n\tWREG32(mmDMA0_CORE_RD_MAX_OUTSTAND + dma_offset, 0);\n\tWREG32(mmDMA0_CORE_RD_MAX_SIZE + dma_offset, 0);\n\n\t/* WA for H/W bug H3-2116 */\n\tWREG32(mmDMA0_CORE_LBW_MAX_OUTSTAND + dma_offset, 15);\n\n\t/* STOP_ON bit implies no completion to operation in case of RAZWI */\n\tif (hdev->stop_on_err)\n\t\tdma_err_cfg |= 1 << DMA0_CORE_ERR_CFG_STOP_ON_ERR_SHIFT;\n\n\tWREG32(mmDMA0_CORE_ERR_CFG + dma_offset, dma_err_cfg);\n\tWREG32(mmDMA0_CORE_ERRMSG_ADDR_LO + dma_offset,\n\t\tlower_32_bits(CFG_BASE + mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR));\n\tWREG32(mmDMA0_CORE_ERRMSG_ADDR_HI + dma_offset,\n\t\tupper_32_bits(CFG_BASE + mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR));\n\tWREG32(mmDMA0_CORE_ERRMSG_WDATA + dma_offset,\n\t\tgaudi_irq_map_table[GAUDI_EVENT_DMA0_CORE].cpu_id + dma_id);\n\tWREG32(mmDMA0_CORE_PROT + dma_offset,\n\t\t\t1 << DMA0_CORE_PROT_ERR_VAL_SHIFT);\n\t/* If the channel is secured, it should be in MMU bypass mode */\n\tWREG32(mmDMA0_CORE_SECURE_PROPS + dma_offset,\n\t\t\t1 << DMA0_CORE_SECURE_PROPS_MMBP_SHIFT);\n\tWREG32(mmDMA0_CORE_CFG_0 + dma_offset, 1 << DMA0_CORE_CFG_0_EN_SHIFT);\n}\n\nstatic void gaudi_enable_qman(struct hl_device *hdev, int dma_id,\n\t\t\t\tu32 enable_mask)\n{\n\tu32 dma_qm_offset = dma_id * DMA_QMAN_OFFSET;\n\n\tWREG32(mmDMA0_QM_GLBL_CFG0 + dma_qm_offset, enable_mask);\n}\n\nstatic void gaudi_init_pci_dma_qmans(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tstruct hl_hw_queue *q;\n\tint i, j, dma_id, cpu_skip, nic_skip, cq_id = 0, q_idx, msi_vec = 0;\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_PCI_DMA)\n\t\treturn;\n\n\tfor (i = 0 ; i < PCI_DMA_NUMBER_OF_CHNLS ; i++) {\n\t\tdma_id = gaudi_dma_assignment[i];\n\t\t/*\n\t\t * For queues after the CPU Q need to add 1 to get the correct\n\t\t * queue. In addition, need to add the CPU EQ and NIC IRQs in\n\t\t * order to get the correct MSI register.\n\t\t */\n\t\tif (dma_id > 1) {\n\t\t\tcpu_skip = 1;\n\t\t\tnic_skip = NIC_NUMBER_OF_ENGINES;\n\t\t} else {\n\t\t\tcpu_skip = 0;\n\t\t\tnic_skip = 0;\n\t\t}\n\n\t\tfor (j = 0 ; j < QMAN_STREAMS ; j++) {\n\t\t\tq_idx = 4 * dma_id + j + cpu_skip;\n\t\t\tq = &hdev->kernel_queues[q_idx];\n\t\t\tq->cq_id = cq_id++;\n\t\t\tq->msi_vec = nic_skip + cpu_skip + msi_vec++;\n\t\t\tgaudi_init_pci_dma_qman(hdev, dma_id, j,\n\t\t\t\t\t\tq->bus_address);\n\t\t}\n\n\t\tgaudi_init_dma_core(hdev, dma_id);\n\n\t\tgaudi_enable_qman(hdev, dma_id, PCI_DMA_QMAN_ENABLE);\n\t}\n\n\tgaudi->hw_cap_initialized |= HW_CAP_PCI_DMA;\n}\n\nstatic void gaudi_init_hbm_dma_qman(struct hl_device *hdev, int dma_id,\n\t\t\t\t\tint qman_id, u64 qman_base_addr)\n{\n\tu32 mtr_base_en_lo, mtr_base_en_hi, mtr_base_ws_lo, mtr_base_ws_hi;\n\tu32 so_base_en_lo, so_base_en_hi, so_base_ws_lo, so_base_ws_hi;\n\tu32 q_off, dma_qm_offset;\n\tu32 dma_qm_err_cfg;\n\n\tdma_qm_offset = dma_id * DMA_QMAN_OFFSET;\n\n\tmtr_base_en_lo = lower_32_bits(CFG_BASE +\n\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tmtr_base_en_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tso_base_en_lo = lower_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\tso_base_en_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\tmtr_base_ws_lo = lower_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tmtr_base_ws_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tso_base_ws_lo = lower_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\tso_base_ws_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\n\tq_off = dma_qm_offset + qman_id * 4;\n\n\tif (qman_id < 4) {\n\t\tWREG32(mmDMA0_QM_PQ_BASE_LO_0 + q_off,\n\t\t\t\t\tlower_32_bits(qman_base_addr));\n\t\tWREG32(mmDMA0_QM_PQ_BASE_HI_0 + q_off,\n\t\t\t\t\tupper_32_bits(qman_base_addr));\n\n\t\tWREG32(mmDMA0_QM_PQ_SIZE_0 + q_off, ilog2(HBM_DMA_QMAN_LENGTH));\n\t\tWREG32(mmDMA0_QM_PQ_PI_0 + q_off, 0);\n\t\tWREG32(mmDMA0_QM_PQ_CI_0 + q_off, 0);\n\n\t\tWREG32(mmDMA0_QM_CP_LDMA_TSIZE_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_CPDMA_SIZE_OFFSET);\n\t\tWREG32(mmDMA0_QM_CP_LDMA_SRC_BASE_LO_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_CPDMA_SRC_OFFSET);\n\t\tWREG32(mmDMA0_QM_CP_LDMA_DST_BASE_LO_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_CPDMA_DST_OFFSET);\n\t} else {\n\t\tWREG32(mmDMA0_QM_CP_LDMA_TSIZE_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_LDMA_SIZE_OFFSET);\n\t\tWREG32(mmDMA0_QM_CP_LDMA_SRC_BASE_LO_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_LDMA_SRC_OFFSET);\n\t\tWREG32(mmDMA0_QM_CP_LDMA_DST_BASE_LO_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_LDMA_DST_OFFSET);\n\n\t\t/* Configure RAZWI IRQ */\n\t\tdma_qm_err_cfg = HBM_DMA_QMAN_GLBL_ERR_CFG_MSG_EN_MASK;\n\t\tif (hdev->stop_on_err) {\n\t\t\tdma_qm_err_cfg |=\n\t\t\t\tHBM_DMA_QMAN_GLBL_ERR_CFG_STOP_ON_ERR_EN_MASK;\n\t\t}\n\t\tWREG32(mmDMA0_QM_GLBL_ERR_CFG + dma_qm_offset, dma_qm_err_cfg);\n\n\t\tWREG32(mmDMA0_QM_GLBL_ERR_ADDR_LO + dma_qm_offset,\n\t\t\tlower_32_bits(CFG_BASE +\n\t\t\t\t\tmmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR));\n\t\tWREG32(mmDMA0_QM_GLBL_ERR_ADDR_HI + dma_qm_offset,\n\t\t\tupper_32_bits(CFG_BASE +\n\t\t\t\t\tmmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR));\n\t\tWREG32(mmDMA0_QM_GLBL_ERR_WDATA + dma_qm_offset,\n\t\t\tgaudi_irq_map_table[GAUDI_EVENT_DMA0_QM].cpu_id +\n\t\t\t\t\t\t\t\t\tdma_id);\n\n\t\tWREG32(mmDMA0_QM_ARB_ERR_MSG_EN + dma_qm_offset,\n\t\t\t\tQM_ARB_ERR_MSG_EN_MASK);\n\n\t\t/* Increase ARB WDT to support streams architecture */\n\t\tWREG32(mmDMA0_QM_ARB_SLV_CHOISE_WDT + dma_qm_offset,\n\t\t\t\tGAUDI_ARB_WDT_TIMEOUT);\n\n\t\tWREG32(mmDMA0_QM_GLBL_CFG1 + dma_qm_offset, 0);\n\t\tWREG32(mmDMA0_QM_GLBL_PROT + dma_qm_offset,\n\t\t\t\tQMAN_INTERNAL_MAKE_TRUSTED);\n\t}\n\n\tWREG32(mmDMA0_QM_CP_MSG_BASE0_ADDR_LO_0 + q_off, mtr_base_en_lo);\n\tWREG32(mmDMA0_QM_CP_MSG_BASE0_ADDR_HI_0 + q_off, mtr_base_en_hi);\n\tWREG32(mmDMA0_QM_CP_MSG_BASE1_ADDR_LO_0 + q_off, so_base_en_lo);\n\tWREG32(mmDMA0_QM_CP_MSG_BASE1_ADDR_HI_0 + q_off, so_base_en_hi);\n\n\t/* Configure DMA5 CP_MSG_BASE 2/3 for sync stream collective */\n\tif (gaudi_dma_assignment[dma_id] == GAUDI_ENGINE_ID_DMA_5) {\n\t\tWREG32(mmDMA0_QM_CP_MSG_BASE2_ADDR_LO_0 + q_off,\n\t\t\t\tmtr_base_ws_lo);\n\t\tWREG32(mmDMA0_QM_CP_MSG_BASE2_ADDR_HI_0 + q_off,\n\t\t\t\tmtr_base_ws_hi);\n\t\tWREG32(mmDMA0_QM_CP_MSG_BASE3_ADDR_LO_0 + q_off,\n\t\t\t\tso_base_ws_lo);\n\t\tWREG32(mmDMA0_QM_CP_MSG_BASE3_ADDR_HI_0 + q_off,\n\t\t\t\tso_base_ws_hi);\n\t}\n}\n\nstatic void gaudi_init_hbm_dma_qmans(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tstruct gaudi_internal_qman_info *q;\n\tu64 qman_base_addr;\n\tint i, j, dma_id, internal_q_index;\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_HBM_DMA)\n\t\treturn;\n\n\tfor (i = 0 ; i < HBM_DMA_NUMBER_OF_CHNLS ; i++) {\n\t\tdma_id = gaudi_dma_assignment[GAUDI_HBM_DMA_1 + i];\n\n\t\tfor (j = 0 ; j < QMAN_STREAMS ; j++) {\n\t\t\t /*\n\t\t\t  * Add the CPU queue in order to get the correct queue\n\t\t\t  * number as all internal queue are placed after it\n\t\t\t  */\n\t\t\tinternal_q_index = dma_id * QMAN_STREAMS + j + 1;\n\n\t\t\tq = &gaudi->internal_qmans[internal_q_index];\n\t\t\tqman_base_addr = (u64) q->pq_dma_addr;\n\t\t\tgaudi_init_hbm_dma_qman(hdev, dma_id, j,\n\t\t\t\t\t\tqman_base_addr);\n\t\t}\n\n\t\t/* Initializing lower CP for HBM DMA QMAN */\n\t\tgaudi_init_hbm_dma_qman(hdev, dma_id, 4, 0);\n\n\t\tgaudi_init_dma_core(hdev, dma_id);\n\n\t\tgaudi_enable_qman(hdev, dma_id, HBM_DMA_QMAN_ENABLE);\n\t}\n\n\tgaudi->hw_cap_initialized |= HW_CAP_HBM_DMA;\n}\n\nstatic void gaudi_init_mme_qman(struct hl_device *hdev, u32 mme_offset,\n\t\t\t\t\tint qman_id, u64 qman_base_addr)\n{\n\tu32 mtr_base_lo, mtr_base_hi;\n\tu32 so_base_lo, so_base_hi;\n\tu32 q_off, mme_id;\n\tu32 mme_qm_err_cfg;\n\n\tmtr_base_lo = lower_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tmtr_base_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tso_base_lo = lower_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\tso_base_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\n\tq_off = mme_offset + qman_id * 4;\n\n\tif (qman_id < 4) {\n\t\tWREG32(mmMME0_QM_PQ_BASE_LO_0 + q_off,\n\t\t\t\t\tlower_32_bits(qman_base_addr));\n\t\tWREG32(mmMME0_QM_PQ_BASE_HI_0 + q_off,\n\t\t\t\t\tupper_32_bits(qman_base_addr));\n\n\t\tWREG32(mmMME0_QM_PQ_SIZE_0 + q_off, ilog2(MME_QMAN_LENGTH));\n\t\tWREG32(mmMME0_QM_PQ_PI_0 + q_off, 0);\n\t\tWREG32(mmMME0_QM_PQ_CI_0 + q_off, 0);\n\n\t\tWREG32(mmMME0_QM_CP_LDMA_TSIZE_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_CPDMA_SIZE_OFFSET);\n\t\tWREG32(mmMME0_QM_CP_LDMA_SRC_BASE_LO_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_CPDMA_SRC_OFFSET);\n\t\tWREG32(mmMME0_QM_CP_LDMA_DST_BASE_LO_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_CPDMA_DST_OFFSET);\n\t} else {\n\t\tWREG32(mmMME0_QM_CP_LDMA_TSIZE_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_LDMA_SIZE_OFFSET);\n\t\tWREG32(mmMME0_QM_CP_LDMA_SRC_BASE_LO_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_LDMA_SRC_OFFSET);\n\t\tWREG32(mmMME0_QM_CP_LDMA_DST_BASE_LO_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_LDMA_DST_OFFSET);\n\n\t\t/* Configure RAZWI IRQ */\n\t\tmme_id = mme_offset /\n\t\t\t\t(mmMME1_QM_GLBL_CFG0 - mmMME0_QM_GLBL_CFG0);\n\n\t\tmme_qm_err_cfg = MME_QMAN_GLBL_ERR_CFG_MSG_EN_MASK;\n\t\tif (hdev->stop_on_err) {\n\t\t\tmme_qm_err_cfg |=\n\t\t\t\tMME_QMAN_GLBL_ERR_CFG_STOP_ON_ERR_EN_MASK;\n\t\t}\n\t\tWREG32(mmMME0_QM_GLBL_ERR_CFG + mme_offset, mme_qm_err_cfg);\n\t\tWREG32(mmMME0_QM_GLBL_ERR_ADDR_LO + mme_offset,\n\t\t\tlower_32_bits(CFG_BASE +\n\t\t\t\t\tmmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR));\n\t\tWREG32(mmMME0_QM_GLBL_ERR_ADDR_HI + mme_offset,\n\t\t\tupper_32_bits(CFG_BASE +\n\t\t\t\t\tmmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR));\n\t\tWREG32(mmMME0_QM_GLBL_ERR_WDATA + mme_offset,\n\t\t\tgaudi_irq_map_table[GAUDI_EVENT_MME0_QM].cpu_id +\n\t\t\t\t\t\t\t\t\tmme_id);\n\n\t\tWREG32(mmMME0_QM_ARB_ERR_MSG_EN + mme_offset,\n\t\t\t\tQM_ARB_ERR_MSG_EN_MASK);\n\n\t\t/* Increase ARB WDT to support streams architecture */\n\t\tWREG32(mmMME0_QM_ARB_SLV_CHOISE_WDT + mme_offset,\n\t\t\t\tGAUDI_ARB_WDT_TIMEOUT);\n\n\t\tWREG32(mmMME0_QM_GLBL_CFG1 + mme_offset, 0);\n\t\tWREG32(mmMME0_QM_GLBL_PROT + mme_offset,\n\t\t\t\tQMAN_INTERNAL_MAKE_TRUSTED);\n\t}\n\n\tWREG32(mmMME0_QM_CP_MSG_BASE0_ADDR_LO_0 + q_off, mtr_base_lo);\n\tWREG32(mmMME0_QM_CP_MSG_BASE0_ADDR_HI_0 + q_off, mtr_base_hi);\n\tWREG32(mmMME0_QM_CP_MSG_BASE1_ADDR_LO_0 + q_off, so_base_lo);\n\tWREG32(mmMME0_QM_CP_MSG_BASE1_ADDR_HI_0 + q_off, so_base_hi);\n}\n\nstatic void gaudi_init_mme_qmans(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tstruct gaudi_internal_qman_info *q;\n\tu64 qman_base_addr;\n\tu32 mme_offset;\n\tint i, internal_q_index;\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_MME)\n\t\treturn;\n\n\t/*\n\t * map GAUDI_QUEUE_ID_MME_0_X to the N_W_MME (mmMME2_QM_BASE)\n\t * and GAUDI_QUEUE_ID_MME_1_X to the S_W_MME (mmMME0_QM_BASE)\n\t */\n\n\tmme_offset = mmMME2_QM_GLBL_CFG0 - mmMME0_QM_GLBL_CFG0;\n\n\tfor (i = 0 ; i < MME_NUMBER_OF_QMANS ; i++) {\n\t\tinternal_q_index = GAUDI_QUEUE_ID_MME_0_0 + i;\n\t\tq = &gaudi->internal_qmans[internal_q_index];\n\t\tqman_base_addr = (u64) q->pq_dma_addr;\n\t\tgaudi_init_mme_qman(hdev, mme_offset, (i & 0x3),\n\t\t\t\t\tqman_base_addr);\n\t\tif (i == 3)\n\t\t\tmme_offset = 0;\n\t}\n\n\t/* Initializing lower CP for MME QMANs */\n\tmme_offset = mmMME2_QM_GLBL_CFG0 - mmMME0_QM_GLBL_CFG0;\n\tgaudi_init_mme_qman(hdev, mme_offset, 4, 0);\n\tgaudi_init_mme_qman(hdev, 0, 4, 0);\n\n\tWREG32(mmMME2_QM_GLBL_CFG0, QMAN_MME_ENABLE);\n\tWREG32(mmMME0_QM_GLBL_CFG0, QMAN_MME_ENABLE);\n\n\tgaudi->hw_cap_initialized |= HW_CAP_MME;\n}\n\nstatic void gaudi_init_tpc_qman(struct hl_device *hdev, u32 tpc_offset,\n\t\t\t\tint qman_id, u64 qman_base_addr)\n{\n\tu32 mtr_base_en_lo, mtr_base_en_hi, mtr_base_ws_lo, mtr_base_ws_hi;\n\tu32 so_base_en_lo, so_base_en_hi, so_base_ws_lo, so_base_ws_hi;\n\tu32 q_off, tpc_id;\n\tu32 tpc_qm_err_cfg;\n\n\tmtr_base_en_lo = lower_32_bits(CFG_BASE +\n\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tmtr_base_en_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tso_base_en_lo = lower_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\tso_base_en_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\tmtr_base_ws_lo = lower_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tmtr_base_ws_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tso_base_ws_lo = lower_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\tso_base_ws_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\n\tq_off = tpc_offset + qman_id * 4;\n\n\ttpc_id = tpc_offset /\n\t\t\t(mmTPC1_QM_GLBL_CFG0 - mmTPC0_QM_GLBL_CFG0);\n\n\tif (qman_id < 4) {\n\t\tWREG32(mmTPC0_QM_PQ_BASE_LO_0 + q_off,\n\t\t\t\t\tlower_32_bits(qman_base_addr));\n\t\tWREG32(mmTPC0_QM_PQ_BASE_HI_0 + q_off,\n\t\t\t\t\tupper_32_bits(qman_base_addr));\n\n\t\tWREG32(mmTPC0_QM_PQ_SIZE_0 + q_off, ilog2(TPC_QMAN_LENGTH));\n\t\tWREG32(mmTPC0_QM_PQ_PI_0 + q_off, 0);\n\t\tWREG32(mmTPC0_QM_PQ_CI_0 + q_off, 0);\n\n\t\tWREG32(mmTPC0_QM_CP_LDMA_TSIZE_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_CPDMA_SIZE_OFFSET);\n\t\tWREG32(mmTPC0_QM_CP_LDMA_SRC_BASE_LO_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_CPDMA_SRC_OFFSET);\n\t\tWREG32(mmTPC0_QM_CP_LDMA_DST_BASE_LO_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_CPDMA_DST_OFFSET);\n\t} else {\n\t\tWREG32(mmTPC0_QM_CP_LDMA_TSIZE_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_LDMA_SIZE_OFFSET);\n\t\tWREG32(mmTPC0_QM_CP_LDMA_SRC_BASE_LO_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_LDMA_SRC_OFFSET);\n\t\tWREG32(mmTPC0_QM_CP_LDMA_DST_BASE_LO_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_LDMA_DST_OFFSET);\n\n\t\t/* Configure RAZWI IRQ */\n\t\ttpc_qm_err_cfg = TPC_QMAN_GLBL_ERR_CFG_MSG_EN_MASK;\n\t\tif (hdev->stop_on_err) {\n\t\t\ttpc_qm_err_cfg |=\n\t\t\t\tTPC_QMAN_GLBL_ERR_CFG_STOP_ON_ERR_EN_MASK;\n\t\t}\n\n\t\tWREG32(mmTPC0_QM_GLBL_ERR_CFG + tpc_offset, tpc_qm_err_cfg);\n\t\tWREG32(mmTPC0_QM_GLBL_ERR_ADDR_LO + tpc_offset,\n\t\t\tlower_32_bits(CFG_BASE +\n\t\t\t\tmmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR));\n\t\tWREG32(mmTPC0_QM_GLBL_ERR_ADDR_HI + tpc_offset,\n\t\t\tupper_32_bits(CFG_BASE +\n\t\t\t\tmmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR));\n\t\tWREG32(mmTPC0_QM_GLBL_ERR_WDATA + tpc_offset,\n\t\t\tgaudi_irq_map_table[GAUDI_EVENT_TPC0_QM].cpu_id +\n\t\t\t\t\t\t\t\t\ttpc_id);\n\n\t\tWREG32(mmTPC0_QM_ARB_ERR_MSG_EN + tpc_offset,\n\t\t\t\tQM_ARB_ERR_MSG_EN_MASK);\n\n\t\t/* Increase ARB WDT to support streams architecture */\n\t\tWREG32(mmTPC0_QM_ARB_SLV_CHOISE_WDT + tpc_offset,\n\t\t\t\tGAUDI_ARB_WDT_TIMEOUT);\n\n\t\tWREG32(mmTPC0_QM_GLBL_CFG1 + tpc_offset, 0);\n\t\tWREG32(mmTPC0_QM_GLBL_PROT + tpc_offset,\n\t\t\t\tQMAN_INTERNAL_MAKE_TRUSTED);\n\t}\n\n\tWREG32(mmTPC0_QM_CP_MSG_BASE0_ADDR_LO_0 + q_off, mtr_base_en_lo);\n\tWREG32(mmTPC0_QM_CP_MSG_BASE0_ADDR_HI_0 + q_off, mtr_base_en_hi);\n\tWREG32(mmTPC0_QM_CP_MSG_BASE1_ADDR_LO_0 + q_off, so_base_en_lo);\n\tWREG32(mmTPC0_QM_CP_MSG_BASE1_ADDR_HI_0 + q_off, so_base_en_hi);\n\n\t/* Configure TPC7 CP_MSG_BASE 2/3 for sync stream collective */\n\tif (tpc_id == 6) {\n\t\tWREG32(mmTPC0_QM_CP_MSG_BASE2_ADDR_LO_0 + q_off,\n\t\t\t\tmtr_base_ws_lo);\n\t\tWREG32(mmTPC0_QM_CP_MSG_BASE2_ADDR_HI_0 + q_off,\n\t\t\t\tmtr_base_ws_hi);\n\t\tWREG32(mmTPC0_QM_CP_MSG_BASE3_ADDR_LO_0 + q_off,\n\t\t\t\tso_base_ws_lo);\n\t\tWREG32(mmTPC0_QM_CP_MSG_BASE3_ADDR_HI_0 + q_off,\n\t\t\t\tso_base_ws_hi);\n\t}\n}\n\nstatic void gaudi_init_tpc_qmans(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tstruct gaudi_internal_qman_info *q;\n\tu64 qman_base_addr;\n\tu32 so_base_hi, tpc_offset = 0;\n\tu32 tpc_delta = mmTPC1_CFG_SM_BASE_ADDRESS_HIGH -\n\t\t\tmmTPC0_CFG_SM_BASE_ADDRESS_HIGH;\n\tint i, tpc_id, internal_q_index;\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_TPC_MASK)\n\t\treturn;\n\n\tso_base_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\n\tfor (tpc_id = 0 ; tpc_id < TPC_NUMBER_OF_ENGINES ; tpc_id++) {\n\t\tfor (i = 0 ; i < QMAN_STREAMS ; i++) {\n\t\t\tinternal_q_index = GAUDI_QUEUE_ID_TPC_0_0 +\n\t\t\t\t\t\ttpc_id * QMAN_STREAMS + i;\n\t\t\tq = &gaudi->internal_qmans[internal_q_index];\n\t\t\tqman_base_addr = (u64) q->pq_dma_addr;\n\t\t\tgaudi_init_tpc_qman(hdev, tpc_offset, i,\n\t\t\t\t\t\tqman_base_addr);\n\n\t\t\tif (i == 3) {\n\t\t\t\t/* Initializing lower CP for TPC QMAN */\n\t\t\t\tgaudi_init_tpc_qman(hdev, tpc_offset, 4, 0);\n\n\t\t\t\t/* Enable the QMAN and TPC channel */\n\t\t\t\tWREG32(mmTPC0_QM_GLBL_CFG0 + tpc_offset,\n\t\t\t\t\t\tQMAN_TPC_ENABLE);\n\t\t\t}\n\t\t}\n\n\t\tWREG32(mmTPC0_CFG_SM_BASE_ADDRESS_HIGH + tpc_id * tpc_delta,\n\t\t\t\tso_base_hi);\n\n\t\ttpc_offset += mmTPC1_QM_GLBL_CFG0 - mmTPC0_QM_GLBL_CFG0;\n\n\t\tgaudi->hw_cap_initialized |=\n\t\t\t\tFIELD_PREP(HW_CAP_TPC_MASK, 1 << tpc_id);\n\t}\n}\n\nstatic void gaudi_init_nic_qman(struct hl_device *hdev, u32 nic_offset,\n\t\t\t\tint qman_id, u64 qman_base_addr, int nic_id)\n{\n\tu32 mtr_base_en_lo, mtr_base_en_hi, mtr_base_ws_lo, mtr_base_ws_hi;\n\tu32 so_base_en_lo, so_base_en_hi, so_base_ws_lo, so_base_ws_hi;\n\tu32 q_off;\n\tu32 nic_qm_err_cfg;\n\n\tmtr_base_en_lo = lower_32_bits(CFG_BASE +\n\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tmtr_base_en_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tso_base_en_lo = lower_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\tso_base_en_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\tmtr_base_ws_lo = lower_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tmtr_base_ws_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0);\n\tso_base_ws_lo = lower_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\tso_base_ws_hi = upper_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_SOB_OBJ_0);\n\n\tq_off = nic_offset + qman_id * 4;\n\n\tWREG32(mmNIC0_QM0_PQ_BASE_LO_0 + q_off, lower_32_bits(qman_base_addr));\n\tWREG32(mmNIC0_QM0_PQ_BASE_HI_0 + q_off, upper_32_bits(qman_base_addr));\n\n\tWREG32(mmNIC0_QM0_PQ_SIZE_0 + q_off, ilog2(NIC_QMAN_LENGTH));\n\tWREG32(mmNIC0_QM0_PQ_PI_0 + q_off, 0);\n\tWREG32(mmNIC0_QM0_PQ_CI_0 + q_off, 0);\n\n\tWREG32(mmNIC0_QM0_CP_LDMA_TSIZE_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_LDMA_SIZE_OFFSET);\n\tWREG32(mmNIC0_QM0_CP_LDMA_SRC_BASE_LO_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_LDMA_SRC_OFFSET);\n\tWREG32(mmNIC0_QM0_CP_LDMA_DST_BASE_LO_OFFSET_0 + q_off,\n\t\t\t\t\t\t\tQMAN_LDMA_DST_OFFSET);\n\n\tWREG32(mmNIC0_QM0_CP_MSG_BASE0_ADDR_LO_0 + q_off, mtr_base_en_lo);\n\tWREG32(mmNIC0_QM0_CP_MSG_BASE0_ADDR_HI_0 + q_off, mtr_base_en_hi);\n\tWREG32(mmNIC0_QM0_CP_MSG_BASE1_ADDR_LO_0 + q_off, so_base_en_lo);\n\tWREG32(mmNIC0_QM0_CP_MSG_BASE1_ADDR_HI_0 + q_off, so_base_en_hi);\n\n\t/* Configure NIC CP_MSG_BASE 2/3 for sync stream collective */\n\tWREG32(mmNIC0_QM0_CP_MSG_BASE2_ADDR_LO_0 + q_off, mtr_base_ws_lo);\n\tWREG32(mmNIC0_QM0_CP_MSG_BASE2_ADDR_HI_0 + q_off, mtr_base_ws_hi);\n\tWREG32(mmNIC0_QM0_CP_MSG_BASE3_ADDR_LO_0 + q_off, so_base_ws_lo);\n\tWREG32(mmNIC0_QM0_CP_MSG_BASE3_ADDR_HI_0 + q_off, so_base_ws_hi);\n\n\tif (qman_id == 0) {\n\t\t/* Configure RAZWI IRQ */\n\t\tnic_qm_err_cfg = NIC_QMAN_GLBL_ERR_CFG_MSG_EN_MASK;\n\t\tif (hdev->stop_on_err) {\n\t\t\tnic_qm_err_cfg |=\n\t\t\t\tNIC_QMAN_GLBL_ERR_CFG_STOP_ON_ERR_EN_MASK;\n\t\t}\n\n\t\tWREG32(mmNIC0_QM0_GLBL_ERR_CFG + nic_offset, nic_qm_err_cfg);\n\t\tWREG32(mmNIC0_QM0_GLBL_ERR_ADDR_LO + nic_offset,\n\t\t\tlower_32_bits(CFG_BASE +\n\t\t\t\tmmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR));\n\t\tWREG32(mmNIC0_QM0_GLBL_ERR_ADDR_HI + nic_offset,\n\t\t\tupper_32_bits(CFG_BASE +\n\t\t\t\tmmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR));\n\t\tWREG32(mmNIC0_QM0_GLBL_ERR_WDATA + nic_offset,\n\t\t\tgaudi_irq_map_table[GAUDI_EVENT_NIC0_QM0].cpu_id +\n\t\t\t\t\t\t\t\t\tnic_id);\n\n\t\tWREG32(mmNIC0_QM0_ARB_ERR_MSG_EN + nic_offset,\n\t\t\t\tQM_ARB_ERR_MSG_EN_MASK);\n\n\t\t/* Increase ARB WDT to support streams architecture */\n\t\tWREG32(mmNIC0_QM0_ARB_SLV_CHOISE_WDT + nic_offset,\n\t\t\t\tGAUDI_ARB_WDT_TIMEOUT);\n\n\t\tWREG32(mmNIC0_QM0_GLBL_CFG1 + nic_offset, 0);\n\t\tWREG32(mmNIC0_QM0_GLBL_PROT + nic_offset,\n\t\t\t\tQMAN_INTERNAL_MAKE_TRUSTED);\n\t}\n}\n\nstatic void gaudi_init_nic_qmans(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tstruct gaudi_internal_qman_info *q;\n\tu64 qman_base_addr;\n\tu32 nic_offset = 0;\n\tu32 nic_delta_between_qmans =\n\t\t\tmmNIC0_QM1_GLBL_CFG0 - mmNIC0_QM0_GLBL_CFG0;\n\tu32 nic_delta_between_nics =\n\t\t\tmmNIC1_QM0_GLBL_CFG0 - mmNIC0_QM0_GLBL_CFG0;\n\tint i, nic_id, internal_q_index;\n\n\tif (!hdev->nic_ports_mask)\n\t\treturn;\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_NIC_MASK)\n\t\treturn;\n\n\tdev_dbg(hdev->dev, \"Initializing NIC QMANs\\n\");\n\n\tfor (nic_id = 0 ; nic_id < NIC_NUMBER_OF_ENGINES ; nic_id++) {\n\t\tif (!(hdev->nic_ports_mask & (1 << nic_id))) {\n\t\t\tnic_offset += nic_delta_between_qmans;\n\t\t\tif (nic_id & 1) {\n\t\t\t\tnic_offset -= (nic_delta_between_qmans * 2);\n\t\t\t\tnic_offset += nic_delta_between_nics;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0 ; i < QMAN_STREAMS ; i++) {\n\t\t\tinternal_q_index = GAUDI_QUEUE_ID_NIC_0_0 +\n\t\t\t\t\t\tnic_id * QMAN_STREAMS + i;\n\t\t\tq = &gaudi->internal_qmans[internal_q_index];\n\t\t\tqman_base_addr = (u64) q->pq_dma_addr;\n\t\t\tgaudi_init_nic_qman(hdev, nic_offset, (i & 0x3),\n\t\t\t\t\t\tqman_base_addr, nic_id);\n\t\t}\n\n\t\t/* Enable the QMAN */\n\t\tWREG32(mmNIC0_QM0_GLBL_CFG0 + nic_offset, NIC_QMAN_ENABLE);\n\n\t\tnic_offset += nic_delta_between_qmans;\n\t\tif (nic_id & 1) {\n\t\t\tnic_offset -= (nic_delta_between_qmans * 2);\n\t\t\tnic_offset += nic_delta_between_nics;\n\t\t}\n\n\t\tgaudi->hw_cap_initialized |= 1 << (HW_CAP_NIC_SHIFT + nic_id);\n\t}\n}\n\nstatic void gaudi_disable_pci_dma_qmans(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_PCI_DMA))\n\t\treturn;\n\n\tWREG32(mmDMA0_QM_GLBL_CFG0, 0);\n\tWREG32(mmDMA1_QM_GLBL_CFG0, 0);\n\tWREG32(mmDMA5_QM_GLBL_CFG0, 0);\n}\n\nstatic void gaudi_disable_hbm_dma_qmans(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_HBM_DMA))\n\t\treturn;\n\n\tWREG32(mmDMA2_QM_GLBL_CFG0, 0);\n\tWREG32(mmDMA3_QM_GLBL_CFG0, 0);\n\tWREG32(mmDMA4_QM_GLBL_CFG0, 0);\n\tWREG32(mmDMA6_QM_GLBL_CFG0, 0);\n\tWREG32(mmDMA7_QM_GLBL_CFG0, 0);\n}\n\nstatic void gaudi_disable_mme_qmans(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_MME))\n\t\treturn;\n\n\tWREG32(mmMME2_QM_GLBL_CFG0, 0);\n\tWREG32(mmMME0_QM_GLBL_CFG0, 0);\n}\n\nstatic void gaudi_disable_tpc_qmans(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu32 tpc_offset = 0;\n\tint tpc_id;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_TPC_MASK))\n\t\treturn;\n\n\tfor (tpc_id = 0 ; tpc_id < TPC_NUMBER_OF_ENGINES ; tpc_id++) {\n\t\tWREG32(mmTPC0_QM_GLBL_CFG0 + tpc_offset, 0);\n\t\ttpc_offset += mmTPC1_QM_GLBL_CFG0 - mmTPC0_QM_GLBL_CFG0;\n\t}\n}\n\nstatic void gaudi_disable_nic_qmans(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu32 nic_mask, nic_offset = 0;\n\tu32 nic_delta_between_qmans =\n\t\t\tmmNIC0_QM1_GLBL_CFG0 - mmNIC0_QM0_GLBL_CFG0;\n\tu32 nic_delta_between_nics =\n\t\t\tmmNIC1_QM0_GLBL_CFG0 - mmNIC0_QM0_GLBL_CFG0;\n\tint nic_id;\n\n\tfor (nic_id = 0 ; nic_id < NIC_NUMBER_OF_ENGINES ; nic_id++) {\n\t\tnic_mask = 1 << (HW_CAP_NIC_SHIFT + nic_id);\n\n\t\tif (gaudi->hw_cap_initialized & nic_mask)\n\t\t\tWREG32(mmNIC0_QM0_GLBL_CFG0 + nic_offset, 0);\n\n\t\tnic_offset += nic_delta_between_qmans;\n\t\tif (nic_id & 1) {\n\t\t\tnic_offset -= (nic_delta_between_qmans * 2);\n\t\t\tnic_offset += nic_delta_between_nics;\n\t\t}\n\t}\n}\n\nstatic void gaudi_stop_pci_dma_qmans(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_PCI_DMA))\n\t\treturn;\n\n\t/* Stop upper CPs of QMANs 0.0 to 1.3 and 5.0 to 5.3 */\n\tWREG32(mmDMA0_QM_GLBL_CFG1, 0xF << DMA0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n\tWREG32(mmDMA1_QM_GLBL_CFG1, 0xF << DMA0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n\tWREG32(mmDMA5_QM_GLBL_CFG1, 0xF << DMA0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n}\n\nstatic void gaudi_stop_hbm_dma_qmans(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_HBM_DMA))\n\t\treturn;\n\n\t/* Stop CPs of HBM DMA QMANs */\n\n\tWREG32(mmDMA2_QM_GLBL_CFG1, 0x1F << DMA0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n\tWREG32(mmDMA3_QM_GLBL_CFG1, 0x1F << DMA0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n\tWREG32(mmDMA4_QM_GLBL_CFG1, 0x1F << DMA0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n\tWREG32(mmDMA6_QM_GLBL_CFG1, 0x1F << DMA0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n\tWREG32(mmDMA7_QM_GLBL_CFG1, 0x1F << DMA0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n}\n\nstatic void gaudi_stop_mme_qmans(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_MME))\n\t\treturn;\n\n\t/* Stop CPs of MME QMANs */\n\tWREG32(mmMME2_QM_GLBL_CFG1, 0x1F << MME0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n\tWREG32(mmMME0_QM_GLBL_CFG1, 0x1F << MME0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n}\n\nstatic void gaudi_stop_tpc_qmans(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_TPC_MASK))\n\t\treturn;\n\n\tWREG32(mmTPC0_QM_GLBL_CFG1, 0x1F << TPC0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n\tWREG32(mmTPC1_QM_GLBL_CFG1, 0x1F << TPC0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n\tWREG32(mmTPC2_QM_GLBL_CFG1, 0x1F << TPC0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n\tWREG32(mmTPC3_QM_GLBL_CFG1, 0x1F << TPC0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n\tWREG32(mmTPC4_QM_GLBL_CFG1, 0x1F << TPC0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n\tWREG32(mmTPC5_QM_GLBL_CFG1, 0x1F << TPC0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n\tWREG32(mmTPC6_QM_GLBL_CFG1, 0x1F << TPC0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n\tWREG32(mmTPC7_QM_GLBL_CFG1, 0x1F << TPC0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n}\n\nstatic void gaudi_stop_nic_qmans(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\t/* Stop upper CPs of QMANs */\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_NIC0)\n\t\tWREG32(mmNIC0_QM0_GLBL_CFG1,\n\t\t\t\tNIC0_QM0_GLBL_CFG1_PQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CP_STOP_MASK);\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_NIC1)\n\t\tWREG32(mmNIC0_QM1_GLBL_CFG1,\n\t\t\t\tNIC0_QM0_GLBL_CFG1_PQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CP_STOP_MASK);\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_NIC2)\n\t\tWREG32(mmNIC1_QM0_GLBL_CFG1,\n\t\t\t\tNIC0_QM0_GLBL_CFG1_PQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CP_STOP_MASK);\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_NIC3)\n\t\tWREG32(mmNIC1_QM1_GLBL_CFG1,\n\t\t\t\tNIC0_QM0_GLBL_CFG1_PQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CP_STOP_MASK);\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_NIC4)\n\t\tWREG32(mmNIC2_QM0_GLBL_CFG1,\n\t\t\t\tNIC0_QM0_GLBL_CFG1_PQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CP_STOP_MASK);\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_NIC5)\n\t\tWREG32(mmNIC2_QM1_GLBL_CFG1,\n\t\t\t\tNIC0_QM0_GLBL_CFG1_PQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CP_STOP_MASK);\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_NIC6)\n\t\tWREG32(mmNIC3_QM0_GLBL_CFG1,\n\t\t\t\tNIC0_QM0_GLBL_CFG1_PQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CP_STOP_MASK);\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_NIC7)\n\t\tWREG32(mmNIC3_QM1_GLBL_CFG1,\n\t\t\t\tNIC0_QM0_GLBL_CFG1_PQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CP_STOP_MASK);\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_NIC8)\n\t\tWREG32(mmNIC4_QM0_GLBL_CFG1,\n\t\t\t\tNIC0_QM0_GLBL_CFG1_PQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CP_STOP_MASK);\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_NIC9)\n\t\tWREG32(mmNIC4_QM1_GLBL_CFG1,\n\t\t\t\tNIC0_QM0_GLBL_CFG1_PQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CQF_STOP_MASK |\n\t\t\t\tNIC0_QM0_GLBL_CFG1_CP_STOP_MASK);\n}\n\nstatic void gaudi_pci_dma_stall(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_PCI_DMA))\n\t\treturn;\n\n\tWREG32(mmDMA0_CORE_CFG_1, 1 << DMA0_CORE_CFG_1_HALT_SHIFT);\n\tWREG32(mmDMA1_CORE_CFG_1, 1 << DMA0_CORE_CFG_1_HALT_SHIFT);\n\tWREG32(mmDMA5_CORE_CFG_1, 1 << DMA0_CORE_CFG_1_HALT_SHIFT);\n}\n\nstatic void gaudi_hbm_dma_stall(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_HBM_DMA))\n\t\treturn;\n\n\tWREG32(mmDMA2_CORE_CFG_1, 1 << DMA0_CORE_CFG_1_HALT_SHIFT);\n\tWREG32(mmDMA3_CORE_CFG_1, 1 << DMA0_CORE_CFG_1_HALT_SHIFT);\n\tWREG32(mmDMA4_CORE_CFG_1, 1 << DMA0_CORE_CFG_1_HALT_SHIFT);\n\tWREG32(mmDMA6_CORE_CFG_1, 1 << DMA0_CORE_CFG_1_HALT_SHIFT);\n\tWREG32(mmDMA7_CORE_CFG_1, 1 << DMA0_CORE_CFG_1_HALT_SHIFT);\n}\n\nstatic void gaudi_mme_stall(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_MME))\n\t\treturn;\n\n\t/* WA for H3-1800 bug: do ACC and SBAB writes twice */\n\tWREG32(mmMME0_ACC_ACC_STALL, 1 << MME_ACC_ACC_STALL_R_SHIFT);\n\tWREG32(mmMME0_ACC_ACC_STALL, 1 << MME_ACC_ACC_STALL_R_SHIFT);\n\tWREG32(mmMME0_SBAB_SB_STALL, 1 << MME_SBAB_SB_STALL_R_SHIFT);\n\tWREG32(mmMME0_SBAB_SB_STALL, 1 << MME_SBAB_SB_STALL_R_SHIFT);\n\tWREG32(mmMME1_ACC_ACC_STALL, 1 << MME_ACC_ACC_STALL_R_SHIFT);\n\tWREG32(mmMME1_ACC_ACC_STALL, 1 << MME_ACC_ACC_STALL_R_SHIFT);\n\tWREG32(mmMME1_SBAB_SB_STALL, 1 << MME_SBAB_SB_STALL_R_SHIFT);\n\tWREG32(mmMME1_SBAB_SB_STALL, 1 << MME_SBAB_SB_STALL_R_SHIFT);\n\tWREG32(mmMME2_ACC_ACC_STALL, 1 << MME_ACC_ACC_STALL_R_SHIFT);\n\tWREG32(mmMME2_ACC_ACC_STALL, 1 << MME_ACC_ACC_STALL_R_SHIFT);\n\tWREG32(mmMME2_SBAB_SB_STALL, 1 << MME_SBAB_SB_STALL_R_SHIFT);\n\tWREG32(mmMME2_SBAB_SB_STALL, 1 << MME_SBAB_SB_STALL_R_SHIFT);\n\tWREG32(mmMME3_ACC_ACC_STALL, 1 << MME_ACC_ACC_STALL_R_SHIFT);\n\tWREG32(mmMME3_ACC_ACC_STALL, 1 << MME_ACC_ACC_STALL_R_SHIFT);\n\tWREG32(mmMME3_SBAB_SB_STALL, 1 << MME_SBAB_SB_STALL_R_SHIFT);\n\tWREG32(mmMME3_SBAB_SB_STALL, 1 << MME_SBAB_SB_STALL_R_SHIFT);\n}\n\nstatic void gaudi_tpc_stall(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_TPC_MASK))\n\t\treturn;\n\n\tWREG32(mmTPC0_CFG_TPC_STALL, 1 << TPC0_CFG_TPC_STALL_V_SHIFT);\n\tWREG32(mmTPC1_CFG_TPC_STALL, 1 << TPC0_CFG_TPC_STALL_V_SHIFT);\n\tWREG32(mmTPC2_CFG_TPC_STALL, 1 << TPC0_CFG_TPC_STALL_V_SHIFT);\n\tWREG32(mmTPC3_CFG_TPC_STALL, 1 << TPC0_CFG_TPC_STALL_V_SHIFT);\n\tWREG32(mmTPC4_CFG_TPC_STALL, 1 << TPC0_CFG_TPC_STALL_V_SHIFT);\n\tWREG32(mmTPC5_CFG_TPC_STALL, 1 << TPC0_CFG_TPC_STALL_V_SHIFT);\n\tWREG32(mmTPC6_CFG_TPC_STALL, 1 << TPC0_CFG_TPC_STALL_V_SHIFT);\n\tWREG32(mmTPC7_CFG_TPC_STALL, 1 << TPC0_CFG_TPC_STALL_V_SHIFT);\n}\n\nstatic void gaudi_set_clock_gating(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu32 qman_offset;\n\tbool enable;\n\tint i;\n\n\t/* In case we are during debug session, don't enable the clock gate\n\t * as it may interfere\n\t */\n\tif (hdev->in_debug)\n\t\treturn;\n\n\tif (!hdev->asic_prop.fw_security_disabled)\n\t\treturn;\n\n\tfor (i = GAUDI_PCI_DMA_1, qman_offset = 0 ; i < GAUDI_HBM_DMA_1 ; i++) {\n\t\tenable = !!(hdev->clock_gating_mask &\n\t\t\t\t(BIT_ULL(gaudi_dma_assignment[i])));\n\n\t\tqman_offset = gaudi_dma_assignment[i] * DMA_QMAN_OFFSET;\n\t\tWREG32(mmDMA0_QM_CGM_CFG1 + qman_offset,\n\t\t\t\tenable ? QMAN_CGM1_PWR_GATE_EN : 0);\n\t\tWREG32(mmDMA0_QM_CGM_CFG + qman_offset,\n\t\t\t\tenable ? QMAN_UPPER_CP_CGM_PWR_GATE_EN : 0);\n\t}\n\n\tfor (i = GAUDI_HBM_DMA_1 ; i < GAUDI_DMA_MAX ; i++) {\n\t\tenable = !!(hdev->clock_gating_mask &\n\t\t\t\t(BIT_ULL(gaudi_dma_assignment[i])));\n\n\t\t/* GC sends work to DMA engine through Upper CP in DMA5 so\n\t\t * we need to not enable clock gating in that DMA\n\t\t */\n\t\tif (i == GAUDI_HBM_DMA_4)\n\t\t\tenable = 0;\n\n\t\tqman_offset = gaudi_dma_assignment[i] * DMA_QMAN_OFFSET;\n\t\tWREG32(mmDMA0_QM_CGM_CFG1 + qman_offset,\n\t\t\t\tenable ? QMAN_CGM1_PWR_GATE_EN : 0);\n\t\tWREG32(mmDMA0_QM_CGM_CFG + qman_offset,\n\t\t\t\tenable ? QMAN_COMMON_CP_CGM_PWR_GATE_EN : 0);\n\t}\n\n\tenable = !!(hdev->clock_gating_mask & (BIT_ULL(GAUDI_ENGINE_ID_MME_0)));\n\tWREG32(mmMME0_QM_CGM_CFG1, enable ? QMAN_CGM1_PWR_GATE_EN : 0);\n\tWREG32(mmMME0_QM_CGM_CFG, enable ? QMAN_COMMON_CP_CGM_PWR_GATE_EN : 0);\n\n\tenable = !!(hdev->clock_gating_mask & (BIT_ULL(GAUDI_ENGINE_ID_MME_2)));\n\tWREG32(mmMME2_QM_CGM_CFG1, enable ? QMAN_CGM1_PWR_GATE_EN : 0);\n\tWREG32(mmMME2_QM_CGM_CFG, enable ? QMAN_COMMON_CP_CGM_PWR_GATE_EN : 0);\n\n\tfor (i = 0, qman_offset = 0 ; i < TPC_NUMBER_OF_ENGINES ; i++) {\n\t\tenable = !!(hdev->clock_gating_mask &\n\t\t\t\t(BIT_ULL(GAUDI_ENGINE_ID_TPC_0 + i)));\n\n\t\tWREG32(mmTPC0_QM_CGM_CFG1 + qman_offset,\n\t\t\t\tenable ? QMAN_CGM1_PWR_GATE_EN : 0);\n\t\tWREG32(mmTPC0_QM_CGM_CFG + qman_offset,\n\t\t\t\tenable ? QMAN_COMMON_CP_CGM_PWR_GATE_EN : 0);\n\n\t\tqman_offset += TPC_QMAN_OFFSET;\n\t}\n\n\tgaudi->hw_cap_initialized |= HW_CAP_CLK_GATE;\n}\n\nstatic void gaudi_disable_clock_gating(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu32 qman_offset;\n\tint i;\n\n\tif (!hdev->asic_prop.fw_security_disabled)\n\t\treturn;\n\n\tfor (i = 0, qman_offset = 0 ; i < DMA_NUMBER_OF_CHANNELS ; i++) {\n\t\tWREG32(mmDMA0_QM_CGM_CFG + qman_offset, 0);\n\t\tWREG32(mmDMA0_QM_CGM_CFG1 + qman_offset, 0);\n\n\t\tqman_offset += (mmDMA1_QM_CGM_CFG - mmDMA0_QM_CGM_CFG);\n\t}\n\n\tWREG32(mmMME0_QM_CGM_CFG, 0);\n\tWREG32(mmMME0_QM_CGM_CFG1, 0);\n\tWREG32(mmMME2_QM_CGM_CFG, 0);\n\tWREG32(mmMME2_QM_CGM_CFG1, 0);\n\n\tfor (i = 0, qman_offset = 0 ; i < TPC_NUMBER_OF_ENGINES ; i++) {\n\t\tWREG32(mmTPC0_QM_CGM_CFG + qman_offset, 0);\n\t\tWREG32(mmTPC0_QM_CGM_CFG1 + qman_offset, 0);\n\n\t\tqman_offset += (mmTPC1_QM_CGM_CFG - mmTPC0_QM_CGM_CFG);\n\t}\n\n\tgaudi->hw_cap_initialized &= ~(HW_CAP_CLK_GATE);\n}\n\nstatic void gaudi_enable_timestamp(struct hl_device *hdev)\n{\n\t/* Disable the timestamp counter */\n\tWREG32(mmPSOC_TIMESTAMP_BASE - CFG_BASE, 0);\n\n\t/* Zero the lower/upper parts of the 64-bit counter */\n\tWREG32(mmPSOC_TIMESTAMP_BASE - CFG_BASE + 0xC, 0);\n\tWREG32(mmPSOC_TIMESTAMP_BASE - CFG_BASE + 0x8, 0);\n\n\t/* Enable the counter */\n\tWREG32(mmPSOC_TIMESTAMP_BASE - CFG_BASE, 1);\n}\n\nstatic void gaudi_disable_timestamp(struct hl_device *hdev)\n{\n\t/* Disable the timestamp counter */\n\tWREG32(mmPSOC_TIMESTAMP_BASE - CFG_BASE, 0);\n}\n\nstatic void gaudi_halt_engines(struct hl_device *hdev, bool hard_reset)\n{\n\tu32 wait_timeout_ms;\n\n\tdev_info(hdev->dev,\n\t\t\"Halting compute engines and disabling interrupts\\n\");\n\n\tif (hdev->pldm)\n\t\twait_timeout_ms = GAUDI_PLDM_RESET_WAIT_MSEC;\n\telse\n\t\twait_timeout_ms = GAUDI_RESET_WAIT_MSEC;\n\n\tgaudi_stop_nic_qmans(hdev);\n\tgaudi_stop_mme_qmans(hdev);\n\tgaudi_stop_tpc_qmans(hdev);\n\tgaudi_stop_hbm_dma_qmans(hdev);\n\tgaudi_stop_pci_dma_qmans(hdev);\n\n\thdev->asic_funcs->disable_clock_gating(hdev);\n\n\tmsleep(wait_timeout_ms);\n\n\tgaudi_pci_dma_stall(hdev);\n\tgaudi_hbm_dma_stall(hdev);\n\tgaudi_tpc_stall(hdev);\n\tgaudi_mme_stall(hdev);\n\n\tmsleep(wait_timeout_ms);\n\n\tgaudi_disable_nic_qmans(hdev);\n\tgaudi_disable_mme_qmans(hdev);\n\tgaudi_disable_tpc_qmans(hdev);\n\tgaudi_disable_hbm_dma_qmans(hdev);\n\tgaudi_disable_pci_dma_qmans(hdev);\n\n\tgaudi_disable_timestamp(hdev);\n\n\tgaudi_disable_msi(hdev);\n}\n\nstatic int gaudi_mmu_init(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu64 hop0_addr;\n\tint rc, i;\n\n\tif (!hdev->mmu_enable)\n\t\treturn 0;\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_MMU)\n\t\treturn 0;\n\n\tfor (i = 0 ; i < prop->max_asid ; i++) {\n\t\thop0_addr = prop->mmu_pgt_addr +\n\t\t\t\t(i * prop->mmu_hop_table_size);\n\n\t\trc = gaudi_mmu_update_asid_hop0_addr(hdev, i, hop0_addr);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"failed to set hop0 addr for asid %d\\n\", i);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t/* init MMU cache manage page */\n\tWREG32(mmSTLB_CACHE_INV_BASE_39_8, MMU_CACHE_MNG_ADDR >> 8);\n\tWREG32(mmSTLB_CACHE_INV_BASE_49_40, MMU_CACHE_MNG_ADDR >> 40);\n\n\thdev->asic_funcs->mmu_invalidate_cache(hdev, true, 0);\n\n\tWREG32(mmMMU_UP_MMU_ENABLE, 1);\n\tWREG32(mmMMU_UP_SPI_MASK, 0xF);\n\n\tWREG32(mmSTLB_HOP_CONFIGURATION,\n\t\t\thdev->mmu_huge_page_opt ? 0x30440 : 0x40440);\n\n\t/*\n\t * The H/W expects the first PI after init to be 1. After wraparound\n\t * we'll write 0.\n\t */\n\tgaudi->mmu_cache_inv_pi = 1;\n\n\tgaudi->hw_cap_initialized |= HW_CAP_MMU;\n\n\treturn 0;\n\nerr:\n\treturn rc;\n}\n\nstatic int gaudi_load_firmware_to_device(struct hl_device *hdev)\n{\n\tvoid __iomem *dst;\n\n\t/* HBM scrambler must be initialized before pushing F/W to HBM */\n\tgaudi_init_scrambler_hbm(hdev);\n\n\tdst = hdev->pcie_bar[HBM_BAR_ID] + LINUX_FW_OFFSET;\n\n\treturn hl_fw_load_fw_to_device(hdev, GAUDI_LINUX_FW_FILE, dst, 0, 0);\n}\n\nstatic int gaudi_load_boot_fit_to_device(struct hl_device *hdev)\n{\n\tvoid __iomem *dst;\n\n\tdst = hdev->pcie_bar[SRAM_BAR_ID] + BOOT_FIT_SRAM_OFFSET;\n\n\treturn hl_fw_load_fw_to_device(hdev, GAUDI_BOOT_FIT_FILE, dst, 0, 0);\n}\n\nstatic int gaudi_read_device_fw_version(struct hl_device *hdev,\n\t\t\t\t\tenum hl_fw_component fwc)\n{\n\tconst char *name;\n\tu32 ver_off;\n\tchar *dest;\n\n\tswitch (fwc) {\n\tcase FW_COMP_UBOOT:\n\t\tver_off = RREG32(mmUBOOT_VER_OFFSET);\n\t\tdest = hdev->asic_prop.uboot_ver;\n\t\tname = \"U-Boot\";\n\t\tbreak;\n\tcase FW_COMP_PREBOOT:\n\t\tver_off = RREG32(mmPREBOOT_VER_OFFSET);\n\t\tdest = hdev->asic_prop.preboot_ver;\n\t\tname = \"Preboot\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(hdev->dev, \"Undefined FW component: %d\\n\", fwc);\n\t\treturn -EIO;\n\t}\n\n\tver_off &= ~((u32)SRAM_BASE_ADDR);\n\n\tif (ver_off < SRAM_SIZE - VERSION_MAX_LEN) {\n\t\tmemcpy_fromio(dest, hdev->pcie_bar[SRAM_BAR_ID] + ver_off,\n\t\t\t\t\t\t\tVERSION_MAX_LEN);\n\t} else {\n\t\tdev_err(hdev->dev, \"%s version offset (0x%x) is above SRAM\\n\",\n\t\t\t\t\t\t\t\tname, ver_off);\n\t\tstrcpy(dest, \"unavailable\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int gaudi_init_cpu(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tint rc;\n\n\tif (!hdev->cpu_enable)\n\t\treturn 0;\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_CPU)\n\t\treturn 0;\n\n\t/*\n\t * The device CPU works with 40 bits addresses.\n\t * This register sets the extension to 50 bits.\n\t */\n\tif (hdev->asic_prop.fw_security_disabled)\n\t\tWREG32(mmCPU_IF_CPU_MSB_ADDR, hdev->cpu_pci_msb_addr);\n\n\trc = hl_fw_init_cpu(hdev, mmPSOC_GLOBAL_CONF_CPU_BOOT_STATUS,\n\t\t\tmmPSOC_GLOBAL_CONF_KMD_MSG_TO_CPU,\n\t\t\tmmCPU_CMD_STATUS_TO_HOST,\n\t\t\tmmCPU_BOOT_DEV_STS0, mmCPU_BOOT_ERR0,\n\t\t\t!hdev->bmc_enable, GAUDI_CPU_TIMEOUT_USEC,\n\t\t\tGAUDI_BOOT_FIT_REQ_TIMEOUT_USEC);\n\n\tif (rc)\n\t\treturn rc;\n\n\tgaudi->hw_cap_initialized |= HW_CAP_CPU;\n\n\treturn 0;\n}\n\nstatic int gaudi_init_cpu_queues(struct hl_device *hdev, u32 cpu_timeout)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct hl_eq *eq;\n\tu32 status;\n\tstruct hl_hw_queue *cpu_pq =\n\t\t\t&hdev->kernel_queues[GAUDI_QUEUE_ID_CPU_PQ];\n\tint err;\n\n\tif (!hdev->cpu_queues_enable)\n\t\treturn 0;\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_CPU_Q)\n\t\treturn 0;\n\n\teq = &hdev->event_queue;\n\n\tWREG32(mmCPU_IF_PQ_BASE_ADDR_LOW, lower_32_bits(cpu_pq->bus_address));\n\tWREG32(mmCPU_IF_PQ_BASE_ADDR_HIGH, upper_32_bits(cpu_pq->bus_address));\n\n\tWREG32(mmCPU_IF_EQ_BASE_ADDR_LOW, lower_32_bits(eq->bus_address));\n\tWREG32(mmCPU_IF_EQ_BASE_ADDR_HIGH, upper_32_bits(eq->bus_address));\n\n\tWREG32(mmCPU_IF_CQ_BASE_ADDR_LOW,\n\t\t\tlower_32_bits(hdev->cpu_accessible_dma_address));\n\tWREG32(mmCPU_IF_CQ_BASE_ADDR_HIGH,\n\t\t\tupper_32_bits(hdev->cpu_accessible_dma_address));\n\n\tWREG32(mmCPU_IF_PQ_LENGTH, HL_QUEUE_SIZE_IN_BYTES);\n\tWREG32(mmCPU_IF_EQ_LENGTH, HL_EQ_SIZE_IN_BYTES);\n\tWREG32(mmCPU_IF_CQ_LENGTH, HL_CPU_ACCESSIBLE_MEM_SIZE);\n\n\t/* Used for EQ CI */\n\tWREG32(mmCPU_IF_EQ_RD_OFFS, 0);\n\n\tWREG32(mmCPU_IF_PF_PQ_PI, 0);\n\n\tif (gaudi->multi_msi_mode)\n\t\tWREG32(mmCPU_IF_QUEUE_INIT, PQ_INIT_STATUS_READY_FOR_CP);\n\telse\n\t\tWREG32(mmCPU_IF_QUEUE_INIT,\n\t\t\tPQ_INIT_STATUS_READY_FOR_CP_SINGLE_MSI);\n\n\tWREG32(mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR, GAUDI_EVENT_PI_UPDATE);\n\n\terr = hl_poll_timeout(\n\t\thdev,\n\t\tmmCPU_IF_QUEUE_INIT,\n\t\tstatus,\n\t\t(status == PQ_INIT_STATUS_READY_FOR_HOST),\n\t\t1000,\n\t\tcpu_timeout);\n\n\tif (err) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to communicate with Device CPU (CPU-CP timeout)\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* update FW application security bits */\n\tif (prop->fw_security_status_valid)\n\t\tprop->fw_app_security_map = RREG32(mmCPU_BOOT_DEV_STS0);\n\n\tgaudi->hw_cap_initialized |= HW_CAP_CPU_Q;\n\treturn 0;\n}\n\nstatic void gaudi_pre_hw_init(struct hl_device *hdev)\n{\n\t/* Perform read from the device to make sure device is up */\n\tRREG32(mmHW_STATE);\n\n\tif (hdev->asic_prop.fw_security_disabled) {\n\t\t/* Set the access through PCI bars (Linux driver only) as\n\t\t * secured\n\t\t */\n\t\tWREG32(mmPCIE_WRAP_LBW_PROT_OVR,\n\t\t\t\t(PCIE_WRAP_LBW_PROT_OVR_RD_EN_MASK |\n\t\t\t\tPCIE_WRAP_LBW_PROT_OVR_WR_EN_MASK));\n\n\t\t/* Perform read to flush the waiting writes to ensure\n\t\t * configuration was set in the device\n\t\t */\n\t\tRREG32(mmPCIE_WRAP_LBW_PROT_OVR);\n\t}\n\n\t/*\n\t * Let's mark in the H/W that we have reached this point. We check\n\t * this value in the reset_before_init function to understand whether\n\t * we need to reset the chip before doing H/W init. This register is\n\t * cleared by the H/W upon H/W reset\n\t */\n\tWREG32(mmHW_STATE, HL_DEVICE_HW_STATE_DIRTY);\n}\n\nstatic int gaudi_hw_init(struct hl_device *hdev)\n{\n\tint rc;\n\n\tgaudi_pre_hw_init(hdev);\n\n\tgaudi_init_pci_dma_qmans(hdev);\n\n\tgaudi_init_hbm_dma_qmans(hdev);\n\n\trc = gaudi_init_cpu(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to initialize CPU\\n\");\n\t\treturn rc;\n\t}\n\n\t/* In case the clock gating was enabled in preboot we need to disable\n\t * it here before touching the MME/TPC registers.\n\t * There is no need to take clk gating mutex because when this function\n\t * runs, no other relevant code can run\n\t */\n\thdev->asic_funcs->disable_clock_gating(hdev);\n\n\t/* SRAM scrambler must be initialized after CPU is running from HBM */\n\tgaudi_init_scrambler_sram(hdev);\n\n\t/* This is here just in case we are working without CPU */\n\tgaudi_init_scrambler_hbm(hdev);\n\n\tgaudi_init_golden_registers(hdev);\n\n\trc = gaudi_mmu_init(hdev);\n\tif (rc)\n\t\treturn rc;\n\n\tgaudi_init_security(hdev);\n\n\tgaudi_init_mme_qmans(hdev);\n\n\tgaudi_init_tpc_qmans(hdev);\n\n\tgaudi_init_nic_qmans(hdev);\n\n\thdev->asic_funcs->set_clock_gating(hdev);\n\n\tgaudi_enable_timestamp(hdev);\n\n\t/* MSI must be enabled before CPU queues and NIC are initialized */\n\trc = gaudi_enable_msi(hdev);\n\tif (rc)\n\t\tgoto disable_queues;\n\n\t/* must be called after MSI was enabled */\n\trc = gaudi_init_cpu_queues(hdev, GAUDI_CPU_TIMEOUT_USEC);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to initialize CPU H/W queues %d\\n\",\n\t\t\trc);\n\t\tgoto disable_msi;\n\t}\n\n\t/* Perform read from the device to flush all configuration */\n\tRREG32(mmHW_STATE);\n\n\treturn 0;\n\ndisable_msi:\n\tgaudi_disable_msi(hdev);\ndisable_queues:\n\tgaudi_disable_mme_qmans(hdev);\n\tgaudi_disable_pci_dma_qmans(hdev);\n\n\treturn rc;\n}\n\nstatic void gaudi_hw_fini(struct hl_device *hdev, bool hard_reset)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu32 status, reset_timeout_ms, cpu_timeout_ms;\n\n\tif (!hard_reset) {\n\t\tdev_err(hdev->dev, \"GAUDI doesn't support soft-reset\\n\");\n\t\treturn;\n\t}\n\n\tif (hdev->pldm) {\n\t\treset_timeout_ms = GAUDI_PLDM_HRESET_TIMEOUT_MSEC;\n\t\tcpu_timeout_ms = GAUDI_PLDM_RESET_WAIT_MSEC;\n\t} else {\n\t\treset_timeout_ms = GAUDI_RESET_TIMEOUT_MSEC;\n\t\tcpu_timeout_ms = GAUDI_CPU_RESET_WAIT_MSEC;\n\t}\n\n\t/* Set device to handle FLR by H/W as we will put the device CPU to\n\t * halt mode\n\t */\n\tif (hdev->asic_prop.fw_security_disabled &&\n\t\t\t\t!hdev->asic_prop.hard_reset_done_by_fw)\n\t\tWREG32(mmPCIE_AUX_FLR_CTRL, (PCIE_AUX_FLR_CTRL_HW_CTRL_MASK |\n\t\t\t\t\tPCIE_AUX_FLR_CTRL_INT_MASK_MASK));\n\n\t/* I don't know what is the state of the CPU so make sure it is\n\t * stopped in any means necessary\n\t */\n\tif (hdev->asic_prop.hard_reset_done_by_fw)\n\t\tWREG32(mmPSOC_GLOBAL_CONF_KMD_MSG_TO_CPU, KMD_MSG_RST_DEV);\n\telse\n\t\tWREG32(mmPSOC_GLOBAL_CONF_KMD_MSG_TO_CPU, KMD_MSG_GOTO_WFE);\n\n\tWREG32(mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR, GAUDI_EVENT_HALT_MACHINE);\n\n\tif (hdev->asic_prop.fw_security_disabled &&\n\t\t\t\t!hdev->asic_prop.hard_reset_done_by_fw) {\n\n\t\t/* Configure the reset registers. Must be done as early as\n\t\t * possible in case we fail during H/W initialization\n\t\t */\n\t\tWREG32(mmPSOC_GLOBAL_CONF_SOFT_RST_CFG_H,\n\t\t\t\t\t\t(CFG_RST_H_DMA_MASK |\n\t\t\t\t\t\tCFG_RST_H_MME_MASK |\n\t\t\t\t\t\tCFG_RST_H_SM_MASK |\n\t\t\t\t\t\tCFG_RST_H_TPC_7_MASK));\n\n\t\tWREG32(mmPSOC_GLOBAL_CONF_SOFT_RST_CFG_L, CFG_RST_L_TPC_MASK);\n\n\t\tWREG32(mmPSOC_GLOBAL_CONF_SW_ALL_RST_CFG_H,\n\t\t\t\t\t\t(CFG_RST_H_HBM_MASK |\n\t\t\t\t\t\tCFG_RST_H_TPC_7_MASK |\n\t\t\t\t\t\tCFG_RST_H_NIC_MASK |\n\t\t\t\t\t\tCFG_RST_H_SM_MASK |\n\t\t\t\t\t\tCFG_RST_H_DMA_MASK |\n\t\t\t\t\t\tCFG_RST_H_MME_MASK |\n\t\t\t\t\t\tCFG_RST_H_CPU_MASK |\n\t\t\t\t\t\tCFG_RST_H_MMU_MASK));\n\n\t\tWREG32(mmPSOC_GLOBAL_CONF_SW_ALL_RST_CFG_L,\n\t\t\t\t\t\t(CFG_RST_L_IF_MASK |\n\t\t\t\t\t\tCFG_RST_L_PSOC_MASK |\n\t\t\t\t\t\tCFG_RST_L_TPC_MASK));\n\n\t\tmsleep(cpu_timeout_ms);\n\n\t\t/* Tell ASIC not to re-initialize PCIe */\n\t\tWREG32(mmPREBOOT_PCIE_EN, LKD_HARD_RESET_MAGIC);\n\n\t\t/* Restart BTL/BLR upon hard-reset */\n\t\tif (hdev->asic_prop.fw_security_disabled)\n\t\t\tWREG32(mmPSOC_GLOBAL_CONF_BOOT_SEQ_RE_START, 1);\n\n\t\tWREG32(mmPSOC_GLOBAL_CONF_SW_ALL_RST,\n\t\t\t1 << PSOC_GLOBAL_CONF_SW_ALL_RST_IND_SHIFT);\n\n\t\tdev_info(hdev->dev,\n\t\t\t\"Issued HARD reset command, going to wait %dms\\n\",\n\t\t\treset_timeout_ms);\n\t} else {\n\t\tdev_info(hdev->dev,\n\t\t\t\"Firmware performs HARD reset, going to wait %dms\\n\",\n\t\t\treset_timeout_ms);\n\t}\n\n\t/*\n\t * After hard reset, we can't poll the BTM_FSM register because the PSOC\n\t * itself is in reset. Need to wait until the reset is deasserted\n\t */\n\tmsleep(reset_timeout_ms);\n\n\tstatus = RREG32(mmPSOC_GLOBAL_CONF_BTM_FSM);\n\tif (status & PSOC_GLOBAL_CONF_BTM_FSM_STATE_MASK)\n\t\tdev_err(hdev->dev,\n\t\t\t\"Timeout while waiting for device to reset 0x%x\\n\",\n\t\t\tstatus);\n\n\tif (gaudi) {\n\t\tgaudi->hw_cap_initialized &= ~(HW_CAP_CPU | HW_CAP_CPU_Q |\n\t\t\t\tHW_CAP_HBM | HW_CAP_PCI_DMA |\n\t\t\t\tHW_CAP_MME | HW_CAP_TPC_MASK |\n\t\t\t\tHW_CAP_HBM_DMA | HW_CAP_PLL |\n\t\t\t\tHW_CAP_NIC_MASK | HW_CAP_MMU |\n\t\t\t\tHW_CAP_SRAM_SCRAMBLER |\n\t\t\t\tHW_CAP_HBM_SCRAMBLER |\n\t\t\t\tHW_CAP_CLK_GATE);\n\n\t\tmemset(gaudi->events_stat, 0, sizeof(gaudi->events_stat));\n\t}\n}\n\nstatic int gaudi_suspend(struct hl_device *hdev)\n{\n\tint rc;\n\n\trc = hl_fw_send_pci_access_msg(hdev, CPUCP_PACKET_DISABLE_PCI_ACCESS);\n\tif (rc)\n\t\tdev_err(hdev->dev, \"Failed to disable PCI access from CPU\\n\");\n\n\treturn rc;\n}\n\nstatic int gaudi_resume(struct hl_device *hdev)\n{\n\treturn gaudi_init_iatu(hdev);\n}\n\nstatic int gaudi_cb_mmap(struct hl_device *hdev, struct vm_area_struct *vma,\n\t\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size)\n{\n\tint rc;\n\n\tvma->vm_flags |= VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP |\n\t\t\tVM_DONTCOPY | VM_NORESERVE;\n\n\trc = dma_mmap_coherent(hdev->dev, vma, cpu_addr,\n\t\t\t\t(dma_addr - HOST_PHYS_BASE), size);\n\tif (rc)\n\t\tdev_err(hdev->dev, \"dma_mmap_coherent error %d\", rc);\n\n\treturn rc;\n}\n\nstatic void gaudi_ring_doorbell(struct hl_device *hdev, u32 hw_queue_id, u32 pi)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu32 db_reg_offset, db_value, dma_qm_offset, q_off;\n\tint dma_id;\n\tbool invalid_queue = false;\n\n\tswitch (hw_queue_id) {\n\tcase GAUDI_QUEUE_ID_DMA_0_0...GAUDI_QUEUE_ID_DMA_0_3:\n\t\tdma_id = gaudi_dma_assignment[GAUDI_PCI_DMA_1];\n\t\tdma_qm_offset = dma_id * DMA_QMAN_OFFSET;\n\t\tq_off = dma_qm_offset + (hw_queue_id & 0x3) * 4;\n\t\tdb_reg_offset = mmDMA0_QM_PQ_PI_0 + q_off;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_DMA_1_0...GAUDI_QUEUE_ID_DMA_1_3:\n\t\tdma_id = gaudi_dma_assignment[GAUDI_PCI_DMA_2];\n\t\tdma_qm_offset = dma_id * DMA_QMAN_OFFSET;\n\t\tq_off = dma_qm_offset + (hw_queue_id & 0x3) * 4;\n\t\tdb_reg_offset = mmDMA0_QM_PQ_PI_0 + q_off;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_DMA_2_0...GAUDI_QUEUE_ID_DMA_2_3:\n\t\tdma_id = gaudi_dma_assignment[GAUDI_HBM_DMA_1];\n\t\tdma_qm_offset = dma_id * DMA_QMAN_OFFSET;\n\t\tq_off = dma_qm_offset + ((hw_queue_id - 1) & 0x3) * 4;\n\t\tdb_reg_offset = mmDMA0_QM_PQ_PI_0 + q_off;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_DMA_3_0...GAUDI_QUEUE_ID_DMA_3_3:\n\t\tdma_id = gaudi_dma_assignment[GAUDI_HBM_DMA_2];\n\t\tdma_qm_offset = dma_id * DMA_QMAN_OFFSET;\n\t\tq_off = dma_qm_offset + ((hw_queue_id - 1) & 0x3) * 4;\n\t\tdb_reg_offset = mmDMA0_QM_PQ_PI_0 + q_off;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_DMA_4_0...GAUDI_QUEUE_ID_DMA_4_3:\n\t\tdma_id = gaudi_dma_assignment[GAUDI_HBM_DMA_3];\n\t\tdma_qm_offset = dma_id * DMA_QMAN_OFFSET;\n\t\tq_off = dma_qm_offset + ((hw_queue_id - 1) & 0x3) * 4;\n\t\tdb_reg_offset = mmDMA0_QM_PQ_PI_0 + q_off;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_DMA_5_0...GAUDI_QUEUE_ID_DMA_5_3:\n\t\tdma_id = gaudi_dma_assignment[GAUDI_HBM_DMA_4];\n\t\tdma_qm_offset = dma_id * DMA_QMAN_OFFSET;\n\t\tq_off = dma_qm_offset + ((hw_queue_id - 1) & 0x3) * 4;\n\t\tdb_reg_offset = mmDMA0_QM_PQ_PI_0 + q_off;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_DMA_6_0...GAUDI_QUEUE_ID_DMA_6_3:\n\t\tdma_id = gaudi_dma_assignment[GAUDI_HBM_DMA_5];\n\t\tdma_qm_offset = dma_id * DMA_QMAN_OFFSET;\n\t\tq_off = dma_qm_offset + ((hw_queue_id - 1) & 0x3) * 4;\n\t\tdb_reg_offset = mmDMA0_QM_PQ_PI_0 + q_off;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_DMA_7_0...GAUDI_QUEUE_ID_DMA_7_3:\n\t\tdma_id = gaudi_dma_assignment[GAUDI_HBM_DMA_6];\n\t\tdma_qm_offset = dma_id * DMA_QMAN_OFFSET;\n\t\tq_off = dma_qm_offset + ((hw_queue_id - 1) & 0x3) * 4;\n\t\tdb_reg_offset = mmDMA0_QM_PQ_PI_0 + q_off;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_CPU_PQ:\n\t\tif (gaudi->hw_cap_initialized & HW_CAP_CPU_Q)\n\t\t\tdb_reg_offset = mmCPU_IF_PF_PQ_PI;\n\t\telse\n\t\t\tinvalid_queue = true;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_MME_0_0:\n\t\tdb_reg_offset = mmMME2_QM_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_MME_0_1:\n\t\tdb_reg_offset = mmMME2_QM_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_MME_0_2:\n\t\tdb_reg_offset = mmMME2_QM_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_MME_0_3:\n\t\tdb_reg_offset = mmMME2_QM_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_MME_1_0:\n\t\tdb_reg_offset = mmMME0_QM_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_MME_1_1:\n\t\tdb_reg_offset = mmMME0_QM_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_MME_1_2:\n\t\tdb_reg_offset = mmMME0_QM_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_MME_1_3:\n\t\tdb_reg_offset = mmMME0_QM_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_0_0:\n\t\tdb_reg_offset = mmTPC0_QM_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_0_1:\n\t\tdb_reg_offset = mmTPC0_QM_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_0_2:\n\t\tdb_reg_offset = mmTPC0_QM_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_0_3:\n\t\tdb_reg_offset = mmTPC0_QM_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_1_0:\n\t\tdb_reg_offset = mmTPC1_QM_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_1_1:\n\t\tdb_reg_offset = mmTPC1_QM_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_1_2:\n\t\tdb_reg_offset = mmTPC1_QM_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_1_3:\n\t\tdb_reg_offset = mmTPC1_QM_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_2_0:\n\t\tdb_reg_offset = mmTPC2_QM_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_2_1:\n\t\tdb_reg_offset = mmTPC2_QM_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_2_2:\n\t\tdb_reg_offset = mmTPC2_QM_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_2_3:\n\t\tdb_reg_offset = mmTPC2_QM_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_3_0:\n\t\tdb_reg_offset = mmTPC3_QM_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_3_1:\n\t\tdb_reg_offset = mmTPC3_QM_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_3_2:\n\t\tdb_reg_offset = mmTPC3_QM_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_3_3:\n\t\tdb_reg_offset = mmTPC3_QM_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_4_0:\n\t\tdb_reg_offset = mmTPC4_QM_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_4_1:\n\t\tdb_reg_offset = mmTPC4_QM_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_4_2:\n\t\tdb_reg_offset = mmTPC4_QM_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_4_3:\n\t\tdb_reg_offset = mmTPC4_QM_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_5_0:\n\t\tdb_reg_offset = mmTPC5_QM_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_5_1:\n\t\tdb_reg_offset = mmTPC5_QM_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_5_2:\n\t\tdb_reg_offset = mmTPC5_QM_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_5_3:\n\t\tdb_reg_offset = mmTPC5_QM_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_6_0:\n\t\tdb_reg_offset = mmTPC6_QM_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_6_1:\n\t\tdb_reg_offset = mmTPC6_QM_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_6_2:\n\t\tdb_reg_offset = mmTPC6_QM_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_6_3:\n\t\tdb_reg_offset = mmTPC6_QM_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_7_0:\n\t\tdb_reg_offset = mmTPC7_QM_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_7_1:\n\t\tdb_reg_offset = mmTPC7_QM_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_7_2:\n\t\tdb_reg_offset = mmTPC7_QM_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_TPC_7_3:\n\t\tdb_reg_offset = mmTPC7_QM_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_0_0:\n\t\tdb_reg_offset = mmNIC0_QM0_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_0_1:\n\t\tdb_reg_offset = mmNIC0_QM0_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_0_2:\n\t\tdb_reg_offset = mmNIC0_QM0_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_0_3:\n\t\tdb_reg_offset = mmNIC0_QM0_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_1_0:\n\t\tdb_reg_offset = mmNIC0_QM1_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_1_1:\n\t\tdb_reg_offset = mmNIC0_QM1_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_1_2:\n\t\tdb_reg_offset = mmNIC0_QM1_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_1_3:\n\t\tdb_reg_offset = mmNIC0_QM1_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_2_0:\n\t\tdb_reg_offset = mmNIC1_QM0_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_2_1:\n\t\tdb_reg_offset = mmNIC1_QM0_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_2_2:\n\t\tdb_reg_offset = mmNIC1_QM0_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_2_3:\n\t\tdb_reg_offset = mmNIC1_QM0_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_3_0:\n\t\tdb_reg_offset = mmNIC1_QM1_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_3_1:\n\t\tdb_reg_offset = mmNIC1_QM1_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_3_2:\n\t\tdb_reg_offset = mmNIC1_QM1_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_3_3:\n\t\tdb_reg_offset = mmNIC1_QM1_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_4_0:\n\t\tdb_reg_offset = mmNIC2_QM0_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_4_1:\n\t\tdb_reg_offset = mmNIC2_QM0_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_4_2:\n\t\tdb_reg_offset = mmNIC2_QM0_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_4_3:\n\t\tdb_reg_offset = mmNIC2_QM0_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_5_0:\n\t\tdb_reg_offset = mmNIC2_QM1_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_5_1:\n\t\tdb_reg_offset = mmNIC2_QM1_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_5_2:\n\t\tdb_reg_offset = mmNIC2_QM1_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_5_3:\n\t\tdb_reg_offset = mmNIC2_QM1_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_6_0:\n\t\tdb_reg_offset = mmNIC3_QM0_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_6_1:\n\t\tdb_reg_offset = mmNIC3_QM0_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_6_2:\n\t\tdb_reg_offset = mmNIC3_QM0_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_6_3:\n\t\tdb_reg_offset = mmNIC3_QM0_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_7_0:\n\t\tdb_reg_offset = mmNIC3_QM1_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_7_1:\n\t\tdb_reg_offset = mmNIC3_QM1_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_7_2:\n\t\tdb_reg_offset = mmNIC3_QM1_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_7_3:\n\t\tdb_reg_offset = mmNIC3_QM1_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_8_0:\n\t\tdb_reg_offset = mmNIC4_QM0_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_8_1:\n\t\tdb_reg_offset = mmNIC4_QM0_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_8_2:\n\t\tdb_reg_offset = mmNIC4_QM0_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_8_3:\n\t\tdb_reg_offset = mmNIC4_QM0_PQ_PI_3;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_9_0:\n\t\tdb_reg_offset = mmNIC4_QM1_PQ_PI_0;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_9_1:\n\t\tdb_reg_offset = mmNIC4_QM1_PQ_PI_1;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_9_2:\n\t\tdb_reg_offset = mmNIC4_QM1_PQ_PI_2;\n\t\tbreak;\n\n\tcase GAUDI_QUEUE_ID_NIC_9_3:\n\t\tdb_reg_offset = mmNIC4_QM1_PQ_PI_3;\n\t\tbreak;\n\n\tdefault:\n\t\tinvalid_queue = true;\n\t}\n\n\tif (invalid_queue) {\n\t\t/* Should never get here */\n\t\tdev_err(hdev->dev, \"h/w queue %d is invalid. Can't set pi\\n\",\n\t\t\thw_queue_id);\n\t\treturn;\n\t}\n\n\tdb_value = pi;\n\n\t/* ring the doorbell */\n\tWREG32(db_reg_offset, db_value);\n\n\tif (hw_queue_id == GAUDI_QUEUE_ID_CPU_PQ) {\n\t\t/* make sure device CPU will read latest data from host */\n\t\tmb();\n\t\tWREG32(mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR,\n\t\t\t\tGAUDI_EVENT_PI_UPDATE);\n\t}\n}\n\nstatic void gaudi_pqe_write(struct hl_device *hdev, __le64 *pqe,\n\t\t\t\tstruct hl_bd *bd)\n{\n\t__le64 *pbd = (__le64 *) bd;\n\n\t/* The QMANs are on the host memory so a simple copy suffice */\n\tpqe[0] = pbd[0];\n\tpqe[1] = pbd[1];\n}\n\nstatic void *gaudi_dma_alloc_coherent(struct hl_device *hdev, size_t size,\n\t\t\t\t\tdma_addr_t *dma_handle, gfp_t flags)\n{\n\tvoid *kernel_addr = dma_alloc_coherent(&hdev->pdev->dev, size,\n\t\t\t\t\t\tdma_handle, flags);\n\n\t/* Shift to the device's base physical address of host memory */\n\tif (kernel_addr)\n\t\t*dma_handle += HOST_PHYS_BASE;\n\n\treturn kernel_addr;\n}\n\nstatic void gaudi_dma_free_coherent(struct hl_device *hdev, size_t size,\n\t\tvoid *cpu_addr, dma_addr_t dma_handle)\n{\n\t/* Cancel the device's base physical address of host memory */\n\tdma_addr_t fixed_dma_handle = dma_handle - HOST_PHYS_BASE;\n\n\tdma_free_coherent(&hdev->pdev->dev, size, cpu_addr, fixed_dma_handle);\n}\n\nstatic int gaudi_hbm_scrubbing(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu64  cur_addr = DRAM_BASE_ADDR_USER;\n\tu32 val;\n\tu32 chunk_size;\n\tint rc, dma_id;\n\n\twhile (cur_addr < prop->dram_end_address) {\n\t\tfor (dma_id = 0 ; dma_id < DMA_NUMBER_OF_CHANNELS ; dma_id++) {\n\t\t\tu32 dma_offset = dma_id * DMA_CORE_OFFSET;\n\n\t\t\tchunk_size =\n\t\t\tmin((u64)SZ_2G, prop->dram_end_address - cur_addr);\n\n\t\t\tdev_dbg(hdev->dev,\n\t\t\t\t\"Doing HBM scrubbing for 0x%09llx - 0x%09llx\\n\",\n\t\t\t\tcur_addr, cur_addr + chunk_size);\n\n\t\t\tWREG32(mmDMA0_CORE_SRC_BASE_LO + dma_offset, 0);\n\t\t\tWREG32(mmDMA0_CORE_SRC_BASE_HI + dma_offset, 0);\n\t\t\tWREG32(mmDMA0_CORE_DST_BASE_LO + dma_offset,\n\t\t\t\t\t\tlower_32_bits(cur_addr));\n\t\t\tWREG32(mmDMA0_CORE_DST_BASE_HI + dma_offset,\n\t\t\t\t\t\tupper_32_bits(cur_addr));\n\t\t\tWREG32(mmDMA0_CORE_DST_TSIZE_0 + dma_offset,\n\t\t\t\t\tchunk_size);\n\t\t\tWREG32(mmDMA0_CORE_COMMIT + dma_offset,\n\t\t\t\t\t((1 << DMA0_CORE_COMMIT_LIN_SHIFT) |\n\t\t\t\t\t(1 << DMA0_CORE_COMMIT_MEM_SET_SHIFT)));\n\n\t\t\tcur_addr += chunk_size;\n\n\t\t\tif (cur_addr == prop->dram_end_address)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfor (dma_id = 0 ; dma_id < DMA_NUMBER_OF_CHANNELS ; dma_id++) {\n\t\t\tu32 dma_offset = dma_id * DMA_CORE_OFFSET;\n\n\t\t\trc = hl_poll_timeout(\n\t\t\t\thdev,\n\t\t\t\tmmDMA0_CORE_STS0 + dma_offset,\n\t\t\t\tval,\n\t\t\t\t((val & DMA0_CORE_STS0_BUSY_MASK) == 0),\n\t\t\t\t1000,\n\t\t\t\tHBM_SCRUBBING_TIMEOUT_US);\n\n\t\t\tif (rc) {\n\t\t\t\tdev_err(hdev->dev,\n\t\t\t\t\t\"DMA Timeout during HBM scrubbing of DMA #%d\\n\",\n\t\t\t\t\tdma_id);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int gaudi_scrub_device_mem(struct hl_device *hdev, u64 addr, u64 size)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tint rc = 0;\n\tu64 val = 0;\n\n\tif (!hdev->memory_scrub)\n\t\treturn 0;\n\n\tif (!addr && !size) {\n\t\t/* Wait till device is idle */\n\t\trc = hl_poll_timeout(\n\t\t\t\thdev,\n\t\t\t\tmmDMA0_CORE_STS0/* dummy */,\n\t\t\t\tval/* dummy */,\n\t\t\t\t(hdev->asic_funcs->is_device_idle(hdev, NULL,\n\t\t\t\t\t\t0, NULL)),\n\t\t\t\t\t\t1000,\n\t\t\t\t\t\tHBM_SCRUBBING_TIMEOUT_US);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev, \"waiting for idle timeout\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* Scrub SRAM */\n\t\taddr = prop->sram_user_base_address;\n\t\tsize = hdev->pldm ? 0x10000 :\n\t\t\t\t(prop->sram_size - SRAM_USER_BASE_OFFSET);\n\t\tval = 0x7777777777777777ull;\n\n\t\trc = gaudi_memset_device_memory(hdev, addr, size, val);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"Failed to clear SRAM in mem scrub all\\n\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tmutex_lock(&gaudi->clk_gate_mutex);\n\t\thdev->asic_funcs->disable_clock_gating(hdev);\n\n\t\t/* Scrub HBM using all DMA channels in parallel */\n\t\trc = gaudi_hbm_scrubbing(hdev);\n\t\tif (rc)\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"Failed to clear HBM in mem scrub all\\n\");\n\n\t\thdev->asic_funcs->set_clock_gating(hdev);\n\t\tmutex_unlock(&gaudi->clk_gate_mutex);\n\t}\n\n\treturn rc;\n}\n\nstatic void *gaudi_get_int_queue_base(struct hl_device *hdev,\n\t\t\t\tu32 queue_id, dma_addr_t *dma_handle,\n\t\t\t\tu16 *queue_len)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tstruct gaudi_internal_qman_info *q;\n\n\tif (queue_id >= GAUDI_QUEUE_ID_SIZE ||\n\t\t\tgaudi_queue_type[queue_id] != QUEUE_TYPE_INT) {\n\t\tdev_err(hdev->dev, \"Got invalid queue id %d\\n\", queue_id);\n\t\treturn NULL;\n\t}\n\n\tq = &gaudi->internal_qmans[queue_id];\n\t*dma_handle = q->pq_dma_addr;\n\t*queue_len = q->pq_size / QMAN_PQ_ENTRY_SIZE;\n\n\treturn q->pq_kernel_addr;\n}\n\nstatic int gaudi_send_cpu_message(struct hl_device *hdev, u32 *msg,\n\t\t\t\tu16 len, u32 timeout, u64 *result)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_CPU_Q)) {\n\t\tif (result)\n\t\t\t*result = 0;\n\t\treturn 0;\n\t}\n\n\tif (!timeout)\n\t\ttimeout = GAUDI_MSG_TO_CPU_TIMEOUT_USEC;\n\n\treturn hl_fw_send_cpu_message(hdev, GAUDI_QUEUE_ID_CPU_PQ, msg, len,\n\t\t\t\t\t\ttimeout, result);\n}\n\nstatic int gaudi_test_queue(struct hl_device *hdev, u32 hw_queue_id)\n{\n\tstruct packet_msg_prot *fence_pkt;\n\tdma_addr_t pkt_dma_addr;\n\tu32 fence_val, tmp, timeout_usec;\n\tdma_addr_t fence_dma_addr;\n\tu32 *fence_ptr;\n\tint rc;\n\n\tif (hdev->pldm)\n\t\ttimeout_usec = GAUDI_PLDM_TEST_QUEUE_WAIT_USEC;\n\telse\n\t\ttimeout_usec = GAUDI_TEST_QUEUE_WAIT_USEC;\n\n\tfence_val = GAUDI_QMAN0_FENCE_VAL;\n\n\tfence_ptr = hdev->asic_funcs->asic_dma_pool_zalloc(hdev, 4, GFP_KERNEL,\n\t\t\t\t\t\t\t&fence_dma_addr);\n\tif (!fence_ptr) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate memory for H/W queue %d testing\\n\",\n\t\t\thw_queue_id);\n\t\treturn -ENOMEM;\n\t}\n\n\t*fence_ptr = 0;\n\n\tfence_pkt = hdev->asic_funcs->asic_dma_pool_zalloc(hdev,\n\t\t\t\t\tsizeof(struct packet_msg_prot),\n\t\t\t\t\tGFP_KERNEL, &pkt_dma_addr);\n\tif (!fence_pkt) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate packet for H/W queue %d testing\\n\",\n\t\t\thw_queue_id);\n\t\trc = -ENOMEM;\n\t\tgoto free_fence_ptr;\n\t}\n\n\ttmp = FIELD_PREP(GAUDI_PKT_CTL_OPCODE_MASK, PACKET_MSG_PROT);\n\ttmp |= FIELD_PREP(GAUDI_PKT_CTL_EB_MASK, 1);\n\ttmp |= FIELD_PREP(GAUDI_PKT_CTL_MB_MASK, 1);\n\n\tfence_pkt->ctl = cpu_to_le32(tmp);\n\tfence_pkt->value = cpu_to_le32(fence_val);\n\tfence_pkt->addr = cpu_to_le64(fence_dma_addr);\n\n\trc = hl_hw_queue_send_cb_no_cmpl(hdev, hw_queue_id,\n\t\t\t\t\tsizeof(struct packet_msg_prot),\n\t\t\t\t\tpkt_dma_addr);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to send fence packet to H/W queue %d\\n\",\n\t\t\thw_queue_id);\n\t\tgoto free_pkt;\n\t}\n\n\trc = hl_poll_timeout_memory(hdev, fence_ptr, tmp, (tmp == fence_val),\n\t\t\t\t\t1000, timeout_usec, true);\n\n\thl_hw_queue_inc_ci_kernel(hdev, hw_queue_id);\n\n\tif (rc == -ETIMEDOUT) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"H/W queue %d test failed (scratch(0x%08llX) == 0x%08X)\\n\",\n\t\t\thw_queue_id, (unsigned long long) fence_dma_addr, tmp);\n\t\trc = -EIO;\n\t}\n\nfree_pkt:\n\thdev->asic_funcs->asic_dma_pool_free(hdev, (void *) fence_pkt,\n\t\t\t\t\tpkt_dma_addr);\nfree_fence_ptr:\n\thdev->asic_funcs->asic_dma_pool_free(hdev, (void *) fence_ptr,\n\t\t\t\t\tfence_dma_addr);\n\treturn rc;\n}\n\nstatic int gaudi_test_cpu_queue(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\t/*\n\t * check capability here as send_cpu_message() won't update the result\n\t * value if no capability\n\t */\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_CPU_Q))\n\t\treturn 0;\n\n\treturn hl_fw_test_cpu_queue(hdev);\n}\n\nstatic int gaudi_test_queues(struct hl_device *hdev)\n{\n\tint i, rc, ret_val = 0;\n\n\tfor (i = 0 ; i < hdev->asic_prop.max_queues ; i++) {\n\t\tif (hdev->asic_prop.hw_queues_props[i].type == QUEUE_TYPE_EXT) {\n\t\t\trc = gaudi_test_queue(hdev, i);\n\t\t\tif (rc)\n\t\t\t\tret_val = -EINVAL;\n\t\t}\n\t}\n\n\trc = gaudi_test_cpu_queue(hdev);\n\tif (rc)\n\t\tret_val = -EINVAL;\n\n\treturn ret_val;\n}\n\nstatic void *gaudi_dma_pool_zalloc(struct hl_device *hdev, size_t size,\n\t\tgfp_t mem_flags, dma_addr_t *dma_handle)\n{\n\tvoid *kernel_addr;\n\n\tif (size > GAUDI_DMA_POOL_BLK_SIZE)\n\t\treturn NULL;\n\n\tkernel_addr = dma_pool_zalloc(hdev->dma_pool, mem_flags, dma_handle);\n\n\t/* Shift to the device's base physical address of host memory */\n\tif (kernel_addr)\n\t\t*dma_handle += HOST_PHYS_BASE;\n\n\treturn kernel_addr;\n}\n\nstatic void gaudi_dma_pool_free(struct hl_device *hdev, void *vaddr,\n\t\t\tdma_addr_t dma_addr)\n{\n\t/* Cancel the device's base physical address of host memory */\n\tdma_addr_t fixed_dma_addr = dma_addr - HOST_PHYS_BASE;\n\n\tdma_pool_free(hdev->dma_pool, vaddr, fixed_dma_addr);\n}\n\nstatic void *gaudi_cpu_accessible_dma_pool_alloc(struct hl_device *hdev,\n\t\t\t\t\tsize_t size, dma_addr_t *dma_handle)\n{\n\treturn hl_fw_cpu_accessible_dma_pool_alloc(hdev, size, dma_handle);\n}\n\nstatic void gaudi_cpu_accessible_dma_pool_free(struct hl_device *hdev,\n\t\t\t\t\t\tsize_t size, void *vaddr)\n{\n\thl_fw_cpu_accessible_dma_pool_free(hdev, size, vaddr);\n}\n\nstatic int gaudi_dma_map_sg(struct hl_device *hdev, struct scatterlist *sgl,\n\t\t\tint nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tif (!dma_map_sg(&hdev->pdev->dev, sgl, nents, dir))\n\t\treturn -ENOMEM;\n\n\t/* Shift to the device's base physical address of host memory */\n\tfor_each_sg(sgl, sg, nents, i)\n\t\tsg->dma_address += HOST_PHYS_BASE;\n\n\treturn 0;\n}\n\nstatic void gaudi_dma_unmap_sg(struct hl_device *hdev, struct scatterlist *sgl,\n\t\t\tint nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\t/* Cancel the device's base physical address of host memory */\n\tfor_each_sg(sgl, sg, nents, i)\n\t\tsg->dma_address -= HOST_PHYS_BASE;\n\n\tdma_unmap_sg(&hdev->pdev->dev, sgl, nents, dir);\n}\n\nstatic u32 gaudi_get_dma_desc_list_size(struct hl_device *hdev,\n\t\t\t\t\tstruct sg_table *sgt)\n{\n\tstruct scatterlist *sg, *sg_next_iter;\n\tu32 count, dma_desc_cnt;\n\tu64 len, len_next;\n\tdma_addr_t addr, addr_next;\n\n\tdma_desc_cnt = 0;\n\n\tfor_each_sg(sgt->sgl, sg, sgt->nents, count) {\n\n\t\tlen = sg_dma_len(sg);\n\t\taddr = sg_dma_address(sg);\n\n\t\tif (len == 0)\n\t\t\tbreak;\n\n\t\twhile ((count + 1) < sgt->nents) {\n\t\t\tsg_next_iter = sg_next(sg);\n\t\t\tlen_next = sg_dma_len(sg_next_iter);\n\t\t\taddr_next = sg_dma_address(sg_next_iter);\n\n\t\t\tif (len_next == 0)\n\t\t\t\tbreak;\n\n\t\t\tif ((addr + len == addr_next) &&\n\t\t\t\t(len + len_next <= DMA_MAX_TRANSFER_SIZE)) {\n\t\t\t\tlen += len_next;\n\t\t\t\tcount++;\n\t\t\t\tsg = sg_next_iter;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdma_desc_cnt++;\n\t}\n\n\treturn dma_desc_cnt * sizeof(struct packet_lin_dma);\n}\n\nstatic int gaudi_pin_memory_before_cs(struct hl_device *hdev,\n\t\t\t\tstruct hl_cs_parser *parser,\n\t\t\t\tstruct packet_lin_dma *user_dma_pkt,\n\t\t\t\tu64 addr, enum dma_data_direction dir)\n{\n\tstruct hl_userptr *userptr;\n\tint rc;\n\n\tif (hl_userptr_is_pinned(hdev, addr, le32_to_cpu(user_dma_pkt->tsize),\n\t\t\tparser->job_userptr_list, &userptr))\n\t\tgoto already_pinned;\n\n\tuserptr = kzalloc(sizeof(*userptr), GFP_ATOMIC);\n\tif (!userptr)\n\t\treturn -ENOMEM;\n\n\trc = hl_pin_host_memory(hdev, addr, le32_to_cpu(user_dma_pkt->tsize),\n\t\t\t\tuserptr);\n\tif (rc)\n\t\tgoto free_userptr;\n\n\tlist_add_tail(&userptr->job_node, parser->job_userptr_list);\n\n\trc = hdev->asic_funcs->asic_dma_map_sg(hdev, userptr->sgt->sgl,\n\t\t\t\t\tuserptr->sgt->nents, dir);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to map sgt with DMA region\\n\");\n\t\tgoto unpin_memory;\n\t}\n\n\tuserptr->dma_mapped = true;\n\tuserptr->dir = dir;\n\nalready_pinned:\n\tparser->patched_cb_size +=\n\t\t\tgaudi_get_dma_desc_list_size(hdev, userptr->sgt);\n\n\treturn 0;\n\nunpin_memory:\n\thl_unpin_host_memory(hdev, userptr);\nfree_userptr:\n\tkfree(userptr);\n\treturn rc;\n}\n\nstatic int gaudi_validate_dma_pkt_host(struct hl_device *hdev,\n\t\t\t\tstruct hl_cs_parser *parser,\n\t\t\t\tstruct packet_lin_dma *user_dma_pkt,\n\t\t\t\tbool src_in_host)\n{\n\tenum dma_data_direction dir;\n\tbool skip_host_mem_pin = false, user_memset;\n\tu64 addr;\n\tint rc = 0;\n\n\tuser_memset = (le32_to_cpu(user_dma_pkt->ctl) &\n\t\t\tGAUDI_PKT_LIN_DMA_CTL_MEMSET_MASK) >>\n\t\t\tGAUDI_PKT_LIN_DMA_CTL_MEMSET_SHIFT;\n\n\tif (src_in_host) {\n\t\tif (user_memset)\n\t\t\tskip_host_mem_pin = true;\n\n\t\tdev_dbg(hdev->dev, \"DMA direction is HOST --> DEVICE\\n\");\n\t\tdir = DMA_TO_DEVICE;\n\t\taddr = le64_to_cpu(user_dma_pkt->src_addr);\n\t} else {\n\t\tdev_dbg(hdev->dev, \"DMA direction is DEVICE --> HOST\\n\");\n\t\tdir = DMA_FROM_DEVICE;\n\t\taddr = (le64_to_cpu(user_dma_pkt->dst_addr) &\n\t\t\t\tGAUDI_PKT_LIN_DMA_DST_ADDR_MASK) >>\n\t\t\t\tGAUDI_PKT_LIN_DMA_DST_ADDR_SHIFT;\n\t}\n\n\tif (skip_host_mem_pin)\n\t\tparser->patched_cb_size += sizeof(*user_dma_pkt);\n\telse\n\t\trc = gaudi_pin_memory_before_cs(hdev, parser, user_dma_pkt,\n\t\t\t\t\t\taddr, dir);\n\n\treturn rc;\n}\n\nstatic int gaudi_validate_dma_pkt_no_mmu(struct hl_device *hdev,\n\t\t\t\tstruct hl_cs_parser *parser,\n\t\t\t\tstruct packet_lin_dma *user_dma_pkt)\n{\n\tbool src_in_host = false;\n\tu64 dst_addr = (le64_to_cpu(user_dma_pkt->dst_addr) &\n\t\t\tGAUDI_PKT_LIN_DMA_DST_ADDR_MASK) >>\n\t\t\tGAUDI_PKT_LIN_DMA_DST_ADDR_SHIFT;\n\n\tdev_dbg(hdev->dev, \"DMA packet details:\\n\");\n\tdev_dbg(hdev->dev, \"source == 0x%llx\\n\",\n\t\t\t\tle64_to_cpu(user_dma_pkt->src_addr));\n\tdev_dbg(hdev->dev, \"destination == 0x%llx\\n\", dst_addr);\n\tdev_dbg(hdev->dev, \"size == %u\\n\", le32_to_cpu(user_dma_pkt->tsize));\n\n\t/*\n\t * Special handling for DMA with size 0. Bypass all validations\n\t * because no transactions will be done except for WR_COMP, which\n\t * is not a security issue\n\t */\n\tif (!le32_to_cpu(user_dma_pkt->tsize)) {\n\t\tparser->patched_cb_size += sizeof(*user_dma_pkt);\n\t\treturn 0;\n\t}\n\n\tif (parser->hw_queue_id <= GAUDI_QUEUE_ID_DMA_0_3)\n\t\tsrc_in_host = true;\n\n\treturn gaudi_validate_dma_pkt_host(hdev, parser, user_dma_pkt,\n\t\t\t\t\t\tsrc_in_host);\n}\n\nstatic int gaudi_validate_load_and_exe_pkt(struct hl_device *hdev,\n\t\t\t\t\tstruct hl_cs_parser *parser,\n\t\t\t\t\tstruct packet_load_and_exe *user_pkt)\n{\n\tu32 cfg;\n\n\tcfg = le32_to_cpu(user_pkt->cfg);\n\n\tif (cfg & GAUDI_PKT_LOAD_AND_EXE_CFG_DST_MASK) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"User not allowed to use Load and Execute\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tparser->patched_cb_size += sizeof(struct packet_load_and_exe);\n\n\treturn 0;\n}\n\nstatic int gaudi_validate_cb(struct hl_device *hdev,\n\t\t\tstruct hl_cs_parser *parser, bool is_mmu)\n{\n\tu32 cb_parsed_length = 0;\n\tint rc = 0;\n\n\tparser->patched_cb_size = 0;\n\n\t/* cb_user_size is more than 0 so loop will always be executed */\n\twhile (cb_parsed_length < parser->user_cb_size) {\n\t\tenum packet_id pkt_id;\n\t\tu16 pkt_size;\n\t\tstruct gaudi_packet *user_pkt;\n\n\t\tuser_pkt = parser->user_cb->kernel_address + cb_parsed_length;\n\n\t\tpkt_id = (enum packet_id) (\n\t\t\t\t(le64_to_cpu(user_pkt->header) &\n\t\t\t\tPACKET_HEADER_PACKET_ID_MASK) >>\n\t\t\t\t\tPACKET_HEADER_PACKET_ID_SHIFT);\n\n\t\tif (!validate_packet_id(pkt_id)) {\n\t\t\tdev_err(hdev->dev, \"Invalid packet id %u\\n\", pkt_id);\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpkt_size = gaudi_packet_sizes[pkt_id];\n\t\tcb_parsed_length += pkt_size;\n\t\tif (cb_parsed_length > parser->user_cb_size) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"packet 0x%x is out of CB boundary\\n\", pkt_id);\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (pkt_id) {\n\t\tcase PACKET_MSG_PROT:\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"User not allowed to use MSG_PROT\\n\");\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\n\t\tcase PACKET_CP_DMA:\n\t\t\tdev_err(hdev->dev, \"User not allowed to use CP_DMA\\n\");\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\n\t\tcase PACKET_STOP:\n\t\t\tdev_err(hdev->dev, \"User not allowed to use STOP\\n\");\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\n\t\tcase PACKET_WREG_BULK:\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"User not allowed to use WREG_BULK\\n\");\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\n\t\tcase PACKET_LOAD_AND_EXE:\n\t\t\trc = gaudi_validate_load_and_exe_pkt(hdev, parser,\n\t\t\t\t(struct packet_load_and_exe *) user_pkt);\n\t\t\tbreak;\n\n\t\tcase PACKET_LIN_DMA:\n\t\t\tparser->contains_dma_pkt = true;\n\t\t\tif (is_mmu)\n\t\t\t\tparser->patched_cb_size += pkt_size;\n\t\t\telse\n\t\t\t\trc = gaudi_validate_dma_pkt_no_mmu(hdev, parser,\n\t\t\t\t\t(struct packet_lin_dma *) user_pkt);\n\t\t\tbreak;\n\n\t\tcase PACKET_WREG_32:\n\t\tcase PACKET_MSG_LONG:\n\t\tcase PACKET_MSG_SHORT:\n\t\tcase PACKET_REPEAT:\n\t\tcase PACKET_FENCE:\n\t\tcase PACKET_NOP:\n\t\tcase PACKET_ARB_POINT:\n\t\t\tparser->patched_cb_size += pkt_size;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(hdev->dev, \"Invalid packet header 0x%x\\n\",\n\t\t\t\tpkt_id);\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * The new CB should have space at the end for two MSG_PROT packets:\n\t * 1. A packet that will act as a completion packet\n\t * 2. A packet that will generate MSI-X interrupt\n\t */\n\tif (parser->completion)\n\t\tparser->patched_cb_size += sizeof(struct packet_msg_prot) * 2;\n\n\treturn rc;\n}\n\nstatic int gaudi_patch_dma_packet(struct hl_device *hdev,\n\t\t\t\tstruct hl_cs_parser *parser,\n\t\t\t\tstruct packet_lin_dma *user_dma_pkt,\n\t\t\t\tstruct packet_lin_dma *new_dma_pkt,\n\t\t\t\tu32 *new_dma_pkt_size)\n{\n\tstruct hl_userptr *userptr;\n\tstruct scatterlist *sg, *sg_next_iter;\n\tu32 count, dma_desc_cnt, user_wrcomp_en_mask, ctl;\n\tu64 len, len_next;\n\tdma_addr_t dma_addr, dma_addr_next;\n\tu64 device_memory_addr, addr;\n\tenum dma_data_direction dir;\n\tstruct sg_table *sgt;\n\tbool src_in_host = false;\n\tbool skip_host_mem_pin = false;\n\tbool user_memset;\n\n\tctl = le32_to_cpu(user_dma_pkt->ctl);\n\n\tif (parser->hw_queue_id <= GAUDI_QUEUE_ID_DMA_0_3)\n\t\tsrc_in_host = true;\n\n\tuser_memset = (ctl & GAUDI_PKT_LIN_DMA_CTL_MEMSET_MASK) >>\n\t\t\tGAUDI_PKT_LIN_DMA_CTL_MEMSET_SHIFT;\n\n\tif (src_in_host) {\n\t\taddr = le64_to_cpu(user_dma_pkt->src_addr);\n\t\tdevice_memory_addr = le64_to_cpu(user_dma_pkt->dst_addr);\n\t\tdir = DMA_TO_DEVICE;\n\t\tif (user_memset)\n\t\t\tskip_host_mem_pin = true;\n\t} else {\n\t\taddr = le64_to_cpu(user_dma_pkt->dst_addr);\n\t\tdevice_memory_addr = le64_to_cpu(user_dma_pkt->src_addr);\n\t\tdir = DMA_FROM_DEVICE;\n\t}\n\n\tif ((!skip_host_mem_pin) &&\n\t\t(!hl_userptr_is_pinned(hdev, addr,\n\t\t\t\t\tle32_to_cpu(user_dma_pkt->tsize),\n\t\t\t\t\tparser->job_userptr_list, &userptr))) {\n\t\tdev_err(hdev->dev, \"Userptr 0x%llx + 0x%x NOT mapped\\n\",\n\t\t\t\taddr, user_dma_pkt->tsize);\n\t\treturn -EFAULT;\n\t}\n\n\tif ((user_memset) && (dir == DMA_TO_DEVICE)) {\n\t\tmemcpy(new_dma_pkt, user_dma_pkt, sizeof(*user_dma_pkt));\n\t\t*new_dma_pkt_size = sizeof(*user_dma_pkt);\n\t\treturn 0;\n\t}\n\n\tuser_wrcomp_en_mask = ctl & GAUDI_PKT_LIN_DMA_CTL_WRCOMP_EN_MASK;\n\n\tsgt = userptr->sgt;\n\tdma_desc_cnt = 0;\n\n\tfor_each_sg(sgt->sgl, sg, sgt->nents, count) {\n\t\tlen = sg_dma_len(sg);\n\t\tdma_addr = sg_dma_address(sg);\n\n\t\tif (len == 0)\n\t\t\tbreak;\n\n\t\twhile ((count + 1) < sgt->nents) {\n\t\t\tsg_next_iter = sg_next(sg);\n\t\t\tlen_next = sg_dma_len(sg_next_iter);\n\t\t\tdma_addr_next = sg_dma_address(sg_next_iter);\n\n\t\t\tif (len_next == 0)\n\t\t\t\tbreak;\n\n\t\t\tif ((dma_addr + len == dma_addr_next) &&\n\t\t\t\t(len + len_next <= DMA_MAX_TRANSFER_SIZE)) {\n\t\t\t\tlen += len_next;\n\t\t\t\tcount++;\n\t\t\t\tsg = sg_next_iter;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tctl = le32_to_cpu(user_dma_pkt->ctl);\n\t\tif (likely(dma_desc_cnt))\n\t\t\tctl &= ~GAUDI_PKT_CTL_EB_MASK;\n\t\tctl &= ~GAUDI_PKT_LIN_DMA_CTL_WRCOMP_EN_MASK;\n\t\tnew_dma_pkt->ctl = cpu_to_le32(ctl);\n\t\tnew_dma_pkt->tsize = cpu_to_le32(len);\n\n\t\tif (dir == DMA_TO_DEVICE) {\n\t\t\tnew_dma_pkt->src_addr = cpu_to_le64(dma_addr);\n\t\t\tnew_dma_pkt->dst_addr = cpu_to_le64(device_memory_addr);\n\t\t} else {\n\t\t\tnew_dma_pkt->src_addr = cpu_to_le64(device_memory_addr);\n\t\t\tnew_dma_pkt->dst_addr = cpu_to_le64(dma_addr);\n\t\t}\n\n\t\tif (!user_memset)\n\t\t\tdevice_memory_addr += len;\n\t\tdma_desc_cnt++;\n\t\tnew_dma_pkt++;\n\t}\n\n\tif (!dma_desc_cnt) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Error of 0 SG entries when patching DMA packet\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t/* Fix the last dma packet - wrcomp must be as user set it */\n\tnew_dma_pkt--;\n\tnew_dma_pkt->ctl |= cpu_to_le32(user_wrcomp_en_mask);\n\n\t*new_dma_pkt_size = dma_desc_cnt * sizeof(struct packet_lin_dma);\n\n\treturn 0;\n}\n\nstatic int gaudi_patch_cb(struct hl_device *hdev,\n\t\t\t\tstruct hl_cs_parser *parser)\n{\n\tu32 cb_parsed_length = 0;\n\tu32 cb_patched_cur_length = 0;\n\tint rc = 0;\n\n\t/* cb_user_size is more than 0 so loop will always be executed */\n\twhile (cb_parsed_length < parser->user_cb_size) {\n\t\tenum packet_id pkt_id;\n\t\tu16 pkt_size;\n\t\tu32 new_pkt_size = 0;\n\t\tstruct gaudi_packet *user_pkt, *kernel_pkt;\n\n\t\tuser_pkt = parser->user_cb->kernel_address + cb_parsed_length;\n\t\tkernel_pkt = parser->patched_cb->kernel_address +\n\t\t\t\t\tcb_patched_cur_length;\n\n\t\tpkt_id = (enum packet_id) (\n\t\t\t\t(le64_to_cpu(user_pkt->header) &\n\t\t\t\tPACKET_HEADER_PACKET_ID_MASK) >>\n\t\t\t\t\tPACKET_HEADER_PACKET_ID_SHIFT);\n\n\t\tif (!validate_packet_id(pkt_id)) {\n\t\t\tdev_err(hdev->dev, \"Invalid packet id %u\\n\", pkt_id);\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpkt_size = gaudi_packet_sizes[pkt_id];\n\t\tcb_parsed_length += pkt_size;\n\t\tif (cb_parsed_length > parser->user_cb_size) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"packet 0x%x is out of CB boundary\\n\", pkt_id);\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (pkt_id) {\n\t\tcase PACKET_LIN_DMA:\n\t\t\trc = gaudi_patch_dma_packet(hdev, parser,\n\t\t\t\t\t(struct packet_lin_dma *) user_pkt,\n\t\t\t\t\t(struct packet_lin_dma *) kernel_pkt,\n\t\t\t\t\t&new_pkt_size);\n\t\t\tcb_patched_cur_length += new_pkt_size;\n\t\t\tbreak;\n\n\t\tcase PACKET_MSG_PROT:\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"User not allowed to use MSG_PROT\\n\");\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\n\t\tcase PACKET_CP_DMA:\n\t\t\tdev_err(hdev->dev, \"User not allowed to use CP_DMA\\n\");\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\n\t\tcase PACKET_STOP:\n\t\t\tdev_err(hdev->dev, \"User not allowed to use STOP\\n\");\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\n\t\tcase PACKET_WREG_32:\n\t\tcase PACKET_WREG_BULK:\n\t\tcase PACKET_MSG_LONG:\n\t\tcase PACKET_MSG_SHORT:\n\t\tcase PACKET_REPEAT:\n\t\tcase PACKET_FENCE:\n\t\tcase PACKET_NOP:\n\t\tcase PACKET_ARB_POINT:\n\t\tcase PACKET_LOAD_AND_EXE:\n\t\t\tmemcpy(kernel_pkt, user_pkt, pkt_size);\n\t\t\tcb_patched_cur_length += pkt_size;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(hdev->dev, \"Invalid packet header 0x%x\\n\",\n\t\t\t\tpkt_id);\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int gaudi_parse_cb_mmu(struct hl_device *hdev,\n\t\tstruct hl_cs_parser *parser)\n{\n\tu64 patched_cb_handle;\n\tu32 patched_cb_size;\n\tstruct hl_cb *user_cb;\n\tint rc;\n\n\t/*\n\t * The new CB should have space at the end for two MSG_PROT pkt:\n\t * 1. A packet that will act as a completion packet\n\t * 2. A packet that will generate MSI interrupt\n\t */\n\tif (parser->completion)\n\t\tparser->patched_cb_size = parser->user_cb_size +\n\t\t\t\tsizeof(struct packet_msg_prot) * 2;\n\telse\n\t\tparser->patched_cb_size = parser->user_cb_size;\n\n\trc = hl_cb_create(hdev, &hdev->kernel_cb_mgr, hdev->kernel_ctx,\n\t\t\t\tparser->patched_cb_size, false, false,\n\t\t\t\t&patched_cb_handle);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate patched CB for DMA CS %d\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\n\tpatched_cb_handle >>= PAGE_SHIFT;\n\tparser->patched_cb = hl_cb_get(hdev, &hdev->kernel_cb_mgr,\n\t\t\t\t(u32) patched_cb_handle);\n\t/* hl_cb_get should never fail */\n\tif (!parser->patched_cb) {\n\t\tdev_crit(hdev->dev, \"DMA CB handle invalid 0x%x\\n\",\n\t\t\t(u32) patched_cb_handle);\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The check that parser->user_cb_size <= parser->user_cb->size was done\n\t * in validate_queue_index().\n\t */\n\tmemcpy(parser->patched_cb->kernel_address,\n\t\tparser->user_cb->kernel_address,\n\t\tparser->user_cb_size);\n\n\tpatched_cb_size = parser->patched_cb_size;\n\n\t/* Validate patched CB instead of user CB */\n\tuser_cb = parser->user_cb;\n\tparser->user_cb = parser->patched_cb;\n\trc = gaudi_validate_cb(hdev, parser, true);\n\tparser->user_cb = user_cb;\n\n\tif (rc) {\n\t\thl_cb_put(parser->patched_cb);\n\t\tgoto out;\n\t}\n\n\tif (patched_cb_size != parser->patched_cb_size) {\n\t\tdev_err(hdev->dev, \"user CB size mismatch\\n\");\n\t\thl_cb_put(parser->patched_cb);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\nout:\n\t/*\n\t * Always call cb destroy here because we still have 1 reference\n\t * to it by calling cb_get earlier. After the job will be completed,\n\t * cb_put will release it, but here we want to remove it from the\n\t * idr\n\t */\n\thl_cb_destroy(hdev, &hdev->kernel_cb_mgr,\n\t\t\t\t\tpatched_cb_handle << PAGE_SHIFT);\n\n\treturn rc;\n}\n\nstatic int gaudi_parse_cb_no_mmu(struct hl_device *hdev,\n\t\tstruct hl_cs_parser *parser)\n{\n\tu64 patched_cb_handle;\n\tint rc;\n\n\trc = gaudi_validate_cb(hdev, parser, false);\n\n\tif (rc)\n\t\tgoto free_userptr;\n\n\trc = hl_cb_create(hdev, &hdev->kernel_cb_mgr, hdev->kernel_ctx,\n\t\t\t\tparser->patched_cb_size, false, false,\n\t\t\t\t&patched_cb_handle);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate patched CB for DMA CS %d\\n\", rc);\n\t\tgoto free_userptr;\n\t}\n\n\tpatched_cb_handle >>= PAGE_SHIFT;\n\tparser->patched_cb = hl_cb_get(hdev, &hdev->kernel_cb_mgr,\n\t\t\t\t(u32) patched_cb_handle);\n\t/* hl_cb_get should never fail here */\n\tif (!parser->patched_cb) {\n\t\tdev_crit(hdev->dev, \"DMA CB handle invalid 0x%x\\n\",\n\t\t\t\t(u32) patched_cb_handle);\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\trc = gaudi_patch_cb(hdev, parser);\n\n\tif (rc)\n\t\thl_cb_put(parser->patched_cb);\n\nout:\n\t/*\n\t * Always call cb destroy here because we still have 1 reference\n\t * to it by calling cb_get earlier. After the job will be completed,\n\t * cb_put will release it, but here we want to remove it from the\n\t * idr\n\t */\n\thl_cb_destroy(hdev, &hdev->kernel_cb_mgr,\n\t\t\t\tpatched_cb_handle << PAGE_SHIFT);\n\nfree_userptr:\n\tif (rc)\n\t\thl_userptr_delete_list(hdev, parser->job_userptr_list);\n\treturn rc;\n}\n\nstatic int gaudi_parse_cb_no_ext_queue(struct hl_device *hdev,\n\t\t\t\t\tstruct hl_cs_parser *parser)\n{\n\tstruct asic_fixed_properties *asic_prop = &hdev->asic_prop;\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu32 nic_mask_q_id = 1 << (HW_CAP_NIC_SHIFT +\n\t\t((parser->hw_queue_id - GAUDI_QUEUE_ID_NIC_0_0) >> 2));\n\n\tif ((parser->hw_queue_id >= GAUDI_QUEUE_ID_NIC_0_0) &&\n\t\t\t(parser->hw_queue_id <= GAUDI_QUEUE_ID_NIC_9_3) &&\n\t\t\t(!(gaudi->hw_cap_initialized & nic_mask_q_id))) {\n\t\tdev_err(hdev->dev, \"h/w queue %d is disabled\\n\",\n\t\t\t\tparser->hw_queue_id);\n\t\treturn -EINVAL;\n\t}\n\n\t/* For internal queue jobs just check if CB address is valid */\n\tif (hl_mem_area_inside_range((u64) (uintptr_t) parser->user_cb,\n\t\t\t\t\tparser->user_cb_size,\n\t\t\t\t\tasic_prop->sram_user_base_address,\n\t\t\t\t\tasic_prop->sram_end_address))\n\t\treturn 0;\n\n\tif (hl_mem_area_inside_range((u64) (uintptr_t) parser->user_cb,\n\t\t\t\t\tparser->user_cb_size,\n\t\t\t\t\tasic_prop->dram_user_base_address,\n\t\t\t\t\tasic_prop->dram_end_address))\n\t\treturn 0;\n\n\t/* PMMU and HPMMU addresses are equal, check only one of them */\n\tif (hl_mem_area_inside_range((u64) (uintptr_t) parser->user_cb,\n\t\t\t\t\tparser->user_cb_size,\n\t\t\t\t\tasic_prop->pmmu.start_addr,\n\t\t\t\t\tasic_prop->pmmu.end_addr))\n\t\treturn 0;\n\n\tdev_err(hdev->dev,\n\t\t\"CB address 0x%px + 0x%x for internal QMAN is not valid\\n\",\n\t\tparser->user_cb, parser->user_cb_size);\n\n\treturn -EFAULT;\n}\n\nstatic int gaudi_cs_parser(struct hl_device *hdev, struct hl_cs_parser *parser)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (parser->queue_type == QUEUE_TYPE_INT)\n\t\treturn gaudi_parse_cb_no_ext_queue(hdev, parser);\n\n\tif (gaudi->hw_cap_initialized & HW_CAP_MMU)\n\t\treturn gaudi_parse_cb_mmu(hdev, parser);\n\telse\n\t\treturn gaudi_parse_cb_no_mmu(hdev, parser);\n}\n\nstatic void gaudi_add_end_of_cb_packets(struct hl_device *hdev,\n\t\t\t\t\tvoid *kernel_address, u32 len,\n\t\t\t\t\tu64 cq_addr, u32 cq_val, u32 msi_vec,\n\t\t\t\t\tbool eb)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tstruct packet_msg_prot *cq_pkt;\n\tu32 tmp;\n\n\tcq_pkt = kernel_address + len - (sizeof(struct packet_msg_prot) * 2);\n\n\ttmp = FIELD_PREP(GAUDI_PKT_CTL_OPCODE_MASK, PACKET_MSG_PROT);\n\ttmp |= FIELD_PREP(GAUDI_PKT_CTL_MB_MASK, 1);\n\n\tif (eb)\n\t\ttmp |= FIELD_PREP(GAUDI_PKT_CTL_EB_MASK, 1);\n\n\tcq_pkt->ctl = cpu_to_le32(tmp);\n\tcq_pkt->value = cpu_to_le32(cq_val);\n\tcq_pkt->addr = cpu_to_le64(cq_addr);\n\n\tcq_pkt++;\n\n\ttmp = FIELD_PREP(GAUDI_PKT_CTL_OPCODE_MASK, PACKET_MSG_PROT);\n\ttmp |= FIELD_PREP(GAUDI_PKT_CTL_MB_MASK, 1);\n\tcq_pkt->ctl = cpu_to_le32(tmp);\n\tcq_pkt->value = cpu_to_le32(1);\n\n\tif (!gaudi->multi_msi_mode)\n\t\tmsi_vec = 0;\n\n\tcq_pkt->addr = cpu_to_le64(CFG_BASE + mmPCIE_MSI_INTR_0 + msi_vec * 4);\n}\n\nstatic void gaudi_update_eq_ci(struct hl_device *hdev, u32 val)\n{\n\tWREG32(mmCPU_IF_EQ_RD_OFFS, val);\n}\n\nstatic int gaudi_memset_device_memory(struct hl_device *hdev, u64 addr,\n\t\t\t\t\tu32 size, u64 val)\n{\n\tstruct packet_lin_dma *lin_dma_pkt;\n\tstruct hl_cs_job *job;\n\tu32 cb_size, ctl, err_cause;\n\tstruct hl_cb *cb;\n\tint rc;\n\n\tcb = hl_cb_kernel_create(hdev, PAGE_SIZE, false);\n\tif (!cb)\n\t\treturn -EFAULT;\n\n\tlin_dma_pkt = cb->kernel_address;\n\tmemset(lin_dma_pkt, 0, sizeof(*lin_dma_pkt));\n\tcb_size = sizeof(*lin_dma_pkt);\n\n\tctl = FIELD_PREP(GAUDI_PKT_CTL_OPCODE_MASK, PACKET_LIN_DMA);\n\tctl |= FIELD_PREP(GAUDI_PKT_LIN_DMA_CTL_MEMSET_MASK, 1);\n\tctl |= FIELD_PREP(GAUDI_PKT_LIN_DMA_CTL_LIN_MASK, 1);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_MB_MASK, 1);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_RB_MASK, 1);\n\n\tlin_dma_pkt->ctl = cpu_to_le32(ctl);\n\tlin_dma_pkt->src_addr = cpu_to_le64(val);\n\tlin_dma_pkt->dst_addr |= cpu_to_le64(addr);\n\tlin_dma_pkt->tsize = cpu_to_le32(size);\n\n\tjob = hl_cs_allocate_job(hdev, QUEUE_TYPE_EXT, true);\n\tif (!job) {\n\t\tdev_err(hdev->dev, \"Failed to allocate a new job\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto release_cb;\n\t}\n\n\t/* Verify DMA is OK */\n\terr_cause = RREG32(mmDMA0_CORE_ERR_CAUSE);\n\tif (err_cause && !hdev->init_done) {\n\t\tdev_dbg(hdev->dev,\n\t\t\t\"Clearing DMA0 engine from errors (cause 0x%x)\\n\",\n\t\t\terr_cause);\n\t\tWREG32(mmDMA0_CORE_ERR_CAUSE, err_cause);\n\t}\n\n\tjob->id = 0;\n\tjob->user_cb = cb;\n\tatomic_inc(&job->user_cb->cs_cnt);\n\tjob->user_cb_size = cb_size;\n\tjob->hw_queue_id = GAUDI_QUEUE_ID_DMA_0_0;\n\tjob->patched_cb = job->user_cb;\n\tjob->job_cb_size = job->user_cb_size + sizeof(struct packet_msg_prot);\n\n\thl_debugfs_add_job(hdev, job);\n\n\trc = gaudi_send_job_on_qman0(hdev, job);\n\thl_debugfs_remove_job(hdev, job);\n\tkfree(job);\n\tatomic_dec(&cb->cs_cnt);\n\n\t/* Verify DMA is OK */\n\terr_cause = RREG32(mmDMA0_CORE_ERR_CAUSE);\n\tif (err_cause) {\n\t\tdev_err(hdev->dev, \"DMA Failed, cause 0x%x\\n\", err_cause);\n\t\trc = -EIO;\n\t\tif (!hdev->init_done) {\n\t\t\tdev_dbg(hdev->dev,\n\t\t\t\t\"Clearing DMA0 engine from errors (cause 0x%x)\\n\",\n\t\t\t\terr_cause);\n\t\t\tWREG32(mmDMA0_CORE_ERR_CAUSE, err_cause);\n\t\t}\n\t}\n\nrelease_cb:\n\thl_cb_put(cb);\n\thl_cb_destroy(hdev, &hdev->kernel_cb_mgr, cb->id << PAGE_SHIFT);\n\n\treturn rc;\n}\n\nstatic int gaudi_memset_registers(struct hl_device *hdev, u64 reg_base,\n\t\t\t\t\tu32 num_regs, u32 val)\n{\n\tstruct packet_msg_long *pkt;\n\tstruct hl_cs_job *job;\n\tu32 cb_size, ctl;\n\tstruct hl_cb *cb;\n\tint i, rc;\n\n\tcb_size = (sizeof(*pkt) * num_regs) + sizeof(struct packet_msg_prot);\n\n\tif (cb_size > SZ_2M) {\n\t\tdev_err(hdev->dev, \"CB size must be smaller than %uMB\", SZ_2M);\n\t\treturn -ENOMEM;\n\t}\n\n\tcb = hl_cb_kernel_create(hdev, cb_size, false);\n\tif (!cb)\n\t\treturn -EFAULT;\n\n\tpkt = cb->kernel_address;\n\n\tctl = FIELD_PREP(GAUDI_PKT_LONG_CTL_OP_MASK, 0); /* write the value */\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_OPCODE_MASK, PACKET_MSG_LONG);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_EB_MASK, 1);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_RB_MASK, 1);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_MB_MASK, 1);\n\n\tfor (i = 0; i < num_regs ; i++, pkt++) {\n\t\tpkt->ctl = cpu_to_le32(ctl);\n\t\tpkt->value = cpu_to_le32(val);\n\t\tpkt->addr = cpu_to_le64(reg_base + (i * 4));\n\t}\n\n\tjob = hl_cs_allocate_job(hdev, QUEUE_TYPE_EXT, true);\n\tif (!job) {\n\t\tdev_err(hdev->dev, \"Failed to allocate a new job\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto release_cb;\n\t}\n\n\tjob->id = 0;\n\tjob->user_cb = cb;\n\tatomic_inc(&job->user_cb->cs_cnt);\n\tjob->user_cb_size = cb_size;\n\tjob->hw_queue_id = GAUDI_QUEUE_ID_DMA_0_0;\n\tjob->patched_cb = job->user_cb;\n\tjob->job_cb_size = cb_size;\n\n\thl_debugfs_add_job(hdev, job);\n\n\trc = gaudi_send_job_on_qman0(hdev, job);\n\thl_debugfs_remove_job(hdev, job);\n\tkfree(job);\n\tatomic_dec(&cb->cs_cnt);\n\nrelease_cb:\n\thl_cb_put(cb);\n\thl_cb_destroy(hdev, &hdev->kernel_cb_mgr, cb->id << PAGE_SHIFT);\n\n\treturn rc;\n}\n\nstatic int gaudi_schedule_register_memset(struct hl_device *hdev,\n\t\tu32 hw_queue_id, u64 reg_base, u32 num_regs, u32 val)\n{\n\tstruct hl_ctx *ctx = hdev->compute_ctx;\n\tstruct hl_pending_cb *pending_cb;\n\tstruct packet_msg_long *pkt;\n\tu32 cb_size, ctl;\n\tstruct hl_cb *cb;\n\tint i;\n\n\t/* If no compute context available or context is going down\n\t * memset registers directly\n\t */\n\tif (!ctx || kref_read(&ctx->refcount) == 0)\n\t\treturn gaudi_memset_registers(hdev, reg_base, num_regs, val);\n\n\tcb_size = (sizeof(*pkt) * num_regs) +\n\t\t\tsizeof(struct packet_msg_prot) * 2;\n\n\tif (cb_size > SZ_2M) {\n\t\tdev_err(hdev->dev, \"CB size must be smaller than %uMB\", SZ_2M);\n\t\treturn -ENOMEM;\n\t}\n\n\tpending_cb = kzalloc(sizeof(*pending_cb), GFP_KERNEL);\n\tif (!pending_cb)\n\t\treturn -ENOMEM;\n\n\tcb = hl_cb_kernel_create(hdev, cb_size, false);\n\tif (!cb) {\n\t\tkfree(pending_cb);\n\t\treturn -EFAULT;\n\t}\n\n\tpkt = cb->kernel_address;\n\n\tctl = FIELD_PREP(GAUDI_PKT_LONG_CTL_OP_MASK, 0); /* write the value */\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_OPCODE_MASK, PACKET_MSG_LONG);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_EB_MASK, 1);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_RB_MASK, 1);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_MB_MASK, 1);\n\n\tfor (i = 0; i < num_regs ; i++, pkt++) {\n\t\tpkt->ctl = cpu_to_le32(ctl);\n\t\tpkt->value = cpu_to_le32(val);\n\t\tpkt->addr = cpu_to_le64(reg_base + (i * 4));\n\t}\n\n\thl_cb_destroy(hdev, &hdev->kernel_cb_mgr, cb->id << PAGE_SHIFT);\n\n\tpending_cb->cb = cb;\n\tpending_cb->cb_size = cb_size;\n\t/* The queue ID MUST be an external queue ID. Otherwise, we will\n\t * have undefined behavior\n\t */\n\tpending_cb->hw_queue_id = hw_queue_id;\n\n\tspin_lock(&ctx->pending_cb_lock);\n\tlist_add_tail(&pending_cb->cb_node, &ctx->pending_cb_list);\n\tspin_unlock(&ctx->pending_cb_lock);\n\n\treturn 0;\n}\n\nstatic int gaudi_restore_sm_registers(struct hl_device *hdev)\n{\n\tu64 base_addr;\n\tu32 num_regs;\n\tint rc;\n\n\tbase_addr = CFG_BASE + mmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_SOB_OBJ_0;\n\tnum_regs = NUM_OF_SOB_IN_BLOCK;\n\trc = gaudi_memset_registers(hdev, base_addr, num_regs, 0);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed resetting SM registers\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbase_addr = CFG_BASE +  mmSYNC_MNGR_E_S_SYNC_MNGR_OBJS_SOB_OBJ_0;\n\tnum_regs = NUM_OF_SOB_IN_BLOCK;\n\trc = gaudi_memset_registers(hdev, base_addr, num_regs, 0);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed resetting SM registers\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbase_addr = CFG_BASE +  mmSYNC_MNGR_W_N_SYNC_MNGR_OBJS_SOB_OBJ_0;\n\tnum_regs = NUM_OF_SOB_IN_BLOCK;\n\trc = gaudi_memset_registers(hdev, base_addr, num_regs, 0);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed resetting SM registers\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbase_addr = CFG_BASE +  mmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_MON_STATUS_0;\n\tnum_regs = NUM_OF_MONITORS_IN_BLOCK;\n\trc = gaudi_memset_registers(hdev, base_addr, num_regs, 0);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed resetting SM registers\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbase_addr = CFG_BASE +  mmSYNC_MNGR_E_S_SYNC_MNGR_OBJS_MON_STATUS_0;\n\tnum_regs = NUM_OF_MONITORS_IN_BLOCK;\n\trc = gaudi_memset_registers(hdev, base_addr, num_regs, 0);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed resetting SM registers\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbase_addr = CFG_BASE +  mmSYNC_MNGR_W_N_SYNC_MNGR_OBJS_MON_STATUS_0;\n\tnum_regs = NUM_OF_MONITORS_IN_BLOCK;\n\trc = gaudi_memset_registers(hdev, base_addr, num_regs, 0);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed resetting SM registers\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbase_addr = CFG_BASE +  mmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_SOB_OBJ_0 +\n\t\t\t(GAUDI_FIRST_AVAILABLE_W_S_SYNC_OBJECT * 4);\n\tnum_regs = NUM_OF_SOB_IN_BLOCK - GAUDI_FIRST_AVAILABLE_W_S_SYNC_OBJECT;\n\trc = gaudi_memset_registers(hdev, base_addr, num_regs, 0);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed resetting SM registers\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbase_addr = CFG_BASE +  mmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_MON_STATUS_0 +\n\t\t\t(GAUDI_FIRST_AVAILABLE_W_S_MONITOR * 4);\n\tnum_regs = NUM_OF_MONITORS_IN_BLOCK - GAUDI_FIRST_AVAILABLE_W_S_MONITOR;\n\trc = gaudi_memset_registers(hdev, base_addr, num_regs, 0);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed resetting SM registers\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void gaudi_restore_dma_registers(struct hl_device *hdev)\n{\n\tu32 sob_delta = mmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_SOB_OBJ_1 -\n\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_SOB_OBJ_0;\n\tint i;\n\n\tfor (i = 0 ; i < DMA_NUMBER_OF_CHANNELS ; i++) {\n\t\tu64 sob_addr = CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_SOB_OBJ_0 +\n\t\t\t\t(i * sob_delta);\n\t\tu32 dma_offset = i * DMA_CORE_OFFSET;\n\n\t\tWREG32(mmDMA0_CORE_WR_COMP_ADDR_LO + dma_offset,\n\t\t\t\tlower_32_bits(sob_addr));\n\t\tWREG32(mmDMA0_CORE_WR_COMP_ADDR_HI + dma_offset,\n\t\t\t\tupper_32_bits(sob_addr));\n\t\tWREG32(mmDMA0_CORE_WR_COMP_WDATA + dma_offset, 0x80000001);\n\n\t\t/* For DMAs 2-7, need to restore WR_AWUSER_31_11 as it can be\n\t\t * modified by the user for SRAM reduction\n\t\t */\n\t\tif (i > 1)\n\t\t\tWREG32(mmDMA0_CORE_WR_AWUSER_31_11 + dma_offset,\n\t\t\t\t\t\t\t\t0x00000001);\n\t}\n}\n\nstatic void gaudi_restore_qm_registers(struct hl_device *hdev)\n{\n\tu32 qman_offset;\n\tint i;\n\n\tfor (i = 0 ; i < DMA_NUMBER_OF_CHANNELS ; i++) {\n\t\tqman_offset = i * DMA_QMAN_OFFSET;\n\t\tWREG32(mmDMA0_QM_ARB_CFG_0 + qman_offset, 0);\n\t}\n\n\tfor (i = 0 ; i < MME_NUMBER_OF_MASTER_ENGINES ; i++) {\n\t\tqman_offset = i * (mmMME2_QM_BASE - mmMME0_QM_BASE);\n\t\tWREG32(mmMME0_QM_ARB_CFG_0 + qman_offset, 0);\n\t}\n\n\tfor (i = 0 ; i < TPC_NUMBER_OF_ENGINES ; i++) {\n\t\tqman_offset = i * TPC_QMAN_OFFSET;\n\t\tWREG32(mmTPC0_QM_ARB_CFG_0 + qman_offset, 0);\n\t}\n\n\tfor (i = 0 ; i < NIC_NUMBER_OF_ENGINES ; i++) {\n\t\tqman_offset = (i >> 1) * NIC_MACRO_QMAN_OFFSET +\n\t\t\t\t(i & 0x1) * NIC_ENGINE_QMAN_OFFSET;\n\t\tWREG32(mmNIC0_QM0_ARB_CFG_0 + qman_offset, 0);\n\t}\n}\n\nstatic int gaudi_restore_user_registers(struct hl_device *hdev)\n{\n\tint rc;\n\n\trc = gaudi_restore_sm_registers(hdev);\n\tif (rc)\n\t\treturn rc;\n\n\tgaudi_restore_dma_registers(hdev);\n\tgaudi_restore_qm_registers(hdev);\n\n\treturn 0;\n}\n\nstatic int gaudi_context_switch(struct hl_device *hdev, u32 asid)\n{\n\treturn gaudi_restore_user_registers(hdev);\n}\n\nstatic int gaudi_mmu_clear_pgt_range(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu64 addr = prop->mmu_pgt_addr;\n\tu32 size = prop->mmu_pgt_size + MMU_CACHE_MNG_SIZE;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_MMU))\n\t\treturn 0;\n\n\treturn gaudi_memset_device_memory(hdev, addr, size, 0);\n}\n\nstatic void gaudi_restore_phase_topology(struct hl_device *hdev)\n{\n\n}\n\nstatic int gaudi_debugfs_read32(struct hl_device *hdev, u64 addr, u32 *val)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu64 hbm_bar_addr;\n\tint rc = 0;\n\n\tif ((addr >= CFG_BASE) && (addr < CFG_BASE + CFG_SIZE)) {\n\n\t\tif ((gaudi->hw_cap_initialized & HW_CAP_CLK_GATE) &&\n\t\t\t\t(hdev->clock_gating_mask &\n\t\t\t\t\t\tGAUDI_CLK_GATE_DEBUGFS_MASK)) {\n\n\t\t\tdev_err_ratelimited(hdev->dev,\n\t\t\t\t\"Can't read register - clock gating is enabled!\\n\");\n\t\t\trc = -EFAULT;\n\t\t} else {\n\t\t\t*val = RREG32(addr - CFG_BASE);\n\t\t}\n\n\t} else if ((addr >= SRAM_BASE_ADDR) &&\n\t\t\t(addr < SRAM_BASE_ADDR + SRAM_BAR_SIZE)) {\n\t\t*val = readl(hdev->pcie_bar[SRAM_BAR_ID] +\n\t\t\t\t(addr - SRAM_BASE_ADDR));\n\t} else if (addr < DRAM_PHYS_BASE + hdev->asic_prop.dram_size) {\n\t\tu64 bar_base_addr = DRAM_PHYS_BASE +\n\t\t\t\t(addr & ~(prop->dram_pci_bar_size - 0x1ull));\n\n\t\thbm_bar_addr = gaudi_set_hbm_bar_base(hdev, bar_base_addr);\n\t\tif (hbm_bar_addr != U64_MAX) {\n\t\t\t*val = readl(hdev->pcie_bar[HBM_BAR_ID] +\n\t\t\t\t\t\t(addr - bar_base_addr));\n\n\t\t\thbm_bar_addr = gaudi_set_hbm_bar_base(hdev,\n\t\t\t\t\t\thbm_bar_addr);\n\t\t}\n\t\tif (hbm_bar_addr == U64_MAX)\n\t\t\trc = -EIO;\n\t} else {\n\t\trc = -EFAULT;\n\t}\n\n\treturn rc;\n}\n\nstatic int gaudi_debugfs_write32(struct hl_device *hdev, u64 addr, u32 val)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu64 hbm_bar_addr;\n\tint rc = 0;\n\n\tif ((addr >= CFG_BASE) && (addr < CFG_BASE + CFG_SIZE)) {\n\n\t\tif ((gaudi->hw_cap_initialized & HW_CAP_CLK_GATE) &&\n\t\t\t\t(hdev->clock_gating_mask &\n\t\t\t\t\t\tGAUDI_CLK_GATE_DEBUGFS_MASK)) {\n\n\t\t\tdev_err_ratelimited(hdev->dev,\n\t\t\t\t\"Can't write register - clock gating is enabled!\\n\");\n\t\t\trc = -EFAULT;\n\t\t} else {\n\t\t\tWREG32(addr - CFG_BASE, val);\n\t\t}\n\n\t} else if ((addr >= SRAM_BASE_ADDR) &&\n\t\t\t(addr < SRAM_BASE_ADDR + SRAM_BAR_SIZE)) {\n\t\twritel(val, hdev->pcie_bar[SRAM_BAR_ID] +\n\t\t\t\t\t(addr - SRAM_BASE_ADDR));\n\t} else if (addr < DRAM_PHYS_BASE + hdev->asic_prop.dram_size) {\n\t\tu64 bar_base_addr = DRAM_PHYS_BASE +\n\t\t\t\t(addr & ~(prop->dram_pci_bar_size - 0x1ull));\n\n\t\thbm_bar_addr = gaudi_set_hbm_bar_base(hdev, bar_base_addr);\n\t\tif (hbm_bar_addr != U64_MAX) {\n\t\t\twritel(val, hdev->pcie_bar[HBM_BAR_ID] +\n\t\t\t\t\t\t(addr - bar_base_addr));\n\n\t\t\thbm_bar_addr = gaudi_set_hbm_bar_base(hdev,\n\t\t\t\t\t\thbm_bar_addr);\n\t\t}\n\t\tif (hbm_bar_addr == U64_MAX)\n\t\t\trc = -EIO;\n\t} else {\n\t\trc = -EFAULT;\n\t}\n\n\treturn rc;\n}\n\nstatic int gaudi_debugfs_read64(struct hl_device *hdev, u64 addr, u64 *val)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu64 hbm_bar_addr;\n\tint rc = 0;\n\n\tif ((addr >= CFG_BASE) && (addr <= CFG_BASE + CFG_SIZE - sizeof(u64))) {\n\n\t\tif ((gaudi->hw_cap_initialized & HW_CAP_CLK_GATE) &&\n\t\t\t\t(hdev->clock_gating_mask &\n\t\t\t\t\t\tGAUDI_CLK_GATE_DEBUGFS_MASK)) {\n\n\t\t\tdev_err_ratelimited(hdev->dev,\n\t\t\t\t\"Can't read register - clock gating is enabled!\\n\");\n\t\t\trc = -EFAULT;\n\t\t} else {\n\t\t\tu32 val_l = RREG32(addr - CFG_BASE);\n\t\t\tu32 val_h = RREG32(addr + sizeof(u32) - CFG_BASE);\n\n\t\t\t*val = (((u64) val_h) << 32) | val_l;\n\t\t}\n\n\t} else if ((addr >= SRAM_BASE_ADDR) &&\n\t\t   (addr <= SRAM_BASE_ADDR + SRAM_BAR_SIZE - sizeof(u64))) {\n\t\t*val = readq(hdev->pcie_bar[SRAM_BAR_ID] +\n\t\t\t\t(addr - SRAM_BASE_ADDR));\n\t} else if (addr <=\n\t\t    DRAM_PHYS_BASE + hdev->asic_prop.dram_size - sizeof(u64)) {\n\t\tu64 bar_base_addr = DRAM_PHYS_BASE +\n\t\t\t\t(addr & ~(prop->dram_pci_bar_size - 0x1ull));\n\n\t\thbm_bar_addr = gaudi_set_hbm_bar_base(hdev, bar_base_addr);\n\t\tif (hbm_bar_addr != U64_MAX) {\n\t\t\t*val = readq(hdev->pcie_bar[HBM_BAR_ID] +\n\t\t\t\t\t\t(addr - bar_base_addr));\n\n\t\t\thbm_bar_addr = gaudi_set_hbm_bar_base(hdev,\n\t\t\t\t\t\thbm_bar_addr);\n\t\t}\n\t\tif (hbm_bar_addr == U64_MAX)\n\t\t\trc = -EIO;\n\t} else {\n\t\trc = -EFAULT;\n\t}\n\n\treturn rc;\n}\n\nstatic int gaudi_debugfs_write64(struct hl_device *hdev, u64 addr, u64 val)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu64 hbm_bar_addr;\n\tint rc = 0;\n\n\tif ((addr >= CFG_BASE) && (addr <= CFG_BASE + CFG_SIZE - sizeof(u64))) {\n\n\t\tif ((gaudi->hw_cap_initialized & HW_CAP_CLK_GATE) &&\n\t\t\t\t(hdev->clock_gating_mask &\n\t\t\t\t\t\tGAUDI_CLK_GATE_DEBUGFS_MASK)) {\n\n\t\t\tdev_err_ratelimited(hdev->dev,\n\t\t\t\t\"Can't write register - clock gating is enabled!\\n\");\n\t\t\trc = -EFAULT;\n\t\t} else {\n\t\t\tWREG32(addr - CFG_BASE, lower_32_bits(val));\n\t\t\tWREG32(addr + sizeof(u32) - CFG_BASE,\n\t\t\t\tupper_32_bits(val));\n\t\t}\n\n\t} else if ((addr >= SRAM_BASE_ADDR) &&\n\t\t   (addr <= SRAM_BASE_ADDR + SRAM_BAR_SIZE - sizeof(u64))) {\n\t\twriteq(val, hdev->pcie_bar[SRAM_BAR_ID] +\n\t\t\t\t\t(addr - SRAM_BASE_ADDR));\n\t} else if (addr <=\n\t\t    DRAM_PHYS_BASE + hdev->asic_prop.dram_size - sizeof(u64)) {\n\t\tu64 bar_base_addr = DRAM_PHYS_BASE +\n\t\t\t\t(addr & ~(prop->dram_pci_bar_size - 0x1ull));\n\n\t\thbm_bar_addr = gaudi_set_hbm_bar_base(hdev, bar_base_addr);\n\t\tif (hbm_bar_addr != U64_MAX) {\n\t\t\twriteq(val, hdev->pcie_bar[HBM_BAR_ID] +\n\t\t\t\t\t\t(addr - bar_base_addr));\n\n\t\t\thbm_bar_addr = gaudi_set_hbm_bar_base(hdev,\n\t\t\t\t\t\thbm_bar_addr);\n\t\t}\n\t\tif (hbm_bar_addr == U64_MAX)\n\t\t\trc = -EIO;\n\t} else {\n\t\trc = -EFAULT;\n\t}\n\n\treturn rc;\n}\n\nstatic u64 gaudi_read_pte(struct hl_device *hdev, u64 addr)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (hdev->hard_reset_pending)\n\t\treturn U64_MAX;\n\n\treturn readq(hdev->pcie_bar[HBM_BAR_ID] +\n\t\t\t(addr - gaudi->hbm_bar_cur_addr));\n}\n\nstatic void gaudi_write_pte(struct hl_device *hdev, u64 addr, u64 val)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (hdev->hard_reset_pending)\n\t\treturn;\n\n\twriteq(val, hdev->pcie_bar[HBM_BAR_ID] +\n\t\t\t(addr - gaudi->hbm_bar_cur_addr));\n}\n\nvoid gaudi_mmu_prepare_reg(struct hl_device *hdev, u64 reg, u32 asid)\n{\n\t/* mask to zero the MMBP and ASID bits */\n\tWREG32_AND(reg, ~0x7FF);\n\tWREG32_OR(reg, asid);\n}\n\nstatic void gaudi_mmu_prepare(struct hl_device *hdev, u32 asid)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_MMU))\n\t\treturn;\n\n\tif (asid & ~DMA0_QM_GLBL_NON_SECURE_PROPS_0_ASID_MASK) {\n\t\tdev_crit(hdev->dev, \"asid %u is too big\\n\", asid);\n\t\treturn;\n\t}\n\n\tmutex_lock(&gaudi->clk_gate_mutex);\n\n\thdev->asic_funcs->disable_clock_gating(hdev);\n\n\tgaudi_mmu_prepare_reg(hdev, mmDMA0_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA0_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA0_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA0_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA0_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmDMA1_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA1_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA1_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA1_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA1_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmDMA2_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA2_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA2_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA2_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA2_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmDMA3_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA3_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA3_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA3_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA3_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmDMA4_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA4_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA4_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA4_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA4_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmDMA5_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA5_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA5_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA5_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA5_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmDMA6_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA6_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA6_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA6_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA6_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmDMA7_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA7_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA7_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA7_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA7_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmDMA0_CORE_NON_SECURE_PROPS, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA1_CORE_NON_SECURE_PROPS, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA2_CORE_NON_SECURE_PROPS, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA3_CORE_NON_SECURE_PROPS, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA4_CORE_NON_SECURE_PROPS, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA5_CORE_NON_SECURE_PROPS, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA6_CORE_NON_SECURE_PROPS, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmDMA7_CORE_NON_SECURE_PROPS, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmTPC0_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC0_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC0_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC0_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC0_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC0_CFG_ARUSER_LO, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC0_CFG_AWUSER_LO, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmTPC1_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC1_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC1_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC1_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC1_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC1_CFG_ARUSER_LO, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC1_CFG_AWUSER_LO, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmTPC2_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC2_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC2_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC2_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC2_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC2_CFG_ARUSER_LO, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC2_CFG_AWUSER_LO, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmTPC3_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC3_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC3_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC3_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC3_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC3_CFG_ARUSER_LO, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC3_CFG_AWUSER_LO, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmTPC4_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC4_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC4_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC4_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC4_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC4_CFG_ARUSER_LO, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC4_CFG_AWUSER_LO, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmTPC5_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC5_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC5_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC5_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC5_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC5_CFG_ARUSER_LO, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC5_CFG_AWUSER_LO, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmTPC6_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC6_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC6_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC6_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC6_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC6_CFG_ARUSER_LO, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC6_CFG_AWUSER_LO, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmTPC7_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC7_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC7_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC7_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC7_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC7_CFG_ARUSER_LO, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmTPC7_CFG_AWUSER_LO, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmMME0_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME0_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME0_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME0_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME0_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME2_QM_GLBL_NON_SECURE_PROPS_0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME2_QM_GLBL_NON_SECURE_PROPS_1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME2_QM_GLBL_NON_SECURE_PROPS_2, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME2_QM_GLBL_NON_SECURE_PROPS_3, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME2_QM_GLBL_NON_SECURE_PROPS_4, asid);\n\n\tgaudi_mmu_prepare_reg(hdev, mmMME0_SBAB_ARUSER0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME0_SBAB_ARUSER1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME1_SBAB_ARUSER0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME1_SBAB_ARUSER1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME2_SBAB_ARUSER0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME2_SBAB_ARUSER1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME3_SBAB_ARUSER0, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME3_SBAB_ARUSER1, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME0_ACC_WBC, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME1_ACC_WBC, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME2_ACC_WBC, asid);\n\tgaudi_mmu_prepare_reg(hdev, mmMME3_ACC_WBC, asid);\n\n\tif (hdev->nic_ports_mask & GAUDI_NIC_MASK_NIC0) {\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC0_QM0_GLBL_NON_SECURE_PROPS_0,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC0_QM0_GLBL_NON_SECURE_PROPS_1,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC0_QM0_GLBL_NON_SECURE_PROPS_2,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC0_QM0_GLBL_NON_SECURE_PROPS_3,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC0_QM0_GLBL_NON_SECURE_PROPS_4,\n\t\t\t\tasid);\n\t}\n\n\tif (hdev->nic_ports_mask & GAUDI_NIC_MASK_NIC1) {\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC0_QM1_GLBL_NON_SECURE_PROPS_0,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC0_QM1_GLBL_NON_SECURE_PROPS_1,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC0_QM1_GLBL_NON_SECURE_PROPS_2,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC0_QM1_GLBL_NON_SECURE_PROPS_3,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC0_QM1_GLBL_NON_SECURE_PROPS_4,\n\t\t\t\tasid);\n\t}\n\n\tif (hdev->nic_ports_mask & GAUDI_NIC_MASK_NIC2) {\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC1_QM0_GLBL_NON_SECURE_PROPS_0,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC1_QM0_GLBL_NON_SECURE_PROPS_1,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC1_QM0_GLBL_NON_SECURE_PROPS_2,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC1_QM0_GLBL_NON_SECURE_PROPS_3,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC1_QM0_GLBL_NON_SECURE_PROPS_4,\n\t\t\t\tasid);\n\t}\n\n\tif (hdev->nic_ports_mask & GAUDI_NIC_MASK_NIC3) {\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC1_QM1_GLBL_NON_SECURE_PROPS_0,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC1_QM1_GLBL_NON_SECURE_PROPS_1,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC1_QM1_GLBL_NON_SECURE_PROPS_2,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC1_QM1_GLBL_NON_SECURE_PROPS_3,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC1_QM1_GLBL_NON_SECURE_PROPS_4,\n\t\t\t\tasid);\n\t}\n\n\tif (hdev->nic_ports_mask & GAUDI_NIC_MASK_NIC4) {\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC2_QM0_GLBL_NON_SECURE_PROPS_0,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC2_QM0_GLBL_NON_SECURE_PROPS_1,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC2_QM0_GLBL_NON_SECURE_PROPS_2,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC2_QM0_GLBL_NON_SECURE_PROPS_3,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC2_QM0_GLBL_NON_SECURE_PROPS_4,\n\t\t\t\tasid);\n\t}\n\n\tif (hdev->nic_ports_mask & GAUDI_NIC_MASK_NIC5) {\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC2_QM1_GLBL_NON_SECURE_PROPS_0,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC2_QM1_GLBL_NON_SECURE_PROPS_1,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC2_QM1_GLBL_NON_SECURE_PROPS_2,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC2_QM1_GLBL_NON_SECURE_PROPS_3,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC2_QM1_GLBL_NON_SECURE_PROPS_4,\n\t\t\t\tasid);\n\t}\n\n\tif (hdev->nic_ports_mask & GAUDI_NIC_MASK_NIC6) {\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC3_QM0_GLBL_NON_SECURE_PROPS_0,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC3_QM0_GLBL_NON_SECURE_PROPS_1,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC3_QM0_GLBL_NON_SECURE_PROPS_2,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC3_QM0_GLBL_NON_SECURE_PROPS_3,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC3_QM0_GLBL_NON_SECURE_PROPS_4,\n\t\t\t\tasid);\n\t}\n\n\tif (hdev->nic_ports_mask & GAUDI_NIC_MASK_NIC7) {\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC3_QM1_GLBL_NON_SECURE_PROPS_0,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC3_QM1_GLBL_NON_SECURE_PROPS_1,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC3_QM1_GLBL_NON_SECURE_PROPS_2,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC3_QM1_GLBL_NON_SECURE_PROPS_3,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC3_QM1_GLBL_NON_SECURE_PROPS_4,\n\t\t\t\tasid);\n\t}\n\n\tif (hdev->nic_ports_mask & GAUDI_NIC_MASK_NIC8) {\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC4_QM0_GLBL_NON_SECURE_PROPS_0,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC4_QM0_GLBL_NON_SECURE_PROPS_1,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC4_QM0_GLBL_NON_SECURE_PROPS_2,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC4_QM0_GLBL_NON_SECURE_PROPS_3,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC4_QM0_GLBL_NON_SECURE_PROPS_4,\n\t\t\t\tasid);\n\t}\n\n\tif (hdev->nic_ports_mask & GAUDI_NIC_MASK_NIC9) {\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC4_QM1_GLBL_NON_SECURE_PROPS_0,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC4_QM1_GLBL_NON_SECURE_PROPS_1,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC4_QM1_GLBL_NON_SECURE_PROPS_2,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC4_QM1_GLBL_NON_SECURE_PROPS_3,\n\t\t\t\tasid);\n\t\tgaudi_mmu_prepare_reg(hdev, mmNIC4_QM1_GLBL_NON_SECURE_PROPS_4,\n\t\t\t\tasid);\n\t}\n\n\thdev->asic_funcs->set_clock_gating(hdev);\n\n\tmutex_unlock(&gaudi->clk_gate_mutex);\n}\n\nstatic int gaudi_send_job_on_qman0(struct hl_device *hdev,\n\t\tstruct hl_cs_job *job)\n{\n\tstruct packet_msg_prot *fence_pkt;\n\tu32 *fence_ptr;\n\tdma_addr_t fence_dma_addr;\n\tstruct hl_cb *cb;\n\tu32 tmp, timeout, dma_offset;\n\tint rc;\n\n\tif (hdev->pldm)\n\t\ttimeout = GAUDI_PLDM_QMAN0_TIMEOUT_USEC;\n\telse\n\t\ttimeout = HL_DEVICE_TIMEOUT_USEC;\n\n\tif (!hdev->asic_funcs->is_device_idle(hdev, NULL, 0, NULL)) {\n\t\tdev_err_ratelimited(hdev->dev,\n\t\t\t\"Can't send driver job on QMAN0 because the device is not idle\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tfence_ptr = hdev->asic_funcs->asic_dma_pool_zalloc(hdev, 4, GFP_KERNEL,\n\t\t\t\t\t\t\t&fence_dma_addr);\n\tif (!fence_ptr) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate fence memory for QMAN0\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcb = job->patched_cb;\n\n\tfence_pkt = cb->kernel_address +\n\t\t\tjob->job_cb_size - sizeof(struct packet_msg_prot);\n\n\ttmp = FIELD_PREP(GAUDI_PKT_CTL_OPCODE_MASK, PACKET_MSG_PROT);\n\ttmp |= FIELD_PREP(GAUDI_PKT_CTL_EB_MASK, 1);\n\ttmp |= FIELD_PREP(GAUDI_PKT_CTL_MB_MASK, 1);\n\n\tfence_pkt->ctl = cpu_to_le32(tmp);\n\tfence_pkt->value = cpu_to_le32(GAUDI_QMAN0_FENCE_VAL);\n\tfence_pkt->addr = cpu_to_le64(fence_dma_addr);\n\n\tdma_offset = gaudi_dma_assignment[GAUDI_PCI_DMA_1] * DMA_CORE_OFFSET;\n\n\tWREG32_OR(mmDMA0_CORE_PROT + dma_offset, BIT(DMA0_CORE_PROT_VAL_SHIFT));\n\n\trc = hl_hw_queue_send_cb_no_cmpl(hdev, GAUDI_QUEUE_ID_DMA_0_0,\n\t\t\t\t\tjob->job_cb_size, cb->bus_address);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to send CB on QMAN0, %d\\n\", rc);\n\t\tgoto free_fence_ptr;\n\t}\n\n\trc = hl_poll_timeout_memory(hdev, fence_ptr, tmp,\n\t\t\t\t(tmp == GAUDI_QMAN0_FENCE_VAL), 1000,\n\t\t\t\ttimeout, true);\n\n\thl_hw_queue_inc_ci_kernel(hdev, GAUDI_QUEUE_ID_DMA_0_0);\n\n\tif (rc == -ETIMEDOUT) {\n\t\tdev_err(hdev->dev, \"QMAN0 Job timeout (0x%x)\\n\", tmp);\n\t\tgoto free_fence_ptr;\n\t}\n\nfree_fence_ptr:\n\tWREG32_AND(mmDMA0_CORE_PROT + dma_offset,\n\t\t\t~BIT(DMA0_CORE_PROT_VAL_SHIFT));\n\n\thdev->asic_funcs->asic_dma_pool_free(hdev, (void *) fence_ptr,\n\t\t\t\t\tfence_dma_addr);\n\treturn rc;\n}\n\nstatic void gaudi_get_event_desc(u16 event_type, char *desc, size_t size)\n{\n\tif (event_type >= GAUDI_EVENT_SIZE)\n\t\tgoto event_not_supported;\n\n\tif (!gaudi_irq_map_table[event_type].valid)\n\t\tgoto event_not_supported;\n\n\tsnprintf(desc, size, gaudi_irq_map_table[event_type].name);\n\n\treturn;\n\nevent_not_supported:\n\tsnprintf(desc, size, \"N/A\");\n}\n\nstatic const char *gaudi_get_razwi_initiator_dma_name(struct hl_device *hdev,\n\t\t\t\t\t\t\tu32 x_y, bool is_write)\n{\n\tu32 dma_id[2], dma_offset, err_cause[2], mask, i;\n\n\tmask = is_write ? DMA0_CORE_ERR_CAUSE_HBW_WR_ERR_MASK :\n\t\t\t\tDMA0_CORE_ERR_CAUSE_HBW_RD_ERR_MASK;\n\n\tswitch (x_y) {\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_W_S_0:\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_W_S_1:\n\t\tdma_id[0] = 0;\n\t\tdma_id[1] = 2;\n\t\tbreak;\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_E_S_0:\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_E_S_1:\n\t\tdma_id[0] = 1;\n\t\tdma_id[1] = 3;\n\t\tbreak;\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_W_N_0:\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_W_N_1:\n\t\tdma_id[0] = 4;\n\t\tdma_id[1] = 6;\n\t\tbreak;\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_E_N_0:\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_E_N_1:\n\t\tdma_id[0] = 5;\n\t\tdma_id[1] = 7;\n\t\tbreak;\n\tdefault:\n\t\tgoto unknown_initiator;\n\t}\n\n\tfor (i = 0 ; i < 2 ; i++) {\n\t\tdma_offset = dma_id[i] * DMA_CORE_OFFSET;\n\t\terr_cause[i] = RREG32(mmDMA0_CORE_ERR_CAUSE + dma_offset);\n\t}\n\n\tswitch (x_y) {\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_W_S_0:\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_W_S_1:\n\t\tif ((err_cause[0] & mask) && !(err_cause[1] & mask))\n\t\t\treturn \"DMA0\";\n\t\telse if (!(err_cause[0] & mask) && (err_cause[1] & mask))\n\t\t\treturn \"DMA2\";\n\t\telse\n\t\t\treturn \"DMA0 or DMA2\";\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_E_S_0:\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_E_S_1:\n\t\tif ((err_cause[0] & mask) && !(err_cause[1] & mask))\n\t\t\treturn \"DMA1\";\n\t\telse if (!(err_cause[0] & mask) && (err_cause[1] & mask))\n\t\t\treturn \"DMA3\";\n\t\telse\n\t\t\treturn \"DMA1 or DMA3\";\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_W_N_0:\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_W_N_1:\n\t\tif ((err_cause[0] & mask) && !(err_cause[1] & mask))\n\t\t\treturn \"DMA4\";\n\t\telse if (!(err_cause[0] & mask) && (err_cause[1] & mask))\n\t\t\treturn \"DMA6\";\n\t\telse\n\t\t\treturn \"DMA4 or DMA6\";\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_E_N_0:\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_E_N_1:\n\t\tif ((err_cause[0] & mask) && !(err_cause[1] & mask))\n\t\t\treturn \"DMA5\";\n\t\telse if (!(err_cause[0] & mask) && (err_cause[1] & mask))\n\t\t\treturn \"DMA7\";\n\t\telse\n\t\t\treturn \"DMA5 or DMA7\";\n\t}\n\nunknown_initiator:\n\treturn \"unknown initiator\";\n}\n\nstatic const char *gaudi_get_razwi_initiator_name(struct hl_device *hdev,\n\t\t\t\t\t\t\tbool is_write)\n{\n\tu32 val, x_y, axi_id;\n\n\tval = is_write ? RREG32(mmMMU_UP_RAZWI_WRITE_ID) :\n\t\t\t\tRREG32(mmMMU_UP_RAZWI_READ_ID);\n\tx_y = val & ((RAZWI_INITIATOR_Y_MASK << RAZWI_INITIATOR_Y_SHIFT) |\n\t\t\t(RAZWI_INITIATOR_X_MASK << RAZWI_INITIATOR_X_SHIFT));\n\taxi_id = val & (RAZWI_INITIATOR_AXI_ID_MASK <<\n\t\t\tRAZWI_INITIATOR_AXI_ID_SHIFT);\n\n\tswitch (x_y) {\n\tcase RAZWI_INITIATOR_ID_X_Y_TPC0_NIC0:\n\t\tif (axi_id == RAZWI_INITIATOR_ID_AXI_ID(AXI_ID_TPC))\n\t\t\treturn \"TPC0\";\n\t\tif (axi_id == RAZWI_INITIATOR_ID_AXI_ID(AXI_ID_NIC))\n\t\t\treturn \"NIC0\";\n\t\tbreak;\n\tcase RAZWI_INITIATOR_ID_X_Y_TPC1:\n\t\treturn \"TPC1\";\n\tcase RAZWI_INITIATOR_ID_X_Y_MME0_0:\n\tcase RAZWI_INITIATOR_ID_X_Y_MME0_1:\n\t\treturn \"MME0\";\n\tcase RAZWI_INITIATOR_ID_X_Y_MME1_0:\n\tcase RAZWI_INITIATOR_ID_X_Y_MME1_1:\n\t\treturn \"MME1\";\n\tcase RAZWI_INITIATOR_ID_X_Y_TPC2:\n\t\treturn \"TPC2\";\n\tcase RAZWI_INITIATOR_ID_X_Y_TPC3_PCI_CPU_PSOC:\n\t\tif (axi_id == RAZWI_INITIATOR_ID_AXI_ID(AXI_ID_TPC))\n\t\t\treturn \"TPC3\";\n\t\tif (axi_id == RAZWI_INITIATOR_ID_AXI_ID(AXI_ID_PCI))\n\t\t\treturn \"PCI\";\n\t\tif (axi_id == RAZWI_INITIATOR_ID_AXI_ID(AXI_ID_CPU))\n\t\t\treturn \"CPU\";\n\t\tif (axi_id == RAZWI_INITIATOR_ID_AXI_ID(AXI_ID_PSOC))\n\t\t\treturn \"PSOC\";\n\t\tbreak;\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_W_S_0:\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_W_S_1:\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_E_S_0:\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_E_S_1:\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_W_N_0:\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_W_N_1:\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_E_N_0:\n\tcase RAZWI_INITIATOR_ID_X_Y_DMA_IF_E_N_1:\n\t\treturn gaudi_get_razwi_initiator_dma_name(hdev, x_y, is_write);\n\tcase RAZWI_INITIATOR_ID_X_Y_TPC4_NIC1_NIC2:\n\t\tif (axi_id == RAZWI_INITIATOR_ID_AXI_ID(AXI_ID_TPC))\n\t\t\treturn \"TPC4\";\n\t\tif (axi_id == RAZWI_INITIATOR_ID_AXI_ID(AXI_ID_NIC))\n\t\t\treturn \"NIC1\";\n\t\tif (axi_id == RAZWI_INITIATOR_ID_AXI_ID(AXI_ID_NIC_FT))\n\t\t\treturn \"NIC2\";\n\t\tbreak;\n\tcase RAZWI_INITIATOR_ID_X_Y_TPC5:\n\t\treturn \"TPC5\";\n\tcase RAZWI_INITIATOR_ID_X_Y_MME2_0:\n\tcase RAZWI_INITIATOR_ID_X_Y_MME2_1:\n\t\treturn \"MME2\";\n\tcase RAZWI_INITIATOR_ID_X_Y_MME3_0:\n\tcase RAZWI_INITIATOR_ID_X_Y_MME3_1:\n\t\treturn \"MME3\";\n\tcase RAZWI_INITIATOR_ID_X_Y_TPC6:\n\t\treturn \"TPC6\";\n\tcase RAZWI_INITIATOR_ID_X_Y_TPC7_NIC4_NIC5:\n\t\tif (axi_id == RAZWI_INITIATOR_ID_AXI_ID(AXI_ID_TPC))\n\t\t\treturn \"TPC7\";\n\t\tif (axi_id == RAZWI_INITIATOR_ID_AXI_ID(AXI_ID_NIC))\n\t\t\treturn \"NIC4\";\n\t\tif (axi_id == RAZWI_INITIATOR_ID_AXI_ID(AXI_ID_NIC_FT))\n\t\t\treturn \"NIC5\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_err(hdev->dev,\n\t\t\"Unknown RAZWI initiator ID 0x%x [Y=%d, X=%d, AXI_ID=%d]\\n\",\n\t\tval,\n\t\t(val >> RAZWI_INITIATOR_Y_SHIFT) & RAZWI_INITIATOR_Y_MASK,\n\t\t(val >> RAZWI_INITIATOR_X_SHIFT) & RAZWI_INITIATOR_X_MASK,\n\t\t(val >> RAZWI_INITIATOR_AXI_ID_SHIFT) &\n\t\t\tRAZWI_INITIATOR_AXI_ID_MASK);\n\n\treturn \"unknown initiator\";\n}\n\nstatic void gaudi_print_razwi_info(struct hl_device *hdev)\n{\n\tif (RREG32(mmMMU_UP_RAZWI_WRITE_VLD)) {\n\t\tdev_err_ratelimited(hdev->dev,\n\t\t\t\"RAZWI event caused by illegal write of %s\\n\",\n\t\t\tgaudi_get_razwi_initiator_name(hdev, true));\n\t\tWREG32(mmMMU_UP_RAZWI_WRITE_VLD, 0);\n\t}\n\n\tif (RREG32(mmMMU_UP_RAZWI_READ_VLD)) {\n\t\tdev_err_ratelimited(hdev->dev,\n\t\t\t\"RAZWI event caused by illegal read of %s\\n\",\n\t\t\tgaudi_get_razwi_initiator_name(hdev, false));\n\t\tWREG32(mmMMU_UP_RAZWI_READ_VLD, 0);\n\t}\n}\n\nstatic void gaudi_print_mmu_error_info(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu64 addr;\n\tu32 val;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_MMU))\n\t\treturn;\n\n\tval = RREG32(mmMMU_UP_PAGE_ERROR_CAPTURE);\n\tif (val & MMU_UP_PAGE_ERROR_CAPTURE_ENTRY_VALID_MASK) {\n\t\taddr = val & MMU_UP_PAGE_ERROR_CAPTURE_VA_49_32_MASK;\n\t\taddr <<= 32;\n\t\taddr |= RREG32(mmMMU_UP_PAGE_ERROR_CAPTURE_VA);\n\n\t\tdev_err_ratelimited(hdev->dev, \"MMU page fault on va 0x%llx\\n\",\n\t\t\t\t\taddr);\n\n\t\tWREG32(mmMMU_UP_PAGE_ERROR_CAPTURE, 0);\n\t}\n\n\tval = RREG32(mmMMU_UP_ACCESS_ERROR_CAPTURE);\n\tif (val & MMU_UP_ACCESS_ERROR_CAPTURE_ENTRY_VALID_MASK) {\n\t\taddr = val & MMU_UP_ACCESS_ERROR_CAPTURE_VA_49_32_MASK;\n\t\taddr <<= 32;\n\t\taddr |= RREG32(mmMMU_UP_ACCESS_ERROR_CAPTURE_VA);\n\n\t\tdev_err_ratelimited(hdev->dev,\n\t\t\t\t\"MMU access error on va 0x%llx\\n\", addr);\n\n\t\tWREG32(mmMMU_UP_ACCESS_ERROR_CAPTURE, 0);\n\t}\n}\n\n/*\n *  +-------------------+------------------------------------------------------+\n *  | Configuration Reg |                     Description                      |\n *  |      Address      |                                                      |\n *  +-------------------+------------------------------------------------------+\n *  |  0xF30 - 0xF3F    |ECC single error indication (1 bit per memory wrapper)|\n *  |                   |0xF30 memory wrappers 31:0 (MSB to LSB)               |\n *  |                   |0xF34 memory wrappers 63:32                           |\n *  |                   |0xF38 memory wrappers 95:64                           |\n *  |                   |0xF3C memory wrappers 127:96                          |\n *  +-------------------+------------------------------------------------------+\n *  |  0xF40 - 0xF4F    |ECC double error indication (1 bit per memory wrapper)|\n *  |                   |0xF40 memory wrappers 31:0 (MSB to LSB)               |\n *  |                   |0xF44 memory wrappers 63:32                           |\n *  |                   |0xF48 memory wrappers 95:64                           |\n *  |                   |0xF4C memory wrappers 127:96                          |\n *  +-------------------+------------------------------------------------------+\n */\nstatic int gaudi_extract_ecc_info(struct hl_device *hdev,\n\t\tstruct ecc_info_extract_params *params, u64 *ecc_address,\n\t\tu64 *ecc_syndrom, u8 *memory_wrapper_idx)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu32 i, num_mem_regs, reg, err_bit;\n\tu64 err_addr, err_word = 0;\n\tint rc = 0;\n\n\tnum_mem_regs = params->num_memories / 32 +\n\t\t\t((params->num_memories % 32) ? 1 : 0);\n\n\tif (params->block_address >= CFG_BASE)\n\t\tparams->block_address -= CFG_BASE;\n\n\tif (params->derr)\n\t\terr_addr = params->block_address + GAUDI_ECC_DERR0_OFFSET;\n\telse\n\t\terr_addr = params->block_address + GAUDI_ECC_SERR0_OFFSET;\n\n\tif (params->disable_clock_gating) {\n\t\tmutex_lock(&gaudi->clk_gate_mutex);\n\t\thdev->asic_funcs->disable_clock_gating(hdev);\n\t}\n\n\t/* Set invalid wrapper index */\n\t*memory_wrapper_idx = 0xFF;\n\n\t/* Iterate through memory wrappers, a single bit must be set */\n\tfor (i = 0 ; i < num_mem_regs ; i++) {\n\t\terr_addr += i * 4;\n\t\terr_word = RREG32(err_addr);\n\t\tif (err_word) {\n\t\t\terr_bit = __ffs(err_word);\n\t\t\t*memory_wrapper_idx = err_bit + (32 * i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (*memory_wrapper_idx == 0xFF) {\n\t\tdev_err(hdev->dev, \"ECC error information cannot be found\\n\");\n\t\trc = -EINVAL;\n\t\tgoto enable_clk_gate;\n\t}\n\n\tWREG32(params->block_address + GAUDI_ECC_MEM_SEL_OFFSET,\n\t\t\t*memory_wrapper_idx);\n\n\t*ecc_address =\n\t\tRREG32(params->block_address + GAUDI_ECC_ADDRESS_OFFSET);\n\t*ecc_syndrom =\n\t\tRREG32(params->block_address + GAUDI_ECC_SYNDROME_OFFSET);\n\n\t/* Clear error indication */\n\treg = RREG32(params->block_address + GAUDI_ECC_MEM_INFO_CLR_OFFSET);\n\tif (params->derr)\n\t\treg |= FIELD_PREP(GAUDI_ECC_MEM_INFO_CLR_DERR_MASK, 1);\n\telse\n\t\treg |= FIELD_PREP(GAUDI_ECC_MEM_INFO_CLR_SERR_MASK, 1);\n\n\tWREG32(params->block_address + GAUDI_ECC_MEM_INFO_CLR_OFFSET, reg);\n\nenable_clk_gate:\n\tif (params->disable_clock_gating) {\n\t\thdev->asic_funcs->set_clock_gating(hdev);\n\n\t\tmutex_unlock(&gaudi->clk_gate_mutex);\n\t}\n\n\treturn rc;\n}\n\nstatic void gaudi_handle_qman_err_generic(struct hl_device *hdev,\n\t\t\t\t\t  const char *qm_name,\n\t\t\t\t\t  u64 glbl_sts_addr,\n\t\t\t\t\t  u64 arb_err_addr)\n{\n\tu32 i, j, glbl_sts_val, arb_err_val, glbl_sts_clr_val;\n\tchar reg_desc[32];\n\n\t/* Iterate through all stream GLBL_STS1 registers + Lower CP */\n\tfor (i = 0 ; i < QMAN_STREAMS + 1 ; i++) {\n\t\tglbl_sts_clr_val = 0;\n\t\tglbl_sts_val = RREG32(glbl_sts_addr + 4 * i);\n\n\t\tif (!glbl_sts_val)\n\t\t\tcontinue;\n\n\t\tif (i == QMAN_STREAMS)\n\t\t\tsnprintf(reg_desc, ARRAY_SIZE(reg_desc), \"LowerCP\");\n\t\telse\n\t\t\tsnprintf(reg_desc, ARRAY_SIZE(reg_desc), \"stream%u\", i);\n\n\t\tfor (j = 0 ; j < GAUDI_NUM_OF_QM_ERR_CAUSE ; j++) {\n\t\t\tif (glbl_sts_val & BIT(j)) {\n\t\t\t\tdev_err_ratelimited(hdev->dev,\n\t\t\t\t\t\t\"%s %s. err cause: %s\\n\",\n\t\t\t\t\t\tqm_name, reg_desc,\n\t\t\t\t\t\tgaudi_qman_error_cause[j]);\n\t\t\t\tglbl_sts_clr_val |= BIT(j);\n\t\t\t}\n\t\t}\n\n\t\t/* Write 1 clear errors */\n\t\tWREG32(glbl_sts_addr + 4 * i, glbl_sts_clr_val);\n\t}\n\n\tarb_err_val = RREG32(arb_err_addr);\n\n\tif (!arb_err_val)\n\t\treturn;\n\n\tfor (j = 0 ; j < GAUDI_NUM_OF_QM_ARB_ERR_CAUSE ; j++) {\n\t\tif (arb_err_val & BIT(j)) {\n\t\t\tdev_err_ratelimited(hdev->dev,\n\t\t\t\t\t\"%s ARB_ERR. err cause: %s\\n\",\n\t\t\t\t\tqm_name,\n\t\t\t\t\tgaudi_qman_arb_error_cause[j]);\n\t\t}\n\t}\n}\n\nstatic void gaudi_print_sm_sei_info(struct hl_device *hdev, u16 event_type,\n\t\tstruct hl_eq_sm_sei_data *sei_data)\n{\n\tu32 index = event_type - GAUDI_EVENT_DMA_IF_SEI_0;\n\n\tswitch (sei_data->sei_cause) {\n\tcase SM_SEI_SO_OVERFLOW:\n\t\tdev_err(hdev->dev,\n\t\t\t\"SM %u SEI Error: SO %u overflow/underflow\",\n\t\t\tindex, le32_to_cpu(sei_data->sei_log));\n\t\tbreak;\n\tcase SM_SEI_LBW_4B_UNALIGNED:\n\t\tdev_err(hdev->dev,\n\t\t\t\"SM %u SEI Error: Unaligned 4B LBW access, monitor agent address low - %#x\",\n\t\t\tindex, le32_to_cpu(sei_data->sei_log));\n\t\tbreak;\n\tcase SM_SEI_AXI_RESPONSE_ERR:\n\t\tdev_err(hdev->dev,\n\t\t\t\"SM %u SEI Error: AXI ID %u response error\",\n\t\t\tindex, le32_to_cpu(sei_data->sei_log));\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hdev->dev, \"Unknown SM SEI cause %u\",\n\t\t\t\tle32_to_cpu(sei_data->sei_log));\n\t\tbreak;\n\t}\n}\n\nstatic void gaudi_handle_ecc_event(struct hl_device *hdev, u16 event_type,\n\t\tstruct hl_eq_ecc_data *ecc_data)\n{\n\tstruct ecc_info_extract_params params;\n\tu64 ecc_address = 0, ecc_syndrom = 0;\n\tu8 index, memory_wrapper_idx = 0;\n\tbool extract_info_from_fw;\n\tint rc;\n\n\tswitch (event_type) {\n\tcase GAUDI_EVENT_PCIE_CORE_SERR ... GAUDI_EVENT_PCIE_PHY_DERR:\n\tcase GAUDI_EVENT_DMA0_SERR_ECC ... GAUDI_EVENT_MMU_DERR:\n\t\textract_info_from_fw = true;\n\t\tbreak;\n\tcase GAUDI_EVENT_TPC0_SERR ... GAUDI_EVENT_TPC7_SERR:\n\t\tindex = event_type - GAUDI_EVENT_TPC0_SERR;\n\t\tparams.block_address = mmTPC0_CFG_BASE + index * TPC_CFG_OFFSET;\n\t\tparams.num_memories = 90;\n\t\tparams.derr = false;\n\t\tparams.disable_clock_gating = true;\n\t\textract_info_from_fw = false;\n\t\tbreak;\n\tcase GAUDI_EVENT_TPC0_DERR ... GAUDI_EVENT_TPC7_DERR:\n\t\tindex = event_type - GAUDI_EVENT_TPC0_DERR;\n\t\tparams.block_address =\n\t\t\tmmTPC0_CFG_BASE + index * TPC_CFG_OFFSET;\n\t\tparams.num_memories = 90;\n\t\tparams.derr = true;\n\t\tparams.disable_clock_gating = true;\n\t\textract_info_from_fw = false;\n\t\tbreak;\n\tcase GAUDI_EVENT_MME0_ACC_SERR:\n\tcase GAUDI_EVENT_MME1_ACC_SERR:\n\tcase GAUDI_EVENT_MME2_ACC_SERR:\n\tcase GAUDI_EVENT_MME3_ACC_SERR:\n\t\tindex = (event_type - GAUDI_EVENT_MME0_ACC_SERR) / 4;\n\t\tparams.block_address = mmMME0_ACC_BASE + index * MME_ACC_OFFSET;\n\t\tparams.num_memories = 128;\n\t\tparams.derr = false;\n\t\tparams.disable_clock_gating = true;\n\t\textract_info_from_fw = false;\n\t\tbreak;\n\tcase GAUDI_EVENT_MME0_ACC_DERR:\n\tcase GAUDI_EVENT_MME1_ACC_DERR:\n\tcase GAUDI_EVENT_MME2_ACC_DERR:\n\tcase GAUDI_EVENT_MME3_ACC_DERR:\n\t\tindex = (event_type - GAUDI_EVENT_MME0_ACC_DERR) / 4;\n\t\tparams.block_address = mmMME0_ACC_BASE + index * MME_ACC_OFFSET;\n\t\tparams.num_memories = 128;\n\t\tparams.derr = true;\n\t\tparams.disable_clock_gating = true;\n\t\textract_info_from_fw = false;\n\t\tbreak;\n\tcase GAUDI_EVENT_MME0_SBAB_SERR:\n\tcase GAUDI_EVENT_MME1_SBAB_SERR:\n\tcase GAUDI_EVENT_MME2_SBAB_SERR:\n\tcase GAUDI_EVENT_MME3_SBAB_SERR:\n\t\tindex = (event_type - GAUDI_EVENT_MME0_SBAB_SERR) / 4;\n\t\tparams.block_address =\n\t\t\tmmMME0_SBAB_BASE + index * MME_ACC_OFFSET;\n\t\tparams.num_memories = 33;\n\t\tparams.derr = false;\n\t\tparams.disable_clock_gating = true;\n\t\textract_info_from_fw = false;\n\t\tbreak;\n\tcase GAUDI_EVENT_MME0_SBAB_DERR:\n\tcase GAUDI_EVENT_MME1_SBAB_DERR:\n\tcase GAUDI_EVENT_MME2_SBAB_DERR:\n\tcase GAUDI_EVENT_MME3_SBAB_DERR:\n\t\tindex = (event_type - GAUDI_EVENT_MME0_SBAB_DERR) / 4;\n\t\tparams.block_address =\n\t\t\tmmMME0_SBAB_BASE + index * MME_ACC_OFFSET;\n\t\tparams.num_memories = 33;\n\t\tparams.derr = true;\n\t\tparams.disable_clock_gating = true;\n\t\textract_info_from_fw = false;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (extract_info_from_fw) {\n\t\tecc_address = le64_to_cpu(ecc_data->ecc_address);\n\t\tecc_syndrom = le64_to_cpu(ecc_data->ecc_syndrom);\n\t\tmemory_wrapper_idx = ecc_data->memory_wrapper_idx;\n\t} else {\n\t\trc = gaudi_extract_ecc_info(hdev, &params, &ecc_address,\n\t\t\t\t&ecc_syndrom, &memory_wrapper_idx);\n\t\tif (rc)\n\t\t\treturn;\n\t}\n\n\tdev_err(hdev->dev,\n\t\t\"ECC error detected. address: %#llx. Syndrom: %#llx. block id %u\\n\",\n\t\tecc_address, ecc_syndrom, memory_wrapper_idx);\n}\n\nstatic void gaudi_handle_qman_err(struct hl_device *hdev, u16 event_type)\n{\n\tu64 glbl_sts_addr, arb_err_addr;\n\tu8 index;\n\tchar desc[32];\n\n\tswitch (event_type) {\n\tcase GAUDI_EVENT_TPC0_QM ... GAUDI_EVENT_TPC7_QM:\n\t\tindex = event_type - GAUDI_EVENT_TPC0_QM;\n\t\tglbl_sts_addr =\n\t\t\tmmTPC0_QM_GLBL_STS1_0 + index * TPC_QMAN_OFFSET;\n\t\tarb_err_addr =\n\t\t\tmmTPC0_QM_ARB_ERR_CAUSE + index * TPC_QMAN_OFFSET;\n\t\tsnprintf(desc, ARRAY_SIZE(desc), \"%s%d\", \"TPC_QM\", index);\n\t\tbreak;\n\tcase GAUDI_EVENT_MME0_QM ... GAUDI_EVENT_MME2_QM:\n\t\tindex = event_type - GAUDI_EVENT_MME0_QM;\n\t\tglbl_sts_addr =\n\t\t\tmmMME0_QM_GLBL_STS1_0 + index * MME_QMAN_OFFSET;\n\t\tarb_err_addr =\n\t\t\tmmMME0_QM_ARB_ERR_CAUSE + index * MME_QMAN_OFFSET;\n\t\tsnprintf(desc, ARRAY_SIZE(desc), \"%s%d\", \"MME_QM\", index);\n\t\tbreak;\n\tcase GAUDI_EVENT_DMA0_QM ... GAUDI_EVENT_DMA7_QM:\n\t\tindex = event_type - GAUDI_EVENT_DMA0_QM;\n\t\tglbl_sts_addr =\n\t\t\tmmDMA0_QM_GLBL_STS1_0 + index * DMA_QMAN_OFFSET;\n\t\tarb_err_addr =\n\t\t\tmmDMA0_QM_ARB_ERR_CAUSE + index * DMA_QMAN_OFFSET;\n\t\tsnprintf(desc, ARRAY_SIZE(desc), \"%s%d\", \"DMA_QM\", index);\n\t\tbreak;\n\tcase GAUDI_EVENT_NIC0_QM0:\n\t\tglbl_sts_addr = mmNIC0_QM0_GLBL_STS1_0;\n\t\tarb_err_addr = mmNIC0_QM0_ARB_ERR_CAUSE;\n\t\tsnprintf(desc, ARRAY_SIZE(desc), \"NIC0_QM0\");\n\t\tbreak;\n\tcase GAUDI_EVENT_NIC0_QM1:\n\t\tglbl_sts_addr = mmNIC0_QM1_GLBL_STS1_0;\n\t\tarb_err_addr = mmNIC0_QM1_ARB_ERR_CAUSE;\n\t\tsnprintf(desc, ARRAY_SIZE(desc), \"NIC0_QM1\");\n\t\tbreak;\n\tcase GAUDI_EVENT_NIC1_QM0:\n\t\tglbl_sts_addr = mmNIC1_QM0_GLBL_STS1_0;\n\t\tarb_err_addr = mmNIC1_QM0_ARB_ERR_CAUSE;\n\t\tsnprintf(desc, ARRAY_SIZE(desc), \"NIC1_QM0\");\n\t\tbreak;\n\tcase GAUDI_EVENT_NIC1_QM1:\n\t\tglbl_sts_addr = mmNIC1_QM1_GLBL_STS1_0;\n\t\tarb_err_addr = mmNIC1_QM1_ARB_ERR_CAUSE;\n\t\tsnprintf(desc, ARRAY_SIZE(desc), \"NIC1_QM1\");\n\t\tbreak;\n\tcase GAUDI_EVENT_NIC2_QM0:\n\t\tglbl_sts_addr = mmNIC2_QM0_GLBL_STS1_0;\n\t\tarb_err_addr = mmNIC2_QM0_ARB_ERR_CAUSE;\n\t\tsnprintf(desc, ARRAY_SIZE(desc), \"NIC2_QM0\");\n\t\tbreak;\n\tcase GAUDI_EVENT_NIC2_QM1:\n\t\tglbl_sts_addr = mmNIC2_QM1_GLBL_STS1_0;\n\t\tarb_err_addr = mmNIC2_QM1_ARB_ERR_CAUSE;\n\t\tsnprintf(desc, ARRAY_SIZE(desc), \"NIC2_QM1\");\n\t\tbreak;\n\tcase GAUDI_EVENT_NIC3_QM0:\n\t\tglbl_sts_addr = mmNIC3_QM0_GLBL_STS1_0;\n\t\tarb_err_addr = mmNIC3_QM0_ARB_ERR_CAUSE;\n\t\tsnprintf(desc, ARRAY_SIZE(desc), \"NIC3_QM0\");\n\t\tbreak;\n\tcase GAUDI_EVENT_NIC3_QM1:\n\t\tglbl_sts_addr = mmNIC3_QM1_GLBL_STS1_0;\n\t\tarb_err_addr = mmNIC3_QM1_ARB_ERR_CAUSE;\n\t\tsnprintf(desc, ARRAY_SIZE(desc), \"NIC3_QM1\");\n\t\tbreak;\n\tcase GAUDI_EVENT_NIC4_QM0:\n\t\tglbl_sts_addr = mmNIC4_QM0_GLBL_STS1_0;\n\t\tarb_err_addr = mmNIC4_QM0_ARB_ERR_CAUSE;\n\t\tsnprintf(desc, ARRAY_SIZE(desc), \"NIC4_QM0\");\n\t\tbreak;\n\tcase GAUDI_EVENT_NIC4_QM1:\n\t\tglbl_sts_addr = mmNIC4_QM1_GLBL_STS1_0;\n\t\tarb_err_addr = mmNIC4_QM1_ARB_ERR_CAUSE;\n\t\tsnprintf(desc, ARRAY_SIZE(desc), \"NIC4_QM1\");\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tgaudi_handle_qman_err_generic(hdev, desc, glbl_sts_addr, arb_err_addr);\n}\n\nstatic void gaudi_print_irq_info(struct hl_device *hdev, u16 event_type,\n\t\t\t\t\tbool razwi)\n{\n\tchar desc[64] = \"\";\n\n\tgaudi_get_event_desc(event_type, desc, sizeof(desc));\n\tdev_err_ratelimited(hdev->dev, \"Received H/W interrupt %d [\\\"%s\\\"]\\n\",\n\t\tevent_type, desc);\n\n\tif (razwi) {\n\t\tgaudi_print_razwi_info(hdev);\n\t\tgaudi_print_mmu_error_info(hdev);\n\t}\n}\n\nstatic int gaudi_soft_reset_late_init(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\t/* Unmask all IRQs since some could have been received\n\t * during the soft reset\n\t */\n\treturn hl_fw_unmask_irq_arr(hdev, gaudi->events, sizeof(gaudi->events));\n}\n\nstatic int gaudi_hbm_read_interrupts(struct hl_device *hdev, int device,\n\t\t\tstruct hl_eq_hbm_ecc_data *hbm_ecc_data)\n{\n\tu32 base, val, val2, wr_par, rd_par, ca_par, derr, serr, type, ch;\n\tint err = 0;\n\n\tif (hdev->asic_prop.fw_security_status_valid &&\n\t\t\t(hdev->asic_prop.fw_app_security_map &\n\t\t\t\tCPU_BOOT_DEV_STS0_HBM_ECC_EN)) {\n\t\tif (!hbm_ecc_data) {\n\t\t\tdev_err(hdev->dev, \"No FW ECC data\");\n\t\t\treturn 0;\n\t\t}\n\n\t\twr_par = FIELD_GET(CPUCP_PKT_HBM_ECC_INFO_WR_PAR_MASK,\n\t\t\t\tle32_to_cpu(hbm_ecc_data->hbm_ecc_info));\n\t\trd_par = FIELD_GET(CPUCP_PKT_HBM_ECC_INFO_RD_PAR_MASK,\n\t\t\t\tle32_to_cpu(hbm_ecc_data->hbm_ecc_info));\n\t\tca_par = FIELD_GET(CPUCP_PKT_HBM_ECC_INFO_CA_PAR_MASK,\n\t\t\t\tle32_to_cpu(hbm_ecc_data->hbm_ecc_info));\n\t\tderr = FIELD_GET(CPUCP_PKT_HBM_ECC_INFO_DERR_MASK,\n\t\t\t\tle32_to_cpu(hbm_ecc_data->hbm_ecc_info));\n\t\tserr = FIELD_GET(CPUCP_PKT_HBM_ECC_INFO_SERR_MASK,\n\t\t\t\tle32_to_cpu(hbm_ecc_data->hbm_ecc_info));\n\t\ttype = FIELD_GET(CPUCP_PKT_HBM_ECC_INFO_TYPE_MASK,\n\t\t\t\tle32_to_cpu(hbm_ecc_data->hbm_ecc_info));\n\t\tch = FIELD_GET(CPUCP_PKT_HBM_ECC_INFO_HBM_CH_MASK,\n\t\t\t\tle32_to_cpu(hbm_ecc_data->hbm_ecc_info));\n\n\t\tdev_err(hdev->dev,\n\t\t\t\"HBM%d pc%d interrupts info: WR_PAR=%d, RD_PAR=%d, CA_PAR=%d, SERR=%d, DERR=%d\\n\",\n\t\t\tdevice, ch, wr_par, rd_par, ca_par, serr, derr);\n\t\tdev_err(hdev->dev,\n\t\t\t\"HBM%d pc%d ECC info: 1ST_ERR_ADDR=0x%x, 1ST_ERR_TYPE=%d, SEC_CONT_CNT=%u, SEC_CNT=%d, DEC_CNT=%d\\n\",\n\t\t\tdevice, ch, hbm_ecc_data->first_addr, type,\n\t\t\thbm_ecc_data->sec_cont_cnt, hbm_ecc_data->sec_cnt,\n\t\t\thbm_ecc_data->dec_cnt);\n\n\t\terr = 1;\n\n\t\treturn 0;\n\t}\n\n\tif (!hdev->asic_prop.fw_security_disabled) {\n\t\tdev_info(hdev->dev, \"Cannot access MC regs for ECC data while security is enabled\\n\");\n\t\treturn 0;\n\t}\n\n\tbase = GAUDI_HBM_CFG_BASE + device * GAUDI_HBM_CFG_OFFSET;\n\tfor (ch = 0 ; ch < GAUDI_HBM_CHANNELS ; ch++) {\n\t\tval = RREG32_MASK(base + ch * 0x1000 + 0x06C, 0x0000FFFF);\n\t\tval = (val & 0xFF) | ((val >> 8) & 0xFF);\n\t\tif (val) {\n\t\t\terr = 1;\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"HBM%d pc%d interrupts info: WR_PAR=%d, RD_PAR=%d, CA_PAR=%d, SERR=%d, DERR=%d\\n\",\n\t\t\t\tdevice, ch * 2, val & 0x1, (val >> 1) & 0x1,\n\t\t\t\t(val >> 2) & 0x1, (val >> 3) & 0x1,\n\t\t\t\t(val >> 4) & 0x1);\n\n\t\t\tval2 = RREG32(base + ch * 0x1000 + 0x060);\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"HBM%d pc%d ECC info: 1ST_ERR_ADDR=0x%x, 1ST_ERR_TYPE=%d, SEC_CONT_CNT=%d, SEC_CNT=%d, DEC_CNT=%d\\n\",\n\t\t\t\tdevice, ch * 2,\n\t\t\t\tRREG32(base + ch * 0x1000 + 0x064),\n\t\t\t\t(val2 & 0x200) >> 9, (val2 & 0xFC00) >> 10,\n\t\t\t\t(val2 & 0xFF0000) >> 16,\n\t\t\t\t(val2 & 0xFF000000) >> 24);\n\t\t}\n\n\t\tval = RREG32_MASK(base + ch * 0x1000 + 0x07C, 0x0000FFFF);\n\t\tval = (val & 0xFF) | ((val >> 8) & 0xFF);\n\t\tif (val) {\n\t\t\terr = 1;\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"HBM%d pc%d interrupts info: WR_PAR=%d, RD_PAR=%d, CA_PAR=%d, SERR=%d, DERR=%d\\n\",\n\t\t\t\tdevice, ch * 2 + 1, val & 0x1, (val >> 1) & 0x1,\n\t\t\t\t(val >> 2) & 0x1, (val >> 3) & 0x1,\n\t\t\t\t(val >> 4) & 0x1);\n\n\t\t\tval2 = RREG32(base + ch * 0x1000 + 0x070);\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"HBM%d pc%d ECC info: 1ST_ERR_ADDR=0x%x, 1ST_ERR_TYPE=%d, SEC_CONT_CNT=%d, SEC_CNT=%d, DEC_CNT=%d\\n\",\n\t\t\t\tdevice, ch * 2 + 1,\n\t\t\t\tRREG32(base + ch * 0x1000 + 0x074),\n\t\t\t\t(val2 & 0x200) >> 9, (val2 & 0xFC00) >> 10,\n\t\t\t\t(val2 & 0xFF0000) >> 16,\n\t\t\t\t(val2 & 0xFF000000) >> 24);\n\t\t}\n\n\t\t/* Clear interrupts */\n\t\tRMWREG32(base + (ch * 0x1000) + 0x060, 0x1C8, 0x1FF);\n\t\tRMWREG32(base + (ch * 0x1000) + 0x070, 0x1C8, 0x1FF);\n\t\tWREG32(base + (ch * 0x1000) + 0x06C, 0x1F1F);\n\t\tWREG32(base + (ch * 0x1000) + 0x07C, 0x1F1F);\n\t\tRMWREG32(base + (ch * 0x1000) + 0x060, 0x0, 0xF);\n\t\tRMWREG32(base + (ch * 0x1000) + 0x070, 0x0, 0xF);\n\t}\n\n\tval  = RREG32(base + 0x8F30);\n\tval2 = RREG32(base + 0x8F34);\n\tif (val | val2) {\n\t\terr = 1;\n\t\tdev_err(hdev->dev,\n\t\t\t\"HBM %d MC SRAM SERR info: Reg 0x8F30=0x%x, Reg 0x8F34=0x%x\\n\",\n\t\t\tdevice, val, val2);\n\t}\n\tval  = RREG32(base + 0x8F40);\n\tval2 = RREG32(base + 0x8F44);\n\tif (val | val2) {\n\t\terr = 1;\n\t\tdev_err(hdev->dev,\n\t\t\t\"HBM %d MC SRAM DERR info: Reg 0x8F40=0x%x, Reg 0x8F44=0x%x\\n\",\n\t\t\tdevice, val, val2);\n\t}\n\n\treturn err;\n}\n\nstatic int gaudi_hbm_event_to_dev(u16 hbm_event_type)\n{\n\tswitch (hbm_event_type) {\n\tcase GAUDI_EVENT_HBM0_SPI_0:\n\tcase GAUDI_EVENT_HBM0_SPI_1:\n\t\treturn 0;\n\tcase GAUDI_EVENT_HBM1_SPI_0:\n\tcase GAUDI_EVENT_HBM1_SPI_1:\n\t\treturn 1;\n\tcase GAUDI_EVENT_HBM2_SPI_0:\n\tcase GAUDI_EVENT_HBM2_SPI_1:\n\t\treturn 2;\n\tcase GAUDI_EVENT_HBM3_SPI_0:\n\tcase GAUDI_EVENT_HBM3_SPI_1:\n\t\treturn 3;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* Should never happen */\n\treturn 0;\n}\n\nstatic bool gaudi_tpc_read_interrupts(struct hl_device *hdev, u8 tpc_id,\n\t\t\t\t\tchar *interrupt_name)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu32 tpc_offset = tpc_id * TPC_CFG_OFFSET, tpc_interrupts_cause, i;\n\tbool soft_reset_required = false;\n\n\t/* Accessing the TPC_INTR_CAUSE registers requires disabling the clock\n\t * gating, and thus cannot be done in CPU-CP and should be done instead\n\t * by the driver.\n\t */\n\n\tmutex_lock(&gaudi->clk_gate_mutex);\n\n\thdev->asic_funcs->disable_clock_gating(hdev);\n\n\ttpc_interrupts_cause = RREG32(mmTPC0_CFG_TPC_INTR_CAUSE + tpc_offset) &\n\t\t\t\tTPC0_CFG_TPC_INTR_CAUSE_CAUSE_MASK;\n\n\tfor (i = 0 ; i < GAUDI_NUM_OF_TPC_INTR_CAUSE ; i++)\n\t\tif (tpc_interrupts_cause & BIT(i)) {\n\t\t\tdev_err_ratelimited(hdev->dev,\n\t\t\t\t\t\"TPC%d_%s interrupt cause: %s\\n\",\n\t\t\t\t\ttpc_id, interrupt_name,\n\t\t\t\t\tgaudi_tpc_interrupts_cause[i]);\n\t\t\t/* If this is QM error, we need to soft-reset */\n\t\t\tif (i == 15)\n\t\t\t\tsoft_reset_required = true;\n\t\t}\n\n\t/* Clear interrupts */\n\tWREG32(mmTPC0_CFG_TPC_INTR_CAUSE + tpc_offset, 0);\n\n\thdev->asic_funcs->set_clock_gating(hdev);\n\n\tmutex_unlock(&gaudi->clk_gate_mutex);\n\n\treturn soft_reset_required;\n}\n\nstatic int tpc_dec_event_to_tpc_id(u16 tpc_dec_event_type)\n{\n\treturn (tpc_dec_event_type - GAUDI_EVENT_TPC0_DEC) >> 1;\n}\n\nstatic int tpc_krn_event_to_tpc_id(u16 tpc_dec_event_type)\n{\n\treturn (tpc_dec_event_type - GAUDI_EVENT_TPC0_KRN_ERR) / 6;\n}\n\nstatic void gaudi_print_clk_change_info(struct hl_device *hdev,\n\t\t\t\t\tu16 event_type)\n{\n\tswitch (event_type) {\n\tcase GAUDI_EVENT_FIX_POWER_ENV_S:\n\t\thdev->clk_throttling_reason |= HL_CLK_THROTTLE_POWER;\n\t\tdev_info_ratelimited(hdev->dev,\n\t\t\t\"Clock throttling due to power consumption\\n\");\n\t\tbreak;\n\n\tcase GAUDI_EVENT_FIX_POWER_ENV_E:\n\t\thdev->clk_throttling_reason &= ~HL_CLK_THROTTLE_POWER;\n\t\tdev_info_ratelimited(hdev->dev,\n\t\t\t\"Power envelop is safe, back to optimal clock\\n\");\n\t\tbreak;\n\n\tcase GAUDI_EVENT_FIX_THERMAL_ENV_S:\n\t\thdev->clk_throttling_reason |= HL_CLK_THROTTLE_THERMAL;\n\t\tdev_info_ratelimited(hdev->dev,\n\t\t\t\"Clock throttling due to overheating\\n\");\n\t\tbreak;\n\n\tcase GAUDI_EVENT_FIX_THERMAL_ENV_E:\n\t\thdev->clk_throttling_reason &= ~HL_CLK_THROTTLE_THERMAL;\n\t\tdev_info_ratelimited(hdev->dev,\n\t\t\t\"Thermal envelop is safe, back to optimal clock\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(hdev->dev, \"Received invalid clock change event %d\\n\",\n\t\t\tevent_type);\n\t\tbreak;\n\t}\n}\n\nstatic void gaudi_handle_eqe(struct hl_device *hdev,\n\t\t\t\tstruct hl_eq_entry *eq_entry)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu32 ctl = le32_to_cpu(eq_entry->hdr.ctl);\n\tu16 event_type = ((ctl & EQ_CTL_EVENT_TYPE_MASK)\n\t\t\t>> EQ_CTL_EVENT_TYPE_SHIFT);\n\tu8 cause;\n\tbool reset_required;\n\n\tgaudi->events_stat[event_type]++;\n\tgaudi->events_stat_aggregate[event_type]++;\n\n\tswitch (event_type) {\n\tcase GAUDI_EVENT_PCIE_CORE_DERR:\n\tcase GAUDI_EVENT_PCIE_IF_DERR:\n\tcase GAUDI_EVENT_PCIE_PHY_DERR:\n\tcase GAUDI_EVENT_TPC0_DERR ... GAUDI_EVENT_TPC7_DERR:\n\tcase GAUDI_EVENT_MME0_ACC_DERR:\n\tcase GAUDI_EVENT_MME0_SBAB_DERR:\n\tcase GAUDI_EVENT_MME1_ACC_DERR:\n\tcase GAUDI_EVENT_MME1_SBAB_DERR:\n\tcase GAUDI_EVENT_MME2_ACC_DERR:\n\tcase GAUDI_EVENT_MME2_SBAB_DERR:\n\tcase GAUDI_EVENT_MME3_ACC_DERR:\n\tcase GAUDI_EVENT_MME3_SBAB_DERR:\n\tcase GAUDI_EVENT_DMA0_DERR_ECC ... GAUDI_EVENT_DMA7_DERR_ECC:\n\t\tfallthrough;\n\tcase GAUDI_EVENT_CPU_IF_ECC_DERR:\n\tcase GAUDI_EVENT_PSOC_MEM_DERR:\n\tcase GAUDI_EVENT_PSOC_CORESIGHT_DERR:\n\tcase GAUDI_EVENT_SRAM0_DERR ... GAUDI_EVENT_SRAM28_DERR:\n\tcase GAUDI_EVENT_DMA_IF0_DERR ... GAUDI_EVENT_DMA_IF3_DERR:\n\tcase GAUDI_EVENT_HBM_0_DERR ... GAUDI_EVENT_HBM_3_DERR:\n\tcase GAUDI_EVENT_MMU_DERR:\n\t\tgaudi_print_irq_info(hdev, event_type, true);\n\t\tgaudi_handle_ecc_event(hdev, event_type, &eq_entry->ecc_data);\n\t\tif (hdev->hard_reset_on_fw_events)\n\t\t\thl_device_reset(hdev, true, false);\n\t\tbreak;\n\n\tcase GAUDI_EVENT_GIC500:\n\tcase GAUDI_EVENT_AXI_ECC:\n\tcase GAUDI_EVENT_L2_RAM_ECC:\n\tcase GAUDI_EVENT_PLL0 ... GAUDI_EVENT_PLL17:\n\t\tgaudi_print_irq_info(hdev, event_type, false);\n\t\tif (hdev->hard_reset_on_fw_events)\n\t\t\thl_device_reset(hdev, true, false);\n\t\tbreak;\n\n\tcase GAUDI_EVENT_HBM0_SPI_0:\n\tcase GAUDI_EVENT_HBM1_SPI_0:\n\tcase GAUDI_EVENT_HBM2_SPI_0:\n\tcase GAUDI_EVENT_HBM3_SPI_0:\n\t\tgaudi_print_irq_info(hdev, event_type, false);\n\t\tgaudi_hbm_read_interrupts(hdev,\n\t\t\t\tgaudi_hbm_event_to_dev(event_type),\n\t\t\t\t&eq_entry->hbm_ecc_data);\n\t\tif (hdev->hard_reset_on_fw_events)\n\t\t\thl_device_reset(hdev, true, false);\n\t\tbreak;\n\n\tcase GAUDI_EVENT_HBM0_SPI_1:\n\tcase GAUDI_EVENT_HBM1_SPI_1:\n\tcase GAUDI_EVENT_HBM2_SPI_1:\n\tcase GAUDI_EVENT_HBM3_SPI_1:\n\t\tgaudi_print_irq_info(hdev, event_type, false);\n\t\tgaudi_hbm_read_interrupts(hdev,\n\t\t\t\tgaudi_hbm_event_to_dev(event_type),\n\t\t\t\t&eq_entry->hbm_ecc_data);\n\t\thl_fw_unmask_irq(hdev, event_type);\n\t\tbreak;\n\n\tcase GAUDI_EVENT_TPC0_DEC:\n\tcase GAUDI_EVENT_TPC1_DEC:\n\tcase GAUDI_EVENT_TPC2_DEC:\n\tcase GAUDI_EVENT_TPC3_DEC:\n\tcase GAUDI_EVENT_TPC4_DEC:\n\tcase GAUDI_EVENT_TPC5_DEC:\n\tcase GAUDI_EVENT_TPC6_DEC:\n\tcase GAUDI_EVENT_TPC7_DEC:\n\t\tgaudi_print_irq_info(hdev, event_type, true);\n\t\treset_required = gaudi_tpc_read_interrupts(hdev,\n\t\t\t\t\ttpc_dec_event_to_tpc_id(event_type),\n\t\t\t\t\t\"AXI_SLV_DEC_Error\");\n\t\tif (reset_required) {\n\t\t\tdev_err(hdev->dev, \"hard reset required due to %s\\n\",\n\t\t\t\tgaudi_irq_map_table[event_type].name);\n\n\t\t\tif (hdev->hard_reset_on_fw_events)\n\t\t\t\thl_device_reset(hdev, true, false);\n\t\t} else {\n\t\t\thl_fw_unmask_irq(hdev, event_type);\n\t\t}\n\t\tbreak;\n\n\tcase GAUDI_EVENT_TPC0_KRN_ERR:\n\tcase GAUDI_EVENT_TPC1_KRN_ERR:\n\tcase GAUDI_EVENT_TPC2_KRN_ERR:\n\tcase GAUDI_EVENT_TPC3_KRN_ERR:\n\tcase GAUDI_EVENT_TPC4_KRN_ERR:\n\tcase GAUDI_EVENT_TPC5_KRN_ERR:\n\tcase GAUDI_EVENT_TPC6_KRN_ERR:\n\tcase GAUDI_EVENT_TPC7_KRN_ERR:\n\t\tgaudi_print_irq_info(hdev, event_type, true);\n\t\treset_required = gaudi_tpc_read_interrupts(hdev,\n\t\t\t\t\ttpc_krn_event_to_tpc_id(event_type),\n\t\t\t\t\t\"KRN_ERR\");\n\t\tif (reset_required) {\n\t\t\tdev_err(hdev->dev, \"hard reset required due to %s\\n\",\n\t\t\t\tgaudi_irq_map_table[event_type].name);\n\n\t\t\tif (hdev->hard_reset_on_fw_events)\n\t\t\t\thl_device_reset(hdev, true, false);\n\t\t} else {\n\t\t\thl_fw_unmask_irq(hdev, event_type);\n\t\t}\n\t\tbreak;\n\n\tcase GAUDI_EVENT_PCIE_CORE_SERR:\n\tcase GAUDI_EVENT_PCIE_IF_SERR:\n\tcase GAUDI_EVENT_PCIE_PHY_SERR:\n\tcase GAUDI_EVENT_TPC0_SERR ... GAUDI_EVENT_TPC7_SERR:\n\tcase GAUDI_EVENT_MME0_ACC_SERR:\n\tcase GAUDI_EVENT_MME0_SBAB_SERR:\n\tcase GAUDI_EVENT_MME1_ACC_SERR:\n\tcase GAUDI_EVENT_MME1_SBAB_SERR:\n\tcase GAUDI_EVENT_MME2_ACC_SERR:\n\tcase GAUDI_EVENT_MME2_SBAB_SERR:\n\tcase GAUDI_EVENT_MME3_ACC_SERR:\n\tcase GAUDI_EVENT_MME3_SBAB_SERR:\n\tcase GAUDI_EVENT_DMA0_SERR_ECC ... GAUDI_EVENT_DMA7_SERR_ECC:\n\tcase GAUDI_EVENT_CPU_IF_ECC_SERR:\n\tcase GAUDI_EVENT_PSOC_MEM_SERR:\n\tcase GAUDI_EVENT_PSOC_CORESIGHT_SERR:\n\tcase GAUDI_EVENT_SRAM0_SERR ... GAUDI_EVENT_SRAM28_SERR:\n\tcase GAUDI_EVENT_DMA_IF0_SERR ... GAUDI_EVENT_DMA_IF3_SERR:\n\tcase GAUDI_EVENT_HBM_0_SERR ... GAUDI_EVENT_HBM_3_SERR:\n\t\tfallthrough;\n\tcase GAUDI_EVENT_MMU_SERR:\n\t\tgaudi_print_irq_info(hdev, event_type, true);\n\t\tgaudi_handle_ecc_event(hdev, event_type, &eq_entry->ecc_data);\n\t\thl_fw_unmask_irq(hdev, event_type);\n\t\tbreak;\n\n\tcase GAUDI_EVENT_PCIE_DEC:\n\tcase GAUDI_EVENT_MME0_WBC_RSP:\n\tcase GAUDI_EVENT_MME0_SBAB0_RSP:\n\tcase GAUDI_EVENT_MME1_WBC_RSP:\n\tcase GAUDI_EVENT_MME1_SBAB0_RSP:\n\tcase GAUDI_EVENT_MME2_WBC_RSP:\n\tcase GAUDI_EVENT_MME2_SBAB0_RSP:\n\tcase GAUDI_EVENT_MME3_WBC_RSP:\n\tcase GAUDI_EVENT_MME3_SBAB0_RSP:\n\tcase GAUDI_EVENT_CPU_AXI_SPLITTER:\n\tcase GAUDI_EVENT_PSOC_AXI_DEC:\n\tcase GAUDI_EVENT_PSOC_PRSTN_FALL:\n\tcase GAUDI_EVENT_MMU_PAGE_FAULT:\n\tcase GAUDI_EVENT_MMU_WR_PERM:\n\tcase GAUDI_EVENT_RAZWI_OR_ADC:\n\tcase GAUDI_EVENT_TPC0_QM ... GAUDI_EVENT_TPC7_QM:\n\tcase GAUDI_EVENT_MME0_QM ... GAUDI_EVENT_MME2_QM:\n\tcase GAUDI_EVENT_DMA0_QM ... GAUDI_EVENT_DMA7_QM:\n\t\tfallthrough;\n\tcase GAUDI_EVENT_NIC0_QM0:\n\tcase GAUDI_EVENT_NIC0_QM1:\n\tcase GAUDI_EVENT_NIC1_QM0:\n\tcase GAUDI_EVENT_NIC1_QM1:\n\tcase GAUDI_EVENT_NIC2_QM0:\n\tcase GAUDI_EVENT_NIC2_QM1:\n\tcase GAUDI_EVENT_NIC3_QM0:\n\tcase GAUDI_EVENT_NIC3_QM1:\n\tcase GAUDI_EVENT_NIC4_QM0:\n\tcase GAUDI_EVENT_NIC4_QM1:\n\tcase GAUDI_EVENT_DMA0_CORE ... GAUDI_EVENT_DMA7_CORE:\n\t\tgaudi_print_irq_info(hdev, event_type, true);\n\t\tgaudi_handle_qman_err(hdev, event_type);\n\t\thl_fw_unmask_irq(hdev, event_type);\n\t\tbreak;\n\n\tcase GAUDI_EVENT_RAZWI_OR_ADC_SW:\n\t\tgaudi_print_irq_info(hdev, event_type, true);\n\t\tif (hdev->hard_reset_on_fw_events)\n\t\t\thl_device_reset(hdev, true, false);\n\t\tbreak;\n\n\tcase GAUDI_EVENT_TPC0_BMON_SPMU:\n\tcase GAUDI_EVENT_TPC1_BMON_SPMU:\n\tcase GAUDI_EVENT_TPC2_BMON_SPMU:\n\tcase GAUDI_EVENT_TPC3_BMON_SPMU:\n\tcase GAUDI_EVENT_TPC4_BMON_SPMU:\n\tcase GAUDI_EVENT_TPC5_BMON_SPMU:\n\tcase GAUDI_EVENT_TPC6_BMON_SPMU:\n\tcase GAUDI_EVENT_TPC7_BMON_SPMU:\n\tcase GAUDI_EVENT_DMA_BM_CH0 ... GAUDI_EVENT_DMA_BM_CH7:\n\t\tgaudi_print_irq_info(hdev, event_type, false);\n\t\thl_fw_unmask_irq(hdev, event_type);\n\t\tbreak;\n\n\tcase GAUDI_EVENT_DMA_IF_SEI_0 ... GAUDI_EVENT_DMA_IF_SEI_3:\n\t\tgaudi_print_irq_info(hdev, event_type, false);\n\t\tgaudi_print_sm_sei_info(hdev, event_type,\n\t\t\t\t\t&eq_entry->sm_sei_data);\n\t\thl_fw_unmask_irq(hdev, event_type);\n\t\tbreak;\n\n\tcase GAUDI_EVENT_FIX_POWER_ENV_S ... GAUDI_EVENT_FIX_THERMAL_ENV_E:\n\t\tgaudi_print_clk_change_info(hdev, event_type);\n\t\thl_fw_unmask_irq(hdev, event_type);\n\t\tbreak;\n\n\tcase GAUDI_EVENT_PSOC_GPIO_U16_0:\n\t\tcause = le64_to_cpu(eq_entry->data[0]) & 0xFF;\n\t\tdev_err(hdev->dev,\n\t\t\t\"Received high temp H/W interrupt %d (cause %d)\\n\",\n\t\t\tevent_type, cause);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(hdev->dev, \"Received invalid H/W interrupt %d\\n\",\n\t\t\t\tevent_type);\n\t\tbreak;\n\t}\n}\n\nstatic void *gaudi_get_events_stat(struct hl_device *hdev, bool aggregate,\n\t\t\t\t\tu32 *size)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (aggregate) {\n\t\t*size = (u32) sizeof(gaudi->events_stat_aggregate);\n\t\treturn gaudi->events_stat_aggregate;\n\t}\n\n\t*size = (u32) sizeof(gaudi->events_stat);\n\treturn gaudi->events_stat;\n}\n\nstatic int gaudi_mmu_invalidate_cache(struct hl_device *hdev, bool is_hard,\n\t\t\t\t\tu32 flags)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu32 status, timeout_usec;\n\tint rc;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_MMU) ||\n\t\thdev->hard_reset_pending)\n\t\treturn 0;\n\n\tif (hdev->pldm)\n\t\ttimeout_usec = GAUDI_PLDM_MMU_TIMEOUT_USEC;\n\telse\n\t\ttimeout_usec = MMU_CONFIG_TIMEOUT_USEC;\n\n\t/* L0 & L1 invalidation */\n\tWREG32(mmSTLB_INV_PS, 3);\n\tWREG32(mmSTLB_CACHE_INV, gaudi->mmu_cache_inv_pi++);\n\tWREG32(mmSTLB_INV_PS, 2);\n\n\trc = hl_poll_timeout(\n\t\thdev,\n\t\tmmSTLB_INV_PS,\n\t\tstatus,\n\t\t!status,\n\t\t1000,\n\t\ttimeout_usec);\n\n\tWREG32(mmSTLB_INV_SET, 0);\n\n\tif (rc) {\n\t\tdev_err_ratelimited(hdev->dev,\n\t\t\t\t\t\"MMU cache invalidation timeout\\n\");\n\t\thl_device_reset(hdev, true, false);\n\t}\n\n\treturn rc;\n}\n\nstatic int gaudi_mmu_invalidate_cache_range(struct hl_device *hdev,\n\t\t\t\tbool is_hard, u32 asid, u64 va, u64 size)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu32 status, timeout_usec;\n\tu32 inv_data;\n\tu32 pi;\n\tint rc;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_MMU) ||\n\t\thdev->hard_reset_pending)\n\t\treturn 0;\n\n\tif (hdev->pldm)\n\t\ttimeout_usec = GAUDI_PLDM_MMU_TIMEOUT_USEC;\n\telse\n\t\ttimeout_usec = MMU_CONFIG_TIMEOUT_USEC;\n\n\t/*\n\t * TODO: currently invalidate entire L0 & L1 as in regular hard\n\t * invalidation. Need to apply invalidation of specific cache\n\t * lines with mask of ASID & VA & size.\n\t * Note that L1 with be flushed entirely in any case.\n\t */\n\n\t/* L0 & L1 invalidation */\n\tinv_data = RREG32(mmSTLB_CACHE_INV);\n\t/* PI is 8 bit */\n\tpi = ((inv_data & STLB_CACHE_INV_PRODUCER_INDEX_MASK) + 1) & 0xFF;\n\tWREG32(mmSTLB_CACHE_INV,\n\t\t(inv_data & STLB_CACHE_INV_INDEX_MASK_MASK) | pi);\n\n\trc = hl_poll_timeout(\n\t\thdev,\n\t\tmmSTLB_INV_CONSUMER_INDEX,\n\t\tstatus,\n\t\tstatus == pi,\n\t\t1000,\n\t\ttimeout_usec);\n\n\tif (rc) {\n\t\tdev_err_ratelimited(hdev->dev,\n\t\t\t\t\t\"MMU cache invalidation timeout\\n\");\n\t\thl_device_reset(hdev, true, false);\n\t}\n\n\treturn rc;\n}\n\nstatic int gaudi_mmu_update_asid_hop0_addr(struct hl_device *hdev,\n\t\t\t\t\tu32 asid, u64 phys_addr)\n{\n\tu32 status, timeout_usec;\n\tint rc;\n\n\tif (hdev->pldm)\n\t\ttimeout_usec = GAUDI_PLDM_MMU_TIMEOUT_USEC;\n\telse\n\t\ttimeout_usec = MMU_CONFIG_TIMEOUT_USEC;\n\n\tWREG32(MMU_ASID, asid);\n\tWREG32(MMU_HOP0_PA43_12, phys_addr >> MMU_HOP0_PA43_12_SHIFT);\n\tWREG32(MMU_HOP0_PA49_44, phys_addr >> MMU_HOP0_PA49_44_SHIFT);\n\tWREG32(MMU_BUSY, 0x80000000);\n\n\trc = hl_poll_timeout(\n\t\thdev,\n\t\tMMU_BUSY,\n\t\tstatus,\n\t\t!(status & 0x80000000),\n\t\t1000,\n\t\ttimeout_usec);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Timeout during MMU hop0 config of asid %d\\n\", asid);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int gaudi_send_heartbeat(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_CPU_Q))\n\t\treturn 0;\n\n\treturn hl_fw_send_heartbeat(hdev);\n}\n\nstatic int gaudi_cpucp_info_get(struct hl_device *hdev)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tint rc;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_CPU_Q))\n\t\treturn 0;\n\n\trc = hl_fw_cpucp_info_get(hdev, mmCPU_BOOT_DEV_STS0, mmCPU_BOOT_ERR0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!strlen(prop->cpucp_info.card_name))\n\t\tstrncpy(prop->cpucp_info.card_name, GAUDI_DEFAULT_CARD_NAME,\n\t\t\t\tCARD_NAME_MAX_LEN);\n\n\thdev->card_type = le32_to_cpu(hdev->asic_prop.cpucp_info.card_type);\n\n\tif (hdev->card_type == cpucp_card_type_pci)\n\t\tprop->max_power_default = MAX_POWER_DEFAULT_PCI;\n\telse if (hdev->card_type == cpucp_card_type_pmc)\n\t\tprop->max_power_default = MAX_POWER_DEFAULT_PMC;\n\n\thdev->max_power = prop->max_power_default;\n\n\treturn 0;\n}\n\nstatic bool gaudi_is_device_idle(struct hl_device *hdev, u64 *mask_arr,\n\t\t\t\t\tu8 mask_len, struct seq_file *s)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tconst char *fmt = \"%-5d%-9s%#-14x%#-12x%#x\\n\";\n\tconst char *mme_slave_fmt = \"%-5d%-9s%-14s%-12s%#x\\n\";\n\tconst char *nic_fmt = \"%-5d%-9s%#-14x%#x\\n\";\n\tunsigned long *mask = (unsigned long *)mask_arr;\n\tu32 qm_glbl_sts0, qm_cgm_sts, dma_core_sts0, tpc_cfg_sts, mme_arch_sts;\n\tbool is_idle = true, is_eng_idle, is_slave;\n\tu64 offset;\n\tint i, dma_id, port;\n\n\tmutex_lock(&gaudi->clk_gate_mutex);\n\n\thdev->asic_funcs->disable_clock_gating(hdev);\n\n\tif (s)\n\t\tseq_puts(s,\n\t\t\t\"\\nDMA  is_idle  QM_GLBL_STS0  QM_CGM_STS  DMA_CORE_STS0\\n\"\n\t\t\t\"---  -------  ------------  ----------  -------------\\n\");\n\n\tfor (i = 0 ; i < DMA_NUMBER_OF_CHNLS ; i++) {\n\t\tdma_id = gaudi_dma_assignment[i];\n\t\toffset = dma_id * DMA_QMAN_OFFSET;\n\n\t\tqm_glbl_sts0 = RREG32(mmDMA0_QM_GLBL_STS0 + offset);\n\t\tqm_cgm_sts = RREG32(mmDMA0_QM_CGM_STS + offset);\n\t\tdma_core_sts0 = RREG32(mmDMA0_CORE_STS0 + offset);\n\t\tis_eng_idle = IS_QM_IDLE(qm_glbl_sts0, qm_cgm_sts) &&\n\t\t\t\tIS_DMA_IDLE(dma_core_sts0);\n\t\tis_idle &= is_eng_idle;\n\n\t\tif (mask && !is_eng_idle)\n\t\t\tset_bit(GAUDI_ENGINE_ID_DMA_0 + dma_id, mask);\n\t\tif (s)\n\t\t\tseq_printf(s, fmt, dma_id,\n\t\t\t\tis_eng_idle ? \"Y\" : \"N\", qm_glbl_sts0,\n\t\t\t\tqm_cgm_sts, dma_core_sts0);\n\t}\n\n\tif (s)\n\t\tseq_puts(s,\n\t\t\t\"\\nTPC  is_idle  QM_GLBL_STS0  QM_CGM_STS  CFG_STATUS\\n\"\n\t\t\t\"---  -------  ------------  ----------  ----------\\n\");\n\n\tfor (i = 0 ; i < TPC_NUMBER_OF_ENGINES ; i++) {\n\t\toffset = i * TPC_QMAN_OFFSET;\n\t\tqm_glbl_sts0 = RREG32(mmTPC0_QM_GLBL_STS0 + offset);\n\t\tqm_cgm_sts = RREG32(mmTPC0_QM_CGM_STS + offset);\n\t\ttpc_cfg_sts = RREG32(mmTPC0_CFG_STATUS + offset);\n\t\tis_eng_idle = IS_QM_IDLE(qm_glbl_sts0, qm_cgm_sts) &&\n\t\t\t\tIS_TPC_IDLE(tpc_cfg_sts);\n\t\tis_idle &= is_eng_idle;\n\n\t\tif (mask && !is_eng_idle)\n\t\t\tset_bit(GAUDI_ENGINE_ID_TPC_0 + i, mask);\n\t\tif (s)\n\t\t\tseq_printf(s, fmt, i,\n\t\t\t\tis_eng_idle ? \"Y\" : \"N\",\n\t\t\t\tqm_glbl_sts0, qm_cgm_sts, tpc_cfg_sts);\n\t}\n\n\tif (s)\n\t\tseq_puts(s,\n\t\t\t\"\\nMME  is_idle  QM_GLBL_STS0  QM_CGM_STS  ARCH_STATUS\\n\"\n\t\t\t\"---  -------  ------------  ----------  -----------\\n\");\n\n\tfor (i = 0 ; i < MME_NUMBER_OF_ENGINES ; i++) {\n\t\toffset = i * MME_QMAN_OFFSET;\n\t\tmme_arch_sts = RREG32(mmMME0_CTRL_ARCH_STATUS + offset);\n\t\tis_eng_idle = IS_MME_IDLE(mme_arch_sts);\n\n\t\t/* MME 1 & 3 are slaves, no need to check their QMANs */\n\t\tis_slave = i % 2;\n\t\tif (!is_slave) {\n\t\t\tqm_glbl_sts0 = RREG32(mmMME0_QM_GLBL_STS0 + offset);\n\t\t\tqm_cgm_sts = RREG32(mmMME0_QM_CGM_STS + offset);\n\t\t\tis_eng_idle &= IS_QM_IDLE(qm_glbl_sts0, qm_cgm_sts);\n\t\t}\n\n\t\tis_idle &= is_eng_idle;\n\n\t\tif (mask && !is_eng_idle)\n\t\t\tset_bit(GAUDI_ENGINE_ID_MME_0 + i, mask);\n\t\tif (s) {\n\t\t\tif (!is_slave)\n\t\t\t\tseq_printf(s, fmt, i,\n\t\t\t\t\tis_eng_idle ? \"Y\" : \"N\",\n\t\t\t\t\tqm_glbl_sts0, qm_cgm_sts, mme_arch_sts);\n\t\t\telse\n\t\t\t\tseq_printf(s, mme_slave_fmt, i,\n\t\t\t\t\tis_eng_idle ? \"Y\" : \"N\", \"-\",\n\t\t\t\t\t\"-\", mme_arch_sts);\n\t\t}\n\t}\n\n\tif (s)\n\t\tseq_puts(s, \"\\nNIC  is_idle  QM_GLBL_STS0  QM_CGM_STS\\n\"\n\t\t\t\t\"---  -------  ------------  ----------\\n\");\n\n\tfor (i = 0 ; i < (NIC_NUMBER_OF_ENGINES / 2) ; i++) {\n\t\toffset = i * NIC_MACRO_QMAN_OFFSET;\n\t\tport = 2 * i;\n\t\tif (hdev->nic_ports_mask & BIT(port)) {\n\t\t\tqm_glbl_sts0 = RREG32(mmNIC0_QM0_GLBL_STS0 + offset);\n\t\t\tqm_cgm_sts = RREG32(mmNIC0_QM0_CGM_STS + offset);\n\t\t\tis_eng_idle = IS_QM_IDLE(qm_glbl_sts0, qm_cgm_sts);\n\t\t\tis_idle &= is_eng_idle;\n\n\t\t\tif (mask && !is_eng_idle)\n\t\t\t\tset_bit(GAUDI_ENGINE_ID_NIC_0 + port, mask);\n\t\t\tif (s)\n\t\t\t\tseq_printf(s, nic_fmt, port,\n\t\t\t\t\t\tis_eng_idle ? \"Y\" : \"N\",\n\t\t\t\t\t\tqm_glbl_sts0, qm_cgm_sts);\n\t\t}\n\n\t\tport = 2 * i + 1;\n\t\tif (hdev->nic_ports_mask & BIT(port)) {\n\t\t\tqm_glbl_sts0 = RREG32(mmNIC0_QM1_GLBL_STS0 + offset);\n\t\t\tqm_cgm_sts = RREG32(mmNIC0_QM1_CGM_STS + offset);\n\t\t\tis_eng_idle = IS_QM_IDLE(qm_glbl_sts0, qm_cgm_sts);\n\t\t\tis_idle &= is_eng_idle;\n\n\t\t\tif (mask && !is_eng_idle)\n\t\t\t\tset_bit(GAUDI_ENGINE_ID_NIC_0 + port, mask);\n\t\t\tif (s)\n\t\t\t\tseq_printf(s, nic_fmt, port,\n\t\t\t\t\t\tis_eng_idle ? \"Y\" : \"N\",\n\t\t\t\t\t\tqm_glbl_sts0, qm_cgm_sts);\n\t\t}\n\t}\n\n\tif (s)\n\t\tseq_puts(s, \"\\n\");\n\n\thdev->asic_funcs->set_clock_gating(hdev);\n\n\tmutex_unlock(&gaudi->clk_gate_mutex);\n\n\treturn is_idle;\n}\n\nstatic void gaudi_hw_queues_lock(struct hl_device *hdev)\n\t__acquires(&gaudi->hw_queues_lock)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tspin_lock(&gaudi->hw_queues_lock);\n}\n\nstatic void gaudi_hw_queues_unlock(struct hl_device *hdev)\n\t__releases(&gaudi->hw_queues_lock)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tspin_unlock(&gaudi->hw_queues_lock);\n}\n\nstatic u32 gaudi_get_pci_id(struct hl_device *hdev)\n{\n\treturn hdev->pdev->device;\n}\n\nstatic int gaudi_get_eeprom_data(struct hl_device *hdev, void *data,\n\t\t\t\tsize_t max_size)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_CPU_Q))\n\t\treturn 0;\n\n\treturn hl_fw_get_eeprom_data(hdev, data, max_size);\n}\n\n/*\n * this function should be used only during initialization and/or after reset,\n * when there are no active users.\n */\nstatic int gaudi_run_tpc_kernel(struct hl_device *hdev, u64 tpc_kernel,\n\t\t\t\tu32 tpc_id)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tu64 kernel_timeout;\n\tu32 status, offset;\n\tint rc;\n\n\toffset = tpc_id * (mmTPC1_CFG_STATUS - mmTPC0_CFG_STATUS);\n\n\tif (hdev->pldm)\n\t\tkernel_timeout = GAUDI_PLDM_TPC_KERNEL_WAIT_USEC;\n\telse\n\t\tkernel_timeout = HL_DEVICE_TIMEOUT_USEC;\n\n\tmutex_lock(&gaudi->clk_gate_mutex);\n\n\thdev->asic_funcs->disable_clock_gating(hdev);\n\n\tWREG32(mmTPC0_CFG_QM_KERNEL_BASE_ADDRESS_LOW + offset,\n\t\t\tlower_32_bits(tpc_kernel));\n\tWREG32(mmTPC0_CFG_QM_KERNEL_BASE_ADDRESS_HIGH + offset,\n\t\t\tupper_32_bits(tpc_kernel));\n\n\tWREG32(mmTPC0_CFG_ICACHE_BASE_ADDERESS_LOW + offset,\n\t\t\tlower_32_bits(tpc_kernel));\n\tWREG32(mmTPC0_CFG_ICACHE_BASE_ADDERESS_HIGH + offset,\n\t\t\tupper_32_bits(tpc_kernel));\n\t/* set a valid LUT pointer, content is of no significance */\n\tWREG32(mmTPC0_CFG_LUT_FUNC256_BASE_ADDR_LO + offset,\n\t\t\tlower_32_bits(tpc_kernel));\n\tWREG32(mmTPC0_CFG_LUT_FUNC256_BASE_ADDR_HI + offset,\n\t\t\tupper_32_bits(tpc_kernel));\n\n\tWREG32(mmTPC0_CFG_QM_SYNC_OBJECT_ADDR + offset,\n\t\t\tlower_32_bits(CFG_BASE +\n\t\t\t\tmmSYNC_MNGR_E_N_SYNC_MNGR_OBJS_SOB_OBJ_0));\n\n\tWREG32(mmTPC0_CFG_TPC_CMD + offset,\n\t\t\t(1 << TPC0_CFG_TPC_CMD_ICACHE_INVALIDATE_SHIFT |\n\t\t\t1 << TPC0_CFG_TPC_CMD_ICACHE_PREFETCH_64KB_SHIFT));\n\t/* wait a bit for the engine to start executing */\n\tusleep_range(1000, 1500);\n\n\t/* wait until engine has finished executing */\n\trc = hl_poll_timeout(\n\t\thdev,\n\t\tmmTPC0_CFG_STATUS + offset,\n\t\tstatus,\n\t\t(status & TPC0_CFG_STATUS_VECTOR_PIPE_EMPTY_MASK) ==\n\t\t\t\tTPC0_CFG_STATUS_VECTOR_PIPE_EMPTY_MASK,\n\t\t1000,\n\t\tkernel_timeout);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Timeout while waiting for TPC%d icache prefetch\\n\",\n\t\t\ttpc_id);\n\t\thdev->asic_funcs->set_clock_gating(hdev);\n\t\tmutex_unlock(&gaudi->clk_gate_mutex);\n\t\treturn -EIO;\n\t}\n\n\tWREG32(mmTPC0_CFG_TPC_EXECUTE + offset,\n\t\t\t1 << TPC0_CFG_TPC_EXECUTE_V_SHIFT);\n\n\t/* wait a bit for the engine to start executing */\n\tusleep_range(1000, 1500);\n\n\t/* wait until engine has finished executing */\n\trc = hl_poll_timeout(\n\t\thdev,\n\t\tmmTPC0_CFG_STATUS + offset,\n\t\tstatus,\n\t\t(status & TPC0_CFG_STATUS_VECTOR_PIPE_EMPTY_MASK) ==\n\t\t\t\tTPC0_CFG_STATUS_VECTOR_PIPE_EMPTY_MASK,\n\t\t1000,\n\t\tkernel_timeout);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Timeout while waiting for TPC%d vector pipe\\n\",\n\t\t\ttpc_id);\n\t\thdev->asic_funcs->set_clock_gating(hdev);\n\t\tmutex_unlock(&gaudi->clk_gate_mutex);\n\t\treturn -EIO;\n\t}\n\n\trc = hl_poll_timeout(\n\t\thdev,\n\t\tmmTPC0_CFG_WQ_INFLIGHT_CNTR + offset,\n\t\tstatus,\n\t\t(status == 0),\n\t\t1000,\n\t\tkernel_timeout);\n\n\thdev->asic_funcs->set_clock_gating(hdev);\n\tmutex_unlock(&gaudi->clk_gate_mutex);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Timeout while waiting for TPC%d kernel to execute\\n\",\n\t\t\ttpc_id);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int gaudi_internal_cb_pool_init(struct hl_device *hdev,\n\t\tstruct hl_ctx *ctx)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\tint min_alloc_order, rc, collective_cb_size;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_MMU))\n\t\treturn 0;\n\n\thdev->internal_cb_pool_virt_addr =\n\t\t\thdev->asic_funcs->asic_dma_alloc_coherent(hdev,\n\t\t\t\t\tHOST_SPACE_INTERNAL_CB_SZ,\n\t\t\t\t\t&hdev->internal_cb_pool_dma_addr,\n\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\n\tif (!hdev->internal_cb_pool_virt_addr)\n\t\treturn -ENOMEM;\n\n\tcollective_cb_size = sizeof(struct packet_msg_short) * 5 +\n\t\t\tsizeof(struct packet_fence);\n\tmin_alloc_order = ilog2(collective_cb_size);\n\n\thdev->internal_cb_pool = gen_pool_create(min_alloc_order, -1);\n\tif (!hdev->internal_cb_pool) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to create internal CB pool\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto free_internal_cb_pool;\n\t}\n\n\trc = gen_pool_add(hdev->internal_cb_pool,\n\t\t\t\t(uintptr_t) hdev->internal_cb_pool_virt_addr,\n\t\t\t\tHOST_SPACE_INTERNAL_CB_SZ, -1);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to add memory to internal CB pool\\n\");\n\t\trc = -EFAULT;\n\t\tgoto destroy_internal_cb_pool;\n\t}\n\n\thdev->internal_cb_va_base = hl_reserve_va_block(hdev, ctx,\n\t\t\tHL_VA_RANGE_TYPE_HOST, HOST_SPACE_INTERNAL_CB_SZ,\n\t\t\tHL_MMU_VA_ALIGNMENT_NOT_NEEDED);\n\n\tif (!hdev->internal_cb_va_base)\n\t\tgoto destroy_internal_cb_pool;\n\n\tmutex_lock(&ctx->mmu_lock);\n\trc = hl_mmu_map_contiguous(ctx, hdev->internal_cb_va_base,\n\t\t\thdev->internal_cb_pool_dma_addr,\n\t\t\tHOST_SPACE_INTERNAL_CB_SZ);\n\n\thdev->asic_funcs->mmu_invalidate_cache(hdev, false, VM_TYPE_USERPTR);\n\tmutex_unlock(&ctx->mmu_lock);\n\n\tif (rc)\n\t\tgoto unreserve_internal_cb_pool;\n\n\treturn 0;\n\nunreserve_internal_cb_pool:\n\thl_unreserve_va_block(hdev, ctx, hdev->internal_cb_va_base,\n\t\t\tHOST_SPACE_INTERNAL_CB_SZ);\ndestroy_internal_cb_pool:\n\tgen_pool_destroy(hdev->internal_cb_pool);\nfree_internal_cb_pool:\n\thdev->asic_funcs->asic_dma_free_coherent(hdev,\n\t\t\tHOST_SPACE_INTERNAL_CB_SZ,\n\t\t\thdev->internal_cb_pool_virt_addr,\n\t\t\thdev->internal_cb_pool_dma_addr);\n\n\treturn rc;\n}\n\nstatic void gaudi_internal_cb_pool_fini(struct hl_device *hdev,\n\t\tstruct hl_ctx *ctx)\n{\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_MMU))\n\t\treturn;\n\n\tmutex_lock(&ctx->mmu_lock);\n\thl_mmu_unmap_contiguous(ctx, hdev->internal_cb_va_base,\n\t\t\tHOST_SPACE_INTERNAL_CB_SZ);\n\thl_unreserve_va_block(hdev, ctx, hdev->internal_cb_va_base,\n\t\t\tHOST_SPACE_INTERNAL_CB_SZ);\n\thdev->asic_funcs->mmu_invalidate_cache(hdev, true, VM_TYPE_USERPTR);\n\tmutex_unlock(&ctx->mmu_lock);\n\n\tgen_pool_destroy(hdev->internal_cb_pool);\n\n\thdev->asic_funcs->asic_dma_free_coherent(hdev,\n\t\t\tHOST_SPACE_INTERNAL_CB_SZ,\n\t\t\thdev->internal_cb_pool_virt_addr,\n\t\t\thdev->internal_cb_pool_dma_addr);\n}\n\nstatic int gaudi_ctx_init(struct hl_ctx *ctx)\n{\n\tif (ctx->asid == HL_KERNEL_ASID_ID)\n\t\treturn 0;\n\n\tgaudi_mmu_prepare(ctx->hdev, ctx->asid);\n\treturn gaudi_internal_cb_pool_init(ctx->hdev, ctx);\n}\n\nstatic void gaudi_ctx_fini(struct hl_ctx *ctx)\n{\n\tif (ctx->asid == HL_KERNEL_ASID_ID)\n\t\treturn;\n\n\tgaudi_internal_cb_pool_fini(ctx->hdev, ctx);\n}\n\nstatic u32 gaudi_get_queue_id_for_cq(struct hl_device *hdev, u32 cq_idx)\n{\n\treturn gaudi_cq_assignment[cq_idx];\n}\n\nstatic u32 gaudi_get_signal_cb_size(struct hl_device *hdev)\n{\n\treturn sizeof(struct packet_msg_short) +\n\t\t\tsizeof(struct packet_msg_prot) * 2;\n}\n\nstatic u32 gaudi_get_wait_cb_size(struct hl_device *hdev)\n{\n\treturn sizeof(struct packet_msg_short) * 4 +\n\t\t\tsizeof(struct packet_fence) +\n\t\t\tsizeof(struct packet_msg_prot) * 2;\n}\n\nstatic u32 gaudi_gen_signal_cb(struct hl_device *hdev, void *data, u16 sob_id,\n\t\t\t\tu32 size, bool eb)\n{\n\tstruct hl_cb *cb = (struct hl_cb *) data;\n\tstruct packet_msg_short *pkt;\n\tu32 value, ctl, pkt_size = sizeof(*pkt);\n\n\tpkt = cb->kernel_address + size;\n\tmemset(pkt, 0, pkt_size);\n\n\t/* Inc by 1, Mode ADD */\n\tvalue = FIELD_PREP(GAUDI_PKT_SHORT_VAL_SOB_SYNC_VAL_MASK, 1);\n\tvalue |= FIELD_PREP(GAUDI_PKT_SHORT_VAL_SOB_MOD_MASK, 1);\n\n\tctl = FIELD_PREP(GAUDI_PKT_SHORT_CTL_ADDR_MASK, sob_id * 4);\n\tctl |= FIELD_PREP(GAUDI_PKT_SHORT_CTL_OP_MASK, 0); /* write the value */\n\tctl |= FIELD_PREP(GAUDI_PKT_SHORT_CTL_BASE_MASK, 3); /* W_S SOB base */\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_OPCODE_MASK, PACKET_MSG_SHORT);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_EB_MASK, eb);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_RB_MASK, 1);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_MB_MASK, 1);\n\n\tpkt->value = cpu_to_le32(value);\n\tpkt->ctl = cpu_to_le32(ctl);\n\n\treturn size + pkt_size;\n}\n\nstatic u32 gaudi_add_mon_msg_short(struct packet_msg_short *pkt, u32 value,\n\t\t\t\t\tu16 addr)\n{\n\tu32 ctl, pkt_size = sizeof(*pkt);\n\n\tmemset(pkt, 0, pkt_size);\n\n\tctl = FIELD_PREP(GAUDI_PKT_SHORT_CTL_ADDR_MASK, addr);\n\tctl |= FIELD_PREP(GAUDI_PKT_SHORT_CTL_BASE_MASK, 2);  /* W_S MON base */\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_OPCODE_MASK, PACKET_MSG_SHORT);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_EB_MASK, 0);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_RB_MASK, 1);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_MB_MASK, 0); /* last pkt MB */\n\n\tpkt->value = cpu_to_le32(value);\n\tpkt->ctl = cpu_to_le32(ctl);\n\n\treturn pkt_size;\n}\n\nstatic u32 gaudi_add_arm_monitor_pkt(struct hl_device *hdev,\n\t\tstruct packet_msg_short *pkt, u16 sob_base, u8 sob_mask,\n\t\tu16 sob_val, u16 mon_id)\n{\n\tu64 monitor_base;\n\tu32 ctl, value, pkt_size = sizeof(*pkt);\n\tu16 msg_addr_offset;\n\tu8 mask;\n\n\tif (hl_gen_sob_mask(sob_base, sob_mask, &mask)) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"sob_base %u (mask %#x) is not valid\\n\",\n\t\t\tsob_base, sob_mask);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * monitor_base should be the content of the base0 address registers,\n\t * so it will be added to the msg short offsets\n\t */\n\tmonitor_base = mmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0;\n\n\tmsg_addr_offset =\n\t\t(mmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_MON_ARM_0 + mon_id * 4) -\n\t\t\t\tmonitor_base;\n\n\tmemset(pkt, 0, pkt_size);\n\n\t/* Monitor config packet: bind the monitor to a sync object */\n\tvalue = FIELD_PREP(GAUDI_PKT_SHORT_VAL_MON_SYNC_GID_MASK, sob_base / 8);\n\tvalue |= FIELD_PREP(GAUDI_PKT_SHORT_VAL_MON_SYNC_VAL_MASK, sob_val);\n\tvalue |= FIELD_PREP(GAUDI_PKT_SHORT_VAL_MON_MODE_MASK,\n\t\t\t0); /* GREATER OR EQUAL*/\n\tvalue |= FIELD_PREP(GAUDI_PKT_SHORT_VAL_MON_MASK_MASK, mask);\n\n\tctl = FIELD_PREP(GAUDI_PKT_SHORT_CTL_ADDR_MASK, msg_addr_offset);\n\tctl |= FIELD_PREP(GAUDI_PKT_SHORT_CTL_OP_MASK, 0); /* write the value */\n\tctl |= FIELD_PREP(GAUDI_PKT_SHORT_CTL_BASE_MASK, 2); /* W_S MON base */\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_OPCODE_MASK, PACKET_MSG_SHORT);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_EB_MASK, 0);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_RB_MASK, 1);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_MB_MASK, 1);\n\n\tpkt->value = cpu_to_le32(value);\n\tpkt->ctl = cpu_to_le32(ctl);\n\n\treturn pkt_size;\n}\n\nstatic u32 gaudi_add_fence_pkt(struct packet_fence *pkt)\n{\n\tu32 ctl, cfg, pkt_size = sizeof(*pkt);\n\n\tmemset(pkt, 0, pkt_size);\n\n\tcfg = FIELD_PREP(GAUDI_PKT_FENCE_CFG_DEC_VAL_MASK, 1);\n\tcfg |= FIELD_PREP(GAUDI_PKT_FENCE_CFG_TARGET_VAL_MASK, 1);\n\tcfg |= FIELD_PREP(GAUDI_PKT_FENCE_CFG_ID_MASK, 2);\n\n\tctl = FIELD_PREP(GAUDI_PKT_CTL_OPCODE_MASK, PACKET_FENCE);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_EB_MASK, 0);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_RB_MASK, 1);\n\tctl |= FIELD_PREP(GAUDI_PKT_CTL_MB_MASK, 1);\n\n\tpkt->cfg = cpu_to_le32(cfg);\n\tpkt->ctl = cpu_to_le32(ctl);\n\n\treturn pkt_size;\n}\n\nstatic int gaudi_get_fence_addr(struct hl_device *hdev, u32 queue_id, u64 *addr)\n{\n\tu32 offset, nic_index;\n\n\tswitch (queue_id) {\n\tcase GAUDI_QUEUE_ID_DMA_0_0:\n\t\toffset = mmDMA0_QM_CP_FENCE2_RDATA_0;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_DMA_0_1:\n\t\toffset = mmDMA0_QM_CP_FENCE2_RDATA_1;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_DMA_0_2:\n\t\toffset = mmDMA0_QM_CP_FENCE2_RDATA_2;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_DMA_0_3:\n\t\toffset = mmDMA0_QM_CP_FENCE2_RDATA_3;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_DMA_1_0:\n\t\toffset = mmDMA1_QM_CP_FENCE2_RDATA_0;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_DMA_1_1:\n\t\toffset = mmDMA1_QM_CP_FENCE2_RDATA_1;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_DMA_1_2:\n\t\toffset = mmDMA1_QM_CP_FENCE2_RDATA_2;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_DMA_1_3:\n\t\toffset = mmDMA1_QM_CP_FENCE2_RDATA_3;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_DMA_5_0:\n\t\toffset = mmDMA5_QM_CP_FENCE2_RDATA_0;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_DMA_5_1:\n\t\toffset = mmDMA5_QM_CP_FENCE2_RDATA_1;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_DMA_5_2:\n\t\toffset = mmDMA5_QM_CP_FENCE2_RDATA_2;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_DMA_5_3:\n\t\toffset = mmDMA5_QM_CP_FENCE2_RDATA_3;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_TPC_7_0:\n\t\toffset = mmTPC7_QM_CP_FENCE2_RDATA_0;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_TPC_7_1:\n\t\toffset = mmTPC7_QM_CP_FENCE2_RDATA_1;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_TPC_7_2:\n\t\toffset = mmTPC7_QM_CP_FENCE2_RDATA_2;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_TPC_7_3:\n\t\toffset = mmTPC7_QM_CP_FENCE2_RDATA_3;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_NIC_0_0:\n\tcase GAUDI_QUEUE_ID_NIC_1_0:\n\tcase GAUDI_QUEUE_ID_NIC_2_0:\n\tcase GAUDI_QUEUE_ID_NIC_3_0:\n\tcase GAUDI_QUEUE_ID_NIC_4_0:\n\tcase GAUDI_QUEUE_ID_NIC_5_0:\n\tcase GAUDI_QUEUE_ID_NIC_6_0:\n\tcase GAUDI_QUEUE_ID_NIC_7_0:\n\tcase GAUDI_QUEUE_ID_NIC_8_0:\n\tcase GAUDI_QUEUE_ID_NIC_9_0:\n\t\tnic_index = (queue_id - GAUDI_QUEUE_ID_NIC_0_0) >> 2;\n\t\toffset = mmNIC0_QM0_CP_FENCE2_RDATA_0 +\n\t\t\t\t(nic_index >> 1) * NIC_MACRO_QMAN_OFFSET +\n\t\t\t\t(nic_index & 0x1) * NIC_ENGINE_QMAN_OFFSET;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_NIC_0_1:\n\tcase GAUDI_QUEUE_ID_NIC_1_1:\n\tcase GAUDI_QUEUE_ID_NIC_2_1:\n\tcase GAUDI_QUEUE_ID_NIC_3_1:\n\tcase GAUDI_QUEUE_ID_NIC_4_1:\n\tcase GAUDI_QUEUE_ID_NIC_5_1:\n\tcase GAUDI_QUEUE_ID_NIC_6_1:\n\tcase GAUDI_QUEUE_ID_NIC_7_1:\n\tcase GAUDI_QUEUE_ID_NIC_8_1:\n\tcase GAUDI_QUEUE_ID_NIC_9_1:\n\t\tnic_index = (queue_id - GAUDI_QUEUE_ID_NIC_0_1) >> 2;\n\t\toffset = mmNIC0_QM0_CP_FENCE2_RDATA_1 +\n\t\t\t\t(nic_index >> 1) * NIC_MACRO_QMAN_OFFSET +\n\t\t\t\t(nic_index & 0x1) * NIC_ENGINE_QMAN_OFFSET;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_NIC_0_2:\n\tcase GAUDI_QUEUE_ID_NIC_1_2:\n\tcase GAUDI_QUEUE_ID_NIC_2_2:\n\tcase GAUDI_QUEUE_ID_NIC_3_2:\n\tcase GAUDI_QUEUE_ID_NIC_4_2:\n\tcase GAUDI_QUEUE_ID_NIC_5_2:\n\tcase GAUDI_QUEUE_ID_NIC_6_2:\n\tcase GAUDI_QUEUE_ID_NIC_7_2:\n\tcase GAUDI_QUEUE_ID_NIC_8_2:\n\tcase GAUDI_QUEUE_ID_NIC_9_2:\n\t\tnic_index = (queue_id - GAUDI_QUEUE_ID_NIC_0_2) >> 2;\n\t\toffset = mmNIC0_QM0_CP_FENCE2_RDATA_2 +\n\t\t\t\t(nic_index >> 1) * NIC_MACRO_QMAN_OFFSET +\n\t\t\t\t(nic_index & 0x1) * NIC_ENGINE_QMAN_OFFSET;\n\t\tbreak;\n\tcase GAUDI_QUEUE_ID_NIC_0_3:\n\tcase GAUDI_QUEUE_ID_NIC_1_3:\n\tcase GAUDI_QUEUE_ID_NIC_2_3:\n\tcase GAUDI_QUEUE_ID_NIC_3_3:\n\tcase GAUDI_QUEUE_ID_NIC_4_3:\n\tcase GAUDI_QUEUE_ID_NIC_5_3:\n\tcase GAUDI_QUEUE_ID_NIC_6_3:\n\tcase GAUDI_QUEUE_ID_NIC_7_3:\n\tcase GAUDI_QUEUE_ID_NIC_8_3:\n\tcase GAUDI_QUEUE_ID_NIC_9_3:\n\t\tnic_index = (queue_id - GAUDI_QUEUE_ID_NIC_0_3) >> 2;\n\t\toffset = mmNIC0_QM0_CP_FENCE2_RDATA_3 +\n\t\t\t\t(nic_index >> 1) * NIC_MACRO_QMAN_OFFSET +\n\t\t\t\t(nic_index & 0x1) * NIC_ENGINE_QMAN_OFFSET;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*addr = CFG_BASE + offset;\n\n\treturn 0;\n}\n\nstatic u32 gaudi_add_mon_pkts(void *buf, u16 mon_id, u64 fence_addr)\n{\n\tu64 monitor_base;\n\tu32 size = 0;\n\tu16 msg_addr_offset;\n\n\t/*\n\t * monitor_base should be the content of the base0 address registers,\n\t * so it will be added to the msg short offsets\n\t */\n\tmonitor_base = mmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0;\n\n\t/* First monitor config packet: low address of the sync */\n\tmsg_addr_offset =\n\t\t(mmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_MON_PAY_ADDRL_0 + mon_id * 4) -\n\t\t\t\tmonitor_base;\n\n\tsize += gaudi_add_mon_msg_short(buf + size, (u32) fence_addr,\n\t\t\t\t\tmsg_addr_offset);\n\n\t/* Second monitor config packet: high address of the sync */\n\tmsg_addr_offset =\n\t\t(mmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_MON_PAY_ADDRH_0 + mon_id * 4) -\n\t\t\t\tmonitor_base;\n\n\tsize += gaudi_add_mon_msg_short(buf + size, (u32) (fence_addr >> 32),\n\t\t\t\t\tmsg_addr_offset);\n\n\t/*\n\t * Third monitor config packet: the payload, i.e. what to write when the\n\t * sync triggers\n\t */\n\tmsg_addr_offset =\n\t\t(mmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_MON_PAY_DATA_0 + mon_id * 4) -\n\t\t\t\tmonitor_base;\n\n\tsize += gaudi_add_mon_msg_short(buf + size, 1, msg_addr_offset);\n\n\treturn size;\n}\n\nstatic u32 gaudi_gen_wait_cb(struct hl_device *hdev,\n\t\t\t\tstruct hl_gen_wait_properties *prop)\n{\n\tstruct hl_cb *cb = (struct hl_cb *) prop->data;\n\tvoid *buf = cb->kernel_address;\n\tu64 fence_addr = 0;\n\tu32 size = prop->size;\n\n\tif (gaudi_get_fence_addr(hdev, prop->q_idx, &fence_addr)) {\n\t\tdev_crit(hdev->dev, \"wrong queue id %d for wait packet\\n\",\n\t\t\t\tprop->q_idx);\n\t\treturn 0;\n\t}\n\n\tsize += gaudi_add_mon_pkts(buf + size, prop->mon_id, fence_addr);\n\tsize += gaudi_add_arm_monitor_pkt(hdev, buf + size, prop->sob_base,\n\t\t\tprop->sob_mask, prop->sob_val, prop->mon_id);\n\tsize += gaudi_add_fence_pkt(buf + size);\n\n\treturn size;\n}\n\nstatic void gaudi_reset_sob(struct hl_device *hdev, void *data)\n{\n\tstruct hl_hw_sob *hw_sob = (struct hl_hw_sob *) data;\n\tint rc;\n\n\tdev_dbg(hdev->dev, \"reset SOB, q_idx: %d, sob_id: %d\\n\", hw_sob->q_idx,\n\t\thw_sob->sob_id);\n\n\trc = gaudi_schedule_register_memset(hdev, hw_sob->q_idx,\n\t\t\tCFG_BASE + mmSYNC_MNGR_W_S_SYNC_MNGR_OBJS_SOB_OBJ_0 +\n\t\t\thw_sob->sob_id * 4, 1, 0);\n\tif (rc)\n\t\tdev_err(hdev->dev, \"failed resetting sob %u\", hw_sob->sob_id);\n\n\tkref_init(&hw_sob->kref);\n}\n\nstatic void gaudi_set_dma_mask_from_fw(struct hl_device *hdev)\n{\n\tif (RREG32(mmPSOC_GLOBAL_CONF_NON_RST_FLOPS_0) ==\n\t\t\t\t\t\t\tHL_POWER9_HOST_MAGIC) {\n\t\thdev->power9_64bit_dma_enable = 1;\n\t\thdev->dma_mask = 64;\n\t} else {\n\t\thdev->power9_64bit_dma_enable = 0;\n\t\thdev->dma_mask = 48;\n\t}\n}\n\nstatic u64 gaudi_get_device_time(struct hl_device *hdev)\n{\n\tu64 device_time = ((u64) RREG32(mmPSOC_TIMESTAMP_CNTCVU)) << 32;\n\n\treturn device_time | RREG32(mmPSOC_TIMESTAMP_CNTCVL);\n}\n\nstatic int gaudi_get_hw_block_id(struct hl_device *hdev, u64 block_addr,\n\t\t\t\tu32 *block_size, u32 *block_id)\n{\n\treturn -EPERM;\n}\n\nstatic int gaudi_block_mmap(struct hl_device *hdev,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tu32 block_id, u32 block_size)\n{\n\treturn -EPERM;\n}\n\nstatic void gaudi_enable_events_from_fw(struct hl_device *hdev)\n{\n\tWREG32(mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR, GAUDI_EVENT_INTS_REGISTER);\n}\n\nstatic const struct hl_asic_funcs gaudi_funcs = {\n\t.early_init = gaudi_early_init,\n\t.early_fini = gaudi_early_fini,\n\t.late_init = gaudi_late_init,\n\t.late_fini = gaudi_late_fini,\n\t.sw_init = gaudi_sw_init,\n\t.sw_fini = gaudi_sw_fini,\n\t.hw_init = gaudi_hw_init,\n\t.hw_fini = gaudi_hw_fini,\n\t.halt_engines = gaudi_halt_engines,\n\t.suspend = gaudi_suspend,\n\t.resume = gaudi_resume,\n\t.cb_mmap = gaudi_cb_mmap,\n\t.ring_doorbell = gaudi_ring_doorbell,\n\t.pqe_write = gaudi_pqe_write,\n\t.asic_dma_alloc_coherent = gaudi_dma_alloc_coherent,\n\t.asic_dma_free_coherent = gaudi_dma_free_coherent,\n\t.scrub_device_mem = gaudi_scrub_device_mem,\n\t.get_int_queue_base = gaudi_get_int_queue_base,\n\t.test_queues = gaudi_test_queues,\n\t.asic_dma_pool_zalloc = gaudi_dma_pool_zalloc,\n\t.asic_dma_pool_free = gaudi_dma_pool_free,\n\t.cpu_accessible_dma_pool_alloc = gaudi_cpu_accessible_dma_pool_alloc,\n\t.cpu_accessible_dma_pool_free = gaudi_cpu_accessible_dma_pool_free,\n\t.hl_dma_unmap_sg = gaudi_dma_unmap_sg,\n\t.cs_parser = gaudi_cs_parser,\n\t.asic_dma_map_sg = gaudi_dma_map_sg,\n\t.get_dma_desc_list_size = gaudi_get_dma_desc_list_size,\n\t.add_end_of_cb_packets = gaudi_add_end_of_cb_packets,\n\t.update_eq_ci = gaudi_update_eq_ci,\n\t.context_switch = gaudi_context_switch,\n\t.restore_phase_topology = gaudi_restore_phase_topology,\n\t.debugfs_read32 = gaudi_debugfs_read32,\n\t.debugfs_write32 = gaudi_debugfs_write32,\n\t.debugfs_read64 = gaudi_debugfs_read64,\n\t.debugfs_write64 = gaudi_debugfs_write64,\n\t.add_device_attr = gaudi_add_device_attr,\n\t.handle_eqe = gaudi_handle_eqe,\n\t.set_pll_profile = gaudi_set_pll_profile,\n\t.get_events_stat = gaudi_get_events_stat,\n\t.read_pte = gaudi_read_pte,\n\t.write_pte = gaudi_write_pte,\n\t.mmu_invalidate_cache = gaudi_mmu_invalidate_cache,\n\t.mmu_invalidate_cache_range = gaudi_mmu_invalidate_cache_range,\n\t.send_heartbeat = gaudi_send_heartbeat,\n\t.set_clock_gating = gaudi_set_clock_gating,\n\t.disable_clock_gating = gaudi_disable_clock_gating,\n\t.debug_coresight = gaudi_debug_coresight,\n\t.is_device_idle = gaudi_is_device_idle,\n\t.soft_reset_late_init = gaudi_soft_reset_late_init,\n\t.hw_queues_lock = gaudi_hw_queues_lock,\n\t.hw_queues_unlock = gaudi_hw_queues_unlock,\n\t.get_pci_id = gaudi_get_pci_id,\n\t.get_eeprom_data = gaudi_get_eeprom_data,\n\t.send_cpu_message = gaudi_send_cpu_message,\n\t.pci_bars_map = gaudi_pci_bars_map,\n\t.init_iatu = gaudi_init_iatu,\n\t.rreg = hl_rreg,\n\t.wreg = hl_wreg,\n\t.halt_coresight = gaudi_halt_coresight,\n\t.ctx_init = gaudi_ctx_init,\n\t.ctx_fini = gaudi_ctx_fini,\n\t.get_clk_rate = gaudi_get_clk_rate,\n\t.get_queue_id_for_cq = gaudi_get_queue_id_for_cq,\n\t.read_device_fw_version = gaudi_read_device_fw_version,\n\t.load_firmware_to_device = gaudi_load_firmware_to_device,\n\t.load_boot_fit_to_device = gaudi_load_boot_fit_to_device,\n\t.get_signal_cb_size = gaudi_get_signal_cb_size,\n\t.get_wait_cb_size = gaudi_get_wait_cb_size,\n\t.gen_signal_cb = gaudi_gen_signal_cb,\n\t.gen_wait_cb = gaudi_gen_wait_cb,\n\t.reset_sob = gaudi_reset_sob,\n\t.reset_sob_group = gaudi_reset_sob_group,\n\t.set_dma_mask_from_fw = gaudi_set_dma_mask_from_fw,\n\t.get_device_time = gaudi_get_device_time,\n\t.collective_wait_init_cs = gaudi_collective_wait_init_cs,\n\t.collective_wait_create_jobs = gaudi_collective_wait_create_jobs,\n\t.scramble_addr = hl_mmu_scramble_addr,\n\t.descramble_addr = hl_mmu_descramble_addr,\n\t.ack_protection_bits_errors = gaudi_ack_protection_bits_errors,\n\t.get_hw_block_id = gaudi_get_hw_block_id,\n\t.hw_block_mmap = gaudi_block_mmap,\n\t.enable_events_from_fw = gaudi_enable_events_from_fw\n};\n\n/**\n * gaudi_set_asic_funcs - set GAUDI function pointers\n *\n * @hdev: pointer to hl_device structure\n *\n */\nvoid gaudi_set_asic_funcs(struct hl_device *hdev)\n{\n\thdev->asic_funcs = &gaudi_funcs;\n}\n"}}, "reports": [{"events": [{"location": {"col": 1, "file": 0, "line": 6819}, "message": "preceding lock on line 6771"}], "macros": [], "notes": [], "path": "/src/drivers/misc/habanalabs/gaudi/gaudi.c", "reportHash": "797f74f3dd693ca8696d8af587db32d2", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
