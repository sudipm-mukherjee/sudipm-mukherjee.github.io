<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/scsi/smartpqi/smartpqi_init.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n *    driver for Microsemi PQI-based storage controllers\n *    Copyright (c) 2019-2020 Microchip Technology Inc. and its subsidiaries\n *    Copyright (c) 2016-2018 Microsemi Corporation\n *    Copyright (c) 2016 PMC-Sierra, Inc.\n *\n *    Questions/Comments/Bugfixes to storagedev@microchip.com\n *\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/rtc.h>\n#include <linux/bcd.h>\n#include <linux/reboot.h>\n#include <linux/cciss_ioctl.h>\n#include <linux/blk-mq-pci.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_transport_sas.h>\n#include <asm/unaligned.h>\n#include \"smartpqi.h\"\n#include \"smartpqi_sis.h\"\n\n#if !defined(BUILD_TIMESTAMP)\n#define BUILD_TIMESTAMP\n#endif\n\n#define DRIVER_VERSION\t\t\"1.2.16-012\"\n#define DRIVER_MAJOR\t\t1\n#define DRIVER_MINOR\t\t2\n#define DRIVER_RELEASE\t\t16\n#define DRIVER_REVISION\t\t12\n\n#define DRIVER_NAME\t\t\"Microsemi PQI Driver (v\" \\\n\t\t\t\tDRIVER_VERSION BUILD_TIMESTAMP \")\"\n#define DRIVER_NAME_SHORT\t\"smartpqi\"\n\n#define PQI_EXTRA_SGL_MEMORY\t(12 * sizeof(struct pqi_sg_descriptor))\n\nMODULE_AUTHOR(\"Microsemi\");\nMODULE_DESCRIPTION(\"Driver for Microsemi Smart Family Controller version \"\n\tDRIVER_VERSION);\nMODULE_VERSION(DRIVER_VERSION);\nMODULE_LICENSE(\"GPL\");\n\nstatic void pqi_take_ctrl_offline(struct pqi_ctrl_info *ctrl_info);\nstatic void pqi_ctrl_offline_worker(struct work_struct *work);\nstatic void pqi_retry_raid_bypass_requests(struct pqi_ctrl_info *ctrl_info);\nstatic int pqi_scan_scsi_devices(struct pqi_ctrl_info *ctrl_info);\nstatic void pqi_scan_start(struct Scsi_Host *shost);\nstatic void pqi_start_io(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_queue_group *queue_group, enum pqi_io_path path,\n\tstruct pqi_io_request *io_request);\nstatic int pqi_submit_raid_request_synchronous(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_iu_header *request, unsigned int flags,\n\tstruct pqi_raid_error_info *error_info, unsigned long timeout_msecs);\nstatic int pqi_aio_submit_io(struct pqi_ctrl_info *ctrl_info,\n\tstruct scsi_cmnd *scmd, u32 aio_handle, u8 *cdb,\n\tunsigned int cdb_length, struct pqi_queue_group *queue_group,\n\tstruct pqi_encryption_info *encryption_info, bool raid_bypass);\nstatic void pqi_ofa_ctrl_quiesce(struct pqi_ctrl_info *ctrl_info);\nstatic void pqi_ofa_ctrl_unquiesce(struct pqi_ctrl_info *ctrl_info);\nstatic int pqi_ofa_ctrl_restart(struct pqi_ctrl_info *ctrl_info);\nstatic void pqi_ofa_setup_host_buffer(struct pqi_ctrl_info *ctrl_info,\n\tu32 bytes_requested);\nstatic void pqi_ofa_free_host_buffer(struct pqi_ctrl_info *ctrl_info);\nstatic int pqi_ofa_host_memory_update(struct pqi_ctrl_info *ctrl_info);\nstatic int pqi_device_wait_for_pending_io(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device, unsigned long timeout_secs);\n\n/* for flags argument to pqi_submit_raid_request_synchronous() */\n#define PQI_SYNC_FLAGS_INTERRUPTABLE\t0x1\n\nstatic struct scsi_transport_template *pqi_sas_transport_template;\n\nstatic atomic_t pqi_controller_count = ATOMIC_INIT(0);\n\nenum pqi_lockup_action {\n\tNONE,\n\tREBOOT,\n\tPANIC\n};\n\nstatic enum pqi_lockup_action pqi_lockup_action = NONE;\n\nstatic struct {\n\tenum pqi_lockup_action\taction;\n\tchar\t\t\t*name;\n} pqi_lockup_actions[] = {\n\t{\n\t\t.action = NONE,\n\t\t.name = \"none\",\n\t},\n\t{\n\t\t.action = REBOOT,\n\t\t.name = \"reboot\",\n\t},\n\t{\n\t\t.action = PANIC,\n\t\t.name = \"panic\",\n\t},\n};\n\nstatic unsigned int pqi_supported_event_types[] = {\n\tPQI_EVENT_TYPE_HOTPLUG,\n\tPQI_EVENT_TYPE_HARDWARE,\n\tPQI_EVENT_TYPE_PHYSICAL_DEVICE,\n\tPQI_EVENT_TYPE_LOGICAL_DEVICE,\n\tPQI_EVENT_TYPE_OFA,\n\tPQI_EVENT_TYPE_AIO_STATE_CHANGE,\n\tPQI_EVENT_TYPE_AIO_CONFIG_CHANGE,\n};\n\nstatic int pqi_disable_device_id_wildcards;\nmodule_param_named(disable_device_id_wildcards,\n\tpqi_disable_device_id_wildcards, int, 0644);\nMODULE_PARM_DESC(disable_device_id_wildcards,\n\t\"Disable device ID wildcards.\");\n\nstatic int pqi_disable_heartbeat;\nmodule_param_named(disable_heartbeat,\n\tpqi_disable_heartbeat, int, 0644);\nMODULE_PARM_DESC(disable_heartbeat,\n\t\"Disable heartbeat.\");\n\nstatic int pqi_disable_ctrl_shutdown;\nmodule_param_named(disable_ctrl_shutdown,\n\tpqi_disable_ctrl_shutdown, int, 0644);\nMODULE_PARM_DESC(disable_ctrl_shutdown,\n\t\"Disable controller shutdown when controller locked up.\");\n\nstatic char *pqi_lockup_action_param;\nmodule_param_named(lockup_action,\n\tpqi_lockup_action_param, charp, 0644);\nMODULE_PARM_DESC(lockup_action, \"Action to take when controller locked up.\\n\"\n\t\"\\t\\tSupported: none, reboot, panic\\n\"\n\t\"\\t\\tDefault: none\");\n\nstatic int pqi_expose_ld_first;\nmodule_param_named(expose_ld_first,\n\tpqi_expose_ld_first, int, 0644);\nMODULE_PARM_DESC(expose_ld_first,\n\t\"Expose logical drives before physical drives.\");\n\nstatic int pqi_hide_vsep;\nmodule_param_named(hide_vsep,\n\tpqi_hide_vsep, int, 0644);\nMODULE_PARM_DESC(hide_vsep,\n\t\"Hide the virtual SEP for direct attached drives.\");\n\nstatic char *raid_levels[] = {\n\t\"RAID-0\",\n\t\"RAID-4\",\n\t\"RAID-1(1+0)\",\n\t\"RAID-5\",\n\t\"RAID-5+1\",\n\t\"RAID-ADG\",\n\t\"RAID-1(ADM)\",\n};\n\nstatic char *pqi_raid_level_to_string(u8 raid_level)\n{\n\tif (raid_level < ARRAY_SIZE(raid_levels))\n\t\treturn raid_levels[raid_level];\n\n\treturn \"RAID UNKNOWN\";\n}\n\n#define SA_RAID_0\t\t0\n#define SA_RAID_4\t\t1\n#define SA_RAID_1\t\t2\t/* also used for RAID 10 */\n#define SA_RAID_5\t\t3\t/* also used for RAID 50 */\n#define SA_RAID_51\t\t4\n#define SA_RAID_6\t\t5\t/* also used for RAID 60 */\n#define SA_RAID_ADM\t\t6\t/* also used for RAID 1+0 ADM */\n#define SA_RAID_MAX\t\tSA_RAID_ADM\n#define SA_RAID_UNKNOWN\t\t0xff\n\nstatic inline void pqi_scsi_done(struct scsi_cmnd *scmd)\n{\n\tpqi_prep_for_scsi_done(scmd);\n\tscmd->scsi_done(scmd);\n}\n\nstatic inline void pqi_disable_write_same(struct scsi_device *sdev)\n{\n\tsdev->no_write_same = 1;\n}\n\nstatic inline bool pqi_scsi3addr_equal(u8 *scsi3addr1, u8 *scsi3addr2)\n{\n\treturn memcmp(scsi3addr1, scsi3addr2, 8) == 0;\n}\n\nstatic inline bool pqi_is_logical_device(struct pqi_scsi_dev *device)\n{\n\treturn !device->is_physical_device;\n}\n\nstatic inline bool pqi_is_external_raid_addr(u8 *scsi3addr)\n{\n\treturn scsi3addr[2] != 0;\n}\n\nstatic inline bool pqi_ctrl_offline(struct pqi_ctrl_info *ctrl_info)\n{\n\treturn !ctrl_info->controller_online;\n}\n\nstatic inline void pqi_check_ctrl_health(struct pqi_ctrl_info *ctrl_info)\n{\n\tif (ctrl_info->controller_online)\n\t\tif (!sis_is_firmware_running(ctrl_info))\n\t\t\tpqi_take_ctrl_offline(ctrl_info);\n}\n\nstatic inline bool pqi_is_hba_lunid(u8 *scsi3addr)\n{\n\treturn pqi_scsi3addr_equal(scsi3addr, RAID_CTLR_LUNID);\n}\n\nstatic inline enum pqi_ctrl_mode pqi_get_ctrl_mode(\n\tstruct pqi_ctrl_info *ctrl_info)\n{\n\treturn sis_read_driver_scratch(ctrl_info);\n}\n\nstatic inline void pqi_save_ctrl_mode(struct pqi_ctrl_info *ctrl_info,\n\tenum pqi_ctrl_mode mode)\n{\n\tsis_write_driver_scratch(ctrl_info, mode);\n}\n\nstatic inline void pqi_ctrl_block_device_reset(struct pqi_ctrl_info *ctrl_info)\n{\n\tctrl_info->block_device_reset = true;\n}\n\nstatic inline bool pqi_device_reset_blocked(struct pqi_ctrl_info *ctrl_info)\n{\n\treturn ctrl_info->block_device_reset;\n}\n\nstatic inline bool pqi_ctrl_blocked(struct pqi_ctrl_info *ctrl_info)\n{\n\treturn ctrl_info->block_requests;\n}\n\nstatic inline void pqi_ctrl_block_requests(struct pqi_ctrl_info *ctrl_info)\n{\n\tctrl_info->block_requests = true;\n\tscsi_block_requests(ctrl_info->scsi_host);\n}\n\nstatic inline void pqi_ctrl_unblock_requests(struct pqi_ctrl_info *ctrl_info)\n{\n\tctrl_info->block_requests = false;\n\twake_up_all(&ctrl_info->block_requests_wait);\n\tpqi_retry_raid_bypass_requests(ctrl_info);\n\tscsi_unblock_requests(ctrl_info->scsi_host);\n}\n\nstatic unsigned long pqi_wait_if_ctrl_blocked(struct pqi_ctrl_info *ctrl_info,\n\tunsigned long timeout_msecs)\n{\n\tunsigned long remaining_msecs;\n\n\tif (!pqi_ctrl_blocked(ctrl_info))\n\t\treturn timeout_msecs;\n\n\tatomic_inc(&ctrl_info->num_blocked_threads);\n\n\tif (timeout_msecs == NO_TIMEOUT) {\n\t\twait_event(ctrl_info->block_requests_wait,\n\t\t\t!pqi_ctrl_blocked(ctrl_info));\n\t\tremaining_msecs = timeout_msecs;\n\t} else {\n\t\tunsigned long remaining_jiffies;\n\n\t\tremaining_jiffies =\n\t\t\twait_event_timeout(ctrl_info->block_requests_wait,\n\t\t\t\t!pqi_ctrl_blocked(ctrl_info),\n\t\t\t\tmsecs_to_jiffies(timeout_msecs));\n\t\tremaining_msecs = jiffies_to_msecs(remaining_jiffies);\n\t}\n\n\tatomic_dec(&ctrl_info->num_blocked_threads);\n\n\treturn remaining_msecs;\n}\n\nstatic inline void pqi_ctrl_wait_until_quiesced(struct pqi_ctrl_info *ctrl_info)\n{\n\twhile (atomic_read(&ctrl_info->num_busy_threads) >\n\t\tatomic_read(&ctrl_info->num_blocked_threads))\n\t\tusleep_range(1000, 2000);\n}\n\nstatic inline bool pqi_device_offline(struct pqi_scsi_dev *device)\n{\n\treturn device->device_offline;\n}\n\nstatic inline void pqi_device_reset_start(struct pqi_scsi_dev *device)\n{\n\tdevice->in_reset = true;\n}\n\nstatic inline void pqi_device_reset_done(struct pqi_scsi_dev *device)\n{\n\tdevice->in_reset = false;\n}\n\nstatic inline bool pqi_device_in_reset(struct pqi_scsi_dev *device)\n{\n\treturn device->in_reset;\n}\n\nstatic inline void pqi_ctrl_ofa_start(struct pqi_ctrl_info *ctrl_info)\n{\n\tctrl_info->in_ofa = true;\n}\n\nstatic inline void pqi_ctrl_ofa_done(struct pqi_ctrl_info *ctrl_info)\n{\n\tctrl_info->in_ofa = false;\n}\n\nstatic inline bool pqi_ctrl_in_ofa(struct pqi_ctrl_info *ctrl_info)\n{\n\treturn ctrl_info->in_ofa;\n}\n\nstatic inline void pqi_device_remove_start(struct pqi_scsi_dev *device)\n{\n\tdevice->in_remove = true;\n}\n\nstatic inline bool pqi_device_in_remove(struct pqi_scsi_dev *device)\n{\n\treturn device->in_remove;\n}\n\nstatic inline void pqi_ctrl_shutdown_start(struct pqi_ctrl_info *ctrl_info)\n{\n\tctrl_info->in_shutdown = true;\n}\n\nstatic inline bool pqi_ctrl_in_shutdown(struct pqi_ctrl_info *ctrl_info)\n{\n\treturn ctrl_info->in_shutdown;\n}\n\nstatic inline void pqi_schedule_rescan_worker_with_delay(\n\tstruct pqi_ctrl_info *ctrl_info, unsigned long delay)\n{\n\tif (pqi_ctrl_offline(ctrl_info))\n\t\treturn;\n\tif (pqi_ctrl_in_ofa(ctrl_info))\n\t\treturn;\n\n\tschedule_delayed_work(&ctrl_info->rescan_work, delay);\n}\n\nstatic inline void pqi_schedule_rescan_worker(struct pqi_ctrl_info *ctrl_info)\n{\n\tpqi_schedule_rescan_worker_with_delay(ctrl_info, 0);\n}\n\n#define PQI_RESCAN_WORK_DELAY\t(10 * PQI_HZ)\n\nstatic inline void pqi_schedule_rescan_worker_delayed(\n\tstruct pqi_ctrl_info *ctrl_info)\n{\n\tpqi_schedule_rescan_worker_with_delay(ctrl_info, PQI_RESCAN_WORK_DELAY);\n}\n\nstatic inline void pqi_cancel_rescan_worker(struct pqi_ctrl_info *ctrl_info)\n{\n\tcancel_delayed_work_sync(&ctrl_info->rescan_work);\n}\n\nstatic inline void pqi_cancel_event_worker(struct pqi_ctrl_info *ctrl_info)\n{\n\tcancel_work_sync(&ctrl_info->event_work);\n}\n\nstatic inline u32 pqi_read_heartbeat_counter(struct pqi_ctrl_info *ctrl_info)\n{\n\tif (!ctrl_info->heartbeat_counter)\n\t\treturn 0;\n\n\treturn readl(ctrl_info->heartbeat_counter);\n}\n\nstatic inline u8 pqi_read_soft_reset_status(struct pqi_ctrl_info *ctrl_info)\n{\n\tif (!ctrl_info->soft_reset_status)\n\t\treturn 0;\n\n\treturn readb(ctrl_info->soft_reset_status);\n}\n\nstatic inline void pqi_clear_soft_reset_status(struct pqi_ctrl_info *ctrl_info,\n\tu8 clear)\n{\n\tu8 status;\n\n\tif (!ctrl_info->soft_reset_status)\n\t\treturn;\n\n\tstatus = pqi_read_soft_reset_status(ctrl_info);\n\tstatus &= ~clear;\n\twriteb(status, ctrl_info->soft_reset_status);\n}\n\nstatic int pqi_map_single(struct pci_dev *pci_dev,\n\tstruct pqi_sg_descriptor *sg_descriptor, void *buffer,\n\tsize_t buffer_length, enum dma_data_direction data_direction)\n{\n\tdma_addr_t bus_address;\n\n\tif (!buffer || buffer_length == 0 || data_direction == DMA_NONE)\n\t\treturn 0;\n\n\tbus_address = dma_map_single(&pci_dev->dev, buffer, buffer_length,\n\t\tdata_direction);\n\tif (dma_mapping_error(&pci_dev->dev, bus_address))\n\t\treturn -ENOMEM;\n\n\tput_unaligned_le64((u64)bus_address, &sg_descriptor->address);\n\tput_unaligned_le32(buffer_length, &sg_descriptor->length);\n\tput_unaligned_le32(CISS_SG_LAST, &sg_descriptor->flags);\n\n\treturn 0;\n}\n\nstatic void pqi_pci_unmap(struct pci_dev *pci_dev,\n\tstruct pqi_sg_descriptor *descriptors, int num_descriptors,\n\tenum dma_data_direction data_direction)\n{\n\tint i;\n\n\tif (data_direction == DMA_NONE)\n\t\treturn;\n\n\tfor (i = 0; i < num_descriptors; i++)\n\t\tdma_unmap_single(&pci_dev->dev,\n\t\t\t(dma_addr_t)get_unaligned_le64(&descriptors[i].address),\n\t\t\tget_unaligned_le32(&descriptors[i].length),\n\t\t\tdata_direction);\n}\n\nstatic int pqi_build_raid_path_request(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_raid_path_request *request, u8 cmd,\n\tu8 *scsi3addr, void *buffer, size_t buffer_length,\n\tu16 vpd_page, enum dma_data_direction *dir)\n{\n\tu8 *cdb;\n\tsize_t cdb_length = buffer_length;\n\n\tmemset(request, 0, sizeof(*request));\n\n\trequest->header.iu_type = PQI_REQUEST_IU_RAID_PATH_IO;\n\tput_unaligned_le16(offsetof(struct pqi_raid_path_request,\n\t\tsg_descriptors[1]) - PQI_REQUEST_HEADER_LENGTH,\n\t\t&request->header.iu_length);\n\tput_unaligned_le32(buffer_length, &request->buffer_length);\n\tmemcpy(request->lun_number, scsi3addr, sizeof(request->lun_number));\n\trequest->task_attribute = SOP_TASK_ATTRIBUTE_SIMPLE;\n\trequest->additional_cdb_bytes_usage = SOP_ADDITIONAL_CDB_BYTES_0;\n\n\tcdb = request->cdb;\n\n\tswitch (cmd) {\n\tcase INQUIRY:\n\t\trequest->data_direction = SOP_READ_FLAG;\n\t\tcdb[0] = INQUIRY;\n\t\tif (vpd_page & VPD_PAGE) {\n\t\t\tcdb[1] = 0x1;\n\t\t\tcdb[2] = (u8)vpd_page;\n\t\t}\n\t\tcdb[4] = (u8)cdb_length;\n\t\tbreak;\n\tcase CISS_REPORT_LOG:\n\tcase CISS_REPORT_PHYS:\n\t\trequest->data_direction = SOP_READ_FLAG;\n\t\tcdb[0] = cmd;\n\t\tif (cmd == CISS_REPORT_PHYS)\n\t\t\tcdb[1] = CISS_REPORT_PHYS_FLAG_OTHER;\n\t\telse\n\t\t\tcdb[1] = CISS_REPORT_LOG_FLAG_UNIQUE_LUN_ID;\n\t\tput_unaligned_be32(cdb_length, &cdb[6]);\n\t\tbreak;\n\tcase CISS_GET_RAID_MAP:\n\t\trequest->data_direction = SOP_READ_FLAG;\n\t\tcdb[0] = CISS_READ;\n\t\tcdb[1] = CISS_GET_RAID_MAP;\n\t\tput_unaligned_be32(cdb_length, &cdb[6]);\n\t\tbreak;\n\tcase SA_FLUSH_CACHE:\n\t\trequest->data_direction = SOP_WRITE_FLAG;\n\t\tcdb[0] = BMIC_WRITE;\n\t\tcdb[6] = BMIC_FLUSH_CACHE;\n\t\tput_unaligned_be16(cdb_length, &cdb[7]);\n\t\tbreak;\n\tcase BMIC_SENSE_DIAG_OPTIONS:\n\t\tcdb_length = 0;\n\t\tfallthrough;\n\tcase BMIC_IDENTIFY_CONTROLLER:\n\tcase BMIC_IDENTIFY_PHYSICAL_DEVICE:\n\tcase BMIC_SENSE_SUBSYSTEM_INFORMATION:\n\t\trequest->data_direction = SOP_READ_FLAG;\n\t\tcdb[0] = BMIC_READ;\n\t\tcdb[6] = cmd;\n\t\tput_unaligned_be16(cdb_length, &cdb[7]);\n\t\tbreak;\n\tcase BMIC_SET_DIAG_OPTIONS:\n\t\tcdb_length = 0;\n\t\tfallthrough;\n\tcase BMIC_WRITE_HOST_WELLNESS:\n\t\trequest->data_direction = SOP_WRITE_FLAG;\n\t\tcdb[0] = BMIC_WRITE;\n\t\tcdb[6] = cmd;\n\t\tput_unaligned_be16(cdb_length, &cdb[7]);\n\t\tbreak;\n\tcase BMIC_CSMI_PASSTHRU:\n\t\trequest->data_direction = SOP_BIDIRECTIONAL;\n\t\tcdb[0] = BMIC_WRITE;\n\t\tcdb[5] = CSMI_CC_SAS_SMP_PASSTHRU;\n\t\tcdb[6] = cmd;\n\t\tput_unaligned_be16(cdb_length, &cdb[7]);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&ctrl_info->pci_dev->dev, \"unknown command 0x%c\\n\", cmd);\n\t\tbreak;\n\t}\n\n\tswitch (request->data_direction) {\n\tcase SOP_READ_FLAG:\n\t\t*dir = DMA_FROM_DEVICE;\n\t\tbreak;\n\tcase SOP_WRITE_FLAG:\n\t\t*dir = DMA_TO_DEVICE;\n\t\tbreak;\n\tcase SOP_NO_DIRECTION_FLAG:\n\t\t*dir = DMA_NONE;\n\t\tbreak;\n\tdefault:\n\t\t*dir = DMA_BIDIRECTIONAL;\n\t\tbreak;\n\t}\n\n\treturn pqi_map_single(ctrl_info->pci_dev, &request->sg_descriptors[0],\n\t\tbuffer, buffer_length, *dir);\n}\n\nstatic inline void pqi_reinit_io_request(struct pqi_io_request *io_request)\n{\n\tio_request->scmd = NULL;\n\tio_request->status = 0;\n\tio_request->error_info = NULL;\n\tio_request->raid_bypass = false;\n}\n\nstatic struct pqi_io_request *pqi_alloc_io_request(\n\tstruct pqi_ctrl_info *ctrl_info)\n{\n\tstruct pqi_io_request *io_request;\n\tu16 i = ctrl_info->next_io_request_slot;\t/* benignly racy */\n\n\twhile (1) {\n\t\tio_request = &ctrl_info->io_request_pool[i];\n\t\tif (atomic_inc_return(&io_request->refcount) == 1)\n\t\t\tbreak;\n\t\tatomic_dec(&io_request->refcount);\n\t\ti = (i + 1) % ctrl_info->max_io_slots;\n\t}\n\n\t/* benignly racy */\n\tctrl_info->next_io_request_slot = (i + 1) % ctrl_info->max_io_slots;\n\n\tpqi_reinit_io_request(io_request);\n\n\treturn io_request;\n}\n\nstatic void pqi_free_io_request(struct pqi_io_request *io_request)\n{\n\tatomic_dec(&io_request->refcount);\n}\n\nstatic int pqi_send_scsi_raid_request(struct pqi_ctrl_info *ctrl_info, u8 cmd,\n\tu8 *scsi3addr, void *buffer, size_t buffer_length, u16 vpd_page,\n\tstruct pqi_raid_error_info *error_info,\tunsigned long timeout_msecs)\n{\n\tint rc;\n\tstruct pqi_raid_path_request request;\n\tenum dma_data_direction dir;\n\n\trc = pqi_build_raid_path_request(ctrl_info, &request,\n\t\tcmd, scsi3addr, buffer,\n\t\tbuffer_length, vpd_page, &dir);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pqi_submit_raid_request_synchronous(ctrl_info, &request.header, 0,\n\t\terror_info, timeout_msecs);\n\n\tpqi_pci_unmap(ctrl_info->pci_dev, request.sg_descriptors, 1, dir);\n\n\treturn rc;\n}\n\n/* helper functions for pqi_send_scsi_raid_request */\n\nstatic inline int pqi_send_ctrl_raid_request(struct pqi_ctrl_info *ctrl_info,\n\tu8 cmd, void *buffer, size_t buffer_length)\n{\n\treturn pqi_send_scsi_raid_request(ctrl_info, cmd, RAID_CTLR_LUNID,\n\t\tbuffer, buffer_length, 0, NULL, NO_TIMEOUT);\n}\n\nstatic inline int pqi_send_ctrl_raid_with_error(struct pqi_ctrl_info *ctrl_info,\n\tu8 cmd, void *buffer, size_t buffer_length,\n\tstruct pqi_raid_error_info *error_info)\n{\n\treturn pqi_send_scsi_raid_request(ctrl_info, cmd, RAID_CTLR_LUNID,\n\t\tbuffer, buffer_length, 0, error_info, NO_TIMEOUT);\n}\n\nstatic inline int pqi_identify_controller(struct pqi_ctrl_info *ctrl_info,\n\tstruct bmic_identify_controller *buffer)\n{\n\treturn pqi_send_ctrl_raid_request(ctrl_info, BMIC_IDENTIFY_CONTROLLER,\n\t\tbuffer, sizeof(*buffer));\n}\n\nstatic inline int pqi_sense_subsystem_info(struct  pqi_ctrl_info *ctrl_info,\n\tstruct bmic_sense_subsystem_info *sense_info)\n{\n\treturn pqi_send_ctrl_raid_request(ctrl_info,\n\t\tBMIC_SENSE_SUBSYSTEM_INFORMATION, sense_info,\n\t\tsizeof(*sense_info));\n}\n\nstatic inline int pqi_scsi_inquiry(struct pqi_ctrl_info *ctrl_info,\n\tu8 *scsi3addr, u16 vpd_page, void *buffer, size_t buffer_length)\n{\n\treturn pqi_send_scsi_raid_request(ctrl_info, INQUIRY, scsi3addr,\n\t\tbuffer, buffer_length, vpd_page, NULL, NO_TIMEOUT);\n}\n\nstatic int pqi_identify_physical_device(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device,\n\tstruct bmic_identify_physical_device *buffer, size_t buffer_length)\n{\n\tint rc;\n\tenum dma_data_direction dir;\n\tu16 bmic_device_index;\n\tstruct pqi_raid_path_request request;\n\n\trc = pqi_build_raid_path_request(ctrl_info, &request,\n\t\tBMIC_IDENTIFY_PHYSICAL_DEVICE, RAID_CTLR_LUNID, buffer,\n\t\tbuffer_length, 0, &dir);\n\tif (rc)\n\t\treturn rc;\n\n\tbmic_device_index = CISS_GET_DRIVE_NUMBER(device->scsi3addr);\n\trequest.cdb[2] = (u8)bmic_device_index;\n\trequest.cdb[9] = (u8)(bmic_device_index >> 8);\n\n\trc = pqi_submit_raid_request_synchronous(ctrl_info, &request.header,\n\t\t0, NULL, NO_TIMEOUT);\n\n\tpqi_pci_unmap(ctrl_info->pci_dev, request.sg_descriptors, 1, dir);\n\n\treturn rc;\n}\n\nstatic int pqi_flush_cache(struct pqi_ctrl_info *ctrl_info,\n\tenum bmic_flush_cache_shutdown_event shutdown_event)\n{\n\tint rc;\n\tstruct bmic_flush_cache *flush_cache;\n\n\t/*\n\t * Don't bother trying to flush the cache if the controller is\n\t * locked up.\n\t */\n\tif (pqi_ctrl_offline(ctrl_info))\n\t\treturn -ENXIO;\n\n\tflush_cache = kzalloc(sizeof(*flush_cache), GFP_KERNEL);\n\tif (!flush_cache)\n\t\treturn -ENOMEM;\n\n\tflush_cache->shutdown_event = shutdown_event;\n\n\trc = pqi_send_ctrl_raid_request(ctrl_info, SA_FLUSH_CACHE, flush_cache,\n\t\tsizeof(*flush_cache));\n\n\tkfree(flush_cache);\n\n\treturn rc;\n}\n\nint pqi_csmi_smp_passthru(struct pqi_ctrl_info *ctrl_info,\n\tstruct bmic_csmi_smp_passthru_buffer *buffer, size_t buffer_length,\n\tstruct pqi_raid_error_info *error_info)\n{\n\treturn pqi_send_ctrl_raid_with_error(ctrl_info, BMIC_CSMI_PASSTHRU,\n\t\tbuffer, buffer_length, error_info);\n}\n\n#define PQI_FETCH_PTRAID_DATA\t\t(1 << 31)\n\nstatic int pqi_set_diag_rescan(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tstruct bmic_diag_options *diag;\n\n\tdiag = kzalloc(sizeof(*diag), GFP_KERNEL);\n\tif (!diag)\n\t\treturn -ENOMEM;\n\n\trc = pqi_send_ctrl_raid_request(ctrl_info, BMIC_SENSE_DIAG_OPTIONS,\n\t\tdiag, sizeof(*diag));\n\tif (rc)\n\t\tgoto out;\n\n\tdiag->options |= cpu_to_le32(PQI_FETCH_PTRAID_DATA);\n\n\trc = pqi_send_ctrl_raid_request(ctrl_info, BMIC_SET_DIAG_OPTIONS, diag,\n\t\tsizeof(*diag));\n\nout:\n\tkfree(diag);\n\n\treturn rc;\n}\n\nstatic inline int pqi_write_host_wellness(struct pqi_ctrl_info *ctrl_info,\n\tvoid *buffer, size_t buffer_length)\n{\n\treturn pqi_send_ctrl_raid_request(ctrl_info, BMIC_WRITE_HOST_WELLNESS,\n\t\tbuffer, buffer_length);\n}\n\n#pragma pack(1)\n\nstruct bmic_host_wellness_driver_version {\n\tu8\tstart_tag[4];\n\tu8\tdriver_version_tag[2];\n\t__le16\tdriver_version_length;\n\tchar\tdriver_version[32];\n\tu8\tdont_write_tag[2];\n\tu8\tend_tag[2];\n};\n\n#pragma pack()\n\nstatic int pqi_write_driver_version_to_host_wellness(\n\tstruct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tstruct bmic_host_wellness_driver_version *buffer;\n\tsize_t buffer_length;\n\n\tbuffer_length = sizeof(*buffer);\n\n\tbuffer = kmalloc(buffer_length, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tbuffer->start_tag[0] = '<';\n\tbuffer->start_tag[1] = 'H';\n\tbuffer->start_tag[2] = 'W';\n\tbuffer->start_tag[3] = '>';\n\tbuffer->driver_version_tag[0] = 'D';\n\tbuffer->driver_version_tag[1] = 'V';\n\tput_unaligned_le16(sizeof(buffer->driver_version),\n\t\t&buffer->driver_version_length);\n\tstrncpy(buffer->driver_version, \"Linux \" DRIVER_VERSION,\n\t\tsizeof(buffer->driver_version) - 1);\n\tbuffer->driver_version[sizeof(buffer->driver_version) - 1] = '\\0';\n\tbuffer->dont_write_tag[0] = 'D';\n\tbuffer->dont_write_tag[1] = 'W';\n\tbuffer->end_tag[0] = 'Z';\n\tbuffer->end_tag[1] = 'Z';\n\n\trc = pqi_write_host_wellness(ctrl_info, buffer, buffer_length);\n\n\tkfree(buffer);\n\n\treturn rc;\n}\n\n#pragma pack(1)\n\nstruct bmic_host_wellness_time {\n\tu8\tstart_tag[4];\n\tu8\ttime_tag[2];\n\t__le16\ttime_length;\n\tu8\ttime[8];\n\tu8\tdont_write_tag[2];\n\tu8\tend_tag[2];\n};\n\n#pragma pack()\n\nstatic int pqi_write_current_time_to_host_wellness(\n\tstruct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tstruct bmic_host_wellness_time *buffer;\n\tsize_t buffer_length;\n\ttime64_t local_time;\n\tunsigned int year;\n\tstruct tm tm;\n\n\tbuffer_length = sizeof(*buffer);\n\n\tbuffer = kmalloc(buffer_length, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tbuffer->start_tag[0] = '<';\n\tbuffer->start_tag[1] = 'H';\n\tbuffer->start_tag[2] = 'W';\n\tbuffer->start_tag[3] = '>';\n\tbuffer->time_tag[0] = 'T';\n\tbuffer->time_tag[1] = 'D';\n\tput_unaligned_le16(sizeof(buffer->time),\n\t\t&buffer->time_length);\n\n\tlocal_time = ktime_get_real_seconds();\n\ttime64_to_tm(local_time, -sys_tz.tz_minuteswest * 60, &tm);\n\tyear = tm.tm_year + 1900;\n\n\tbuffer->time[0] = bin2bcd(tm.tm_hour);\n\tbuffer->time[1] = bin2bcd(tm.tm_min);\n\tbuffer->time[2] = bin2bcd(tm.tm_sec);\n\tbuffer->time[3] = 0;\n\tbuffer->time[4] = bin2bcd(tm.tm_mon + 1);\n\tbuffer->time[5] = bin2bcd(tm.tm_mday);\n\tbuffer->time[6] = bin2bcd(year / 100);\n\tbuffer->time[7] = bin2bcd(year % 100);\n\n\tbuffer->dont_write_tag[0] = 'D';\n\tbuffer->dont_write_tag[1] = 'W';\n\tbuffer->end_tag[0] = 'Z';\n\tbuffer->end_tag[1] = 'Z';\n\n\trc = pqi_write_host_wellness(ctrl_info, buffer, buffer_length);\n\n\tkfree(buffer);\n\n\treturn rc;\n}\n\n#define PQI_UPDATE_TIME_WORK_INTERVAL\t(24UL * 60 * 60 * PQI_HZ)\n\nstatic void pqi_update_time_worker(struct work_struct *work)\n{\n\tint rc;\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tctrl_info = container_of(to_delayed_work(work), struct pqi_ctrl_info,\n\t\tupdate_time_work);\n\n\tif (pqi_ctrl_offline(ctrl_info))\n\t\treturn;\n\n\trc = pqi_write_current_time_to_host_wellness(ctrl_info);\n\tif (rc)\n\t\tdev_warn(&ctrl_info->pci_dev->dev,\n\t\t\t\"error updating time on controller\\n\");\n\n\tschedule_delayed_work(&ctrl_info->update_time_work,\n\t\tPQI_UPDATE_TIME_WORK_INTERVAL);\n}\n\nstatic inline void pqi_schedule_update_time_worker(\n\tstruct pqi_ctrl_info *ctrl_info)\n{\n\tschedule_delayed_work(&ctrl_info->update_time_work, 0);\n}\n\nstatic inline void pqi_cancel_update_time_worker(\n\tstruct pqi_ctrl_info *ctrl_info)\n{\n\tcancel_delayed_work_sync(&ctrl_info->update_time_work);\n}\n\nstatic inline int pqi_report_luns(struct pqi_ctrl_info *ctrl_info, u8 cmd,\n\tvoid *buffer, size_t buffer_length)\n{\n\treturn pqi_send_ctrl_raid_request(ctrl_info, cmd, buffer,\n\t\tbuffer_length);\n}\n\nstatic int pqi_report_phys_logical_luns(struct pqi_ctrl_info *ctrl_info, u8 cmd,\n\tvoid **buffer)\n{\n\tint rc;\n\tsize_t lun_list_length;\n\tsize_t lun_data_length;\n\tsize_t new_lun_list_length;\n\tvoid *lun_data = NULL;\n\tstruct report_lun_header *report_lun_header;\n\n\treport_lun_header = kmalloc(sizeof(*report_lun_header), GFP_KERNEL);\n\tif (!report_lun_header) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = pqi_report_luns(ctrl_info, cmd, report_lun_header,\n\t\tsizeof(*report_lun_header));\n\tif (rc)\n\t\tgoto out;\n\n\tlun_list_length = get_unaligned_be32(&report_lun_header->list_length);\n\nagain:\n\tlun_data_length = sizeof(struct report_lun_header) + lun_list_length;\n\n\tlun_data = kmalloc(lun_data_length, GFP_KERNEL);\n\tif (!lun_data) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (lun_list_length == 0) {\n\t\tmemcpy(lun_data, report_lun_header, sizeof(*report_lun_header));\n\t\tgoto out;\n\t}\n\n\trc = pqi_report_luns(ctrl_info, cmd, lun_data, lun_data_length);\n\tif (rc)\n\t\tgoto out;\n\n\tnew_lun_list_length = get_unaligned_be32(\n\t\t&((struct report_lun_header *)lun_data)->list_length);\n\n\tif (new_lun_list_length > lun_list_length) {\n\t\tlun_list_length = new_lun_list_length;\n\t\tkfree(lun_data);\n\t\tgoto again;\n\t}\n\nout:\n\tkfree(report_lun_header);\n\n\tif (rc) {\n\t\tkfree(lun_data);\n\t\tlun_data = NULL;\n\t}\n\n\t*buffer = lun_data;\n\n\treturn rc;\n}\n\nstatic inline int pqi_report_phys_luns(struct pqi_ctrl_info *ctrl_info,\n\tvoid **buffer)\n{\n\treturn pqi_report_phys_logical_luns(ctrl_info, CISS_REPORT_PHYS,\n\t\tbuffer);\n}\n\nstatic inline int pqi_report_logical_luns(struct pqi_ctrl_info *ctrl_info,\n\tvoid **buffer)\n{\n\treturn pqi_report_phys_logical_luns(ctrl_info, CISS_REPORT_LOG, buffer);\n}\n\nstatic int pqi_get_device_lists(struct pqi_ctrl_info *ctrl_info,\n\tstruct report_phys_lun_extended **physdev_list,\n\tstruct report_log_lun_extended **logdev_list)\n{\n\tint rc;\n\tsize_t logdev_list_length;\n\tsize_t logdev_data_length;\n\tstruct report_log_lun_extended *internal_logdev_list;\n\tstruct report_log_lun_extended *logdev_data;\n\tstruct report_lun_header report_lun_header;\n\n\trc = pqi_report_phys_luns(ctrl_info, (void **)physdev_list);\n\tif (rc)\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"report physical LUNs failed\\n\");\n\n\trc = pqi_report_logical_luns(ctrl_info, (void **)logdev_list);\n\tif (rc)\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"report logical LUNs failed\\n\");\n\n\t/*\n\t * Tack the controller itself onto the end of the logical device list.\n\t */\n\n\tlogdev_data = *logdev_list;\n\n\tif (logdev_data) {\n\t\tlogdev_list_length =\n\t\t\tget_unaligned_be32(&logdev_data->header.list_length);\n\t} else {\n\t\tmemset(&report_lun_header, 0, sizeof(report_lun_header));\n\t\tlogdev_data =\n\t\t\t(struct report_log_lun_extended *)&report_lun_header;\n\t\tlogdev_list_length = 0;\n\t}\n\n\tlogdev_data_length = sizeof(struct report_lun_header) +\n\t\tlogdev_list_length;\n\n\tinternal_logdev_list = kmalloc(logdev_data_length +\n\t\tsizeof(struct report_log_lun_extended), GFP_KERNEL);\n\tif (!internal_logdev_list) {\n\t\tkfree(*logdev_list);\n\t\t*logdev_list = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(internal_logdev_list, logdev_data, logdev_data_length);\n\tmemset((u8 *)internal_logdev_list + logdev_data_length, 0,\n\t\tsizeof(struct report_log_lun_extended_entry));\n\tput_unaligned_be32(logdev_list_length +\n\t\tsizeof(struct report_log_lun_extended_entry),\n\t\t&internal_logdev_list->header.list_length);\n\n\tkfree(*logdev_list);\n\t*logdev_list = internal_logdev_list;\n\n\treturn 0;\n}\n\nstatic inline void pqi_set_bus_target_lun(struct pqi_scsi_dev *device,\n\tint bus, int target, int lun)\n{\n\tdevice->bus = bus;\n\tdevice->target = target;\n\tdevice->lun = lun;\n}\n\nstatic void pqi_assign_bus_target_lun(struct pqi_scsi_dev *device)\n{\n\tu8 *scsi3addr;\n\tu32 lunid;\n\tint bus;\n\tint target;\n\tint lun;\n\n\tscsi3addr = device->scsi3addr;\n\tlunid = get_unaligned_le32(scsi3addr);\n\n\tif (pqi_is_hba_lunid(scsi3addr)) {\n\t\t/* The specified device is the controller. */\n\t\tpqi_set_bus_target_lun(device, PQI_HBA_BUS, 0, lunid & 0x3fff);\n\t\tdevice->target_lun_valid = true;\n\t\treturn;\n\t}\n\n\tif (pqi_is_logical_device(device)) {\n\t\tif (device->is_external_raid_device) {\n\t\t\tbus = PQI_EXTERNAL_RAID_VOLUME_BUS;\n\t\t\ttarget = (lunid >> 16) & 0x3fff;\n\t\t\tlun = lunid & 0xff;\n\t\t} else {\n\t\t\tbus = PQI_RAID_VOLUME_BUS;\n\t\t\ttarget = 0;\n\t\t\tlun = lunid & 0x3fff;\n\t\t}\n\t\tpqi_set_bus_target_lun(device, bus, target, lun);\n\t\tdevice->target_lun_valid = true;\n\t\treturn;\n\t}\n\n\t/*\n\t * Defer target and LUN assignment for non-controller physical devices\n\t * because the SAS transport layer will make these assignments later.\n\t */\n\tpqi_set_bus_target_lun(device, PQI_PHYSICAL_DEVICE_BUS, 0, 0);\n}\n\nstatic void pqi_get_raid_level(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device)\n{\n\tint rc;\n\tu8 raid_level;\n\tu8 *buffer;\n\n\traid_level = SA_RAID_UNKNOWN;\n\n\tbuffer = kmalloc(64, GFP_KERNEL);\n\tif (buffer) {\n\t\trc = pqi_scsi_inquiry(ctrl_info, device->scsi3addr,\n\t\t\tVPD_PAGE | CISS_VPD_LV_DEVICE_GEOMETRY, buffer, 64);\n\t\tif (rc == 0) {\n\t\t\traid_level = buffer[8];\n\t\t\tif (raid_level > SA_RAID_MAX)\n\t\t\t\traid_level = SA_RAID_UNKNOWN;\n\t\t}\n\t\tkfree(buffer);\n\t}\n\n\tdevice->raid_level = raid_level;\n}\n\nstatic int pqi_validate_raid_map(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device, struct raid_map *raid_map)\n{\n\tchar *err_msg;\n\tu32 raid_map_size;\n\tu32 r5or6_blocks_per_row;\n\n\traid_map_size = get_unaligned_le32(&raid_map->structure_size);\n\n\tif (raid_map_size < offsetof(struct raid_map, disk_data)) {\n\t\terr_msg = \"RAID map too small\";\n\t\tgoto bad_raid_map;\n\t}\n\n\tif (device->raid_level == SA_RAID_1) {\n\t\tif (get_unaligned_le16(&raid_map->layout_map_count) != 2) {\n\t\t\terr_msg = \"invalid RAID-1 map\";\n\t\t\tgoto bad_raid_map;\n\t\t}\n\t} else if (device->raid_level == SA_RAID_ADM) {\n\t\tif (get_unaligned_le16(&raid_map->layout_map_count) != 3) {\n\t\t\terr_msg = \"invalid RAID-1(ADM) map\";\n\t\t\tgoto bad_raid_map;\n\t\t}\n\t} else if ((device->raid_level == SA_RAID_5 ||\n\t\tdevice->raid_level == SA_RAID_6) &&\n\t\tget_unaligned_le16(&raid_map->layout_map_count) > 1) {\n\t\t/* RAID 50/60 */\n\t\tr5or6_blocks_per_row =\n\t\t\tget_unaligned_le16(&raid_map->strip_size) *\n\t\t\tget_unaligned_le16(&raid_map->data_disks_per_row);\n\t\tif (r5or6_blocks_per_row == 0) {\n\t\t\terr_msg = \"invalid RAID-5 or RAID-6 map\";\n\t\t\tgoto bad_raid_map;\n\t\t}\n\t}\n\n\treturn 0;\n\nbad_raid_map:\n\tdev_warn(&ctrl_info->pci_dev->dev,\n\t\t\"logical device %08x%08x %s\\n\",\n\t\t*((u32 *)&device->scsi3addr),\n\t\t*((u32 *)&device->scsi3addr[4]), err_msg);\n\n\treturn -EINVAL;\n}\n\nstatic int pqi_get_raid_map(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device)\n{\n\tint rc;\n\tu32 raid_map_size;\n\tstruct raid_map *raid_map;\n\n\traid_map = kmalloc(sizeof(*raid_map), GFP_KERNEL);\n\tif (!raid_map)\n\t\treturn -ENOMEM;\n\n\trc = pqi_send_scsi_raid_request(ctrl_info, CISS_GET_RAID_MAP,\n\t\tdevice->scsi3addr, raid_map, sizeof(*raid_map),\n\t\t0, NULL, NO_TIMEOUT);\n\n\tif (rc)\n\t\tgoto error;\n\n\traid_map_size = get_unaligned_le32(&raid_map->structure_size);\n\n\tif (raid_map_size > sizeof(*raid_map)) {\n\n\t\tkfree(raid_map);\n\n\t\traid_map = kmalloc(raid_map_size, GFP_KERNEL);\n\t\tif (!raid_map)\n\t\t\treturn -ENOMEM;\n\n\t\trc = pqi_send_scsi_raid_request(ctrl_info, CISS_GET_RAID_MAP,\n\t\t\tdevice->scsi3addr, raid_map, raid_map_size,\n\t\t\t0, NULL, NO_TIMEOUT);\n\t\tif (rc)\n\t\t\tgoto error;\n\n\t\tif (get_unaligned_le32(&raid_map->structure_size)\n\t\t\t!= raid_map_size) {\n\t\t\tdev_warn(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"Requested %d bytes, received %d bytes\",\n\t\t\t\traid_map_size,\n\t\t\t\tget_unaligned_le32(&raid_map->structure_size));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\trc = pqi_validate_raid_map(ctrl_info, device, raid_map);\n\tif (rc)\n\t\tgoto error;\n\n\tdevice->raid_map = raid_map;\n\n\treturn 0;\n\nerror:\n\tkfree(raid_map);\n\n\treturn rc;\n}\n\nstatic void pqi_get_raid_bypass_status(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device)\n{\n\tint rc;\n\tu8 *buffer;\n\tu8 bypass_status;\n\n\tbuffer = kmalloc(64, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn;\n\n\trc = pqi_scsi_inquiry(ctrl_info, device->scsi3addr,\n\t\tVPD_PAGE | CISS_VPD_LV_BYPASS_STATUS, buffer, 64);\n\tif (rc)\n\t\tgoto out;\n\n#define RAID_BYPASS_STATUS\t\t4\n#define RAID_BYPASS_CONFIGURED\t\t0x1\n#define RAID_BYPASS_ENABLED\t\t0x2\n\n\tbypass_status = buffer[RAID_BYPASS_STATUS];\n\tdevice->raid_bypass_configured =\n\t\t(bypass_status & RAID_BYPASS_CONFIGURED) != 0;\n\tif (device->raid_bypass_configured &&\n\t\t(bypass_status & RAID_BYPASS_ENABLED) &&\n\t\tpqi_get_raid_map(ctrl_info, device) == 0)\n\t\tdevice->raid_bypass_enabled = true;\n\nout:\n\tkfree(buffer);\n}\n\n/*\n * Use vendor-specific VPD to determine online/offline status of a volume.\n */\n\nstatic void pqi_get_volume_status(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device)\n{\n\tint rc;\n\tsize_t page_length;\n\tu8 volume_status = CISS_LV_STATUS_UNAVAILABLE;\n\tbool volume_offline = true;\n\tu32 volume_flags;\n\tstruct ciss_vpd_logical_volume_status *vpd;\n\n\tvpd = kmalloc(sizeof(*vpd), GFP_KERNEL);\n\tif (!vpd)\n\t\tgoto no_buffer;\n\n\trc = pqi_scsi_inquiry(ctrl_info, device->scsi3addr,\n\t\tVPD_PAGE | CISS_VPD_LV_STATUS, vpd, sizeof(*vpd));\n\tif (rc)\n\t\tgoto out;\n\n\tif (vpd->page_code != CISS_VPD_LV_STATUS)\n\t\tgoto out;\n\n\tpage_length = offsetof(struct ciss_vpd_logical_volume_status,\n\t\tvolume_status) + vpd->page_length;\n\tif (page_length < sizeof(*vpd))\n\t\tgoto out;\n\n\tvolume_status = vpd->volume_status;\n\tvolume_flags = get_unaligned_be32(&vpd->flags);\n\tvolume_offline = (volume_flags & CISS_LV_FLAGS_NO_HOST_IO) != 0;\n\nout:\n\tkfree(vpd);\nno_buffer:\n\tdevice->volume_status = volume_status;\n\tdevice->volume_offline = volume_offline;\n}\n\nstatic int pqi_get_physical_device_info(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device,\n\tstruct bmic_identify_physical_device *id_phys)\n{\n\tint rc;\n\n\tmemset(id_phys, 0, sizeof(*id_phys));\n\n\trc = pqi_identify_physical_device(ctrl_info, device,\n\t\tid_phys, sizeof(*id_phys));\n\tif (rc) {\n\t\tdevice->queue_depth = PQI_PHYSICAL_DISK_DEFAULT_MAX_QUEUE_DEPTH;\n\t\treturn rc;\n\t}\n\n\tscsi_sanitize_inquiry_string(&id_phys->model[0], 8);\n\tscsi_sanitize_inquiry_string(&id_phys->model[8], 16);\n\n\tmemcpy(device->vendor, &id_phys->model[0], sizeof(device->vendor));\n\tmemcpy(device->model, &id_phys->model[8], sizeof(device->model));\n\n\tdevice->box_index = id_phys->box_index;\n\tdevice->phys_box_on_bus = id_phys->phys_box_on_bus;\n\tdevice->phy_connected_dev_type = id_phys->phy_connected_dev_type[0];\n\tdevice->queue_depth =\n\t\tget_unaligned_le16(&id_phys->current_queue_depth_limit);\n\tdevice->active_path_index = id_phys->active_path_number;\n\tdevice->path_map = id_phys->redundant_path_present_map;\n\tmemcpy(&device->box,\n\t\t&id_phys->alternate_paths_phys_box_on_port,\n\t\tsizeof(device->box));\n\tmemcpy(&device->phys_connector,\n\t\t&id_phys->alternate_paths_phys_connector,\n\t\tsizeof(device->phys_connector));\n\tdevice->bay = id_phys->phys_bay_in_box;\n\n\treturn 0;\n}\n\nstatic int pqi_get_logical_device_info(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device)\n{\n\tint rc;\n\tu8 *buffer;\n\n\tbuffer = kmalloc(64, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t/* Send an inquiry to the device to see what it is. */\n\trc = pqi_scsi_inquiry(ctrl_info, device->scsi3addr, 0, buffer, 64);\n\tif (rc)\n\t\tgoto out;\n\n\tscsi_sanitize_inquiry_string(&buffer[8], 8);\n\tscsi_sanitize_inquiry_string(&buffer[16], 16);\n\n\tdevice->devtype = buffer[0] & 0x1f;\n\tmemcpy(device->vendor, &buffer[8], sizeof(device->vendor));\n\tmemcpy(device->model, &buffer[16], sizeof(device->model));\n\n\tif (device->devtype == TYPE_DISK) {\n\t\tif (device->is_external_raid_device) {\n\t\t\tdevice->raid_level = SA_RAID_UNKNOWN;\n\t\t\tdevice->volume_status = CISS_LV_OK;\n\t\t\tdevice->volume_offline = false;\n\t\t} else {\n\t\t\tpqi_get_raid_level(ctrl_info, device);\n\t\t\tpqi_get_raid_bypass_status(ctrl_info, device);\n\t\t\tpqi_get_volume_status(ctrl_info, device);\n\t\t}\n\t}\n\nout:\n\tkfree(buffer);\n\n\treturn rc;\n}\n\nstatic int pqi_get_device_info(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device,\n\tstruct bmic_identify_physical_device *id_phys)\n{\n\tint rc;\n\n\tif (device->is_expander_smp_device)\n\t\treturn 0;\n\n\tif (pqi_is_logical_device(device))\n\t\trc = pqi_get_logical_device_info(ctrl_info, device);\n\telse\n\t\trc = pqi_get_physical_device_info(ctrl_info, device, id_phys);\n\n\treturn rc;\n}\n\nstatic void pqi_show_volume_status(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device)\n{\n\tchar *status;\n\tstatic const char unknown_state_str[] =\n\t\t\"Volume is in an unknown state (%u)\";\n\tchar unknown_state_buffer[sizeof(unknown_state_str) + 10];\n\n\tswitch (device->volume_status) {\n\tcase CISS_LV_OK:\n\t\tstatus = \"Volume online\";\n\t\tbreak;\n\tcase CISS_LV_FAILED:\n\t\tstatus = \"Volume failed\";\n\t\tbreak;\n\tcase CISS_LV_NOT_CONFIGURED:\n\t\tstatus = \"Volume not configured\";\n\t\tbreak;\n\tcase CISS_LV_DEGRADED:\n\t\tstatus = \"Volume degraded\";\n\t\tbreak;\n\tcase CISS_LV_READY_FOR_RECOVERY:\n\t\tstatus = \"Volume ready for recovery operation\";\n\t\tbreak;\n\tcase CISS_LV_UNDERGOING_RECOVERY:\n\t\tstatus = \"Volume undergoing recovery\";\n\t\tbreak;\n\tcase CISS_LV_WRONG_PHYSICAL_DRIVE_REPLACED:\n\t\tstatus = \"Wrong physical drive was replaced\";\n\t\tbreak;\n\tcase CISS_LV_PHYSICAL_DRIVE_CONNECTION_PROBLEM:\n\t\tstatus = \"A physical drive not properly connected\";\n\t\tbreak;\n\tcase CISS_LV_HARDWARE_OVERHEATING:\n\t\tstatus = \"Hardware is overheating\";\n\t\tbreak;\n\tcase CISS_LV_HARDWARE_HAS_OVERHEATED:\n\t\tstatus = \"Hardware has overheated\";\n\t\tbreak;\n\tcase CISS_LV_UNDERGOING_EXPANSION:\n\t\tstatus = \"Volume undergoing expansion\";\n\t\tbreak;\n\tcase CISS_LV_NOT_AVAILABLE:\n\t\tstatus = \"Volume waiting for transforming volume\";\n\t\tbreak;\n\tcase CISS_LV_QUEUED_FOR_EXPANSION:\n\t\tstatus = \"Volume queued for expansion\";\n\t\tbreak;\n\tcase CISS_LV_DISABLED_SCSI_ID_CONFLICT:\n\t\tstatus = \"Volume disabled due to SCSI ID conflict\";\n\t\tbreak;\n\tcase CISS_LV_EJECTED:\n\t\tstatus = \"Volume has been ejected\";\n\t\tbreak;\n\tcase CISS_LV_UNDERGOING_ERASE:\n\t\tstatus = \"Volume undergoing background erase\";\n\t\tbreak;\n\tcase CISS_LV_READY_FOR_PREDICTIVE_SPARE_REBUILD:\n\t\tstatus = \"Volume ready for predictive spare rebuild\";\n\t\tbreak;\n\tcase CISS_LV_UNDERGOING_RPI:\n\t\tstatus = \"Volume undergoing rapid parity initialization\";\n\t\tbreak;\n\tcase CISS_LV_PENDING_RPI:\n\t\tstatus = \"Volume queued for rapid parity initialization\";\n\t\tbreak;\n\tcase CISS_LV_ENCRYPTED_NO_KEY:\n\t\tstatus = \"Encrypted volume inaccessible - key not present\";\n\t\tbreak;\n\tcase CISS_LV_UNDERGOING_ENCRYPTION:\n\t\tstatus = \"Volume undergoing encryption process\";\n\t\tbreak;\n\tcase CISS_LV_UNDERGOING_ENCRYPTION_REKEYING:\n\t\tstatus = \"Volume undergoing encryption re-keying process\";\n\t\tbreak;\n\tcase CISS_LV_ENCRYPTED_IN_NON_ENCRYPTED_CONTROLLER:\n\t\tstatus = \"Volume encrypted but encryption is disabled\";\n\t\tbreak;\n\tcase CISS_LV_PENDING_ENCRYPTION:\n\t\tstatus = \"Volume pending migration to encrypted state\";\n\t\tbreak;\n\tcase CISS_LV_PENDING_ENCRYPTION_REKEYING:\n\t\tstatus = \"Volume pending encryption rekeying\";\n\t\tbreak;\n\tcase CISS_LV_NOT_SUPPORTED:\n\t\tstatus = \"Volume not supported on this controller\";\n\t\tbreak;\n\tcase CISS_LV_STATUS_UNAVAILABLE:\n\t\tstatus = \"Volume status not available\";\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(unknown_state_buffer, sizeof(unknown_state_buffer),\n\t\t\tunknown_state_str, device->volume_status);\n\t\tstatus = unknown_state_buffer;\n\t\tbreak;\n\t}\n\n\tdev_info(&ctrl_info->pci_dev->dev,\n\t\t\"scsi %d:%d:%d:%d %s\\n\",\n\t\tctrl_info->scsi_host->host_no,\n\t\tdevice->bus, device->target, device->lun, status);\n}\n\nstatic void pqi_rescan_worker(struct work_struct *work)\n{\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tctrl_info = container_of(to_delayed_work(work), struct pqi_ctrl_info,\n\t\trescan_work);\n\n\tpqi_scan_scsi_devices(ctrl_info);\n}\n\nstatic int pqi_add_device(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device)\n{\n\tint rc;\n\n\tif (pqi_is_logical_device(device))\n\t\trc = scsi_add_device(ctrl_info->scsi_host, device->bus,\n\t\t\tdevice->target, device->lun);\n\telse\n\t\trc = pqi_add_sas_device(ctrl_info->sas_host, device);\n\n\treturn rc;\n}\n\n#define PQI_PENDING_IO_TIMEOUT_SECS\t20\n\nstatic inline void pqi_remove_device(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device)\n{\n\tint rc;\n\n\tpqi_device_remove_start(device);\n\n\trc = pqi_device_wait_for_pending_io(ctrl_info, device, PQI_PENDING_IO_TIMEOUT_SECS);\n\tif (rc)\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"scsi %d:%d:%d:%d removing device with %d outstanding command(s)\\n\",\n\t\t\tctrl_info->scsi_host->host_no, device->bus,\n\t\t\tdevice->target, device->lun,\n\t\t\tatomic_read(&device->scsi_cmds_outstanding));\n\n\tif (pqi_is_logical_device(device))\n\t\tscsi_remove_device(device->sdev);\n\telse\n\t\tpqi_remove_sas_device(device);\n}\n\n/* Assumes the SCSI device list lock is held. */\n\nstatic struct pqi_scsi_dev *pqi_find_scsi_dev(struct pqi_ctrl_info *ctrl_info,\n\tint bus, int target, int lun)\n{\n\tstruct pqi_scsi_dev *device;\n\n\tlist_for_each_entry(device, &ctrl_info->scsi_device_list, scsi_device_list_entry)\n\t\tif (device->bus == bus && device->target == target && device->lun == lun)\n\t\t\treturn device;\n\n\treturn NULL;\n}\n\nstatic inline bool pqi_device_equal(struct pqi_scsi_dev *dev1,\n\tstruct pqi_scsi_dev *dev2)\n{\n\tif (dev1->is_physical_device != dev2->is_physical_device)\n\t\treturn false;\n\n\tif (dev1->is_physical_device)\n\t\treturn dev1->wwid == dev2->wwid;\n\n\treturn memcmp(dev1->volume_id, dev2->volume_id,\n\t\tsizeof(dev1->volume_id)) == 0;\n}\n\nenum pqi_find_result {\n\tDEVICE_NOT_FOUND,\n\tDEVICE_CHANGED,\n\tDEVICE_SAME,\n};\n\nstatic enum pqi_find_result pqi_scsi_find_entry(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device_to_find, struct pqi_scsi_dev **matching_device)\n{\n\tstruct pqi_scsi_dev *device;\n\n\tlist_for_each_entry(device, &ctrl_info->scsi_device_list, scsi_device_list_entry) {\n\t\tif (pqi_scsi3addr_equal(device_to_find->scsi3addr, device->scsi3addr)) {\n\t\t\t*matching_device = device;\n\t\t\tif (pqi_device_equal(device_to_find, device)) {\n\t\t\t\tif (device_to_find->volume_offline)\n\t\t\t\t\treturn DEVICE_CHANGED;\n\t\t\t\treturn DEVICE_SAME;\n\t\t\t}\n\t\t\treturn DEVICE_CHANGED;\n\t\t}\n\t}\n\n\treturn DEVICE_NOT_FOUND;\n}\n\nstatic inline const char *pqi_device_type(struct pqi_scsi_dev *device)\n{\n\tif (device->is_expander_smp_device)\n\t\treturn \"Enclosure SMP    \";\n\n\treturn scsi_device_type(device->devtype);\n}\n\n#define PQI_DEV_INFO_BUFFER_LENGTH\t128\n\nstatic void pqi_dev_info(struct pqi_ctrl_info *ctrl_info,\n\tchar *action, struct pqi_scsi_dev *device)\n{\n\tssize_t count;\n\tchar buffer[PQI_DEV_INFO_BUFFER_LENGTH];\n\n\tcount = snprintf(buffer, PQI_DEV_INFO_BUFFER_LENGTH,\n\t\t\"%d:%d:\", ctrl_info->scsi_host->host_no, device->bus);\n\n\tif (device->target_lun_valid)\n\t\tcount += scnprintf(buffer + count,\n\t\t\tPQI_DEV_INFO_BUFFER_LENGTH - count,\n\t\t\t\"%d:%d\",\n\t\t\tdevice->target,\n\t\t\tdevice->lun);\n\telse\n\t\tcount += scnprintf(buffer + count,\n\t\t\tPQI_DEV_INFO_BUFFER_LENGTH - count,\n\t\t\t\"-:-\");\n\n\tif (pqi_is_logical_device(device))\n\t\tcount += scnprintf(buffer + count,\n\t\t\tPQI_DEV_INFO_BUFFER_LENGTH - count,\n\t\t\t\" %08x%08x\",\n\t\t\t*((u32 *)&device->scsi3addr),\n\t\t\t*((u32 *)&device->scsi3addr[4]));\n\telse\n\t\tcount += scnprintf(buffer + count,\n\t\t\tPQI_DEV_INFO_BUFFER_LENGTH - count,\n\t\t\t\" %016llx\", device->sas_address);\n\n\tcount += scnprintf(buffer + count, PQI_DEV_INFO_BUFFER_LENGTH - count,\n\t\t\" %s %.8s %.16s \",\n\t\tpqi_device_type(device),\n\t\tdevice->vendor,\n\t\tdevice->model);\n\n\tif (pqi_is_logical_device(device)) {\n\t\tif (device->devtype == TYPE_DISK)\n\t\t\tcount += scnprintf(buffer + count,\n\t\t\t\tPQI_DEV_INFO_BUFFER_LENGTH - count,\n\t\t\t\t\"SSDSmartPathCap%c En%c %-12s\",\n\t\t\t\tdevice->raid_bypass_configured ? '+' : '-',\n\t\t\t\tdevice->raid_bypass_enabled ? '+' : '-',\n\t\t\t\tpqi_raid_level_to_string(device->raid_level));\n\t} else {\n\t\tcount += scnprintf(buffer + count,\n\t\t\tPQI_DEV_INFO_BUFFER_LENGTH - count,\n\t\t\t\"AIO%c\", device->aio_enabled ? '+' : '-');\n\t\tif (device->devtype == TYPE_DISK ||\n\t\t\tdevice->devtype == TYPE_ZBC)\n\t\t\tcount += scnprintf(buffer + count,\n\t\t\t\tPQI_DEV_INFO_BUFFER_LENGTH - count,\n\t\t\t\t\" qd=%-6d\", device->queue_depth);\n\t}\n\n\tdev_info(&ctrl_info->pci_dev->dev, \"%s %s\\n\", action, buffer);\n}\n\n/* Assumes the SCSI device list lock is held. */\n\nstatic void pqi_scsi_update_device(struct pqi_scsi_dev *existing_device,\n\tstruct pqi_scsi_dev *new_device)\n{\n\texisting_device->devtype = new_device->devtype;\n\texisting_device->device_type = new_device->device_type;\n\texisting_device->bus = new_device->bus;\n\tif (new_device->target_lun_valid) {\n\t\texisting_device->target = new_device->target;\n\t\texisting_device->lun = new_device->lun;\n\t\texisting_device->target_lun_valid = true;\n\t}\n\n\tif ((existing_device->volume_status == CISS_LV_QUEUED_FOR_EXPANSION ||\n\t\texisting_device->volume_status == CISS_LV_UNDERGOING_EXPANSION) &&\n\t\tnew_device->volume_status == CISS_LV_OK)\n\t\texisting_device->rescan = true;\n\n\t/* By definition, the scsi3addr and wwid fields are already the same. */\n\n\texisting_device->is_physical_device = new_device->is_physical_device;\n\texisting_device->is_external_raid_device =\n\t\tnew_device->is_external_raid_device;\n\texisting_device->is_expander_smp_device =\n\t\tnew_device->is_expander_smp_device;\n\texisting_device->aio_enabled = new_device->aio_enabled;\n\tmemcpy(existing_device->vendor, new_device->vendor,\n\t\tsizeof(existing_device->vendor));\n\tmemcpy(existing_device->model, new_device->model,\n\t\tsizeof(existing_device->model));\n\texisting_device->sas_address = new_device->sas_address;\n\texisting_device->raid_level = new_device->raid_level;\n\texisting_device->queue_depth = new_device->queue_depth;\n\texisting_device->aio_handle = new_device->aio_handle;\n\texisting_device->volume_status = new_device->volume_status;\n\texisting_device->active_path_index = new_device->active_path_index;\n\texisting_device->path_map = new_device->path_map;\n\texisting_device->bay = new_device->bay;\n\texisting_device->box_index = new_device->box_index;\n\texisting_device->phys_box_on_bus = new_device->phys_box_on_bus;\n\texisting_device->phy_connected_dev_type =\n\t\tnew_device->phy_connected_dev_type;\n\tmemcpy(existing_device->box, new_device->box,\n\t\tsizeof(existing_device->box));\n\tmemcpy(existing_device->phys_connector, new_device->phys_connector,\n\t\tsizeof(existing_device->phys_connector));\n\texisting_device->offload_to_mirror = 0;\n\tkfree(existing_device->raid_map);\n\texisting_device->raid_map = new_device->raid_map;\n\texisting_device->raid_bypass_configured =\n\t\tnew_device->raid_bypass_configured;\n\texisting_device->raid_bypass_enabled =\n\t\tnew_device->raid_bypass_enabled;\n\texisting_device->device_offline = false;\n\n\t/* To prevent this from being freed later. */\n\tnew_device->raid_map = NULL;\n}\n\nstatic inline void pqi_free_device(struct pqi_scsi_dev *device)\n{\n\tif (device) {\n\t\tkfree(device->raid_map);\n\t\tkfree(device);\n\t}\n}\n\n/*\n * Called when exposing a new device to the OS fails in order to re-adjust\n * our internal SCSI device list to match the SCSI ML's view.\n */\n\nstatic inline void pqi_fixup_botched_add(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctrl_info->scsi_device_list_lock, flags);\n\tlist_del(&device->scsi_device_list_entry);\n\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\n\t/* Allow the device structure to be freed later. */\n\tdevice->keep_device = false;\n}\n\nstatic inline bool pqi_is_device_added(struct pqi_scsi_dev *device)\n{\n\tif (device->is_expander_smp_device)\n\t\treturn device->sas_port != NULL;\n\n\treturn device->sdev != NULL;\n}\n\nstatic void pqi_update_device_list(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *new_device_list[], unsigned int num_new_devices)\n{\n\tint rc;\n\tunsigned int i;\n\tunsigned long flags;\n\tenum pqi_find_result find_result;\n\tstruct pqi_scsi_dev *device;\n\tstruct pqi_scsi_dev *next;\n\tstruct pqi_scsi_dev *matching_device;\n\tLIST_HEAD(add_list);\n\tLIST_HEAD(delete_list);\n\n\t/*\n\t * The idea here is to do as little work as possible while holding the\n\t * spinlock.  That's why we go to great pains to defer anything other\n\t * than updating the internal device list until after we release the\n\t * spinlock.\n\t */\n\n\tspin_lock_irqsave(&ctrl_info->scsi_device_list_lock, flags);\n\n\t/* Assume that all devices in the existing list have gone away. */\n\tlist_for_each_entry(device, &ctrl_info->scsi_device_list, scsi_device_list_entry)\n\t\tdevice->device_gone = true;\n\n\tfor (i = 0; i < num_new_devices; i++) {\n\t\tdevice = new_device_list[i];\n\n\t\tfind_result = pqi_scsi_find_entry(ctrl_info, device,\n\t\t\t&matching_device);\n\n\t\tswitch (find_result) {\n\t\tcase DEVICE_SAME:\n\t\t\t/*\n\t\t\t * The newly found device is already in the existing\n\t\t\t * device list.\n\t\t\t */\n\t\t\tdevice->new_device = false;\n\t\t\tmatching_device->device_gone = false;\n\t\t\tpqi_scsi_update_device(matching_device, device);\n\t\t\tbreak;\n\t\tcase DEVICE_NOT_FOUND:\n\t\t\t/*\n\t\t\t * The newly found device is NOT in the existing device\n\t\t\t * list.\n\t\t\t */\n\t\t\tdevice->new_device = true;\n\t\t\tbreak;\n\t\tcase DEVICE_CHANGED:\n\t\t\t/*\n\t\t\t * The original device has gone away and we need to add\n\t\t\t * the new device.\n\t\t\t */\n\t\t\tdevice->new_device = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Process all devices that have gone away. */\n\tlist_for_each_entry_safe(device, next, &ctrl_info->scsi_device_list,\n\t\tscsi_device_list_entry) {\n\t\tif (device->device_gone) {\n\t\t\tlist_del_init(&device->scsi_device_list_entry);\n\t\t\tlist_add_tail(&device->delete_list_entry, &delete_list);\n\t\t}\n\t}\n\n\t/* Process all new devices. */\n\tfor (i = 0; i < num_new_devices; i++) {\n\t\tdevice = new_device_list[i];\n\t\tif (!device->new_device)\n\t\t\tcontinue;\n\t\tif (device->volume_offline)\n\t\t\tcontinue;\n\t\tlist_add_tail(&device->scsi_device_list_entry,\n\t\t\t&ctrl_info->scsi_device_list);\n\t\tlist_add_tail(&device->add_list_entry, &add_list);\n\t\t/* To prevent this device structure from being freed later. */\n\t\tdevice->keep_device = true;\n\t}\n\n\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\n\tif (pqi_ctrl_in_ofa(ctrl_info))\n\t\tpqi_ctrl_ofa_done(ctrl_info);\n\n\t/* Remove all devices that have gone away. */\n\tlist_for_each_entry_safe(device, next, &delete_list, delete_list_entry) {\n\t\tif (device->volume_offline) {\n\t\t\tpqi_dev_info(ctrl_info, \"offline\", device);\n\t\t\tpqi_show_volume_status(ctrl_info, device);\n\t\t}\n\t\tlist_del(&device->delete_list_entry);\n\t\tif (pqi_is_device_added(device)) {\n\t\t\tpqi_remove_device(ctrl_info, device);\n\t\t} else {\n\t\t\tif (!device->volume_offline)\n\t\t\t\tpqi_dev_info(ctrl_info, \"removed\", device);\n\t\t\tpqi_free_device(device);\n\t\t}\n\t}\n\n\t/*\n\t * Notify the SCSI ML if the queue depth of any existing device has\n\t * changed.\n\t */\n\tlist_for_each_entry(device, &ctrl_info->scsi_device_list,\n\t\tscsi_device_list_entry) {\n\t\tif (device->sdev) {\n\t\t\tif (device->queue_depth !=\n\t\t\t\tdevice->advertised_queue_depth) {\n\t\t\t\tdevice->advertised_queue_depth = device->queue_depth;\n\t\t\t\tscsi_change_queue_depth(device->sdev,\n\t\t\t\t\tdevice->advertised_queue_depth);\n\t\t\t}\n\t\t\tif (device->rescan) {\n\t\t\t\tscsi_rescan_device(&device->sdev->sdev_gendev);\n\t\t\t\tdevice->rescan = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Expose any new devices. */\n\tlist_for_each_entry_safe(device, next, &add_list, add_list_entry) {\n\t\tif (!pqi_is_device_added(device)) {\n\t\t\trc = pqi_add_device(ctrl_info, device);\n\t\t\tif (rc == 0) {\n\t\t\t\tpqi_dev_info(ctrl_info, \"added\", device);\n\t\t\t} else {\n\t\t\t\tdev_warn(&ctrl_info->pci_dev->dev,\n\t\t\t\t\t\"scsi %d:%d:%d:%d addition failed, device not added\\n\",\n\t\t\t\t\tctrl_info->scsi_host->host_no,\n\t\t\t\t\tdevice->bus, device->target,\n\t\t\t\t\tdevice->lun);\n\t\t\t\tpqi_fixup_botched_add(ctrl_info, device);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic inline bool pqi_is_supported_device(struct pqi_scsi_dev *device)\n{\n\t/*\n\t * Only support the HBA controller itself as a RAID\n\t * controller.  If it's a RAID controller other than\n\t * the HBA itself (an external RAID controller, for\n\t * example), we don't support it.\n\t */\n\tif (device->device_type == SA_DEVICE_TYPE_CONTROLLER &&\n\t\t!pqi_is_hba_lunid(device->scsi3addr))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline bool pqi_skip_device(u8 *scsi3addr)\n{\n\t/* Ignore all masked devices. */\n\tif (MASKED_DEVICE(scsi3addr))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline void pqi_mask_device(u8 *scsi3addr)\n{\n\tscsi3addr[3] |= 0xc0;\n}\n\nstatic inline bool pqi_is_device_with_sas_address(struct pqi_scsi_dev *device)\n{\n\tswitch (device->device_type) {\n\tcase SA_DEVICE_TYPE_SAS:\n\tcase SA_DEVICE_TYPE_EXPANDER_SMP:\n\tcase SA_DEVICE_TYPE_SES:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic inline bool pqi_expose_device(struct pqi_scsi_dev *device)\n{\n\treturn !device->is_physical_device ||\n\t\t!pqi_skip_device(device->scsi3addr);\n}\n\nstatic int pqi_update_scsi_devices(struct pqi_ctrl_info *ctrl_info)\n{\n\tint i;\n\tint rc;\n\tLIST_HEAD(new_device_list_head);\n\tstruct report_phys_lun_extended *physdev_list = NULL;\n\tstruct report_log_lun_extended *logdev_list = NULL;\n\tstruct report_phys_lun_extended_entry *phys_lun_ext_entry;\n\tstruct report_log_lun_extended_entry *log_lun_ext_entry;\n\tstruct bmic_identify_physical_device *id_phys = NULL;\n\tu32 num_physicals;\n\tu32 num_logicals;\n\tstruct pqi_scsi_dev **new_device_list = NULL;\n\tstruct pqi_scsi_dev *device;\n\tstruct pqi_scsi_dev *next;\n\tunsigned int num_new_devices;\n\tunsigned int num_valid_devices;\n\tbool is_physical_device;\n\tu8 *scsi3addr;\n\tunsigned int physical_index;\n\tunsigned int logical_index;\n\tstatic char *out_of_memory_msg =\n\t\t\"failed to allocate memory, device discovery stopped\";\n\n\trc = pqi_get_device_lists(ctrl_info, &physdev_list, &logdev_list);\n\tif (rc)\n\t\tgoto out;\n\n\tif (physdev_list)\n\t\tnum_physicals =\n\t\t\tget_unaligned_be32(&physdev_list->header.list_length)\n\t\t\t\t/ sizeof(physdev_list->lun_entries[0]);\n\telse\n\t\tnum_physicals = 0;\n\n\tif (logdev_list)\n\t\tnum_logicals =\n\t\t\tget_unaligned_be32(&logdev_list->header.list_length)\n\t\t\t\t/ sizeof(logdev_list->lun_entries[0]);\n\telse\n\t\tnum_logicals = 0;\n\n\tif (num_physicals) {\n\t\t/*\n\t\t * We need this buffer for calls to pqi_get_physical_disk_info()\n\t\t * below.  We allocate it here instead of inside\n\t\t * pqi_get_physical_disk_info() because it's a fairly large\n\t\t * buffer.\n\t\t */\n\t\tid_phys = kmalloc(sizeof(*id_phys), GFP_KERNEL);\n\t\tif (!id_phys) {\n\t\t\tdev_warn(&ctrl_info->pci_dev->dev, \"%s\\n\",\n\t\t\t\tout_of_memory_msg);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (pqi_hide_vsep) {\n\t\t\tfor (i = num_physicals - 1; i >= 0; i--) {\n\t\t\t\tphys_lun_ext_entry =\n\t\t\t\t\t\t&physdev_list->lun_entries[i];\n\t\t\t\tif (CISS_GET_DRIVE_NUMBER(\n\t\t\t\t\tphys_lun_ext_entry->lunid) ==\n\t\t\t\t\t\tPQI_VSEP_CISS_BTL) {\n\t\t\t\t\tpqi_mask_device(\n\t\t\t\t\t\tphys_lun_ext_entry->lunid);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tnum_new_devices = num_physicals + num_logicals;\n\n\tnew_device_list = kmalloc_array(num_new_devices,\n\t\t\t\t\tsizeof(*new_device_list),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!new_device_list) {\n\t\tdev_warn(&ctrl_info->pci_dev->dev, \"%s\\n\", out_of_memory_msg);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num_new_devices; i++) {\n\t\tdevice = kzalloc(sizeof(*device), GFP_KERNEL);\n\t\tif (!device) {\n\t\t\tdev_warn(&ctrl_info->pci_dev->dev, \"%s\\n\",\n\t\t\t\tout_of_memory_msg);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tlist_add_tail(&device->new_device_list_entry,\n\t\t\t&new_device_list_head);\n\t}\n\n\tdevice = NULL;\n\tnum_valid_devices = 0;\n\tphysical_index = 0;\n\tlogical_index = 0;\n\n\tfor (i = 0; i < num_new_devices; i++) {\n\n\t\tif ((!pqi_expose_ld_first && i < num_physicals) ||\n\t\t\t(pqi_expose_ld_first && i >= num_logicals)) {\n\t\t\tis_physical_device = true;\n\t\t\tphys_lun_ext_entry =\n\t\t\t\t&physdev_list->lun_entries[physical_index++];\n\t\t\tlog_lun_ext_entry = NULL;\n\t\t\tscsi3addr = phys_lun_ext_entry->lunid;\n\t\t} else {\n\t\t\tis_physical_device = false;\n\t\t\tphys_lun_ext_entry = NULL;\n\t\t\tlog_lun_ext_entry =\n\t\t\t\t&logdev_list->lun_entries[logical_index++];\n\t\t\tscsi3addr = log_lun_ext_entry->lunid;\n\t\t}\n\n\t\tif (is_physical_device && pqi_skip_device(scsi3addr))\n\t\t\tcontinue;\n\n\t\tif (device)\n\t\t\tdevice = list_next_entry(device, new_device_list_entry);\n\t\telse\n\t\t\tdevice = list_first_entry(&new_device_list_head,\n\t\t\t\tstruct pqi_scsi_dev, new_device_list_entry);\n\n\t\tmemcpy(device->scsi3addr, scsi3addr, sizeof(device->scsi3addr));\n\t\tdevice->is_physical_device = is_physical_device;\n\t\tif (is_physical_device) {\n\t\t\tdevice->device_type = phys_lun_ext_entry->device_type;\n\t\t\tif (device->device_type == SA_DEVICE_TYPE_EXPANDER_SMP)\n\t\t\t\tdevice->is_expander_smp_device = true;\n\t\t} else {\n\t\t\tdevice->is_external_raid_device =\n\t\t\t\tpqi_is_external_raid_addr(scsi3addr);\n\t\t}\n\n\t\tif (!pqi_is_supported_device(device))\n\t\t\tcontinue;\n\n\t\t/* Gather information about the device. */\n\t\trc = pqi_get_device_info(ctrl_info, device, id_phys);\n\t\tif (rc == -ENOMEM) {\n\t\t\tdev_warn(&ctrl_info->pci_dev->dev, \"%s\\n\",\n\t\t\t\tout_of_memory_msg);\n\t\t\tgoto out;\n\t\t}\n\t\tif (rc) {\n\t\t\tif (device->is_physical_device)\n\t\t\t\tdev_warn(&ctrl_info->pci_dev->dev,\n\t\t\t\t\t\"obtaining device info failed, skipping physical device %016llx\\n\",\n\t\t\t\t\tget_unaligned_be64(\n\t\t\t\t\t\t&phys_lun_ext_entry->wwid));\n\t\t\telse\n\t\t\t\tdev_warn(&ctrl_info->pci_dev->dev,\n\t\t\t\t\t\"obtaining device info failed, skipping logical device %08x%08x\\n\",\n\t\t\t\t\t*((u32 *)&device->scsi3addr),\n\t\t\t\t\t*((u32 *)&device->scsi3addr[4]));\n\t\t\trc = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpqi_assign_bus_target_lun(device);\n\n\t\tif (device->is_physical_device) {\n\t\t\tdevice->wwid = phys_lun_ext_entry->wwid;\n\t\t\tif ((phys_lun_ext_entry->device_flags &\n\t\t\t\tCISS_REPORT_PHYS_DEV_FLAG_AIO_ENABLED) &&\n\t\t\t\tphys_lun_ext_entry->aio_handle) {\n\t\t\t\tdevice->aio_enabled = true;\n\t\t\t\tdevice->aio_handle =\n\t\t\t\t\tphys_lun_ext_entry->aio_handle;\n\t\t\t}\n\t\t} else {\n\t\t\tmemcpy(device->volume_id, log_lun_ext_entry->volume_id,\n\t\t\t\tsizeof(device->volume_id));\n\t\t}\n\n\t\tif (pqi_is_device_with_sas_address(device))\n\t\t\tdevice->sas_address = get_unaligned_be64(&device->wwid);\n\n\t\tnew_device_list[num_valid_devices++] = device;\n\t}\n\n\tpqi_update_device_list(ctrl_info, new_device_list, num_valid_devices);\n\nout:\n\tlist_for_each_entry_safe(device, next, &new_device_list_head,\n\t\tnew_device_list_entry) {\n\t\tif (device->keep_device)\n\t\t\tcontinue;\n\t\tlist_del(&device->new_device_list_entry);\n\t\tpqi_free_device(device);\n\t}\n\n\tkfree(new_device_list);\n\tkfree(physdev_list);\n\tkfree(logdev_list);\n\tkfree(id_phys);\n\n\treturn rc;\n}\n\nstatic int pqi_scan_scsi_devices(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc = 0;\n\n\tif (pqi_ctrl_offline(ctrl_info))\n\t\treturn -ENXIO;\n\n\tif (!mutex_trylock(&ctrl_info->scan_mutex)) {\n\t\tpqi_schedule_rescan_worker_delayed(ctrl_info);\n\t\trc = -EINPROGRESS;\n\t} else {\n\t\trc = pqi_update_scsi_devices(ctrl_info);\n\t\tif (rc)\n\t\t\tpqi_schedule_rescan_worker_delayed(ctrl_info);\n\t\tmutex_unlock(&ctrl_info->scan_mutex);\n\t}\n\n\treturn rc;\n}\n\nstatic void pqi_scan_start(struct Scsi_Host *shost)\n{\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tctrl_info = shost_to_hba(shost);\n\tif (pqi_ctrl_in_ofa(ctrl_info))\n\t\treturn;\n\n\tpqi_scan_scsi_devices(ctrl_info);\n}\n\n/* Returns TRUE if scan is finished. */\n\nstatic int pqi_scan_finished(struct Scsi_Host *shost,\n\tunsigned long elapsed_time)\n{\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tctrl_info = shost_priv(shost);\n\n\treturn !mutex_is_locked(&ctrl_info->scan_mutex);\n}\n\nstatic void pqi_wait_until_scan_finished(struct pqi_ctrl_info *ctrl_info)\n{\n\tmutex_lock(&ctrl_info->scan_mutex);\n\tmutex_unlock(&ctrl_info->scan_mutex);\n}\n\nstatic void pqi_wait_until_lun_reset_finished(struct pqi_ctrl_info *ctrl_info)\n{\n\tmutex_lock(&ctrl_info->lun_reset_mutex);\n\tmutex_unlock(&ctrl_info->lun_reset_mutex);\n}\n\nstatic void pqi_wait_until_ofa_finished(struct pqi_ctrl_info *ctrl_info)\n{\n\tmutex_lock(&ctrl_info->ofa_mutex);\n\tmutex_unlock(&ctrl_info->ofa_mutex);\n}\n\nstatic inline void pqi_set_encryption_info(\n\tstruct pqi_encryption_info *encryption_info, struct raid_map *raid_map,\n\tu64 first_block)\n{\n\tu32 volume_blk_size;\n\n\t/*\n\t * Set the encryption tweak values based on logical block address.\n\t * If the block size is 512, the tweak value is equal to the LBA.\n\t * For other block sizes, tweak value is (LBA * block size) / 512.\n\t */\n\tvolume_blk_size = get_unaligned_le32(&raid_map->volume_blk_size);\n\tif (volume_blk_size != 512)\n\t\tfirst_block = (first_block * volume_blk_size) / 512;\n\n\tencryption_info->data_encryption_key_index =\n\t\tget_unaligned_le16(&raid_map->data_encryption_key_index);\n\tencryption_info->encrypt_tweak_lower = lower_32_bits(first_block);\n\tencryption_info->encrypt_tweak_upper = upper_32_bits(first_block);\n}\n\n/*\n * Attempt to perform RAID bypass mapping for a logical volume I/O.\n */\n\n#define PQI_RAID_BYPASS_INELIGIBLE\t1\n\nstatic int pqi_raid_bypass_submit_scsi_cmd(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device, struct scsi_cmnd *scmd,\n\tstruct pqi_queue_group *queue_group)\n{\n\tstruct raid_map *raid_map;\n\tbool is_write = false;\n\tu32 map_index;\n\tu64 first_block;\n\tu64 last_block;\n\tu32 block_cnt;\n\tu32 blocks_per_row;\n\tu64 first_row;\n\tu64 last_row;\n\tu32 first_row_offset;\n\tu32 last_row_offset;\n\tu32 first_column;\n\tu32 last_column;\n\tu64 r0_first_row;\n\tu64 r0_last_row;\n\tu32 r5or6_blocks_per_row;\n\tu64 r5or6_first_row;\n\tu64 r5or6_last_row;\n\tu32 r5or6_first_row_offset;\n\tu32 r5or6_last_row_offset;\n\tu32 r5or6_first_column;\n\tu32 r5or6_last_column;\n\tu16 data_disks_per_row;\n\tu32 total_disks_per_row;\n\tu16 layout_map_count;\n\tu32 stripesize;\n\tu16 strip_size;\n\tu32 first_group;\n\tu32 last_group;\n\tu32 current_group;\n\tu32 map_row;\n\tu32 aio_handle;\n\tu64 disk_block;\n\tu32 disk_block_cnt;\n\tu8 cdb[16];\n\tu8 cdb_length;\n\tint offload_to_mirror;\n\tstruct pqi_encryption_info *encryption_info_ptr;\n\tstruct pqi_encryption_info encryption_info;\n#if BITS_PER_LONG == 32\n\tu64 tmpdiv;\n#endif\n\n\t/* Check for valid opcode, get LBA and block count. */\n\tswitch (scmd->cmnd[0]) {\n\tcase WRITE_6:\n\t\tis_write = true;\n\t\tfallthrough;\n\tcase READ_6:\n\t\tfirst_block = (u64)(((scmd->cmnd[1] & 0x1f) << 16) |\n\t\t\t(scmd->cmnd[2] << 8) | scmd->cmnd[3]);\n\t\tblock_cnt = (u32)scmd->cmnd[4];\n\t\tif (block_cnt == 0)\n\t\t\tblock_cnt = 256;\n\t\tbreak;\n\tcase WRITE_10:\n\t\tis_write = true;\n\t\tfallthrough;\n\tcase READ_10:\n\t\tfirst_block = (u64)get_unaligned_be32(&scmd->cmnd[2]);\n\t\tblock_cnt = (u32)get_unaligned_be16(&scmd->cmnd[7]);\n\t\tbreak;\n\tcase WRITE_12:\n\t\tis_write = true;\n\t\tfallthrough;\n\tcase READ_12:\n\t\tfirst_block = (u64)get_unaligned_be32(&scmd->cmnd[2]);\n\t\tblock_cnt = get_unaligned_be32(&scmd->cmnd[6]);\n\t\tbreak;\n\tcase WRITE_16:\n\t\tis_write = true;\n\t\tfallthrough;\n\tcase READ_16:\n\t\tfirst_block = get_unaligned_be64(&scmd->cmnd[2]);\n\t\tblock_cnt = get_unaligned_be32(&scmd->cmnd[10]);\n\t\tbreak;\n\tdefault:\n\t\t/* Process via normal I/O path. */\n\t\treturn PQI_RAID_BYPASS_INELIGIBLE;\n\t}\n\n\t/* Check for write to non-RAID-0. */\n\tif (is_write && device->raid_level != SA_RAID_0)\n\t\treturn PQI_RAID_BYPASS_INELIGIBLE;\n\n\tif (unlikely(block_cnt == 0))\n\t\treturn PQI_RAID_BYPASS_INELIGIBLE;\n\n\tlast_block = first_block + block_cnt - 1;\n\traid_map = device->raid_map;\n\n\t/* Check for invalid block or wraparound. */\n\tif (last_block >= get_unaligned_le64(&raid_map->volume_blk_cnt) ||\n\t\tlast_block < first_block)\n\t\treturn PQI_RAID_BYPASS_INELIGIBLE;\n\n\tdata_disks_per_row = get_unaligned_le16(&raid_map->data_disks_per_row);\n\tstrip_size = get_unaligned_le16(&raid_map->strip_size);\n\tlayout_map_count = get_unaligned_le16(&raid_map->layout_map_count);\n\n\t/* Calculate stripe information for the request. */\n\tblocks_per_row = data_disks_per_row * strip_size;\n#if BITS_PER_LONG == 32\n\ttmpdiv = first_block;\n\tdo_div(tmpdiv, blocks_per_row);\n\tfirst_row = tmpdiv;\n\ttmpdiv = last_block;\n\tdo_div(tmpdiv, blocks_per_row);\n\tlast_row = tmpdiv;\n\tfirst_row_offset = (u32)(first_block - (first_row * blocks_per_row));\n\tlast_row_offset = (u32)(last_block - (last_row * blocks_per_row));\n\ttmpdiv = first_row_offset;\n\tdo_div(tmpdiv, strip_size);\n\tfirst_column = tmpdiv;\n\ttmpdiv = last_row_offset;\n\tdo_div(tmpdiv, strip_size);\n\tlast_column = tmpdiv;\n#else\n\tfirst_row = first_block / blocks_per_row;\n\tlast_row = last_block / blocks_per_row;\n\tfirst_row_offset = (u32)(first_block - (first_row * blocks_per_row));\n\tlast_row_offset = (u32)(last_block - (last_row * blocks_per_row));\n\tfirst_column = first_row_offset / strip_size;\n\tlast_column = last_row_offset / strip_size;\n#endif\n\n\t/* If this isn't a single row/column then give to the controller. */\n\tif (first_row != last_row || first_column != last_column)\n\t\treturn PQI_RAID_BYPASS_INELIGIBLE;\n\n\t/* Proceeding with driver mapping. */\n\ttotal_disks_per_row = data_disks_per_row +\n\t\tget_unaligned_le16(&raid_map->metadata_disks_per_row);\n\tmap_row = ((u32)(first_row >> raid_map->parity_rotation_shift)) %\n\t\tget_unaligned_le16(&raid_map->row_cnt);\n\tmap_index = (map_row * total_disks_per_row) + first_column;\n\n\t/* RAID 1 */\n\tif (device->raid_level == SA_RAID_1) {\n\t\tif (device->offload_to_mirror)\n\t\t\tmap_index += data_disks_per_row;\n\t\tdevice->offload_to_mirror = !device->offload_to_mirror;\n\t} else if (device->raid_level == SA_RAID_ADM) {\n\t\t/* RAID ADM */\n\t\t/*\n\t\t * Handles N-way mirrors  (R1-ADM) and R10 with # of drives\n\t\t * divisible by 3.\n\t\t */\n\t\toffload_to_mirror = device->offload_to_mirror;\n\t\tif (offload_to_mirror == 0)  {\n\t\t\t/* use physical disk in the first mirrored group. */\n\t\t\tmap_index %= data_disks_per_row;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\t/*\n\t\t\t\t * Determine mirror group that map_index\n\t\t\t\t * indicates.\n\t\t\t\t */\n\t\t\t\tcurrent_group = map_index / data_disks_per_row;\n\n\t\t\t\tif (offload_to_mirror != current_group) {\n\t\t\t\t\tif (current_group <\n\t\t\t\t\t\tlayout_map_count - 1) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Select raid index from\n\t\t\t\t\t\t * next group.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tmap_index += data_disks_per_row;\n\t\t\t\t\t\tcurrent_group++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Select raid index from first\n\t\t\t\t\t\t * group.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tmap_index %= data_disks_per_row;\n\t\t\t\t\t\tcurrent_group = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (offload_to_mirror != current_group);\n\t\t}\n\n\t\t/* Set mirror group to use next time. */\n\t\toffload_to_mirror =\n\t\t\t(offload_to_mirror >= layout_map_count - 1) ?\n\t\t\t\t0 : offload_to_mirror + 1;\n\t\tdevice->offload_to_mirror = offload_to_mirror;\n\t\t/*\n\t\t * Avoid direct use of device->offload_to_mirror within this\n\t\t * function since multiple threads might simultaneously\n\t\t * increment it beyond the range of device->layout_map_count -1.\n\t\t */\n\t} else if ((device->raid_level == SA_RAID_5 ||\n\t\tdevice->raid_level == SA_RAID_6) && layout_map_count > 1) {\n\t\t/* RAID 50/60 */\n\t\t/* Verify first and last block are in same RAID group */\n\t\tr5or6_blocks_per_row = strip_size * data_disks_per_row;\n\t\tstripesize = r5or6_blocks_per_row * layout_map_count;\n#if BITS_PER_LONG == 32\n\t\ttmpdiv = first_block;\n\t\tfirst_group = do_div(tmpdiv, stripesize);\n\t\ttmpdiv = first_group;\n\t\tdo_div(tmpdiv, r5or6_blocks_per_row);\n\t\tfirst_group = tmpdiv;\n\t\ttmpdiv = last_block;\n\t\tlast_group = do_div(tmpdiv, stripesize);\n\t\ttmpdiv = last_group;\n\t\tdo_div(tmpdiv, r5or6_blocks_per_row);\n\t\tlast_group = tmpdiv;\n#else\n\t\tfirst_group = (first_block % stripesize) / r5or6_blocks_per_row;\n\t\tlast_group = (last_block % stripesize) / r5or6_blocks_per_row;\n#endif\n\t\tif (first_group != last_group)\n\t\t\treturn PQI_RAID_BYPASS_INELIGIBLE;\n\n\t\t/* Verify request is in a single row of RAID 5/6 */\n#if BITS_PER_LONG == 32\n\t\ttmpdiv = first_block;\n\t\tdo_div(tmpdiv, stripesize);\n\t\tfirst_row = r5or6_first_row = r0_first_row = tmpdiv;\n\t\ttmpdiv = last_block;\n\t\tdo_div(tmpdiv, stripesize);\n\t\tr5or6_last_row = r0_last_row = tmpdiv;\n#else\n\t\tfirst_row = r5or6_first_row = r0_first_row =\n\t\t\tfirst_block / stripesize;\n\t\tr5or6_last_row = r0_last_row = last_block / stripesize;\n#endif\n\t\tif (r5or6_first_row != r5or6_last_row)\n\t\t\treturn PQI_RAID_BYPASS_INELIGIBLE;\n\n\t\t/* Verify request is in a single column */\n#if BITS_PER_LONG == 32\n\t\ttmpdiv = first_block;\n\t\tfirst_row_offset = do_div(tmpdiv, stripesize);\n\t\ttmpdiv = first_row_offset;\n\t\tfirst_row_offset = (u32)do_div(tmpdiv, r5or6_blocks_per_row);\n\t\tr5or6_first_row_offset = first_row_offset;\n\t\ttmpdiv = last_block;\n\t\tr5or6_last_row_offset = do_div(tmpdiv, stripesize);\n\t\ttmpdiv = r5or6_last_row_offset;\n\t\tr5or6_last_row_offset = do_div(tmpdiv, r5or6_blocks_per_row);\n\t\ttmpdiv = r5or6_first_row_offset;\n\t\tdo_div(tmpdiv, strip_size);\n\t\tfirst_column = r5or6_first_column = tmpdiv;\n\t\ttmpdiv = r5or6_last_row_offset;\n\t\tdo_div(tmpdiv, strip_size);\n\t\tr5or6_last_column = tmpdiv;\n#else\n\t\tfirst_row_offset = r5or6_first_row_offset =\n\t\t\t(u32)((first_block % stripesize) %\n\t\t\tr5or6_blocks_per_row);\n\n\t\tr5or6_last_row_offset =\n\t\t\t(u32)((last_block % stripesize) %\n\t\t\tr5or6_blocks_per_row);\n\n\t\tfirst_column = r5or6_first_row_offset / strip_size;\n\t\tr5or6_first_column = first_column;\n\t\tr5or6_last_column = r5or6_last_row_offset / strip_size;\n#endif\n\t\tif (r5or6_first_column != r5or6_last_column)\n\t\t\treturn PQI_RAID_BYPASS_INELIGIBLE;\n\n\t\t/* Request is eligible */\n\t\tmap_row =\n\t\t\t((u32)(first_row >> raid_map->parity_rotation_shift)) %\n\t\t\tget_unaligned_le16(&raid_map->row_cnt);\n\n\t\tmap_index = (first_group *\n\t\t\t(get_unaligned_le16(&raid_map->row_cnt) *\n\t\t\ttotal_disks_per_row)) +\n\t\t\t(map_row * total_disks_per_row) + first_column;\n\t}\n\n\taio_handle = raid_map->disk_data[map_index].aio_handle;\n\tdisk_block = get_unaligned_le64(&raid_map->disk_starting_blk) +\n\t\tfirst_row * strip_size +\n\t\t(first_row_offset - first_column * strip_size);\n\tdisk_block_cnt = block_cnt;\n\n\t/* Handle differing logical/physical block sizes. */\n\tif (raid_map->phys_blk_shift) {\n\t\tdisk_block <<= raid_map->phys_blk_shift;\n\t\tdisk_block_cnt <<= raid_map->phys_blk_shift;\n\t}\n\n\tif (unlikely(disk_block_cnt > 0xffff))\n\t\treturn PQI_RAID_BYPASS_INELIGIBLE;\n\n\t/* Build the new CDB for the physical disk I/O. */\n\tif (disk_block > 0xffffffff) {\n\t\tcdb[0] = is_write ? WRITE_16 : READ_16;\n\t\tcdb[1] = 0;\n\t\tput_unaligned_be64(disk_block, &cdb[2]);\n\t\tput_unaligned_be32(disk_block_cnt, &cdb[10]);\n\t\tcdb[14] = 0;\n\t\tcdb[15] = 0;\n\t\tcdb_length = 16;\n\t} else {\n\t\tcdb[0] = is_write ? WRITE_10 : READ_10;\n\t\tcdb[1] = 0;\n\t\tput_unaligned_be32((u32)disk_block, &cdb[2]);\n\t\tcdb[6] = 0;\n\t\tput_unaligned_be16((u16)disk_block_cnt, &cdb[7]);\n\t\tcdb[9] = 0;\n\t\tcdb_length = 10;\n\t}\n\n\tif (get_unaligned_le16(&raid_map->flags) &\n\t\tRAID_MAP_ENCRYPTION_ENABLED) {\n\t\tpqi_set_encryption_info(&encryption_info, raid_map,\n\t\t\tfirst_block);\n\t\tencryption_info_ptr = &encryption_info;\n\t} else {\n\t\tencryption_info_ptr = NULL;\n\t}\n\n\treturn pqi_aio_submit_io(ctrl_info, scmd, aio_handle,\n\t\tcdb, cdb_length, queue_group, encryption_info_ptr, true);\n}\n\n#define PQI_STATUS_IDLE\t\t0x0\n\n#define PQI_CREATE_ADMIN_QUEUE_PAIR\t1\n#define PQI_DELETE_ADMIN_QUEUE_PAIR\t2\n\n#define PQI_DEVICE_STATE_POWER_ON_AND_RESET\t\t0x0\n#define PQI_DEVICE_STATE_STATUS_AVAILABLE\t\t0x1\n#define PQI_DEVICE_STATE_ALL_REGISTERS_READY\t\t0x2\n#define PQI_DEVICE_STATE_ADMIN_QUEUE_PAIR_READY\t\t0x3\n#define PQI_DEVICE_STATE_ERROR\t\t\t\t0x4\n\n#define PQI_MODE_READY_TIMEOUT_SECS\t\t30\n#define PQI_MODE_READY_POLL_INTERVAL_MSECS\t1\n\nstatic int pqi_wait_for_pqi_mode_ready(struct pqi_ctrl_info *ctrl_info)\n{\n\tstruct pqi_device_registers __iomem *pqi_registers;\n\tunsigned long timeout;\n\tu64 signature;\n\tu8 status;\n\n\tpqi_registers = ctrl_info->pqi_registers;\n\ttimeout = (PQI_MODE_READY_TIMEOUT_SECS * PQI_HZ) + jiffies;\n\n\twhile (1) {\n\t\tsignature = readq(&pqi_registers->signature);\n\t\tif (memcmp(&signature, PQI_DEVICE_SIGNATURE,\n\t\t\tsizeof(signature)) == 0)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"timed out waiting for PQI signature\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(PQI_MODE_READY_POLL_INTERVAL_MSECS);\n\t}\n\n\twhile (1) {\n\t\tstatus = readb(&pqi_registers->function_and_status_code);\n\t\tif (status == PQI_STATUS_IDLE)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"timed out waiting for PQI IDLE\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(PQI_MODE_READY_POLL_INTERVAL_MSECS);\n\t}\n\n\twhile (1) {\n\t\tif (readl(&pqi_registers->device_status) ==\n\t\t\tPQI_DEVICE_STATE_ALL_REGISTERS_READY)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"timed out waiting for PQI all registers ready\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(PQI_MODE_READY_POLL_INTERVAL_MSECS);\n\t}\n\n\treturn 0;\n}\n\nstatic inline void pqi_aio_path_disabled(struct pqi_io_request *io_request)\n{\n\tstruct pqi_scsi_dev *device;\n\n\tdevice = io_request->scmd->device->hostdata;\n\tdevice->raid_bypass_enabled = false;\n\tdevice->aio_enabled = false;\n}\n\nstatic inline void pqi_take_device_offline(struct scsi_device *sdev, char *path)\n{\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct pqi_scsi_dev *device;\n\n\tdevice = sdev->hostdata;\n\tif (device->device_offline)\n\t\treturn;\n\n\tdevice->device_offline = true;\n\tctrl_info = shost_to_hba(sdev->host);\n\tpqi_schedule_rescan_worker(ctrl_info);\n\tdev_err(&ctrl_info->pci_dev->dev, \"re-scanning %s scsi %d:%d:%d:%d\\n\",\n\t\tpath, ctrl_info->scsi_host->host_no, device->bus,\n\t\tdevice->target, device->lun);\n}\n\nstatic void pqi_process_raid_io_error(struct pqi_io_request *io_request)\n{\n\tu8 scsi_status;\n\tu8 host_byte;\n\tstruct scsi_cmnd *scmd;\n\tstruct pqi_raid_error_info *error_info;\n\tsize_t sense_data_length;\n\tint residual_count;\n\tint xfer_count;\n\tstruct scsi_sense_hdr sshdr;\n\n\tscmd = io_request->scmd;\n\tif (!scmd)\n\t\treturn;\n\n\terror_info = io_request->error_info;\n\tscsi_status = error_info->status;\n\thost_byte = DID_OK;\n\n\tswitch (error_info->data_out_result) {\n\tcase PQI_DATA_IN_OUT_GOOD:\n\t\tbreak;\n\tcase PQI_DATA_IN_OUT_UNDERFLOW:\n\t\txfer_count =\n\t\t\tget_unaligned_le32(&error_info->data_out_transferred);\n\t\tresidual_count = scsi_bufflen(scmd) - xfer_count;\n\t\tscsi_set_resid(scmd, residual_count);\n\t\tif (xfer_count < scmd->underflow)\n\t\t\thost_byte = DID_SOFT_ERROR;\n\t\tbreak;\n\tcase PQI_DATA_IN_OUT_UNSOLICITED_ABORT:\n\tcase PQI_DATA_IN_OUT_ABORTED:\n\t\thost_byte = DID_ABORT;\n\t\tbreak;\n\tcase PQI_DATA_IN_OUT_TIMEOUT:\n\t\thost_byte = DID_TIME_OUT;\n\t\tbreak;\n\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW:\n\tcase PQI_DATA_IN_OUT_PROTOCOL_ERROR:\n\tcase PQI_DATA_IN_OUT_BUFFER_ERROR:\n\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW_DESCRIPTOR_AREA:\n\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW_BRIDGE:\n\tcase PQI_DATA_IN_OUT_ERROR:\n\tcase PQI_DATA_IN_OUT_HARDWARE_ERROR:\n\tcase PQI_DATA_IN_OUT_PCIE_FABRIC_ERROR:\n\tcase PQI_DATA_IN_OUT_PCIE_COMPLETION_TIMEOUT:\n\tcase PQI_DATA_IN_OUT_PCIE_COMPLETER_ABORT_RECEIVED:\n\tcase PQI_DATA_IN_OUT_PCIE_UNSUPPORTED_REQUEST_RECEIVED:\n\tcase PQI_DATA_IN_OUT_PCIE_ECRC_CHECK_FAILED:\n\tcase PQI_DATA_IN_OUT_PCIE_UNSUPPORTED_REQUEST:\n\tcase PQI_DATA_IN_OUT_PCIE_ACS_VIOLATION:\n\tcase PQI_DATA_IN_OUT_PCIE_TLP_PREFIX_BLOCKED:\n\tcase PQI_DATA_IN_OUT_PCIE_POISONED_MEMORY_READ:\n\tdefault:\n\t\thost_byte = DID_ERROR;\n\t\tbreak;\n\t}\n\n\tsense_data_length = get_unaligned_le16(&error_info->sense_data_length);\n\tif (sense_data_length == 0)\n\t\tsense_data_length =\n\t\t\tget_unaligned_le16(&error_info->response_data_length);\n\tif (sense_data_length) {\n\t\tif (sense_data_length > sizeof(error_info->data))\n\t\t\tsense_data_length = sizeof(error_info->data);\n\n\t\tif (scsi_status == SAM_STAT_CHECK_CONDITION &&\n\t\t\tscsi_normalize_sense(error_info->data,\n\t\t\t\tsense_data_length, &sshdr) &&\n\t\t\t\tsshdr.sense_key == HARDWARE_ERROR &&\n\t\t\t\tsshdr.asc == 0x3e) {\n\t\t\tstruct pqi_ctrl_info *ctrl_info = shost_to_hba(scmd->device->host);\n\t\t\tstruct pqi_scsi_dev *device = scmd->device->hostdata;\n\n\t\t\tswitch (sshdr.ascq) {\n\t\t\tcase 0x1: /* LOGICAL UNIT FAILURE */\n\t\t\t\tif (printk_ratelimit())\n\t\t\t\t\tscmd_printk(KERN_ERR, scmd, \"received 'logical unit failure' from controller for scsi %d:%d:%d:%d\\n\",\n\t\t\t\t\t\tctrl_info->scsi_host->host_no, device->bus, device->target, device->lun);\n\t\t\t\tpqi_take_device_offline(scmd->device, \"RAID\");\n\t\t\t\thost_byte = DID_NO_CONNECT;\n\t\t\t\tbreak;\n\n\t\t\tdefault: /* See http://www.t10.org/lists/asc-num.htm#ASC_3E */\n\t\t\t\tif (printk_ratelimit())\n\t\t\t\t\tscmd_printk(KERN_ERR, scmd, \"received unhandled error %d from controller for scsi %d:%d:%d:%d\\n\",\n\t\t\t\t\t\tsshdr.ascq, ctrl_info->scsi_host->host_no, device->bus, device->target, device->lun);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sense_data_length > SCSI_SENSE_BUFFERSIZE)\n\t\t\tsense_data_length = SCSI_SENSE_BUFFERSIZE;\n\t\tmemcpy(scmd->sense_buffer, error_info->data,\n\t\t\tsense_data_length);\n\t}\n\n\tscmd->result = scsi_status;\n\tset_host_byte(scmd, host_byte);\n}\n\nstatic void pqi_process_aio_io_error(struct pqi_io_request *io_request)\n{\n\tu8 scsi_status;\n\tu8 host_byte;\n\tstruct scsi_cmnd *scmd;\n\tstruct pqi_aio_error_info *error_info;\n\tsize_t sense_data_length;\n\tint residual_count;\n\tint xfer_count;\n\tbool device_offline;\n\n\tscmd = io_request->scmd;\n\terror_info = io_request->error_info;\n\thost_byte = DID_OK;\n\tsense_data_length = 0;\n\tdevice_offline = false;\n\n\tswitch (error_info->service_response) {\n\tcase PQI_AIO_SERV_RESPONSE_COMPLETE:\n\t\tscsi_status = error_info->status;\n\t\tbreak;\n\tcase PQI_AIO_SERV_RESPONSE_FAILURE:\n\t\tswitch (error_info->status) {\n\t\tcase PQI_AIO_STATUS_IO_ABORTED:\n\t\t\tscsi_status = SAM_STAT_TASK_ABORTED;\n\t\t\tbreak;\n\t\tcase PQI_AIO_STATUS_UNDERRUN:\n\t\t\tscsi_status = SAM_STAT_GOOD;\n\t\t\tresidual_count = get_unaligned_le32(\n\t\t\t\t\t\t&error_info->residual_count);\n\t\t\tscsi_set_resid(scmd, residual_count);\n\t\t\txfer_count = scsi_bufflen(scmd) - residual_count;\n\t\t\tif (xfer_count < scmd->underflow)\n\t\t\t\thost_byte = DID_SOFT_ERROR;\n\t\t\tbreak;\n\t\tcase PQI_AIO_STATUS_OVERRUN:\n\t\t\tscsi_status = SAM_STAT_GOOD;\n\t\t\tbreak;\n\t\tcase PQI_AIO_STATUS_AIO_PATH_DISABLED:\n\t\t\tpqi_aio_path_disabled(io_request);\n\t\t\tscsi_status = SAM_STAT_GOOD;\n\t\t\tio_request->status = -EAGAIN;\n\t\t\tbreak;\n\t\tcase PQI_AIO_STATUS_NO_PATH_TO_DEVICE:\n\t\tcase PQI_AIO_STATUS_INVALID_DEVICE:\n\t\t\tif (!io_request->raid_bypass) {\n\t\t\t\tdevice_offline = true;\n\t\t\t\tpqi_take_device_offline(scmd->device, \"AIO\");\n\t\t\t\thost_byte = DID_NO_CONNECT;\n\t\t\t}\n\t\t\tscsi_status = SAM_STAT_CHECK_CONDITION;\n\t\t\tbreak;\n\t\tcase PQI_AIO_STATUS_IO_ERROR:\n\t\tdefault:\n\t\t\tscsi_status = SAM_STAT_CHECK_CONDITION;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PQI_AIO_SERV_RESPONSE_TMF_COMPLETE:\n\tcase PQI_AIO_SERV_RESPONSE_TMF_SUCCEEDED:\n\t\tscsi_status = SAM_STAT_GOOD;\n\t\tbreak;\n\tcase PQI_AIO_SERV_RESPONSE_TMF_REJECTED:\n\tcase PQI_AIO_SERV_RESPONSE_TMF_INCORRECT_LUN:\n\tdefault:\n\t\tscsi_status = SAM_STAT_CHECK_CONDITION;\n\t\tbreak;\n\t}\n\n\tif (error_info->data_present) {\n\t\tsense_data_length =\n\t\t\tget_unaligned_le16(&error_info->data_length);\n\t\tif (sense_data_length) {\n\t\t\tif (sense_data_length > sizeof(error_info->data))\n\t\t\t\tsense_data_length = sizeof(error_info->data);\n\t\t\tif (sense_data_length > SCSI_SENSE_BUFFERSIZE)\n\t\t\t\tsense_data_length = SCSI_SENSE_BUFFERSIZE;\n\t\t\tmemcpy(scmd->sense_buffer, error_info->data,\n\t\t\t\tsense_data_length);\n\t\t}\n\t}\n\n\tif (device_offline && sense_data_length == 0)\n\t\tscsi_build_sense_buffer(0, scmd->sense_buffer, HARDWARE_ERROR,\n\t\t\t0x3e, 0x1);\n\n\tscmd->result = scsi_status;\n\tset_host_byte(scmd, host_byte);\n}\n\nstatic void pqi_process_io_error(unsigned int iu_type,\n\tstruct pqi_io_request *io_request)\n{\n\tswitch (iu_type) {\n\tcase PQI_RESPONSE_IU_RAID_PATH_IO_ERROR:\n\t\tpqi_process_raid_io_error(io_request);\n\t\tbreak;\n\tcase PQI_RESPONSE_IU_AIO_PATH_IO_ERROR:\n\t\tpqi_process_aio_io_error(io_request);\n\t\tbreak;\n\t}\n}\n\nstatic int pqi_interpret_task_management_response(\n\tstruct pqi_task_management_response *response)\n{\n\tint rc;\n\n\tswitch (response->response_code) {\n\tcase SOP_TMF_COMPLETE:\n\tcase SOP_TMF_FUNCTION_SUCCEEDED:\n\t\trc = 0;\n\t\tbreak;\n\tcase SOP_TMF_REJECTED:\n\t\trc = -EAGAIN;\n\t\tbreak;\n\tdefault:\n\t\trc = -EIO;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic inline void pqi_invalid_response(struct pqi_ctrl_info *ctrl_info)\n{\n\tpqi_take_ctrl_offline(ctrl_info);\n}\n\nstatic int pqi_process_io_intr(struct pqi_ctrl_info *ctrl_info, struct pqi_queue_group *queue_group)\n{\n\tint num_responses;\n\tpqi_index_t oq_pi;\n\tpqi_index_t oq_ci;\n\tstruct pqi_io_request *io_request;\n\tstruct pqi_io_response *response;\n\tu16 request_id;\n\n\tnum_responses = 0;\n\toq_ci = queue_group->oq_ci_copy;\n\n\twhile (1) {\n\t\toq_pi = readl(queue_group->oq_pi);\n\t\tif (oq_pi >= ctrl_info->num_elements_per_oq) {\n\t\t\tpqi_invalid_response(ctrl_info);\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"I/O interrupt: producer index (%u) out of range (0-%u): consumer index: %u\\n\",\n\t\t\t\toq_pi, ctrl_info->num_elements_per_oq - 1, oq_ci);\n\t\t\treturn -1;\n\t\t}\n\t\tif (oq_pi == oq_ci)\n\t\t\tbreak;\n\n\t\tnum_responses++;\n\t\tresponse = queue_group->oq_element_array +\n\t\t\t(oq_ci * PQI_OPERATIONAL_OQ_ELEMENT_LENGTH);\n\n\t\trequest_id = get_unaligned_le16(&response->request_id);\n\t\tif (request_id >= ctrl_info->max_io_slots) {\n\t\t\tpqi_invalid_response(ctrl_info);\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"request ID in response (%u) out of range (0-%u): producer index: %u  consumer index: %u\\n\",\n\t\t\t\trequest_id, ctrl_info->max_io_slots - 1, oq_pi, oq_ci);\n\t\t\treturn -1;\n\t\t}\n\n\t\tio_request = &ctrl_info->io_request_pool[request_id];\n\t\tif (atomic_read(&io_request->refcount) == 0) {\n\t\t\tpqi_invalid_response(ctrl_info);\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"request ID in response (%u) does not match an outstanding I/O request: producer index: %u  consumer index: %u\\n\",\n\t\t\t\trequest_id, oq_pi, oq_ci);\n\t\t\treturn -1;\n\t\t}\n\n\t\tswitch (response->header.iu_type) {\n\t\tcase PQI_RESPONSE_IU_RAID_PATH_IO_SUCCESS:\n\t\tcase PQI_RESPONSE_IU_AIO_PATH_IO_SUCCESS:\n\t\t\tif (io_request->scmd)\n\t\t\t\tio_request->scmd->result = 0;\n\t\t\tfallthrough;\n\t\tcase PQI_RESPONSE_IU_GENERAL_MANAGEMENT:\n\t\t\tbreak;\n\t\tcase PQI_RESPONSE_IU_VENDOR_GENERAL:\n\t\t\tio_request->status =\n\t\t\t\tget_unaligned_le16(\n\t\t\t\t&((struct pqi_vendor_general_response *)\n\t\t\t\t\tresponse)->status);\n\t\t\tbreak;\n\t\tcase PQI_RESPONSE_IU_TASK_MANAGEMENT:\n\t\t\tio_request->status =\n\t\t\t\tpqi_interpret_task_management_response(\n\t\t\t\t\t(void *)response);\n\t\t\tbreak;\n\t\tcase PQI_RESPONSE_IU_AIO_PATH_DISABLED:\n\t\t\tpqi_aio_path_disabled(io_request);\n\t\t\tio_request->status = -EAGAIN;\n\t\t\tbreak;\n\t\tcase PQI_RESPONSE_IU_RAID_PATH_IO_ERROR:\n\t\tcase PQI_RESPONSE_IU_AIO_PATH_IO_ERROR:\n\t\t\tio_request->error_info = ctrl_info->error_buffer +\n\t\t\t\t(get_unaligned_le16(&response->error_index) *\n\t\t\t\tPQI_ERROR_BUFFER_ELEMENT_LENGTH);\n\t\t\tpqi_process_io_error(response->header.iu_type, io_request);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpqi_invalid_response(ctrl_info);\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"unexpected IU type: 0x%x: producer index: %u  consumer index: %u\\n\",\n\t\t\t\tresponse->header.iu_type, oq_pi, oq_ci);\n\t\t\treturn -1;\n\t\t}\n\n\t\tio_request->io_complete_callback(io_request, io_request->context);\n\n\t\t/*\n\t\t * Note that the I/O request structure CANNOT BE TOUCHED after\n\t\t * returning from the I/O completion callback!\n\t\t */\n\t\toq_ci = (oq_ci + 1) % ctrl_info->num_elements_per_oq;\n\t}\n\n\tif (num_responses) {\n\t\tqueue_group->oq_ci_copy = oq_ci;\n\t\twritel(oq_ci, queue_group->oq_ci);\n\t}\n\n\treturn num_responses;\n}\n\nstatic inline unsigned int pqi_num_elements_free(unsigned int pi,\n\tunsigned int ci, unsigned int elements_in_queue)\n{\n\tunsigned int num_elements_used;\n\n\tif (pi >= ci)\n\t\tnum_elements_used = pi - ci;\n\telse\n\t\tnum_elements_used = elements_in_queue - ci + pi;\n\n\treturn elements_in_queue - num_elements_used - 1;\n}\n\nstatic void pqi_send_event_ack(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_event_acknowledge_request *iu, size_t iu_length)\n{\n\tpqi_index_t iq_pi;\n\tpqi_index_t iq_ci;\n\tunsigned long flags;\n\tvoid *next_element;\n\tstruct pqi_queue_group *queue_group;\n\n\tqueue_group = &ctrl_info->queue_groups[PQI_DEFAULT_QUEUE_GROUP];\n\tput_unaligned_le16(queue_group->oq_id, &iu->header.response_queue_id);\n\n\twhile (1) {\n\t\tspin_lock_irqsave(&queue_group->submit_lock[RAID_PATH], flags);\n\n\t\tiq_pi = queue_group->iq_pi_copy[RAID_PATH];\n\t\tiq_ci = readl(queue_group->iq_ci[RAID_PATH]);\n\n\t\tif (pqi_num_elements_free(iq_pi, iq_ci,\n\t\t\tctrl_info->num_elements_per_iq))\n\t\t\tbreak;\n\n\t\tspin_unlock_irqrestore(\n\t\t\t&queue_group->submit_lock[RAID_PATH], flags);\n\n\t\tif (pqi_ctrl_offline(ctrl_info))\n\t\t\treturn;\n\t}\n\n\tnext_element = queue_group->iq_element_array[RAID_PATH] +\n\t\t(iq_pi * PQI_OPERATIONAL_IQ_ELEMENT_LENGTH);\n\n\tmemcpy(next_element, iu, iu_length);\n\n\tiq_pi = (iq_pi + 1) % ctrl_info->num_elements_per_iq;\n\tqueue_group->iq_pi_copy[RAID_PATH] = iq_pi;\n\n\t/*\n\t * This write notifies the controller that an IU is available to be\n\t * processed.\n\t */\n\twritel(iq_pi, queue_group->iq_pi[RAID_PATH]);\n\n\tspin_unlock_irqrestore(&queue_group->submit_lock[RAID_PATH], flags);\n}\n\nstatic void pqi_acknowledge_event(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_event *event)\n{\n\tstruct pqi_event_acknowledge_request request;\n\n\tmemset(&request, 0, sizeof(request));\n\n\trequest.header.iu_type = PQI_REQUEST_IU_ACKNOWLEDGE_VENDOR_EVENT;\n\tput_unaligned_le16(sizeof(request) - PQI_REQUEST_HEADER_LENGTH,\n\t\t&request.header.iu_length);\n\trequest.event_type = event->event_type;\n\trequest.event_id = event->event_id;\n\trequest.additional_event_id = event->additional_event_id;\n\n\tpqi_send_event_ack(ctrl_info, &request, sizeof(request));\n}\n\n#define PQI_SOFT_RESET_STATUS_TIMEOUT_SECS\t\t30\n#define PQI_SOFT_RESET_STATUS_POLL_INTERVAL_SECS\t1\n\nstatic enum pqi_soft_reset_status pqi_poll_for_soft_reset_status(\n\tstruct pqi_ctrl_info *ctrl_info)\n{\n\tunsigned long timeout;\n\tu8 status;\n\n\ttimeout = (PQI_SOFT_RESET_STATUS_TIMEOUT_SECS * PQI_HZ) + jiffies;\n\n\twhile (1) {\n\t\tstatus = pqi_read_soft_reset_status(ctrl_info);\n\t\tif (status & PQI_SOFT_RESET_INITIATE)\n\t\t\treturn RESET_INITIATE_DRIVER;\n\n\t\tif (status & PQI_SOFT_RESET_ABORT)\n\t\t\treturn RESET_ABORT;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"timed out waiting for soft reset status\\n\");\n\t\t\treturn RESET_TIMEDOUT;\n\t\t}\n\n\t\tif (!sis_is_firmware_running(ctrl_info))\n\t\t\treturn RESET_NORESPONSE;\n\n\t\tssleep(PQI_SOFT_RESET_STATUS_POLL_INTERVAL_SECS);\n\t}\n}\n\nstatic void pqi_process_soft_reset(struct pqi_ctrl_info *ctrl_info,\n\tenum pqi_soft_reset_status reset_status)\n{\n\tint rc;\n\n\tswitch (reset_status) {\n\tcase RESET_INITIATE_DRIVER:\n\tcase RESET_TIMEDOUT:\n\t\tdev_info(&ctrl_info->pci_dev->dev,\n\t\t\t\"resetting controller %u\\n\", ctrl_info->ctrl_id);\n\t\tsis_soft_reset(ctrl_info);\n\t\tfallthrough;\n\tcase RESET_INITIATE_FIRMWARE:\n\t\trc = pqi_ofa_ctrl_restart(ctrl_info);\n\t\tpqi_ofa_free_host_buffer(ctrl_info);\n\t\tdev_info(&ctrl_info->pci_dev->dev,\n\t\t\t\"Online Firmware Activation for controller %u: %s\\n\",\n\t\t\tctrl_info->ctrl_id, rc == 0 ? \"SUCCESS\" : \"FAILED\");\n\t\tbreak;\n\tcase RESET_ABORT:\n\t\tpqi_ofa_ctrl_unquiesce(ctrl_info);\n\t\tdev_info(&ctrl_info->pci_dev->dev,\n\t\t\t\"Online Firmware Activation for controller %u: %s\\n\",\n\t\t\tctrl_info->ctrl_id, \"ABORTED\");\n\t\tbreak;\n\tcase RESET_NORESPONSE:\n\t\tpqi_ofa_free_host_buffer(ctrl_info);\n\t\tpqi_take_ctrl_offline(ctrl_info);\n\t\tbreak;\n\t}\n}\n\nstatic void pqi_ofa_process_event(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_event *event)\n{\n\tu16 event_id;\n\tenum pqi_soft_reset_status status;\n\n\tevent_id = get_unaligned_le16(&event->event_id);\n\n\tmutex_lock(&ctrl_info->ofa_mutex);\n\n\tif (event_id == PQI_EVENT_OFA_QUIESCE) {\n\t\tdev_info(&ctrl_info->pci_dev->dev,\n\t\t\t\"Received Online Firmware Activation quiesce event for controller %u\\n\",\n\t\t\tctrl_info->ctrl_id);\n\t\tpqi_ofa_ctrl_quiesce(ctrl_info);\n\t\tpqi_acknowledge_event(ctrl_info, event);\n\t\tif (ctrl_info->soft_reset_handshake_supported) {\n\t\t\tstatus = pqi_poll_for_soft_reset_status(ctrl_info);\n\t\t\tpqi_process_soft_reset(ctrl_info, status);\n\t\t} else {\n\t\t\tpqi_process_soft_reset(ctrl_info,\n\t\t\t\t\tRESET_INITIATE_FIRMWARE);\n\t\t}\n\n\t} else if (event_id == PQI_EVENT_OFA_MEMORY_ALLOCATION) {\n\t\tpqi_acknowledge_event(ctrl_info, event);\n\t\tpqi_ofa_setup_host_buffer(ctrl_info,\n\t\t\tle32_to_cpu(event->ofa_bytes_requested));\n\t\tpqi_ofa_host_memory_update(ctrl_info);\n\t} else if (event_id == PQI_EVENT_OFA_CANCELLED) {\n\t\tpqi_ofa_free_host_buffer(ctrl_info);\n\t\tpqi_acknowledge_event(ctrl_info, event);\n\t\tdev_info(&ctrl_info->pci_dev->dev,\n\t\t\t\"Online Firmware Activation(%u) cancel reason : %u\\n\",\n\t\t\tctrl_info->ctrl_id, event->ofa_cancel_reason);\n\t}\n\n\tmutex_unlock(&ctrl_info->ofa_mutex);\n}\n\nstatic void pqi_event_worker(struct work_struct *work)\n{\n\tunsigned int i;\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct pqi_event *event;\n\n\tctrl_info = container_of(work, struct pqi_ctrl_info, event_work);\n\n\tpqi_ctrl_busy(ctrl_info);\n\tpqi_wait_if_ctrl_blocked(ctrl_info, NO_TIMEOUT);\n\tif (pqi_ctrl_offline(ctrl_info))\n\t\tgoto out;\n\n\tpqi_schedule_rescan_worker_delayed(ctrl_info);\n\n\tevent = ctrl_info->events;\n\tfor (i = 0; i < PQI_NUM_SUPPORTED_EVENTS; i++) {\n\t\tif (event->pending) {\n\t\t\tevent->pending = false;\n\t\t\tif (event->event_type == PQI_EVENT_TYPE_OFA) {\n\t\t\t\tpqi_ctrl_unbusy(ctrl_info);\n\t\t\t\tpqi_ofa_process_event(ctrl_info, event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpqi_acknowledge_event(ctrl_info, event);\n\t\t}\n\t\tevent++;\n\t}\n\nout:\n\tpqi_ctrl_unbusy(ctrl_info);\n}\n\n#define PQI_HEARTBEAT_TIMER_INTERVAL\t(10 * PQI_HZ)\n\nstatic void pqi_heartbeat_timer_handler(struct timer_list *t)\n{\n\tint num_interrupts;\n\tu32 heartbeat_count;\n\tstruct pqi_ctrl_info *ctrl_info = from_timer(ctrl_info, t,\n\t\t\t\t\t\t     heartbeat_timer);\n\n\tpqi_check_ctrl_health(ctrl_info);\n\tif (pqi_ctrl_offline(ctrl_info))\n\t\treturn;\n\n\tnum_interrupts = atomic_read(&ctrl_info->num_interrupts);\n\theartbeat_count = pqi_read_heartbeat_counter(ctrl_info);\n\n\tif (num_interrupts == ctrl_info->previous_num_interrupts) {\n\t\tif (heartbeat_count == ctrl_info->previous_heartbeat_count) {\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"no heartbeat detected - last heartbeat count: %u\\n\",\n\t\t\t\theartbeat_count);\n\t\t\tpqi_take_ctrl_offline(ctrl_info);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tctrl_info->previous_num_interrupts = num_interrupts;\n\t}\n\n\tctrl_info->previous_heartbeat_count = heartbeat_count;\n\tmod_timer(&ctrl_info->heartbeat_timer,\n\t\tjiffies + PQI_HEARTBEAT_TIMER_INTERVAL);\n}\n\nstatic void pqi_start_heartbeat_timer(struct pqi_ctrl_info *ctrl_info)\n{\n\tif (!ctrl_info->heartbeat_counter)\n\t\treturn;\n\n\tctrl_info->previous_num_interrupts =\n\t\tatomic_read(&ctrl_info->num_interrupts);\n\tctrl_info->previous_heartbeat_count =\n\t\tpqi_read_heartbeat_counter(ctrl_info);\n\n\tctrl_info->heartbeat_timer.expires =\n\t\tjiffies + PQI_HEARTBEAT_TIMER_INTERVAL;\n\tadd_timer(&ctrl_info->heartbeat_timer);\n}\n\nstatic inline void pqi_stop_heartbeat_timer(struct pqi_ctrl_info *ctrl_info)\n{\n\tdel_timer_sync(&ctrl_info->heartbeat_timer);\n}\n\nstatic inline int pqi_event_type_to_event_index(unsigned int event_type)\n{\n\tint index;\n\n\tfor (index = 0; index < ARRAY_SIZE(pqi_supported_event_types); index++)\n\t\tif (event_type == pqi_supported_event_types[index])\n\t\t\treturn index;\n\n\treturn -1;\n}\n\nstatic inline bool pqi_is_supported_event(unsigned int event_type)\n{\n\treturn pqi_event_type_to_event_index(event_type) != -1;\n}\n\nstatic void pqi_ofa_capture_event_payload(struct pqi_event *event,\n\tstruct pqi_event_response *response)\n{\n\tu16 event_id;\n\n\tevent_id = get_unaligned_le16(&event->event_id);\n\n\tif (event->event_type == PQI_EVENT_TYPE_OFA) {\n\t\tif (event_id == PQI_EVENT_OFA_MEMORY_ALLOCATION) {\n\t\t\tevent->ofa_bytes_requested =\n\t\t\tresponse->data.ofa_memory_allocation.bytes_requested;\n\t\t} else if (event_id == PQI_EVENT_OFA_CANCELLED) {\n\t\t\tevent->ofa_cancel_reason =\n\t\t\tresponse->data.ofa_cancelled.reason;\n\t\t}\n\t}\n}\n\nstatic int pqi_process_event_intr(struct pqi_ctrl_info *ctrl_info)\n{\n\tint num_events;\n\tpqi_index_t oq_pi;\n\tpqi_index_t oq_ci;\n\tstruct pqi_event_queue *event_queue;\n\tstruct pqi_event_response *response;\n\tstruct pqi_event *event;\n\tint event_index;\n\n\tevent_queue = &ctrl_info->event_queue;\n\tnum_events = 0;\n\toq_ci = event_queue->oq_ci_copy;\n\n\twhile (1) {\n\t\toq_pi = readl(event_queue->oq_pi);\n\t\tif (oq_pi >= PQI_NUM_EVENT_QUEUE_ELEMENTS) {\n\t\t\tpqi_invalid_response(ctrl_info);\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"event interrupt: producer index (%u) out of range (0-%u): consumer index: %u\\n\",\n\t\t\t\toq_pi, PQI_NUM_EVENT_QUEUE_ELEMENTS - 1, oq_ci);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (oq_pi == oq_ci)\n\t\t\tbreak;\n\n\t\tnum_events++;\n\t\tresponse = event_queue->oq_element_array + (oq_ci * PQI_EVENT_OQ_ELEMENT_LENGTH);\n\n\t\tevent_index =\n\t\t\tpqi_event_type_to_event_index(response->event_type);\n\n\t\tif (event_index >= 0 && response->request_acknowledge) {\n\t\t\tevent = &ctrl_info->events[event_index];\n\t\t\tevent->pending = true;\n\t\t\tevent->event_type = response->event_type;\n\t\t\tevent->event_id = response->event_id;\n\t\t\tevent->additional_event_id = response->additional_event_id;\n\t\t\tif (event->event_type == PQI_EVENT_TYPE_OFA)\n\t\t\t\tpqi_ofa_capture_event_payload(event, response);\n\t\t}\n\n\t\toq_ci = (oq_ci + 1) % PQI_NUM_EVENT_QUEUE_ELEMENTS;\n\t}\n\n\tif (num_events) {\n\t\tevent_queue->oq_ci_copy = oq_ci;\n\t\twritel(oq_ci, event_queue->oq_ci);\n\t\tschedule_work(&ctrl_info->event_work);\n\t}\n\n\treturn num_events;\n}\n\n#define PQI_LEGACY_INTX_MASK\t0x1\n\nstatic inline void pqi_configure_legacy_intx(struct pqi_ctrl_info *ctrl_info,\n\tbool enable_intx)\n{\n\tu32 intx_mask;\n\tstruct pqi_device_registers __iomem *pqi_registers;\n\tvolatile void __iomem *register_addr;\n\n\tpqi_registers = ctrl_info->pqi_registers;\n\n\tif (enable_intx)\n\t\tregister_addr = &pqi_registers->legacy_intx_mask_clear;\n\telse\n\t\tregister_addr = &pqi_registers->legacy_intx_mask_set;\n\n\tintx_mask = readl(register_addr);\n\tintx_mask |= PQI_LEGACY_INTX_MASK;\n\twritel(intx_mask, register_addr);\n}\n\nstatic void pqi_change_irq_mode(struct pqi_ctrl_info *ctrl_info,\n\tenum pqi_irq_mode new_mode)\n{\n\tswitch (ctrl_info->irq_mode) {\n\tcase IRQ_MODE_MSIX:\n\t\tswitch (new_mode) {\n\t\tcase IRQ_MODE_MSIX:\n\t\t\tbreak;\n\t\tcase IRQ_MODE_INTX:\n\t\t\tpqi_configure_legacy_intx(ctrl_info, true);\n\t\t\tsis_enable_intx(ctrl_info);\n\t\t\tbreak;\n\t\tcase IRQ_MODE_NONE:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IRQ_MODE_INTX:\n\t\tswitch (new_mode) {\n\t\tcase IRQ_MODE_MSIX:\n\t\t\tpqi_configure_legacy_intx(ctrl_info, false);\n\t\t\tsis_enable_msix(ctrl_info);\n\t\t\tbreak;\n\t\tcase IRQ_MODE_INTX:\n\t\t\tbreak;\n\t\tcase IRQ_MODE_NONE:\n\t\t\tpqi_configure_legacy_intx(ctrl_info, false);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IRQ_MODE_NONE:\n\t\tswitch (new_mode) {\n\t\tcase IRQ_MODE_MSIX:\n\t\t\tsis_enable_msix(ctrl_info);\n\t\t\tbreak;\n\t\tcase IRQ_MODE_INTX:\n\t\t\tpqi_configure_legacy_intx(ctrl_info, true);\n\t\t\tsis_enable_intx(ctrl_info);\n\t\t\tbreak;\n\t\tcase IRQ_MODE_NONE:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tctrl_info->irq_mode = new_mode;\n}\n\n#define PQI_LEGACY_INTX_PENDING\t\t0x1\n\nstatic inline bool pqi_is_valid_irq(struct pqi_ctrl_info *ctrl_info)\n{\n\tbool valid_irq;\n\tu32 intx_status;\n\n\tswitch (ctrl_info->irq_mode) {\n\tcase IRQ_MODE_MSIX:\n\t\tvalid_irq = true;\n\t\tbreak;\n\tcase IRQ_MODE_INTX:\n\t\tintx_status =\n\t\t\treadl(&ctrl_info->pqi_registers->legacy_intx_status);\n\t\tif (intx_status & PQI_LEGACY_INTX_PENDING)\n\t\t\tvalid_irq = true;\n\t\telse\n\t\t\tvalid_irq = false;\n\t\tbreak;\n\tcase IRQ_MODE_NONE:\n\tdefault:\n\t\tvalid_irq = false;\n\t\tbreak;\n\t}\n\n\treturn valid_irq;\n}\n\nstatic irqreturn_t pqi_irq_handler(int irq, void *data)\n{\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct pqi_queue_group *queue_group;\n\tint num_io_responses_handled;\n\tint num_events_handled;\n\n\tqueue_group = data;\n\tctrl_info = queue_group->ctrl_info;\n\n\tif (!pqi_is_valid_irq(ctrl_info))\n\t\treturn IRQ_NONE;\n\n\tnum_io_responses_handled = pqi_process_io_intr(ctrl_info, queue_group);\n\tif (num_io_responses_handled < 0)\n\t\tgoto out;\n\n\tif (irq == ctrl_info->event_irq) {\n\t\tnum_events_handled = pqi_process_event_intr(ctrl_info);\n\t\tif (num_events_handled < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tnum_events_handled = 0;\n\t}\n\n\tif (num_io_responses_handled + num_events_handled > 0)\n\t\tatomic_inc(&ctrl_info->num_interrupts);\n\n\tpqi_start_io(ctrl_info, queue_group, RAID_PATH, NULL);\n\tpqi_start_io(ctrl_info, queue_group, AIO_PATH, NULL);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int pqi_request_irqs(struct pqi_ctrl_info *ctrl_info)\n{\n\tstruct pci_dev *pci_dev = ctrl_info->pci_dev;\n\tint i;\n\tint rc;\n\n\tctrl_info->event_irq = pci_irq_vector(pci_dev, 0);\n\n\tfor (i = 0; i < ctrl_info->num_msix_vectors_enabled; i++) {\n\t\trc = request_irq(pci_irq_vector(pci_dev, i), pqi_irq_handler, 0,\n\t\t\tDRIVER_NAME_SHORT, &ctrl_info->queue_groups[i]);\n\t\tif (rc) {\n\t\t\tdev_err(&pci_dev->dev,\n\t\t\t\t\"irq %u init failed with error %d\\n\",\n\t\t\t\tpci_irq_vector(pci_dev, i), rc);\n\t\t\treturn rc;\n\t\t}\n\t\tctrl_info->num_msix_vectors_initialized++;\n\t}\n\n\treturn 0;\n}\n\nstatic void pqi_free_irqs(struct pqi_ctrl_info *ctrl_info)\n{\n\tint i;\n\n\tfor (i = 0; i < ctrl_info->num_msix_vectors_initialized; i++)\n\t\tfree_irq(pci_irq_vector(ctrl_info->pci_dev, i),\n\t\t\t&ctrl_info->queue_groups[i]);\n\n\tctrl_info->num_msix_vectors_initialized = 0;\n}\n\nstatic int pqi_enable_msix_interrupts(struct pqi_ctrl_info *ctrl_info)\n{\n\tint num_vectors_enabled;\n\n\tnum_vectors_enabled = pci_alloc_irq_vectors(ctrl_info->pci_dev,\n\t\t\tPQI_MIN_MSIX_VECTORS, ctrl_info->num_queue_groups,\n\t\t\tPCI_IRQ_MSIX | PCI_IRQ_AFFINITY);\n\tif (num_vectors_enabled < 0) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"MSI-X init failed with error %d\\n\",\n\t\t\tnum_vectors_enabled);\n\t\treturn num_vectors_enabled;\n\t}\n\n\tctrl_info->num_msix_vectors_enabled = num_vectors_enabled;\n\tctrl_info->irq_mode = IRQ_MODE_MSIX;\n\treturn 0;\n}\n\nstatic void pqi_disable_msix_interrupts(struct pqi_ctrl_info *ctrl_info)\n{\n\tif (ctrl_info->num_msix_vectors_enabled) {\n\t\tpci_free_irq_vectors(ctrl_info->pci_dev);\n\t\tctrl_info->num_msix_vectors_enabled = 0;\n\t}\n}\n\nstatic int pqi_alloc_operational_queues(struct pqi_ctrl_info *ctrl_info)\n{\n\tunsigned int i;\n\tsize_t alloc_length;\n\tsize_t element_array_length_per_iq;\n\tsize_t element_array_length_per_oq;\n\tvoid *element_array;\n\tvoid __iomem *next_queue_index;\n\tvoid *aligned_pointer;\n\tunsigned int num_inbound_queues;\n\tunsigned int num_outbound_queues;\n\tunsigned int num_queue_indexes;\n\tstruct pqi_queue_group *queue_group;\n\n\telement_array_length_per_iq =\n\t\tPQI_OPERATIONAL_IQ_ELEMENT_LENGTH *\n\t\tctrl_info->num_elements_per_iq;\n\telement_array_length_per_oq =\n\t\tPQI_OPERATIONAL_OQ_ELEMENT_LENGTH *\n\t\tctrl_info->num_elements_per_oq;\n\tnum_inbound_queues = ctrl_info->num_queue_groups * 2;\n\tnum_outbound_queues = ctrl_info->num_queue_groups;\n\tnum_queue_indexes = (ctrl_info->num_queue_groups * 3) + 1;\n\n\taligned_pointer = NULL;\n\n\tfor (i = 0; i < num_inbound_queues; i++) {\n\t\taligned_pointer = PTR_ALIGN(aligned_pointer,\n\t\t\tPQI_QUEUE_ELEMENT_ARRAY_ALIGNMENT);\n\t\taligned_pointer += element_array_length_per_iq;\n\t}\n\n\tfor (i = 0; i < num_outbound_queues; i++) {\n\t\taligned_pointer = PTR_ALIGN(aligned_pointer,\n\t\t\tPQI_QUEUE_ELEMENT_ARRAY_ALIGNMENT);\n\t\taligned_pointer += element_array_length_per_oq;\n\t}\n\n\taligned_pointer = PTR_ALIGN(aligned_pointer,\n\t\tPQI_QUEUE_ELEMENT_ARRAY_ALIGNMENT);\n\taligned_pointer += PQI_NUM_EVENT_QUEUE_ELEMENTS *\n\t\tPQI_EVENT_OQ_ELEMENT_LENGTH;\n\n\tfor (i = 0; i < num_queue_indexes; i++) {\n\t\taligned_pointer = PTR_ALIGN(aligned_pointer,\n\t\t\tPQI_OPERATIONAL_INDEX_ALIGNMENT);\n\t\taligned_pointer += sizeof(pqi_index_t);\n\t}\n\n\talloc_length = (size_t)aligned_pointer +\n\t\tPQI_QUEUE_ELEMENT_ARRAY_ALIGNMENT;\n\n\talloc_length += PQI_EXTRA_SGL_MEMORY;\n\n\tctrl_info->queue_memory_base =\n\t\tdma_alloc_coherent(&ctrl_info->pci_dev->dev, alloc_length,\n\t\t\t\t   &ctrl_info->queue_memory_base_dma_handle,\n\t\t\t\t   GFP_KERNEL);\n\n\tif (!ctrl_info->queue_memory_base)\n\t\treturn -ENOMEM;\n\n\tctrl_info->queue_memory_length = alloc_length;\n\n\telement_array = PTR_ALIGN(ctrl_info->queue_memory_base,\n\t\tPQI_QUEUE_ELEMENT_ARRAY_ALIGNMENT);\n\n\tfor (i = 0; i < ctrl_info->num_queue_groups; i++) {\n\t\tqueue_group = &ctrl_info->queue_groups[i];\n\t\tqueue_group->iq_element_array[RAID_PATH] = element_array;\n\t\tqueue_group->iq_element_array_bus_addr[RAID_PATH] =\n\t\t\tctrl_info->queue_memory_base_dma_handle +\n\t\t\t\t(element_array - ctrl_info->queue_memory_base);\n\t\telement_array += element_array_length_per_iq;\n\t\telement_array = PTR_ALIGN(element_array,\n\t\t\tPQI_QUEUE_ELEMENT_ARRAY_ALIGNMENT);\n\t\tqueue_group->iq_element_array[AIO_PATH] = element_array;\n\t\tqueue_group->iq_element_array_bus_addr[AIO_PATH] =\n\t\t\tctrl_info->queue_memory_base_dma_handle +\n\t\t\t(element_array - ctrl_info->queue_memory_base);\n\t\telement_array += element_array_length_per_iq;\n\t\telement_array = PTR_ALIGN(element_array,\n\t\t\tPQI_QUEUE_ELEMENT_ARRAY_ALIGNMENT);\n\t}\n\n\tfor (i = 0; i < ctrl_info->num_queue_groups; i++) {\n\t\tqueue_group = &ctrl_info->queue_groups[i];\n\t\tqueue_group->oq_element_array = element_array;\n\t\tqueue_group->oq_element_array_bus_addr =\n\t\t\tctrl_info->queue_memory_base_dma_handle +\n\t\t\t(element_array - ctrl_info->queue_memory_base);\n\t\telement_array += element_array_length_per_oq;\n\t\telement_array = PTR_ALIGN(element_array,\n\t\t\tPQI_QUEUE_ELEMENT_ARRAY_ALIGNMENT);\n\t}\n\n\tctrl_info->event_queue.oq_element_array = element_array;\n\tctrl_info->event_queue.oq_element_array_bus_addr =\n\t\tctrl_info->queue_memory_base_dma_handle +\n\t\t(element_array - ctrl_info->queue_memory_base);\n\telement_array += PQI_NUM_EVENT_QUEUE_ELEMENTS *\n\t\tPQI_EVENT_OQ_ELEMENT_LENGTH;\n\n\tnext_queue_index = (void __iomem *)PTR_ALIGN(element_array,\n\t\tPQI_OPERATIONAL_INDEX_ALIGNMENT);\n\n\tfor (i = 0; i < ctrl_info->num_queue_groups; i++) {\n\t\tqueue_group = &ctrl_info->queue_groups[i];\n\t\tqueue_group->iq_ci[RAID_PATH] = next_queue_index;\n\t\tqueue_group->iq_ci_bus_addr[RAID_PATH] =\n\t\t\tctrl_info->queue_memory_base_dma_handle +\n\t\t\t(next_queue_index -\n\t\t\t(void __iomem *)ctrl_info->queue_memory_base);\n\t\tnext_queue_index += sizeof(pqi_index_t);\n\t\tnext_queue_index = PTR_ALIGN(next_queue_index,\n\t\t\tPQI_OPERATIONAL_INDEX_ALIGNMENT);\n\t\tqueue_group->iq_ci[AIO_PATH] = next_queue_index;\n\t\tqueue_group->iq_ci_bus_addr[AIO_PATH] =\n\t\t\tctrl_info->queue_memory_base_dma_handle +\n\t\t\t(next_queue_index -\n\t\t\t(void __iomem *)ctrl_info->queue_memory_base);\n\t\tnext_queue_index += sizeof(pqi_index_t);\n\t\tnext_queue_index = PTR_ALIGN(next_queue_index,\n\t\t\tPQI_OPERATIONAL_INDEX_ALIGNMENT);\n\t\tqueue_group->oq_pi = next_queue_index;\n\t\tqueue_group->oq_pi_bus_addr =\n\t\t\tctrl_info->queue_memory_base_dma_handle +\n\t\t\t(next_queue_index -\n\t\t\t(void __iomem *)ctrl_info->queue_memory_base);\n\t\tnext_queue_index += sizeof(pqi_index_t);\n\t\tnext_queue_index = PTR_ALIGN(next_queue_index,\n\t\t\tPQI_OPERATIONAL_INDEX_ALIGNMENT);\n\t}\n\n\tctrl_info->event_queue.oq_pi = next_queue_index;\n\tctrl_info->event_queue.oq_pi_bus_addr =\n\t\tctrl_info->queue_memory_base_dma_handle +\n\t\t(next_queue_index -\n\t\t(void __iomem *)ctrl_info->queue_memory_base);\n\n\treturn 0;\n}\n\nstatic void pqi_init_operational_queues(struct pqi_ctrl_info *ctrl_info)\n{\n\tunsigned int i;\n\tu16 next_iq_id = PQI_MIN_OPERATIONAL_QUEUE_ID;\n\tu16 next_oq_id = PQI_MIN_OPERATIONAL_QUEUE_ID;\n\n\t/*\n\t * Initialize the backpointers to the controller structure in\n\t * each operational queue group structure.\n\t */\n\tfor (i = 0; i < ctrl_info->num_queue_groups; i++)\n\t\tctrl_info->queue_groups[i].ctrl_info = ctrl_info;\n\n\t/*\n\t * Assign IDs to all operational queues.  Note that the IDs\n\t * assigned to operational IQs are independent of the IDs\n\t * assigned to operational OQs.\n\t */\n\tctrl_info->event_queue.oq_id = next_oq_id++;\n\tfor (i = 0; i < ctrl_info->num_queue_groups; i++) {\n\t\tctrl_info->queue_groups[i].iq_id[RAID_PATH] = next_iq_id++;\n\t\tctrl_info->queue_groups[i].iq_id[AIO_PATH] = next_iq_id++;\n\t\tctrl_info->queue_groups[i].oq_id = next_oq_id++;\n\t}\n\n\t/*\n\t * Assign MSI-X table entry indexes to all queues.  Note that the\n\t * interrupt for the event queue is shared with the first queue group.\n\t */\n\tctrl_info->event_queue.int_msg_num = 0;\n\tfor (i = 0; i < ctrl_info->num_queue_groups; i++)\n\t\tctrl_info->queue_groups[i].int_msg_num = i;\n\n\tfor (i = 0; i < ctrl_info->num_queue_groups; i++) {\n\t\tspin_lock_init(&ctrl_info->queue_groups[i].submit_lock[0]);\n\t\tspin_lock_init(&ctrl_info->queue_groups[i].submit_lock[1]);\n\t\tINIT_LIST_HEAD(&ctrl_info->queue_groups[i].request_list[0]);\n\t\tINIT_LIST_HEAD(&ctrl_info->queue_groups[i].request_list[1]);\n\t}\n}\n\nstatic int pqi_alloc_admin_queues(struct pqi_ctrl_info *ctrl_info)\n{\n\tsize_t alloc_length;\n\tstruct pqi_admin_queues_aligned *admin_queues_aligned;\n\tstruct pqi_admin_queues *admin_queues;\n\n\talloc_length = sizeof(struct pqi_admin_queues_aligned) +\n\t\tPQI_QUEUE_ELEMENT_ARRAY_ALIGNMENT;\n\n\tctrl_info->admin_queue_memory_base =\n\t\tdma_alloc_coherent(&ctrl_info->pci_dev->dev, alloc_length,\n\t\t\t\t   &ctrl_info->admin_queue_memory_base_dma_handle,\n\t\t\t\t   GFP_KERNEL);\n\n\tif (!ctrl_info->admin_queue_memory_base)\n\t\treturn -ENOMEM;\n\n\tctrl_info->admin_queue_memory_length = alloc_length;\n\n\tadmin_queues = &ctrl_info->admin_queues;\n\tadmin_queues_aligned = PTR_ALIGN(ctrl_info->admin_queue_memory_base,\n\t\tPQI_QUEUE_ELEMENT_ARRAY_ALIGNMENT);\n\tadmin_queues->iq_element_array =\n\t\t&admin_queues_aligned->iq_element_array;\n\tadmin_queues->oq_element_array =\n\t\t&admin_queues_aligned->oq_element_array;\n\tadmin_queues->iq_ci = &admin_queues_aligned->iq_ci;\n\tadmin_queues->oq_pi =\n\t\t(pqi_index_t __iomem *)&admin_queues_aligned->oq_pi;\n\n\tadmin_queues->iq_element_array_bus_addr =\n\t\tctrl_info->admin_queue_memory_base_dma_handle +\n\t\t(admin_queues->iq_element_array -\n\t\tctrl_info->admin_queue_memory_base);\n\tadmin_queues->oq_element_array_bus_addr =\n\t\tctrl_info->admin_queue_memory_base_dma_handle +\n\t\t(admin_queues->oq_element_array -\n\t\tctrl_info->admin_queue_memory_base);\n\tadmin_queues->iq_ci_bus_addr =\n\t\tctrl_info->admin_queue_memory_base_dma_handle +\n\t\t((void *)admin_queues->iq_ci -\n\t\tctrl_info->admin_queue_memory_base);\n\tadmin_queues->oq_pi_bus_addr =\n\t\tctrl_info->admin_queue_memory_base_dma_handle +\n\t\t((void __iomem *)admin_queues->oq_pi -\n\t\t(void __iomem *)ctrl_info->admin_queue_memory_base);\n\n\treturn 0;\n}\n\n#define PQI_ADMIN_QUEUE_CREATE_TIMEOUT_JIFFIES\t\tPQI_HZ\n#define PQI_ADMIN_QUEUE_CREATE_POLL_INTERVAL_MSECS\t1\n\nstatic int pqi_create_admin_queues(struct pqi_ctrl_info *ctrl_info)\n{\n\tstruct pqi_device_registers __iomem *pqi_registers;\n\tstruct pqi_admin_queues *admin_queues;\n\tunsigned long timeout;\n\tu8 status;\n\tu32 reg;\n\n\tpqi_registers = ctrl_info->pqi_registers;\n\tadmin_queues = &ctrl_info->admin_queues;\n\n\twriteq((u64)admin_queues->iq_element_array_bus_addr,\n\t\t&pqi_registers->admin_iq_element_array_addr);\n\twriteq((u64)admin_queues->oq_element_array_bus_addr,\n\t\t&pqi_registers->admin_oq_element_array_addr);\n\twriteq((u64)admin_queues->iq_ci_bus_addr,\n\t\t&pqi_registers->admin_iq_ci_addr);\n\twriteq((u64)admin_queues->oq_pi_bus_addr,\n\t\t&pqi_registers->admin_oq_pi_addr);\n\n\treg = PQI_ADMIN_IQ_NUM_ELEMENTS |\n\t\t(PQI_ADMIN_OQ_NUM_ELEMENTS << 8) |\n\t\t(admin_queues->int_msg_num << 16);\n\twritel(reg, &pqi_registers->admin_iq_num_elements);\n\twritel(PQI_CREATE_ADMIN_QUEUE_PAIR,\n\t\t&pqi_registers->function_and_status_code);\n\n\ttimeout = PQI_ADMIN_QUEUE_CREATE_TIMEOUT_JIFFIES + jiffies;\n\twhile (1) {\n\t\tstatus = readb(&pqi_registers->function_and_status_code);\n\t\tif (status == PQI_STATUS_IDLE)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\t\tmsleep(PQI_ADMIN_QUEUE_CREATE_POLL_INTERVAL_MSECS);\n\t}\n\n\t/*\n\t * The offset registers are not initialized to the correct\n\t * offsets until *after* the create admin queue pair command\n\t * completes successfully.\n\t */\n\tadmin_queues->iq_pi = ctrl_info->iomem_base +\n\t\tPQI_DEVICE_REGISTERS_OFFSET +\n\t\treadq(&pqi_registers->admin_iq_pi_offset);\n\tadmin_queues->oq_ci = ctrl_info->iomem_base +\n\t\tPQI_DEVICE_REGISTERS_OFFSET +\n\t\treadq(&pqi_registers->admin_oq_ci_offset);\n\n\treturn 0;\n}\n\nstatic void pqi_submit_admin_request(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_general_admin_request *request)\n{\n\tstruct pqi_admin_queues *admin_queues;\n\tvoid *next_element;\n\tpqi_index_t iq_pi;\n\n\tadmin_queues = &ctrl_info->admin_queues;\n\tiq_pi = admin_queues->iq_pi_copy;\n\n\tnext_element = admin_queues->iq_element_array +\n\t\t(iq_pi * PQI_ADMIN_IQ_ELEMENT_LENGTH);\n\n\tmemcpy(next_element, request, sizeof(*request));\n\n\tiq_pi = (iq_pi + 1) % PQI_ADMIN_IQ_NUM_ELEMENTS;\n\tadmin_queues->iq_pi_copy = iq_pi;\n\n\t/*\n\t * This write notifies the controller that an IU is available to be\n\t * processed.\n\t */\n\twritel(iq_pi, admin_queues->iq_pi);\n}\n\n#define PQI_ADMIN_REQUEST_TIMEOUT_SECS\t60\n\nstatic int pqi_poll_for_admin_response(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_general_admin_response *response)\n{\n\tstruct pqi_admin_queues *admin_queues;\n\tpqi_index_t oq_pi;\n\tpqi_index_t oq_ci;\n\tunsigned long timeout;\n\n\tadmin_queues = &ctrl_info->admin_queues;\n\toq_ci = admin_queues->oq_ci_copy;\n\n\ttimeout = (PQI_ADMIN_REQUEST_TIMEOUT_SECS * PQI_HZ) + jiffies;\n\n\twhile (1) {\n\t\toq_pi = readl(admin_queues->oq_pi);\n\t\tif (oq_pi != oq_ci)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"timed out waiting for admin response\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tif (!sis_is_firmware_running(ctrl_info))\n\t\t\treturn -ENXIO;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tmemcpy(response, admin_queues->oq_element_array +\n\t\t(oq_ci * PQI_ADMIN_OQ_ELEMENT_LENGTH), sizeof(*response));\n\n\toq_ci = (oq_ci + 1) % PQI_ADMIN_OQ_NUM_ELEMENTS;\n\tadmin_queues->oq_ci_copy = oq_ci;\n\twritel(oq_ci, admin_queues->oq_ci);\n\n\treturn 0;\n}\n\nstatic void pqi_start_io(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_queue_group *queue_group, enum pqi_io_path path,\n\tstruct pqi_io_request *io_request)\n{\n\tstruct pqi_io_request *next;\n\tvoid *next_element;\n\tpqi_index_t iq_pi;\n\tpqi_index_t iq_ci;\n\tsize_t iu_length;\n\tunsigned long flags;\n\tunsigned int num_elements_needed;\n\tunsigned int num_elements_to_end_of_queue;\n\tsize_t copy_count;\n\tstruct pqi_iu_header *request;\n\n\tspin_lock_irqsave(&queue_group->submit_lock[path], flags);\n\n\tif (io_request) {\n\t\tio_request->queue_group = queue_group;\n\t\tlist_add_tail(&io_request->request_list_entry,\n\t\t\t&queue_group->request_list[path]);\n\t}\n\n\tiq_pi = queue_group->iq_pi_copy[path];\n\n\tlist_for_each_entry_safe(io_request, next,\n\t\t&queue_group->request_list[path], request_list_entry) {\n\n\t\trequest = io_request->iu;\n\n\t\tiu_length = get_unaligned_le16(&request->iu_length) +\n\t\t\tPQI_REQUEST_HEADER_LENGTH;\n\t\tnum_elements_needed =\n\t\t\tDIV_ROUND_UP(iu_length,\n\t\t\t\tPQI_OPERATIONAL_IQ_ELEMENT_LENGTH);\n\n\t\tiq_ci = readl(queue_group->iq_ci[path]);\n\n\t\tif (num_elements_needed > pqi_num_elements_free(iq_pi, iq_ci,\n\t\t\tctrl_info->num_elements_per_iq))\n\t\t\tbreak;\n\n\t\tput_unaligned_le16(queue_group->oq_id,\n\t\t\t&request->response_queue_id);\n\n\t\tnext_element = queue_group->iq_element_array[path] +\n\t\t\t(iq_pi * PQI_OPERATIONAL_IQ_ELEMENT_LENGTH);\n\n\t\tnum_elements_to_end_of_queue =\n\t\t\tctrl_info->num_elements_per_iq - iq_pi;\n\n\t\tif (num_elements_needed <= num_elements_to_end_of_queue) {\n\t\t\tmemcpy(next_element, request, iu_length);\n\t\t} else {\n\t\t\tcopy_count = num_elements_to_end_of_queue *\n\t\t\t\tPQI_OPERATIONAL_IQ_ELEMENT_LENGTH;\n\t\t\tmemcpy(next_element, request, copy_count);\n\t\t\tmemcpy(queue_group->iq_element_array[path],\n\t\t\t\t(u8 *)request + copy_count,\n\t\t\t\tiu_length - copy_count);\n\t\t}\n\n\t\tiq_pi = (iq_pi + num_elements_needed) %\n\t\t\tctrl_info->num_elements_per_iq;\n\n\t\tlist_del(&io_request->request_list_entry);\n\t}\n\n\tif (iq_pi != queue_group->iq_pi_copy[path]) {\n\t\tqueue_group->iq_pi_copy[path] = iq_pi;\n\t\t/*\n\t\t * This write notifies the controller that one or more IUs are\n\t\t * available to be processed.\n\t\t */\n\t\twritel(iq_pi, queue_group->iq_pi[path]);\n\t}\n\n\tspin_unlock_irqrestore(&queue_group->submit_lock[path], flags);\n}\n\n#define PQI_WAIT_FOR_COMPLETION_IO_TIMEOUT_SECS\t\t10\n\nstatic int pqi_wait_for_completion_io(struct pqi_ctrl_info *ctrl_info,\n\tstruct completion *wait)\n{\n\tint rc;\n\n\twhile (1) {\n\t\tif (wait_for_completion_io_timeout(wait,\n\t\t\tPQI_WAIT_FOR_COMPLETION_IO_TIMEOUT_SECS * PQI_HZ)) {\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tpqi_check_ctrl_health(ctrl_info);\n\t\tif (pqi_ctrl_offline(ctrl_info)) {\n\t\t\trc = -ENXIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic void pqi_raid_synchronous_complete(struct pqi_io_request *io_request,\n\tvoid *context)\n{\n\tstruct completion *waiting = context;\n\n\tcomplete(waiting);\n}\n\nstatic int pqi_process_raid_io_error_synchronous(\n\tstruct pqi_raid_error_info *error_info)\n{\n\tint rc = -EIO;\n\n\tswitch (error_info->data_out_result) {\n\tcase PQI_DATA_IN_OUT_GOOD:\n\t\tif (error_info->status == SAM_STAT_GOOD)\n\t\t\trc = 0;\n\t\tbreak;\n\tcase PQI_DATA_IN_OUT_UNDERFLOW:\n\t\tif (error_info->status == SAM_STAT_GOOD ||\n\t\t\terror_info->status == SAM_STAT_CHECK_CONDITION)\n\t\t\trc = 0;\n\t\tbreak;\n\tcase PQI_DATA_IN_OUT_ABORTED:\n\t\trc = PQI_CMD_STATUS_ABORTED;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int pqi_submit_raid_request_synchronous(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_iu_header *request, unsigned int flags,\n\tstruct pqi_raid_error_info *error_info, unsigned long timeout_msecs)\n{\n\tint rc = 0;\n\tstruct pqi_io_request *io_request;\n\tunsigned long start_jiffies;\n\tunsigned long msecs_blocked;\n\tsize_t iu_length;\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\n\t/*\n\t * Note that specifying PQI_SYNC_FLAGS_INTERRUPTABLE and a timeout value\n\t * are mutually exclusive.\n\t */\n\n\tif (flags & PQI_SYNC_FLAGS_INTERRUPTABLE) {\n\t\tif (down_interruptible(&ctrl_info->sync_request_sem))\n\t\t\treturn -ERESTARTSYS;\n\t} else {\n\t\tif (timeout_msecs == NO_TIMEOUT) {\n\t\t\tdown(&ctrl_info->sync_request_sem);\n\t\t} else {\n\t\t\tstart_jiffies = jiffies;\n\t\t\tif (down_timeout(&ctrl_info->sync_request_sem,\n\t\t\t\tmsecs_to_jiffies(timeout_msecs)))\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\tmsecs_blocked =\n\t\t\t\tjiffies_to_msecs(jiffies - start_jiffies);\n\t\t\tif (msecs_blocked >= timeout_msecs) {\n\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttimeout_msecs -= msecs_blocked;\n\t\t}\n\t}\n\n\tpqi_ctrl_busy(ctrl_info);\n\ttimeout_msecs = pqi_wait_if_ctrl_blocked(ctrl_info, timeout_msecs);\n\tif (timeout_msecs == 0) {\n\t\tpqi_ctrl_unbusy(ctrl_info);\n\t\trc = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tif (pqi_ctrl_offline(ctrl_info)) {\n\t\tpqi_ctrl_unbusy(ctrl_info);\n\t\trc = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tatomic_inc(&ctrl_info->sync_cmds_outstanding);\n\n\tio_request = pqi_alloc_io_request(ctrl_info);\n\n\tput_unaligned_le16(io_request->index,\n\t\t&(((struct pqi_raid_path_request *)request)->request_id));\n\n\tif (request->iu_type == PQI_REQUEST_IU_RAID_PATH_IO)\n\t\t((struct pqi_raid_path_request *)request)->error_index =\n\t\t\t((struct pqi_raid_path_request *)request)->request_id;\n\n\tiu_length = get_unaligned_le16(&request->iu_length) +\n\t\tPQI_REQUEST_HEADER_LENGTH;\n\tmemcpy(io_request->iu, request, iu_length);\n\n\tio_request->io_complete_callback = pqi_raid_synchronous_complete;\n\tio_request->context = &wait;\n\n\tpqi_start_io(ctrl_info,\n\t\t&ctrl_info->queue_groups[PQI_DEFAULT_QUEUE_GROUP], RAID_PATH,\n\t\tio_request);\n\n\tpqi_ctrl_unbusy(ctrl_info);\n\n\tif (timeout_msecs == NO_TIMEOUT) {\n\t\tpqi_wait_for_completion_io(ctrl_info, &wait);\n\t} else {\n\t\tif (!wait_for_completion_io_timeout(&wait,\n\t\t\tmsecs_to_jiffies(timeout_msecs))) {\n\t\t\tdev_warn(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"command timed out\\n\");\n\t\t\trc = -ETIMEDOUT;\n\t\t}\n\t}\n\n\tif (error_info) {\n\t\tif (io_request->error_info)\n\t\t\tmemcpy(error_info, io_request->error_info,\n\t\t\t\tsizeof(*error_info));\n\t\telse\n\t\t\tmemset(error_info, 0, sizeof(*error_info));\n\t} else if (rc == 0 && io_request->error_info) {\n\t\trc = pqi_process_raid_io_error_synchronous(\n\t\t\tio_request->error_info);\n\t}\n\n\tpqi_free_io_request(io_request);\n\n\tatomic_dec(&ctrl_info->sync_cmds_outstanding);\nout:\n\tup(&ctrl_info->sync_request_sem);\n\n\treturn rc;\n}\n\nstatic int pqi_validate_admin_response(\n\tstruct pqi_general_admin_response *response, u8 expected_function_code)\n{\n\tif (response->header.iu_type != PQI_RESPONSE_IU_GENERAL_ADMIN)\n\t\treturn -EINVAL;\n\n\tif (get_unaligned_le16(&response->header.iu_length) !=\n\t\tPQI_GENERAL_ADMIN_IU_LENGTH)\n\t\treturn -EINVAL;\n\n\tif (response->function_code != expected_function_code)\n\t\treturn -EINVAL;\n\n\tif (response->status != PQI_GENERAL_ADMIN_STATUS_SUCCESS)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int pqi_submit_admin_request_synchronous(\n\tstruct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_general_admin_request *request,\n\tstruct pqi_general_admin_response *response)\n{\n\tint rc;\n\n\tpqi_submit_admin_request(ctrl_info, request);\n\n\trc = pqi_poll_for_admin_response(ctrl_info, response);\n\n\tif (rc == 0)\n\t\trc = pqi_validate_admin_response(response,\n\t\t\trequest->function_code);\n\n\treturn rc;\n}\n\nstatic int pqi_report_device_capability(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tstruct pqi_general_admin_request request;\n\tstruct pqi_general_admin_response response;\n\tstruct pqi_device_capability *capability;\n\tstruct pqi_iu_layer_descriptor *sop_iu_layer_descriptor;\n\n\tcapability = kmalloc(sizeof(*capability), GFP_KERNEL);\n\tif (!capability)\n\t\treturn -ENOMEM;\n\n\tmemset(&request, 0, sizeof(request));\n\n\trequest.header.iu_type = PQI_REQUEST_IU_GENERAL_ADMIN;\n\tput_unaligned_le16(PQI_GENERAL_ADMIN_IU_LENGTH,\n\t\t&request.header.iu_length);\n\trequest.function_code =\n\t\tPQI_GENERAL_ADMIN_FUNCTION_REPORT_DEVICE_CAPABILITY;\n\tput_unaligned_le32(sizeof(*capability),\n\t\t&request.data.report_device_capability.buffer_length);\n\n\trc = pqi_map_single(ctrl_info->pci_dev,\n\t\t&request.data.report_device_capability.sg_descriptor,\n\t\tcapability, sizeof(*capability),\n\t\tDMA_FROM_DEVICE);\n\tif (rc)\n\t\tgoto out;\n\n\trc = pqi_submit_admin_request_synchronous(ctrl_info, &request,\n\t\t&response);\n\n\tpqi_pci_unmap(ctrl_info->pci_dev,\n\t\t&request.data.report_device_capability.sg_descriptor, 1,\n\t\tDMA_FROM_DEVICE);\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (response.status != PQI_GENERAL_ADMIN_STATUS_SUCCESS) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\tctrl_info->max_inbound_queues =\n\t\tget_unaligned_le16(&capability->max_inbound_queues);\n\tctrl_info->max_elements_per_iq =\n\t\tget_unaligned_le16(&capability->max_elements_per_iq);\n\tctrl_info->max_iq_element_length =\n\t\tget_unaligned_le16(&capability->max_iq_element_length)\n\t\t* 16;\n\tctrl_info->max_outbound_queues =\n\t\tget_unaligned_le16(&capability->max_outbound_queues);\n\tctrl_info->max_elements_per_oq =\n\t\tget_unaligned_le16(&capability->max_elements_per_oq);\n\tctrl_info->max_oq_element_length =\n\t\tget_unaligned_le16(&capability->max_oq_element_length)\n\t\t* 16;\n\n\tsop_iu_layer_descriptor =\n\t\t&capability->iu_layer_descriptors[PQI_PROTOCOL_SOP];\n\n\tctrl_info->max_inbound_iu_length_per_firmware =\n\t\tget_unaligned_le16(\n\t\t\t&sop_iu_layer_descriptor->max_inbound_iu_length);\n\tctrl_info->inbound_spanning_supported =\n\t\tsop_iu_layer_descriptor->inbound_spanning_supported;\n\tctrl_info->outbound_spanning_supported =\n\t\tsop_iu_layer_descriptor->outbound_spanning_supported;\n\nout:\n\tkfree(capability);\n\n\treturn rc;\n}\n\nstatic int pqi_validate_device_capability(struct pqi_ctrl_info *ctrl_info)\n{\n\tif (ctrl_info->max_iq_element_length <\n\t\tPQI_OPERATIONAL_IQ_ELEMENT_LENGTH) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"max. inbound queue element length of %d is less than the required length of %d\\n\",\n\t\t\tctrl_info->max_iq_element_length,\n\t\t\tPQI_OPERATIONAL_IQ_ELEMENT_LENGTH);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctrl_info->max_oq_element_length <\n\t\tPQI_OPERATIONAL_OQ_ELEMENT_LENGTH) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"max. outbound queue element length of %d is less than the required length of %d\\n\",\n\t\t\tctrl_info->max_oq_element_length,\n\t\t\tPQI_OPERATIONAL_OQ_ELEMENT_LENGTH);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctrl_info->max_inbound_iu_length_per_firmware <\n\t\tPQI_OPERATIONAL_IQ_ELEMENT_LENGTH) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"max. inbound IU length of %u is less than the min. required length of %d\\n\",\n\t\t\tctrl_info->max_inbound_iu_length_per_firmware,\n\t\t\tPQI_OPERATIONAL_IQ_ELEMENT_LENGTH);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ctrl_info->inbound_spanning_supported) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"the controller does not support inbound spanning\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctrl_info->outbound_spanning_supported) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"the controller supports outbound spanning but this driver does not\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int pqi_create_event_queue(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tstruct pqi_event_queue *event_queue;\n\tstruct pqi_general_admin_request request;\n\tstruct pqi_general_admin_response response;\n\n\tevent_queue = &ctrl_info->event_queue;\n\n\t/*\n\t * Create OQ (Outbound Queue - device to host queue) to dedicate\n\t * to events.\n\t */\n\tmemset(&request, 0, sizeof(request));\n\trequest.header.iu_type = PQI_REQUEST_IU_GENERAL_ADMIN;\n\tput_unaligned_le16(PQI_GENERAL_ADMIN_IU_LENGTH,\n\t\t&request.header.iu_length);\n\trequest.function_code = PQI_GENERAL_ADMIN_FUNCTION_CREATE_OQ;\n\tput_unaligned_le16(event_queue->oq_id,\n\t\t&request.data.create_operational_oq.queue_id);\n\tput_unaligned_le64((u64)event_queue->oq_element_array_bus_addr,\n\t\t&request.data.create_operational_oq.element_array_addr);\n\tput_unaligned_le64((u64)event_queue->oq_pi_bus_addr,\n\t\t&request.data.create_operational_oq.pi_addr);\n\tput_unaligned_le16(PQI_NUM_EVENT_QUEUE_ELEMENTS,\n\t\t&request.data.create_operational_oq.num_elements);\n\tput_unaligned_le16(PQI_EVENT_OQ_ELEMENT_LENGTH / 16,\n\t\t&request.data.create_operational_oq.element_length);\n\trequest.data.create_operational_oq.queue_protocol = PQI_PROTOCOL_SOP;\n\tput_unaligned_le16(event_queue->int_msg_num,\n\t\t&request.data.create_operational_oq.int_msg_num);\n\n\trc = pqi_submit_admin_request_synchronous(ctrl_info, &request,\n\t\t&response);\n\tif (rc)\n\t\treturn rc;\n\n\tevent_queue->oq_ci = ctrl_info->iomem_base +\n\t\tPQI_DEVICE_REGISTERS_OFFSET +\n\t\tget_unaligned_le64(\n\t\t\t&response.data.create_operational_oq.oq_ci_offset);\n\n\treturn 0;\n}\n\nstatic int pqi_create_queue_group(struct pqi_ctrl_info *ctrl_info,\n\tunsigned int group_number)\n{\n\tint rc;\n\tstruct pqi_queue_group *queue_group;\n\tstruct pqi_general_admin_request request;\n\tstruct pqi_general_admin_response response;\n\n\tqueue_group = &ctrl_info->queue_groups[group_number];\n\n\t/*\n\t * Create IQ (Inbound Queue - host to device queue) for\n\t * RAID path.\n\t */\n\tmemset(&request, 0, sizeof(request));\n\trequest.header.iu_type = PQI_REQUEST_IU_GENERAL_ADMIN;\n\tput_unaligned_le16(PQI_GENERAL_ADMIN_IU_LENGTH,\n\t\t&request.header.iu_length);\n\trequest.function_code = PQI_GENERAL_ADMIN_FUNCTION_CREATE_IQ;\n\tput_unaligned_le16(queue_group->iq_id[RAID_PATH],\n\t\t&request.data.create_operational_iq.queue_id);\n\tput_unaligned_le64(\n\t\t(u64)queue_group->iq_element_array_bus_addr[RAID_PATH],\n\t\t&request.data.create_operational_iq.element_array_addr);\n\tput_unaligned_le64((u64)queue_group->iq_ci_bus_addr[RAID_PATH],\n\t\t&request.data.create_operational_iq.ci_addr);\n\tput_unaligned_le16(ctrl_info->num_elements_per_iq,\n\t\t&request.data.create_operational_iq.num_elements);\n\tput_unaligned_le16(PQI_OPERATIONAL_IQ_ELEMENT_LENGTH / 16,\n\t\t&request.data.create_operational_iq.element_length);\n\trequest.data.create_operational_iq.queue_protocol = PQI_PROTOCOL_SOP;\n\n\trc = pqi_submit_admin_request_synchronous(ctrl_info, &request,\n\t\t&response);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error creating inbound RAID queue\\n\");\n\t\treturn rc;\n\t}\n\n\tqueue_group->iq_pi[RAID_PATH] = ctrl_info->iomem_base +\n\t\tPQI_DEVICE_REGISTERS_OFFSET +\n\t\tget_unaligned_le64(\n\t\t\t&response.data.create_operational_iq.iq_pi_offset);\n\n\t/*\n\t * Create IQ (Inbound Queue - host to device queue) for\n\t * Advanced I/O (AIO) path.\n\t */\n\tmemset(&request, 0, sizeof(request));\n\trequest.header.iu_type = PQI_REQUEST_IU_GENERAL_ADMIN;\n\tput_unaligned_le16(PQI_GENERAL_ADMIN_IU_LENGTH,\n\t\t&request.header.iu_length);\n\trequest.function_code = PQI_GENERAL_ADMIN_FUNCTION_CREATE_IQ;\n\tput_unaligned_le16(queue_group->iq_id[AIO_PATH],\n\t\t&request.data.create_operational_iq.queue_id);\n\tput_unaligned_le64((u64)queue_group->\n\t\tiq_element_array_bus_addr[AIO_PATH],\n\t\t&request.data.create_operational_iq.element_array_addr);\n\tput_unaligned_le64((u64)queue_group->iq_ci_bus_addr[AIO_PATH],\n\t\t&request.data.create_operational_iq.ci_addr);\n\tput_unaligned_le16(ctrl_info->num_elements_per_iq,\n\t\t&request.data.create_operational_iq.num_elements);\n\tput_unaligned_le16(PQI_OPERATIONAL_IQ_ELEMENT_LENGTH / 16,\n\t\t&request.data.create_operational_iq.element_length);\n\trequest.data.create_operational_iq.queue_protocol = PQI_PROTOCOL_SOP;\n\n\trc = pqi_submit_admin_request_synchronous(ctrl_info, &request,\n\t\t&response);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error creating inbound AIO queue\\n\");\n\t\treturn rc;\n\t}\n\n\tqueue_group->iq_pi[AIO_PATH] = ctrl_info->iomem_base +\n\t\tPQI_DEVICE_REGISTERS_OFFSET +\n\t\tget_unaligned_le64(\n\t\t\t&response.data.create_operational_iq.iq_pi_offset);\n\n\t/*\n\t * Designate the 2nd IQ as the AIO path.  By default, all IQs are\n\t * assumed to be for RAID path I/O unless we change the queue's\n\t * property.\n\t */\n\tmemset(&request, 0, sizeof(request));\n\trequest.header.iu_type = PQI_REQUEST_IU_GENERAL_ADMIN;\n\tput_unaligned_le16(PQI_GENERAL_ADMIN_IU_LENGTH,\n\t\t&request.header.iu_length);\n\trequest.function_code = PQI_GENERAL_ADMIN_FUNCTION_CHANGE_IQ_PROPERTY;\n\tput_unaligned_le16(queue_group->iq_id[AIO_PATH],\n\t\t&request.data.change_operational_iq_properties.queue_id);\n\tput_unaligned_le32(PQI_IQ_PROPERTY_IS_AIO_QUEUE,\n\t\t&request.data.change_operational_iq_properties.vendor_specific);\n\n\trc = pqi_submit_admin_request_synchronous(ctrl_info, &request,\n\t\t&response);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error changing queue property\\n\");\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Create OQ (Outbound Queue - device to host queue).\n\t */\n\tmemset(&request, 0, sizeof(request));\n\trequest.header.iu_type = PQI_REQUEST_IU_GENERAL_ADMIN;\n\tput_unaligned_le16(PQI_GENERAL_ADMIN_IU_LENGTH,\n\t\t&request.header.iu_length);\n\trequest.function_code = PQI_GENERAL_ADMIN_FUNCTION_CREATE_OQ;\n\tput_unaligned_le16(queue_group->oq_id,\n\t\t&request.data.create_operational_oq.queue_id);\n\tput_unaligned_le64((u64)queue_group->oq_element_array_bus_addr,\n\t\t&request.data.create_operational_oq.element_array_addr);\n\tput_unaligned_le64((u64)queue_group->oq_pi_bus_addr,\n\t\t&request.data.create_operational_oq.pi_addr);\n\tput_unaligned_le16(ctrl_info->num_elements_per_oq,\n\t\t&request.data.create_operational_oq.num_elements);\n\tput_unaligned_le16(PQI_OPERATIONAL_OQ_ELEMENT_LENGTH / 16,\n\t\t&request.data.create_operational_oq.element_length);\n\trequest.data.create_operational_oq.queue_protocol = PQI_PROTOCOL_SOP;\n\tput_unaligned_le16(queue_group->int_msg_num,\n\t\t&request.data.create_operational_oq.int_msg_num);\n\n\trc = pqi_submit_admin_request_synchronous(ctrl_info, &request,\n\t\t&response);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error creating outbound queue\\n\");\n\t\treturn rc;\n\t}\n\n\tqueue_group->oq_ci = ctrl_info->iomem_base +\n\t\tPQI_DEVICE_REGISTERS_OFFSET +\n\t\tget_unaligned_le64(\n\t\t\t&response.data.create_operational_oq.oq_ci_offset);\n\n\treturn 0;\n}\n\nstatic int pqi_create_queues(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tunsigned int i;\n\n\trc = pqi_create_event_queue(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error creating event queue\\n\");\n\t\treturn rc;\n\t}\n\n\tfor (i = 0; i < ctrl_info->num_queue_groups; i++) {\n\t\trc = pqi_create_queue_group(ctrl_info, i);\n\t\tif (rc) {\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"error creating queue group number %u/%u\\n\",\n\t\t\t\ti, ctrl_info->num_queue_groups);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define PQI_REPORT_EVENT_CONFIG_BUFFER_LENGTH\t\\\n\t(offsetof(struct pqi_event_config, descriptors) + \\\n\t(PQI_MAX_EVENT_DESCRIPTORS * sizeof(struct pqi_event_descriptor)))\n\nstatic int pqi_configure_events(struct pqi_ctrl_info *ctrl_info,\n\tbool enable_events)\n{\n\tint rc;\n\tunsigned int i;\n\tstruct pqi_event_config *event_config;\n\tstruct pqi_event_descriptor *event_descriptor;\n\tstruct pqi_general_management_request request;\n\n\tevent_config = kmalloc(PQI_REPORT_EVENT_CONFIG_BUFFER_LENGTH,\n\t\tGFP_KERNEL);\n\tif (!event_config)\n\t\treturn -ENOMEM;\n\n\tmemset(&request, 0, sizeof(request));\n\n\trequest.header.iu_type = PQI_REQUEST_IU_REPORT_VENDOR_EVENT_CONFIG;\n\tput_unaligned_le16(offsetof(struct pqi_general_management_request,\n\t\tdata.report_event_configuration.sg_descriptors[1]) -\n\t\tPQI_REQUEST_HEADER_LENGTH, &request.header.iu_length);\n\tput_unaligned_le32(PQI_REPORT_EVENT_CONFIG_BUFFER_LENGTH,\n\t\t&request.data.report_event_configuration.buffer_length);\n\n\trc = pqi_map_single(ctrl_info->pci_dev,\n\t\trequest.data.report_event_configuration.sg_descriptors,\n\t\tevent_config, PQI_REPORT_EVENT_CONFIG_BUFFER_LENGTH,\n\t\tDMA_FROM_DEVICE);\n\tif (rc)\n\t\tgoto out;\n\n\trc = pqi_submit_raid_request_synchronous(ctrl_info, &request.header,\n\t\t0, NULL, NO_TIMEOUT);\n\n\tpqi_pci_unmap(ctrl_info->pci_dev,\n\t\trequest.data.report_event_configuration.sg_descriptors, 1,\n\t\tDMA_FROM_DEVICE);\n\n\tif (rc)\n\t\tgoto out;\n\n\tfor (i = 0; i < event_config->num_event_descriptors; i++) {\n\t\tevent_descriptor = &event_config->descriptors[i];\n\t\tif (enable_events &&\n\t\t\tpqi_is_supported_event(event_descriptor->event_type))\n\t\t\tput_unaligned_le16(ctrl_info->event_queue.oq_id,\n\t\t\t\t\t&event_descriptor->oq_id);\n\t\telse\n\t\t\tput_unaligned_le16(0, &event_descriptor->oq_id);\n\t}\n\n\tmemset(&request, 0, sizeof(request));\n\n\trequest.header.iu_type = PQI_REQUEST_IU_SET_VENDOR_EVENT_CONFIG;\n\tput_unaligned_le16(offsetof(struct pqi_general_management_request,\n\t\tdata.report_event_configuration.sg_descriptors[1]) -\n\t\tPQI_REQUEST_HEADER_LENGTH, &request.header.iu_length);\n\tput_unaligned_le32(PQI_REPORT_EVENT_CONFIG_BUFFER_LENGTH,\n\t\t&request.data.report_event_configuration.buffer_length);\n\n\trc = pqi_map_single(ctrl_info->pci_dev,\n\t\trequest.data.report_event_configuration.sg_descriptors,\n\t\tevent_config, PQI_REPORT_EVENT_CONFIG_BUFFER_LENGTH,\n\t\tDMA_TO_DEVICE);\n\tif (rc)\n\t\tgoto out;\n\n\trc = pqi_submit_raid_request_synchronous(ctrl_info, &request.header, 0,\n\t\tNULL, NO_TIMEOUT);\n\n\tpqi_pci_unmap(ctrl_info->pci_dev,\n\t\trequest.data.report_event_configuration.sg_descriptors, 1,\n\t\tDMA_TO_DEVICE);\n\nout:\n\tkfree(event_config);\n\n\treturn rc;\n}\n\nstatic inline int pqi_enable_events(struct pqi_ctrl_info *ctrl_info)\n{\n\treturn pqi_configure_events(ctrl_info, true);\n}\n\nstatic inline int pqi_disable_events(struct pqi_ctrl_info *ctrl_info)\n{\n\treturn pqi_configure_events(ctrl_info, false);\n}\n\nstatic void pqi_free_all_io_requests(struct pqi_ctrl_info *ctrl_info)\n{\n\tunsigned int i;\n\tstruct device *dev;\n\tsize_t sg_chain_buffer_length;\n\tstruct pqi_io_request *io_request;\n\n\tif (!ctrl_info->io_request_pool)\n\t\treturn;\n\n\tdev = &ctrl_info->pci_dev->dev;\n\tsg_chain_buffer_length = ctrl_info->sg_chain_buffer_length;\n\tio_request = ctrl_info->io_request_pool;\n\n\tfor (i = 0; i < ctrl_info->max_io_slots; i++) {\n\t\tkfree(io_request->iu);\n\t\tif (!io_request->sg_chain_buffer)\n\t\t\tbreak;\n\t\tdma_free_coherent(dev, sg_chain_buffer_length,\n\t\t\tio_request->sg_chain_buffer,\n\t\t\tio_request->sg_chain_buffer_dma_handle);\n\t\tio_request++;\n\t}\n\n\tkfree(ctrl_info->io_request_pool);\n\tctrl_info->io_request_pool = NULL;\n}\n\nstatic inline int pqi_alloc_error_buffer(struct pqi_ctrl_info *ctrl_info)\n{\n\n\tctrl_info->error_buffer = dma_alloc_coherent(&ctrl_info->pci_dev->dev,\n\t\t\t\t     ctrl_info->error_buffer_length,\n\t\t\t\t     &ctrl_info->error_buffer_dma_handle,\n\t\t\t\t     GFP_KERNEL);\n\tif (!ctrl_info->error_buffer)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int pqi_alloc_io_resources(struct pqi_ctrl_info *ctrl_info)\n{\n\tunsigned int i;\n\tvoid *sg_chain_buffer;\n\tsize_t sg_chain_buffer_length;\n\tdma_addr_t sg_chain_buffer_dma_handle;\n\tstruct device *dev;\n\tstruct pqi_io_request *io_request;\n\n\tctrl_info->io_request_pool =\n\t\tkcalloc(ctrl_info->max_io_slots,\n\t\t\tsizeof(ctrl_info->io_request_pool[0]), GFP_KERNEL);\n\n\tif (!ctrl_info->io_request_pool) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"failed to allocate I/O request pool\\n\");\n\t\tgoto error;\n\t}\n\n\tdev = &ctrl_info->pci_dev->dev;\n\tsg_chain_buffer_length = ctrl_info->sg_chain_buffer_length;\n\tio_request = ctrl_info->io_request_pool;\n\n\tfor (i = 0; i < ctrl_info->max_io_slots; i++) {\n\t\tio_request->iu =\n\t\t\tkmalloc(ctrl_info->max_inbound_iu_length, GFP_KERNEL);\n\n\t\tif (!io_request->iu) {\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"failed to allocate IU buffers\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tsg_chain_buffer = dma_alloc_coherent(dev,\n\t\t\tsg_chain_buffer_length, &sg_chain_buffer_dma_handle,\n\t\t\tGFP_KERNEL);\n\n\t\tif (!sg_chain_buffer) {\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"failed to allocate PQI scatter-gather chain buffers\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tio_request->index = i;\n\t\tio_request->sg_chain_buffer = sg_chain_buffer;\n\t\tio_request->sg_chain_buffer_dma_handle =\n\t\t\tsg_chain_buffer_dma_handle;\n\t\tio_request++;\n\t}\n\n\treturn 0;\n\nerror:\n\tpqi_free_all_io_requests(ctrl_info);\n\n\treturn -ENOMEM;\n}\n\n/*\n * Calculate required resources that are sized based on max. outstanding\n * requests and max. transfer size.\n */\n\nstatic void pqi_calculate_io_resources(struct pqi_ctrl_info *ctrl_info)\n{\n\tu32 max_transfer_size;\n\tu32 max_sg_entries;\n\n\tctrl_info->scsi_ml_can_queue =\n\t\tctrl_info->max_outstanding_requests - PQI_RESERVED_IO_SLOTS;\n\tctrl_info->max_io_slots = ctrl_info->max_outstanding_requests;\n\n\tctrl_info->error_buffer_length =\n\t\tctrl_info->max_io_slots * PQI_ERROR_BUFFER_ELEMENT_LENGTH;\n\n\tif (reset_devices)\n\t\tmax_transfer_size = min(ctrl_info->max_transfer_size,\n\t\t\tPQI_MAX_TRANSFER_SIZE_KDUMP);\n\telse\n\t\tmax_transfer_size = min(ctrl_info->max_transfer_size,\n\t\t\tPQI_MAX_TRANSFER_SIZE);\n\n\tmax_sg_entries = max_transfer_size / PAGE_SIZE;\n\n\t/* +1 to cover when the buffer is not page-aligned. */\n\tmax_sg_entries++;\n\n\tmax_sg_entries = min(ctrl_info->max_sg_entries, max_sg_entries);\n\n\tmax_transfer_size = (max_sg_entries - 1) * PAGE_SIZE;\n\n\tctrl_info->sg_chain_buffer_length =\n\t\t(max_sg_entries * sizeof(struct pqi_sg_descriptor)) +\n\t\tPQI_EXTRA_SGL_MEMORY;\n\tctrl_info->sg_tablesize = max_sg_entries;\n\tctrl_info->max_sectors = max_transfer_size / 512;\n}\n\nstatic void pqi_calculate_queue_resources(struct pqi_ctrl_info *ctrl_info)\n{\n\tint num_queue_groups;\n\tu16 num_elements_per_iq;\n\tu16 num_elements_per_oq;\n\n\tif (reset_devices) {\n\t\tnum_queue_groups = 1;\n\t} else {\n\t\tint num_cpus;\n\t\tint max_queue_groups;\n\n\t\tmax_queue_groups = min(ctrl_info->max_inbound_queues / 2,\n\t\t\tctrl_info->max_outbound_queues - 1);\n\t\tmax_queue_groups = min(max_queue_groups, PQI_MAX_QUEUE_GROUPS);\n\n\t\tnum_cpus = num_online_cpus();\n\t\tnum_queue_groups = min(num_cpus, ctrl_info->max_msix_vectors);\n\t\tnum_queue_groups = min(num_queue_groups, max_queue_groups);\n\t}\n\n\tctrl_info->num_queue_groups = num_queue_groups;\n\tctrl_info->max_hw_queue_index = num_queue_groups - 1;\n\n\t/*\n\t * Make sure that the max. inbound IU length is an even multiple\n\t * of our inbound element length.\n\t */\n\tctrl_info->max_inbound_iu_length =\n\t\t(ctrl_info->max_inbound_iu_length_per_firmware /\n\t\tPQI_OPERATIONAL_IQ_ELEMENT_LENGTH) *\n\t\tPQI_OPERATIONAL_IQ_ELEMENT_LENGTH;\n\n\tnum_elements_per_iq =\n\t\t(ctrl_info->max_inbound_iu_length /\n\t\tPQI_OPERATIONAL_IQ_ELEMENT_LENGTH);\n\n\t/* Add one because one element in each queue is unusable. */\n\tnum_elements_per_iq++;\n\n\tnum_elements_per_iq = min(num_elements_per_iq,\n\t\tctrl_info->max_elements_per_iq);\n\n\tnum_elements_per_oq = ((num_elements_per_iq - 1) * 2) + 1;\n\tnum_elements_per_oq = min(num_elements_per_oq,\n\t\tctrl_info->max_elements_per_oq);\n\n\tctrl_info->num_elements_per_iq = num_elements_per_iq;\n\tctrl_info->num_elements_per_oq = num_elements_per_oq;\n\n\tctrl_info->max_sg_per_iu =\n\t\t((ctrl_info->max_inbound_iu_length -\n\t\tPQI_OPERATIONAL_IQ_ELEMENT_LENGTH) /\n\t\tsizeof(struct pqi_sg_descriptor)) +\n\t\tPQI_MAX_EMBEDDED_SG_DESCRIPTORS;\n}\n\nstatic inline void pqi_set_sg_descriptor(\n\tstruct pqi_sg_descriptor *sg_descriptor, struct scatterlist *sg)\n{\n\tu64 address = (u64)sg_dma_address(sg);\n\tunsigned int length = sg_dma_len(sg);\n\n\tput_unaligned_le64(address, &sg_descriptor->address);\n\tput_unaligned_le32(length, &sg_descriptor->length);\n\tput_unaligned_le32(0, &sg_descriptor->flags);\n}\n\nstatic int pqi_build_raid_sg_list(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_raid_path_request *request, struct scsi_cmnd *scmd,\n\tstruct pqi_io_request *io_request)\n{\n\tint i;\n\tu16 iu_length;\n\tint sg_count;\n\tbool chained;\n\tunsigned int num_sg_in_iu;\n\tunsigned int max_sg_per_iu;\n\tstruct scatterlist *sg;\n\tstruct pqi_sg_descriptor *sg_descriptor;\n\n\tsg_count = scsi_dma_map(scmd);\n\tif (sg_count < 0)\n\t\treturn sg_count;\n\n\tiu_length = offsetof(struct pqi_raid_path_request, sg_descriptors) -\n\t\tPQI_REQUEST_HEADER_LENGTH;\n\n\tif (sg_count == 0)\n\t\tgoto out;\n\n\tsg = scsi_sglist(scmd);\n\tsg_descriptor = request->sg_descriptors;\n\tmax_sg_per_iu = ctrl_info->max_sg_per_iu - 1;\n\tchained = false;\n\tnum_sg_in_iu = 0;\n\ti = 0;\n\n\twhile (1) {\n\t\tpqi_set_sg_descriptor(sg_descriptor, sg);\n\t\tif (!chained)\n\t\t\tnum_sg_in_iu++;\n\t\ti++;\n\t\tif (i == sg_count)\n\t\t\tbreak;\n\t\tsg_descriptor++;\n\t\tif (i == max_sg_per_iu) {\n\t\t\tput_unaligned_le64(\n\t\t\t\t(u64)io_request->sg_chain_buffer_dma_handle,\n\t\t\t\t&sg_descriptor->address);\n\t\t\tput_unaligned_le32((sg_count - num_sg_in_iu)\n\t\t\t\t* sizeof(*sg_descriptor),\n\t\t\t\t&sg_descriptor->length);\n\t\t\tput_unaligned_le32(CISS_SG_CHAIN,\n\t\t\t\t&sg_descriptor->flags);\n\t\t\tchained = true;\n\t\t\tnum_sg_in_iu++;\n\t\t\tsg_descriptor = io_request->sg_chain_buffer;\n\t\t}\n\t\tsg = sg_next(sg);\n\t}\n\n\tput_unaligned_le32(CISS_SG_LAST, &sg_descriptor->flags);\n\trequest->partial = chained;\n\tiu_length += num_sg_in_iu * sizeof(*sg_descriptor);\n\nout:\n\tput_unaligned_le16(iu_length, &request->header.iu_length);\n\n\treturn 0;\n}\n\nstatic int pqi_build_aio_sg_list(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_aio_path_request *request, struct scsi_cmnd *scmd,\n\tstruct pqi_io_request *io_request)\n{\n\tint i;\n\tu16 iu_length;\n\tint sg_count;\n\tbool chained;\n\tunsigned int num_sg_in_iu;\n\tunsigned int max_sg_per_iu;\n\tstruct scatterlist *sg;\n\tstruct pqi_sg_descriptor *sg_descriptor;\n\n\tsg_count = scsi_dma_map(scmd);\n\tif (sg_count < 0)\n\t\treturn sg_count;\n\n\tiu_length = offsetof(struct pqi_aio_path_request, sg_descriptors) -\n\t\tPQI_REQUEST_HEADER_LENGTH;\n\tnum_sg_in_iu = 0;\n\n\tif (sg_count == 0)\n\t\tgoto out;\n\n\tsg = scsi_sglist(scmd);\n\tsg_descriptor = request->sg_descriptors;\n\tmax_sg_per_iu = ctrl_info->max_sg_per_iu - 1;\n\tchained = false;\n\ti = 0;\n\n\twhile (1) {\n\t\tpqi_set_sg_descriptor(sg_descriptor, sg);\n\t\tif (!chained)\n\t\t\tnum_sg_in_iu++;\n\t\ti++;\n\t\tif (i == sg_count)\n\t\t\tbreak;\n\t\tsg_descriptor++;\n\t\tif (i == max_sg_per_iu) {\n\t\t\tput_unaligned_le64(\n\t\t\t\t(u64)io_request->sg_chain_buffer_dma_handle,\n\t\t\t\t&sg_descriptor->address);\n\t\t\tput_unaligned_le32((sg_count - num_sg_in_iu)\n\t\t\t\t* sizeof(*sg_descriptor),\n\t\t\t\t&sg_descriptor->length);\n\t\t\tput_unaligned_le32(CISS_SG_CHAIN,\n\t\t\t\t&sg_descriptor->flags);\n\t\t\tchained = true;\n\t\t\tnum_sg_in_iu++;\n\t\t\tsg_descriptor = io_request->sg_chain_buffer;\n\t\t}\n\t\tsg = sg_next(sg);\n\t}\n\n\tput_unaligned_le32(CISS_SG_LAST, &sg_descriptor->flags);\n\trequest->partial = chained;\n\tiu_length += num_sg_in_iu * sizeof(*sg_descriptor);\n\nout:\n\tput_unaligned_le16(iu_length, &request->header.iu_length);\n\trequest->num_sg_descriptors = num_sg_in_iu;\n\n\treturn 0;\n}\n\nstatic void pqi_raid_io_complete(struct pqi_io_request *io_request,\n\tvoid *context)\n{\n\tstruct scsi_cmnd *scmd;\n\n\tscmd = io_request->scmd;\n\tpqi_free_io_request(io_request);\n\tscsi_dma_unmap(scmd);\n\tpqi_scsi_done(scmd);\n}\n\nstatic int pqi_raid_submit_scsi_cmd_with_io_request(\n\tstruct pqi_ctrl_info *ctrl_info, struct pqi_io_request *io_request,\n\tstruct pqi_scsi_dev *device, struct scsi_cmnd *scmd,\n\tstruct pqi_queue_group *queue_group)\n{\n\tint rc;\n\tsize_t cdb_length;\n\tstruct pqi_raid_path_request *request;\n\n\tio_request->io_complete_callback = pqi_raid_io_complete;\n\tio_request->scmd = scmd;\n\n\trequest = io_request->iu;\n\tmemset(request, 0,\n\t\toffsetof(struct pqi_raid_path_request, sg_descriptors));\n\n\trequest->header.iu_type = PQI_REQUEST_IU_RAID_PATH_IO;\n\tput_unaligned_le32(scsi_bufflen(scmd), &request->buffer_length);\n\trequest->task_attribute = SOP_TASK_ATTRIBUTE_SIMPLE;\n\tput_unaligned_le16(io_request->index, &request->request_id);\n\trequest->error_index = request->request_id;\n\tmemcpy(request->lun_number, device->scsi3addr,\n\t\tsizeof(request->lun_number));\n\n\tcdb_length = min_t(size_t, scmd->cmd_len, sizeof(request->cdb));\n\tmemcpy(request->cdb, scmd->cmnd, cdb_length);\n\n\tswitch (cdb_length) {\n\tcase 6:\n\tcase 10:\n\tcase 12:\n\tcase 16:\n\t\t/* No bytes in the Additional CDB bytes field */\n\t\trequest->additional_cdb_bytes_usage =\n\t\t\tSOP_ADDITIONAL_CDB_BYTES_0;\n\t\tbreak;\n\tcase 20:\n\t\t/* 4 bytes in the Additional cdb field */\n\t\trequest->additional_cdb_bytes_usage =\n\t\t\tSOP_ADDITIONAL_CDB_BYTES_4;\n\t\tbreak;\n\tcase 24:\n\t\t/* 8 bytes in the Additional cdb field */\n\t\trequest->additional_cdb_bytes_usage =\n\t\t\tSOP_ADDITIONAL_CDB_BYTES_8;\n\t\tbreak;\n\tcase 28:\n\t\t/* 12 bytes in the Additional cdb field */\n\t\trequest->additional_cdb_bytes_usage =\n\t\t\tSOP_ADDITIONAL_CDB_BYTES_12;\n\t\tbreak;\n\tcase 32:\n\tdefault:\n\t\t/* 16 bytes in the Additional cdb field */\n\t\trequest->additional_cdb_bytes_usage =\n\t\t\tSOP_ADDITIONAL_CDB_BYTES_16;\n\t\tbreak;\n\t}\n\n\tswitch (scmd->sc_data_direction) {\n\tcase DMA_TO_DEVICE:\n\t\trequest->data_direction = SOP_READ_FLAG;\n\t\tbreak;\n\tcase DMA_FROM_DEVICE:\n\t\trequest->data_direction = SOP_WRITE_FLAG;\n\t\tbreak;\n\tcase DMA_NONE:\n\t\trequest->data_direction = SOP_NO_DIRECTION_FLAG;\n\t\tbreak;\n\tcase DMA_BIDIRECTIONAL:\n\t\trequest->data_direction = SOP_BIDIRECTIONAL;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"unknown data direction: %d\\n\",\n\t\t\tscmd->sc_data_direction);\n\t\tbreak;\n\t}\n\n\trc = pqi_build_raid_sg_list(ctrl_info, request, scmd, io_request);\n\tif (rc) {\n\t\tpqi_free_io_request(io_request);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tpqi_start_io(ctrl_info, queue_group, RAID_PATH, io_request);\n\n\treturn 0;\n}\n\nstatic inline int pqi_raid_submit_scsi_cmd(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device, struct scsi_cmnd *scmd,\n\tstruct pqi_queue_group *queue_group)\n{\n\tstruct pqi_io_request *io_request;\n\n\tio_request = pqi_alloc_io_request(ctrl_info);\n\n\treturn pqi_raid_submit_scsi_cmd_with_io_request(ctrl_info, io_request,\n\t\tdevice, scmd, queue_group);\n}\n\nstatic inline void pqi_schedule_bypass_retry(struct pqi_ctrl_info *ctrl_info)\n{\n\tif (!pqi_ctrl_blocked(ctrl_info))\n\t\tschedule_work(&ctrl_info->raid_bypass_retry_work);\n}\n\nstatic bool pqi_raid_bypass_retry_needed(struct pqi_io_request *io_request)\n{\n\tstruct scsi_cmnd *scmd;\n\tstruct pqi_scsi_dev *device;\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tif (!io_request->raid_bypass)\n\t\treturn false;\n\n\tscmd = io_request->scmd;\n\tif ((scmd->result & 0xff) == SAM_STAT_GOOD)\n\t\treturn false;\n\tif (host_byte(scmd->result) == DID_NO_CONNECT)\n\t\treturn false;\n\n\tdevice = scmd->device->hostdata;\n\tif (pqi_device_offline(device))\n\t\treturn false;\n\n\tctrl_info = shost_to_hba(scmd->device->host);\n\tif (pqi_ctrl_offline(ctrl_info))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline void pqi_add_to_raid_bypass_retry_list(\n\tstruct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_io_request *io_request, bool at_head)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctrl_info->raid_bypass_retry_list_lock, flags);\n\tif (at_head)\n\t\tlist_add(&io_request->request_list_entry,\n\t\t\t&ctrl_info->raid_bypass_retry_list);\n\telse\n\t\tlist_add_tail(&io_request->request_list_entry,\n\t\t\t&ctrl_info->raid_bypass_retry_list);\n\tspin_unlock_irqrestore(&ctrl_info->raid_bypass_retry_list_lock, flags);\n}\n\nstatic void pqi_queued_raid_bypass_complete(struct pqi_io_request *io_request,\n\tvoid *context)\n{\n\tstruct scsi_cmnd *scmd;\n\n\tscmd = io_request->scmd;\n\tpqi_free_io_request(io_request);\n\tpqi_scsi_done(scmd);\n}\n\nstatic void pqi_queue_raid_bypass_retry(struct pqi_io_request *io_request)\n{\n\tstruct scsi_cmnd *scmd;\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tio_request->io_complete_callback = pqi_queued_raid_bypass_complete;\n\tscmd = io_request->scmd;\n\tscmd->result = 0;\n\tctrl_info = shost_to_hba(scmd->device->host);\n\n\tpqi_add_to_raid_bypass_retry_list(ctrl_info, io_request, false);\n\tpqi_schedule_bypass_retry(ctrl_info);\n}\n\nstatic int pqi_retry_raid_bypass(struct pqi_io_request *io_request)\n{\n\tstruct scsi_cmnd *scmd;\n\tstruct pqi_scsi_dev *device;\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct pqi_queue_group *queue_group;\n\n\tscmd = io_request->scmd;\n\tdevice = scmd->device->hostdata;\n\tif (pqi_device_in_reset(device)) {\n\t\tpqi_free_io_request(io_request);\n\t\tset_host_byte(scmd, DID_RESET);\n\t\tpqi_scsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tctrl_info = shost_to_hba(scmd->device->host);\n\tqueue_group = io_request->queue_group;\n\n\tpqi_reinit_io_request(io_request);\n\n\treturn pqi_raid_submit_scsi_cmd_with_io_request(ctrl_info, io_request,\n\t\tdevice, scmd, queue_group);\n}\n\nstatic inline struct pqi_io_request *pqi_next_queued_raid_bypass_request(\n\tstruct pqi_ctrl_info *ctrl_info)\n{\n\tunsigned long flags;\n\tstruct pqi_io_request *io_request;\n\n\tspin_lock_irqsave(&ctrl_info->raid_bypass_retry_list_lock, flags);\n\tio_request = list_first_entry_or_null(\n\t\t&ctrl_info->raid_bypass_retry_list,\n\t\tstruct pqi_io_request, request_list_entry);\n\tif (io_request)\n\t\tlist_del(&io_request->request_list_entry);\n\tspin_unlock_irqrestore(&ctrl_info->raid_bypass_retry_list_lock, flags);\n\n\treturn io_request;\n}\n\nstatic void pqi_retry_raid_bypass_requests(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tstruct pqi_io_request *io_request;\n\n\tpqi_ctrl_busy(ctrl_info);\n\n\twhile (1) {\n\t\tif (pqi_ctrl_blocked(ctrl_info))\n\t\t\tbreak;\n\t\tio_request = pqi_next_queued_raid_bypass_request(ctrl_info);\n\t\tif (!io_request)\n\t\t\tbreak;\n\t\trc = pqi_retry_raid_bypass(io_request);\n\t\tif (rc) {\n\t\t\tpqi_add_to_raid_bypass_retry_list(ctrl_info, io_request,\n\t\t\t\ttrue);\n\t\t\tpqi_schedule_bypass_retry(ctrl_info);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpqi_ctrl_unbusy(ctrl_info);\n}\n\nstatic void pqi_raid_bypass_retry_worker(struct work_struct *work)\n{\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tctrl_info = container_of(work, struct pqi_ctrl_info,\n\t\traid_bypass_retry_work);\n\tpqi_retry_raid_bypass_requests(ctrl_info);\n}\n\nstatic void pqi_clear_all_queued_raid_bypass_retries(\n\tstruct pqi_ctrl_info *ctrl_info)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctrl_info->raid_bypass_retry_list_lock, flags);\n\tINIT_LIST_HEAD(&ctrl_info->raid_bypass_retry_list);\n\tspin_unlock_irqrestore(&ctrl_info->raid_bypass_retry_list_lock, flags);\n}\n\nstatic void pqi_aio_io_complete(struct pqi_io_request *io_request,\n\tvoid *context)\n{\n\tstruct scsi_cmnd *scmd;\n\n\tscmd = io_request->scmd;\n\tscsi_dma_unmap(scmd);\n\tif (io_request->status == -EAGAIN)\n\t\tset_host_byte(scmd, DID_IMM_RETRY);\n\telse if (pqi_raid_bypass_retry_needed(io_request)) {\n\t\tpqi_queue_raid_bypass_retry(io_request);\n\t\treturn;\n\t}\n\tpqi_free_io_request(io_request);\n\tpqi_scsi_done(scmd);\n}\n\nstatic inline int pqi_aio_submit_scsi_cmd(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device, struct scsi_cmnd *scmd,\n\tstruct pqi_queue_group *queue_group)\n{\n\treturn pqi_aio_submit_io(ctrl_info, scmd, device->aio_handle,\n\t\tscmd->cmnd, scmd->cmd_len, queue_group, NULL, false);\n}\n\nstatic int pqi_aio_submit_io(struct pqi_ctrl_info *ctrl_info,\n\tstruct scsi_cmnd *scmd, u32 aio_handle, u8 *cdb,\n\tunsigned int cdb_length, struct pqi_queue_group *queue_group,\n\tstruct pqi_encryption_info *encryption_info, bool raid_bypass)\n{\n\tint rc;\n\tstruct pqi_io_request *io_request;\n\tstruct pqi_aio_path_request *request;\n\n\tio_request = pqi_alloc_io_request(ctrl_info);\n\tio_request->io_complete_callback = pqi_aio_io_complete;\n\tio_request->scmd = scmd;\n\tio_request->raid_bypass = raid_bypass;\n\n\trequest = io_request->iu;\n\tmemset(request, 0,\n\t\toffsetof(struct pqi_raid_path_request, sg_descriptors));\n\n\trequest->header.iu_type = PQI_REQUEST_IU_AIO_PATH_IO;\n\tput_unaligned_le32(aio_handle, &request->nexus_id);\n\tput_unaligned_le32(scsi_bufflen(scmd), &request->buffer_length);\n\trequest->task_attribute = SOP_TASK_ATTRIBUTE_SIMPLE;\n\tput_unaligned_le16(io_request->index, &request->request_id);\n\trequest->error_index = request->request_id;\n\tif (cdb_length > sizeof(request->cdb))\n\t\tcdb_length = sizeof(request->cdb);\n\trequest->cdb_length = cdb_length;\n\tmemcpy(request->cdb, cdb, cdb_length);\n\n\tswitch (scmd->sc_data_direction) {\n\tcase DMA_TO_DEVICE:\n\t\trequest->data_direction = SOP_READ_FLAG;\n\t\tbreak;\n\tcase DMA_FROM_DEVICE:\n\t\trequest->data_direction = SOP_WRITE_FLAG;\n\t\tbreak;\n\tcase DMA_NONE:\n\t\trequest->data_direction = SOP_NO_DIRECTION_FLAG;\n\t\tbreak;\n\tcase DMA_BIDIRECTIONAL:\n\t\trequest->data_direction = SOP_BIDIRECTIONAL;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"unknown data direction: %d\\n\",\n\t\t\tscmd->sc_data_direction);\n\t\tbreak;\n\t}\n\n\tif (encryption_info) {\n\t\trequest->encryption_enable = true;\n\t\tput_unaligned_le16(encryption_info->data_encryption_key_index,\n\t\t\t&request->data_encryption_key_index);\n\t\tput_unaligned_le32(encryption_info->encrypt_tweak_lower,\n\t\t\t&request->encrypt_tweak_lower);\n\t\tput_unaligned_le32(encryption_info->encrypt_tweak_upper,\n\t\t\t&request->encrypt_tweak_upper);\n\t}\n\n\trc = pqi_build_aio_sg_list(ctrl_info, request, scmd, io_request);\n\tif (rc) {\n\t\tpqi_free_io_request(io_request);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tpqi_start_io(ctrl_info, queue_group, AIO_PATH, io_request);\n\n\treturn 0;\n}\n\nstatic inline u16 pqi_get_hw_queue(struct pqi_ctrl_info *ctrl_info,\n\tstruct scsi_cmnd *scmd)\n{\n\tu16 hw_queue;\n\n\thw_queue = blk_mq_unique_tag_to_hwq(blk_mq_unique_tag(scmd->request));\n\tif (hw_queue > ctrl_info->max_hw_queue_index)\n\t\thw_queue = 0;\n\n\treturn hw_queue;\n}\n\n/*\n * This function gets called just before we hand the completed SCSI request\n * back to the SML.\n */\n\nvoid pqi_prep_for_scsi_done(struct scsi_cmnd *scmd)\n{\n\tstruct pqi_scsi_dev *device;\n\n\tif (!scmd->device) {\n\t\tset_host_byte(scmd, DID_NO_CONNECT);\n\t\treturn;\n\t}\n\n\tdevice = scmd->device->hostdata;\n\tif (!device) {\n\t\tset_host_byte(scmd, DID_NO_CONNECT);\n\t\treturn;\n\t}\n\n\tatomic_dec(&device->scsi_cmds_outstanding);\n}\n\nstatic int pqi_scsi_queue_command(struct Scsi_Host *shost,\n\tstruct scsi_cmnd *scmd)\n{\n\tint rc;\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct pqi_scsi_dev *device;\n\tu16 hw_queue;\n\tstruct pqi_queue_group *queue_group;\n\tbool raid_bypassed;\n\n\tdevice = scmd->device->hostdata;\n\tctrl_info = shost_to_hba(shost);\n\n\tif (!device) {\n\t\tset_host_byte(scmd, DID_NO_CONNECT);\n\t\tpqi_scsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tatomic_inc(&device->scsi_cmds_outstanding);\n\n\tif (pqi_ctrl_offline(ctrl_info) || pqi_device_in_remove(device)) {\n\t\tset_host_byte(scmd, DID_NO_CONNECT);\n\t\tpqi_scsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tpqi_ctrl_busy(ctrl_info);\n\tif (pqi_ctrl_blocked(ctrl_info) || pqi_device_in_reset(device) ||\n\t    pqi_ctrl_in_ofa(ctrl_info) || pqi_ctrl_in_shutdown(ctrl_info)) {\n\t\trc = SCSI_MLQUEUE_HOST_BUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * This is necessary because the SML doesn't zero out this field during\n\t * error recovery.\n\t */\n\tscmd->result = 0;\n\n\thw_queue = pqi_get_hw_queue(ctrl_info, scmd);\n\tqueue_group = &ctrl_info->queue_groups[hw_queue];\n\n\tif (pqi_is_logical_device(device)) {\n\t\traid_bypassed = false;\n\t\tif (device->raid_bypass_enabled &&\n\t\t\t!blk_rq_is_passthrough(scmd->request)) {\n\t\t\trc = pqi_raid_bypass_submit_scsi_cmd(ctrl_info, device,\n\t\t\t\tscmd, queue_group);\n\t\t\tif (rc == 0 || rc == SCSI_MLQUEUE_HOST_BUSY) {\n\t\t\t\traid_bypassed = true;\n\t\t\t\tatomic_inc(&device->raid_bypass_cnt);\n\t\t\t}\n\t\t}\n\t\tif (!raid_bypassed)\n\t\t\trc = pqi_raid_submit_scsi_cmd(ctrl_info, device, scmd, queue_group);\n\t} else {\n\t\tif (device->aio_enabled)\n\t\t\trc = pqi_aio_submit_scsi_cmd(ctrl_info, device, scmd, queue_group);\n\t\telse\n\t\t\trc = pqi_raid_submit_scsi_cmd(ctrl_info, device, scmd, queue_group);\n\t}\n\nout:\n\tpqi_ctrl_unbusy(ctrl_info);\n\tif (rc)\n\t\tatomic_dec(&device->scsi_cmds_outstanding);\n\n\treturn rc;\n}\n\nstatic int pqi_wait_until_queued_io_drained(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_queue_group *queue_group)\n{\n\tunsigned int path;\n\tunsigned long flags;\n\tbool list_is_empty;\n\n\tfor (path = 0; path < 2; path++) {\n\t\twhile (1) {\n\t\t\tspin_lock_irqsave(\n\t\t\t\t&queue_group->submit_lock[path], flags);\n\t\t\tlist_is_empty =\n\t\t\t\tlist_empty(&queue_group->request_list[path]);\n\t\t\tspin_unlock_irqrestore(\n\t\t\t\t&queue_group->submit_lock[path], flags);\n\t\t\tif (list_is_empty)\n\t\t\t\tbreak;\n\t\t\tpqi_check_ctrl_health(ctrl_info);\n\t\t\tif (pqi_ctrl_offline(ctrl_info))\n\t\t\t\treturn -ENXIO;\n\t\t\tusleep_range(1000, 2000);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pqi_wait_until_inbound_queues_empty(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tunsigned int i;\n\tunsigned int path;\n\tstruct pqi_queue_group *queue_group;\n\tpqi_index_t iq_pi;\n\tpqi_index_t iq_ci;\n\n\tfor (i = 0; i < ctrl_info->num_queue_groups; i++) {\n\t\tqueue_group = &ctrl_info->queue_groups[i];\n\n\t\trc = pqi_wait_until_queued_io_drained(ctrl_info, queue_group);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tfor (path = 0; path < 2; path++) {\n\t\t\tiq_pi = queue_group->iq_pi_copy[path];\n\n\t\t\twhile (1) {\n\t\t\t\tiq_ci = readl(queue_group->iq_ci[path]);\n\t\t\t\tif (iq_ci == iq_pi)\n\t\t\t\t\tbreak;\n\t\t\t\tpqi_check_ctrl_health(ctrl_info);\n\t\t\t\tif (pqi_ctrl_offline(ctrl_info))\n\t\t\t\t\treturn -ENXIO;\n\t\t\t\tusleep_range(1000, 2000);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void pqi_fail_io_queued_for_device(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device)\n{\n\tunsigned int i;\n\tunsigned int path;\n\tstruct pqi_queue_group *queue_group;\n\tunsigned long flags;\n\tstruct pqi_io_request *io_request;\n\tstruct pqi_io_request *next;\n\tstruct scsi_cmnd *scmd;\n\tstruct pqi_scsi_dev *scsi_device;\n\n\tfor (i = 0; i < ctrl_info->num_queue_groups; i++) {\n\t\tqueue_group = &ctrl_info->queue_groups[i];\n\n\t\tfor (path = 0; path < 2; path++) {\n\t\t\tspin_lock_irqsave(\n\t\t\t\t&queue_group->submit_lock[path], flags);\n\n\t\t\tlist_for_each_entry_safe(io_request, next,\n\t\t\t\t&queue_group->request_list[path],\n\t\t\t\trequest_list_entry) {\n\t\t\t\tscmd = io_request->scmd;\n\t\t\t\tif (!scmd)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tscsi_device = scmd->device->hostdata;\n\t\t\t\tif (scsi_device != device)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tlist_del(&io_request->request_list_entry);\n\t\t\t\tset_host_byte(scmd, DID_RESET);\n\t\t\t\tpqi_scsi_done(scmd);\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(\n\t\t\t\t&queue_group->submit_lock[path], flags);\n\t\t}\n\t}\n}\n\nstatic void pqi_fail_io_queued_for_all_devices(struct pqi_ctrl_info *ctrl_info)\n{\n\tunsigned int i;\n\tunsigned int path;\n\tstruct pqi_queue_group *queue_group;\n\tunsigned long flags;\n\tstruct pqi_io_request *io_request;\n\tstruct pqi_io_request *next;\n\tstruct scsi_cmnd *scmd;\n\n\tfor (i = 0; i < ctrl_info->num_queue_groups; i++) {\n\t\tqueue_group = &ctrl_info->queue_groups[i];\n\n\t\tfor (path = 0; path < 2; path++) {\n\t\t\tspin_lock_irqsave(&queue_group->submit_lock[path],\n\t\t\t\t\t\tflags);\n\n\t\t\tlist_for_each_entry_safe(io_request, next,\n\t\t\t\t&queue_group->request_list[path],\n\t\t\t\trequest_list_entry) {\n\n\t\t\t\tscmd = io_request->scmd;\n\t\t\t\tif (!scmd)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tlist_del(&io_request->request_list_entry);\n\t\t\t\tset_host_byte(scmd, DID_RESET);\n\t\t\t\tpqi_scsi_done(scmd);\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(\n\t\t\t\t&queue_group->submit_lock[path], flags);\n\t\t}\n\t}\n}\n\nstatic int pqi_device_wait_for_pending_io(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device, unsigned long timeout_secs)\n{\n\tunsigned long timeout;\n\n\ttimeout = (timeout_secs * PQI_HZ) + jiffies;\n\n\twhile (atomic_read(&device->scsi_cmds_outstanding)) {\n\t\tpqi_check_ctrl_health(ctrl_info);\n\t\tif (pqi_ctrl_offline(ctrl_info))\n\t\t\treturn -ENXIO;\n\t\tif (timeout_secs != NO_TIMEOUT) {\n\t\t\tif (time_after(jiffies, timeout)) {\n\t\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\t\"timed out waiting for pending IO\\n\");\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t}\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn 0;\n}\n\nstatic int pqi_ctrl_wait_for_pending_io(struct pqi_ctrl_info *ctrl_info,\n\tunsigned long timeout_secs)\n{\n\tbool io_pending;\n\tunsigned long flags;\n\tunsigned long timeout;\n\tstruct pqi_scsi_dev *device;\n\n\ttimeout = (timeout_secs * PQI_HZ) + jiffies;\n\twhile (1) {\n\t\tio_pending = false;\n\n\t\tspin_lock_irqsave(&ctrl_info->scsi_device_list_lock, flags);\n\t\tlist_for_each_entry(device, &ctrl_info->scsi_device_list,\n\t\t\tscsi_device_list_entry) {\n\t\t\tif (atomic_read(&device->scsi_cmds_outstanding)) {\n\t\t\t\tio_pending = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock,\n\t\t\t\t\tflags);\n\n\t\tif (!io_pending)\n\t\t\tbreak;\n\n\t\tpqi_check_ctrl_health(ctrl_info);\n\t\tif (pqi_ctrl_offline(ctrl_info))\n\t\t\treturn -ENXIO;\n\n\t\tif (timeout_secs != NO_TIMEOUT) {\n\t\t\tif (time_after(jiffies, timeout)) {\n\t\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\t\"timed out waiting for pending IO\\n\");\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t}\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn 0;\n}\n\nstatic int pqi_ctrl_wait_for_pending_sync_cmds(struct pqi_ctrl_info *ctrl_info)\n{\n\twhile (atomic_read(&ctrl_info->sync_cmds_outstanding)) {\n\t\tpqi_check_ctrl_health(ctrl_info);\n\t\tif (pqi_ctrl_offline(ctrl_info))\n\t\t\treturn -ENXIO;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn 0;\n}\n\nstatic void pqi_lun_reset_complete(struct pqi_io_request *io_request,\n\tvoid *context)\n{\n\tstruct completion *waiting = context;\n\n\tcomplete(waiting);\n}\n\n#define PQI_LUN_RESET_TIMEOUT_SECS\t\t30\n#define PQI_LUN_RESET_POLL_COMPLETION_SECS\t10\n\nstatic int pqi_wait_for_lun_reset_completion(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device, struct completion *wait)\n{\n\tint rc;\n\n\twhile (1) {\n\t\tif (wait_for_completion_io_timeout(wait,\n\t\t\tPQI_LUN_RESET_POLL_COMPLETION_SECS * PQI_HZ)) {\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tpqi_check_ctrl_health(ctrl_info);\n\t\tif (pqi_ctrl_offline(ctrl_info)) {\n\t\t\trc = -ENXIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int pqi_lun_reset(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device)\n{\n\tint rc;\n\tstruct pqi_io_request *io_request;\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\tstruct pqi_task_management_request *request;\n\n\tio_request = pqi_alloc_io_request(ctrl_info);\n\tio_request->io_complete_callback = pqi_lun_reset_complete;\n\tio_request->context = &wait;\n\n\trequest = io_request->iu;\n\tmemset(request, 0, sizeof(*request));\n\n\trequest->header.iu_type = PQI_REQUEST_IU_TASK_MANAGEMENT;\n\tput_unaligned_le16(sizeof(*request) - PQI_REQUEST_HEADER_LENGTH,\n\t\t&request->header.iu_length);\n\tput_unaligned_le16(io_request->index, &request->request_id);\n\tmemcpy(request->lun_number, device->scsi3addr,\n\t\tsizeof(request->lun_number));\n\trequest->task_management_function = SOP_TASK_MANAGEMENT_LUN_RESET;\n\tif (ctrl_info->tmf_iu_timeout_supported)\n\t\tput_unaligned_le16(PQI_LUN_RESET_TIMEOUT_SECS,\n\t\t\t\t\t&request->timeout);\n\n\tpqi_start_io(ctrl_info,\n\t\t&ctrl_info->queue_groups[PQI_DEFAULT_QUEUE_GROUP], RAID_PATH,\n\t\tio_request);\n\n\trc = pqi_wait_for_lun_reset_completion(ctrl_info, device, &wait);\n\tif (rc == 0)\n\t\trc = io_request->status;\n\n\tpqi_free_io_request(io_request);\n\n\treturn rc;\n}\n\n/* Performs a reset at the LUN level. */\n\n#define PQI_LUN_RESET_RETRIES\t\t\t3\n#define PQI_LUN_RESET_RETRY_INTERVAL_MSECS\t10000\n#define PQI_LUN_RESET_PENDING_IO_TIMEOUT_SECS\t120\n\nstatic int _pqi_device_reset(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device)\n{\n\tint rc;\n\tunsigned int retries;\n\tunsigned long timeout_secs;\n\n\tfor (retries = 0;;) {\n\t\trc = pqi_lun_reset(ctrl_info, device);\n\t\tif (rc == 0 || ++retries > PQI_LUN_RESET_RETRIES)\n\t\t\tbreak;\n\t\tmsleep(PQI_LUN_RESET_RETRY_INTERVAL_MSECS);\n\t}\n\n\ttimeout_secs = rc ? PQI_LUN_RESET_PENDING_IO_TIMEOUT_SECS : NO_TIMEOUT;\n\n\trc |= pqi_device_wait_for_pending_io(ctrl_info, device, timeout_secs);\n\n\treturn rc == 0 ? SUCCESS : FAILED;\n}\n\nstatic int pqi_device_reset(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_scsi_dev *device)\n{\n\tint rc;\n\n\tmutex_lock(&ctrl_info->lun_reset_mutex);\n\n\tpqi_ctrl_block_requests(ctrl_info);\n\tpqi_ctrl_wait_until_quiesced(ctrl_info);\n\tpqi_fail_io_queued_for_device(ctrl_info, device);\n\trc = pqi_wait_until_inbound_queues_empty(ctrl_info);\n\tpqi_device_reset_start(device);\n\tpqi_ctrl_unblock_requests(ctrl_info);\n\n\tif (rc)\n\t\trc = FAILED;\n\telse\n\t\trc = _pqi_device_reset(ctrl_info, device);\n\n\tpqi_device_reset_done(device);\n\n\tmutex_unlock(&ctrl_info->lun_reset_mutex);\n\n\treturn rc;\n}\n\nstatic int pqi_eh_device_reset_handler(struct scsi_cmnd *scmd)\n{\n\tint rc;\n\tstruct Scsi_Host *shost;\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct pqi_scsi_dev *device;\n\n\tshost = scmd->device->host;\n\tctrl_info = shost_to_hba(shost);\n\tdevice = scmd->device->hostdata;\n\n\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\"resetting scsi %d:%d:%d:%d\\n\",\n\t\tshost->host_no, device->bus, device->target, device->lun);\n\n\tpqi_check_ctrl_health(ctrl_info);\n\tif (pqi_ctrl_offline(ctrl_info) ||\n\t\tpqi_device_reset_blocked(ctrl_info)) {\n\t\trc = FAILED;\n\t\tgoto out;\n\t}\n\n\tpqi_wait_until_ofa_finished(ctrl_info);\n\n\tatomic_inc(&ctrl_info->sync_cmds_outstanding);\n\trc = pqi_device_reset(ctrl_info, device);\n\tatomic_dec(&ctrl_info->sync_cmds_outstanding);\n\nout:\n\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\"reset of scsi %d:%d:%d:%d: %s\\n\",\n\t\tshost->host_no, device->bus, device->target, device->lun,\n\t\trc == SUCCESS ? \"SUCCESS\" : \"FAILED\");\n\n\treturn rc;\n}\n\nstatic int pqi_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct pqi_scsi_dev *device;\n\tunsigned long flags;\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct scsi_target *starget;\n\tstruct sas_rphy *rphy;\n\n\tctrl_info = shost_to_hba(sdev->host);\n\n\tspin_lock_irqsave(&ctrl_info->scsi_device_list_lock, flags);\n\n\tif (sdev_channel(sdev) == PQI_PHYSICAL_DEVICE_BUS) {\n\t\tstarget = scsi_target(sdev);\n\t\trphy = target_to_rphy(starget);\n\t\tdevice = pqi_find_device_by_sas_rphy(ctrl_info, rphy);\n\t\tif (device) {\n\t\t\tdevice->target = sdev_id(sdev);\n\t\t\tdevice->lun = sdev->lun;\n\t\t\tdevice->target_lun_valid = true;\n\t\t}\n\t} else {\n\t\tdevice = pqi_find_scsi_dev(ctrl_info, sdev_channel(sdev),\n\t\t\tsdev_id(sdev), sdev->lun);\n\t}\n\n\tif (device) {\n\t\tsdev->hostdata = device;\n\t\tdevice->sdev = sdev;\n\t\tif (device->queue_depth) {\n\t\t\tdevice->advertised_queue_depth = device->queue_depth;\n\t\t\tscsi_change_queue_depth(sdev,\n\t\t\t\tdevice->advertised_queue_depth);\n\t\t}\n\t\tif (pqi_is_logical_device(device))\n\t\t\tpqi_disable_write_same(sdev);\n\t\telse\n\t\t\tsdev->allow_restart = 1;\n\t}\n\n\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\n\treturn 0;\n}\n\nstatic int pqi_map_queues(struct Scsi_Host *shost)\n{\n\tstruct pqi_ctrl_info *ctrl_info = shost_to_hba(shost);\n\n\treturn blk_mq_pci_map_queues(&shost->tag_set.map[HCTX_TYPE_DEFAULT],\n\t\t\t\t\tctrl_info->pci_dev, 0);\n}\n\nstatic int pqi_slave_configure(struct scsi_device *sdev)\n{\n\tstruct pqi_scsi_dev *device;\n\n\tdevice = sdev->hostdata;\n\tdevice->devtype = sdev->type;\n\n\treturn 0;\n}\n\nstatic void pqi_slave_destroy(struct scsi_device *sdev)\n{\n\tunsigned long flags;\n\tstruct pqi_scsi_dev *device;\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tctrl_info = shost_to_hba(sdev->host);\n\n\tspin_lock_irqsave(&ctrl_info->scsi_device_list_lock, flags);\n\n\tdevice = sdev->hostdata;\n\tif (device) {\n\t\tsdev->hostdata = NULL;\n\t\tif (!list_empty(&device->scsi_device_list_entry))\n\t\t\tlist_del(&device->scsi_device_list_entry);\n\t}\n\n\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\n\tif (device) {\n\t\tpqi_dev_info(ctrl_info, \"removed\", device);\n\t\tpqi_free_device(device);\n\t}\n}\n\nstatic int pqi_getpciinfo_ioctl(struct pqi_ctrl_info *ctrl_info, void __user *arg)\n{\n\tstruct pci_dev *pci_dev;\n\tu32 subsystem_vendor;\n\tu32 subsystem_device;\n\tcciss_pci_info_struct pciinfo;\n\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tpci_dev = ctrl_info->pci_dev;\n\n\tpciinfo.domain = pci_domain_nr(pci_dev->bus);\n\tpciinfo.bus = pci_dev->bus->number;\n\tpciinfo.dev_fn = pci_dev->devfn;\n\tsubsystem_vendor = pci_dev->subsystem_vendor;\n\tsubsystem_device = pci_dev->subsystem_device;\n\tpciinfo.board_id = ((subsystem_device << 16) & 0xffff0000) | subsystem_vendor;\n\n\tif (copy_to_user(arg, &pciinfo, sizeof(pciinfo)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int pqi_getdrivver_ioctl(void __user *arg)\n{\n\tu32 version;\n\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tversion = (DRIVER_MAJOR << 28) | (DRIVER_MINOR << 24) |\n\t\t(DRIVER_RELEASE << 16) | DRIVER_REVISION;\n\n\tif (copy_to_user(arg, &version, sizeof(version)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstruct ciss_error_info {\n\tu8\tscsi_status;\n\tint\tcommand_status;\n\tsize_t\tsense_data_length;\n};\n\nstatic void pqi_error_info_to_ciss(struct pqi_raid_error_info *pqi_error_info,\n\tstruct ciss_error_info *ciss_error_info)\n{\n\tint ciss_cmd_status;\n\tsize_t sense_data_length;\n\n\tswitch (pqi_error_info->data_out_result) {\n\tcase PQI_DATA_IN_OUT_GOOD:\n\t\tciss_cmd_status = CISS_CMD_STATUS_SUCCESS;\n\t\tbreak;\n\tcase PQI_DATA_IN_OUT_UNDERFLOW:\n\t\tciss_cmd_status = CISS_CMD_STATUS_DATA_UNDERRUN;\n\t\tbreak;\n\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW:\n\t\tciss_cmd_status = CISS_CMD_STATUS_DATA_OVERRUN;\n\t\tbreak;\n\tcase PQI_DATA_IN_OUT_PROTOCOL_ERROR:\n\tcase PQI_DATA_IN_OUT_BUFFER_ERROR:\n\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW_DESCRIPTOR_AREA:\n\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW_BRIDGE:\n\tcase PQI_DATA_IN_OUT_ERROR:\n\t\tciss_cmd_status = CISS_CMD_STATUS_PROTOCOL_ERROR;\n\t\tbreak;\n\tcase PQI_DATA_IN_OUT_HARDWARE_ERROR:\n\tcase PQI_DATA_IN_OUT_PCIE_FABRIC_ERROR:\n\tcase PQI_DATA_IN_OUT_PCIE_COMPLETION_TIMEOUT:\n\tcase PQI_DATA_IN_OUT_PCIE_COMPLETER_ABORT_RECEIVED:\n\tcase PQI_DATA_IN_OUT_PCIE_UNSUPPORTED_REQUEST_RECEIVED:\n\tcase PQI_DATA_IN_OUT_PCIE_ECRC_CHECK_FAILED:\n\tcase PQI_DATA_IN_OUT_PCIE_UNSUPPORTED_REQUEST:\n\tcase PQI_DATA_IN_OUT_PCIE_ACS_VIOLATION:\n\tcase PQI_DATA_IN_OUT_PCIE_TLP_PREFIX_BLOCKED:\n\tcase PQI_DATA_IN_OUT_PCIE_POISONED_MEMORY_READ:\n\t\tciss_cmd_status = CISS_CMD_STATUS_HARDWARE_ERROR;\n\t\tbreak;\n\tcase PQI_DATA_IN_OUT_UNSOLICITED_ABORT:\n\t\tciss_cmd_status = CISS_CMD_STATUS_UNSOLICITED_ABORT;\n\t\tbreak;\n\tcase PQI_DATA_IN_OUT_ABORTED:\n\t\tciss_cmd_status = CISS_CMD_STATUS_ABORTED;\n\t\tbreak;\n\tcase PQI_DATA_IN_OUT_TIMEOUT:\n\t\tciss_cmd_status = CISS_CMD_STATUS_TIMEOUT;\n\t\tbreak;\n\tdefault:\n\t\tciss_cmd_status = CISS_CMD_STATUS_TARGET_STATUS;\n\t\tbreak;\n\t}\n\n\tsense_data_length =\n\t\tget_unaligned_le16(&pqi_error_info->sense_data_length);\n\tif (sense_data_length == 0)\n\t\tsense_data_length =\n\t\tget_unaligned_le16(&pqi_error_info->response_data_length);\n\tif (sense_data_length)\n\t\tif (sense_data_length > sizeof(pqi_error_info->data))\n\t\t\tsense_data_length = sizeof(pqi_error_info->data);\n\n\tciss_error_info->scsi_status = pqi_error_info->status;\n\tciss_error_info->command_status = ciss_cmd_status;\n\tciss_error_info->sense_data_length = sense_data_length;\n}\n\nstatic int pqi_passthru_ioctl(struct pqi_ctrl_info *ctrl_info, void __user *arg)\n{\n\tint rc;\n\tchar *kernel_buffer = NULL;\n\tu16 iu_length;\n\tsize_t sense_data_length;\n\tIOCTL_Command_struct iocommand;\n\tstruct pqi_raid_path_request request;\n\tstruct pqi_raid_error_info pqi_error_info;\n\tstruct ciss_error_info ciss_error_info;\n\n\tif (pqi_ctrl_offline(ctrl_info))\n\t\treturn -ENXIO;\n\tif (!arg)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tif (copy_from_user(&iocommand, arg, sizeof(iocommand)))\n\t\treturn -EFAULT;\n\tif (iocommand.buf_size < 1 &&\n\t\tiocommand.Request.Type.Direction != XFER_NONE)\n\t\treturn -EINVAL;\n\tif (iocommand.Request.CDBLen > sizeof(request.cdb))\n\t\treturn -EINVAL;\n\tif (iocommand.Request.Type.Type != TYPE_CMD)\n\t\treturn -EINVAL;\n\n\tswitch (iocommand.Request.Type.Direction) {\n\tcase XFER_NONE:\n\tcase XFER_WRITE:\n\tcase XFER_READ:\n\tcase XFER_READ | XFER_WRITE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (iocommand.buf_size > 0) {\n\t\tkernel_buffer = kmalloc(iocommand.buf_size, GFP_KERNEL);\n\t\tif (!kernel_buffer)\n\t\t\treturn -ENOMEM;\n\t\tif (iocommand.Request.Type.Direction & XFER_WRITE) {\n\t\t\tif (copy_from_user(kernel_buffer, iocommand.buf,\n\t\t\t\tiocommand.buf_size)) {\n\t\t\t\trc = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tmemset(kernel_buffer, 0, iocommand.buf_size);\n\t\t}\n\t}\n\n\tmemset(&request, 0, sizeof(request));\n\n\trequest.header.iu_type = PQI_REQUEST_IU_RAID_PATH_IO;\n\tiu_length = offsetof(struct pqi_raid_path_request, sg_descriptors) -\n\t\tPQI_REQUEST_HEADER_LENGTH;\n\tmemcpy(request.lun_number, iocommand.LUN_info.LunAddrBytes,\n\t\tsizeof(request.lun_number));\n\tmemcpy(request.cdb, iocommand.Request.CDB, iocommand.Request.CDBLen);\n\trequest.additional_cdb_bytes_usage = SOP_ADDITIONAL_CDB_BYTES_0;\n\n\tswitch (iocommand.Request.Type.Direction) {\n\tcase XFER_NONE:\n\t\trequest.data_direction = SOP_NO_DIRECTION_FLAG;\n\t\tbreak;\n\tcase XFER_WRITE:\n\t\trequest.data_direction = SOP_WRITE_FLAG;\n\t\tbreak;\n\tcase XFER_READ:\n\t\trequest.data_direction = SOP_READ_FLAG;\n\t\tbreak;\n\tcase XFER_READ | XFER_WRITE:\n\t\trequest.data_direction = SOP_BIDIRECTIONAL;\n\t\tbreak;\n\t}\n\n\trequest.task_attribute = SOP_TASK_ATTRIBUTE_SIMPLE;\n\n\tif (iocommand.buf_size > 0) {\n\t\tput_unaligned_le32(iocommand.buf_size, &request.buffer_length);\n\n\t\trc = pqi_map_single(ctrl_info->pci_dev,\n\t\t\t&request.sg_descriptors[0], kernel_buffer,\n\t\t\tiocommand.buf_size, DMA_BIDIRECTIONAL);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tiu_length += sizeof(request.sg_descriptors[0]);\n\t}\n\n\tput_unaligned_le16(iu_length, &request.header.iu_length);\n\n\tif (ctrl_info->raid_iu_timeout_supported)\n\t\tput_unaligned_le32(iocommand.Request.Timeout, &request.timeout);\n\n\trc = pqi_submit_raid_request_synchronous(ctrl_info, &request.header,\n\t\tPQI_SYNC_FLAGS_INTERRUPTABLE, &pqi_error_info, NO_TIMEOUT);\n\n\tif (iocommand.buf_size > 0)\n\t\tpqi_pci_unmap(ctrl_info->pci_dev, request.sg_descriptors, 1,\n\t\t\tDMA_BIDIRECTIONAL);\n\n\tmemset(&iocommand.error_info, 0, sizeof(iocommand.error_info));\n\n\tif (rc == 0) {\n\t\tpqi_error_info_to_ciss(&pqi_error_info, &ciss_error_info);\n\t\tiocommand.error_info.ScsiStatus = ciss_error_info.scsi_status;\n\t\tiocommand.error_info.CommandStatus =\n\t\t\tciss_error_info.command_status;\n\t\tsense_data_length = ciss_error_info.sense_data_length;\n\t\tif (sense_data_length) {\n\t\t\tif (sense_data_length >\n\t\t\t\tsizeof(iocommand.error_info.SenseInfo))\n\t\t\t\tsense_data_length =\n\t\t\t\t\tsizeof(iocommand.error_info.SenseInfo);\n\t\t\tmemcpy(iocommand.error_info.SenseInfo,\n\t\t\t\tpqi_error_info.data, sense_data_length);\n\t\t\tiocommand.error_info.SenseLen = sense_data_length;\n\t\t}\n\t}\n\n\tif (copy_to_user(arg, &iocommand, sizeof(iocommand))) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (rc == 0 && iocommand.buf_size > 0 &&\n\t\t(iocommand.Request.Type.Direction & XFER_READ)) {\n\t\tif (copy_to_user(iocommand.buf, kernel_buffer,\n\t\t\tiocommand.buf_size)) {\n\t\t\trc = -EFAULT;\n\t\t}\n\t}\n\nout:\n\tkfree(kernel_buffer);\n\n\treturn rc;\n}\n\nstatic int pqi_ioctl(struct scsi_device *sdev, unsigned int cmd,\n\t\t     void __user *arg)\n{\n\tint rc;\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tctrl_info = shost_to_hba(sdev->host);\n\n\tif (pqi_ctrl_in_ofa(ctrl_info) || pqi_ctrl_in_shutdown(ctrl_info))\n\t\treturn -EBUSY;\n\n\tswitch (cmd) {\n\tcase CCISS_DEREGDISK:\n\tcase CCISS_REGNEWDISK:\n\tcase CCISS_REGNEWD:\n\t\trc = pqi_scan_scsi_devices(ctrl_info);\n\t\tbreak;\n\tcase CCISS_GETPCIINFO:\n\t\trc = pqi_getpciinfo_ioctl(ctrl_info, arg);\n\t\tbreak;\n\tcase CCISS_GETDRIVVER:\n\t\trc = pqi_getdrivver_ioctl(arg);\n\t\tbreak;\n\tcase CCISS_PASSTHRU:\n\t\trc = pqi_passthru_ioctl(ctrl_info, arg);\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic ssize_t pqi_firmware_version_show(struct device *dev,\n\tstruct device_attribute *attr, char *buffer)\n{\n\tstruct Scsi_Host *shost;\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tshost = class_to_shost(dev);\n\tctrl_info = shost_to_hba(shost);\n\n\treturn snprintf(buffer, PAGE_SIZE, \"%s\\n\", ctrl_info->firmware_version);\n}\n\nstatic ssize_t pqi_driver_version_show(struct device *dev,\n\tstruct device_attribute *attr, char *buffer)\n{\n\treturn snprintf(buffer, PAGE_SIZE, \"%s\\n\",\n\t\t\tDRIVER_VERSION BUILD_TIMESTAMP);\n}\n\nstatic ssize_t pqi_serial_number_show(struct device *dev,\n\tstruct device_attribute *attr, char *buffer)\n{\n\tstruct Scsi_Host *shost;\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tshost = class_to_shost(dev);\n\tctrl_info = shost_to_hba(shost);\n\n\treturn snprintf(buffer, PAGE_SIZE, \"%s\\n\", ctrl_info->serial_number);\n}\n\nstatic ssize_t pqi_model_show(struct device *dev,\n\tstruct device_attribute *attr, char *buffer)\n{\n\tstruct Scsi_Host *shost;\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tshost = class_to_shost(dev);\n\tctrl_info = shost_to_hba(shost);\n\n\treturn snprintf(buffer, PAGE_SIZE, \"%s\\n\", ctrl_info->model);\n}\n\nstatic ssize_t pqi_vendor_show(struct device *dev,\n\tstruct device_attribute *attr, char *buffer)\n{\n\tstruct Scsi_Host *shost;\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tshost = class_to_shost(dev);\n\tctrl_info = shost_to_hba(shost);\n\n\treturn snprintf(buffer, PAGE_SIZE, \"%s\\n\", ctrl_info->vendor);\n}\n\nstatic ssize_t pqi_host_rescan_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buffer, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\n\tpqi_scan_start(shost);\n\n\treturn count;\n}\n\nstatic ssize_t pqi_lockup_action_show(struct device *dev,\n\tstruct device_attribute *attr, char *buffer)\n{\n\tint count = 0;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pqi_lockup_actions); i++) {\n\t\tif (pqi_lockup_actions[i].action == pqi_lockup_action)\n\t\t\tcount += scnprintf(buffer + count, PAGE_SIZE - count,\n\t\t\t\t\"[%s] \", pqi_lockup_actions[i].name);\n\t\telse\n\t\t\tcount += scnprintf(buffer + count, PAGE_SIZE - count,\n\t\t\t\t\"%s \", pqi_lockup_actions[i].name);\n\t}\n\n\tcount += scnprintf(buffer + count, PAGE_SIZE - count, \"\\n\");\n\n\treturn count;\n}\n\nstatic ssize_t pqi_lockup_action_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buffer, size_t count)\n{\n\tunsigned int i;\n\tchar *action_name;\n\tchar action_name_buffer[32];\n\n\tstrlcpy(action_name_buffer, buffer, sizeof(action_name_buffer));\n\taction_name = strstrip(action_name_buffer);\n\n\tfor (i = 0; i < ARRAY_SIZE(pqi_lockup_actions); i++) {\n\t\tif (strcmp(action_name, pqi_lockup_actions[i].name) == 0) {\n\t\t\tpqi_lockup_action = pqi_lockup_actions[i].action;\n\t\t\treturn count;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic DEVICE_ATTR(driver_version, 0444, pqi_driver_version_show, NULL);\nstatic DEVICE_ATTR(firmware_version, 0444, pqi_firmware_version_show, NULL);\nstatic DEVICE_ATTR(model, 0444, pqi_model_show, NULL);\nstatic DEVICE_ATTR(serial_number, 0444, pqi_serial_number_show, NULL);\nstatic DEVICE_ATTR(vendor, 0444, pqi_vendor_show, NULL);\nstatic DEVICE_ATTR(rescan, 0200, NULL, pqi_host_rescan_store);\nstatic DEVICE_ATTR(lockup_action, 0644,\n\tpqi_lockup_action_show, pqi_lockup_action_store);\n\nstatic struct device_attribute *pqi_shost_attrs[] = {\n\t&dev_attr_driver_version,\n\t&dev_attr_firmware_version,\n\t&dev_attr_model,\n\t&dev_attr_serial_number,\n\t&dev_attr_vendor,\n\t&dev_attr_rescan,\n\t&dev_attr_lockup_action,\n\tNULL\n};\n\nstatic ssize_t pqi_unique_id_show(struct device *dev,\n\tstruct device_attribute *attr, char *buffer)\n{\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct scsi_device *sdev;\n\tstruct pqi_scsi_dev *device;\n\tunsigned long flags;\n\tu8 unique_id[16];\n\n\tsdev = to_scsi_device(dev);\n\tctrl_info = shost_to_hba(sdev->host);\n\n\tspin_lock_irqsave(&ctrl_info->scsi_device_list_lock, flags);\n\n\tdevice = sdev->hostdata;\n\tif (!device) {\n\t\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\tif (device->is_physical_device) {\n\t\tmemset(unique_id, 0, 8);\n\t\tmemcpy(unique_id + 8, &device->wwid, sizeof(device->wwid));\n\t} else {\n\t\tmemcpy(unique_id, device->volume_id, sizeof(device->volume_id));\n\t}\n\n\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\n\treturn snprintf(buffer, PAGE_SIZE,\n\t\t\"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\\n\",\n\t\tunique_id[0], unique_id[1], unique_id[2], unique_id[3],\n\t\tunique_id[4], unique_id[5], unique_id[6], unique_id[7],\n\t\tunique_id[8], unique_id[9], unique_id[10], unique_id[11],\n\t\tunique_id[12], unique_id[13], unique_id[14], unique_id[15]);\n}\n\nstatic ssize_t pqi_lunid_show(struct device *dev,\n\tstruct device_attribute *attr, char *buffer)\n{\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct scsi_device *sdev;\n\tstruct pqi_scsi_dev *device;\n\tunsigned long flags;\n\tu8 lunid[8];\n\n\tsdev = to_scsi_device(dev);\n\tctrl_info = shost_to_hba(sdev->host);\n\n\tspin_lock_irqsave(&ctrl_info->scsi_device_list_lock, flags);\n\n\tdevice = sdev->hostdata;\n\tif (!device) {\n\t\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\tmemcpy(lunid, device->scsi3addr, sizeof(lunid));\n\n\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\n\treturn snprintf(buffer, PAGE_SIZE, \"0x%8phN\\n\", lunid);\n}\n\n#define MAX_PATHS\t8\n\nstatic ssize_t pqi_path_info_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct scsi_device *sdev;\n\tstruct pqi_scsi_dev *device;\n\tunsigned long flags;\n\tint i;\n\tint output_len = 0;\n\tu8 box;\n\tu8 bay;\n\tu8 path_map_index;\n\tchar *active;\n\tu8 phys_connector[2];\n\n\tsdev = to_scsi_device(dev);\n\tctrl_info = shost_to_hba(sdev->host);\n\n\tspin_lock_irqsave(&ctrl_info->scsi_device_list_lock, flags);\n\n\tdevice = sdev->hostdata;\n\tif (!device) {\n\t\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\tbay = device->bay;\n\tfor (i = 0; i < MAX_PATHS; i++) {\n\t\tpath_map_index = 1 << i;\n\t\tif (i == device->active_path_index)\n\t\t\tactive = \"Active\";\n\t\telse if (device->path_map & path_map_index)\n\t\t\tactive = \"Inactive\";\n\t\telse\n\t\t\tcontinue;\n\n\t\toutput_len += scnprintf(buf + output_len,\n\t\t\t\t\tPAGE_SIZE - output_len,\n\t\t\t\t\t\"[%d:%d:%d:%d] %20.20s \",\n\t\t\t\t\tctrl_info->scsi_host->host_no,\n\t\t\t\t\tdevice->bus, device->target,\n\t\t\t\t\tdevice->lun,\n\t\t\t\t\tscsi_device_type(device->devtype));\n\n\t\tif (device->devtype == TYPE_RAID ||\n\t\t\tpqi_is_logical_device(device))\n\t\t\tgoto end_buffer;\n\n\t\tmemcpy(&phys_connector, &device->phys_connector[i],\n\t\t\tsizeof(phys_connector));\n\t\tif (phys_connector[0] < '0')\n\t\t\tphys_connector[0] = '0';\n\t\tif (phys_connector[1] < '0')\n\t\t\tphys_connector[1] = '0';\n\n\t\toutput_len += scnprintf(buf + output_len,\n\t\t\t\t\tPAGE_SIZE - output_len,\n\t\t\t\t\t\"PORT: %.2s \", phys_connector);\n\n\t\tbox = device->box[i];\n\t\tif (box != 0 && box != 0xFF)\n\t\t\toutput_len += scnprintf(buf + output_len,\n\t\t\t\t\t\tPAGE_SIZE - output_len,\n\t\t\t\t\t\t\"BOX: %hhu \", box);\n\n\t\tif ((device->devtype == TYPE_DISK ||\n\t\t\tdevice->devtype == TYPE_ZBC) &&\n\t\t\tpqi_expose_device(device))\n\t\t\toutput_len += scnprintf(buf + output_len,\n\t\t\t\t\t\tPAGE_SIZE - output_len,\n\t\t\t\t\t\t\"BAY: %hhu \", bay);\n\nend_buffer:\n\t\toutput_len += scnprintf(buf + output_len,\n\t\t\t\t\tPAGE_SIZE - output_len,\n\t\t\t\t\t\"%s\\n\", active);\n\t}\n\n\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\n\treturn output_len;\n}\n\nstatic ssize_t pqi_sas_address_show(struct device *dev,\n\tstruct device_attribute *attr, char *buffer)\n{\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct scsi_device *sdev;\n\tstruct pqi_scsi_dev *device;\n\tunsigned long flags;\n\tu64 sas_address;\n\n\tsdev = to_scsi_device(dev);\n\tctrl_info = shost_to_hba(sdev->host);\n\n\tspin_lock_irqsave(&ctrl_info->scsi_device_list_lock, flags);\n\n\tdevice = sdev->hostdata;\n\tif (!device || !pqi_is_device_with_sas_address(device)) {\n\t\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\tsas_address = device->sas_address;\n\n\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\n\treturn snprintf(buffer, PAGE_SIZE, \"0x%016llx\\n\", sas_address);\n}\n\nstatic ssize_t pqi_ssd_smart_path_enabled_show(struct device *dev,\n\tstruct device_attribute *attr, char *buffer)\n{\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct scsi_device *sdev;\n\tstruct pqi_scsi_dev *device;\n\tunsigned long flags;\n\n\tsdev = to_scsi_device(dev);\n\tctrl_info = shost_to_hba(sdev->host);\n\n\tspin_lock_irqsave(&ctrl_info->scsi_device_list_lock, flags);\n\n\tdevice = sdev->hostdata;\n\tif (!device) {\n\t\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\tbuffer[0] = device->raid_bypass_enabled ? '1' : '0';\n\tbuffer[1] = '\\n';\n\tbuffer[2] = '\\0';\n\n\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\n\treturn 2;\n}\n\nstatic ssize_t pqi_raid_level_show(struct device *dev,\n\tstruct device_attribute *attr, char *buffer)\n{\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct scsi_device *sdev;\n\tstruct pqi_scsi_dev *device;\n\tunsigned long flags;\n\tchar *raid_level;\n\n\tsdev = to_scsi_device(dev);\n\tctrl_info = shost_to_hba(sdev->host);\n\n\tspin_lock_irqsave(&ctrl_info->scsi_device_list_lock, flags);\n\n\tdevice = sdev->hostdata;\n\tif (!device) {\n\t\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\tif (pqi_is_logical_device(device))\n\t\traid_level = pqi_raid_level_to_string(device->raid_level);\n\telse\n\t\traid_level = \"N/A\";\n\n\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\n\treturn snprintf(buffer, PAGE_SIZE, \"%s\\n\", raid_level);\n}\n\nstatic ssize_t pqi_raid_bypass_cnt_show(struct device *dev,\n\tstruct device_attribute *attr, char *buffer)\n{\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct scsi_device *sdev;\n\tstruct pqi_scsi_dev *device;\n\tunsigned long flags;\n\tint raid_bypass_cnt;\n\n\tsdev = to_scsi_device(dev);\n\tctrl_info = shost_to_hba(sdev->host);\n\n\tspin_lock_irqsave(&ctrl_info->scsi_device_list_lock, flags);\n\n\tdevice = sdev->hostdata;\n\tif (!device) {\n\t\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\traid_bypass_cnt = atomic_read(&device->raid_bypass_cnt);\n\n\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\n\treturn snprintf(buffer, PAGE_SIZE, \"0x%x\\n\", raid_bypass_cnt);\n}\n\nstatic DEVICE_ATTR(lunid, 0444, pqi_lunid_show, NULL);\nstatic DEVICE_ATTR(unique_id, 0444, pqi_unique_id_show, NULL);\nstatic DEVICE_ATTR(path_info, 0444, pqi_path_info_show, NULL);\nstatic DEVICE_ATTR(sas_address, 0444, pqi_sas_address_show, NULL);\nstatic DEVICE_ATTR(ssd_smart_path_enabled, 0444, pqi_ssd_smart_path_enabled_show, NULL);\nstatic DEVICE_ATTR(raid_level, 0444, pqi_raid_level_show, NULL);\nstatic DEVICE_ATTR(raid_bypass_cnt, 0444, pqi_raid_bypass_cnt_show, NULL);\n\nstatic struct device_attribute *pqi_sdev_attrs[] = {\n\t&dev_attr_lunid,\n\t&dev_attr_unique_id,\n\t&dev_attr_path_info,\n\t&dev_attr_sas_address,\n\t&dev_attr_ssd_smart_path_enabled,\n\t&dev_attr_raid_level,\n\t&dev_attr_raid_bypass_cnt,\n\tNULL\n};\n\nstatic struct scsi_host_template pqi_driver_template = {\n\t.module = THIS_MODULE,\n\t.name = DRIVER_NAME_SHORT,\n\t.proc_name = DRIVER_NAME_SHORT,\n\t.queuecommand = pqi_scsi_queue_command,\n\t.scan_start = pqi_scan_start,\n\t.scan_finished = pqi_scan_finished,\n\t.this_id = -1,\n\t.eh_device_reset_handler = pqi_eh_device_reset_handler,\n\t.ioctl = pqi_ioctl,\n\t.slave_alloc = pqi_slave_alloc,\n\t.slave_configure = pqi_slave_configure,\n\t.slave_destroy = pqi_slave_destroy,\n\t.map_queues = pqi_map_queues,\n\t.sdev_attrs = pqi_sdev_attrs,\n\t.shost_attrs = pqi_shost_attrs,\n};\n\nstatic int pqi_register_scsi(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tstruct Scsi_Host *shost;\n\n\tshost = scsi_host_alloc(&pqi_driver_template, sizeof(ctrl_info));\n\tif (!shost) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"scsi_host_alloc failed for controller %u\\n\",\n\t\t\tctrl_info->ctrl_id);\n\t\treturn -ENOMEM;\n\t}\n\n\tshost->io_port = 0;\n\tshost->n_io_port = 0;\n\tshost->this_id = -1;\n\tshost->max_channel = PQI_MAX_BUS;\n\tshost->max_cmd_len = MAX_COMMAND_SIZE;\n\tshost->max_lun = ~0;\n\tshost->max_id = ~0;\n\tshost->max_sectors = ctrl_info->max_sectors;\n\tshost->can_queue = ctrl_info->scsi_ml_can_queue;\n\tshost->cmd_per_lun = shost->can_queue;\n\tshost->sg_tablesize = ctrl_info->sg_tablesize;\n\tshost->transportt = pqi_sas_transport_template;\n\tshost->irq = pci_irq_vector(ctrl_info->pci_dev, 0);\n\tshost->unique_id = shost->irq;\n\tshost->nr_hw_queues = ctrl_info->num_queue_groups;\n\tshost->hostdata[0] = (unsigned long)ctrl_info;\n\n\trc = scsi_add_host(shost, &ctrl_info->pci_dev->dev);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"scsi_add_host failed for controller %u\\n\",\n\t\t\tctrl_info->ctrl_id);\n\t\tgoto free_host;\n\t}\n\n\trc = pqi_add_sas_host(shost, ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"add SAS host failed for controller %u\\n\",\n\t\t\tctrl_info->ctrl_id);\n\t\tgoto remove_host;\n\t}\n\n\tctrl_info->scsi_host = shost;\n\n\treturn 0;\n\nremove_host:\n\tscsi_remove_host(shost);\nfree_host:\n\tscsi_host_put(shost);\n\n\treturn rc;\n}\n\nstatic void pqi_unregister_scsi(struct pqi_ctrl_info *ctrl_info)\n{\n\tstruct Scsi_Host *shost;\n\n\tpqi_delete_sas_host(ctrl_info);\n\n\tshost = ctrl_info->scsi_host;\n\tif (!shost)\n\t\treturn;\n\n\tscsi_remove_host(shost);\n\tscsi_host_put(shost);\n}\n\nstatic int pqi_wait_for_pqi_reset_completion(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc = 0;\n\tstruct pqi_device_registers __iomem *pqi_registers;\n\tunsigned long timeout;\n\tunsigned int timeout_msecs;\n\tunion pqi_reset_register reset_reg;\n\n\tpqi_registers = ctrl_info->pqi_registers;\n\ttimeout_msecs = readw(&pqi_registers->max_reset_timeout) * 100;\n\ttimeout = msecs_to_jiffies(timeout_msecs) + jiffies;\n\n\twhile (1) {\n\t\tmsleep(PQI_RESET_POLL_INTERVAL_MSECS);\n\t\treset_reg.all_bits = readl(&pqi_registers->device_reset);\n\t\tif (reset_reg.bits.reset_action == PQI_RESET_ACTION_COMPLETED)\n\t\t\tbreak;\n\t\tpqi_check_ctrl_health(ctrl_info);\n\t\tif (pqi_ctrl_offline(ctrl_info)) {\n\t\t\trc = -ENXIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\trc = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int pqi_reset(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tunion pqi_reset_register reset_reg;\n\n\tif (ctrl_info->pqi_reset_quiesce_supported) {\n\t\trc = sis_pqi_reset_quiesce(ctrl_info);\n\t\tif (rc) {\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"PQI reset failed during quiesce with error %d\\n\",\n\t\t\t\trc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treset_reg.all_bits = 0;\n\treset_reg.bits.reset_type = PQI_RESET_TYPE_HARD_RESET;\n\treset_reg.bits.reset_action = PQI_RESET_ACTION_RESET;\n\n\twritel(reset_reg.all_bits, &ctrl_info->pqi_registers->device_reset);\n\n\trc = pqi_wait_for_pqi_reset_completion(ctrl_info);\n\tif (rc)\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"PQI reset failed with error %d\\n\", rc);\n\n\treturn rc;\n}\n\nstatic int pqi_get_ctrl_serial_number(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tstruct bmic_sense_subsystem_info *sense_info;\n\n\tsense_info = kzalloc(sizeof(*sense_info), GFP_KERNEL);\n\tif (!sense_info)\n\t\treturn -ENOMEM;\n\n\trc = pqi_sense_subsystem_info(ctrl_info, sense_info);\n\tif (rc)\n\t\tgoto out;\n\n\tmemcpy(ctrl_info->serial_number, sense_info->ctrl_serial_number,\n\t\tsizeof(sense_info->ctrl_serial_number));\n\tctrl_info->serial_number[sizeof(sense_info->ctrl_serial_number)] = '\\0';\n\nout:\n\tkfree(sense_info);\n\n\treturn rc;\n}\n\nstatic int pqi_get_ctrl_product_details(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tstruct bmic_identify_controller *identify;\n\n\tidentify = kmalloc(sizeof(*identify), GFP_KERNEL);\n\tif (!identify)\n\t\treturn -ENOMEM;\n\n\trc = pqi_identify_controller(ctrl_info, identify);\n\tif (rc)\n\t\tgoto out;\n\n\tmemcpy(ctrl_info->firmware_version, identify->firmware_version,\n\t\tsizeof(identify->firmware_version));\n\tctrl_info->firmware_version[sizeof(identify->firmware_version)] = '\\0';\n\tsnprintf(ctrl_info->firmware_version +\n\t\tstrlen(ctrl_info->firmware_version),\n\t\tsizeof(ctrl_info->firmware_version),\n\t\t\"-%u\", get_unaligned_le16(&identify->firmware_build_number));\n\n\tmemcpy(ctrl_info->model, identify->product_id,\n\t\tsizeof(identify->product_id));\n\tctrl_info->model[sizeof(identify->product_id)] = '\\0';\n\n\tmemcpy(ctrl_info->vendor, identify->vendor_id,\n\t\tsizeof(identify->vendor_id));\n\tctrl_info->vendor[sizeof(identify->vendor_id)] = '\\0';\n\nout:\n\tkfree(identify);\n\n\treturn rc;\n}\n\nstruct pqi_config_table_section_info {\n\tstruct pqi_ctrl_info *ctrl_info;\n\tvoid\t\t*section;\n\tu32\t\tsection_offset;\n\tvoid __iomem\t*section_iomem_addr;\n};\n\nstatic inline bool pqi_is_firmware_feature_supported(\n\tstruct pqi_config_table_firmware_features *firmware_features,\n\tunsigned int bit_position)\n{\n\tunsigned int byte_index;\n\n\tbyte_index = bit_position / BITS_PER_BYTE;\n\n\tif (byte_index >= le16_to_cpu(firmware_features->num_elements))\n\t\treturn false;\n\n\treturn firmware_features->features_supported[byte_index] &\n\t\t(1 << (bit_position % BITS_PER_BYTE)) ? true : false;\n}\n\nstatic inline bool pqi_is_firmware_feature_enabled(\n\tstruct pqi_config_table_firmware_features *firmware_features,\n\tvoid __iomem *firmware_features_iomem_addr,\n\tunsigned int bit_position)\n{\n\tunsigned int byte_index;\n\tu8 __iomem *features_enabled_iomem_addr;\n\n\tbyte_index = (bit_position / BITS_PER_BYTE) +\n\t\t(le16_to_cpu(firmware_features->num_elements) * 2);\n\n\tfeatures_enabled_iomem_addr = firmware_features_iomem_addr +\n\t\toffsetof(struct pqi_config_table_firmware_features,\n\t\t\tfeatures_supported) + byte_index;\n\n\treturn *((__force u8 *)features_enabled_iomem_addr) &\n\t\t(1 << (bit_position % BITS_PER_BYTE)) ? true : false;\n}\n\nstatic inline void pqi_request_firmware_feature(\n\tstruct pqi_config_table_firmware_features *firmware_features,\n\tunsigned int bit_position)\n{\n\tunsigned int byte_index;\n\n\tbyte_index = (bit_position / BITS_PER_BYTE) +\n\t\tle16_to_cpu(firmware_features->num_elements);\n\n\tfirmware_features->features_supported[byte_index] |=\n\t\t(1 << (bit_position % BITS_PER_BYTE));\n}\n\nstatic int pqi_config_table_update(struct pqi_ctrl_info *ctrl_info,\n\tu16 first_section, u16 last_section)\n{\n\tstruct pqi_vendor_general_request request;\n\n\tmemset(&request, 0, sizeof(request));\n\n\trequest.header.iu_type = PQI_REQUEST_IU_VENDOR_GENERAL;\n\tput_unaligned_le16(sizeof(request) - PQI_REQUEST_HEADER_LENGTH,\n\t\t&request.header.iu_length);\n\tput_unaligned_le16(PQI_VENDOR_GENERAL_CONFIG_TABLE_UPDATE,\n\t\t&request.function_code);\n\tput_unaligned_le16(first_section,\n\t\t&request.data.config_table_update.first_section);\n\tput_unaligned_le16(last_section,\n\t\t&request.data.config_table_update.last_section);\n\n\treturn pqi_submit_raid_request_synchronous(ctrl_info, &request.header,\n\t\t0, NULL, NO_TIMEOUT);\n}\n\nstatic int pqi_enable_firmware_features(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_config_table_firmware_features *firmware_features,\n\tvoid __iomem *firmware_features_iomem_addr)\n{\n\tvoid *features_requested;\n\tvoid __iomem *features_requested_iomem_addr;\n\n\tfeatures_requested = firmware_features->features_supported +\n\t\tle16_to_cpu(firmware_features->num_elements);\n\n\tfeatures_requested_iomem_addr = firmware_features_iomem_addr +\n\t\t(features_requested - (void *)firmware_features);\n\n\tmemcpy_toio(features_requested_iomem_addr, features_requested,\n\t\tle16_to_cpu(firmware_features->num_elements));\n\n\treturn pqi_config_table_update(ctrl_info,\n\t\tPQI_CONFIG_TABLE_SECTION_FIRMWARE_FEATURES,\n\t\tPQI_CONFIG_TABLE_SECTION_FIRMWARE_FEATURES);\n}\n\nstruct pqi_firmware_feature {\n\tchar\t\t*feature_name;\n\tunsigned int\tfeature_bit;\n\tbool\t\tsupported;\n\tbool\t\tenabled;\n\tvoid (*feature_status)(struct pqi_ctrl_info *ctrl_info,\n\t\tstruct pqi_firmware_feature *firmware_feature);\n};\n\nstatic void pqi_firmware_feature_status(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_firmware_feature *firmware_feature)\n{\n\tif (!firmware_feature->supported) {\n\t\tdev_info(&ctrl_info->pci_dev->dev, \"%s not supported by controller\\n\",\n\t\t\tfirmware_feature->feature_name);\n\t\treturn;\n\t}\n\n\tif (firmware_feature->enabled) {\n\t\tdev_info(&ctrl_info->pci_dev->dev,\n\t\t\t\"%s enabled\\n\", firmware_feature->feature_name);\n\t\treturn;\n\t}\n\n\tdev_err(&ctrl_info->pci_dev->dev, \"failed to enable %s\\n\",\n\t\tfirmware_feature->feature_name);\n}\n\nstatic void pqi_ctrl_update_feature_flags(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_firmware_feature *firmware_feature)\n{\n\tswitch (firmware_feature->feature_bit) {\n\tcase PQI_FIRMWARE_FEATURE_SOFT_RESET_HANDSHAKE:\n\t\tctrl_info->soft_reset_handshake_supported =\n\t\t\tfirmware_feature->enabled;\n\t\tbreak;\n\tcase PQI_FIRMWARE_FEATURE_RAID_IU_TIMEOUT:\n\t\tctrl_info->raid_iu_timeout_supported =\n\t\t\tfirmware_feature->enabled;\n\t\tbreak;\n\tcase PQI_FIRMWARE_FEATURE_TMF_IU_TIMEOUT:\n\t\tctrl_info->tmf_iu_timeout_supported =\n\t\t\tfirmware_feature->enabled;\n\t\tbreak;\n\t}\n\n\tpqi_firmware_feature_status(ctrl_info, firmware_feature);\n}\n\nstatic inline void pqi_firmware_feature_update(struct pqi_ctrl_info *ctrl_info,\n\tstruct pqi_firmware_feature *firmware_feature)\n{\n\tif (firmware_feature->feature_status)\n\t\tfirmware_feature->feature_status(ctrl_info, firmware_feature);\n}\n\nstatic DEFINE_MUTEX(pqi_firmware_features_mutex);\n\nstatic struct pqi_firmware_feature pqi_firmware_features[] = {\n\t{\n\t\t.feature_name = \"Online Firmware Activation\",\n\t\t.feature_bit = PQI_FIRMWARE_FEATURE_OFA,\n\t\t.feature_status = pqi_firmware_feature_status,\n\t},\n\t{\n\t\t.feature_name = \"Serial Management Protocol\",\n\t\t.feature_bit = PQI_FIRMWARE_FEATURE_SMP,\n\t\t.feature_status = pqi_firmware_feature_status,\n\t},\n\t{\n\t\t.feature_name = \"New Soft Reset Handshake\",\n\t\t.feature_bit = PQI_FIRMWARE_FEATURE_SOFT_RESET_HANDSHAKE,\n\t\t.feature_status = pqi_ctrl_update_feature_flags,\n\t},\n\t{\n\t\t.feature_name = \"RAID IU Timeout\",\n\t\t.feature_bit = PQI_FIRMWARE_FEATURE_RAID_IU_TIMEOUT,\n\t\t.feature_status = pqi_ctrl_update_feature_flags,\n\t},\n\t{\n\t\t.feature_name = \"TMF IU Timeout\",\n\t\t.feature_bit = PQI_FIRMWARE_FEATURE_TMF_IU_TIMEOUT,\n\t\t.feature_status = pqi_ctrl_update_feature_flags,\n\t},\n};\n\nstatic void pqi_process_firmware_features(\n\tstruct pqi_config_table_section_info *section_info)\n{\n\tint rc;\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct pqi_config_table_firmware_features *firmware_features;\n\tvoid __iomem *firmware_features_iomem_addr;\n\tunsigned int i;\n\tunsigned int num_features_supported;\n\n\tctrl_info = section_info->ctrl_info;\n\tfirmware_features = section_info->section;\n\tfirmware_features_iomem_addr = section_info->section_iomem_addr;\n\n\tfor (i = 0, num_features_supported = 0;\n\t\ti < ARRAY_SIZE(pqi_firmware_features); i++) {\n\t\tif (pqi_is_firmware_feature_supported(firmware_features,\n\t\t\tpqi_firmware_features[i].feature_bit)) {\n\t\t\tpqi_firmware_features[i].supported = true;\n\t\t\tnum_features_supported++;\n\t\t} else {\n\t\t\tpqi_firmware_feature_update(ctrl_info,\n\t\t\t\t&pqi_firmware_features[i]);\n\t\t}\n\t}\n\n\tif (num_features_supported == 0)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(pqi_firmware_features); i++) {\n\t\tif (!pqi_firmware_features[i].supported)\n\t\t\tcontinue;\n\t\tpqi_request_firmware_feature(firmware_features,\n\t\t\tpqi_firmware_features[i].feature_bit);\n\t}\n\n\trc = pqi_enable_firmware_features(ctrl_info, firmware_features,\n\t\tfirmware_features_iomem_addr);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"failed to enable firmware features in PQI configuration table\\n\");\n\t\tfor (i = 0; i < ARRAY_SIZE(pqi_firmware_features); i++) {\n\t\t\tif (!pqi_firmware_features[i].supported)\n\t\t\t\tcontinue;\n\t\t\tpqi_firmware_feature_update(ctrl_info,\n\t\t\t\t&pqi_firmware_features[i]);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(pqi_firmware_features); i++) {\n\t\tif (!pqi_firmware_features[i].supported)\n\t\t\tcontinue;\n\t\tif (pqi_is_firmware_feature_enabled(firmware_features,\n\t\t\tfirmware_features_iomem_addr,\n\t\t\tpqi_firmware_features[i].feature_bit)) {\n\t\t\tpqi_firmware_features[i].enabled = true;\n\t\t}\n\t\tpqi_firmware_feature_update(ctrl_info,\n\t\t\t&pqi_firmware_features[i]);\n\t}\n}\n\nstatic void pqi_init_firmware_features(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pqi_firmware_features); i++) {\n\t\tpqi_firmware_features[i].supported = false;\n\t\tpqi_firmware_features[i].enabled = false;\n\t}\n}\n\nstatic void pqi_process_firmware_features_section(\n\tstruct pqi_config_table_section_info *section_info)\n{\n\tmutex_lock(&pqi_firmware_features_mutex);\n\tpqi_init_firmware_features();\n\tpqi_process_firmware_features(section_info);\n\tmutex_unlock(&pqi_firmware_features_mutex);\n}\n\nstatic int pqi_process_config_table(struct pqi_ctrl_info *ctrl_info)\n{\n\tu32 table_length;\n\tu32 section_offset;\n\tvoid __iomem *table_iomem_addr;\n\tstruct pqi_config_table *config_table;\n\tstruct pqi_config_table_section_header *section;\n\tstruct pqi_config_table_section_info section_info;\n\n\ttable_length = ctrl_info->config_table_length;\n\tif (table_length == 0)\n\t\treturn 0;\n\n\tconfig_table = kmalloc(table_length, GFP_KERNEL);\n\tif (!config_table) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"failed to allocate memory for PQI configuration table\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * Copy the config table contents from I/O memory space into the\n\t * temporary buffer.\n\t */\n\ttable_iomem_addr = ctrl_info->iomem_base +\n\t\tctrl_info->config_table_offset;\n\tmemcpy_fromio(config_table, table_iomem_addr, table_length);\n\n\tsection_info.ctrl_info = ctrl_info;\n\tsection_offset =\n\t\tget_unaligned_le32(&config_table->first_section_offset);\n\n\twhile (section_offset) {\n\t\tsection = (void *)config_table + section_offset;\n\n\t\tsection_info.section = section;\n\t\tsection_info.section_offset = section_offset;\n\t\tsection_info.section_iomem_addr =\n\t\t\ttable_iomem_addr + section_offset;\n\n\t\tswitch (get_unaligned_le16(&section->section_id)) {\n\t\tcase PQI_CONFIG_TABLE_SECTION_FIRMWARE_FEATURES:\n\t\t\tpqi_process_firmware_features_section(&section_info);\n\t\t\tbreak;\n\t\tcase PQI_CONFIG_TABLE_SECTION_HEARTBEAT:\n\t\t\tif (pqi_disable_heartbeat)\n\t\t\t\tdev_warn(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"heartbeat disabled by module parameter\\n\");\n\t\t\telse\n\t\t\t\tctrl_info->heartbeat_counter =\n\t\t\t\t\ttable_iomem_addr +\n\t\t\t\t\tsection_offset +\n\t\t\t\t\toffsetof(\n\t\t\t\t\tstruct pqi_config_table_heartbeat,\n\t\t\t\t\t\theartbeat_counter);\n\t\t\tbreak;\n\t\tcase PQI_CONFIG_TABLE_SECTION_SOFT_RESET:\n\t\t\tctrl_info->soft_reset_status =\n\t\t\t\ttable_iomem_addr +\n\t\t\t\tsection_offset +\n\t\t\t\toffsetof(struct pqi_config_table_soft_reset,\n\t\t\t\t\t\tsoft_reset_status);\n\t\t\tbreak;\n\t\t}\n\n\t\tsection_offset =\n\t\t\tget_unaligned_le16(&section->next_section_offset);\n\t}\n\n\tkfree(config_table);\n\n\treturn 0;\n}\n\n/* Switches the controller from PQI mode back into SIS mode. */\n\nstatic int pqi_revert_to_sis_mode(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\n\tpqi_change_irq_mode(ctrl_info, IRQ_MODE_NONE);\n\trc = pqi_reset(ctrl_info);\n\tif (rc)\n\t\treturn rc;\n\trc = sis_reenable_sis_mode(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"re-enabling SIS mode failed with error %d\\n\", rc);\n\t\treturn rc;\n\t}\n\tpqi_save_ctrl_mode(ctrl_info, SIS_MODE);\n\n\treturn 0;\n}\n\n/*\n * If the controller isn't already in SIS mode, this function forces it into\n * SIS mode.\n */\n\nstatic int pqi_force_sis_mode(struct pqi_ctrl_info *ctrl_info)\n{\n\tif (!sis_is_firmware_running(ctrl_info))\n\t\treturn -ENXIO;\n\n\tif (pqi_get_ctrl_mode(ctrl_info) == SIS_MODE)\n\t\treturn 0;\n\n\tif (sis_is_kernel_up(ctrl_info)) {\n\t\tpqi_save_ctrl_mode(ctrl_info, SIS_MODE);\n\t\treturn 0;\n\t}\n\n\treturn pqi_revert_to_sis_mode(ctrl_info);\n}\n\n#define PQI_POST_RESET_DELAY_B4_MSGU_READY\t5000\n\nstatic int pqi_ctrl_init(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\n\tif (reset_devices) {\n\t\tsis_soft_reset(ctrl_info);\n\t\tmsleep(PQI_POST_RESET_DELAY_B4_MSGU_READY);\n\t} else {\n\t\trc = pqi_force_sis_mode(ctrl_info);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t/*\n\t * Wait until the controller is ready to start accepting SIS\n\t * commands.\n\t */\n\trc = sis_wait_for_ctrl_ready(ctrl_info);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * Get the controller properties.  This allows us to determine\n\t * whether or not it supports PQI mode.\n\t */\n\trc = sis_get_ctrl_properties(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error obtaining controller properties\\n\");\n\t\treturn rc;\n\t}\n\n\trc = sis_get_pqi_capabilities(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error obtaining controller capabilities\\n\");\n\t\treturn rc;\n\t}\n\n\tif (reset_devices) {\n\t\tif (ctrl_info->max_outstanding_requests >\n\t\t\tPQI_MAX_OUTSTANDING_REQUESTS_KDUMP)\n\t\t\tctrl_info->max_outstanding_requests =\n\t\t\t\t\tPQI_MAX_OUTSTANDING_REQUESTS_KDUMP;\n\t} else {\n\t\tif (ctrl_info->max_outstanding_requests >\n\t\t\tPQI_MAX_OUTSTANDING_REQUESTS)\n\t\t\tctrl_info->max_outstanding_requests =\n\t\t\t\t\tPQI_MAX_OUTSTANDING_REQUESTS;\n\t}\n\n\tpqi_calculate_io_resources(ctrl_info);\n\n\trc = pqi_alloc_error_buffer(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"failed to allocate PQI error buffer\\n\");\n\t\treturn rc;\n\t}\n\n\t/*\n\t * If the function we are about to call succeeds, the\n\t * controller will transition from legacy SIS mode\n\t * into PQI mode.\n\t */\n\trc = sis_init_base_struct_addr(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error initializing PQI mode\\n\");\n\t\treturn rc;\n\t}\n\n\t/* Wait for the controller to complete the SIS -> PQI transition. */\n\trc = pqi_wait_for_pqi_mode_ready(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"transition to PQI mode failed\\n\");\n\t\treturn rc;\n\t}\n\n\t/* From here on, we are running in PQI mode. */\n\tctrl_info->pqi_mode_enabled = true;\n\tpqi_save_ctrl_mode(ctrl_info, PQI_MODE);\n\n\trc = pqi_alloc_admin_queues(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"failed to allocate admin queues\\n\");\n\t\treturn rc;\n\t}\n\n\trc = pqi_create_admin_queues(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error creating admin queues\\n\");\n\t\treturn rc;\n\t}\n\n\trc = pqi_report_device_capability(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"obtaining device capability failed\\n\");\n\t\treturn rc;\n\t}\n\n\trc = pqi_validate_device_capability(ctrl_info);\n\tif (rc)\n\t\treturn rc;\n\n\tpqi_calculate_queue_resources(ctrl_info);\n\n\trc = pqi_enable_msix_interrupts(ctrl_info);\n\tif (rc)\n\t\treturn rc;\n\n\tif (ctrl_info->num_msix_vectors_enabled < ctrl_info->num_queue_groups) {\n\t\tctrl_info->max_msix_vectors =\n\t\t\tctrl_info->num_msix_vectors_enabled;\n\t\tpqi_calculate_queue_resources(ctrl_info);\n\t}\n\n\trc = pqi_alloc_io_resources(ctrl_info);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pqi_alloc_operational_queues(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"failed to allocate operational queues\\n\");\n\t\treturn rc;\n\t}\n\n\tpqi_init_operational_queues(ctrl_info);\n\n\trc = pqi_request_irqs(ctrl_info);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pqi_create_queues(ctrl_info);\n\tif (rc)\n\t\treturn rc;\n\n\tpqi_change_irq_mode(ctrl_info, IRQ_MODE_MSIX);\n\n\tctrl_info->controller_online = true;\n\n\trc = pqi_process_config_table(ctrl_info);\n\tif (rc)\n\t\treturn rc;\n\n\tpqi_start_heartbeat_timer(ctrl_info);\n\n\trc = pqi_enable_events(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error enabling events\\n\");\n\t\treturn rc;\n\t}\n\n\t/* Register with the SCSI subsystem. */\n\trc = pqi_register_scsi(ctrl_info);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pqi_get_ctrl_product_details(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error obtaining product details\\n\");\n\t\treturn rc;\n\t}\n\n\trc = pqi_get_ctrl_serial_number(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error obtaining ctrl serial number\\n\");\n\t\treturn rc;\n\t}\n\n\trc = pqi_set_diag_rescan(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error enabling multi-lun rescan\\n\");\n\t\treturn rc;\n\t}\n\n\trc = pqi_write_driver_version_to_host_wellness(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error updating host wellness\\n\");\n\t\treturn rc;\n\t}\n\n\tpqi_schedule_update_time_worker(ctrl_info);\n\n\tpqi_scan_scsi_devices(ctrl_info);\n\n\treturn 0;\n}\n\nstatic void pqi_reinit_queues(struct pqi_ctrl_info *ctrl_info)\n{\n\tunsigned int i;\n\tstruct pqi_admin_queues *admin_queues;\n\tstruct pqi_event_queue *event_queue;\n\n\tadmin_queues = &ctrl_info->admin_queues;\n\tadmin_queues->iq_pi_copy = 0;\n\tadmin_queues->oq_ci_copy = 0;\n\twritel(0, admin_queues->oq_pi);\n\n\tfor (i = 0; i < ctrl_info->num_queue_groups; i++) {\n\t\tctrl_info->queue_groups[i].iq_pi_copy[RAID_PATH] = 0;\n\t\tctrl_info->queue_groups[i].iq_pi_copy[AIO_PATH] = 0;\n\t\tctrl_info->queue_groups[i].oq_ci_copy = 0;\n\n\t\twritel(0, ctrl_info->queue_groups[i].iq_ci[RAID_PATH]);\n\t\twritel(0, ctrl_info->queue_groups[i].iq_ci[AIO_PATH]);\n\t\twritel(0, ctrl_info->queue_groups[i].oq_pi);\n\t}\n\n\tevent_queue = &ctrl_info->event_queue;\n\twritel(0, event_queue->oq_pi);\n\tevent_queue->oq_ci_copy = 0;\n}\n\nstatic int pqi_ctrl_init_resume(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\n\trc = pqi_force_sis_mode(ctrl_info);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * Wait until the controller is ready to start accepting SIS\n\t * commands.\n\t */\n\trc = sis_wait_for_ctrl_ready_resume(ctrl_info);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * Get the controller properties.  This allows us to determine\n\t * whether or not it supports PQI mode.\n\t */\n\trc = sis_get_ctrl_properties(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error obtaining controller properties\\n\");\n\t\treturn rc;\n\t}\n\n\trc = sis_get_pqi_capabilities(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error obtaining controller capabilities\\n\");\n\t\treturn rc;\n\t}\n\n\t/*\n\t * If the function we are about to call succeeds, the\n\t * controller will transition from legacy SIS mode\n\t * into PQI mode.\n\t */\n\trc = sis_init_base_struct_addr(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error initializing PQI mode\\n\");\n\t\treturn rc;\n\t}\n\n\t/* Wait for the controller to complete the SIS -> PQI transition. */\n\trc = pqi_wait_for_pqi_mode_ready(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"transition to PQI mode failed\\n\");\n\t\treturn rc;\n\t}\n\n\t/* From here on, we are running in PQI mode. */\n\tctrl_info->pqi_mode_enabled = true;\n\tpqi_save_ctrl_mode(ctrl_info, PQI_MODE);\n\n\tpqi_reinit_queues(ctrl_info);\n\n\trc = pqi_create_admin_queues(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error creating admin queues\\n\");\n\t\treturn rc;\n\t}\n\n\trc = pqi_create_queues(ctrl_info);\n\tif (rc)\n\t\treturn rc;\n\n\tpqi_change_irq_mode(ctrl_info, IRQ_MODE_MSIX);\n\n\tctrl_info->controller_online = true;\n\tpqi_ctrl_unblock_requests(ctrl_info);\n\n\trc = pqi_process_config_table(ctrl_info);\n\tif (rc)\n\t\treturn rc;\n\n\tpqi_start_heartbeat_timer(ctrl_info);\n\n\trc = pqi_enable_events(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error enabling events\\n\");\n\t\treturn rc;\n\t}\n\n\trc = pqi_get_ctrl_product_details(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error obtaining product details\\n\");\n\t\treturn rc;\n\t}\n\n\trc = pqi_set_diag_rescan(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error enabling multi-lun rescan\\n\");\n\t\treturn rc;\n\t}\n\n\trc = pqi_write_driver_version_to_host_wellness(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"error updating host wellness\\n\");\n\t\treturn rc;\n\t}\n\n\tpqi_schedule_update_time_worker(ctrl_info);\n\n\tpqi_scan_scsi_devices(ctrl_info);\n\n\treturn 0;\n}\n\nstatic inline int pqi_set_pcie_completion_timeout(struct pci_dev *pci_dev,\n\tu16 timeout)\n{\n\tint rc;\n\n\trc = pcie_capability_clear_and_set_word(pci_dev, PCI_EXP_DEVCTL2,\n\t\tPCI_EXP_DEVCTL2_COMP_TIMEOUT, timeout);\n\n\treturn pcibios_err_to_errno(rc);\n}\n\nstatic int pqi_pci_init(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tu64 mask;\n\n\trc = pci_enable_device(ctrl_info->pci_dev);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"failed to enable PCI device\\n\");\n\t\treturn rc;\n\t}\n\n\tif (sizeof(dma_addr_t) > 4)\n\t\tmask = DMA_BIT_MASK(64);\n\telse\n\t\tmask = DMA_BIT_MASK(32);\n\n\trc = dma_set_mask_and_coherent(&ctrl_info->pci_dev->dev, mask);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev, \"failed to set DMA mask\\n\");\n\t\tgoto disable_device;\n\t}\n\n\trc = pci_request_regions(ctrl_info->pci_dev, DRIVER_NAME_SHORT);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"failed to obtain PCI resources\\n\");\n\t\tgoto disable_device;\n\t}\n\n\tctrl_info->iomem_base = ioremap(pci_resource_start(\n\t\tctrl_info->pci_dev, 0),\n\t\tsizeof(struct pqi_ctrl_registers));\n\tif (!ctrl_info->iomem_base) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"failed to map memory for controller registers\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto release_regions;\n\t}\n\n#define PCI_EXP_COMP_TIMEOUT_65_TO_210_MS\t\t0x6\n\n\t/* Increase the PCIe completion timeout. */\n\trc = pqi_set_pcie_completion_timeout(ctrl_info->pci_dev,\n\t\tPCI_EXP_COMP_TIMEOUT_65_TO_210_MS);\n\tif (rc) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"failed to set PCIe completion timeout\\n\");\n\t\tgoto release_regions;\n\t}\n\n\t/* Enable bus mastering. */\n\tpci_set_master(ctrl_info->pci_dev);\n\n\tctrl_info->registers = ctrl_info->iomem_base;\n\tctrl_info->pqi_registers = &ctrl_info->registers->pqi_registers;\n\n\tpci_set_drvdata(ctrl_info->pci_dev, ctrl_info);\n\n\treturn 0;\n\nrelease_regions:\n\tpci_release_regions(ctrl_info->pci_dev);\ndisable_device:\n\tpci_disable_device(ctrl_info->pci_dev);\n\n\treturn rc;\n}\n\nstatic void pqi_cleanup_pci_init(struct pqi_ctrl_info *ctrl_info)\n{\n\tiounmap(ctrl_info->iomem_base);\n\tpci_release_regions(ctrl_info->pci_dev);\n\tif (pci_is_enabled(ctrl_info->pci_dev))\n\t\tpci_disable_device(ctrl_info->pci_dev);\n\tpci_set_drvdata(ctrl_info->pci_dev, NULL);\n}\n\nstatic struct pqi_ctrl_info *pqi_alloc_ctrl_info(int numa_node)\n{\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tctrl_info = kzalloc_node(sizeof(struct pqi_ctrl_info),\n\t\t\tGFP_KERNEL, numa_node);\n\tif (!ctrl_info)\n\t\treturn NULL;\n\n\tmutex_init(&ctrl_info->scan_mutex);\n\tmutex_init(&ctrl_info->lun_reset_mutex);\n\tmutex_init(&ctrl_info->ofa_mutex);\n\n\tINIT_LIST_HEAD(&ctrl_info->scsi_device_list);\n\tspin_lock_init(&ctrl_info->scsi_device_list_lock);\n\n\tINIT_WORK(&ctrl_info->event_work, pqi_event_worker);\n\tatomic_set(&ctrl_info->num_interrupts, 0);\n\tatomic_set(&ctrl_info->sync_cmds_outstanding, 0);\n\n\tINIT_DELAYED_WORK(&ctrl_info->rescan_work, pqi_rescan_worker);\n\tINIT_DELAYED_WORK(&ctrl_info->update_time_work, pqi_update_time_worker);\n\n\ttimer_setup(&ctrl_info->heartbeat_timer, pqi_heartbeat_timer_handler, 0);\n\tINIT_WORK(&ctrl_info->ctrl_offline_work, pqi_ctrl_offline_worker);\n\n\tsema_init(&ctrl_info->sync_request_sem,\n\t\tPQI_RESERVED_IO_SLOTS_SYNCHRONOUS_REQUESTS);\n\tinit_waitqueue_head(&ctrl_info->block_requests_wait);\n\n\tINIT_LIST_HEAD(&ctrl_info->raid_bypass_retry_list);\n\tspin_lock_init(&ctrl_info->raid_bypass_retry_list_lock);\n\tINIT_WORK(&ctrl_info->raid_bypass_retry_work,\n\t\tpqi_raid_bypass_retry_worker);\n\n\tctrl_info->ctrl_id = atomic_inc_return(&pqi_controller_count) - 1;\n\tctrl_info->irq_mode = IRQ_MODE_NONE;\n\tctrl_info->max_msix_vectors = PQI_MAX_MSIX_VECTORS;\n\n\treturn ctrl_info;\n}\n\nstatic inline void pqi_free_ctrl_info(struct pqi_ctrl_info *ctrl_info)\n{\n\tkfree(ctrl_info);\n}\n\nstatic void pqi_free_interrupts(struct pqi_ctrl_info *ctrl_info)\n{\n\tpqi_free_irqs(ctrl_info);\n\tpqi_disable_msix_interrupts(ctrl_info);\n}\n\nstatic void pqi_free_ctrl_resources(struct pqi_ctrl_info *ctrl_info)\n{\n\tpqi_stop_heartbeat_timer(ctrl_info);\n\tpqi_free_interrupts(ctrl_info);\n\tif (ctrl_info->queue_memory_base)\n\t\tdma_free_coherent(&ctrl_info->pci_dev->dev,\n\t\t\tctrl_info->queue_memory_length,\n\t\t\tctrl_info->queue_memory_base,\n\t\t\tctrl_info->queue_memory_base_dma_handle);\n\tif (ctrl_info->admin_queue_memory_base)\n\t\tdma_free_coherent(&ctrl_info->pci_dev->dev,\n\t\t\tctrl_info->admin_queue_memory_length,\n\t\t\tctrl_info->admin_queue_memory_base,\n\t\t\tctrl_info->admin_queue_memory_base_dma_handle);\n\tpqi_free_all_io_requests(ctrl_info);\n\tif (ctrl_info->error_buffer)\n\t\tdma_free_coherent(&ctrl_info->pci_dev->dev,\n\t\t\tctrl_info->error_buffer_length,\n\t\t\tctrl_info->error_buffer,\n\t\t\tctrl_info->error_buffer_dma_handle);\n\tif (ctrl_info->iomem_base)\n\t\tpqi_cleanup_pci_init(ctrl_info);\n\tpqi_free_ctrl_info(ctrl_info);\n}\n\nstatic void pqi_remove_ctrl(struct pqi_ctrl_info *ctrl_info)\n{\n\tpqi_cancel_rescan_worker(ctrl_info);\n\tpqi_cancel_update_time_worker(ctrl_info);\n\tpqi_unregister_scsi(ctrl_info);\n\tif (ctrl_info->pqi_mode_enabled)\n\t\tpqi_revert_to_sis_mode(ctrl_info);\n\tpqi_free_ctrl_resources(ctrl_info);\n}\n\nstatic void pqi_ofa_ctrl_quiesce(struct pqi_ctrl_info *ctrl_info)\n{\n\tpqi_cancel_update_time_worker(ctrl_info);\n\tpqi_cancel_rescan_worker(ctrl_info);\n\tpqi_wait_until_lun_reset_finished(ctrl_info);\n\tpqi_wait_until_scan_finished(ctrl_info);\n\tpqi_ctrl_ofa_start(ctrl_info);\n\tpqi_ctrl_block_requests(ctrl_info);\n\tpqi_ctrl_wait_until_quiesced(ctrl_info);\n\tpqi_ctrl_wait_for_pending_io(ctrl_info, PQI_PENDING_IO_TIMEOUT_SECS);\n\tpqi_fail_io_queued_for_all_devices(ctrl_info);\n\tpqi_wait_until_inbound_queues_empty(ctrl_info);\n\tpqi_stop_heartbeat_timer(ctrl_info);\n\tctrl_info->pqi_mode_enabled = false;\n\tpqi_save_ctrl_mode(ctrl_info, SIS_MODE);\n}\n\nstatic void pqi_ofa_ctrl_unquiesce(struct pqi_ctrl_info *ctrl_info)\n{\n\tpqi_ofa_free_host_buffer(ctrl_info);\n\tctrl_info->pqi_mode_enabled = true;\n\tpqi_save_ctrl_mode(ctrl_info, PQI_MODE);\n\tctrl_info->controller_online = true;\n\tpqi_ctrl_unblock_requests(ctrl_info);\n\tpqi_start_heartbeat_timer(ctrl_info);\n\tpqi_schedule_update_time_worker(ctrl_info);\n\tpqi_clear_soft_reset_status(ctrl_info,\n\t\tPQI_SOFT_RESET_ABORT);\n\tpqi_scan_scsi_devices(ctrl_info);\n}\n\nstatic int pqi_ofa_alloc_mem(struct pqi_ctrl_info *ctrl_info,\n\tu32 total_size, u32 chunk_size)\n{\n\tu32 sg_count;\n\tu32 size;\n\tint i;\n\tstruct pqi_sg_descriptor *mem_descriptor = NULL;\n\tstruct device *dev;\n\tstruct pqi_ofa_memory *ofap;\n\n\tdev = &ctrl_info->pci_dev->dev;\n\n\tsg_count = (total_size + chunk_size - 1);\n\tsg_count /= chunk_size;\n\n\tofap = ctrl_info->pqi_ofa_mem_virt_addr;\n\n\tif (sg_count*chunk_size < total_size)\n\t\tgoto out;\n\n\tctrl_info->pqi_ofa_chunk_virt_addr =\n\t\t\t\tkcalloc(sg_count, sizeof(void *), GFP_KERNEL);\n\tif (!ctrl_info->pqi_ofa_chunk_virt_addr)\n\t\tgoto out;\n\n\tfor (size = 0, i = 0; size < total_size; size += chunk_size, i++) {\n\t\tdma_addr_t dma_handle;\n\n\t\tctrl_info->pqi_ofa_chunk_virt_addr[i] =\n\t\t\tdma_alloc_coherent(dev, chunk_size, &dma_handle,\n\t\t\t\t\t   GFP_KERNEL);\n\n\t\tif (!ctrl_info->pqi_ofa_chunk_virt_addr[i])\n\t\t\tbreak;\n\n\t\tmem_descriptor = &ofap->sg_descriptor[i];\n\t\tput_unaligned_le64 ((u64) dma_handle, &mem_descriptor->address);\n\t\tput_unaligned_le32 (chunk_size, &mem_descriptor->length);\n\t}\n\n\tif (!size || size < total_size)\n\t\tgoto out_free_chunks;\n\n\tput_unaligned_le32(CISS_SG_LAST, &mem_descriptor->flags);\n\tput_unaligned_le16(sg_count, &ofap->num_memory_descriptors);\n\tput_unaligned_le32(size, &ofap->bytes_allocated);\n\n\treturn 0;\n\nout_free_chunks:\n\twhile (--i >= 0) {\n\t\tmem_descriptor = &ofap->sg_descriptor[i];\n\t\tdma_free_coherent(dev, chunk_size,\n\t\t\t\tctrl_info->pqi_ofa_chunk_virt_addr[i],\n\t\t\t\tget_unaligned_le64(&mem_descriptor->address));\n\t}\n\tkfree(ctrl_info->pqi_ofa_chunk_virt_addr);\n\nout:\n\tput_unaligned_le32 (0, &ofap->bytes_allocated);\n\treturn -ENOMEM;\n}\n\nstatic int pqi_ofa_alloc_host_buffer(struct pqi_ctrl_info *ctrl_info)\n{\n\tu32 total_size;\n\tu32 min_chunk_size;\n\tu32 chunk_sz;\n\n\ttotal_size = le32_to_cpu(\n\t\t\tctrl_info->pqi_ofa_mem_virt_addr->bytes_allocated);\n\tmin_chunk_size = total_size / PQI_OFA_MAX_SG_DESCRIPTORS;\n\n\tfor (chunk_sz = total_size; chunk_sz >= min_chunk_size; chunk_sz /= 2)\n\t\tif (!pqi_ofa_alloc_mem(ctrl_info, total_size, chunk_sz))\n\t\t\treturn 0;\n\n\treturn -ENOMEM;\n}\n\nstatic void pqi_ofa_setup_host_buffer(struct pqi_ctrl_info *ctrl_info,\n\tu32 bytes_requested)\n{\n\tstruct pqi_ofa_memory *pqi_ofa_memory;\n\tstruct device *dev;\n\n\tdev = &ctrl_info->pci_dev->dev;\n\tpqi_ofa_memory = dma_alloc_coherent(dev,\n\t\t\t\t\t    PQI_OFA_MEMORY_DESCRIPTOR_LENGTH,\n\t\t\t\t\t    &ctrl_info->pqi_ofa_mem_dma_handle,\n\t\t\t\t\t    GFP_KERNEL);\n\n\tif (!pqi_ofa_memory)\n\t\treturn;\n\n\tput_unaligned_le16(PQI_OFA_VERSION, &pqi_ofa_memory->version);\n\tmemcpy(&pqi_ofa_memory->signature, PQI_OFA_SIGNATURE,\n\t\t\t\t\tsizeof(pqi_ofa_memory->signature));\n\tpqi_ofa_memory->bytes_allocated = cpu_to_le32(bytes_requested);\n\n\tctrl_info->pqi_ofa_mem_virt_addr = pqi_ofa_memory;\n\n\tif (pqi_ofa_alloc_host_buffer(ctrl_info) < 0) {\n\t\tdev_err(dev, \"Failed to allocate host buffer of size = %u\",\n\t\t\tbytes_requested);\n\t}\n\n\treturn;\n}\n\nstatic void pqi_ofa_free_host_buffer(struct pqi_ctrl_info *ctrl_info)\n{\n\tint i;\n\tstruct pqi_sg_descriptor *mem_descriptor;\n\tstruct pqi_ofa_memory *ofap;\n\n\tofap = ctrl_info->pqi_ofa_mem_virt_addr;\n\n\tif (!ofap)\n\t\treturn;\n\n\tif (!ofap->bytes_allocated)\n\t\tgoto out;\n\n\tmem_descriptor = ofap->sg_descriptor;\n\n\tfor (i = 0; i < get_unaligned_le16(&ofap->num_memory_descriptors);\n\t\ti++) {\n\t\tdma_free_coherent(&ctrl_info->pci_dev->dev,\n\t\t\tget_unaligned_le32(&mem_descriptor[i].length),\n\t\t\tctrl_info->pqi_ofa_chunk_virt_addr[i],\n\t\t\tget_unaligned_le64(&mem_descriptor[i].address));\n\t}\n\tkfree(ctrl_info->pqi_ofa_chunk_virt_addr);\n\nout:\n\tdma_free_coherent(&ctrl_info->pci_dev->dev,\n\t\t\tPQI_OFA_MEMORY_DESCRIPTOR_LENGTH, ofap,\n\t\t\tctrl_info->pqi_ofa_mem_dma_handle);\n\tctrl_info->pqi_ofa_mem_virt_addr = NULL;\n}\n\nstatic int pqi_ofa_host_memory_update(struct pqi_ctrl_info *ctrl_info)\n{\n\tstruct pqi_vendor_general_request request;\n\tsize_t size;\n\tstruct pqi_ofa_memory *ofap;\n\n\tmemset(&request, 0, sizeof(request));\n\n\tofap = ctrl_info->pqi_ofa_mem_virt_addr;\n\n\trequest.header.iu_type = PQI_REQUEST_IU_VENDOR_GENERAL;\n\tput_unaligned_le16(sizeof(request) - PQI_REQUEST_HEADER_LENGTH,\n\t\t&request.header.iu_length);\n\tput_unaligned_le16(PQI_VENDOR_GENERAL_HOST_MEMORY_UPDATE,\n\t\t&request.function_code);\n\n\tif (ofap) {\n\t\tsize = offsetof(struct pqi_ofa_memory, sg_descriptor) +\n\t\t\tget_unaligned_le16(&ofap->num_memory_descriptors) *\n\t\t\tsizeof(struct pqi_sg_descriptor);\n\n\t\tput_unaligned_le64((u64)ctrl_info->pqi_ofa_mem_dma_handle,\n\t\t\t&request.data.ofa_memory_allocation.buffer_address);\n\t\tput_unaligned_le32(size,\n\t\t\t&request.data.ofa_memory_allocation.buffer_length);\n\n\t}\n\n\treturn pqi_submit_raid_request_synchronous(ctrl_info, &request.header,\n\t\t0, NULL, NO_TIMEOUT);\n}\n\nstatic int pqi_ofa_ctrl_restart(struct pqi_ctrl_info *ctrl_info)\n{\n\tmsleep(PQI_POST_RESET_DELAY_B4_MSGU_READY);\n\treturn pqi_ctrl_init_resume(ctrl_info);\n}\n\nstatic void pqi_perform_lockup_action(void)\n{\n\tswitch (pqi_lockup_action) {\n\tcase PANIC:\n\t\tpanic(\"FATAL: Smart Family Controller lockup detected\");\n\t\tbreak;\n\tcase REBOOT:\n\t\temergency_restart();\n\t\tbreak;\n\tcase NONE:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic struct pqi_raid_error_info pqi_ctrl_offline_raid_error_info = {\n\t.data_out_result = PQI_DATA_IN_OUT_HARDWARE_ERROR,\n\t.status = SAM_STAT_CHECK_CONDITION,\n};\n\nstatic void pqi_fail_all_outstanding_requests(struct pqi_ctrl_info *ctrl_info)\n{\n\tunsigned int i;\n\tstruct pqi_io_request *io_request;\n\tstruct scsi_cmnd *scmd;\n\n\tfor (i = 0; i < ctrl_info->max_io_slots; i++) {\n\t\tio_request = &ctrl_info->io_request_pool[i];\n\t\tif (atomic_read(&io_request->refcount) == 0)\n\t\t\tcontinue;\n\n\t\tscmd = io_request->scmd;\n\t\tif (scmd) {\n\t\t\tset_host_byte(scmd, DID_NO_CONNECT);\n\t\t} else {\n\t\t\tio_request->status = -ENXIO;\n\t\t\tio_request->error_info =\n\t\t\t\t&pqi_ctrl_offline_raid_error_info;\n\t\t}\n\n\t\tio_request->io_complete_callback(io_request,\n\t\t\tio_request->context);\n\t}\n}\n\nstatic void pqi_take_ctrl_offline_deferred(struct pqi_ctrl_info *ctrl_info)\n{\n\tpqi_perform_lockup_action();\n\tpqi_stop_heartbeat_timer(ctrl_info);\n\tpqi_free_interrupts(ctrl_info);\n\tpqi_cancel_rescan_worker(ctrl_info);\n\tpqi_cancel_update_time_worker(ctrl_info);\n\tpqi_ctrl_wait_until_quiesced(ctrl_info);\n\tpqi_fail_all_outstanding_requests(ctrl_info);\n\tpqi_clear_all_queued_raid_bypass_retries(ctrl_info);\n\tpqi_ctrl_unblock_requests(ctrl_info);\n}\n\nstatic void pqi_ctrl_offline_worker(struct work_struct *work)\n{\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tctrl_info = container_of(work, struct pqi_ctrl_info, ctrl_offline_work);\n\tpqi_take_ctrl_offline_deferred(ctrl_info);\n}\n\nstatic void pqi_take_ctrl_offline(struct pqi_ctrl_info *ctrl_info)\n{\n\tif (!ctrl_info->controller_online)\n\t\treturn;\n\n\tctrl_info->controller_online = false;\n\tctrl_info->pqi_mode_enabled = false;\n\tpqi_ctrl_block_requests(ctrl_info);\n\tif (!pqi_disable_ctrl_shutdown)\n\t\tsis_shutdown_ctrl(ctrl_info);\n\tpci_disable_device(ctrl_info->pci_dev);\n\tdev_err(&ctrl_info->pci_dev->dev, \"controller offline\\n\");\n\tschedule_work(&ctrl_info->ctrl_offline_work);\n}\n\nstatic void pqi_print_ctrl_info(struct pci_dev *pci_dev,\n\tconst struct pci_device_id *id)\n{\n\tchar *ctrl_description;\n\n\tif (id->driver_data)\n\t\tctrl_description = (char *)id->driver_data;\n\telse\n\t\tctrl_description = \"Microsemi Smart Family Controller\";\n\n\tdev_info(&pci_dev->dev, \"%s found\\n\", ctrl_description);\n}\n\nstatic int pqi_pci_probe(struct pci_dev *pci_dev,\n\tconst struct pci_device_id *id)\n{\n\tint rc;\n\tint node, cp_node;\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tpqi_print_ctrl_info(pci_dev, id);\n\n\tif (pqi_disable_device_id_wildcards &&\n\t\tid->subvendor == PCI_ANY_ID &&\n\t\tid->subdevice == PCI_ANY_ID) {\n\t\tdev_warn(&pci_dev->dev,\n\t\t\t\"controller not probed because device ID wildcards are disabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (id->subvendor == PCI_ANY_ID || id->subdevice == PCI_ANY_ID)\n\t\tdev_warn(&pci_dev->dev,\n\t\t\t\"controller device ID matched using wildcards\\n\");\n\n\tnode = dev_to_node(&pci_dev->dev);\n\tif (node == NUMA_NO_NODE) {\n\t\tcp_node = cpu_to_node(0);\n\t\tif (cp_node == NUMA_NO_NODE)\n\t\t\tcp_node = 0;\n\t\tset_dev_node(&pci_dev->dev, cp_node);\n\t}\n\n\tctrl_info = pqi_alloc_ctrl_info(node);\n\tif (!ctrl_info) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"failed to allocate controller info block\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tctrl_info->pci_dev = pci_dev;\n\n\trc = pqi_pci_init(ctrl_info);\n\tif (rc)\n\t\tgoto error;\n\n\trc = pqi_ctrl_init(ctrl_info);\n\tif (rc)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tpqi_remove_ctrl(ctrl_info);\n\n\treturn rc;\n}\n\nstatic void pqi_pci_remove(struct pci_dev *pci_dev)\n{\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tctrl_info = pci_get_drvdata(pci_dev);\n\tif (!ctrl_info)\n\t\treturn;\n\n\tpqi_remove_ctrl(ctrl_info);\n}\n\nstatic void pqi_crash_if_pending_command(struct pqi_ctrl_info *ctrl_info)\n{\n\tunsigned int i;\n\tstruct pqi_io_request *io_request;\n\tstruct scsi_cmnd *scmd;\n\n\tfor (i = 0; i < ctrl_info->max_io_slots; i++) {\n\t\tio_request = &ctrl_info->io_request_pool[i];\n\t\tif (atomic_read(&io_request->refcount) == 0)\n\t\t\tcontinue;\n\t\tscmd = io_request->scmd;\n\t\tWARN_ON(scmd != NULL); /* IO command from SML */\n\t\tWARN_ON(scmd == NULL); /* Non-IO cmd or driver initiated*/\n\t}\n}\n\nstatic void pqi_shutdown(struct pci_dev *pci_dev)\n{\n\tint rc;\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tctrl_info = pci_get_drvdata(pci_dev);\n\tif (!ctrl_info) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"cache could not be flushed\\n\");\n\t\treturn;\n\t}\n\n\tpqi_disable_events(ctrl_info);\n\tpqi_wait_until_ofa_finished(ctrl_info);\n\tpqi_cancel_update_time_worker(ctrl_info);\n\tpqi_cancel_rescan_worker(ctrl_info);\n\tpqi_cancel_event_worker(ctrl_info);\n\n\tpqi_ctrl_shutdown_start(ctrl_info);\n\tpqi_ctrl_wait_until_quiesced(ctrl_info);\n\n\trc = pqi_ctrl_wait_for_pending_io(ctrl_info, NO_TIMEOUT);\n\tif (rc) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"wait for pending I/O failed\\n\");\n\t\treturn;\n\t}\n\n\tpqi_ctrl_block_device_reset(ctrl_info);\n\tpqi_wait_until_lun_reset_finished(ctrl_info);\n\n\t/*\n\t * Write all data in the controller's battery-backed cache to\n\t * storage.\n\t */\n\trc = pqi_flush_cache(ctrl_info, SHUTDOWN);\n\tif (rc)\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"unable to flush controller cache\\n\");\n\n\tpqi_ctrl_block_requests(ctrl_info);\n\n\trc = pqi_ctrl_wait_for_pending_sync_cmds(ctrl_info);\n\tif (rc) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"wait for pending sync cmds failed\\n\");\n\t\treturn;\n\t}\n\n\tpqi_crash_if_pending_command(ctrl_info);\n\tpqi_reset(ctrl_info);\n}\n\nstatic void pqi_process_lockup_action_param(void)\n{\n\tunsigned int i;\n\n\tif (!pqi_lockup_action_param)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(pqi_lockup_actions); i++) {\n\t\tif (strcmp(pqi_lockup_action_param,\n\t\t\tpqi_lockup_actions[i].name) == 0) {\n\t\t\tpqi_lockup_action = pqi_lockup_actions[i].action;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tpr_warn(\"%s: invalid lockup action setting \\\"%s\\\" - supported settings: none, reboot, panic\\n\",\n\t\tDRIVER_NAME_SHORT, pqi_lockup_action_param);\n}\n\nstatic void pqi_process_module_params(void)\n{\n\tpqi_process_lockup_action_param();\n}\n\nstatic __maybe_unused int pqi_suspend(struct pci_dev *pci_dev, pm_message_t state)\n{\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tctrl_info = pci_get_drvdata(pci_dev);\n\n\tpqi_disable_events(ctrl_info);\n\tpqi_cancel_update_time_worker(ctrl_info);\n\tpqi_cancel_rescan_worker(ctrl_info);\n\tpqi_wait_until_scan_finished(ctrl_info);\n\tpqi_wait_until_lun_reset_finished(ctrl_info);\n\tpqi_wait_until_ofa_finished(ctrl_info);\n\tpqi_flush_cache(ctrl_info, SUSPEND);\n\tpqi_ctrl_block_requests(ctrl_info);\n\tpqi_ctrl_wait_until_quiesced(ctrl_info);\n\tpqi_wait_until_inbound_queues_empty(ctrl_info);\n\tpqi_ctrl_wait_for_pending_io(ctrl_info, NO_TIMEOUT);\n\tpqi_stop_heartbeat_timer(ctrl_info);\n\n\tif (state.event == PM_EVENT_FREEZE)\n\t\treturn 0;\n\n\tpci_save_state(pci_dev);\n\tpci_set_power_state(pci_dev, pci_choose_state(pci_dev, state));\n\n\tctrl_info->controller_online = false;\n\tctrl_info->pqi_mode_enabled = false;\n\n\treturn 0;\n}\n\nstatic __maybe_unused int pqi_resume(struct pci_dev *pci_dev)\n{\n\tint rc;\n\tstruct pqi_ctrl_info *ctrl_info;\n\n\tctrl_info = pci_get_drvdata(pci_dev);\n\n\tif (pci_dev->current_state != PCI_D0) {\n\t\tctrl_info->max_hw_queue_index = 0;\n\t\tpqi_free_interrupts(ctrl_info);\n\t\tpqi_change_irq_mode(ctrl_info, IRQ_MODE_INTX);\n\t\trc = request_irq(pci_irq_vector(pci_dev, 0), pqi_irq_handler,\n\t\t\tIRQF_SHARED, DRIVER_NAME_SHORT,\n\t\t\t&ctrl_info->queue_groups[0]);\n\t\tif (rc) {\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"irq %u init failed with error %d\\n\",\n\t\t\t\tpci_dev->irq, rc);\n\t\t\treturn rc;\n\t\t}\n\t\tpqi_start_heartbeat_timer(ctrl_info);\n\t\tpqi_ctrl_unblock_requests(ctrl_info);\n\t\treturn 0;\n\t}\n\n\tpci_set_power_state(pci_dev, PCI_D0);\n\tpci_restore_state(pci_dev);\n\n\treturn pqi_ctrl_init_resume(ctrl_info);\n}\n\n/* Define the PCI IDs for the controllers that we support. */\nstatic const struct pci_device_id pqi_pci_id_table[] = {\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x105b, 0x1211)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x105b, 0x1321)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x152d, 0x8a22)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x152d, 0x8a23)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x152d, 0x8a24)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x152d, 0x8a36)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x152d, 0x8a37)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x193d, 0x1104)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x193d, 0x1105)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x193d, 0x1106)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x193d, 0x1107)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x193d, 0x8460)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x193d, 0x8461)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x193d, 0xc460)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x193d, 0xc461)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x193d, 0xf460)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x193d, 0xf461)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x1bd4, 0x0045)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x1bd4, 0x0046)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x1bd4, 0x0047)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x1bd4, 0x0048)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x1bd4, 0x004a)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x1bd4, 0x004b)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x1bd4, 0x004c)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x1bd4, 0x004f)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x19e5, 0xd227)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x19e5, 0xd228)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x19e5, 0xd229)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x19e5, 0xd22a)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x19e5, 0xd22b)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x19e5, 0xd22c)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0110)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0608)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0800)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0801)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0802)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0803)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0804)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0805)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0806)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0807)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0808)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0809)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x080a)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0900)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0901)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0902)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0903)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0904)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0905)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0906)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0907)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x0908)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x090a)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x1200)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x1201)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x1202)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x1280)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x1281)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x1282)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x1300)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x1301)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x1302)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x1303)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADAPTEC2, 0x1380)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_ADVANTECH, 0x8312)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_DELL, 0x1fe0)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_HP, 0x0600)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_HP, 0x0601)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_HP, 0x0602)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_HP, 0x0603)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_HP, 0x0609)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_HP, 0x0650)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_HP, 0x0651)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_HP, 0x0652)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_HP, 0x0653)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_HP, 0x0654)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_HP, 0x0655)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_HP, 0x0700)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_HP, 0x0701)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_HP, 0x1001)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_HP, 0x1100)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_HP, 0x1101)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x1d8d, 0x0800)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x1d8d, 0x0908)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x1d8d, 0x0806)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       0x1d8d, 0x0916)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_VENDOR_ID_GIGABYTE, 0x1000)\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x028f,\n\t\t\t       PCI_ANY_ID, PCI_ANY_ID)\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(pci, pqi_pci_id_table);\n\nstatic struct pci_driver pqi_pci_driver = {\n\t.name = DRIVER_NAME_SHORT,\n\t.id_table = pqi_pci_id_table,\n\t.probe = pqi_pci_probe,\n\t.remove = pqi_pci_remove,\n\t.shutdown = pqi_shutdown,\n#if defined(CONFIG_PM)\n\t.suspend = pqi_suspend,\n\t.resume = pqi_resume,\n#endif\n};\n\nstatic int __init pqi_init(void)\n{\n\tint rc;\n\n\tpr_info(DRIVER_NAME \"\\n\");\n\n\tpqi_sas_transport_template = sas_attach_transport(&pqi_sas_transport_functions);\n\tif (!pqi_sas_transport_template)\n\t\treturn -ENODEV;\n\n\tpqi_process_module_params();\n\n\trc = pci_register_driver(&pqi_pci_driver);\n\tif (rc)\n\t\tsas_release_transport(pqi_sas_transport_template);\n\n\treturn rc;\n}\n\nstatic void __exit pqi_cleanup(void)\n{\n\tpci_unregister_driver(&pqi_pci_driver);\n\tsas_release_transport(pqi_sas_transport_template);\n}\n\nmodule_init(pqi_init);\nmodule_exit(pqi_cleanup);\n\nstatic void __attribute__((unused)) verify_structures(void)\n{\n\tBUILD_BUG_ON(offsetof(struct pqi_ctrl_registers,\n\t\tsis_host_to_ctrl_doorbell) != 0x20);\n\tBUILD_BUG_ON(offsetof(struct pqi_ctrl_registers,\n\t\tsis_interrupt_mask) != 0x34);\n\tBUILD_BUG_ON(offsetof(struct pqi_ctrl_registers,\n\t\tsis_ctrl_to_host_doorbell) != 0x9c);\n\tBUILD_BUG_ON(offsetof(struct pqi_ctrl_registers,\n\t\tsis_ctrl_to_host_doorbell_clear) != 0xa0);\n\tBUILD_BUG_ON(offsetof(struct pqi_ctrl_registers,\n\t\tsis_driver_scratch) != 0xb0);\n\tBUILD_BUG_ON(offsetof(struct pqi_ctrl_registers,\n\t\tsis_firmware_status) != 0xbc);\n\tBUILD_BUG_ON(offsetof(struct pqi_ctrl_registers,\n\t\tsis_mailbox) != 0x1000);\n\tBUILD_BUG_ON(offsetof(struct pqi_ctrl_registers,\n\t\tpqi_registers) != 0x4000);\n\n\tBUILD_BUG_ON(offsetof(struct pqi_iu_header,\n\t\tiu_type) != 0x0);\n\tBUILD_BUG_ON(offsetof(struct pqi_iu_header,\n\t\tiu_length) != 0x2);\n\tBUILD_BUG_ON(offsetof(struct pqi_iu_header,\n\t\tresponse_queue_id) != 0x4);\n\tBUILD_BUG_ON(offsetof(struct pqi_iu_header,\n\t\twork_area) != 0x6);\n\tBUILD_BUG_ON(sizeof(struct pqi_iu_header) != 0x8);\n\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_error_info,\n\t\tstatus) != 0x0);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_error_info,\n\t\tservice_response) != 0x1);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_error_info,\n\t\tdata_present) != 0x2);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_error_info,\n\t\treserved) != 0x3);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_error_info,\n\t\tresidual_count) != 0x4);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_error_info,\n\t\tdata_length) != 0x8);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_error_info,\n\t\treserved1) != 0xa);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_error_info,\n\t\tdata) != 0xc);\n\tBUILD_BUG_ON(sizeof(struct pqi_aio_error_info) != 0x10c);\n\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_error_info,\n\t\tdata_in_result) != 0x0);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_error_info,\n\t\tdata_out_result) != 0x1);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_error_info,\n\t\treserved) != 0x2);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_error_info,\n\t\tstatus) != 0x5);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_error_info,\n\t\tstatus_qualifier) != 0x6);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_error_info,\n\t\tsense_data_length) != 0x8);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_error_info,\n\t\tresponse_data_length) != 0xa);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_error_info,\n\t\tdata_in_transferred) != 0xc);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_error_info,\n\t\tdata_out_transferred) != 0x10);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_error_info,\n\t\tdata) != 0x14);\n\tBUILD_BUG_ON(sizeof(struct pqi_raid_error_info) != 0x114);\n\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tsignature) != 0x0);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tfunction_and_status_code) != 0x8);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tmax_admin_iq_elements) != 0x10);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tmax_admin_oq_elements) != 0x11);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tadmin_iq_element_length) != 0x12);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tadmin_oq_element_length) != 0x13);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tmax_reset_timeout) != 0x14);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tlegacy_intx_status) != 0x18);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tlegacy_intx_mask_set) != 0x1c);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tlegacy_intx_mask_clear) != 0x20);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tdevice_status) != 0x40);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tadmin_iq_pi_offset) != 0x48);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tadmin_oq_ci_offset) != 0x50);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tadmin_iq_element_array_addr) != 0x58);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tadmin_oq_element_array_addr) != 0x60);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tadmin_iq_ci_addr) != 0x68);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tadmin_oq_pi_addr) != 0x70);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tadmin_iq_num_elements) != 0x78);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tadmin_oq_num_elements) != 0x79);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tadmin_queue_int_msg_num) != 0x7a);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tdevice_error) != 0x80);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\terror_details) != 0x88);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tdevice_reset) != 0x90);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_registers,\n\t\tpower_action) != 0x94);\n\tBUILD_BUG_ON(sizeof(struct pqi_device_registers) != 0x100);\n\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\theader.iu_type) != 0);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\theader.iu_length) != 2);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\theader.work_area) != 6);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\trequest_id) != 8);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tfunction_code) != 10);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.report_device_capability.buffer_length) != 44);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.report_device_capability.sg_descriptor) != 48);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.create_operational_iq.queue_id) != 12);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.create_operational_iq.element_array_addr) != 16);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.create_operational_iq.ci_addr) != 24);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.create_operational_iq.num_elements) != 32);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.create_operational_iq.element_length) != 34);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.create_operational_iq.queue_protocol) != 36);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.create_operational_oq.queue_id) != 12);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.create_operational_oq.element_array_addr) != 16);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.create_operational_oq.pi_addr) != 24);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.create_operational_oq.num_elements) != 32);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.create_operational_oq.element_length) != 34);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.create_operational_oq.queue_protocol) != 36);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.create_operational_oq.int_msg_num) != 40);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.create_operational_oq.coalescing_count) != 42);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.create_operational_oq.min_coalescing_time) != 44);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.create_operational_oq.max_coalescing_time) != 48);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_request,\n\t\tdata.delete_operational_queue.queue_id) != 12);\n\tBUILD_BUG_ON(sizeof(struct pqi_general_admin_request) != 64);\n\tBUILD_BUG_ON(sizeof_field(struct pqi_general_admin_request,\n\t\tdata.create_operational_iq) != 64 - 11);\n\tBUILD_BUG_ON(sizeof_field(struct pqi_general_admin_request,\n\t\tdata.create_operational_oq) != 64 - 11);\n\tBUILD_BUG_ON(sizeof_field(struct pqi_general_admin_request,\n\t\tdata.delete_operational_queue) != 64 - 11);\n\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_response,\n\t\theader.iu_type) != 0);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_response,\n\t\theader.iu_length) != 2);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_response,\n\t\theader.work_area) != 6);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_response,\n\t\trequest_id) != 8);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_response,\n\t\tfunction_code) != 10);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_response,\n\t\tstatus) != 11);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_response,\n\t\tdata.create_operational_iq.status_descriptor) != 12);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_response,\n\t\tdata.create_operational_iq.iq_pi_offset) != 16);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_response,\n\t\tdata.create_operational_oq.status_descriptor) != 12);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_admin_response,\n\t\tdata.create_operational_oq.oq_ci_offset) != 16);\n\tBUILD_BUG_ON(sizeof(struct pqi_general_admin_response) != 64);\n\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_path_request,\n\t\theader.iu_type) != 0);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_path_request,\n\t\theader.iu_length) != 2);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_path_request,\n\t\theader.response_queue_id) != 4);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_path_request,\n\t\theader.work_area) != 6);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_path_request,\n\t\trequest_id) != 8);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_path_request,\n\t\tnexus_id) != 10);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_path_request,\n\t\tbuffer_length) != 12);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_path_request,\n\t\tlun_number) != 16);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_path_request,\n\t\tprotocol_specific) != 24);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_path_request,\n\t\terror_index) != 27);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_path_request,\n\t\tcdb) != 32);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_path_request,\n\t\ttimeout) != 60);\n\tBUILD_BUG_ON(offsetof(struct pqi_raid_path_request,\n\t\tsg_descriptors) != 64);\n\tBUILD_BUG_ON(sizeof(struct pqi_raid_path_request) !=\n\t\tPQI_OPERATIONAL_IQ_ELEMENT_LENGTH);\n\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_path_request,\n\t\theader.iu_type) != 0);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_path_request,\n\t\theader.iu_length) != 2);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_path_request,\n\t\theader.response_queue_id) != 4);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_path_request,\n\t\theader.work_area) != 6);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_path_request,\n\t\trequest_id) != 8);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_path_request,\n\t\tnexus_id) != 12);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_path_request,\n\t\tbuffer_length) != 16);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_path_request,\n\t\tdata_encryption_key_index) != 22);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_path_request,\n\t\tencrypt_tweak_lower) != 24);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_path_request,\n\t\tencrypt_tweak_upper) != 28);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_path_request,\n\t\tcdb) != 32);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_path_request,\n\t\terror_index) != 48);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_path_request,\n\t\tnum_sg_descriptors) != 50);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_path_request,\n\t\tcdb_length) != 51);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_path_request,\n\t\tlun_number) != 52);\n\tBUILD_BUG_ON(offsetof(struct pqi_aio_path_request,\n\t\tsg_descriptors) != 64);\n\tBUILD_BUG_ON(sizeof(struct pqi_aio_path_request) !=\n\t\tPQI_OPERATIONAL_IQ_ELEMENT_LENGTH);\n\n\tBUILD_BUG_ON(offsetof(struct pqi_io_response,\n\t\theader.iu_type) != 0);\n\tBUILD_BUG_ON(offsetof(struct pqi_io_response,\n\t\theader.iu_length) != 2);\n\tBUILD_BUG_ON(offsetof(struct pqi_io_response,\n\t\trequest_id) != 8);\n\tBUILD_BUG_ON(offsetof(struct pqi_io_response,\n\t\terror_index) != 10);\n\n\tBUILD_BUG_ON(offsetof(struct pqi_general_management_request,\n\t\theader.iu_type) != 0);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_management_request,\n\t\theader.iu_length) != 2);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_management_request,\n\t\theader.response_queue_id) != 4);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_management_request,\n\t\trequest_id) != 8);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_management_request,\n\t\tdata.report_event_configuration.buffer_length) != 12);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_management_request,\n\t\tdata.report_event_configuration.sg_descriptors) != 16);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_management_request,\n\t\tdata.set_event_configuration.global_event_oq_id) != 10);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_management_request,\n\t\tdata.set_event_configuration.buffer_length) != 12);\n\tBUILD_BUG_ON(offsetof(struct pqi_general_management_request,\n\t\tdata.set_event_configuration.sg_descriptors) != 16);\n\n\tBUILD_BUG_ON(offsetof(struct pqi_iu_layer_descriptor,\n\t\tmax_inbound_iu_length) != 6);\n\tBUILD_BUG_ON(offsetof(struct pqi_iu_layer_descriptor,\n\t\tmax_outbound_iu_length) != 14);\n\tBUILD_BUG_ON(sizeof(struct pqi_iu_layer_descriptor) != 16);\n\n\tBUILD_BUG_ON(offsetof(struct pqi_device_capability,\n\t\tdata_length) != 0);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_capability,\n\t\tiq_arbitration_priority_support_bitmask) != 8);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_capability,\n\t\tmaximum_aw_a) != 9);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_capability,\n\t\tmaximum_aw_b) != 10);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_capability,\n\t\tmaximum_aw_c) != 11);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_capability,\n\t\tmax_inbound_queues) != 16);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_capability,\n\t\tmax_elements_per_iq) != 18);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_capability,\n\t\tmax_iq_element_length) != 24);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_capability,\n\t\tmin_iq_element_length) != 26);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_capability,\n\t\tmax_outbound_queues) != 30);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_capability,\n\t\tmax_elements_per_oq) != 32);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_capability,\n\t\tintr_coalescing_time_granularity) != 34);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_capability,\n\t\tmax_oq_element_length) != 36);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_capability,\n\t\tmin_oq_element_length) != 38);\n\tBUILD_BUG_ON(offsetof(struct pqi_device_capability,\n\t\tiu_layer_descriptors) != 64);\n\tBUILD_BUG_ON(sizeof(struct pqi_device_capability) != 576);\n\n\tBUILD_BUG_ON(offsetof(struct pqi_event_descriptor,\n\t\tevent_type) != 0);\n\tBUILD_BUG_ON(offsetof(struct pqi_event_descriptor,\n\t\toq_id) != 2);\n\tBUILD_BUG_ON(sizeof(struct pqi_event_descriptor) != 4);\n\n\tBUILD_BUG_ON(offsetof(struct pqi_event_config,\n\t\tnum_event_descriptors) != 2);\n\tBUILD_BUG_ON(offsetof(struct pqi_event_config,\n\t\tdescriptors) != 4);\n\n\tBUILD_BUG_ON(PQI_NUM_SUPPORTED_EVENTS !=\n\t\tARRAY_SIZE(pqi_supported_event_types));\n\n\tBUILD_BUG_ON(offsetof(struct pqi_event_response,\n\t\theader.iu_type) != 0);\n\tBUILD_BUG_ON(offsetof(struct pqi_event_response,\n\t\theader.iu_length) != 2);\n\tBUILD_BUG_ON(offsetof(struct pqi_event_response,\n\t\tevent_type) != 8);\n\tBUILD_BUG_ON(offsetof(struct pqi_event_response,\n\t\tevent_id) != 10);\n\tBUILD_BUG_ON(offsetof(struct pqi_event_response,\n\t\tadditional_event_id) != 12);\n\tBUILD_BUG_ON(offsetof(struct pqi_event_response,\n\t\tdata) != 16);\n\tBUILD_BUG_ON(sizeof(struct pqi_event_response) != 32);\n\n\tBUILD_BUG_ON(offsetof(struct pqi_event_acknowledge_request,\n\t\theader.iu_type) != 0);\n\tBUILD_BUG_ON(offsetof(struct pqi_event_acknowledge_request,\n\t\theader.iu_length) != 2);\n\tBUILD_BUG_ON(offsetof(struct pqi_event_acknowledge_request,\n\t\tevent_type) != 8);\n\tBUILD_BUG_ON(offsetof(struct pqi_event_acknowledge_request,\n\t\tevent_id) != 10);\n\tBUILD_BUG_ON(offsetof(struct pqi_event_acknowledge_request,\n\t\tadditional_event_id) != 12);\n\tBUILD_BUG_ON(sizeof(struct pqi_event_acknowledge_request) != 16);\n\n\tBUILD_BUG_ON(offsetof(struct pqi_task_management_request,\n\t\theader.iu_type) != 0);\n\tBUILD_BUG_ON(offsetof(struct pqi_task_management_request,\n\t\theader.iu_length) != 2);\n\tBUILD_BUG_ON(offsetof(struct pqi_task_management_request,\n\t\trequest_id) != 8);\n\tBUILD_BUG_ON(offsetof(struct pqi_task_management_request,\n\t\tnexus_id) != 10);\n\tBUILD_BUG_ON(offsetof(struct pqi_task_management_request,\n\t\ttimeout) != 14);\n\tBUILD_BUG_ON(offsetof(struct pqi_task_management_request,\n\t\tlun_number) != 16);\n\tBUILD_BUG_ON(offsetof(struct pqi_task_management_request,\n\t\tprotocol_specific) != 24);\n\tBUILD_BUG_ON(offsetof(struct pqi_task_management_request,\n\t\toutbound_queue_id_to_manage) != 26);\n\tBUILD_BUG_ON(offsetof(struct pqi_task_management_request,\n\t\trequest_id_to_manage) != 28);\n\tBUILD_BUG_ON(offsetof(struct pqi_task_management_request,\n\t\ttask_management_function) != 30);\n\tBUILD_BUG_ON(sizeof(struct pqi_task_management_request) != 32);\n\n\tBUILD_BUG_ON(offsetof(struct pqi_task_management_response,\n\t\theader.iu_type) != 0);\n\tBUILD_BUG_ON(offsetof(struct pqi_task_management_response,\n\t\theader.iu_length) != 2);\n\tBUILD_BUG_ON(offsetof(struct pqi_task_management_response,\n\t\trequest_id) != 8);\n\tBUILD_BUG_ON(offsetof(struct pqi_task_management_response,\n\t\tnexus_id) != 10);\n\tBUILD_BUG_ON(offsetof(struct pqi_task_management_response,\n\t\tadditional_response_info) != 12);\n\tBUILD_BUG_ON(offsetof(struct pqi_task_management_response,\n\t\tresponse_code) != 15);\n\tBUILD_BUG_ON(sizeof(struct pqi_task_management_response) != 16);\n\n\tBUILD_BUG_ON(offsetof(struct bmic_identify_controller,\n\t\tconfigured_logical_drive_count) != 0);\n\tBUILD_BUG_ON(offsetof(struct bmic_identify_controller,\n\t\tconfiguration_signature) != 1);\n\tBUILD_BUG_ON(offsetof(struct bmic_identify_controller,\n\t\tfirmware_version) != 5);\n\tBUILD_BUG_ON(offsetof(struct bmic_identify_controller,\n\t\textended_logical_unit_count) != 154);\n\tBUILD_BUG_ON(offsetof(struct bmic_identify_controller,\n\t\tfirmware_build_number) != 190);\n\tBUILD_BUG_ON(offsetof(struct bmic_identify_controller,\n\t\tcontroller_mode) != 292);\n\n\tBUILD_BUG_ON(offsetof(struct bmic_identify_physical_device,\n\t\tphys_bay_in_box) != 115);\n\tBUILD_BUG_ON(offsetof(struct bmic_identify_physical_device,\n\t\tdevice_type) != 120);\n\tBUILD_BUG_ON(offsetof(struct bmic_identify_physical_device,\n\t\tredundant_path_present_map) != 1736);\n\tBUILD_BUG_ON(offsetof(struct bmic_identify_physical_device,\n\t\tactive_path_number) != 1738);\n\tBUILD_BUG_ON(offsetof(struct bmic_identify_physical_device,\n\t\talternate_paths_phys_connector) != 1739);\n\tBUILD_BUG_ON(offsetof(struct bmic_identify_physical_device,\n\t\talternate_paths_phys_box_on_port) != 1755);\n\tBUILD_BUG_ON(offsetof(struct bmic_identify_physical_device,\n\t\tcurrent_queue_depth_limit) != 1796);\n\tBUILD_BUG_ON(sizeof(struct bmic_identify_physical_device) != 2560);\n\n\tBUILD_BUG_ON(PQI_ADMIN_IQ_NUM_ELEMENTS > 255);\n\tBUILD_BUG_ON(PQI_ADMIN_OQ_NUM_ELEMENTS > 255);\n\tBUILD_BUG_ON(PQI_ADMIN_IQ_ELEMENT_LENGTH %\n\t\tPQI_QUEUE_ELEMENT_LENGTH_ALIGNMENT != 0);\n\tBUILD_BUG_ON(PQI_ADMIN_OQ_ELEMENT_LENGTH %\n\t\tPQI_QUEUE_ELEMENT_LENGTH_ALIGNMENT != 0);\n\tBUILD_BUG_ON(PQI_OPERATIONAL_IQ_ELEMENT_LENGTH > 1048560);\n\tBUILD_BUG_ON(PQI_OPERATIONAL_IQ_ELEMENT_LENGTH %\n\t\tPQI_QUEUE_ELEMENT_LENGTH_ALIGNMENT != 0);\n\tBUILD_BUG_ON(PQI_OPERATIONAL_OQ_ELEMENT_LENGTH > 1048560);\n\tBUILD_BUG_ON(PQI_OPERATIONAL_OQ_ELEMENT_LENGTH %\n\t\tPQI_QUEUE_ELEMENT_LENGTH_ALIGNMENT != 0);\n\n\tBUILD_BUG_ON(PQI_RESERVED_IO_SLOTS >= PQI_MAX_OUTSTANDING_REQUESTS);\n\tBUILD_BUG_ON(PQI_RESERVED_IO_SLOTS >=\n\t\tPQI_MAX_OUTSTANDING_REQUESTS_KDUMP);\n}\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 0, "line": 6165}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/smartpqi/smartpqi_init.c", "reportHash": "71f25624731c2f7f582c2fb498ab4767", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 6159}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/smartpqi/smartpqi_init.c", "reportHash": "853a10f3d956e59578d75286e96527e2", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 6336}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/smartpqi/smartpqi_init.c", "reportHash": "dcc729875fb354b2e461daf4335c41ee", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 6190}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/smartpqi/smartpqi_init.c", "reportHash": "57c605bcdc7705873239b1aa738fc74f", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 6533}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/smartpqi/smartpqi_init.c", "reportHash": "ac17b7a074656cdc15bef75856bfcc51", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 6506}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/smartpqi/smartpqi_init.c", "reportHash": "b39dfb8edf3c567311e7a73861a08f29", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 6448}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/smartpqi/smartpqi_init.c", "reportHash": "93556853f41986b9e7a596442f0252fb", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 6178}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/smartpqi/smartpqi_init.c", "reportHash": "b259626d10fde3fd9f12345b8665823e", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 6304}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/smartpqi/smartpqi_init.c", "reportHash": "db27d1870088e40b4d08c50d7a780ca4", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 6202}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/smartpqi/smartpqi_init.c", "reportHash": "6ffb25ef881fcb90b92938febd3bd222", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
