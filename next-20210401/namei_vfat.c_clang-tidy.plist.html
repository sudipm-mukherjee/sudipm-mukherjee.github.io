<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/src/fs/fat/fat.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _FAT_H\n#define _FAT_H\n\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/msdos_fs.h>\n\n/*\n * vfat shortname flags\n */\n#define VFAT_SFN_DISPLAY_LOWER\t0x0001 /* convert to lowercase for display */\n#define VFAT_SFN_DISPLAY_WIN95\t0x0002 /* emulate win95 rule for display */\n#define VFAT_SFN_DISPLAY_WINNT\t0x0004 /* emulate winnt rule for display */\n#define VFAT_SFN_CREATE_WIN95\t0x0100 /* emulate win95 rule for create */\n#define VFAT_SFN_CREATE_WINNT\t0x0200 /* emulate winnt rule for create */\n\n#define FAT_ERRORS_CONT\t\t1      /* ignore error and continue */\n#define FAT_ERRORS_PANIC\t2      /* panic on error */\n#define FAT_ERRORS_RO\t\t3      /* remount r/o on error */\n\n#define FAT_NFS_STALE_RW\t1      /* NFS RW support, can cause ESTALE */\n#define FAT_NFS_NOSTALE_RO\t2      /* NFS RO support, no ESTALE issue */\n\nstruct fat_mount_options {\n\tkuid_t fs_uid;\n\tkgid_t fs_gid;\n\tunsigned short fs_fmask;\n\tunsigned short fs_dmask;\n\tunsigned short codepage;   /* Codepage for shortname conversions */\n\tint time_offset;\t   /* Offset of timestamps from UTC (in minutes) */\n\tchar *iocharset;           /* Charset used for filename input/display */\n\tunsigned short shortname;  /* flags for shortname display/create rule */\n\tunsigned char name_check;  /* r = relaxed, n = normal, s = strict */\n\tunsigned char errors;\t   /* On error: continue, panic, remount-ro */\n\tunsigned char nfs;\t  /* NFS support: nostale_ro, stale_rw */\n\tunsigned short allow_utime;/* permission for setting the [am]time */\n\tunsigned quiet:1,          /* set = fake successful chmods and chowns */\n\t\t showexec:1,       /* set = only set x bit for com/exe/bat */\n\t\t sys_immutable:1,  /* set = system files are immutable */\n\t\t dotsOK:1,         /* set = hidden and system files are named '.filename' */\n\t\t isvfat:1,         /* 0=no vfat long filename support, 1=vfat support */\n\t\t utf8:1,\t   /* Use of UTF-8 character set (Default) */\n\t\t unicode_xlate:1,  /* create escape sequences for unhandled Unicode */\n\t\t numtail:1,        /* Does first alias have a numeric '~1' type tail? */\n\t\t flush:1,\t   /* write things quickly */\n\t\t nocase:1,\t   /* Does this need case conversion? 0=need case conversion*/\n\t\t usefree:1,\t   /* Use free_clusters for FAT32 */\n\t\t tz_set:1,\t   /* Filesystem timestamps' offset set */\n\t\t rodir:1,\t   /* allow ATTR_RO for directory */\n\t\t discard:1,\t   /* Issue discard requests on deletions */\n\t\t dos1xfloppy:1;\t   /* Assume default BPB for DOS 1.x floppies */\n};\n\n#define FAT_HASH_BITS\t8\n#define FAT_HASH_SIZE\t(1UL << FAT_HASH_BITS)\n\n/*\n * MS-DOS file system in-core superblock data\n */\nstruct msdos_sb_info {\n\tunsigned short sec_per_clus;  /* sectors/cluster */\n\tunsigned short cluster_bits;  /* log2(cluster_size) */\n\tunsigned int cluster_size;    /* cluster size */\n\tunsigned char fats, fat_bits; /* number of FATs, FAT bits (12,16 or 32) */\n\tunsigned short fat_start;\n\tunsigned long fat_length;     /* FAT start & length (sec.) */\n\tunsigned long dir_start;\n\tunsigned short dir_entries;   /* root dir start & entries */\n\tunsigned long data_start;     /* first data sector */\n\tunsigned long max_cluster;    /* maximum cluster number */\n\tunsigned long root_cluster;   /* first cluster of the root directory */\n\tunsigned long fsinfo_sector;  /* sector number of FAT32 fsinfo */\n\tstruct mutex fat_lock;\n\tstruct mutex nfs_build_inode_lock;\n\tstruct mutex s_lock;\n\tunsigned int prev_free;      /* previously allocated cluster number */\n\tunsigned int free_clusters;  /* -1 if undefined */\n\tunsigned int free_clus_valid; /* is free_clusters valid? */\n\tstruct fat_mount_options options;\n\tstruct nls_table *nls_disk;   /* Codepage used on disk */\n\tstruct nls_table *nls_io;     /* Charset used for input and display */\n\tconst void *dir_ops;\t      /* Opaque; default directory operations */\n\tint dir_per_block;\t      /* dir entries per block */\n\tint dir_per_block_bits;\t      /* log2(dir_per_block) */\n\tunsigned int vol_id;\t\t/*volume ID*/\n\n\tint fatent_shift;\n\tconst struct fatent_operations *fatent_ops;\n\tstruct inode *fat_inode;\n\tstruct inode *fsinfo_inode;\n\n\tstruct ratelimit_state ratelimit;\n\n\tspinlock_t inode_hash_lock;\n\tstruct hlist_head inode_hashtable[FAT_HASH_SIZE];\n\n\tspinlock_t dir_hash_lock;\n\tstruct hlist_head dir_hashtable[FAT_HASH_SIZE];\n\n\tunsigned int dirty;           /* fs state before mount */\n\tstruct rcu_head rcu;\n};\n\n#define FAT_CACHE_VALID\t0\t/* special case for valid cache */\n\n/*\n * MS-DOS file system inode data in memory\n */\nstruct msdos_inode_info {\n\tspinlock_t cache_lru_lock;\n\tstruct list_head cache_lru;\n\tint nr_caches;\n\t/* for avoiding the race between fat_free() and fat_get_cluster() */\n\tunsigned int cache_valid_id;\n\n\t/* NOTE: mmu_private is 64bits, so must hold ->i_mutex to access */\n\tloff_t mmu_private;\t/* physically allocated size */\n\n\tint i_start;\t\t/* first cluster or 0 */\n\tint i_logstart;\t\t/* logical first cluster */\n\tint i_attrs;\t\t/* unused attribute bits */\n\tloff_t i_pos;\t\t/* on-disk position of directory entry or 0 */\n\tstruct hlist_node i_fat_hash;\t/* hash by i_location */\n\tstruct hlist_node i_dir_hash;\t/* hash by i_logstart */\n\tstruct rw_semaphore truncate_lock; /* protect bmap against truncate */\n\tstruct inode vfs_inode;\n};\n\nstruct fat_slot_info {\n\tloff_t i_pos;\t\t/* on-disk position of directory entry */\n\tloff_t slot_off;\t/* offset for slot or de start */\n\tint nr_slots;\t\t/* number of slots + 1(de) in filename */\n\tstruct msdos_dir_entry *de;\n\tstruct buffer_head *bh;\n};\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\n/*\n * Functions that determine the variant of the FAT file system (i.e.,\n * whether this is FAT12, FAT16 or FAT32.\n */\nstatic inline bool is_fat12(const struct msdos_sb_info *sbi)\n{\n\treturn sbi->fat_bits == 12;\n}\n\nstatic inline bool is_fat16(const struct msdos_sb_info *sbi)\n{\n\treturn sbi->fat_bits == 16;\n}\n\nstatic inline bool is_fat32(const struct msdos_sb_info *sbi)\n{\n\treturn sbi->fat_bits == 32;\n}\n\n/* Maximum number of clusters */\nstatic inline u32 max_fat(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\treturn is_fat32(sbi) ? MAX_FAT32 :\n\t\tis_fat16(sbi) ? MAX_FAT16 : MAX_FAT12;\n}\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}\n\n/*\n * If ->i_mode can't hold S_IWUGO (i.e. ATTR_RO), we use ->i_attrs to\n * save ATTR_RO instead of ->i_mode.\n *\n * If it's directory and !sbi->options.rodir, ATTR_RO isn't read-only\n * bit, it's just used as flag for app.\n */\nstatic inline int fat_mode_can_hold_ro(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tumode_t mask;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (!sbi->options.rodir)\n\t\t\treturn 0;\n\t\tmask = ~sbi->options.fs_dmask;\n\t} else\n\t\tmask = ~sbi->options.fs_fmask;\n\n\tif (!(mask & S_IWUGO))\n\t\treturn 0;\n\treturn 1;\n}\n\n/* Convert attribute bits and a mask to the UNIX mode. */\nstatic inline umode_t fat_make_mode(struct msdos_sb_info *sbi,\n\t\t\t\t   u8 attrs, umode_t mode)\n{\n\tif (attrs & ATTR_RO && !((attrs & ATTR_DIR) && !sbi->options.rodir))\n\t\tmode &= ~S_IWUGO;\n\n\tif (attrs & ATTR_DIR)\n\t\treturn (mode & ~sbi->options.fs_dmask) | S_IFDIR;\n\telse\n\t\treturn (mode & ~sbi->options.fs_fmask) | S_IFREG;\n}\n\n/* Return the FAT attribute byte for this inode */\nstatic inline u8 fat_make_attrs(struct inode *inode)\n{\n\tu8 attrs = MSDOS_I(inode)->i_attrs;\n\tif (S_ISDIR(inode->i_mode))\n\t\tattrs |= ATTR_DIR;\n\tif (fat_mode_can_hold_ro(inode) && !(inode->i_mode & S_IWUGO))\n\t\tattrs |= ATTR_RO;\n\treturn attrs;\n}\n\nstatic inline void fat_save_attrs(struct inode *inode, u8 attrs)\n{\n\tif (fat_mode_can_hold_ro(inode))\n\t\tMSDOS_I(inode)->i_attrs = attrs & ATTR_UNUSED;\n\telse\n\t\tMSDOS_I(inode)->i_attrs = attrs & (ATTR_UNUSED | ATTR_RO);\n}\n\nstatic inline unsigned char fat_checksum(const __u8 *name)\n{\n\tunsigned char s = name[0];\n\ts = (s<<7) + (s>>1) + name[1];\ts = (s<<7) + (s>>1) + name[2];\n\ts = (s<<7) + (s>>1) + name[3];\ts = (s<<7) + (s>>1) + name[4];\n\ts = (s<<7) + (s>>1) + name[5];\ts = (s<<7) + (s>>1) + name[6];\n\ts = (s<<7) + (s>>1) + name[7];\ts = (s<<7) + (s>>1) + name[8];\n\ts = (s<<7) + (s>>1) + name[9];\ts = (s<<7) + (s>>1) + name[10];\n\treturn s;\n}\n\nstatic inline sector_t fat_clus_to_blknr(struct msdos_sb_info *sbi, int clus)\n{\n\treturn ((sector_t)clus - FAT_START_ENT) * sbi->sec_per_clus\n\t\t+ sbi->data_start;\n}\n\nstatic inline void fat_get_blknr_offset(struct msdos_sb_info *sbi,\n\t\t\t\tloff_t i_pos, sector_t *blknr, int *offset)\n{\n\t*blknr = i_pos >> sbi->dir_per_block_bits;\n\t*offset = i_pos & (sbi->dir_per_block - 1);\n}\n\nstatic inline loff_t fat_i_pos_read(struct msdos_sb_info *sbi,\n\t\t\t\t\tstruct inode *inode)\n{\n\tloff_t i_pos;\n#if BITS_PER_LONG == 32\n\tspin_lock(&sbi->inode_hash_lock);\n#endif\n\ti_pos = MSDOS_I(inode)->i_pos;\n#if BITS_PER_LONG == 32\n\tspin_unlock(&sbi->inode_hash_lock);\n#endif\n\treturn i_pos;\n}\n\nstatic inline void fat16_towchar(wchar_t *dst, const __u8 *src, size_t len)\n{\n#ifdef __BIG_ENDIAN\n\twhile (len--) {\n\t\t*dst++ = src[0] | (src[1] << 8);\n\t\tsrc += 2;\n\t}\n#else\n\tmemcpy(dst, src, len * 2);\n#endif\n}\n\nstatic inline int fat_get_start(const struct msdos_sb_info *sbi,\n\t\t\t\tconst struct msdos_dir_entry *de)\n{\n\tint cluster = le16_to_cpu(de->start);\n\tif (is_fat32(sbi))\n\t\tcluster |= (le16_to_cpu(de->starthi) << 16);\n\treturn cluster;\n}\n\nstatic inline void fat_set_start(struct msdos_dir_entry *de, int cluster)\n{\n\tde->start   = cpu_to_le16(cluster);\n\tde->starthi = cpu_to_le16(cluster >> 16);\n}\n\nstatic inline void fatwchar_to16(__u8 *dst, const wchar_t *src, size_t len)\n{\n#ifdef __BIG_ENDIAN\n\twhile (len--) {\n\t\tdst[0] = *src & 0x00FF;\n\t\tdst[1] = (*src & 0xFF00) >> 8;\n\t\tdst += 2;\n\t\tsrc++;\n\t}\n#else\n\tmemcpy(dst, src, len * 2);\n#endif\n}\n\n/* fat/cache.c */\nextern void fat_cache_inval_inode(struct inode *inode);\nextern int fat_get_cluster(struct inode *inode, int cluster,\n\t\t\t   int *fclus, int *dclus);\nextern int fat_get_mapped_cluster(struct inode *inode, sector_t sector,\n\t\t\t\t  sector_t last_block,\n\t\t\t\t  unsigned long *mapped_blocks, sector_t *bmap);\nextern int fat_bmap(struct inode *inode, sector_t sector, sector_t *phys,\n\t\t    unsigned long *mapped_blocks, int create, bool from_bmap);\n\n/* fat/dir.c */\nextern const struct file_operations fat_dir_operations;\nextern int fat_search_long(struct inode *inode, const unsigned char *name,\n\t\t\t   int name_len, struct fat_slot_info *sinfo);\nextern int fat_dir_empty(struct inode *dir);\nextern int fat_subdirs(struct inode *dir);\nextern int fat_scan(struct inode *dir, const unsigned char *name,\n\t\t    struct fat_slot_info *sinfo);\nextern int fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t\t     struct fat_slot_info *sinfo);\nextern int fat_get_dotdot_entry(struct inode *dir, struct buffer_head **bh,\n\t\t\t\tstruct msdos_dir_entry **de);\nextern int fat_alloc_new_dir(struct inode *dir, struct timespec64 *ts);\nextern int fat_add_entries(struct inode *dir, void *slots, int nr_slots,\n\t\t\t   struct fat_slot_info *sinfo);\nextern int fat_remove_entries(struct inode *dir, struct fat_slot_info *sinfo);\n\n/* fat/fatent.c */\nstruct fat_entry {\n\tint entry;\n\tunion {\n\t\tu8 *ent12_p[2];\n\t\t__le16 *ent16_p;\n\t\t__le32 *ent32_p;\n\t} u;\n\tint nr_bhs;\n\tstruct buffer_head *bhs[2];\n\tstruct inode *fat_inode;\n};\n\nstatic inline void fatent_init(struct fat_entry *fatent)\n{\n\tfatent->nr_bhs = 0;\n\tfatent->entry = 0;\n\tfatent->u.ent32_p = NULL;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}\n\nstatic inline void fatent_set_entry(struct fat_entry *fatent, int entry)\n{\n\tfatent->entry = entry;\n\tfatent->u.ent32_p = NULL;\n}\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}\n\nstatic inline bool fat_valid_entry(struct msdos_sb_info *sbi, int entry)\n{\n\treturn FAT_START_ENT <= entry && entry < sbi->max_cluster;\n}\n\nextern void fat_ent_access_init(struct super_block *sb);\nextern int fat_ent_read(struct inode *inode, struct fat_entry *fatent,\n\t\t\tint entry);\nextern int fat_ent_write(struct inode *inode, struct fat_entry *fatent,\n\t\t\t int new, int wait);\nextern int fat_alloc_clusters(struct inode *inode, int *cluster,\n\t\t\t      int nr_cluster);\nextern int fat_free_clusters(struct inode *inode, int cluster);\nextern int fat_count_free_clusters(struct super_block *sb);\nextern int fat_trim_fs(struct inode *inode, struct fstrim_range *range);\n\n/* fat/file.c */\nextern long fat_generic_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t      unsigned long arg);\nextern const struct file_operations fat_file_operations;\nextern const struct inode_operations fat_file_inode_operations;\nextern int fat_setattr(struct user_namespace *mnt_userns, struct dentry *dentry,\n\t\t       struct iattr *attr);\nextern void fat_truncate_blocks(struct inode *inode, loff_t offset);\nextern int fat_getattr(struct user_namespace *mnt_userns,\n\t\t       const struct path *path, struct kstat *stat,\n\t\t       u32 request_mask, unsigned int flags);\nextern int fat_file_fsync(struct file *file, loff_t start, loff_t end,\n\t\t\t  int datasync);\n\n/* fat/inode.c */\nextern int fat_block_truncate_page(struct inode *inode, loff_t from);\nextern void fat_attach(struct inode *inode, loff_t i_pos);\nextern void fat_detach(struct inode *inode);\nextern struct inode *fat_iget(struct super_block *sb, loff_t i_pos);\nextern struct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos);\nextern int fat_sync_inode(struct inode *inode);\nextern int fat_fill_super(struct super_block *sb, void *data, int silent,\n\t\t\t  int isvfat, void (*setup)(struct super_block *));\nextern int fat_fill_inode(struct inode *inode, struct msdos_dir_entry *de);\n\nextern int fat_flush_inodes(struct super_block *sb, struct inode *i1,\n\t\t\t    struct inode *i2);\nstatic inline unsigned long fat_dir_hash(int logstart)\n{\n\treturn hash_32(logstart, FAT_HASH_BITS);\n}\nextern int fat_add_cluster(struct inode *inode);\n\n/* fat/misc.c */\nextern __printf(3, 4) __cold\nvoid __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...);\n#define fat_fs_error(sb, fmt, args...)\t\t\\\n\t__fat_fs_error(sb, 1, fmt , ## args)\n#define fat_fs_error_ratelimit(sb, fmt, args...) \\\n\t__fat_fs_error(sb, __ratelimit(&MSDOS_SB(sb)->ratelimit), fmt , ## args)\n__printf(3, 4) __cold\nvoid fat_msg(struct super_block *sb, const char *level, const char *fmt, ...);\n#define fat_msg_ratelimit(sb, level, fmt, args...)\t\\\n\tdo {\t\\\n\t\t\tif (__ratelimit(&MSDOS_SB(sb)->ratelimit))\t\\\n\t\t\t\tfat_msg(sb, level, fmt, ## args);\t\\\n\t } while (0)\nextern int fat_clusters_flush(struct super_block *sb);\nextern int fat_chain_add(struct inode *inode, int new_dclus, int nr_cluster);\nextern void fat_time_fat2unix(struct msdos_sb_info *sbi, struct timespec64 *ts,\n\t\t\t      __le16 __time, __le16 __date, u8 time_cs);\nextern void fat_time_unix2fat(struct msdos_sb_info *sbi, struct timespec64 *ts,\n\t\t\t      __le16 *time, __le16 *date, u8 *time_cs);\nextern int fat_truncate_time(struct inode *inode, struct timespec64 *now,\n\t\t\t     int flags);\nextern int fat_update_time(struct inode *inode, struct timespec64 *now,\n\t\t\t   int flags);\nextern int fat_sync_bhs(struct buffer_head **bhs, int nr_bhs);\n\nint fat_cache_init(void);\nvoid fat_cache_destroy(void);\n\n/* fat/nfs.c */\nextern const struct export_operations fat_export_ops;\nextern const struct export_operations fat_export_ops_nostale;\n\n/* helper for printk */\ntypedef unsigned long long\tllu;\n\n#endif /* !_FAT_H */\n"}, "0": {"id": 0, "path": "/src/fs/fat/namei_vfat.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  linux/fs/vfat/namei.c\n *\n *  Written 1992,1993 by Werner Almesberger\n *\n *  Windows95/Windows NT compatible extended MSDOS filesystem\n *    by Gordon Chaffee Copyright (C) 1995.  Send bug reports for the\n *    VFAT filesystem to <chaffee@cs.berkeley.edu>.  Specify\n *    what file operation caused you trouble and if you can duplicate\n *    the problem, send a script that demonstrates it.\n *\n *  Short name translation 1999, 2001 by Wolfram Pienkoss <wp@bszh.de>\n *\n *  Support Multibyte characters and cleanup by\n *\t\t\t\tOGAWA Hirofumi <hirofumi@mail.parknet.co.jp>\n */\n\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/iversion.h>\n#include \"fat.h\"\n\nstatic inline unsigned long vfat_d_version(struct dentry *dentry)\n{\n\treturn (unsigned long) dentry->d_fsdata;\n}\n\nstatic inline void vfat_d_version_set(struct dentry *dentry,\n\t\t\t\t      unsigned long version)\n{\n\tdentry->d_fsdata = (void *) version;\n}\n\n/*\n * If new entry was created in the parent, it could create the 8.3\n * alias (the shortname of logname).  So, the parent may have the\n * negative-dentry which matches the created 8.3 alias.\n *\n * If it happened, the negative dentry isn't actually negative\n * anymore.  So, drop it.\n */\nstatic int vfat_revalidate_shortname(struct dentry *dentry)\n{\n\tint ret = 1;\n\tspin_lock(&dentry->d_lock);\n\tif (!inode_eq_iversion(d_inode(dentry->d_parent), vfat_d_version(dentry)))\n\t\tret = 0;\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}\n\nstatic int vfat_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\t/* This is not negative dentry. Always valid. */\n\tif (d_really_is_positive(dentry))\n\t\treturn 1;\n\treturn vfat_revalidate_shortname(dentry);\n}\n\nstatic int vfat_revalidate_ci(struct dentry *dentry, unsigned int flags)\n{\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\t/*\n\t * This is not negative dentry. Always valid.\n\t *\n\t * Note, rename() to existing directory entry will have ->d_inode,\n\t * and will use existing name which isn't specified name by user.\n\t *\n\t * We may be able to drop this positive dentry here. But dropping\n\t * positive dentry isn't good idea. So it's unsupported like\n\t * rename(\"filename\", \"FILENAME\") for now.\n\t */\n\tif (d_really_is_positive(dentry))\n\t\treturn 1;\n\n\t/*\n\t * This may be nfsd (or something), anyway, we can't see the\n\t * intent of this. So, since this can be for creation, drop it.\n\t */\n\tif (!flags)\n\t\treturn 0;\n\n\t/*\n\t * Drop the negative dentry, in order to make sure to use the\n\t * case sensitive name which is specified by user if this is\n\t * for creation.\n\t */\n\tif (flags & (LOOKUP_CREATE | LOOKUP_RENAME_TARGET))\n\t\treturn 0;\n\n\treturn vfat_revalidate_shortname(dentry);\n}\n\n/* returns the length of a struct qstr, ignoring trailing dots */\nstatic unsigned int __vfat_striptail_len(unsigned int len, const char *name)\n{\n\twhile (len && name[len - 1] == '.')\n\t\tlen--;\n\treturn len;\n}\n\nstatic unsigned int vfat_striptail_len(const struct qstr *qstr)\n{\n\treturn __vfat_striptail_len(qstr->len, qstr->name);\n}\n\n/*\n * Compute the hash for the vfat name corresponding to the dentry.\n * Note: if the name is invalid, we leave the hash code unchanged so\n * that the existing dentry can be used. The vfat fs routines will\n * return ENOENT or EINVAL as appropriate.\n */\nstatic int vfat_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\tqstr->hash = full_name_hash(dentry, qstr->name, vfat_striptail_len(qstr));\n\treturn 0;\n}\n\n/*\n * Compute the hash for the vfat name corresponding to the dentry.\n * Note: if the name is invalid, we leave the hash code unchanged so\n * that the existing dentry can be used. The vfat fs routines will\n * return ENOENT or EINVAL as appropriate.\n */\nstatic int vfat_hashi(const struct dentry *dentry, struct qstr *qstr)\n{\n\tstruct nls_table *t = MSDOS_SB(dentry->d_sb)->nls_io;\n\tconst unsigned char *name;\n\tunsigned int len;\n\tunsigned long hash;\n\n\tname = qstr->name;\n\tlen = vfat_striptail_len(qstr);\n\n\thash = init_name_hash(dentry);\n\twhile (len--)\n\t\thash = partial_name_hash(nls_tolower(t, *name++), hash);\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}\n\n/*\n * Case insensitive compare of two vfat names.\n */\nstatic int vfat_cmpi(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct nls_table *t = MSDOS_SB(dentry->d_sb)->nls_io;\n\tunsigned int alen, blen;\n\n\t/* A filename cannot end in '.' or we treat it like it has none */\n\talen = vfat_striptail_len(name);\n\tblen = __vfat_striptail_len(len, str);\n\tif (alen == blen) {\n\t\tif (nls_strnicmp(t, name->name, str, alen) == 0)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/*\n * Case sensitive compare of two vfat names.\n */\nstatic int vfat_cmp(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tunsigned int alen, blen;\n\n\t/* A filename cannot end in '.' or we treat it like it has none */\n\talen = vfat_striptail_len(name);\n\tblen = __vfat_striptail_len(len, str);\n\tif (alen == blen) {\n\t\tif (strncmp(name->name, str, alen) == 0)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic const struct dentry_operations vfat_ci_dentry_ops = {\n\t.d_revalidate\t= vfat_revalidate_ci,\n\t.d_hash\t\t= vfat_hashi,\n\t.d_compare\t= vfat_cmpi,\n};\n\nstatic const struct dentry_operations vfat_dentry_ops = {\n\t.d_revalidate\t= vfat_revalidate,\n\t.d_hash\t\t= vfat_hash,\n\t.d_compare\t= vfat_cmp,\n};\n\n/* Characters that are undesirable in an MS-DOS file name */\n\nstatic inline wchar_t vfat_bad_char(wchar_t w)\n{\n\treturn (w < 0x0020)\n\t    || (w == '*') || (w == '?') || (w == '<') || (w == '>')\n\t    || (w == '|') || (w == '\"') || (w == ':') || (w == '/')\n\t    || (w == '\\\\');\n}\n\nstatic inline wchar_t vfat_replace_char(wchar_t w)\n{\n\treturn (w == '[') || (w == ']') || (w == ';') || (w == ',')\n\t    || (w == '+') || (w == '=');\n}\n\nstatic wchar_t vfat_skip_char(wchar_t w)\n{\n\treturn (w == '.') || (w == ' ');\n}\n\nstatic inline int vfat_is_used_badchars(const wchar_t *s, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (vfat_bad_char(s[i]))\n\t\t\treturn -EINVAL;\n\n\tif (s[i - 1] == ' ') /* last character cannot be space */\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int vfat_find_form(struct inode *dir, unsigned char *name)\n{\n\tstruct fat_slot_info sinfo;\n\tint err = fat_scan(dir, name, &sinfo);\n\tif (err)\n\t\treturn -ENOENT;\n\tbrelse(sinfo.bh);\n\treturn 0;\n}\n\n/*\n * 1) Valid characters for the 8.3 format alias are any combination of\n * letters, uppercase alphabets, digits, any of the\n * following special characters:\n *     $ % ' ` - @ { } ~ ! # ( ) & _ ^\n * In this case Longfilename is not stored in disk.\n *\n * WinNT's Extension:\n * File name and extension name is contain uppercase/lowercase\n * only. And it is expressed by CASE_LOWER_BASE and CASE_LOWER_EXT.\n *\n * 2) File name is 8.3 format, but it contain the uppercase and\n * lowercase char, muliti bytes char, etc. In this case numtail is not\n * added, but Longfilename is stored.\n *\n * 3) When the one except for the above, or the following special\n * character are contained:\n *        .   [ ] ; , + =\n * numtail is added, and Longfilename must be stored in disk .\n */\nstruct shortname_info {\n\tunsigned char lower:1,\n\t\t      upper:1,\n\t\t      valid:1;\n};\n#define INIT_SHORTNAME_INFO(x)\tdo {\t\t\\\n\t(x)->lower = 1;\t\t\t\t\\\n\t(x)->upper = 1;\t\t\t\t\\\n\t(x)->valid = 1;\t\t\t\t\\\n} while (0)\n\nstatic inline int to_shortname_char(struct nls_table *nls,\n\t\t\t\t    unsigned char *buf, int buf_size,\n\t\t\t\t    wchar_t *src, struct shortname_info *info)\n{\n\tint len;\n\n\tif (vfat_skip_char(*src)) {\n\t\tinfo->valid = 0;\n\t\treturn 0;\n\t}\n\tif (vfat_replace_char(*src)) {\n\t\tinfo->valid = 0;\n\t\tbuf[0] = '_';\n\t\treturn 1;\n\t}\n\n\tlen = nls->uni2char(*src, buf, buf_size);\n\tif (len <= 0) {\n\t\tinfo->valid = 0;\n\t\tbuf[0] = '_';\n\t\tlen = 1;\n\t} else if (len == 1) {\n\t\tunsigned char prev = buf[0];\n\n\t\tif (buf[0] >= 0x7F) {\n\t\t\tinfo->lower = 0;\n\t\t\tinfo->upper = 0;\n\t\t}\n\n\t\tbuf[0] = nls_toupper(nls, buf[0]);\n\t\tif (isalpha(buf[0])) {\n\t\t\tif (buf[0] == prev)\n\t\t\t\tinfo->lower = 0;\n\t\t\telse\n\t\t\t\tinfo->upper = 0;\n\t\t}\n\t} else {\n\t\tinfo->lower = 0;\n\t\tinfo->upper = 0;\n\t}\n\n\treturn len;\n}\n\n/*\n * Given a valid longname, create a unique shortname.  Make sure the\n * shortname does not exist\n * Returns negative number on error, 0 for a normal\n * return, and 1 for valid shortname\n */\nstatic int vfat_create_shortname(struct inode *dir, struct nls_table *nls,\n\t\t\t\t wchar_t *uname, int ulen,\n\t\t\t\t unsigned char *name_res, unsigned char *lcase)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(dir->i_sb)->options;\n\twchar_t *ip, *ext_start, *end, *name_start;\n\tunsigned char base[9], ext[4], buf[5], *p;\n\tunsigned char charbuf[NLS_MAX_CHARSET_SIZE];\n\tint chl, chi;\n\tint sz = 0, extlen, baselen, i, numtail_baselen, numtail2_baselen;\n\tint is_shortname;\n\tstruct shortname_info base_info, ext_info;\n\n\tis_shortname = 1;\n\tINIT_SHORTNAME_INFO(&base_info);\n\tINIT_SHORTNAME_INFO(&ext_info);\n\n\t/* Now, we need to create a shortname from the long name */\n\text_start = end = &uname[ulen];\n\twhile (--ext_start >= uname) {\n\t\tif (*ext_start == 0x002E) {\t/* is `.' */\n\t\t\tif (ext_start == end - 1) {\n\t\t\t\tsz = ulen;\n\t\t\t\text_start = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ext_start == uname - 1) {\n\t\tsz = ulen;\n\t\text_start = NULL;\n\t} else if (ext_start) {\n\t\t/*\n\t\t * Names which start with a dot could be just\n\t\t * an extension eg. \"...test\".  In this case Win95\n\t\t * uses the extension as the name and sets no extension.\n\t\t */\n\t\tname_start = &uname[0];\n\t\twhile (name_start < ext_start) {\n\t\t\tif (!vfat_skip_char(*name_start))\n\t\t\t\tbreak;\n\t\t\tname_start++;\n\t\t}\n\t\tif (name_start != ext_start) {\n\t\t\tsz = ext_start - uname;\n\t\t\text_start++;\n\t\t} else {\n\t\t\tsz = ulen;\n\t\t\text_start = NULL;\n\t\t}\n\t}\n\n\tnumtail_baselen = 6;\n\tnumtail2_baselen = 2;\n\tfor (baselen = i = 0, p = base, ip = uname; i < sz; i++, ip++) {\n\t\tchl = to_shortname_char(nls, charbuf, sizeof(charbuf),\n\t\t\t\t\tip, &base_info);\n\t\tif (chl == 0)\n\t\t\tcontinue;\n\n\t\tif (baselen < 2 && (baselen + chl) > 2)\n\t\t\tnumtail2_baselen = baselen;\n\t\tif (baselen < 6 && (baselen + chl) > 6)\n\t\t\tnumtail_baselen = baselen;\n\t\tfor (chi = 0; chi < chl; chi++) {\n\t\t\t*p++ = charbuf[chi];\n\t\t\tbaselen++;\n\t\t\tif (baselen >= 8)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (baselen >= 8) {\n\t\t\tif ((chi < chl - 1) || (ip + 1) - uname < sz)\n\t\t\t\tis_shortname = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (baselen == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\textlen = 0;\n\tif (ext_start) {\n\t\tfor (p = ext, ip = ext_start; extlen < 3 && ip < end; ip++) {\n\t\t\tchl = to_shortname_char(nls, charbuf, sizeof(charbuf),\n\t\t\t\t\t\tip, &ext_info);\n\t\t\tif (chl == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif ((extlen + chl) > 3) {\n\t\t\t\tis_shortname = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (chi = 0; chi < chl; chi++) {\n\t\t\t\t*p++ = charbuf[chi];\n\t\t\t\textlen++;\n\t\t\t}\n\t\t\tif (extlen >= 3) {\n\t\t\t\tif (ip + 1 != end)\n\t\t\t\t\tis_shortname = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\text[extlen] = '\\0';\n\tbase[baselen] = '\\0';\n\n\t/* Yes, it can happen. \".\\xe5\" would do it. */\n\tif (base[0] == DELETED_FLAG)\n\t\tbase[0] = 0x05;\n\n\t/* OK, at this point we know that base is not longer than 8 symbols,\n\t * ext is not longer than 3, base is nonempty, both don't contain\n\t * any bad symbols (lowercase transformed to uppercase).\n\t */\n\n\tmemset(name_res, ' ', MSDOS_NAME);\n\tmemcpy(name_res, base, baselen);\n\tmemcpy(name_res + 8, ext, extlen);\n\t*lcase = 0;\n\tif (is_shortname && base_info.valid && ext_info.valid) {\n\t\tif (vfat_find_form(dir, name_res) == 0)\n\t\t\treturn -EEXIST;\n\n\t\tif (opts->shortname & VFAT_SFN_CREATE_WIN95) {\n\t\t\treturn (base_info.upper && ext_info.upper);\n\t\t} else if (opts->shortname & VFAT_SFN_CREATE_WINNT) {\n\t\t\tif ((base_info.upper || base_info.lower) &&\n\t\t\t    (ext_info.upper || ext_info.lower)) {\n\t\t\t\tif (!base_info.upper && base_info.lower)\n\t\t\t\t\t*lcase |= CASE_LOWER_BASE;\n\t\t\t\tif (!ext_info.upper && ext_info.lower)\n\t\t\t\t\t*lcase |= CASE_LOWER_EXT;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\tif (opts->numtail == 0)\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\treturn 0;\n\n\t/*\n\t * Try to find a unique extension.  This used to\n\t * iterate through all possibilities sequentially,\n\t * but that gave extremely bad performance.  Windows\n\t * only tries a few cases before using random\n\t * values for part of the base.\n\t */\n\n\tif (baselen > 6) {\n\t\tbaselen = numtail_baselen;\n\t\tname_res[7] = ' ';\n\t}\n\tname_res[baselen] = '~';\n\tfor (i = 1; i < 10; i++) {\n\t\tname_res[baselen + 1] = i + '0';\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\treturn 0;\n\t}\n\n\ti = jiffies;\n\tsz = (jiffies >> 16) & 0x7;\n\tif (baselen > 2) {\n\t\tbaselen = numtail2_baselen;\n\t\tname_res[7] = ' ';\n\t}\n\tname_res[baselen + 4] = '~';\n\tname_res[baselen + 5] = '1' + sz;\n\twhile (1) {\n\t\tsnprintf(buf, sizeof(buf), \"%04X\", i & 0xffff);\n\t\tmemcpy(&name_res[baselen], buf, 4);\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\tbreak;\n\t\ti -= 11;\n\t}\n\treturn 0;\n}\n\n/* Translate a string, including coded sequences into Unicode */\nstatic int\nxlate_to_uni(const unsigned char *name, int len, unsigned char *outname,\n\t     int *longlen, int *outlen, int escape, int utf8,\n\t     struct nls_table *nls)\n{\n\tconst unsigned char *ip;\n\tunsigned char *op;\n\tint i, fill;\n\tint charlen;\n\n\tif (utf8) {\n\t\t*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *) outname, FAT_LFN_LEN + 2);\n\t\tif (*outlen < 0)\n\t\t\treturn *outlen;\n\t\telse if (*outlen > FAT_LFN_LEN)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\top = &outname[*outlen * sizeof(wchar_t)];\n\t} else {\n\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t i < len && *outlen < FAT_LFN_LEN;\n\t\t\t *outlen += 1) {\n\t\t\tif (escape && (*ip == ':')) {\n\t\t\t\tu8 uc[2];\n\n\t\t\t\tif (i > len - 5)\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\tif (hex2bin(uc, ip + 1, 2) < 0)\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\t*(wchar_t *)op = uc[0] << 8 | uc[1];\n\n\t\t\t\top += 2;\n\t\t\t\tip += 5;\n\t\t\t\ti += 5;\n\t\t\t} else {\n\t\t\t\tcharlen = nls->char2uni(ip, len - i,\n\t\t\t\t\t\t\t(wchar_t *)op);\n\t\t\t\tif (charlen < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tip += charlen;\n\t\t\t\ti += charlen;\n\t\t\t\top += 2;\n\t\t\t}\n\t\t}\n\t\tif (i < len)\n\t\t\treturn -ENAMETOOLONG;\n\t}\n\n\t*longlen = *outlen;\n\tif (*outlen % 13) {\n\t\t*op++ = 0;\n\t\t*op++ = 0;\n\t\t*outlen += 1;\n\t\tif (*outlen % 13) {\n\t\t\tfill = 13 - (*outlen % 13);\n\t\t\tfor (i = 0; i < fill; i++) {\n\t\t\t\t*op++ = 0xff;\n\t\t\t\t*op++ = 0xff;\n\t\t\t}\n\t\t\t*outlen += fill;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vfat_build_slots(struct inode *dir, const unsigned char *name,\n\t\t\t    int len, int is_dir, int cluster,\n\t\t\t    struct timespec64 *ts,\n\t\t\t    struct msdos_dir_slot *slots, int *nr_slots)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tstruct fat_mount_options *opts = &sbi->options;\n\tstruct msdos_dir_slot *ps;\n\tstruct msdos_dir_entry *de;\n\tunsigned char cksum, lcase;\n\tunsigned char msdos_name[MSDOS_NAME];\n\twchar_t *uname;\n\t__le16 time, date;\n\tu8 time_cs;\n\tint err, ulen, usize, i;\n\tloff_t offset;\n\n\t*nr_slots = 0;\n\n\tuname = __getname();\n\tif (!uname)\n\t\treturn -ENOMEM;\n\n\terr = xlate_to_uni(name, len, (unsigned char *)uname, &ulen, &usize,\n\t\t\t   opts->unicode_xlate, opts->utf8, sbi->nls_io);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = vfat_is_used_badchars(uname, ulen);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = vfat_create_shortname(dir, sbi->nls_disk, uname, ulen,\n\t\t\t\t    msdos_name, &lcase);\n\tif (err < 0)\n\t\tgoto out_free;\n\telse if (err == 1) {\n\t\tde = (struct msdos_dir_entry *)slots;\n\t\terr = 0;\n\t\tgoto shortname;\n\t}\n\n\t/* build the entry of long file name */\n\tcksum = fat_checksum(msdos_name);\n\n\t*nr_slots = usize / 13;\n\tfor (ps = slots, i = *nr_slots; i > 0; i--, ps++) {\n\t\tps->id = i;\n\t\tps->attr = ATTR_EXT;\n\t\tps->reserved = 0;\n\t\tps->alias_checksum = cksum;\n\t\tps->start = 0;\n\t\toffset = (i - 1) * 13;\n\t\tfatwchar_to16(ps->name0_4, uname + offset, 5);\n\t\tfatwchar_to16(ps->name5_10, uname + offset + 5, 6);\n\t\tfatwchar_to16(ps->name11_12, uname + offset + 11, 2);\n\t}\n\tslots[0].id |= 0x40;\n\tde = (struct msdos_dir_entry *)ps;\n\nshortname:\n\t/* build the entry of 8.3 alias name */\n\t(*nr_slots)++;\n\tmemcpy(de->name, msdos_name, MSDOS_NAME);\n\tde->attr = is_dir ? ATTR_DIR : ATTR_ARCH;\n\tde->lcase = lcase;\n\tfat_time_unix2fat(sbi, ts, &time, &date, &time_cs);\n\tde->time = de->ctime = time;\n\tde->date = de->cdate = de->adate = date;\n\tde->ctime_cs = time_cs;\n\tfat_set_start(de, cluster);\n\tde->size = 0;\nout_free:\n\t__putname(uname);\n\treturn err;\n}\n\nstatic int vfat_add_entry(struct inode *dir, const struct qstr *qname,\n\t\t\t  int is_dir, int cluster, struct timespec64 *ts,\n\t\t\t  struct fat_slot_info *sinfo)\n{\n\tstruct msdos_dir_slot *slots;\n\tunsigned int len;\n\tint err, nr_slots;\n\n\tlen = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\n\tslots = kmalloc_array(MSDOS_SLOTS, sizeof(*slots), GFP_NOFS);\n\tif (slots == NULL)\n\t\treturn -ENOMEM;\n\n\terr = vfat_build_slots(dir, qname->name, len, is_dir, cluster, ts,\n\t\t\t       slots, &nr_slots);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = fat_add_entries(dir, slots, nr_slots, sinfo);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* update timestamp */\n\tfat_truncate_time(dir, ts, S_CTIME|S_MTIME);\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\ncleanup:\n\tkfree(slots);\n\treturn err;\n}\n\nstatic int vfat_find(struct inode *dir, const struct qstr *qname,\n\t\t     struct fat_slot_info *sinfo)\n{\n\tunsigned int len = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\treturn fat_search_long(dir, qname->name, len, sinfo);\n}\n\nstatic struct dentry *vfat_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tstruct inode *inode;\n\tstruct dentry *alias;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = vfat_find(dir, &dentry->d_name, &sinfo);\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\tinode = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto error;\n\t}\n\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto error;\n\t}\n\n\talias = d_find_alias(inode);\n\t/*\n\t * Checking \"alias->d_parent == dentry->d_parent\" to make sure\n\t * FS is not corrupted (especially double linked dir).\n\t */\n\tif (alias && alias->d_parent == dentry->d_parent) {\n\t\t/*\n\t\t * This inode has non anonymous-DCACHE_DISCONNECTED\n\t\t * dentry. This means, the user did ->lookup() by an\n\t\t * another name (longname vs 8.3 alias of it) in past.\n\t\t *\n\t\t * Switch to new one for reason of locality if possible.\n\t\t */\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\td_move(alias, dentry);\n\t\tiput(inode);\n\t\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\t\treturn alias;\n\t} else\n\t\tdput(alias);\n\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tif (!inode)\n\t\tvfat_d_version_set(dentry, inode_query_iversion(dir));\n\treturn d_splice_alias(inode, dentry);\nerror:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn ERR_PTR(err);\n}\n\nstatic int vfat_create(struct user_namespace *mnt_userns, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\tstruct fat_slot_info sinfo;\n\tstruct timespec64 ts;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\tts = current_time(dir);\n\terr = vfat_add_entry(dir, &dentry->d_name, 0, 0, &ts, &sinfo);\n\tif (err)\n\t\tgoto out;\n\tinode_inc_iversion(dir);\n\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\tinode_inc_iversion(inode);\n\tfat_truncate_time(inode, &ts, S_ATIME|S_CTIME|S_MTIME);\n\t/* timestamp is already written, so mark_inode_dirty() is unneeded. */\n\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn err;\n}\n\nstatic int vfat_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = fat_dir_empty(inode);\n\tif (err)\n\t\tgoto out;\n\terr = vfat_find(dir, &dentry->d_name, &sinfo);\n\tif (err)\n\t\tgoto out;\n\n\terr = fat_remove_entries(dir, &sinfo);\t/* and releases bh */\n\tif (err)\n\t\tgoto out;\n\tdrop_nlink(dir);\n\n\tclear_nlink(inode);\n\tfat_truncate_time(inode, NULL, S_ATIME|S_MTIME);\n\tfat_detach(inode);\n\tvfat_d_version_set(dentry, inode_query_iversion(dir));\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\n\treturn err;\n}\n\nstatic int vfat_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = vfat_find(dir, &dentry->d_name, &sinfo);\n\tif (err)\n\t\tgoto out;\n\n\terr = fat_remove_entries(dir, &sinfo);\t/* and releases bh */\n\tif (err)\n\t\tgoto out;\n\tclear_nlink(inode);\n\tfat_truncate_time(inode, NULL, S_ATIME|S_MTIME);\n\tfat_detach(inode);\n\tvfat_d_version_set(dentry, inode_query_iversion(dir));\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\n\treturn err;\n}\n\nstatic int vfat_mkdir(struct user_namespace *mnt_userns, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\tstruct fat_slot_info sinfo;\n\tstruct timespec64 ts;\n\tint err, cluster;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\tts = current_time(dir);\n\tcluster = fat_alloc_new_dir(dir, &ts);\n\tif (cluster < 0) {\n\t\terr = cluster;\n\t\tgoto out;\n\t}\n\terr = vfat_add_entry(dir, &dentry->d_name, 1, cluster, &ts, &sinfo);\n\tif (err)\n\t\tgoto out_free;\n\tinode_inc_iversion(dir);\n\tinc_nlink(dir);\n\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\t/* the directory was completed, just return a error */\n\t\tgoto out;\n\t}\n\tinode_inc_iversion(inode);\n\tset_nlink(inode, 2);\n\tfat_truncate_time(inode, &ts, S_ATIME|S_CTIME|S_MTIME);\n\t/* timestamp is already written, so mark_inode_dirty() is unneeded. */\n\n\td_instantiate(dentry, inode);\n\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn 0;\n\nout_free:\n\tfat_free_clusters(dir, cluster);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn err;\n}\n\nstatic int vfat_rename(struct user_namespace *mnt_userns, struct inode *old_dir,\n\t\t       struct dentry *old_dentry, struct inode *new_dir,\n\t\t       struct dentry *new_dentry, unsigned int flags)\n{\n\tstruct buffer_head *dotdot_bh;\n\tstruct msdos_dir_entry *dotdot_de;\n\tstruct inode *old_inode, *new_inode;\n\tstruct fat_slot_info old_sinfo, sinfo;\n\tstruct timespec64 ts;\n\tloff_t new_i_pos;\n\tint err, is_dir, update_dotdot, corrupt = 0;\n\tstruct super_block *sb = old_dir->i_sb;\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\told_sinfo.bh = sinfo.bh = dotdot_bh = NULL;\n\told_inode = d_inode(old_dentry);\n\tnew_inode = d_inode(new_dentry);\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\terr = vfat_find(old_dir, &old_dentry->d_name, &old_sinfo);\n\tif (err)\n\t\tgoto out;\n\n\tis_dir = S_ISDIR(old_inode->i_mode);\n\tupdate_dotdot = (is_dir && old_dir != new_dir);\n\tif (update_dotdot) {\n\t\tif (fat_get_dotdot_entry(old_inode, &dotdot_bh, &dotdot_de)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tts = current_time(old_dir);\n\tif (new_inode) {\n\t\tif (is_dir) {\n\t\t\terr = fat_dir_empty(new_inode);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tnew_i_pos = MSDOS_I(new_inode)->i_pos;\n\t\tfat_detach(new_inode);\n\t} else {\n\t\terr = vfat_add_entry(new_dir, &new_dentry->d_name, is_dir, 0,\n\t\t\t\t     &ts, &sinfo);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tnew_i_pos = sinfo.i_pos;\n\t}\n\tinode_inc_iversion(new_dir);\n\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, new_i_pos);\n\tif (IS_DIRSYNC(new_dir)) {\n\t\terr = fat_sync_inode(old_inode);\n\t\tif (err)\n\t\t\tgoto error_inode;\n\t} else\n\t\tmark_inode_dirty(old_inode);\n\n\tif (update_dotdot) {\n\t\tfat_set_start(dotdot_de, MSDOS_I(new_dir)->i_logstart);\n\t\tmark_buffer_dirty_inode(dotdot_bh, old_inode);\n\t\tif (IS_DIRSYNC(new_dir)) {\n\t\t\terr = sync_dirty_buffer(dotdot_bh);\n\t\t\tif (err)\n\t\t\t\tgoto error_dotdot;\n\t\t}\n\t\tdrop_nlink(old_dir);\n\t\tif (!new_inode)\n \t\t\tinc_nlink(new_dir);\n\t}\n\n\terr = fat_remove_entries(old_dir, &old_sinfo);\t/* and releases bh */\n\told_sinfo.bh = NULL;\n\tif (err)\n\t\tgoto error_dotdot;\n\tinode_inc_iversion(old_dir);\n\tfat_truncate_time(old_dir, &ts, S_CTIME|S_MTIME);\n\tif (IS_DIRSYNC(old_dir))\n\t\t(void)fat_sync_inode(old_dir);\n\telse\n\t\tmark_inode_dirty(old_dir);\n\n\tif (new_inode) {\n\t\tdrop_nlink(new_inode);\n\t\tif (is_dir)\n\t\t\tdrop_nlink(new_inode);\n\t\tfat_truncate_time(new_inode, &ts, S_CTIME);\n\t}\nout:\n\tbrelse(sinfo.bh);\n\tbrelse(dotdot_bh);\n\tbrelse(old_sinfo.bh);\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\n\treturn err;\n\nerror_dotdot:\n\t/* data cluster is shared, serious corruption */\n\tcorrupt = 1;\n\n\tif (update_dotdot) {\n\t\tfat_set_start(dotdot_de, MSDOS_I(old_dir)->i_logstart);\n\t\tmark_buffer_dirty_inode(dotdot_bh, old_inode);\n\t\tcorrupt |= sync_dirty_buffer(dotdot_bh);\n\t}\nerror_inode:\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, old_sinfo.i_pos);\n\tif (new_inode) {\n\t\tfat_attach(new_inode, new_i_pos);\n\t\tif (corrupt)\n\t\t\tcorrupt |= fat_sync_inode(new_inode);\n\t} else {\n\t\t/*\n\t\t * If new entry was not sharing the data cluster, it\n\t\t * shouldn't be serious corruption.\n\t\t */\n\t\tint err2 = fat_remove_entries(new_dir, &sinfo);\n\t\tif (corrupt)\n\t\t\tcorrupt |= err2;\n\t\tsinfo.bh = NULL;\n\t}\n\tif (corrupt < 0) {\n\t\tfat_fs_error(new_dir->i_sb,\n\t\t\t     \"%s: Filesystem corrupted (i_pos %lld)\",\n\t\t\t     __func__, sinfo.i_pos);\n\t}\n\tgoto out;\n}\n\nstatic const struct inode_operations vfat_dir_inode_operations = {\n\t.create\t\t= vfat_create,\n\t.lookup\t\t= vfat_lookup,\n\t.unlink\t\t= vfat_unlink,\n\t.mkdir\t\t= vfat_mkdir,\n\t.rmdir\t\t= vfat_rmdir,\n\t.rename\t\t= vfat_rename,\n\t.setattr\t= fat_setattr,\n\t.getattr\t= fat_getattr,\n\t.update_time\t= fat_update_time,\n};\n\nstatic void setup(struct super_block *sb)\n{\n\tMSDOS_SB(sb)->dir_ops = &vfat_dir_inode_operations;\n\tif (MSDOS_SB(sb)->options.name_check != 's')\n\t\tsb->s_d_op = &vfat_ci_dentry_ops;\n\telse\n\t\tsb->s_d_op = &vfat_dentry_ops;\n}\n\nstatic int vfat_fill_super(struct super_block *sb, void *data, int silent)\n{\n\treturn fat_fill_super(sb, data, silent, 1, setup);\n}\n\nstatic struct dentry *vfat_mount(struct file_system_type *fs_type,\n\t\t       int flags, const char *dev_name,\n\t\t       void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, vfat_fill_super);\n}\n\nstatic struct file_system_type vfat_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"vfat\",\n\t.mount\t\t= vfat_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV | FS_ALLOW_IDMAP,\n};\nMODULE_ALIAS_FS(\"vfat\");\n\nstatic int __init init_vfat_fs(void)\n{\n\treturn register_filesystem(&vfat_fs_type);\n}\n\nstatic void __exit exit_vfat_fs(void)\n{\n\tunregister_filesystem(&vfat_fs_type);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"VFAT filesystem support\");\nMODULE_AUTHOR(\"Gordon Chaffee\");\n\nmodule_init(init_vfat_fs)\nmodule_exit(exit_vfat_fs)\n"}, "2": {"id": 2, "path": "/src/include/uapi/linux/stat.h", "content": "/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef _UAPI_LINUX_STAT_H\n#define _UAPI_LINUX_STAT_H\n\n#include <linux/types.h>\n\n#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)\n\n#define S_IFMT  00170000\n#define S_IFSOCK 0140000\n#define S_IFLNK\t 0120000\n#define S_IFREG  0100000\n#define S_IFBLK  0060000\n#define S_IFDIR  0040000\n#define S_IFCHR  0020000\n#define S_IFIFO  0010000\n#define S_ISUID  0004000\n#define S_ISGID  0002000\n#define S_ISVTX  0001000\n\n#define S_ISLNK(m)\t(((m) & S_IFMT) == S_IFLNK)\n#define S_ISREG(m)\t(((m) & S_IFMT) == S_IFREG)\n#define S_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\n#define S_ISCHR(m)\t(((m) & S_IFMT) == S_IFCHR)\n#define S_ISBLK(m)\t(((m) & S_IFMT) == S_IFBLK)\n#define S_ISFIFO(m)\t(((m) & S_IFMT) == S_IFIFO)\n#define S_ISSOCK(m)\t(((m) & S_IFMT) == S_IFSOCK)\n\n#define S_IRWXU 00700\n#define S_IRUSR 00400\n#define S_IWUSR 00200\n#define S_IXUSR 00100\n\n#define S_IRWXG 00070\n#define S_IRGRP 00040\n#define S_IWGRP 00020\n#define S_IXGRP 00010\n\n#define S_IRWXO 00007\n#define S_IROTH 00004\n#define S_IWOTH 00002\n#define S_IXOTH 00001\n\n#endif\n\n/*\n * Timestamp structure for the timestamps in struct statx.\n *\n * tv_sec holds the number of seconds before (negative) or after (positive)\n * 00:00:00 1st January 1970 UTC.\n *\n * tv_nsec holds a number of nanoseconds (0..999,999,999) after the tv_sec time.\n *\n * __reserved is held in case we need a yet finer resolution.\n */\nstruct statx_timestamp {\n\t__s64\ttv_sec;\n\t__u32\ttv_nsec;\n\t__s32\t__reserved;\n};\n\n/*\n * Structures for the extended file attribute retrieval system call\n * (statx()).\n *\n * The caller passes a mask of what they're specifically interested in as a\n * parameter to statx().  What statx() actually got will be indicated in\n * st_mask upon return.\n *\n * For each bit in the mask argument:\n *\n * - if the datum is not supported:\n *\n *   - the bit will be cleared, and\n *\n *   - the datum will be set to an appropriate fabricated value if one is\n *     available (eg. CIFS can take a default uid and gid), otherwise\n *\n *   - the field will be cleared;\n *\n * - otherwise, if explicitly requested:\n *\n *   - the datum will be synchronised to the server if AT_STATX_FORCE_SYNC is\n *     set or if the datum is considered out of date, and\n *\n *   - the field will be filled in and the bit will be set;\n *\n * - otherwise, if not requested, but available in approximate form without any\n *   effort, it will be filled in anyway, and the bit will be set upon return\n *   (it might not be up to date, however, and no attempt will be made to\n *   synchronise the internal state first);\n *\n * - otherwise the field and the bit will be cleared before returning.\n *\n * Items in STATX_BASIC_STATS may be marked unavailable on return, but they\n * will have values installed for compatibility purposes so that stat() and\n * co. can be emulated in userspace.\n */\nstruct statx {\n\t/* 0x00 */\n\t__u32\tstx_mask;\t/* What results were written [uncond] */\n\t__u32\tstx_blksize;\t/* Preferred general I/O size [uncond] */\n\t__u64\tstx_attributes;\t/* Flags conveying information about the file [uncond] */\n\t/* 0x10 */\n\t__u32\tstx_nlink;\t/* Number of hard links */\n\t__u32\tstx_uid;\t/* User ID of owner */\n\t__u32\tstx_gid;\t/* Group ID of owner */\n\t__u16\tstx_mode;\t/* File mode */\n\t__u16\t__spare0[1];\n\t/* 0x20 */\n\t__u64\tstx_ino;\t/* Inode number */\n\t__u64\tstx_size;\t/* File size */\n\t__u64\tstx_blocks;\t/* Number of 512-byte blocks allocated */\n\t__u64\tstx_attributes_mask; /* Mask to show what's supported in stx_attributes */\n\t/* 0x40 */\n\tstruct statx_timestamp\tstx_atime;\t/* Last access time */\n\tstruct statx_timestamp\tstx_btime;\t/* File creation time */\n\tstruct statx_timestamp\tstx_ctime;\t/* Last attribute change time */\n\tstruct statx_timestamp\tstx_mtime;\t/* Last data modification time */\n\t/* 0x80 */\n\t__u32\tstx_rdev_major;\t/* Device ID of special file [if bdev/cdev] */\n\t__u32\tstx_rdev_minor;\n\t__u32\tstx_dev_major;\t/* ID of device containing file [uncond] */\n\t__u32\tstx_dev_minor;\n\t/* 0x90 */\n\t__u64\tstx_mnt_id;\n\t__u64\t__spare2;\n\t/* 0xa0 */\n\t__u64\t__spare3[12];\t/* Spare space for future expansion */\n\t/* 0x100 */\n};\n\n/*\n * Flags to be stx_mask\n *\n * Query request/result mask for statx() and struct statx::stx_mask.\n *\n * These bits should be set in the mask argument of statx() to request\n * particular items when calling statx().\n */\n#define STATX_TYPE\t\t0x00000001U\t/* Want/got stx_mode & S_IFMT */\n#define STATX_MODE\t\t0x00000002U\t/* Want/got stx_mode & ~S_IFMT */\n#define STATX_NLINK\t\t0x00000004U\t/* Want/got stx_nlink */\n#define STATX_UID\t\t0x00000008U\t/* Want/got stx_uid */\n#define STATX_GID\t\t0x00000010U\t/* Want/got stx_gid */\n#define STATX_ATIME\t\t0x00000020U\t/* Want/got stx_atime */\n#define STATX_MTIME\t\t0x00000040U\t/* Want/got stx_mtime */\n#define STATX_CTIME\t\t0x00000080U\t/* Want/got stx_ctime */\n#define STATX_INO\t\t0x00000100U\t/* Want/got stx_ino */\n#define STATX_SIZE\t\t0x00000200U\t/* Want/got stx_size */\n#define STATX_BLOCKS\t\t0x00000400U\t/* Want/got stx_blocks */\n#define STATX_BASIC_STATS\t0x000007ffU\t/* The stuff in the normal stat struct */\n#define STATX_BTIME\t\t0x00000800U\t/* Want/got stx_btime */\n#define STATX_MNT_ID\t\t0x00001000U\t/* Got stx_mnt_id */\n\n#define STATX__RESERVED\t\t0x80000000U\t/* Reserved for future struct statx expansion */\n\n#ifndef __KERNEL__\n/*\n * This is deprecated, and shall remain the same value in the future.  To avoid\n * confusion please use the equivalent (STATX_BASIC_STATS | STATX_BTIME)\n * instead.\n */\n#define STATX_ALL\t\t0x00000fffU\n#endif\n\n/*\n * Attributes to be found in stx_attributes and masked in stx_attributes_mask.\n *\n * These give information about the features or the state of a file that might\n * be of use to ordinary userspace programs such as GUIs or ls rather than\n * specialised tools.\n *\n * Note that the flags marked [I] correspond to the FS_IOC_SETFLAGS flags\n * semantically.  Where possible, the numerical value is picked to correspond\n * also.  Note that the DAX attribute indicates that the file is in the CPU\n * direct access state.  It does not correspond to the per-inode flag that\n * some filesystems support.\n *\n */\n#define STATX_ATTR_COMPRESSED\t\t0x00000004 /* [I] File is compressed by the fs */\n#define STATX_ATTR_IMMUTABLE\t\t0x00000010 /* [I] File is marked immutable */\n#define STATX_ATTR_APPEND\t\t0x00000020 /* [I] File is append-only */\n#define STATX_ATTR_NODUMP\t\t0x00000040 /* [I] File is not to be dumped */\n#define STATX_ATTR_ENCRYPTED\t\t0x00000800 /* [I] File requires key to decrypt in fs */\n#define STATX_ATTR_AUTOMOUNT\t\t0x00001000 /* Dir: Automount trigger */\n#define STATX_ATTR_MOUNT_ROOT\t\t0x00002000 /* Root of a mount */\n#define STATX_ATTR_VERITY\t\t0x00100000 /* [I] Verity protected file */\n#define STATX_ATTR_DAX\t\t\t0x00200000 /* File is currently in DAX state */\n\n\n#endif /* _UAPI_LINUX_STAT_H */\n"}, "3": {"id": 3, "path": "/src/include/linux/fs.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_FS_H\n#define _LINUX_FS_H\n\n#include <linux/linkage.h>\n#include <linux/wait_bit.h>\n#include <linux/kdev_t.h>\n#include <linux/dcache.h>\n#include <linux/path.h>\n#include <linux/stat.h>\n#include <linux/cache.h>\n#include <linux/list.h>\n#include <linux/list_lru.h>\n#include <linux/llist.h>\n#include <linux/radix-tree.h>\n#include <linux/xarray.h>\n#include <linux/rbtree.h>\n#include <linux/init.h>\n#include <linux/pid.h>\n#include <linux/bug.h>\n#include <linux/mutex.h>\n#include <linux/rwsem.h>\n#include <linux/mm_types.h>\n#include <linux/capability.h>\n#include <linux/semaphore.h>\n#include <linux/fcntl.h>\n#include <linux/rculist_bl.h>\n#include <linux/atomic.h>\n#include <linux/shrinker.h>\n#include <linux/migrate_mode.h>\n#include <linux/uidgid.h>\n#include <linux/lockdep.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/workqueue.h>\n#include <linux/delayed_call.h>\n#include <linux/uuid.h>\n#include <linux/errseq.h>\n#include <linux/ioprio.h>\n#include <linux/fs_types.h>\n#include <linux/build_bug.h>\n#include <linux/stddef.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n\n#include <asm/byteorder.h>\n#include <uapi/linux/fs.h>\n\nstruct backing_dev_info;\nstruct bdi_writeback;\nstruct bio;\nstruct export_operations;\nstruct fiemap_extent_info;\nstruct hd_geometry;\nstruct iovec;\nstruct kiocb;\nstruct kobject;\nstruct pipe_inode_info;\nstruct poll_table_struct;\nstruct kstatfs;\nstruct vm_area_struct;\nstruct vfsmount;\nstruct cred;\nstruct swap_info_struct;\nstruct seq_file;\nstruct workqueue_struct;\nstruct iov_iter;\nstruct fscrypt_info;\nstruct fscrypt_operations;\nstruct fsverity_info;\nstruct fsverity_operations;\nstruct fs_context;\nstruct fs_parameter_spec;\n\nextern void __init inode_init(void);\nextern void __init inode_init_early(void);\nextern void __init files_init(void);\nextern void __init files_maxfiles_init(void);\n\nextern struct files_stat_struct files_stat;\nextern unsigned long get_max_files(void);\nextern unsigned int sysctl_nr_open;\nextern struct inodes_stat_t inodes_stat;\nextern int leases_enable, lease_break_time;\nextern int sysctl_protected_symlinks;\nextern int sysctl_protected_hardlinks;\nextern int sysctl_protected_fifos;\nextern int sysctl_protected_regular;\n\ntypedef __kernel_rwf_t rwf_t;\n\nstruct buffer_head;\ntypedef int (get_block_t)(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create);\ntypedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,\n\t\t\tssize_t bytes, void *private);\n\n#define MAY_EXEC\t\t0x00000001\n#define MAY_WRITE\t\t0x00000002\n#define MAY_READ\t\t0x00000004\n#define MAY_APPEND\t\t0x00000008\n#define MAY_ACCESS\t\t0x00000010\n#define MAY_OPEN\t\t0x00000020\n#define MAY_CHDIR\t\t0x00000040\n/* called from RCU mode, don't block */\n#define MAY_NOT_BLOCK\t\t0x00000080\n\n/*\n * flags in file.f_mode.  Note that FMODE_READ and FMODE_WRITE must correspond\n * to O_WRONLY and O_RDWR via the strange trick in do_dentry_open()\n */\n\n/* file is open for reading */\n#define FMODE_READ\t\t((__force fmode_t)0x1)\n/* file is open for writing */\n#define FMODE_WRITE\t\t((__force fmode_t)0x2)\n/* file is seekable */\n#define FMODE_LSEEK\t\t((__force fmode_t)0x4)\n/* file can be accessed using pread */\n#define FMODE_PREAD\t\t((__force fmode_t)0x8)\n/* file can be accessed using pwrite */\n#define FMODE_PWRITE\t\t((__force fmode_t)0x10)\n/* File is opened for execution with sys_execve / sys_uselib */\n#define FMODE_EXEC\t\t((__force fmode_t)0x20)\n/* File is opened with O_NDELAY (only set for block devices) */\n#define FMODE_NDELAY\t\t((__force fmode_t)0x40)\n/* File is opened with O_EXCL (only set for block devices) */\n#define FMODE_EXCL\t\t((__force fmode_t)0x80)\n/* File is opened using open(.., 3, ..) and is writeable only for ioctls\n   (specialy hack for floppy.c) */\n#define FMODE_WRITE_IOCTL\t((__force fmode_t)0x100)\n/* 32bit hashes as llseek() offset (for directories) */\n#define FMODE_32BITHASH         ((__force fmode_t)0x200)\n/* 64bit hashes as llseek() offset (for directories) */\n#define FMODE_64BITHASH         ((__force fmode_t)0x400)\n\n/*\n * Don't update ctime and mtime.\n *\n * Currently a special hack for the XFS open_by_handle ioctl, but we'll\n * hopefully graduate it to a proper O_CMTIME flag supported by open(2) soon.\n */\n#define FMODE_NOCMTIME\t\t((__force fmode_t)0x800)\n\n/* Expect random access pattern */\n#define FMODE_RANDOM\t\t((__force fmode_t)0x1000)\n\n/* File is huge (eg. /dev/mem): treat loff_t as unsigned */\n#define FMODE_UNSIGNED_OFFSET\t((__force fmode_t)0x2000)\n\n/* File is opened with O_PATH; almost nothing can be done with it */\n#define FMODE_PATH\t\t((__force fmode_t)0x4000)\n\n/* File needs atomic accesses to f_pos */\n#define FMODE_ATOMIC_POS\t((__force fmode_t)0x8000)\n/* Write access to underlying fs */\n#define FMODE_WRITER\t\t((__force fmode_t)0x10000)\n/* Has read method(s) */\n#define FMODE_CAN_READ          ((__force fmode_t)0x20000)\n/* Has write method(s) */\n#define FMODE_CAN_WRITE         ((__force fmode_t)0x40000)\n\n#define FMODE_OPENED\t\t((__force fmode_t)0x80000)\n#define FMODE_CREATED\t\t((__force fmode_t)0x100000)\n\n/* File is stream-like */\n#define FMODE_STREAM\t\t((__force fmode_t)0x200000)\n\n/* File was opened by fanotify and shouldn't generate fanotify events */\n#define FMODE_NONOTIFY\t\t((__force fmode_t)0x4000000)\n\n/* File is capable of returning -EAGAIN if I/O will block */\n#define FMODE_NOWAIT\t\t((__force fmode_t)0x8000000)\n\n/* File represents mount that needs unmounting */\n#define FMODE_NEED_UNMOUNT\t((__force fmode_t)0x10000000)\n\n/* File does not contribute to nr_files count */\n#define FMODE_NOACCOUNT\t\t((__force fmode_t)0x20000000)\n\n/* File supports async buffered reads */\n#define FMODE_BUF_RASYNC\t((__force fmode_t)0x40000000)\n\n/*\n * Attribute flags.  These should be or-ed together to figure out what\n * has been changed!\n */\n#define ATTR_MODE\t(1 << 0)\n#define ATTR_UID\t(1 << 1)\n#define ATTR_GID\t(1 << 2)\n#define ATTR_SIZE\t(1 << 3)\n#define ATTR_ATIME\t(1 << 4)\n#define ATTR_MTIME\t(1 << 5)\n#define ATTR_CTIME\t(1 << 6)\n#define ATTR_ATIME_SET\t(1 << 7)\n#define ATTR_MTIME_SET\t(1 << 8)\n#define ATTR_FORCE\t(1 << 9) /* Not a change, but a change it */\n#define ATTR_KILL_SUID\t(1 << 11)\n#define ATTR_KILL_SGID\t(1 << 12)\n#define ATTR_FILE\t(1 << 13)\n#define ATTR_KILL_PRIV\t(1 << 14)\n#define ATTR_OPEN\t(1 << 15) /* Truncating from open(O_TRUNC) */\n#define ATTR_TIMES_SET\t(1 << 16)\n#define ATTR_TOUCH\t(1 << 17)\n\n/*\n * Whiteout is represented by a char device.  The following constants define the\n * mode and device number to use.\n */\n#define WHITEOUT_MODE 0\n#define WHITEOUT_DEV 0\n\n/*\n * This is the Inode Attributes structure, used for notify_change().  It\n * uses the above definitions as flags, to know which values have changed.\n * Also, in this manner, a Filesystem can look at only the values it cares\n * about.  Basically, these are the attributes that the VFS layer can\n * request to change from the FS layer.\n *\n * Derek Atkins <warlord@MIT.EDU> 94-10-20\n */\nstruct iattr {\n\tunsigned int\tia_valid;\n\tumode_t\t\tia_mode;\n\tkuid_t\t\tia_uid;\n\tkgid_t\t\tia_gid;\n\tloff_t\t\tia_size;\n\tstruct timespec64 ia_atime;\n\tstruct timespec64 ia_mtime;\n\tstruct timespec64 ia_ctime;\n\n\t/*\n\t * Not an attribute, but an auxiliary info for filesystems wanting to\n\t * implement an ftruncate() like method.  NOTE: filesystem should\n\t * check for (ia_valid & ATTR_FILE), and not for (ia_file != NULL).\n\t */\n\tstruct file\t*ia_file;\n};\n\n/*\n * Includes for diskquotas.\n */\n#include <linux/quota.h>\n\n/*\n * Maximum number of layers of fs stack.  Needs to be limited to\n * prevent kernel stack overflow\n */\n#define FILESYSTEM_MAX_STACK_DEPTH 2\n\n/** \n * enum positive_aop_returns - aop return codes with specific semantics\n *\n * @AOP_WRITEPAGE_ACTIVATE: Informs the caller that page writeback has\n * \t\t\t    completed, that the page is still locked, and\n * \t\t\t    should be considered active.  The VM uses this hint\n * \t\t\t    to return the page to the active list -- it won't\n * \t\t\t    be a candidate for writeback again in the near\n * \t\t\t    future.  Other callers must be careful to unlock\n * \t\t\t    the page if they get this return.  Returned by\n * \t\t\t    writepage(); \n *\n * @AOP_TRUNCATED_PAGE: The AOP method that was handed a locked page has\n *  \t\t\tunlocked it and the page might have been truncated.\n *  \t\t\tThe caller should back up to acquiring a new page and\n *  \t\t\ttrying again.  The aop will be taking reasonable\n *  \t\t\tprecautions not to livelock.  If the caller held a page\n *  \t\t\treference, it should drop it before retrying.  Returned\n *  \t\t\tby readpage().\n *\n * address_space_operation functions return these large constants to indicate\n * special semantics to the caller.  These are much larger than the bytes in a\n * page to allow for functions that return the number of bytes operated on in a\n * given page.\n */\n\nenum positive_aop_returns {\n\tAOP_WRITEPAGE_ACTIVATE\t= 0x80000,\n\tAOP_TRUNCATED_PAGE\t= 0x80001,\n};\n\n#define AOP_FLAG_CONT_EXPAND\t\t0x0001 /* called from cont_expand */\n#define AOP_FLAG_NOFS\t\t\t0x0002 /* used by filesystem to direct\n\t\t\t\t\t\t* helper code (eg buffer layer)\n\t\t\t\t\t\t* to clear GFP_FS from alloc */\n\n/*\n * oh the beauties of C type declarations.\n */\nstruct page;\nstruct address_space;\nstruct writeback_control;\nstruct readahead_control;\n\n/*\n * Write life time hint values.\n * Stored in struct inode as u8.\n */\nenum rw_hint {\n\tWRITE_LIFE_NOT_SET\t= 0,\n\tWRITE_LIFE_NONE\t\t= RWH_WRITE_LIFE_NONE,\n\tWRITE_LIFE_SHORT\t= RWH_WRITE_LIFE_SHORT,\n\tWRITE_LIFE_MEDIUM\t= RWH_WRITE_LIFE_MEDIUM,\n\tWRITE_LIFE_LONG\t\t= RWH_WRITE_LIFE_LONG,\n\tWRITE_LIFE_EXTREME\t= RWH_WRITE_LIFE_EXTREME,\n};\n\n/* Match RWF_* bits to IOCB bits */\n#define IOCB_HIPRI\t\t(__force int) RWF_HIPRI\n#define IOCB_DSYNC\t\t(__force int) RWF_DSYNC\n#define IOCB_SYNC\t\t(__force int) RWF_SYNC\n#define IOCB_NOWAIT\t\t(__force int) RWF_NOWAIT\n#define IOCB_APPEND\t\t(__force int) RWF_APPEND\n\n/* non-RWF related bits - start at 16 */\n#define IOCB_EVENTFD\t\t(1 << 16)\n#define IOCB_DIRECT\t\t(1 << 17)\n#define IOCB_WRITE\t\t(1 << 18)\n/* iocb->ki_waitq is valid */\n#define IOCB_WAITQ\t\t(1 << 19)\n#define IOCB_NOIO\t\t(1 << 20)\n\nstruct kiocb {\n\tstruct file\t\t*ki_filp;\n\n\t/* The 'ki_filp' pointer is shared in a union for aio */\n\trandomized_struct_fields_start\n\n\tloff_t\t\t\tki_pos;\n\tvoid (*ki_complete)(struct kiocb *iocb, long ret, long ret2);\n\tvoid\t\t\t*private;\n\tint\t\t\tki_flags;\n\tu16\t\t\tki_hint;\n\tu16\t\t\tki_ioprio; /* See linux/ioprio.h */\n\tunion {\n\t\tunsigned int\t\tki_cookie; /* for ->iopoll */\n\t\tstruct wait_page_queue\t*ki_waitq; /* for async buffered IO */\n\t};\n\n\trandomized_struct_fields_end\n};\n\nstatic inline bool is_sync_kiocb(struct kiocb *kiocb)\n{\n\treturn kiocb->ki_complete == NULL;\n}\n\n/*\n * \"descriptor\" for what we're up to with a read.\n * This allows us to use the same read code yet\n * have multiple different users of the data that\n * we read from a file.\n *\n * The simplest case just copies the data to user\n * mode.\n */\ntypedef struct {\n\tsize_t written;\n\tsize_t count;\n\tunion {\n\t\tchar __user *buf;\n\t\tvoid *data;\n\t} arg;\n\tint error;\n} read_descriptor_t;\n\ntypedef int (*read_actor_t)(read_descriptor_t *, struct page *,\n\t\tunsigned long, unsigned long);\n\nstruct address_space_operations {\n\tint (*writepage)(struct page *page, struct writeback_control *wbc);\n\tint (*readpage)(struct file *, struct page *);\n\n\t/* Write back some dirty pages from this mapping. */\n\tint (*writepages)(struct address_space *, struct writeback_control *);\n\n\t/* Set a page dirty.  Return true if this dirtied it */\n\tint (*set_page_dirty)(struct page *page);\n\n\t/*\n\t * Reads in the requested pages. Unlike ->readpage(), this is\n\t * PURELY used for read-ahead!.\n\t */\n\tint (*readpages)(struct file *filp, struct address_space *mapping,\n\t\t\tstruct list_head *pages, unsigned nr_pages);\n\tvoid (*readahead)(struct readahead_control *);\n\n\tint (*write_begin)(struct file *, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\t\tstruct page **pagep, void **fsdata);\n\tint (*write_end)(struct file *, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\t\tstruct page *page, void *fsdata);\n\n\t/* Unfortunately this kludge is needed for FIBMAP. Don't use it */\n\tsector_t (*bmap)(struct address_space *, sector_t);\n\tvoid (*invalidatepage) (struct page *, unsigned int, unsigned int);\n\tint (*releasepage) (struct page *, gfp_t);\n\tvoid (*freepage)(struct page *);\n\tssize_t (*direct_IO)(struct kiocb *, struct iov_iter *iter);\n\t/*\n\t * migrate the contents of a page to the specified target. If\n\t * migrate_mode is MIGRATE_ASYNC, it must not block.\n\t */\n\tint (*migratepage) (struct address_space *,\n\t\t\tstruct page *, struct page *, enum migrate_mode);\n\tbool (*isolate_page)(struct page *, isolate_mode_t);\n\tvoid (*putback_page)(struct page *);\n\tint (*launder_page) (struct page *);\n\tint (*is_partially_uptodate) (struct page *, unsigned long,\n\t\t\t\t\tunsigned long);\n\tvoid (*is_dirty_writeback) (struct page *, bool *, bool *);\n\tint (*error_remove_page)(struct address_space *, struct page *);\n\n\t/* swapfile support */\n\tint (*swap_activate)(struct swap_info_struct *sis, struct file *file,\n\t\t\t\tsector_t *span);\n\tvoid (*swap_deactivate)(struct file *file);\n};\n\nextern const struct address_space_operations empty_aops;\n\n/*\n * pagecache_write_begin/pagecache_write_end must be used by general code\n * to write into the pagecache.\n */\nint pagecache_write_begin(struct file *, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\t\tstruct page **pagep, void **fsdata);\n\nint pagecache_write_end(struct file *, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\t\tstruct page *page, void *fsdata);\n\n/**\n * struct address_space - Contents of a cacheable, mappable object.\n * @host: Owner, either the inode or the block_device.\n * @i_pages: Cached pages.\n * @gfp_mask: Memory allocation flags to use for allocating pages.\n * @i_mmap_writable: Number of VM_SHARED mappings.\n * @nr_thps: Number of THPs in the pagecache (non-shmem only).\n * @i_mmap: Tree of private and shared mappings.\n * @i_mmap_rwsem: Protects @i_mmap and @i_mmap_writable.\n * @nrpages: Number of page entries, protected by the i_pages lock.\n * @writeback_index: Writeback starts here.\n * @a_ops: Methods.\n * @flags: Error bits and flags (AS_*).\n * @wb_err: The most recent error which has occurred.\n * @private_lock: For use by the owner of the address_space.\n * @private_list: For use by the owner of the address_space.\n * @private_data: For use by the owner of the address_space.\n */\nstruct address_space {\n\tstruct inode\t\t*host;\n\tstruct xarray\t\ti_pages;\n\tgfp_t\t\t\tgfp_mask;\n\tatomic_t\t\ti_mmap_writable;\n#ifdef CONFIG_READ_ONLY_THP_FOR_FS\n\t/* number of thp, only for non-shmem files */\n\tatomic_t\t\tnr_thps;\n#endif\n\tstruct rb_root_cached\ti_mmap;\n\tstruct rw_semaphore\ti_mmap_rwsem;\n\tunsigned long\t\tnrpages;\n\tpgoff_t\t\t\twriteback_index;\n\tconst struct address_space_operations *a_ops;\n\tunsigned long\t\tflags;\n\terrseq_t\t\twb_err;\n\tspinlock_t\t\tprivate_lock;\n\tstruct list_head\tprivate_list;\n\tvoid\t\t\t*private_data;\n} __attribute__((aligned(sizeof(long)))) __randomize_layout;\n\t/*\n\t * On most architectures that alignment is already the case; but\n\t * must be enforced here for CRIS, to let the least significant bit\n\t * of struct page's \"mapping\" pointer be used for PAGE_MAPPING_ANON.\n\t */\n\n/* XArray tags, for tagging dirty and writeback pages in the pagecache. */\n#define PAGECACHE_TAG_DIRTY\tXA_MARK_0\n#define PAGECACHE_TAG_WRITEBACK\tXA_MARK_1\n#define PAGECACHE_TAG_TOWRITE\tXA_MARK_2\n\n/*\n * Returns true if any of the pages in the mapping are marked with the tag.\n */\nstatic inline bool mapping_tagged(struct address_space *mapping, xa_mark_t tag)\n{\n\treturn xa_marked(&mapping->i_pages, tag);\n}\n\nstatic inline void i_mmap_lock_write(struct address_space *mapping)\n{\n\tdown_write(&mapping->i_mmap_rwsem);\n}\n\nstatic inline int i_mmap_trylock_write(struct address_space *mapping)\n{\n\treturn down_write_trylock(&mapping->i_mmap_rwsem);\n}\n\nstatic inline void i_mmap_unlock_write(struct address_space *mapping)\n{\n\tup_write(&mapping->i_mmap_rwsem);\n}\n\nstatic inline void i_mmap_lock_read(struct address_space *mapping)\n{\n\tdown_read(&mapping->i_mmap_rwsem);\n}\n\nstatic inline void i_mmap_unlock_read(struct address_space *mapping)\n{\n\tup_read(&mapping->i_mmap_rwsem);\n}\n\nstatic inline void i_mmap_assert_locked(struct address_space *mapping)\n{\n\tlockdep_assert_held(&mapping->i_mmap_rwsem);\n}\n\nstatic inline void i_mmap_assert_write_locked(struct address_space *mapping)\n{\n\tlockdep_assert_held_write(&mapping->i_mmap_rwsem);\n}\n\n/*\n * Might pages of this file be mapped into userspace?\n */\nstatic inline int mapping_mapped(struct address_space *mapping)\n{\n\treturn\t!RB_EMPTY_ROOT(&mapping->i_mmap.rb_root);\n}\n\n/*\n * Might pages of this file have been modified in userspace?\n * Note that i_mmap_writable counts all VM_SHARED vmas: do_mmap\n * marks vma as VM_SHARED if it is shared, and the file was opened for\n * writing i.e. vma may be mprotected writable even if now readonly.\n *\n * If i_mmap_writable is negative, no new writable mappings are allowed. You\n * can only deny writable mappings, if none exists right now.\n */\nstatic inline int mapping_writably_mapped(struct address_space *mapping)\n{\n\treturn atomic_read(&mapping->i_mmap_writable) > 0;\n}\n\nstatic inline int mapping_map_writable(struct address_space *mapping)\n{\n\treturn atomic_inc_unless_negative(&mapping->i_mmap_writable) ?\n\t\t0 : -EPERM;\n}\n\nstatic inline void mapping_unmap_writable(struct address_space *mapping)\n{\n\tatomic_dec(&mapping->i_mmap_writable);\n}\n\nstatic inline int mapping_deny_writable(struct address_space *mapping)\n{\n\treturn atomic_dec_unless_positive(&mapping->i_mmap_writable) ?\n\t\t0 : -EBUSY;\n}\n\nstatic inline void mapping_allow_writable(struct address_space *mapping)\n{\n\tatomic_inc(&mapping->i_mmap_writable);\n}\n\n/*\n * Use sequence counter to get consistent i_size on 32-bit processors.\n */\n#if BITS_PER_LONG==32 && defined(CONFIG_SMP)\n#include <linux/seqlock.h>\n#define __NEED_I_SIZE_ORDERED\n#define i_size_ordered_init(inode) seqcount_init(&inode->i_size_seqcount)\n#else\n#define i_size_ordered_init(inode) do { } while (0)\n#endif\n\nstruct posix_acl;\n#define ACL_NOT_CACHED ((void *)(-1))\n#define ACL_DONT_CACHE ((void *)(-3))\n\nstatic inline struct posix_acl *\nuncached_acl_sentinel(struct task_struct *task)\n{\n\treturn (void *)task + 1;\n}\n\nstatic inline bool\nis_uncached_acl(struct posix_acl *acl)\n{\n\treturn (long)acl & 1;\n}\n\n#define IOP_FASTPERM\t0x0001\n#define IOP_LOOKUP\t0x0002\n#define IOP_NOFOLLOW\t0x0004\n#define IOP_XATTR\t0x0008\n#define IOP_DEFAULT_READLINK\t0x0010\n\nstruct fsnotify_mark_connector;\n\n/*\n * Keep mostly read-only and often accessed (especially for\n * the RCU path lookup and 'stat' data) fields at the beginning\n * of the 'struct inode'\n */\nstruct inode {\n\tumode_t\t\t\ti_mode;\n\tunsigned short\t\ti_opflags;\n\tkuid_t\t\t\ti_uid;\n\tkgid_t\t\t\ti_gid;\n\tunsigned int\t\ti_flags;\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tstruct posix_acl\t*i_acl;\n\tstruct posix_acl\t*i_default_acl;\n#endif\n\n\tconst struct inode_operations\t*i_op;\n\tstruct super_block\t*i_sb;\n\tstruct address_space\t*i_mapping;\n\n#ifdef CONFIG_SECURITY\n\tvoid\t\t\t*i_security;\n#endif\n\n\t/* Stat data, not accessed from path walking */\n\tunsigned long\t\ti_ino;\n\t/*\n\t * Filesystems may only read i_nlink directly.  They shall use the\n\t * following functions for modification:\n\t *\n\t *    (set|clear|inc|drop)_nlink\n\t *    inode_(inc|dec)_link_count\n\t */\n\tunion {\n\t\tconst unsigned int i_nlink;\n\t\tunsigned int __i_nlink;\n\t};\n\tdev_t\t\t\ti_rdev;\n\tloff_t\t\t\ti_size;\n\tstruct timespec64\ti_atime;\n\tstruct timespec64\ti_mtime;\n\tstruct timespec64\ti_ctime;\n\tspinlock_t\t\ti_lock;\t/* i_blocks, i_bytes, maybe i_size */\n\tunsigned short          i_bytes;\n\tu8\t\t\ti_blkbits;\n\tu8\t\t\ti_write_hint;\n\tblkcnt_t\t\ti_blocks;\n\n#ifdef __NEED_I_SIZE_ORDERED\n\tseqcount_t\t\ti_size_seqcount;\n#endif\n\n\t/* Misc */\n\tunsigned long\t\ti_state;\n\tstruct rw_semaphore\ti_rwsem;\n\n\tunsigned long\t\tdirtied_when;\t/* jiffies of first dirtying */\n\tunsigned long\t\tdirtied_time_when;\n\n\tstruct hlist_node\ti_hash;\n\tstruct list_head\ti_io_list;\t/* backing dev IO list */\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tstruct bdi_writeback\t*i_wb;\t\t/* the associated cgroup wb */\n\n\t/* foreign inode detection, see wbc_detach_inode() */\n\tint\t\t\ti_wb_frn_winner;\n\tu16\t\t\ti_wb_frn_avg_time;\n\tu16\t\t\ti_wb_frn_history;\n#endif\n\tstruct list_head\ti_lru;\t\t/* inode LRU list */\n\tstruct list_head\ti_sb_list;\n\tstruct list_head\ti_wb_list;\t/* backing dev writeback list */\n\tunion {\n\t\tstruct hlist_head\ti_dentry;\n\t\tstruct rcu_head\t\ti_rcu;\n\t};\n\tatomic64_t\t\ti_version;\n\tatomic64_t\t\ti_sequence; /* see futex */\n\tatomic_t\t\ti_count;\n\tatomic_t\t\ti_dio_count;\n\tatomic_t\t\ti_writecount;\n#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)\n\tatomic_t\t\ti_readcount; /* struct files open RO */\n#endif\n\tunion {\n\t\tconst struct file_operations\t*i_fop;\t/* former ->i_op->default_file_ops */\n\t\tvoid (*free_inode)(struct inode *);\n\t};\n\tstruct file_lock_context\t*i_flctx;\n\tstruct address_space\ti_data;\n\tstruct list_head\ti_devices;\n\tunion {\n\t\tstruct pipe_inode_info\t*i_pipe;\n\t\tstruct cdev\t\t*i_cdev;\n\t\tchar\t\t\t*i_link;\n\t\tunsigned\t\ti_dir_seq;\n\t};\n\n\t__u32\t\t\ti_generation;\n\n#ifdef CONFIG_FSNOTIFY\n\t__u32\t\t\ti_fsnotify_mask; /* all events this inode cares about */\n\tstruct fsnotify_mark_connector __rcu\t*i_fsnotify_marks;\n#endif\n\n#ifdef CONFIG_FS_ENCRYPTION\n\tstruct fscrypt_info\t*i_crypt_info;\n#endif\n\n#ifdef CONFIG_FS_VERITY\n\tstruct fsverity_info\t*i_verity_info;\n#endif\n\n\tvoid\t\t\t*i_private; /* fs or device private pointer */\n} __randomize_layout;\n\nstruct timespec64 timestamp_truncate(struct timespec64 t, struct inode *inode);\n\nstatic inline unsigned int i_blocksize(const struct inode *node)\n{\n\treturn (1 << node->i_blkbits);\n}\n\nstatic inline int inode_unhashed(struct inode *inode)\n{\n\treturn hlist_unhashed(&inode->i_hash);\n}\n\n/*\n * __mark_inode_dirty expects inodes to be hashed.  Since we don't\n * want special inodes in the fileset inode space, we make them\n * appear hashed, but do not put on any lists.  hlist_del()\n * will work fine and require no locking.\n */\nstatic inline void inode_fake_hash(struct inode *inode)\n{\n\thlist_add_fake(&inode->i_hash);\n}\n\n/*\n * inode->i_mutex nesting subclasses for the lock validator:\n *\n * 0: the object of the current VFS operation\n * 1: parent\n * 2: child/target\n * 3: xattr\n * 4: second non-directory\n * 5: second parent (when locking independent directories in rename)\n *\n * I_MUTEX_NONDIR2 is for certain operations (such as rename) which lock two\n * non-directories at once.\n *\n * The locking order between these classes is\n * parent[2] -> child -> grandchild -> normal -> xattr -> second non-directory\n */\nenum inode_i_mutex_lock_class\n{\n\tI_MUTEX_NORMAL,\n\tI_MUTEX_PARENT,\n\tI_MUTEX_CHILD,\n\tI_MUTEX_XATTR,\n\tI_MUTEX_NONDIR2,\n\tI_MUTEX_PARENT2,\n};\n\nstatic inline void inode_lock(struct inode *inode)\n{\n\tdown_write(&inode->i_rwsem);\n}\n\nstatic inline void inode_unlock(struct inode *inode)\n{\n\tup_write(&inode->i_rwsem);\n}\n\nstatic inline void inode_lock_shared(struct inode *inode)\n{\n\tdown_read(&inode->i_rwsem);\n}\n\nstatic inline void inode_unlock_shared(struct inode *inode)\n{\n\tup_read(&inode->i_rwsem);\n}\n\nstatic inline int inode_trylock(struct inode *inode)\n{\n\treturn down_write_trylock(&inode->i_rwsem);\n}\n\nstatic inline int inode_trylock_shared(struct inode *inode)\n{\n\treturn down_read_trylock(&inode->i_rwsem);\n}\n\nstatic inline int inode_is_locked(struct inode *inode)\n{\n\treturn rwsem_is_locked(&inode->i_rwsem);\n}\n\nstatic inline void inode_lock_nested(struct inode *inode, unsigned subclass)\n{\n\tdown_write_nested(&inode->i_rwsem, subclass);\n}\n\nstatic inline void inode_lock_shared_nested(struct inode *inode, unsigned subclass)\n{\n\tdown_read_nested(&inode->i_rwsem, subclass);\n}\n\nvoid lock_two_nondirectories(struct inode *, struct inode*);\nvoid unlock_two_nondirectories(struct inode *, struct inode*);\n\n/*\n * NOTE: in a 32bit arch with a preemptable kernel and\n * an UP compile the i_size_read/write must be atomic\n * with respect to the local cpu (unlike with preempt disabled),\n * but they don't need to be atomic with respect to other cpus like in\n * true SMP (so they need either to either locally disable irq around\n * the read or for example on x86 they can be still implemented as a\n * cmpxchg8b without the need of the lock prefix). For SMP compiles\n * and 64bit archs it makes no difference if preempt is enabled or not.\n */\nstatic inline loff_t i_size_read(const struct inode *inode)\n{\n#if BITS_PER_LONG==32 && defined(CONFIG_SMP)\n\tloff_t i_size;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&inode->i_size_seqcount);\n\t\ti_size = inode->i_size;\n\t} while (read_seqcount_retry(&inode->i_size_seqcount, seq));\n\treturn i_size;\n#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPTION)\n\tloff_t i_size;\n\n\tpreempt_disable();\n\ti_size = inode->i_size;\n\tpreempt_enable();\n\treturn i_size;\n#else\n\treturn inode->i_size;\n#endif\n}\n\n/*\n * NOTE: unlike i_size_read(), i_size_write() does need locking around it\n * (normally i_mutex), otherwise on 32bit/SMP an update of i_size_seqcount\n * can be lost, resulting in subsequent i_size_read() calls spinning forever.\n */\nstatic inline void i_size_write(struct inode *inode, loff_t i_size)\n{\n#if BITS_PER_LONG==32 && defined(CONFIG_SMP)\n\tpreempt_disable();\n\twrite_seqcount_begin(&inode->i_size_seqcount);\n\tinode->i_size = i_size;\n\twrite_seqcount_end(&inode->i_size_seqcount);\n\tpreempt_enable();\n#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPTION)\n\tpreempt_disable();\n\tinode->i_size = i_size;\n\tpreempt_enable();\n#else\n\tinode->i_size = i_size;\n#endif\n}\n\nstatic inline unsigned iminor(const struct inode *inode)\n{\n\treturn MINOR(inode->i_rdev);\n}\n\nstatic inline unsigned imajor(const struct inode *inode)\n{\n\treturn MAJOR(inode->i_rdev);\n}\n\nstruct fown_struct {\n\trwlock_t lock;          /* protects pid, uid, euid fields */\n\tstruct pid *pid;\t/* pid or -pgrp where SIGIO should be sent */\n\tenum pid_type pid_type;\t/* Kind of process group SIGIO should be sent to */\n\tkuid_t uid, euid;\t/* uid/euid of process setting the owner */\n\tint signum;\t\t/* posix.1b rt signal to be delivered on IO */\n};\n\n/*\n * Track a single file's readahead state\n */\nstruct file_ra_state {\n\tpgoff_t start;\t\t\t/* where readahead started */\n\tunsigned int size;\t\t/* # of readahead pages */\n\tunsigned int async_size;\t/* do asynchronous readahead when\n\t\t\t\t\t   there are only # of pages ahead */\n\n\tunsigned int ra_pages;\t\t/* Maximum readahead window */\n\tunsigned int mmap_miss;\t\t/* Cache miss stat for mmap accesses */\n\tloff_t prev_pos;\t\t/* Cache last read() position */\n};\n\n/*\n * Check if @index falls in the readahead windows.\n */\nstatic inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)\n{\n\treturn (index >= ra->start &&\n\t\tindex <  ra->start + ra->size);\n}\n\nstruct file {\n\tunion {\n\t\tstruct llist_node\tfu_llist;\n\t\tstruct rcu_head \tfu_rcuhead;\n\t} f_u;\n\tstruct path\t\tf_path;\n\tstruct inode\t\t*f_inode;\t/* cached value */\n\tconst struct file_operations\t*f_op;\n\n\t/*\n\t * Protects f_ep, f_flags.\n\t * Must not be taken from IRQ context.\n\t */\n\tspinlock_t\t\tf_lock;\n\tenum rw_hint\t\tf_write_hint;\n\tatomic_long_t\t\tf_count;\n\tunsigned int \t\tf_flags;\n\tfmode_t\t\t\tf_mode;\n\tstruct mutex\t\tf_pos_lock;\n\tloff_t\t\t\tf_pos;\n\tstruct fown_struct\tf_owner;\n\tconst struct cred\t*f_cred;\n\tstruct file_ra_state\tf_ra;\n\n\tu64\t\t\tf_version;\n#ifdef CONFIG_SECURITY\n\tvoid\t\t\t*f_security;\n#endif\n\t/* needed for tty driver, and maybe others */\n\tvoid\t\t\t*private_data;\n\n#ifdef CONFIG_EPOLL\n\t/* Used by fs/eventpoll.c to link all the hooks to this file */\n\tstruct hlist_head\t*f_ep;\n#endif /* #ifdef CONFIG_EPOLL */\n\tstruct address_space\t*f_mapping;\n\terrseq_t\t\tf_wb_err;\n\terrseq_t\t\tf_sb_err; /* for syncfs */\n} __randomize_layout\n  __attribute__((aligned(4)));\t/* lest something weird decides that 2 is OK */\n\nstruct file_handle {\n\t__u32 handle_bytes;\n\tint handle_type;\n\t/* file identifier */\n\tunsigned char f_handle[];\n};\n\nstatic inline struct file *get_file(struct file *f)\n{\n\tatomic_long_inc(&f->f_count);\n\treturn f;\n}\n#define get_file_rcu_many(x, cnt)\t\\\n\tatomic_long_add_unless(&(x)->f_count, (cnt), 0)\n#define get_file_rcu(x) get_file_rcu_many((x), 1)\n#define file_count(x)\tatomic_long_read(&(x)->f_count)\n\n#define\tMAX_NON_LFS\t((1UL<<31) - 1)\n\n/* Page cache limit. The filesystems should put that into their s_maxbytes \n   limits, otherwise bad things can happen in VM. */ \n#if BITS_PER_LONG==32\n#define MAX_LFS_FILESIZE\t((loff_t)ULONG_MAX << PAGE_SHIFT)\n#elif BITS_PER_LONG==64\n#define MAX_LFS_FILESIZE \t((loff_t)LLONG_MAX)\n#endif\n\n#define FL_POSIX\t1\n#define FL_FLOCK\t2\n#define FL_DELEG\t4\t/* NFSv4 delegation */\n#define FL_ACCESS\t8\t/* not trying to lock, just looking */\n#define FL_EXISTS\t16\t/* when unlocking, test for existence */\n#define FL_LEASE\t32\t/* lease held on this file */\n#define FL_CLOSE\t64\t/* unlock on close */\n#define FL_SLEEP\t128\t/* A blocking lock */\n#define FL_DOWNGRADE_PENDING\t256 /* Lease is being downgraded */\n#define FL_UNLOCK_PENDING\t512 /* Lease is being broken */\n#define FL_OFDLCK\t1024\t/* lock is \"owned\" by struct file */\n#define FL_LAYOUT\t2048\t/* outstanding pNFS layout */\n\n#define FL_CLOSE_POSIX (FL_POSIX | FL_CLOSE)\n\n/*\n * Special return value from posix_lock_file() and vfs_lock_file() for\n * asynchronous locking.\n */\n#define FILE_LOCK_DEFERRED 1\n\n/* legacy typedef, should eventually be removed */\ntypedef void *fl_owner_t;\n\nstruct file_lock;\n\nstruct file_lock_operations {\n\tvoid (*fl_copy_lock)(struct file_lock *, struct file_lock *);\n\tvoid (*fl_release_private)(struct file_lock *);\n};\n\nstruct lock_manager_operations {\n\tfl_owner_t (*lm_get_owner)(fl_owner_t);\n\tvoid (*lm_put_owner)(fl_owner_t);\n\tvoid (*lm_notify)(struct file_lock *);\t/* unblock callback */\n\tint (*lm_grant)(struct file_lock *, int);\n\tbool (*lm_break)(struct file_lock *);\n\tint (*lm_change)(struct file_lock *, int, struct list_head *);\n\tvoid (*lm_setup)(struct file_lock *, void **);\n\tbool (*lm_breaker_owns_lease)(struct file_lock *);\n};\n\nstruct lock_manager {\n\tstruct list_head list;\n\t/*\n\t * NFSv4 and up also want opens blocked during the grace period;\n\t * NLM doesn't care:\n\t */\n\tbool block_opens;\n};\n\nstruct net;\nvoid locks_start_grace(struct net *, struct lock_manager *);\nvoid locks_end_grace(struct lock_manager *);\nbool locks_in_grace(struct net *);\nbool opens_in_grace(struct net *);\n\n/* that will die - we need it for nfs_lock_info */\n#include <linux/nfs_fs_i.h>\n\n/*\n * struct file_lock represents a generic \"file lock\". It's used to represent\n * POSIX byte range locks, BSD (flock) locks, and leases. It's important to\n * note that the same struct is used to represent both a request for a lock and\n * the lock itself, but the same object is never used for both.\n *\n * FIXME: should we create a separate \"struct lock_request\" to help distinguish\n * these two uses?\n *\n * The varous i_flctx lists are ordered by:\n *\n * 1) lock owner\n * 2) lock range start\n * 3) lock range end\n *\n * Obviously, the last two criteria only matter for POSIX locks.\n */\nstruct file_lock {\n\tstruct file_lock *fl_blocker;\t/* The lock, that is blocking us */\n\tstruct list_head fl_list;\t/* link into file_lock_context */\n\tstruct hlist_node fl_link;\t/* node in global lists */\n\tstruct list_head fl_blocked_requests;\t/* list of requests with\n\t\t\t\t\t\t * ->fl_blocker pointing here\n\t\t\t\t\t\t */\n\tstruct list_head fl_blocked_member;\t/* node in\n\t\t\t\t\t\t * ->fl_blocker->fl_blocked_requests\n\t\t\t\t\t\t */\n\tfl_owner_t fl_owner;\n\tunsigned int fl_flags;\n\tunsigned char fl_type;\n\tunsigned int fl_pid;\n\tint fl_link_cpu;\t\t/* what cpu's list is this on? */\n\twait_queue_head_t fl_wait;\n\tstruct file *fl_file;\n\tloff_t fl_start;\n\tloff_t fl_end;\n\n\tstruct fasync_struct *\tfl_fasync; /* for lease break notifications */\n\t/* for lease breaks: */\n\tunsigned long fl_break_time;\n\tunsigned long fl_downgrade_time;\n\n\tconst struct file_lock_operations *fl_ops;\t/* Callbacks for filesystems */\n\tconst struct lock_manager_operations *fl_lmops;\t/* Callbacks for lockmanagers */\n\tunion {\n\t\tstruct nfs_lock_info\tnfs_fl;\n\t\tstruct nfs4_lock_info\tnfs4_fl;\n\t\tstruct {\n\t\t\tstruct list_head link;\t/* link in AFS vnode's pending_locks list */\n\t\t\tint state;\t\t/* state of grant or error if -ve */\n\t\t\tunsigned int\tdebug_id;\n\t\t} afs;\n\t} fl_u;\n} __randomize_layout;\n\nstruct file_lock_context {\n\tspinlock_t\t\tflc_lock;\n\tstruct list_head\tflc_flock;\n\tstruct list_head\tflc_posix;\n\tstruct list_head\tflc_lease;\n};\n\n/* The following constant reflects the upper bound of the file/locking space */\n#ifndef OFFSET_MAX\n#define INT_LIMIT(x)\t(~((x)1 << (sizeof(x)*8 - 1)))\n#define OFFSET_MAX\tINT_LIMIT(loff_t)\n#define OFFT_OFFSET_MAX\tINT_LIMIT(off_t)\n#endif\n\nextern void send_sigio(struct fown_struct *fown, int fd, int band);\n\n#define locks_inode(f) file_inode(f)\n\n#ifdef CONFIG_FILE_LOCKING\nextern int fcntl_getlk(struct file *, unsigned int, struct flock *);\nextern int fcntl_setlk(unsigned int, struct file *, unsigned int,\n\t\t\tstruct flock *);\n\n#if BITS_PER_LONG == 32\nextern int fcntl_getlk64(struct file *, unsigned int, struct flock64 *);\nextern int fcntl_setlk64(unsigned int, struct file *, unsigned int,\n\t\t\tstruct flock64 *);\n#endif\n\nextern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);\nextern int fcntl_getlease(struct file *filp);\n\n/* fs/locks.c */\nvoid locks_free_lock_context(struct inode *inode);\nvoid locks_free_lock(struct file_lock *fl);\nextern void locks_init_lock(struct file_lock *);\nextern struct file_lock * locks_alloc_lock(void);\nextern void locks_copy_lock(struct file_lock *, struct file_lock *);\nextern void locks_copy_conflock(struct file_lock *, struct file_lock *);\nextern void locks_remove_posix(struct file *, fl_owner_t);\nextern void locks_remove_file(struct file *);\nextern void locks_release_private(struct file_lock *);\nextern void posix_test_lock(struct file *, struct file_lock *);\nextern int posix_lock_file(struct file *, struct file_lock *, struct file_lock *);\nextern int locks_delete_block(struct file_lock *);\nextern int vfs_test_lock(struct file *, struct file_lock *);\nextern int vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct file_lock *);\nextern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);\nextern int locks_lock_inode_wait(struct inode *inode, struct file_lock *fl);\nextern int __break_lease(struct inode *inode, unsigned int flags, unsigned int type);\nextern void lease_get_mtime(struct inode *, struct timespec64 *time);\nextern int generic_setlease(struct file *, long, struct file_lock **, void **priv);\nextern int vfs_setlease(struct file *, long, struct file_lock **, void **);\nextern int lease_modify(struct file_lock *, int, struct list_head *);\n\nstruct notifier_block;\nextern int lease_register_notifier(struct notifier_block *);\nextern void lease_unregister_notifier(struct notifier_block *);\n\nstruct files_struct;\nextern void show_fd_locks(struct seq_file *f,\n\t\t\t struct file *filp, struct files_struct *files);\n#else /* !CONFIG_FILE_LOCKING */\nstatic inline int fcntl_getlk(struct file *file, unsigned int cmd,\n\t\t\t      struct flock __user *user)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int fcntl_setlk(unsigned int fd, struct file *file,\n\t\t\t      unsigned int cmd, struct flock __user *user)\n{\n\treturn -EACCES;\n}\n\n#if BITS_PER_LONG == 32\nstatic inline int fcntl_getlk64(struct file *file, unsigned int cmd,\n\t\t\t\tstruct flock64 __user *user)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int fcntl_setlk64(unsigned int fd, struct file *file,\n\t\t\t\tunsigned int cmd, struct flock64 __user *user)\n{\n\treturn -EACCES;\n}\n#endif\nstatic inline int fcntl_setlease(unsigned int fd, struct file *filp, long arg)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int fcntl_getlease(struct file *filp)\n{\n\treturn F_UNLCK;\n}\n\nstatic inline void\nlocks_free_lock_context(struct inode *inode)\n{\n}\n\nstatic inline void locks_init_lock(struct file_lock *fl)\n{\n\treturn;\n}\n\nstatic inline void locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\treturn;\n}\n\nstatic inline void locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\treturn;\n}\n\nstatic inline void locks_remove_posix(struct file *filp, fl_owner_t owner)\n{\n\treturn;\n}\n\nstatic inline void locks_remove_file(struct file *filp)\n{\n\treturn;\n}\n\nstatic inline void posix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\treturn;\n}\n\nstatic inline int posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\t\t  struct file_lock *conflock)\n{\n\treturn -ENOLCK;\n}\n\nstatic inline int locks_delete_block(struct file_lock *waiter)\n{\n\treturn -ENOENT;\n}\n\nstatic inline int vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\treturn 0;\n}\n\nstatic inline int vfs_lock_file(struct file *filp, unsigned int cmd,\n\t\t\t\tstruct file_lock *fl, struct file_lock *conf)\n{\n\treturn -ENOLCK;\n}\n\nstatic inline int vfs_cancel_lock(struct file *filp, struct file_lock *fl)\n{\n\treturn 0;\n}\n\nstatic inline int locks_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\treturn -ENOLCK;\n}\n\nstatic inline int __break_lease(struct inode *inode, unsigned int mode, unsigned int type)\n{\n\treturn 0;\n}\n\nstatic inline void lease_get_mtime(struct inode *inode,\n\t\t\t\t   struct timespec64 *time)\n{\n\treturn;\n}\n\nstatic inline int generic_setlease(struct file *filp, long arg,\n\t\t\t\t    struct file_lock **flp, void **priv)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int vfs_setlease(struct file *filp, long arg,\n\t\t\t       struct file_lock **lease, void **priv)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int lease_modify(struct file_lock *fl, int arg,\n\t\t\t       struct list_head *dispose)\n{\n\treturn -EINVAL;\n}\n\nstruct files_struct;\nstatic inline void show_fd_locks(struct seq_file *f,\n\t\t\tstruct file *filp, struct files_struct *files) {}\n#endif /* !CONFIG_FILE_LOCKING */\n\nstatic inline struct inode *file_inode(const struct file *f)\n{\n\treturn f->f_inode;\n}\n\nstatic inline struct dentry *file_dentry(const struct file *file)\n{\n\treturn d_real(file->f_path.dentry, file_inode(file));\n}\n\nstatic inline int locks_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\treturn locks_lock_inode_wait(locks_inode(filp), fl);\n}\n\nstruct fasync_struct {\n\trwlock_t\t\tfa_lock;\n\tint\t\t\tmagic;\n\tint\t\t\tfa_fd;\n\tstruct fasync_struct\t*fa_next; /* singly linked list */\n\tstruct file\t\t*fa_file;\n\tstruct rcu_head\t\tfa_rcu;\n};\n\n#define FASYNC_MAGIC 0x4601\n\n/* SMP safe fasync helpers: */\nextern int fasync_helper(int, struct file *, int, struct fasync_struct **);\nextern struct fasync_struct *fasync_insert_entry(int, struct file *, struct fasync_struct **, struct fasync_struct *);\nextern int fasync_remove_entry(struct file *, struct fasync_struct **);\nextern struct fasync_struct *fasync_alloc(void);\nextern void fasync_free(struct fasync_struct *);\n\n/* can be called from interrupts */\nextern void kill_fasync(struct fasync_struct **, int, int);\n\nextern void __f_setown(struct file *filp, struct pid *, enum pid_type, int force);\nextern int f_setown(struct file *filp, unsigned long arg, int force);\nextern void f_delown(struct file *filp);\nextern pid_t f_getown(struct file *filp);\nextern int send_sigurg(struct fown_struct *fown);\n\n/*\n * sb->s_flags.  Note that these mirror the equivalent MS_* flags where\n * represented in both.\n */\n#define SB_RDONLY\t 1\t/* Mount read-only */\n#define SB_NOSUID\t 2\t/* Ignore suid and sgid bits */\n#define SB_NODEV\t 4\t/* Disallow access to device special files */\n#define SB_NOEXEC\t 8\t/* Disallow program execution */\n#define SB_SYNCHRONOUS\t16\t/* Writes are synced at once */\n#define SB_MANDLOCK\t64\t/* Allow mandatory locks on an FS */\n#define SB_DIRSYNC\t128\t/* Directory modifications are synchronous */\n#define SB_NOATIME\t1024\t/* Do not update access times. */\n#define SB_NODIRATIME\t2048\t/* Do not update directory access times */\n#define SB_SILENT\t32768\n#define SB_POSIXACL\t(1<<16)\t/* VFS does not apply the umask */\n#define SB_INLINECRYPT\t(1<<17)\t/* Use blk-crypto for encrypted files */\n#define SB_KERNMOUNT\t(1<<22) /* this is a kern_mount call */\n#define SB_I_VERSION\t(1<<23) /* Update inode I_version field */\n#define SB_LAZYTIME\t(1<<25) /* Update the on-disk [acm]times lazily */\n\n/* These sb flags are internal to the kernel */\n#define SB_SUBMOUNT     (1<<26)\n#define SB_FORCE    \t(1<<27)\n#define SB_NOSEC\t(1<<28)\n#define SB_BORN\t\t(1<<29)\n#define SB_ACTIVE\t(1<<30)\n#define SB_NOUSER\t(1<<31)\n\n/* These flags relate to encoding and casefolding */\n#define SB_ENC_STRICT_MODE_FL\t(1 << 0)\n\n#define sb_has_strict_encoding(sb) \\\n\t(sb->s_encoding_flags & SB_ENC_STRICT_MODE_FL)\n\n/*\n *\tUmount options\n */\n\n#define MNT_FORCE\t0x00000001\t/* Attempt to forcibily umount */\n#define MNT_DETACH\t0x00000002\t/* Just detach from the tree */\n#define MNT_EXPIRE\t0x00000004\t/* Mark for expiry */\n#define UMOUNT_NOFOLLOW\t0x00000008\t/* Don't follow symlink on umount */\n#define UMOUNT_UNUSED\t0x80000000\t/* Flag guaranteed to be unused */\n\n/* sb->s_iflags */\n#define SB_I_CGROUPWB\t0x00000001\t/* cgroup-aware writeback enabled */\n#define SB_I_NOEXEC\t0x00000002\t/* Ignore executables on this fs */\n#define SB_I_NODEV\t0x00000004\t/* Ignore devices on this fs */\n#define SB_I_STABLE_WRITES 0x00000008\t/* don't modify blks until WB is done */\n\n/* sb->s_iflags to limit user namespace mounts */\n#define SB_I_USERNS_VISIBLE\t\t0x00000010 /* fstype already mounted */\n#define SB_I_IMA_UNVERIFIABLE_SIGNATURE\t0x00000020\n#define SB_I_UNTRUSTED_MOUNTER\t\t0x00000040\n\n#define SB_I_SKIP_SYNC\t0x00000100\t/* Skip superblock at global sync */\n\n/* Possible states of 'frozen' field */\nenum {\n\tSB_UNFROZEN = 0,\t\t/* FS is unfrozen */\n\tSB_FREEZE_WRITE\t= 1,\t\t/* Writes, dir ops, ioctls frozen */\n\tSB_FREEZE_PAGEFAULT = 2,\t/* Page faults stopped as well */\n\tSB_FREEZE_FS = 3,\t\t/* For internal FS use (e.g. to stop\n\t\t\t\t\t * internal threads if needed) */\n\tSB_FREEZE_COMPLETE = 4,\t\t/* ->freeze_fs finished successfully */\n};\n\n#define SB_FREEZE_LEVELS (SB_FREEZE_COMPLETE - 1)\n\nstruct sb_writers {\n\tint\t\t\t\tfrozen;\t\t/* Is sb frozen? */\n\twait_queue_head_t\t\twait_unfrozen;\t/* wait for thaw */\n\tstruct percpu_rw_semaphore\trw_sem[SB_FREEZE_LEVELS];\n};\n\nstruct super_block {\n\tstruct list_head\ts_list;\t\t/* Keep this first */\n\tdev_t\t\t\ts_dev;\t\t/* search index; _not_ kdev_t */\n\tunsigned char\t\ts_blocksize_bits;\n\tunsigned long\t\ts_blocksize;\n\tloff_t\t\t\ts_maxbytes;\t/* Max file size */\n\tstruct file_system_type\t*s_type;\n\tconst struct super_operations\t*s_op;\n\tconst struct dquot_operations\t*dq_op;\n\tconst struct quotactl_ops\t*s_qcop;\n\tconst struct export_operations *s_export_op;\n\tunsigned long\t\ts_flags;\n\tunsigned long\t\ts_iflags;\t/* internal SB_I_* flags */\n\tunsigned long\t\ts_magic;\n\tstruct dentry\t\t*s_root;\n\tstruct rw_semaphore\ts_umount;\n\tint\t\t\ts_count;\n\tatomic_t\t\ts_active;\n#ifdef CONFIG_SECURITY\n\tvoid                    *s_security;\n#endif\n\tconst struct xattr_handler **s_xattr;\n#ifdef CONFIG_FS_ENCRYPTION\n\tconst struct fscrypt_operations\t*s_cop;\n\tstruct key\t\t*s_master_keys; /* master crypto keys in use */\n#endif\n#ifdef CONFIG_FS_VERITY\n\tconst struct fsverity_operations *s_vop;\n#endif\n#ifdef CONFIG_UNICODE\n\tstruct unicode_map *s_encoding;\n\t__u16 s_encoding_flags;\n#endif\n\tstruct hlist_bl_head\ts_roots;\t/* alternate root dentries for NFS */\n\tstruct list_head\ts_mounts;\t/* list of mounts; _not_ for fs use */\n\tstruct block_device\t*s_bdev;\n\tstruct backing_dev_info *s_bdi;\n\tstruct mtd_info\t\t*s_mtd;\n\tstruct hlist_node\ts_instances;\n\tunsigned int\t\ts_quota_types;\t/* Bitmask of supported quota types */\n\tstruct quota_info\ts_dquot;\t/* Diskquota specific options */\n\n\tstruct sb_writers\ts_writers;\n\n\t/*\n\t * Keep s_fs_info, s_time_gran, s_fsnotify_mask, and\n\t * s_fsnotify_marks together for cache efficiency. They are frequently\n\t * accessed and rarely modified.\n\t */\n\tvoid\t\t\t*s_fs_info;\t/* Filesystem private info */\n\n\t/* Granularity of c/m/atime in ns (cannot be worse than a second) */\n\tu32\t\t\ts_time_gran;\n\t/* Time limits for c/m/atime in seconds */\n\ttime64_t\t\t   s_time_min;\n\ttime64_t\t\t   s_time_max;\n#ifdef CONFIG_FSNOTIFY\n\t__u32\t\t\ts_fsnotify_mask;\n\tstruct fsnotify_mark_connector __rcu\t*s_fsnotify_marks;\n#endif\n\n\tchar\t\t\ts_id[32];\t/* Informational name */\n\tuuid_t\t\t\ts_uuid;\t\t/* UUID */\n\n\tunsigned int\t\ts_max_links;\n\tfmode_t\t\t\ts_mode;\n\n\t/*\n\t * The next field is for VFS *only*. No filesystems have any business\n\t * even looking at it. You had been warned.\n\t */\n\tstruct mutex s_vfs_rename_mutex;\t/* Kludge */\n\n\t/*\n\t * Filesystem subtype.  If non-empty the filesystem type field\n\t * in /proc/mounts will be \"type.subtype\"\n\t */\n\tconst char *s_subtype;\n\n\tconst struct dentry_operations *s_d_op; /* default d_op for dentries */\n\n\t/*\n\t * Saved pool identifier for cleancache (-1 means none)\n\t */\n\tint cleancache_poolid;\n\n\tstruct shrinker s_shrink;\t/* per-sb shrinker handle */\n\n\t/* Number of inodes with nlink == 0 but still referenced */\n\tatomic_long_t s_remove_count;\n\n\t/* Pending fsnotify inode refs */\n\tatomic_long_t s_fsnotify_inode_refs;\n\n\t/* Being remounted read-only */\n\tint s_readonly_remount;\n\n\t/* per-sb errseq_t for reporting writeback errors via syncfs */\n\terrseq_t s_wb_err;\n\n\t/* AIO completions deferred from interrupt context */\n\tstruct workqueue_struct *s_dio_done_wq;\n\tstruct hlist_head s_pins;\n\n\t/*\n\t * Owning user namespace and default context in which to\n\t * interpret filesystem uids, gids, quotas, device nodes,\n\t * xattrs and security labels.\n\t */\n\tstruct user_namespace *s_user_ns;\n\n\t/*\n\t * The list_lru structure is essentially just a pointer to a table\n\t * of per-node lru lists, each of which has its own spinlock.\n\t * There is no need to put them into separate cachelines.\n\t */\n\tstruct list_lru\t\ts_dentry_lru;\n\tstruct list_lru\t\ts_inode_lru;\n\tstruct rcu_head\t\trcu;\n\tstruct work_struct\tdestroy_work;\n\n\tstruct mutex\t\ts_sync_lock;\t/* sync serialisation lock */\n\n\t/*\n\t * Indicates how deep in a filesystem stack this SB is\n\t */\n\tint s_stack_depth;\n\n\t/* s_inode_list_lock protects s_inodes */\n\tspinlock_t\t\ts_inode_list_lock ____cacheline_aligned_in_smp;\n\tstruct list_head\ts_inodes;\t/* all inodes */\n\n\tspinlock_t\t\ts_inode_wblist_lock;\n\tstruct list_head\ts_inodes_wb;\t/* writeback inodes */\n} __randomize_layout;\n\n/* Helper functions so that in most cases filesystems will\n * not need to deal directly with kuid_t and kgid_t and can\n * instead deal with the raw numeric values that are stored\n * in the filesystem.\n */\nstatic inline uid_t i_uid_read(const struct inode *inode)\n{\n\treturn from_kuid(inode->i_sb->s_user_ns, inode->i_uid);\n}\n\nstatic inline gid_t i_gid_read(const struct inode *inode)\n{\n\treturn from_kgid(inode->i_sb->s_user_ns, inode->i_gid);\n}\n\nstatic inline void i_uid_write(struct inode *inode, uid_t uid)\n{\n\tinode->i_uid = make_kuid(inode->i_sb->s_user_ns, uid);\n}\n\nstatic inline void i_gid_write(struct inode *inode, gid_t gid)\n{\n\tinode->i_gid = make_kgid(inode->i_sb->s_user_ns, gid);\n}\n\n/**\n * kuid_into_mnt - map a kuid down into a mnt_userns\n * @mnt_userns: user namespace of the relevant mount\n * @kuid: kuid to be mapped\n *\n * Return: @kuid mapped according to @mnt_userns.\n * If @kuid has no mapping INVALID_UID is returned.\n */\nstatic inline kuid_t kuid_into_mnt(struct user_namespace *mnt_userns,\n\t\t\t\t   kuid_t kuid)\n{\n\treturn make_kuid(mnt_userns, __kuid_val(kuid));\n}\n\n/**\n * kgid_into_mnt - map a kgid down into a mnt_userns\n * @mnt_userns: user namespace of the relevant mount\n * @kgid: kgid to be mapped\n *\n * Return: @kgid mapped according to @mnt_userns.\n * If @kgid has no mapping INVALID_GID is returned.\n */\nstatic inline kgid_t kgid_into_mnt(struct user_namespace *mnt_userns,\n\t\t\t\t   kgid_t kgid)\n{\n\treturn make_kgid(mnt_userns, __kgid_val(kgid));\n}\n\n/**\n * i_uid_into_mnt - map an inode's i_uid down into a mnt_userns\n * @mnt_userns: user namespace of the mount the inode was found from\n * @inode: inode to map\n *\n * Return: the inode's i_uid mapped down according to @mnt_userns.\n * If the inode's i_uid has no mapping INVALID_UID is returned.\n */\nstatic inline kuid_t i_uid_into_mnt(struct user_namespace *mnt_userns,\n\t\t\t\t    const struct inode *inode)\n{\n\treturn kuid_into_mnt(mnt_userns, inode->i_uid);\n}\n\n/**\n * i_gid_into_mnt - map an inode's i_gid down into a mnt_userns\n * @mnt_userns: user namespace of the mount the inode was found from\n * @inode: inode to map\n *\n * Return: the inode's i_gid mapped down according to @mnt_userns.\n * If the inode's i_gid has no mapping INVALID_GID is returned.\n */\nstatic inline kgid_t i_gid_into_mnt(struct user_namespace *mnt_userns,\n\t\t\t\t    const struct inode *inode)\n{\n\treturn kgid_into_mnt(mnt_userns, inode->i_gid);\n}\n\n/**\n * kuid_from_mnt - map a kuid up into a mnt_userns\n * @mnt_userns: user namespace of the relevant mount\n * @kuid: kuid to be mapped\n *\n * Return: @kuid mapped up according to @mnt_userns.\n * If @kuid has no mapping INVALID_UID is returned.\n */\nstatic inline kuid_t kuid_from_mnt(struct user_namespace *mnt_userns,\n\t\t\t\t   kuid_t kuid)\n{\n\treturn KUIDT_INIT(from_kuid(mnt_userns, kuid));\n}\n\n/**\n * kgid_from_mnt - map a kgid up into a mnt_userns\n * @mnt_userns: user namespace of the relevant mount\n * @kgid: kgid to be mapped\n *\n * Return: @kgid mapped up according to @mnt_userns.\n * If @kgid has no mapping INVALID_GID is returned.\n */\nstatic inline kgid_t kgid_from_mnt(struct user_namespace *mnt_userns,\n\t\t\t\t   kgid_t kgid)\n{\n\treturn KGIDT_INIT(from_kgid(mnt_userns, kgid));\n}\n\n/**\n * mapped_fsuid - return caller's fsuid mapped up into a mnt_userns\n * @mnt_userns: user namespace of the relevant mount\n *\n * Use this helper to initialize a new vfs or filesystem object based on\n * the caller's fsuid. A common example is initializing the i_uid field of\n * a newly allocated inode triggered by a creation event such as mkdir or\n * O_CREAT. Other examples include the allocation of quotas for a specific\n * user.\n *\n * Return: the caller's current fsuid mapped up according to @mnt_userns.\n */\nstatic inline kuid_t mapped_fsuid(struct user_namespace *mnt_userns)\n{\n\treturn kuid_from_mnt(mnt_userns, current_fsuid());\n}\n\n/**\n * mapped_fsgid - return caller's fsgid mapped up into a mnt_userns\n * @mnt_userns: user namespace of the relevant mount\n *\n * Use this helper to initialize a new vfs or filesystem object based on\n * the caller's fsgid. A common example is initializing the i_gid field of\n * a newly allocated inode triggered by a creation event such as mkdir or\n * O_CREAT. Other examples include the allocation of quotas for a specific\n * user.\n *\n * Return: the caller's current fsgid mapped up according to @mnt_userns.\n */\nstatic inline kgid_t mapped_fsgid(struct user_namespace *mnt_userns)\n{\n\treturn kgid_from_mnt(mnt_userns, current_fsgid());\n}\n\n/**\n * inode_fsuid_set - initialize inode's i_uid field with callers fsuid\n * @inode: inode to initialize\n * @mnt_userns: user namespace of the mount the inode was found from\n *\n * Initialize the i_uid field of @inode. If the inode was found/created via\n * an idmapped mount map the caller's fsuid according to @mnt_users.\n */\nstatic inline void inode_fsuid_set(struct inode *inode,\n\t\t\t\t   struct user_namespace *mnt_userns)\n{\n\tinode->i_uid = mapped_fsuid(mnt_userns);\n}\n\n/**\n * inode_fsgid_set - initialize inode's i_gid field with callers fsgid\n * @inode: inode to initialize\n * @mnt_userns: user namespace of the mount the inode was found from\n *\n * Initialize the i_gid field of @inode. If the inode was found/created via\n * an idmapped mount map the caller's fsgid according to @mnt_users.\n */\nstatic inline void inode_fsgid_set(struct inode *inode,\n\t\t\t\t   struct user_namespace *mnt_userns)\n{\n\tinode->i_gid = mapped_fsgid(mnt_userns);\n}\n\n/**\n * fsuidgid_has_mapping() - check whether caller's fsuid/fsgid is mapped\n * @sb: the superblock we want a mapping in\n * @mnt_userns: user namespace of the relevant mount\n *\n * Check whether the caller's fsuid and fsgid have a valid mapping in the\n * s_user_ns of the superblock @sb. If the caller is on an idmapped mount map\n * the caller's fsuid and fsgid according to the @mnt_userns first.\n *\n * Return: true if fsuid and fsgid is mapped, false if not.\n */\nstatic inline bool fsuidgid_has_mapping(struct super_block *sb,\n\t\t\t\t\tstruct user_namespace *mnt_userns)\n{\n\tstruct user_namespace *s_user_ns = sb->s_user_ns;\n\n\treturn kuid_has_mapping(s_user_ns, mapped_fsuid(mnt_userns)) &&\n\t       kgid_has_mapping(s_user_ns, mapped_fsgid(mnt_userns));\n}\n\nextern struct timespec64 current_time(struct inode *inode);\n\n/*\n * Snapshotting support.\n */\n\n/*\n * These are internal functions, please use sb_start_{write,pagefault,intwrite}\n * instead.\n */\nstatic inline void __sb_end_write(struct super_block *sb, int level)\n{\n\tpercpu_up_read(sb->s_writers.rw_sem + level-1);\n}\n\nstatic inline void __sb_start_write(struct super_block *sb, int level)\n{\n\tpercpu_down_read(sb->s_writers.rw_sem + level - 1);\n}\n\nstatic inline bool __sb_start_write_trylock(struct super_block *sb, int level)\n{\n\treturn percpu_down_read_trylock(sb->s_writers.rw_sem + level - 1);\n}\n\n#define __sb_writers_acquired(sb, lev)\t\\\n\tpercpu_rwsem_acquire(&(sb)->s_writers.rw_sem[(lev)-1], 1, _THIS_IP_)\n#define __sb_writers_release(sb, lev)\t\\\n\tpercpu_rwsem_release(&(sb)->s_writers.rw_sem[(lev)-1], 1, _THIS_IP_)\n\n/**\n * sb_end_write - drop write access to a superblock\n * @sb: the super we wrote to\n *\n * Decrement number of writers to the filesystem. Wake up possible waiters\n * wanting to freeze the filesystem.\n */\nstatic inline void sb_end_write(struct super_block *sb)\n{\n\t__sb_end_write(sb, SB_FREEZE_WRITE);\n}\n\n/**\n * sb_end_pagefault - drop write access to a superblock from a page fault\n * @sb: the super we wrote to\n *\n * Decrement number of processes handling write page fault to the filesystem.\n * Wake up possible waiters wanting to freeze the filesystem.\n */\nstatic inline void sb_end_pagefault(struct super_block *sb)\n{\n\t__sb_end_write(sb, SB_FREEZE_PAGEFAULT);\n}\n\n/**\n * sb_end_intwrite - drop write access to a superblock for internal fs purposes\n * @sb: the super we wrote to\n *\n * Decrement fs-internal number of writers to the filesystem.  Wake up possible\n * waiters wanting to freeze the filesystem.\n */\nstatic inline void sb_end_intwrite(struct super_block *sb)\n{\n\t__sb_end_write(sb, SB_FREEZE_FS);\n}\n\n/**\n * sb_start_write - get write access to a superblock\n * @sb: the super we write to\n *\n * When a process wants to write data or metadata to a file system (i.e. dirty\n * a page or an inode), it should embed the operation in a sb_start_write() -\n * sb_end_write() pair to get exclusion against file system freezing. This\n * function increments number of writers preventing freezing. If the file\n * system is already frozen, the function waits until the file system is\n * thawed.\n *\n * Since freeze protection behaves as a lock, users have to preserve\n * ordering of freeze protection and other filesystem locks. Generally,\n * freeze protection should be the outermost lock. In particular, we have:\n *\n * sb_start_write\n *   -> i_mutex\t\t\t(write path, truncate, directory ops, ...)\n *   -> s_umount\t\t(freeze_super, thaw_super)\n */\nstatic inline void sb_start_write(struct super_block *sb)\n{\n\t__sb_start_write(sb, SB_FREEZE_WRITE);\n}\n\nstatic inline bool sb_start_write_trylock(struct super_block *sb)\n{\n\treturn __sb_start_write_trylock(sb, SB_FREEZE_WRITE);\n}\n\n/**\n * sb_start_pagefault - get write access to a superblock from a page fault\n * @sb: the super we write to\n *\n * When a process starts handling write page fault, it should embed the\n * operation into sb_start_pagefault() - sb_end_pagefault() pair to get\n * exclusion against file system freezing. This is needed since the page fault\n * is going to dirty a page. This function increments number of running page\n * faults preventing freezing. If the file system is already frozen, the\n * function waits until the file system is thawed.\n *\n * Since page fault freeze protection behaves as a lock, users have to preserve\n * ordering of freeze protection and other filesystem locks. It is advised to\n * put sb_start_pagefault() close to mmap_lock in lock ordering. Page fault\n * handling code implies lock dependency:\n *\n * mmap_lock\n *   -> sb_start_pagefault\n */\nstatic inline void sb_start_pagefault(struct super_block *sb)\n{\n\t__sb_start_write(sb, SB_FREEZE_PAGEFAULT);\n}\n\n/**\n * sb_start_intwrite - get write access to a superblock for internal fs purposes\n * @sb: the super we write to\n *\n * This is the third level of protection against filesystem freezing. It is\n * free for use by a filesystem. The only requirement is that it must rank\n * below sb_start_pagefault.\n *\n * For example filesystem can call sb_start_intwrite() when starting a\n * transaction which somewhat eases handling of freezing for internal sources\n * of filesystem changes (internal fs threads, discarding preallocation on file\n * close, etc.).\n */\nstatic inline void sb_start_intwrite(struct super_block *sb)\n{\n\t__sb_start_write(sb, SB_FREEZE_FS);\n}\n\nstatic inline bool sb_start_intwrite_trylock(struct super_block *sb)\n{\n\treturn __sb_start_write_trylock(sb, SB_FREEZE_FS);\n}\n\nbool inode_owner_or_capable(struct user_namespace *mnt_userns,\n\t\t\t    const struct inode *inode);\n\n/*\n * VFS helper functions..\n */\nint vfs_create(struct user_namespace *, struct inode *,\n\t       struct dentry *, umode_t, bool);\nint vfs_mkdir(struct user_namespace *, struct inode *,\n\t      struct dentry *, umode_t);\nint vfs_mknod(struct user_namespace *, struct inode *, struct dentry *,\n              umode_t, dev_t);\nint vfs_symlink(struct user_namespace *, struct inode *,\n\t\tstruct dentry *, const char *);\nint vfs_link(struct dentry *, struct user_namespace *, struct inode *,\n\t     struct dentry *, struct inode **);\nint vfs_rmdir(struct user_namespace *, struct inode *, struct dentry *);\nint vfs_unlink(struct user_namespace *, struct inode *, struct dentry *,\n\t       struct inode **);\n\n/**\n * struct renamedata - contains all information required for renaming\n * @old_mnt_userns:    old user namespace of the mount the inode was found from\n * @old_dir:           parent of source\n * @old_dentry:                source\n * @new_mnt_userns:    new user namespace of the mount the inode was found from\n * @new_dir:           parent of destination\n * @new_dentry:                destination\n * @delegated_inode:   returns an inode needing a delegation break\n * @flags:             rename flags\n */\nstruct renamedata {\n\tstruct user_namespace *old_mnt_userns;\n\tstruct inode *old_dir;\n\tstruct dentry *old_dentry;\n\tstruct user_namespace *new_mnt_userns;\n\tstruct inode *new_dir;\n\tstruct dentry *new_dentry;\n\tstruct inode **delegated_inode;\n\tunsigned int flags;\n} __randomize_layout;\n\nint vfs_rename(struct renamedata *);\n\nstatic inline int vfs_whiteout(struct user_namespace *mnt_userns,\n\t\t\t       struct inode *dir, struct dentry *dentry)\n{\n\treturn vfs_mknod(mnt_userns, dir, dentry, S_IFCHR | WHITEOUT_MODE,\n\t\t\t WHITEOUT_DEV);\n}\n\nstruct dentry *vfs_tmpfile(struct user_namespace *mnt_userns,\n\t\t\t   struct dentry *dentry, umode_t mode, int open_flag);\n\nint vfs_mkobj(struct dentry *, umode_t,\n\t\tint (*f)(struct dentry *, umode_t, void *),\n\t\tvoid *);\n\nint vfs_fchown(struct file *file, uid_t user, gid_t group);\nint vfs_fchmod(struct file *file, umode_t mode);\nint vfs_utimes(const struct path *path, struct timespec64 *times);\n\nextern long vfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\n\n#ifdef CONFIG_COMPAT\nextern long compat_ptr_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\tunsigned long arg);\n#else\n#define compat_ptr_ioctl NULL\n#endif\n\n/*\n * VFS file helper functions.\n */\nvoid inode_init_owner(struct user_namespace *mnt_userns, struct inode *inode,\n\t\t      const struct inode *dir, umode_t mode);\nextern bool may_open_dev(const struct path *path);\n\n/*\n * This is the \"filldir\" function type, used by readdir() to let\n * the kernel specify what kind of dirent layout it wants to have.\n * This allows the kernel to read directories into kernel space or\n * to have different dirent layouts depending on the binary type.\n */\nstruct dir_context;\ntypedef int (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64,\n\t\t\t unsigned);\n\nstruct dir_context {\n\tfilldir_t actor;\n\tloff_t pos;\n};\n\n/*\n * These flags let !MMU mmap() govern direct device mapping vs immediate\n * copying more easily for MAP_PRIVATE, especially for ROM filesystems.\n *\n * NOMMU_MAP_COPY:\tCopy can be mapped (MAP_PRIVATE)\n * NOMMU_MAP_DIRECT:\tCan be mapped directly (MAP_SHARED)\n * NOMMU_MAP_READ:\tCan be mapped for reading\n * NOMMU_MAP_WRITE:\tCan be mapped for writing\n * NOMMU_MAP_EXEC:\tCan be mapped for execution\n */\n#define NOMMU_MAP_COPY\t\t0x00000001\n#define NOMMU_MAP_DIRECT\t0x00000008\n#define NOMMU_MAP_READ\t\tVM_MAYREAD\n#define NOMMU_MAP_WRITE\t\tVM_MAYWRITE\n#define NOMMU_MAP_EXEC\t\tVM_MAYEXEC\n\n#define NOMMU_VMFLAGS \\\n\t(NOMMU_MAP_READ | NOMMU_MAP_WRITE | NOMMU_MAP_EXEC)\n\n/*\n * These flags control the behavior of the remap_file_range function pointer.\n * If it is called with len == 0 that means \"remap to end of source file\".\n * See Documentation/filesystems/vfs.rst for more details about this call.\n *\n * REMAP_FILE_DEDUP: only remap if contents identical (i.e. deduplicate)\n * REMAP_FILE_CAN_SHORTEN: caller can handle a shortened request\n */\n#define REMAP_FILE_DEDUP\t\t(1 << 0)\n#define REMAP_FILE_CAN_SHORTEN\t\t(1 << 1)\n\n/*\n * These flags signal that the caller is ok with altering various aspects of\n * the behavior of the remap operation.  The changes must be made by the\n * implementation; the vfs remap helper functions can take advantage of them.\n * Flags in this category exist to preserve the quirky behavior of the hoisted\n * btrfs clone/dedupe ioctls.\n */\n#define REMAP_FILE_ADVISORY\t\t(REMAP_FILE_CAN_SHORTEN)\n\nstruct iov_iter;\n\nstruct file_operations {\n\tstruct module *owner;\n\tloff_t (*llseek) (struct file *, loff_t, int);\n\tssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\n\tssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\n\tssize_t (*read_iter) (struct kiocb *, struct iov_iter *);\n\tssize_t (*write_iter) (struct kiocb *, struct iov_iter *);\n\tint (*iopoll)(struct kiocb *kiocb, bool spin);\n\tint (*iterate) (struct file *, struct dir_context *);\n\tint (*iterate_shared) (struct file *, struct dir_context *);\n\t__poll_t (*poll) (struct file *, struct poll_table_struct *);\n\tlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\n\tlong (*compat_ioctl) (struct file *, unsigned int, unsigned long);\n\tint (*mmap) (struct file *, struct vm_area_struct *);\n\tunsigned long mmap_supported_flags;\n\tint (*open) (struct inode *, struct file *);\n\tint (*flush) (struct file *, fl_owner_t id);\n\tint (*release) (struct inode *, struct file *);\n\tint (*fsync) (struct file *, loff_t, loff_t, int datasync);\n\tint (*fasync) (int, struct file *, int);\n\tint (*lock) (struct file *, int, struct file_lock *);\n\tssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);\n\tunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);\n\tint (*check_flags)(int);\n\tint (*flock) (struct file *, int, struct file_lock *);\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);\n\tssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);\n\tint (*setlease)(struct file *, long, struct file_lock **, void **);\n\tlong (*fallocate)(struct file *file, int mode, loff_t offset,\n\t\t\t  loff_t len);\n\tvoid (*show_fdinfo)(struct seq_file *m, struct file *f);\n#ifndef CONFIG_MMU\n\tunsigned (*mmap_capabilities)(struct file *);\n#endif\n\tssize_t (*copy_file_range)(struct file *, loff_t, struct file *,\n\t\t\tloff_t, size_t, unsigned int);\n\tloff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,\n\t\t\t\t   struct file *file_out, loff_t pos_out,\n\t\t\t\t   loff_t len, unsigned int remap_flags);\n\tint (*fadvise)(struct file *, loff_t, loff_t, int);\n} __randomize_layout;\n\nstruct inode_operations {\n\tstruct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);\n\tconst char * (*get_link) (struct dentry *, struct inode *, struct delayed_call *);\n\tint (*permission) (struct user_namespace *, struct inode *, int);\n\tstruct posix_acl * (*get_acl)(struct inode *, int);\n\n\tint (*readlink) (struct dentry *, char __user *,int);\n\n\tint (*create) (struct user_namespace *, struct inode *,struct dentry *,\n\t\t       umode_t, bool);\n\tint (*link) (struct dentry *,struct inode *,struct dentry *);\n\tint (*unlink) (struct inode *,struct dentry *);\n\tint (*symlink) (struct user_namespace *, struct inode *,struct dentry *,\n\t\t\tconst char *);\n\tint (*mkdir) (struct user_namespace *, struct inode *,struct dentry *,\n\t\t      umode_t);\n\tint (*rmdir) (struct inode *,struct dentry *);\n\tint (*mknod) (struct user_namespace *, struct inode *,struct dentry *,\n\t\t      umode_t,dev_t);\n\tint (*rename) (struct user_namespace *, struct inode *, struct dentry *,\n\t\t\tstruct inode *, struct dentry *, unsigned int);\n\tint (*setattr) (struct user_namespace *, struct dentry *,\n\t\t\tstruct iattr *);\n\tint (*getattr) (struct user_namespace *, const struct path *,\n\t\t\tstruct kstat *, u32, unsigned int);\n\tssize_t (*listxattr) (struct dentry *, char *, size_t);\n\tint (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,\n\t\t      u64 len);\n\tint (*update_time)(struct inode *, struct timespec64 *, int);\n\tint (*atomic_open)(struct inode *, struct dentry *,\n\t\t\t   struct file *, unsigned open_flag,\n\t\t\t   umode_t create_mode);\n\tint (*tmpfile) (struct user_namespace *, struct inode *,\n\t\t\tstruct dentry *, umode_t);\n\tint (*set_acl)(struct user_namespace *, struct inode *,\n\t\t       struct posix_acl *, int);\n} ____cacheline_aligned;\n\nstatic inline ssize_t call_read_iter(struct file *file, struct kiocb *kio,\n\t\t\t\t     struct iov_iter *iter)\n{\n\treturn file->f_op->read_iter(kio, iter);\n}\n\nstatic inline ssize_t call_write_iter(struct file *file, struct kiocb *kio,\n\t\t\t\t      struct iov_iter *iter)\n{\n\treturn file->f_op->write_iter(kio, iter);\n}\n\nstatic inline int call_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\treturn file->f_op->mmap(file, vma);\n}\n\nextern ssize_t vfs_read(struct file *, char __user *, size_t, loff_t *);\nextern ssize_t vfs_write(struct file *, const char __user *, size_t, loff_t *);\nextern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,\n\t\t\t\t   loff_t, size_t, unsigned int);\nextern ssize_t generic_copy_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t       struct file *file_out, loff_t pos_out,\n\t\t\t\t       size_t len, unsigned int flags);\nextern int generic_remap_file_range_prep(struct file *file_in, loff_t pos_in,\n\t\t\t\t\t struct file *file_out, loff_t pos_out,\n\t\t\t\t\t loff_t *count,\n\t\t\t\t\t unsigned int remap_flags);\nextern loff_t do_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t  struct file *file_out, loff_t pos_out,\n\t\t\t\t  loff_t len, unsigned int remap_flags);\nextern loff_t vfs_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t   struct file *file_out, loff_t pos_out,\n\t\t\t\t   loff_t len, unsigned int remap_flags);\nextern int vfs_dedupe_file_range(struct file *file,\n\t\t\t\t struct file_dedupe_range *same);\nextern loff_t vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,\n\t\t\t\t\tstruct file *dst_file, loff_t dst_pos,\n\t\t\t\t\tloff_t len, unsigned int remap_flags);\n\n\nstruct super_operations {\n   \tstruct inode *(*alloc_inode)(struct super_block *sb);\n\tvoid (*destroy_inode)(struct inode *);\n\tvoid (*free_inode)(struct inode *);\n\n   \tvoid (*dirty_inode) (struct inode *, int flags);\n\tint (*write_inode) (struct inode *, struct writeback_control *wbc);\n\tint (*drop_inode) (struct inode *);\n\tvoid (*evict_inode) (struct inode *);\n\tvoid (*put_super) (struct super_block *);\n\tint (*sync_fs)(struct super_block *sb, int wait);\n\tint (*freeze_super) (struct super_block *);\n\tint (*freeze_fs) (struct super_block *);\n\tint (*thaw_super) (struct super_block *);\n\tint (*unfreeze_fs) (struct super_block *);\n\tint (*statfs) (struct dentry *, struct kstatfs *);\n\tint (*remount_fs) (struct super_block *, int *, char *);\n\tvoid (*umount_begin) (struct super_block *);\n\n\tint (*show_options)(struct seq_file *, struct dentry *);\n\tint (*show_devname)(struct seq_file *, struct dentry *);\n\tint (*show_path)(struct seq_file *, struct dentry *);\n\tint (*show_stats)(struct seq_file *, struct dentry *);\n#ifdef CONFIG_QUOTA\n\tssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);\n\tssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);\n\tstruct dquot **(*get_dquots)(struct inode *);\n#endif\n\tint (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);\n\tlong (*nr_cached_objects)(struct super_block *,\n\t\t\t\t  struct shrink_control *);\n\tlong (*free_cached_objects)(struct super_block *,\n\t\t\t\t    struct shrink_control *);\n};\n\n/*\n * Inode flags - they have no relation to superblock flags now\n */\n#define S_SYNC\t\t(1 << 0)  /* Writes are synced at once */\n#define S_NOATIME\t(1 << 1)  /* Do not update access times */\n#define S_APPEND\t(1 << 2)  /* Append-only file */\n#define S_IMMUTABLE\t(1 << 3)  /* Immutable file */\n#define S_DEAD\t\t(1 << 4)  /* removed, but still open directory */\n#define S_NOQUOTA\t(1 << 5)  /* Inode is not counted to quota */\n#define S_DIRSYNC\t(1 << 6)  /* Directory modifications are synchronous */\n#define S_NOCMTIME\t(1 << 7)  /* Do not update file c/mtime */\n#define S_SWAPFILE\t(1 << 8)  /* Do not truncate: swapon got its bmaps */\n#define S_PRIVATE\t(1 << 9)  /* Inode is fs-internal */\n#define S_IMA\t\t(1 << 10) /* Inode has an associated IMA struct */\n#define S_AUTOMOUNT\t(1 << 11) /* Automount/referral quasi-directory */\n#define S_NOSEC\t\t(1 << 12) /* no suid or xattr security attributes */\n#ifdef CONFIG_FS_DAX\n#define S_DAX\t\t(1 << 13) /* Direct Access, avoiding the page cache */\n#else\n#define S_DAX\t\t0\t  /* Make all the DAX code disappear */\n#endif\n#define S_ENCRYPTED\t(1 << 14) /* Encrypted file (using fs/crypto/) */\n#define S_CASEFOLD\t(1 << 15) /* Casefolded file */\n#define S_VERITY\t(1 << 16) /* Verity file (using fs/verity/) */\n\n/*\n * Note that nosuid etc flags are inode-specific: setting some file-system\n * flags just means all the inodes inherit those flags by default. It might be\n * possible to override it selectively if you really wanted to with some\n * ioctl() that is not currently implemented.\n *\n * Exception: SB_RDONLY is always applied to the entire file system.\n *\n * Unfortunately, it is possible to change a filesystems flags with it mounted\n * with files in use.  This means that all of the inodes will not have their\n * i_flags updated.  Hence, i_flags no longer inherit the superblock mount\n * flags, so these have to be checked separately. -- rmk@arm.uk.linux.org\n */\n#define __IS_FLG(inode, flg)\t((inode)->i_sb->s_flags & (flg))\n\nstatic inline bool sb_rdonly(const struct super_block *sb) { return sb->s_flags & SB_RDONLY; }\n#define IS_RDONLY(inode)\tsb_rdonly((inode)->i_sb)\n#define IS_SYNC(inode)\t\t(__IS_FLG(inode, SB_SYNCHRONOUS) || \\\n\t\t\t\t\t((inode)->i_flags & S_SYNC))\n#define IS_DIRSYNC(inode)\t(__IS_FLG(inode, SB_SYNCHRONOUS|SB_DIRSYNC) || \\\n\t\t\t\t\t((inode)->i_flags & (S_SYNC|S_DIRSYNC)))\n#define IS_MANDLOCK(inode)\t__IS_FLG(inode, SB_MANDLOCK)\n#define IS_NOATIME(inode)\t__IS_FLG(inode, SB_RDONLY|SB_NOATIME)\n#define IS_I_VERSION(inode)\t__IS_FLG(inode, SB_I_VERSION)\n\n#define IS_NOQUOTA(inode)\t((inode)->i_flags & S_NOQUOTA)\n#define IS_APPEND(inode)\t((inode)->i_flags & S_APPEND)\n#define IS_IMMUTABLE(inode)\t((inode)->i_flags & S_IMMUTABLE)\n#define IS_POSIXACL(inode)\t__IS_FLG(inode, SB_POSIXACL)\n\n#define IS_DEADDIR(inode)\t((inode)->i_flags & S_DEAD)\n#define IS_NOCMTIME(inode)\t((inode)->i_flags & S_NOCMTIME)\n#define IS_SWAPFILE(inode)\t((inode)->i_flags & S_SWAPFILE)\n#define IS_PRIVATE(inode)\t((inode)->i_flags & S_PRIVATE)\n#define IS_IMA(inode)\t\t((inode)->i_flags & S_IMA)\n#define IS_AUTOMOUNT(inode)\t((inode)->i_flags & S_AUTOMOUNT)\n#define IS_NOSEC(inode)\t\t((inode)->i_flags & S_NOSEC)\n#define IS_DAX(inode)\t\t((inode)->i_flags & S_DAX)\n#define IS_ENCRYPTED(inode)\t((inode)->i_flags & S_ENCRYPTED)\n#define IS_CASEFOLDED(inode)\t((inode)->i_flags & S_CASEFOLD)\n#define IS_VERITY(inode)\t((inode)->i_flags & S_VERITY)\n\n#define IS_WHITEOUT(inode)\t(S_ISCHR(inode->i_mode) && \\\n\t\t\t\t (inode)->i_rdev == WHITEOUT_DEV)\n\nstatic inline bool HAS_UNMAPPED_ID(struct user_namespace *mnt_userns,\n\t\t\t\t   struct inode *inode)\n{\n\treturn !uid_valid(i_uid_into_mnt(mnt_userns, inode)) ||\n\t       !gid_valid(i_gid_into_mnt(mnt_userns, inode));\n}\n\nstatic inline enum rw_hint file_write_hint(struct file *file)\n{\n\tif (file->f_write_hint != WRITE_LIFE_NOT_SET)\n\t\treturn file->f_write_hint;\n\n\treturn file_inode(file)->i_write_hint;\n}\n\nstatic inline int iocb_flags(struct file *file);\n\nstatic inline u16 ki_hint_validate(enum rw_hint hint)\n{\n\ttypeof(((struct kiocb *)0)->ki_hint) max_hint = -1;\n\n\tif (hint <= max_hint)\n\t\treturn hint;\n\treturn 0;\n}\n\nstatic inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)\n{\n\t*kiocb = (struct kiocb) {\n\t\t.ki_filp = filp,\n\t\t.ki_flags = iocb_flags(filp),\n\t\t.ki_hint = ki_hint_validate(file_write_hint(filp)),\n\t\t.ki_ioprio = get_current_ioprio(),\n\t};\n}\n\nstatic inline void kiocb_clone(struct kiocb *kiocb, struct kiocb *kiocb_src,\n\t\t\t       struct file *filp)\n{\n\t*kiocb = (struct kiocb) {\n\t\t.ki_filp = filp,\n\t\t.ki_flags = kiocb_src->ki_flags,\n\t\t.ki_hint = kiocb_src->ki_hint,\n\t\t.ki_ioprio = kiocb_src->ki_ioprio,\n\t\t.ki_pos = kiocb_src->ki_pos,\n\t};\n}\n\n/*\n * Inode state bits.  Protected by inode->i_lock\n *\n * Four bits determine the dirty state of the inode: I_DIRTY_SYNC,\n * I_DIRTY_DATASYNC, I_DIRTY_PAGES, and I_DIRTY_TIME.\n *\n * Four bits define the lifetime of an inode.  Initially, inodes are I_NEW,\n * until that flag is cleared.  I_WILL_FREE, I_FREEING and I_CLEAR are set at\n * various stages of removing an inode.\n *\n * Two bits are used for locking and completion notification, I_NEW and I_SYNC.\n *\n * I_DIRTY_SYNC\t\tInode is dirty, but doesn't have to be written on\n *\t\t\tfdatasync() (unless I_DIRTY_DATASYNC is also set).\n *\t\t\tTimestamp updates are the usual cause.\n * I_DIRTY_DATASYNC\tData-related inode changes pending.  We keep track of\n *\t\t\tthese changes separately from I_DIRTY_SYNC so that we\n *\t\t\tdon't have to write inode on fdatasync() when only\n *\t\t\te.g. the timestamps have changed.\n * I_DIRTY_PAGES\tInode has dirty pages.  Inode itself may be clean.\n * I_DIRTY_TIME\t\tThe inode itself only has dirty timestamps, and the\n *\t\t\tlazytime mount option is enabled.  We keep track of this\n *\t\t\tseparately from I_DIRTY_SYNC in order to implement\n *\t\t\tlazytime.  This gets cleared if I_DIRTY_INODE\n *\t\t\t(I_DIRTY_SYNC and/or I_DIRTY_DATASYNC) gets set.  I.e.\n *\t\t\teither I_DIRTY_TIME *or* I_DIRTY_INODE can be set in\n *\t\t\ti_state, but not both.  I_DIRTY_PAGES may still be set.\n * I_NEW\t\tServes as both a mutex and completion notification.\n *\t\t\tNew inodes set I_NEW.  If two processes both create\n *\t\t\tthe same inode, one of them will release its inode and\n *\t\t\twait for I_NEW to be released before returning.\n *\t\t\tInodes in I_WILL_FREE, I_FREEING or I_CLEAR state can\n *\t\t\talso cause waiting on I_NEW, without I_NEW actually\n *\t\t\tbeing set.  find_inode() uses this to prevent returning\n *\t\t\tnearly-dead inodes.\n * I_WILL_FREE\t\tMust be set when calling write_inode_now() if i_count\n *\t\t\tis zero.  I_FREEING must be set when I_WILL_FREE is\n *\t\t\tcleared.\n * I_FREEING\t\tSet when inode is about to be freed but still has dirty\n *\t\t\tpages or buffers attached or the inode itself is still\n *\t\t\tdirty.\n * I_CLEAR\t\tAdded by clear_inode().  In this state the inode is\n *\t\t\tclean and can be destroyed.  Inode keeps I_FREEING.\n *\n *\t\t\tInodes that are I_WILL_FREE, I_FREEING or I_CLEAR are\n *\t\t\tprohibited for many purposes.  iget() must wait for\n *\t\t\tthe inode to be completely released, then create it\n *\t\t\tanew.  Other functions will just ignore such inodes,\n *\t\t\tif appropriate.  I_NEW is used for waiting.\n *\n * I_SYNC\t\tWriteback of inode is running. The bit is set during\n *\t\t\tdata writeback, and cleared with a wakeup on the bit\n *\t\t\taddress once it is done. The bit is also used to pin\n *\t\t\tthe inode in memory for flusher thread.\n *\n * I_REFERENCED\t\tMarks the inode as recently references on the LRU list.\n *\n * I_DIO_WAKEUP\t\tNever set.  Only used as a key for wait_on_bit().\n *\n * I_WB_SWITCH\t\tCgroup bdi_writeback switching in progress.  Used to\n *\t\t\tsynchronize competing switching instances and to tell\n *\t\t\twb stat updates to grab the i_pages lock.  See\n *\t\t\tinode_switch_wbs_work_fn() for details.\n *\n * I_OVL_INUSE\t\tUsed by overlayfs to get exclusive ownership on upper\n *\t\t\tand work dirs among overlayfs mounts.\n *\n * I_CREATING\t\tNew object's inode in the middle of setting up.\n *\n * I_DONTCACHE\t\tEvict inode as soon as it is not used anymore.\n *\n * I_SYNC_QUEUED\tInode is queued in b_io or b_more_io writeback lists.\n *\t\t\tUsed to detect that mark_inode_dirty() should not move\n * \t\t\tinode between dirty lists.\n *\n * Q: What is the difference between I_WILL_FREE and I_FREEING?\n */\n#define I_DIRTY_SYNC\t\t(1 << 0)\n#define I_DIRTY_DATASYNC\t(1 << 1)\n#define I_DIRTY_PAGES\t\t(1 << 2)\n#define __I_NEW\t\t\t3\n#define I_NEW\t\t\t(1 << __I_NEW)\n#define I_WILL_FREE\t\t(1 << 4)\n#define I_FREEING\t\t(1 << 5)\n#define I_CLEAR\t\t\t(1 << 6)\n#define __I_SYNC\t\t7\n#define I_SYNC\t\t\t(1 << __I_SYNC)\n#define I_REFERENCED\t\t(1 << 8)\n#define __I_DIO_WAKEUP\t\t9\n#define I_DIO_WAKEUP\t\t(1 << __I_DIO_WAKEUP)\n#define I_LINKABLE\t\t(1 << 10)\n#define I_DIRTY_TIME\t\t(1 << 11)\n#define I_WB_SWITCH\t\t(1 << 13)\n#define I_OVL_INUSE\t\t(1 << 14)\n#define I_CREATING\t\t(1 << 15)\n#define I_DONTCACHE\t\t(1 << 16)\n#define I_SYNC_QUEUED\t\t(1 << 17)\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n#define I_DIRTY (I_DIRTY_INODE | I_DIRTY_PAGES)\n#define I_DIRTY_ALL (I_DIRTY | I_DIRTY_TIME)\n\nextern void __mark_inode_dirty(struct inode *, int);\nstatic inline void mark_inode_dirty(struct inode *inode)\n{\n\t__mark_inode_dirty(inode, I_DIRTY);\n}\n\nstatic inline void mark_inode_dirty_sync(struct inode *inode)\n{\n\t__mark_inode_dirty(inode, I_DIRTY_SYNC);\n}\n\n/*\n * Returns true if the given inode itself only has dirty timestamps (its pages\n * may still be dirty) and isn't currently being allocated or freed.\n * Filesystems should call this if when writing an inode when lazytime is\n * enabled, they want to opportunistically write the timestamps of other inodes\n * located very nearby on-disk, e.g. in the same inode block.  This returns true\n * if the given inode is in need of such an opportunistic update.  Requires\n * i_lock, or at least later re-checking under i_lock.\n */\nstatic inline bool inode_is_dirtytime_only(struct inode *inode)\n{\n\treturn (inode->i_state & (I_DIRTY_TIME | I_NEW |\n\t\t\t\t  I_FREEING | I_WILL_FREE)) == I_DIRTY_TIME;\n}\n\nextern void inc_nlink(struct inode *inode);\nextern void drop_nlink(struct inode *inode);\nextern void clear_nlink(struct inode *inode);\nextern void set_nlink(struct inode *inode, unsigned int nlink);\n\nstatic inline void inode_inc_link_count(struct inode *inode)\n{\n\tinc_nlink(inode);\n\tmark_inode_dirty(inode);\n}\n\nstatic inline void inode_dec_link_count(struct inode *inode)\n{\n\tdrop_nlink(inode);\n\tmark_inode_dirty(inode);\n}\n\nenum file_time_flags {\n\tS_ATIME = 1,\n\tS_MTIME = 2,\n\tS_CTIME = 4,\n\tS_VERSION = 8,\n};\n\nextern bool atime_needs_update(const struct path *, struct inode *);\nextern void touch_atime(const struct path *);\nstatic inline void file_accessed(struct file *file)\n{\n\tif (!(file->f_flags & O_NOATIME))\n\t\ttouch_atime(&file->f_path);\n}\n\nextern int file_modified(struct file *file);\n\nint sync_inode(struct inode *inode, struct writeback_control *wbc);\nint sync_inode_metadata(struct inode *inode, int wait);\n\nstruct file_system_type {\n\tconst char *name;\n\tint fs_flags;\n#define FS_REQUIRES_DEV\t\t1 \n#define FS_BINARY_MOUNTDATA\t2\n#define FS_HAS_SUBTYPE\t\t4\n#define FS_USERNS_MOUNT\t\t8\t/* Can be mounted by userns root */\n#define FS_DISALLOW_NOTIFY_PERM\t16\t/* Disable fanotify permission events */\n#define FS_ALLOW_IDMAP         32      /* FS has been updated to handle vfs idmappings. */\n#define FS_THP_SUPPORT\t\t8192\t/* Remove once all fs converted */\n#define FS_RENAME_DOES_D_MOVE\t32768\t/* FS will handle d_move() during rename() internally. */\n\tint (*init_fs_context)(struct fs_context *);\n\tconst struct fs_parameter_spec *parameters;\n\tstruct dentry *(*mount) (struct file_system_type *, int,\n\t\t       const char *, void *);\n\tvoid (*kill_sb) (struct super_block *);\n\tstruct module *owner;\n\tstruct file_system_type * next;\n\tstruct hlist_head fs_supers;\n\n\tstruct lock_class_key s_lock_key;\n\tstruct lock_class_key s_umount_key;\n\tstruct lock_class_key s_vfs_rename_key;\n\tstruct lock_class_key s_writers_key[SB_FREEZE_LEVELS];\n\n\tstruct lock_class_key i_lock_key;\n\tstruct lock_class_key i_mutex_key;\n\tstruct lock_class_key i_mutex_dir_key;\n};\n\n#define MODULE_ALIAS_FS(NAME) MODULE_ALIAS(\"fs-\" NAME)\n\nextern struct dentry *mount_bdev(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data,\n\tint (*fill_super)(struct super_block *, void *, int));\nextern struct dentry *mount_single(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int));\nextern struct dentry *mount_nodev(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int));\nextern struct dentry *mount_subtree(struct vfsmount *mnt, const char *path);\nvoid generic_shutdown_super(struct super_block *sb);\nvoid kill_block_super(struct super_block *sb);\nvoid kill_anon_super(struct super_block *sb);\nvoid kill_litter_super(struct super_block *sb);\nvoid deactivate_super(struct super_block *sb);\nvoid deactivate_locked_super(struct super_block *sb);\nint set_anon_super(struct super_block *s, void *data);\nint set_anon_super_fc(struct super_block *s, struct fs_context *fc);\nint get_anon_bdev(dev_t *);\nvoid free_anon_bdev(dev_t);\nstruct super_block *sget_fc(struct fs_context *fc,\n\t\t\t    int (*test)(struct super_block *, struct fs_context *),\n\t\t\t    int (*set)(struct super_block *, struct fs_context *));\nstruct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags, void *data);\n\n/* Alas, no aliases. Too much hassle with bringing module.h everywhere */\n#define fops_get(fops) \\\n\t(((fops) && try_module_get((fops)->owner) ? (fops) : NULL))\n#define fops_put(fops) \\\n\tdo { if (fops) module_put((fops)->owner); } while(0)\n/*\n * This one is to be used *ONLY* from ->open() instances.\n * fops must be non-NULL, pinned down *and* module dependencies\n * should be sufficient to pin the caller down as well.\n */\n#define replace_fops(f, fops) \\\n\tdo {\t\\\n\t\tstruct file *__file = (f); \\\n\t\tfops_put(__file->f_op); \\\n\t\tBUG_ON(!(__file->f_op = (fops))); \\\n\t} while(0)\n\nextern int register_filesystem(struct file_system_type *);\nextern int unregister_filesystem(struct file_system_type *);\nextern struct vfsmount *kern_mount(struct file_system_type *);\nextern void kern_unmount(struct vfsmount *mnt);\nextern int may_umount_tree(struct vfsmount *);\nextern int may_umount(struct vfsmount *);\nextern long do_mount(const char *, const char __user *,\n\t\t     const char *, unsigned long, void *);\nextern struct vfsmount *collect_mounts(const struct path *);\nextern void drop_collected_mounts(struct vfsmount *);\nextern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,\n\t\t\t  struct vfsmount *);\nextern int vfs_statfs(const struct path *, struct kstatfs *);\nextern int user_statfs(const char __user *, struct kstatfs *);\nextern int fd_statfs(int, struct kstatfs *);\nextern int freeze_super(struct super_block *super);\nextern int thaw_super(struct super_block *super);\nextern bool our_mnt(struct vfsmount *mnt);\nextern __printf(2, 3)\nint super_setup_bdi_name(struct super_block *sb, char *fmt, ...);\nextern int super_setup_bdi(struct super_block *sb);\n\nextern int current_umask(void);\n\nextern void ihold(struct inode * inode);\nextern void iput(struct inode *);\nextern int generic_update_time(struct inode *, struct timespec64 *, int);\n\n/* /sys/fs */\nextern struct kobject *fs_kobj;\n\n#define MAX_RW_COUNT (INT_MAX & PAGE_MASK)\n\n#ifdef CONFIG_MANDATORY_FILE_LOCKING\nextern int locks_mandatory_locked(struct file *);\nextern int locks_mandatory_area(struct inode *, struct file *, loff_t, loff_t, unsigned char);\n\n/*\n * Candidates for mandatory locking have the setgid bit set\n * but no group execute bit -  an otherwise meaningless combination.\n */\n\nstatic inline int __mandatory_lock(struct inode *ino)\n{\n\treturn (ino->i_mode & (S_ISGID | S_IXGRP)) == S_ISGID;\n}\n\n/*\n * ... and these candidates should be on SB_MANDLOCK mounted fs,\n * otherwise these will be advisory locks\n */\n\nstatic inline int mandatory_lock(struct inode *ino)\n{\n\treturn IS_MANDLOCK(ino) && __mandatory_lock(ino);\n}\n\nstatic inline int locks_verify_locked(struct file *file)\n{\n\tif (mandatory_lock(locks_inode(file)))\n\t\treturn locks_mandatory_locked(file);\n\treturn 0;\n}\n\nstatic inline int locks_verify_truncate(struct inode *inode,\n\t\t\t\t    struct file *f,\n\t\t\t\t    loff_t size)\n{\n\tif (!inode->i_flctx || !mandatory_lock(inode))\n\t\treturn 0;\n\n\tif (size < inode->i_size) {\n\t\treturn locks_mandatory_area(inode, f, size, inode->i_size - 1,\n\t\t\t\tF_WRLCK);\n\t} else {\n\t\treturn locks_mandatory_area(inode, f, inode->i_size, size - 1,\n\t\t\t\tF_WRLCK);\n\t}\n}\n\n#else /* !CONFIG_MANDATORY_FILE_LOCKING */\n\nstatic inline int locks_mandatory_locked(struct file *file)\n{\n\treturn 0;\n}\n\nstatic inline int locks_mandatory_area(struct inode *inode, struct file *filp,\n                                       loff_t start, loff_t end, unsigned char type)\n{\n\treturn 0;\n}\n\nstatic inline int __mandatory_lock(struct inode *inode)\n{\n\treturn 0;\n}\n\nstatic inline int mandatory_lock(struct inode *inode)\n{\n\treturn 0;\n}\n\nstatic inline int locks_verify_locked(struct file *file)\n{\n\treturn 0;\n}\n\nstatic inline int locks_verify_truncate(struct inode *inode, struct file *filp,\n\t\t\t\t\tsize_t size)\n{\n\treturn 0;\n}\n\n#endif /* CONFIG_MANDATORY_FILE_LOCKING */\n\n\n#ifdef CONFIG_FILE_LOCKING\nstatic inline int break_lease(struct inode *inode, unsigned int mode)\n{\n\t/*\n\t * Since this check is lockless, we must ensure that any refcounts\n\t * taken are done before checking i_flctx->flc_lease. Otherwise, we\n\t * could end up racing with tasks trying to set a new lease on this\n\t * file.\n\t */\n\tsmp_mb();\n\tif (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))\n\t\treturn __break_lease(inode, mode, FL_LEASE);\n\treturn 0;\n}\n\nstatic inline int break_deleg(struct inode *inode, unsigned int mode)\n{\n\t/*\n\t * Since this check is lockless, we must ensure that any refcounts\n\t * taken are done before checking i_flctx->flc_lease. Otherwise, we\n\t * could end up racing with tasks trying to set a new lease on this\n\t * file.\n\t */\n\tsmp_mb();\n\tif (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))\n\t\treturn __break_lease(inode, mode, FL_DELEG);\n\treturn 0;\n}\n\nstatic inline int try_break_deleg(struct inode *inode, struct inode **delegated_inode)\n{\n\tint ret;\n\n\tret = break_deleg(inode, O_WRONLY|O_NONBLOCK);\n\tif (ret == -EWOULDBLOCK && delegated_inode) {\n\t\t*delegated_inode = inode;\n\t\tihold(inode);\n\t}\n\treturn ret;\n}\n\nstatic inline int break_deleg_wait(struct inode **delegated_inode)\n{\n\tint ret;\n\n\tret = break_deleg(*delegated_inode, O_WRONLY);\n\tiput(*delegated_inode);\n\t*delegated_inode = NULL;\n\treturn ret;\n}\n\nstatic inline int break_layout(struct inode *inode, bool wait)\n{\n\tsmp_mb();\n\tif (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))\n\t\treturn __break_lease(inode,\n\t\t\t\twait ? O_WRONLY : O_WRONLY | O_NONBLOCK,\n\t\t\t\tFL_LAYOUT);\n\treturn 0;\n}\n\n#else /* !CONFIG_FILE_LOCKING */\nstatic inline int break_lease(struct inode *inode, unsigned int mode)\n{\n\treturn 0;\n}\n\nstatic inline int break_deleg(struct inode *inode, unsigned int mode)\n{\n\treturn 0;\n}\n\nstatic inline int try_break_deleg(struct inode *inode, struct inode **delegated_inode)\n{\n\treturn 0;\n}\n\nstatic inline int break_deleg_wait(struct inode **delegated_inode)\n{\n\tBUG();\n\treturn 0;\n}\n\nstatic inline int break_layout(struct inode *inode, bool wait)\n{\n\treturn 0;\n}\n\n#endif /* CONFIG_FILE_LOCKING */\n\n/* fs/open.c */\nstruct audit_names;\nstruct filename {\n\tconst char\t\t*name;\t/* pointer to actual string */\n\tconst __user char\t*uptr;\t/* original userland pointer */\n\tint\t\t\trefcnt;\n\tstruct audit_names\t*aname;\n\tconst char\t\tiname[];\n};\nstatic_assert(offsetof(struct filename, iname) % sizeof(long) == 0);\n\nstatic inline struct user_namespace *file_mnt_user_ns(struct file *file)\n{\n\treturn mnt_user_ns(file->f_path.mnt);\n}\nextern long vfs_truncate(const struct path *, loff_t);\nint do_truncate(struct user_namespace *, struct dentry *, loff_t start,\n\t\tunsigned int time_attrs, struct file *filp);\nextern int vfs_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\tloff_t len);\nextern long do_sys_open(int dfd, const char __user *filename, int flags,\n\t\t\tumode_t mode);\nextern struct file *file_open_name(struct filename *, int, umode_t);\nextern struct file *filp_open(const char *, int, umode_t);\nextern struct file *file_open_root(struct dentry *, struct vfsmount *,\n\t\t\t\t   const char *, int, umode_t);\nextern struct file * dentry_open(const struct path *, int, const struct cred *);\nextern struct file * open_with_fake_path(const struct path *, int,\n\t\t\t\t\t struct inode*, const struct cred *);\nstatic inline struct file *file_clone_open(struct file *file)\n{\n\treturn dentry_open(&file->f_path, file->f_flags, file->f_cred);\n}\nextern int filp_close(struct file *, fl_owner_t id);\n\nextern struct filename *getname_flags(const char __user *, int, int *);\nextern struct filename *getname(const char __user *);\nextern struct filename *getname_kernel(const char *);\nextern void putname(struct filename *name);\n\nextern int finish_open(struct file *file, struct dentry *dentry,\n\t\t\tint (*open)(struct inode *, struct file *));\nextern int finish_no_open(struct file *file, struct dentry *dentry);\n\n/* fs/dcache.c */\nextern void __init vfs_caches_init_early(void);\nextern void __init vfs_caches_init(void);\n\nextern struct kmem_cache *names_cachep;\n\n#define __getname()\t\tkmem_cache_alloc(names_cachep, GFP_KERNEL)\n#define __putname(name)\t\tkmem_cache_free(names_cachep, (void *)(name))\n\nextern struct super_block *blockdev_superblock;\nstatic inline bool sb_is_blkdev_sb(struct super_block *sb)\n{\n\treturn IS_ENABLED(CONFIG_BLOCK) && sb == blockdev_superblock;\n}\n\nvoid emergency_thaw_all(void);\nextern int sync_filesystem(struct super_block *);\nextern const struct file_operations def_blk_fops;\nextern const struct file_operations def_chr_fops;\n\n/* fs/char_dev.c */\n#define CHRDEV_MAJOR_MAX 512\n/* Marks the bottom of the first segment of free char majors */\n#define CHRDEV_MAJOR_DYN_END 234\n/* Marks the top and bottom of the second segment of free char majors */\n#define CHRDEV_MAJOR_DYN_EXT_START 511\n#define CHRDEV_MAJOR_DYN_EXT_END 384\n\nextern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);\nextern int register_chrdev_region(dev_t, unsigned, const char *);\nextern int __register_chrdev(unsigned int major, unsigned int baseminor,\n\t\t\t     unsigned int count, const char *name,\n\t\t\t     const struct file_operations *fops);\nextern void __unregister_chrdev(unsigned int major, unsigned int baseminor,\n\t\t\t\tunsigned int count, const char *name);\nextern void unregister_chrdev_region(dev_t, unsigned);\nextern void chrdev_show(struct seq_file *,off_t);\n\nstatic inline int register_chrdev(unsigned int major, const char *name,\n\t\t\t\t  const struct file_operations *fops)\n{\n\treturn __register_chrdev(major, 0, 256, name, fops);\n}\n\nstatic inline void unregister_chrdev(unsigned int major, const char *name)\n{\n\t__unregister_chrdev(major, 0, 256, name);\n}\n\nextern void init_special_inode(struct inode *, umode_t, dev_t);\n\n/* Invalid inode operations -- fs/bad_inode.c */\nextern void make_bad_inode(struct inode *);\nextern bool is_bad_inode(struct inode *);\n\nunsigned long invalidate_mapping_pages(struct address_space *mapping,\n\t\t\t\t\tpgoff_t start, pgoff_t end);\n\nvoid invalidate_mapping_pagevec(struct address_space *mapping,\n\t\t\t\tpgoff_t start, pgoff_t end,\n\t\t\t\tunsigned long *nr_pagevec);\n\nstatic inline void invalidate_remote_inode(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode))\n\t\tinvalidate_mapping_pages(inode->i_mapping, 0, -1);\n}\nextern int invalidate_inode_pages2(struct address_space *mapping);\nextern int invalidate_inode_pages2_range(struct address_space *mapping,\n\t\t\t\t\t pgoff_t start, pgoff_t end);\nextern int write_inode_now(struct inode *, int);\nextern int filemap_fdatawrite(struct address_space *);\nextern int filemap_flush(struct address_space *);\nextern int filemap_fdatawait_keep_errors(struct address_space *mapping);\nextern int filemap_fdatawait_range(struct address_space *, loff_t lstart,\n\t\t\t\t   loff_t lend);\nextern int filemap_fdatawait_range_keep_errors(struct address_space *mapping,\n\t\tloff_t start_byte, loff_t end_byte);\n\nstatic inline int filemap_fdatawait(struct address_space *mapping)\n{\n\treturn filemap_fdatawait_range(mapping, 0, LLONG_MAX);\n}\n\nextern bool filemap_range_has_page(struct address_space *, loff_t lstart,\n\t\t\t\t  loff_t lend);\nextern bool filemap_range_needs_writeback(struct address_space *,\n\t\t\t\t\t  loff_t lstart, loff_t lend);\nextern int filemap_write_and_wait_range(struct address_space *mapping,\n\t\t\t\t        loff_t lstart, loff_t lend);\nextern int __filemap_fdatawrite_range(struct address_space *mapping,\n\t\t\t\tloff_t start, loff_t end, int sync_mode);\nextern int filemap_fdatawrite_range(struct address_space *mapping,\n\t\t\t\tloff_t start, loff_t end);\nextern int filemap_check_errors(struct address_space *mapping);\nextern void __filemap_set_wb_err(struct address_space *mapping, int err);\n\nstatic inline int filemap_write_and_wait(struct address_space *mapping)\n{\n\treturn filemap_write_and_wait_range(mapping, 0, LLONG_MAX);\n}\n\nextern int __must_check file_fdatawait_range(struct file *file, loff_t lstart,\n\t\t\t\t\t\tloff_t lend);\nextern int __must_check file_check_and_advance_wb_err(struct file *file);\nextern int __must_check file_write_and_wait_range(struct file *file,\n\t\t\t\t\t\tloff_t start, loff_t end);\n\nstatic inline int file_write_and_wait(struct file *file)\n{\n\treturn file_write_and_wait_range(file, 0, LLONG_MAX);\n}\n\n/**\n * filemap_set_wb_err - set a writeback error on an address_space\n * @mapping: mapping in which to set writeback error\n * @err: error to be set in mapping\n *\n * When writeback fails in some way, we must record that error so that\n * userspace can be informed when fsync and the like are called.  We endeavor\n * to report errors on any file that was open at the time of the error.  Some\n * internal callers also need to know when writeback errors have occurred.\n *\n * When a writeback error occurs, most filesystems will want to call\n * filemap_set_wb_err to record the error in the mapping so that it will be\n * automatically reported whenever fsync is called on the file.\n */\nstatic inline void filemap_set_wb_err(struct address_space *mapping, int err)\n{\n\t/* Fastpath for common case of no error */\n\tif (unlikely(err))\n\t\t__filemap_set_wb_err(mapping, err);\n}\n\n/**\n * filemap_check_wb_err - has an error occurred since the mark was sampled?\n * @mapping: mapping to check for writeback errors\n * @since: previously-sampled errseq_t\n *\n * Grab the errseq_t value from the mapping, and see if it has changed \"since\"\n * the given value was sampled.\n *\n * If it has then report the latest error set, otherwise return 0.\n */\nstatic inline int filemap_check_wb_err(struct address_space *mapping,\n\t\t\t\t\terrseq_t since)\n{\n\treturn errseq_check(&mapping->wb_err, since);\n}\n\n/**\n * filemap_sample_wb_err - sample the current errseq_t to test for later errors\n * @mapping: mapping to be sampled\n *\n * Writeback errors are always reported relative to a particular sample point\n * in the past. This function provides those sample points.\n */\nstatic inline errseq_t filemap_sample_wb_err(struct address_space *mapping)\n{\n\treturn errseq_sample(&mapping->wb_err);\n}\n\n/**\n * file_sample_sb_err - sample the current errseq_t to test for later errors\n * @file: file pointer to be sampled\n *\n * Grab the most current superblock-level errseq_t value for the given\n * struct file.\n */\nstatic inline errseq_t file_sample_sb_err(struct file *file)\n{\n\treturn errseq_sample(&file->f_path.dentry->d_sb->s_wb_err);\n}\n\nextern int vfs_fsync_range(struct file *file, loff_t start, loff_t end,\n\t\t\t   int datasync);\nextern int vfs_fsync(struct file *file, int datasync);\n\nextern int sync_file_range(struct file *file, loff_t offset, loff_t nbytes,\n\t\t\t\tunsigned int flags);\n\n/*\n * Sync the bytes written if this was a synchronous write.  Expect ki_pos\n * to already be updated for the write, and will return either the amount\n * of bytes passed in, or an error if syncing the file failed.\n */\nstatic inline ssize_t generic_write_sync(struct kiocb *iocb, ssize_t count)\n{\n\tif (iocb->ki_flags & IOCB_DSYNC) {\n\t\tint ret = vfs_fsync_range(iocb->ki_filp,\n\t\t\t\tiocb->ki_pos - count, iocb->ki_pos - 1,\n\t\t\t\t(iocb->ki_flags & IOCB_SYNC) ? 0 : 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\nextern void emergency_sync(void);\nextern void emergency_remount(void);\n\n#ifdef CONFIG_BLOCK\nextern int bmap(struct inode *inode, sector_t *block);\n#else\nstatic inline int bmap(struct inode *inode,  sector_t *block)\n{\n\treturn -EINVAL;\n}\n#endif\n\nint notify_change(struct user_namespace *, struct dentry *,\n\t\t  struct iattr *, struct inode **);\nint inode_permission(struct user_namespace *, struct inode *, int);\nint generic_permission(struct user_namespace *, struct inode *, int);\nstatic inline int file_permission(struct file *file, int mask)\n{\n\treturn inode_permission(file_mnt_user_ns(file),\n\t\t\t\tfile_inode(file), mask);\n}\nstatic inline int path_permission(const struct path *path, int mask)\n{\n\treturn inode_permission(mnt_user_ns(path->mnt),\n\t\t\t\td_inode(path->dentry), mask);\n}\nint __check_sticky(struct user_namespace *mnt_userns, struct inode *dir,\n\t\t   struct inode *inode);\n\nstatic inline bool execute_ok(struct inode *inode)\n{\n\treturn (inode->i_mode & S_IXUGO) || S_ISDIR(inode->i_mode);\n}\n\nstatic inline bool inode_wrong_type(const struct inode *inode, umode_t mode)\n{\n\treturn (inode->i_mode ^ mode) & S_IFMT;\n}\n\nstatic inline void file_start_write(struct file *file)\n{\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn;\n\tsb_start_write(file_inode(file)->i_sb);\n}\n\nstatic inline bool file_start_write_trylock(struct file *file)\n{\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn true;\n\treturn sb_start_write_trylock(file_inode(file)->i_sb);\n}\n\nstatic inline void file_end_write(struct file *file)\n{\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn;\n\t__sb_end_write(file_inode(file)->i_sb, SB_FREEZE_WRITE);\n}\n\n/*\n * get_write_access() gets write permission for a file.\n * put_write_access() releases this write permission.\n * This is used for regular files.\n * We cannot support write (and maybe mmap read-write shared) accesses and\n * MAP_DENYWRITE mmappings simultaneously. The i_writecount field of an inode\n * can have the following values:\n * 0: no writers, no VM_DENYWRITE mappings\n * < 0: (-i_writecount) vm_area_structs with VM_DENYWRITE set exist\n * > 0: (i_writecount) users are writing to the file.\n *\n * Normally we operate on that counter with atomic_{inc,dec} and it's safe\n * except for the cases where we don't hold i_writecount yet. Then we need to\n * use {get,deny}_write_access() - these functions check the sign and refuse\n * to do the change if sign is wrong.\n */\nstatic inline int get_write_access(struct inode *inode)\n{\n\treturn atomic_inc_unless_negative(&inode->i_writecount) ? 0 : -ETXTBSY;\n}\nstatic inline int deny_write_access(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\treturn atomic_dec_unless_positive(&inode->i_writecount) ? 0 : -ETXTBSY;\n}\nstatic inline void put_write_access(struct inode * inode)\n{\n\tatomic_dec(&inode->i_writecount);\n}\nstatic inline void allow_write_access(struct file *file)\n{\n\tif (file)\n\t\tatomic_inc(&file_inode(file)->i_writecount);\n}\nstatic inline bool inode_is_open_for_write(const struct inode *inode)\n{\n\treturn atomic_read(&inode->i_writecount) > 0;\n}\n\n#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)\nstatic inline void i_readcount_dec(struct inode *inode)\n{\n\tBUG_ON(!atomic_read(&inode->i_readcount));\n\tatomic_dec(&inode->i_readcount);\n}\nstatic inline void i_readcount_inc(struct inode *inode)\n{\n\tatomic_inc(&inode->i_readcount);\n}\n#else\nstatic inline void i_readcount_dec(struct inode *inode)\n{\n\treturn;\n}\nstatic inline void i_readcount_inc(struct inode *inode)\n{\n\treturn;\n}\n#endif\nextern int do_pipe_flags(int *, int);\n\nextern ssize_t kernel_read(struct file *, void *, size_t, loff_t *);\nssize_t __kernel_read(struct file *file, void *buf, size_t count, loff_t *pos);\nextern ssize_t kernel_write(struct file *, const void *, size_t, loff_t *);\nextern ssize_t __kernel_write(struct file *, const void *, size_t, loff_t *);\nextern struct file * open_exec(const char *);\n \n/* fs/dcache.c -- generic fs support functions */\nextern bool is_subdir(struct dentry *, struct dentry *);\nextern bool path_is_under(const struct path *, const struct path *);\n\nextern char *file_path(struct file *, char *, int);\n\n#include <linux/err.h>\n\n/* needed for stackable file system support */\nextern loff_t default_llseek(struct file *file, loff_t offset, int whence);\n\nextern loff_t vfs_llseek(struct file *file, loff_t offset, int whence);\n\nextern int inode_init_always(struct super_block *, struct inode *);\nextern void inode_init_once(struct inode *);\nextern void address_space_init_once(struct address_space *mapping);\nextern struct inode * igrab(struct inode *);\nextern ino_t iunique(struct super_block *, ino_t);\nextern int inode_needs_sync(struct inode *inode);\nextern int generic_delete_inode(struct inode *inode);\nstatic inline int generic_drop_inode(struct inode *inode)\n{\n\treturn !inode->i_nlink || inode_unhashed(inode);\n}\nextern void d_mark_dontcache(struct inode *inode);\n\nextern struct inode *ilookup5_nowait(struct super_block *sb,\n\t\tunsigned long hashval, int (*test)(struct inode *, void *),\n\t\tvoid *data);\nextern struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data);\nextern struct inode *ilookup(struct super_block *sb, unsigned long ino);\n\nextern struct inode *inode_insert5(struct inode *inode, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *),\n\t\tvoid *data);\nextern struct inode * iget5_locked(struct super_block *, unsigned long, int (*test)(struct inode *, void *), int (*set)(struct inode *, void *), void *);\nextern struct inode * iget_locked(struct super_block *, unsigned long);\nextern struct inode *find_inode_nowait(struct super_block *,\n\t\t\t\t       unsigned long,\n\t\t\t\t       int (*match)(struct inode *,\n\t\t\t\t\t\t    unsigned long, void *),\n\t\t\t\t       void *data);\nextern struct inode *find_inode_rcu(struct super_block *, unsigned long,\n\t\t\t\t    int (*)(struct inode *, void *), void *);\nextern struct inode *find_inode_by_ino_rcu(struct super_block *, unsigned long);\nextern int insert_inode_locked4(struct inode *, unsigned long, int (*test)(struct inode *, void *), void *);\nextern int insert_inode_locked(struct inode *);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nextern void lockdep_annotate_inode_mutex_key(struct inode *inode);\n#else\nstatic inline void lockdep_annotate_inode_mutex_key(struct inode *inode) { };\n#endif\nextern void unlock_new_inode(struct inode *);\nextern void discard_new_inode(struct inode *);\nextern unsigned int get_next_ino(void);\nextern void evict_inodes(struct super_block *sb);\n\n/*\n * Userspace may rely on the the inode number being non-zero. For example, glibc\n * simply ignores files with zero i_ino in unlink() and other places.\n *\n * As an additional complication, if userspace was compiled with\n * _FILE_OFFSET_BITS=32 on a 64-bit kernel we'll only end up reading out the\n * lower 32 bits, so we need to check that those aren't zero explicitly. With\n * _FILE_OFFSET_BITS=64, this may cause some harmless false-negatives, but\n * better safe than sorry.\n */\nstatic inline bool is_zero_ino(ino_t ino)\n{\n\treturn (u32)ino == 0;\n}\n\nextern void __iget(struct inode * inode);\nextern void iget_failed(struct inode *);\nextern void clear_inode(struct inode *);\nextern void __destroy_inode(struct inode *);\nextern struct inode *new_inode_pseudo(struct super_block *sb);\nextern struct inode *new_inode(struct super_block *sb);\nextern void free_inode_nonrcu(struct inode *inode);\nextern int should_remove_suid(struct dentry *);\nextern int file_remove_privs(struct file *);\n\nextern void __insert_inode_hash(struct inode *, unsigned long hashval);\nstatic inline void insert_inode_hash(struct inode *inode)\n{\n\t__insert_inode_hash(inode, inode->i_ino);\n}\n\nextern void __remove_inode_hash(struct inode *);\nstatic inline void remove_inode_hash(struct inode *inode)\n{\n\tif (!inode_unhashed(inode) && !hlist_fake(&inode->i_hash))\n\t\t__remove_inode_hash(inode);\n}\n\nextern void inode_sb_list_add(struct inode *inode);\n\nextern int sb_set_blocksize(struct super_block *, int);\nextern int sb_min_blocksize(struct super_block *, int);\n\nextern int generic_file_mmap(struct file *, struct vm_area_struct *);\nextern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);\nextern ssize_t generic_write_checks(struct kiocb *, struct iov_iter *);\nextern int generic_write_check_limits(struct file *file, loff_t pos,\n\t\tloff_t *count);\nextern int generic_file_rw_checks(struct file *file_in, struct file *file_out);\nssize_t filemap_read(struct kiocb *iocb, struct iov_iter *to,\n\t\tssize_t already_read);\nextern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);\nextern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);\nextern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);\nextern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *);\nextern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);\n\nssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos,\n\t\trwf_t flags);\nssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos,\n\t\trwf_t flags);\nssize_t vfs_iocb_iter_read(struct file *file, struct kiocb *iocb,\n\t\t\t   struct iov_iter *iter);\nssize_t vfs_iocb_iter_write(struct file *file, struct kiocb *iocb,\n\t\t\t    struct iov_iter *iter);\n\n/* fs/block_dev.c */\nextern ssize_t blkdev_read_iter(struct kiocb *iocb, struct iov_iter *to);\nextern ssize_t blkdev_write_iter(struct kiocb *iocb, struct iov_iter *from);\nextern int blkdev_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\tint datasync);\nextern void block_sync_page(struct page *page);\n\n/* fs/splice.c */\nextern ssize_t generic_file_splice_read(struct file *, loff_t *,\n\t\tstruct pipe_inode_info *, size_t, unsigned int);\nextern ssize_t iter_file_splice_write(struct pipe_inode_info *,\n\t\tstruct file *, loff_t *, size_t, unsigned int);\nextern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,\n\t\tstruct file *out, loff_t *, size_t len, unsigned int flags);\nextern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n\t\tloff_t *opos, size_t len, unsigned int flags);\n\n\nextern void\nfile_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);\nextern loff_t noop_llseek(struct file *file, loff_t offset, int whence);\nextern loff_t no_llseek(struct file *file, loff_t offset, int whence);\nextern loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize);\nextern loff_t generic_file_llseek(struct file *file, loff_t offset, int whence);\nextern loff_t generic_file_llseek_size(struct file *file, loff_t offset,\n\t\tint whence, loff_t maxsize, loff_t eof);\nextern loff_t fixed_size_llseek(struct file *file, loff_t offset,\n\t\tint whence, loff_t size);\nextern loff_t no_seek_end_llseek_size(struct file *, loff_t, int, loff_t);\nextern loff_t no_seek_end_llseek(struct file *, loff_t, int);\nextern int generic_file_open(struct inode * inode, struct file * filp);\nextern int nonseekable_open(struct inode * inode, struct file * filp);\nextern int stream_open(struct inode * inode, struct file * filp);\n\n#ifdef CONFIG_BLOCK\ntypedef void (dio_submit_t)(struct bio *bio, struct inode *inode,\n\t\t\t    loff_t file_offset);\n\nenum {\n\t/* need locking between buffered and direct access */\n\tDIO_LOCKING\t= 0x01,\n\n\t/* filesystem does not support filling holes */\n\tDIO_SKIP_HOLES\t= 0x02,\n};\n\nssize_t __blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,\n\t\t\t     struct block_device *bdev, struct iov_iter *iter,\n\t\t\t     get_block_t get_block,\n\t\t\t     dio_iodone_t end_io, dio_submit_t submit_io,\n\t\t\t     int flags);\n\nstatic inline ssize_t blockdev_direct_IO(struct kiocb *iocb,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t struct iov_iter *iter,\n\t\t\t\t\t get_block_t get_block)\n{\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev, iter,\n\t\t\tget_block, NULL, NULL, DIO_LOCKING | DIO_SKIP_HOLES);\n}\n#endif\n\nvoid inode_dio_wait(struct inode *inode);\n\n/**\n * inode_dio_begin - signal start of a direct I/O requests\n * @inode: inode the direct I/O happens on\n *\n * This is called once we've finished processing a direct I/O request,\n * and is used to wake up callers waiting for direct I/O to be quiesced.\n */\nstatic inline void inode_dio_begin(struct inode *inode)\n{\n\tatomic_inc(&inode->i_dio_count);\n}\n\n/**\n * inode_dio_end - signal finish of a direct I/O requests\n * @inode: inode the direct I/O happens on\n *\n * This is called once we've finished processing a direct I/O request,\n * and is used to wake up callers waiting for direct I/O to be quiesced.\n */\nstatic inline void inode_dio_end(struct inode *inode)\n{\n\tif (atomic_dec_and_test(&inode->i_dio_count))\n\t\twake_up_bit(&inode->i_state, __I_DIO_WAKEUP);\n}\n\n/*\n * Warn about a page cache invalidation failure diring a direct I/O write.\n */\nvoid dio_warn_stale_pagecache(struct file *filp);\n\nextern void inode_set_flags(struct inode *inode, unsigned int flags,\n\t\t\t    unsigned int mask);\n\nextern const struct file_operations generic_ro_fops;\n\n#define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))\n\nextern int readlink_copy(char __user *, int, const char *);\nextern int page_readlink(struct dentry *, char __user *, int);\nextern const char *page_get_link(struct dentry *, struct inode *,\n\t\t\t\t struct delayed_call *);\nextern void page_put_link(void *);\nextern int __page_symlink(struct inode *inode, const char *symname, int len,\n\t\tint nofs);\nextern int page_symlink(struct inode *inode, const char *symname, int len);\nextern const struct inode_operations page_symlink_inode_operations;\nextern void kfree_link(void *);\nvoid generic_fillattr(struct user_namespace *, struct inode *, struct kstat *);\nextern int vfs_getattr_nosec(const struct path *, struct kstat *, u32, unsigned int);\nextern int vfs_getattr(const struct path *, struct kstat *, u32, unsigned int);\nvoid __inode_add_bytes(struct inode *inode, loff_t bytes);\nvoid inode_add_bytes(struct inode *inode, loff_t bytes);\nvoid __inode_sub_bytes(struct inode *inode, loff_t bytes);\nvoid inode_sub_bytes(struct inode *inode, loff_t bytes);\nstatic inline loff_t __inode_get_bytes(struct inode *inode)\n{\n\treturn (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;\n}\nloff_t inode_get_bytes(struct inode *inode);\nvoid inode_set_bytes(struct inode *inode, loff_t bytes);\nconst char *simple_get_link(struct dentry *, struct inode *,\n\t\t\t    struct delayed_call *);\nextern const struct inode_operations simple_symlink_inode_operations;\n\nextern int iterate_dir(struct file *, struct dir_context *);\n\nint vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,\n\t\tint flags);\nint vfs_fstat(int fd, struct kstat *stat);\n\nstatic inline int vfs_stat(const char __user *filename, struct kstat *stat)\n{\n\treturn vfs_fstatat(AT_FDCWD, filename, stat, 0);\n}\nstatic inline int vfs_lstat(const char __user *name, struct kstat *stat)\n{\n\treturn vfs_fstatat(AT_FDCWD, name, stat, AT_SYMLINK_NOFOLLOW);\n}\n\nextern const char *vfs_get_link(struct dentry *, struct delayed_call *);\nextern int vfs_readlink(struct dentry *, char __user *, int);\n\nextern struct file_system_type *get_filesystem(struct file_system_type *fs);\nextern void put_filesystem(struct file_system_type *fs);\nextern struct file_system_type *get_fs_type(const char *name);\nextern struct super_block *get_super(struct block_device *);\nextern struct super_block *get_active_super(struct block_device *bdev);\nextern void drop_super(struct super_block *sb);\nextern void drop_super_exclusive(struct super_block *sb);\nextern void iterate_supers(void (*)(struct super_block *, void *), void *);\nextern void iterate_supers_type(struct file_system_type *,\n\t\t\t        void (*)(struct super_block *, void *), void *);\n\nextern int dcache_dir_open(struct inode *, struct file *);\nextern int dcache_dir_close(struct inode *, struct file *);\nextern loff_t dcache_dir_lseek(struct file *, loff_t, int);\nextern int dcache_readdir(struct file *, struct dir_context *);\nextern int simple_setattr(struct user_namespace *, struct dentry *,\n\t\t\t  struct iattr *);\nextern int simple_getattr(struct user_namespace *, const struct path *,\n\t\t\t  struct kstat *, u32, unsigned int);\nextern int simple_statfs(struct dentry *, struct kstatfs *);\nextern int simple_open(struct inode *inode, struct file *file);\nextern int simple_link(struct dentry *, struct inode *, struct dentry *);\nextern int simple_unlink(struct inode *, struct dentry *);\nextern int simple_rmdir(struct inode *, struct dentry *);\nextern int simple_rename(struct user_namespace *, struct inode *,\n\t\t\t struct dentry *, struct inode *, struct dentry *,\n\t\t\t unsigned int);\nextern void simple_recursive_removal(struct dentry *,\n                              void (*callback)(struct dentry *));\nextern int noop_fsync(struct file *, loff_t, loff_t, int);\nextern int noop_set_page_dirty(struct page *page);\nextern void noop_invalidatepage(struct page *page, unsigned int offset,\n\t\tunsigned int length);\nextern ssize_t noop_direct_IO(struct kiocb *iocb, struct iov_iter *iter);\nextern int simple_empty(struct dentry *);\nextern int simple_readpage(struct file *file, struct page *page);\nextern int simple_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata);\nextern int simple_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata);\nextern int always_delete_dentry(const struct dentry *);\nextern struct inode *alloc_anon_inode(struct super_block *);\nextern int simple_nosetlease(struct file *, long, struct file_lock **, void **);\nextern const struct dentry_operations simple_dentry_operations;\n\nextern struct dentry *simple_lookup(struct inode *, struct dentry *, unsigned int flags);\nextern ssize_t generic_read_dir(struct file *, char __user *, size_t, loff_t *);\nextern const struct file_operations simple_dir_operations;\nextern const struct inode_operations simple_dir_inode_operations;\nextern void make_empty_dir_inode(struct inode *inode);\nextern bool is_empty_dir_inode(struct inode *inode);\nstruct tree_descr { const char *name; const struct file_operations *ops; int mode; };\nstruct dentry *d_alloc_name(struct dentry *, const char *);\nextern int simple_fill_super(struct super_block *, unsigned long,\n\t\t\t     const struct tree_descr *);\nextern int simple_pin_fs(struct file_system_type *, struct vfsmount **mount, int *count);\nextern void simple_release_fs(struct vfsmount **mount, int *count);\n\nextern ssize_t simple_read_from_buffer(void __user *to, size_t count,\n\t\t\tloff_t *ppos, const void *from, size_t available);\nextern ssize_t simple_write_to_buffer(void *to, size_t available, loff_t *ppos,\n\t\tconst void __user *from, size_t count);\n\nextern int __generic_file_fsync(struct file *, loff_t, loff_t, int);\nextern int generic_file_fsync(struct file *, loff_t, loff_t, int);\n\nextern int generic_check_addressable(unsigned, u64);\n\nextern void generic_set_encrypted_ci_d_ops(struct dentry *dentry);\n\n#ifdef CONFIG_MIGRATION\nextern int buffer_migrate_page(struct address_space *,\n\t\t\t\tstruct page *, struct page *,\n\t\t\t\tenum migrate_mode);\nextern int buffer_migrate_page_norefs(struct address_space *,\n\t\t\t\tstruct page *, struct page *,\n\t\t\t\tenum migrate_mode);\n#else\n#define buffer_migrate_page NULL\n#define buffer_migrate_page_norefs NULL\n#endif\n\nint setattr_prepare(struct user_namespace *, struct dentry *, struct iattr *);\nextern int inode_newsize_ok(const struct inode *, loff_t offset);\nvoid setattr_copy(struct user_namespace *, struct inode *inode,\n\t\t  const struct iattr *attr);\n\nextern int file_update_time(struct file *file);\n\nstatic inline bool vma_is_dax(const struct vm_area_struct *vma)\n{\n\treturn vma->vm_file && IS_DAX(vma->vm_file->f_mapping->host);\n}\n\nstatic inline bool vma_is_fsdax(struct vm_area_struct *vma)\n{\n\tstruct inode *inode;\n\n\tif (!IS_ENABLED(CONFIG_FS_DAX) || !vma->vm_file)\n\t\treturn false;\n\tif (!vma_is_dax(vma))\n\t\treturn false;\n\tinode = file_inode(vma->vm_file);\n\tif (S_ISCHR(inode->i_mode))\n\t\treturn false; /* device-dax */\n\treturn true;\n}\n\nstatic inline int iocb_flags(struct file *file)\n{\n\tint res = 0;\n\tif (file->f_flags & O_APPEND)\n\t\tres |= IOCB_APPEND;\n\tif (file->f_flags & O_DIRECT)\n\t\tres |= IOCB_DIRECT;\n\tif ((file->f_flags & O_DSYNC) || IS_SYNC(file->f_mapping->host))\n\t\tres |= IOCB_DSYNC;\n\tif (file->f_flags & __O_SYNC)\n\t\tres |= IOCB_SYNC;\n\treturn res;\n}\n\nstatic inline int kiocb_set_rw_flags(struct kiocb *ki, rwf_t flags)\n{\n\tint kiocb_flags = 0;\n\n\t/* make sure there's no overlap between RWF and private IOCB flags */\n\tBUILD_BUG_ON((__force int) RWF_SUPPORTED & IOCB_EVENTFD);\n\n\tif (!flags)\n\t\treturn 0;\n\tif (unlikely(flags & ~RWF_SUPPORTED))\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags & RWF_NOWAIT) {\n\t\tif (!(ki->ki_filp->f_mode & FMODE_NOWAIT))\n\t\t\treturn -EOPNOTSUPP;\n\t\tkiocb_flags |= IOCB_NOIO;\n\t}\n\tkiocb_flags |= (__force int) (flags & RWF_SUPPORTED);\n\tif (flags & RWF_SYNC)\n\t\tkiocb_flags |= IOCB_DSYNC;\n\n\tki->ki_flags |= kiocb_flags;\n\treturn 0;\n}\n\nstatic inline ino_t parent_ino(struct dentry *dentry)\n{\n\tino_t res;\n\n\t/*\n\t * Don't strictly need d_lock here? If the parent ino could change\n\t * then surely we'd have a deeper race in the caller?\n\t */\n\tspin_lock(&dentry->d_lock);\n\tres = dentry->d_parent->d_inode->i_ino;\n\tspin_unlock(&dentry->d_lock);\n\treturn res;\n}\n\n/* Transaction based IO helpers */\n\n/*\n * An argresp is stored in an allocated page and holds the\n * size of the argument or response, along with its content\n */\nstruct simple_transaction_argresp {\n\tssize_t size;\n\tchar data[];\n};\n\n#define SIMPLE_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct simple_transaction_argresp))\n\nchar *simple_transaction_get(struct file *file, const char __user *buf,\n\t\t\t\tsize_t size);\nssize_t simple_transaction_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t size, loff_t *pos);\nint simple_transaction_release(struct inode *inode, struct file *file);\n\nvoid simple_transaction_set(struct file *file, size_t n);\n\n/*\n * simple attribute files\n *\n * These attributes behave similar to those in sysfs:\n *\n * Writing to an attribute immediately sets a value, an open file can be\n * written to multiple times.\n *\n * Reading from an attribute creates a buffer from the value that might get\n * read with multiple read calls. When the attribute has been read\n * completely, no further read calls are possible until the file is opened\n * again.\n *\n * All attributes contain a text representation of a numeric value\n * that are accessed with the get() and set() functions.\n */\n#define DEFINE_SIMPLE_ATTRIBUTE(__fops, __get, __set, __fmt)\t\t\\\nstatic int __fops ## _open(struct inode *inode, struct file *file)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t__simple_attr_check_format(__fmt, 0ull);\t\t\t\\\n\treturn simple_attr_open(inode, file, __get, __set, __fmt);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic const struct file_operations __fops = {\t\t\t\t\\\n\t.owner\t = THIS_MODULE,\t\t\t\t\t\t\\\n\t.open\t = __fops ## _open,\t\t\t\t\t\\\n\t.release = simple_attr_release,\t\t\t\t\t\\\n\t.read\t = simple_attr_read,\t\t\t\t\t\\\n\t.write\t = simple_attr_write,\t\t\t\t\t\\\n\t.llseek\t = generic_file_llseek,\t\t\t\t\t\\\n}\n\nstatic inline __printf(1, 2)\nvoid __simple_attr_check_format(const char *fmt, ...)\n{\n\t/* don't do anything, just let the compiler check the arguments; */\n}\n\nint simple_attr_open(struct inode *inode, struct file *file,\n\t\t     int (*get)(void *, u64 *), int (*set)(void *, u64),\n\t\t     const char *fmt);\nint simple_attr_release(struct inode *inode, struct file *file);\nssize_t simple_attr_read(struct file *file, char __user *buf,\n\t\t\t size_t len, loff_t *ppos);\nssize_t simple_attr_write(struct file *file, const char __user *buf,\n\t\t\t  size_t len, loff_t *ppos);\n\nstruct ctl_table;\nint proc_nr_files(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos);\nint proc_nr_dentry(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos);\nint proc_nr_inodes(struct ctl_table *table, int write,\n\t\t   void *buffer, size_t *lenp, loff_t *ppos);\nint __init get_filesystem_list(char *buf);\n\n#define __FMODE_EXEC\t\t((__force int) FMODE_EXEC)\n#define __FMODE_NONOTIFY\t((__force int) FMODE_NONOTIFY)\n\n#define ACC_MODE(x) (\"\\004\\002\\006\\006\"[(x)&O_ACCMODE])\n#define OPEN_FMODE(flag) ((__force fmode_t)(((flag + 1) & O_ACCMODE) | \\\n\t\t\t\t\t    (flag & __FMODE_NONOTIFY)))\n\nstatic inline bool is_sxid(umode_t mode)\n{\n\treturn (mode & S_ISUID) || ((mode & S_ISGID) && (mode & S_IXGRP));\n}\n\nstatic inline int check_sticky(struct user_namespace *mnt_userns,\n\t\t\t       struct inode *dir, struct inode *inode)\n{\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\n\treturn __check_sticky(mnt_userns, dir, inode);\n}\n\nstatic inline void inode_has_no_xattr(struct inode *inode)\n{\n\tif (!is_sxid(inode->i_mode) && (inode->i_sb->s_flags & SB_NOSEC))\n\t\tinode->i_flags |= S_NOSEC;\n}\n\nstatic inline bool is_root_inode(struct inode *inode)\n{\n\treturn inode == inode->i_sb->s_root->d_inode;\n}\n\nstatic inline bool dir_emit(struct dir_context *ctx,\n\t\t\t    const char *name, int namelen,\n\t\t\t    u64 ino, unsigned type)\n{\n\treturn ctx->actor(ctx, name, namelen, ctx->pos, ino, type) == 0;\n}\nstatic inline bool dir_emit_dot(struct file *file, struct dir_context *ctx)\n{\n\treturn ctx->actor(ctx, \".\", 1, ctx->pos,\n\t\t\t  file->f_path.dentry->d_inode->i_ino, DT_DIR) == 0;\n}\nstatic inline bool dir_emit_dotdot(struct file *file, struct dir_context *ctx)\n{\n\treturn ctx->actor(ctx, \"..\", 2, ctx->pos,\n\t\t\t  parent_ino(file->f_path.dentry), DT_DIR) == 0;\n}\nstatic inline bool dir_emit_dots(struct file *file, struct dir_context *ctx)\n{\n\tif (ctx->pos == 0) {\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\treturn false;\n\t\tctx->pos = 1;\n\t}\n\tif (ctx->pos == 1) {\n\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\treturn false;\n\t\tctx->pos = 2;\n\t}\n\treturn true;\n}\nstatic inline bool dir_relax(struct inode *inode)\n{\n\tinode_unlock(inode);\n\tinode_lock(inode);\n\treturn !IS_DEADDIR(inode);\n}\n\nstatic inline bool dir_relax_shared(struct inode *inode)\n{\n\tinode_unlock_shared(inode);\n\tinode_lock_shared(inode);\n\treturn !IS_DEADDIR(inode);\n}\n\nextern bool path_noexec(const struct path *path);\nextern void inode_nohighmem(struct inode *inode);\n\n/* mm/fadvise.c */\nextern int vfs_fadvise(struct file *file, loff_t offset, loff_t len,\n\t\t       int advice);\nextern int generic_fadvise(struct file *file, loff_t offset, loff_t len,\n\t\t\t   int advice);\n\nint vfs_ioc_setflags_prepare(struct inode *inode, unsigned int oldflags,\n\t\t\t     unsigned int flags);\n\nint vfs_ioc_fssetxattr_check(struct inode *inode, const struct fsxattr *old_fa,\n\t\t\t     struct fsxattr *fa);\n\nstatic inline void simple_fill_fsxattr(struct fsxattr *fa, __u32 xflags)\n{\n\tmemset(fa, 0, sizeof(*fa));\n\tfa->fsx_xflags = xflags;\n}\n\n/*\n * Flush file data before changing attributes.  Caller must hold any locks\n * required to prevent further writes to this file until we're done setting\n * flags.\n */\nstatic inline int inode_drain_writes(struct inode *inode)\n{\n\tinode_dio_wait(inode);\n\treturn filemap_write_and_wait(inode->i_mapping);\n}\n\n#endif /* _LINUX_FS_H */\n"}}, "reports": [{"events": [{"location": {"col": 2, "file": 1, "line": 433}, "message": "expanded from macro 'fat_fs_error'"}, {"location": {"col": 6, "file": 0, "line": 909}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 909}, "message": "Taking false branch"}, {"location": {"col": 8, "file": 0, "line": 916}, "message": "Calling 'vfat_find'"}, {"location": {"col": 6, "file": 0, "line": 696}, "message": "Assuming 'len' is not equal to 0"}, {"location": {"col": 2, "file": 0, "line": 696}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 698}, "message": "Returning value, which participates in a condition later"}, {"location": {"col": 8, "file": 0, "line": 916}, "message": "Returning from 'vfat_find'"}, {"location": {"col": 6, "file": 0, "line": 917}, "message": "Assuming 'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 917}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 920}, "message": "Assuming the condition is false"}, {"location": {"col": 21, "file": 2, "line": 23}, "message": "expanded from macro 'S_ISDIR'"}, {"location": {"col": 19, "file": 0, "line": 921}, "message": "'is_dir' is 0"}, {"location": {"col": 26, "file": 0, "line": 921}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 922}, "message": "'update_dotdot' is 0"}, {"location": {"col": 2, "file": 0, "line": 922}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 930}, "message": "Assuming 'new_inode' is non-null"}, {"location": {"col": 2, "file": 0, "line": 930}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 931}, "message": "'is_dir' is 0"}, {"location": {"col": 3, "file": 0, "line": 931}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 949}, "message": "Assuming the condition is true"}, {"location": {"col": 28, "file": 3, "line": 2217}, "message": "expanded from macro 'IS_DIRSYNC'"}, {"location": {"col": 31, "file": 3, "line": 2211}, "message": "expanded from macro '__IS_FLG'"}, {"location": {"col": 6, "file": 0, "line": 949}, "message": "Left side of '||' is true"}, {"location": {"col": 71, "file": 3, "line": 2217}, "message": "expanded from macro 'IS_DIRSYNC'"}, {"location": {"col": 7, "file": 0, "line": 951}, "message": "Assuming 'err' is 0"}, {"location": {"col": 3, "file": 0, "line": 951}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 956}, "message": "'update_dotdot' is 0"}, {"location": {"col": 2, "file": 0, "line": 956}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 971}, "message": "Assuming 'err' is not equal to 0"}, {"location": {"col": 2, "file": 0, "line": 971}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 972}, "message": "Control jumps to line 996"}, {"location": {"col": 6, "file": 0, "line": 998}, "message": "'update_dotdot' is 0"}, {"location": {"col": 2, "file": 0, "line": 998}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1006}, "message": "'new_inode' is non-null"}, {"location": {"col": 2, "file": 0, "line": 1006}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 1008}, "message": "'corrupt' is 1"}, {"location": {"col": 3, "file": 0, "line": 1008}, "message": "Taking true branch"}, {"location": {"col": 6, "file": 0, "line": 1020}, "message": "Assuming 'corrupt' is < 0"}, {"location": {"col": 2, "file": 0, "line": 1020}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 1021}, "message": "5th function call argument is an uninitialized value"}, {"location": {"col": 2, "file": 1, "line": 433}, "message": "expanded from macro 'fat_fs_error'"}, {"location": {"col": 3, "file": 0, "line": 1021}, "message": "5th function call argument is an uninitialized value"}], "macros": [], "notes": [], "path": "/src/fs/fat/namei_vfat.c", "reportHash": "4cbedf6f1a654ab71956ed63e49ca84e", "checkerName": "clang-analyzer-core.CallAndMessage", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
