<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/net/ethernet/intel/igb/igb_main.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/* Copyright(c) 2007 - 2018 Intel Corporation. */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/netdevice.h>\n#include <linux/ipv6.h>\n#include <linux/slab.h>\n#include <net/checksum.h>\n#include <net/ip6_checksum.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n#include <linux/net_tstamp.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/if.h>\n#include <linux/if_vlan.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/sctp.h>\n#include <linux/if_ether.h>\n#include <linux/aer.h>\n#include <linux/prefetch.h>\n#include <linux/bpf.h>\n#include <linux/bpf_trace.h>\n#include <linux/pm_runtime.h>\n#include <linux/etherdevice.h>\n#ifdef CONFIG_IGB_DCA\n#include <linux/dca.h>\n#endif\n#include <linux/i2c.h>\n#include \"igb.h\"\n\nenum queue_mode {\n\tQUEUE_MODE_STRICT_PRIORITY,\n\tQUEUE_MODE_STREAM_RESERVATION,\n};\n\nenum tx_queue_prio {\n\tTX_QUEUE_PRIO_HIGH,\n\tTX_QUEUE_PRIO_LOW,\n};\n\nchar igb_driver_name[] = \"igb\";\nstatic const char igb_driver_string[] =\n\t\t\t\t\"Intel(R) Gigabit Ethernet Network Driver\";\nstatic const char igb_copyright[] =\n\t\t\t\t\"Copyright (c) 2007-2014 Intel Corporation.\";\n\nstatic const struct e1000_info *igb_info_tbl[] = {\n\t[board_82575] = &e1000_82575_info,\n};\n\nstatic const struct pci_device_id igb_pci_tbl[] = {\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_BACKPLANE_1GBPS) },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_SGMII) },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_BACKPLANE_2_5GBPS) },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I211_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_FIBER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_SGMII), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_COPPER_FLASHLESS), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_SERDES_FLASHLESS), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_FIBER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_SGMII), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_FIBER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_QUAD_FIBER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_SGMII), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_COPPER_DUAL), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_DH89XXCC_SGMII), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_DH89XXCC_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_DH89XXCC_BACKPLANE), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_DH89XXCC_SFP), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_NS), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_NS_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_FIBER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_SERDES_QUAD), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_QUAD_COPPER_ET2), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_QUAD_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82575EB_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82575EB_FIBER_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82575GB_QUAD_COPPER), board_82575 },\n\t/* required last entry */\n\t{0, }\n};\n\nMODULE_DEVICE_TABLE(pci, igb_pci_tbl);\n\nstatic int igb_setup_all_tx_resources(struct igb_adapter *);\nstatic int igb_setup_all_rx_resources(struct igb_adapter *);\nstatic void igb_free_all_tx_resources(struct igb_adapter *);\nstatic void igb_free_all_rx_resources(struct igb_adapter *);\nstatic void igb_setup_mrqc(struct igb_adapter *);\nstatic int igb_probe(struct pci_dev *, const struct pci_device_id *);\nstatic void igb_remove(struct pci_dev *pdev);\nstatic int igb_sw_init(struct igb_adapter *);\nint igb_open(struct net_device *);\nint igb_close(struct net_device *);\nstatic void igb_configure(struct igb_adapter *);\nstatic void igb_configure_tx(struct igb_adapter *);\nstatic void igb_configure_rx(struct igb_adapter *);\nstatic void igb_clean_all_tx_rings(struct igb_adapter *);\nstatic void igb_clean_all_rx_rings(struct igb_adapter *);\nstatic void igb_clean_tx_ring(struct igb_ring *);\nstatic void igb_clean_rx_ring(struct igb_ring *);\nstatic void igb_set_rx_mode(struct net_device *);\nstatic void igb_update_phy_info(struct timer_list *);\nstatic void igb_watchdog(struct timer_list *);\nstatic void igb_watchdog_task(struct work_struct *);\nstatic netdev_tx_t igb_xmit_frame(struct sk_buff *skb, struct net_device *);\nstatic void igb_get_stats64(struct net_device *dev,\n\t\t\t    struct rtnl_link_stats64 *stats);\nstatic int igb_change_mtu(struct net_device *, int);\nstatic int igb_set_mac(struct net_device *, void *);\nstatic void igb_set_uta(struct igb_adapter *adapter, bool set);\nstatic irqreturn_t igb_intr(int irq, void *);\nstatic irqreturn_t igb_intr_msi(int irq, void *);\nstatic irqreturn_t igb_msix_other(int irq, void *);\nstatic irqreturn_t igb_msix_ring(int irq, void *);\n#ifdef CONFIG_IGB_DCA\nstatic void igb_update_dca(struct igb_q_vector *);\nstatic void igb_setup_dca(struct igb_adapter *);\n#endif /* CONFIG_IGB_DCA */\nstatic int igb_poll(struct napi_struct *, int);\nstatic bool igb_clean_tx_irq(struct igb_q_vector *, int);\nstatic int igb_clean_rx_irq(struct igb_q_vector *, int);\nstatic int igb_ioctl(struct net_device *, struct ifreq *, int cmd);\nstatic void igb_tx_timeout(struct net_device *, unsigned int txqueue);\nstatic void igb_reset_task(struct work_struct *);\nstatic void igb_vlan_mode(struct net_device *netdev,\n\t\t\t  netdev_features_t features);\nstatic int igb_vlan_rx_add_vid(struct net_device *, __be16, u16);\nstatic int igb_vlan_rx_kill_vid(struct net_device *, __be16, u16);\nstatic void igb_restore_vlan(struct igb_adapter *);\nstatic void igb_rar_set_index(struct igb_adapter *, u32);\nstatic void igb_ping_all_vfs(struct igb_adapter *);\nstatic void igb_msg_task(struct igb_adapter *);\nstatic void igb_vmm_control(struct igb_adapter *);\nstatic int igb_set_vf_mac(struct igb_adapter *, int, unsigned char *);\nstatic void igb_flush_mac_table(struct igb_adapter *);\nstatic int igb_available_rars(struct igb_adapter *, u8);\nstatic void igb_set_default_mac_filter(struct igb_adapter *);\nstatic int igb_uc_sync(struct net_device *, const unsigned char *);\nstatic int igb_uc_unsync(struct net_device *, const unsigned char *);\nstatic void igb_restore_vf_multicasts(struct igb_adapter *adapter);\nstatic int igb_ndo_set_vf_mac(struct net_device *netdev, int vf, u8 *mac);\nstatic int igb_ndo_set_vf_vlan(struct net_device *netdev,\n\t\t\t       int vf, u16 vlan, u8 qos, __be16 vlan_proto);\nstatic int igb_ndo_set_vf_bw(struct net_device *, int, int, int);\nstatic int igb_ndo_set_vf_spoofchk(struct net_device *netdev, int vf,\n\t\t\t\t   bool setting);\nstatic int igb_ndo_set_vf_trust(struct net_device *netdev, int vf,\n\t\t\t\tbool setting);\nstatic int igb_ndo_get_vf_config(struct net_device *netdev, int vf,\n\t\t\t\t struct ifla_vf_info *ivi);\nstatic void igb_check_vf_rate_limit(struct igb_adapter *);\nstatic void igb_nfc_filter_exit(struct igb_adapter *adapter);\nstatic void igb_nfc_filter_restore(struct igb_adapter *adapter);\n\n#ifdef CONFIG_PCI_IOV\nstatic int igb_vf_configure(struct igb_adapter *adapter, int vf);\nstatic int igb_pci_enable_sriov(struct pci_dev *dev, int num_vfs);\nstatic int igb_disable_sriov(struct pci_dev *dev);\nstatic int igb_pci_disable_sriov(struct pci_dev *dev);\n#endif\n\nstatic int igb_suspend(struct device *);\nstatic int igb_resume(struct device *);\nstatic int igb_runtime_suspend(struct device *dev);\nstatic int igb_runtime_resume(struct device *dev);\nstatic int igb_runtime_idle(struct device *dev);\nstatic const struct dev_pm_ops igb_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(igb_suspend, igb_resume)\n\tSET_RUNTIME_PM_OPS(igb_runtime_suspend, igb_runtime_resume,\n\t\t\tigb_runtime_idle)\n};\nstatic void igb_shutdown(struct pci_dev *);\nstatic int igb_pci_sriov_configure(struct pci_dev *dev, int num_vfs);\n#ifdef CONFIG_IGB_DCA\nstatic int igb_notify_dca(struct notifier_block *, unsigned long, void *);\nstatic struct notifier_block dca_notifier = {\n\t.notifier_call\t= igb_notify_dca,\n\t.next\t\t= NULL,\n\t.priority\t= 0\n};\n#endif\n#ifdef CONFIG_PCI_IOV\nstatic unsigned int max_vfs;\nmodule_param(max_vfs, uint, 0);\nMODULE_PARM_DESC(max_vfs, \"Maximum number of virtual functions to allocate per physical function\");\n#endif /* CONFIG_PCI_IOV */\n\nstatic pci_ers_result_t igb_io_error_detected(struct pci_dev *,\n\t\t     pci_channel_state_t);\nstatic pci_ers_result_t igb_io_slot_reset(struct pci_dev *);\nstatic void igb_io_resume(struct pci_dev *);\n\nstatic const struct pci_error_handlers igb_err_handler = {\n\t.error_detected = igb_io_error_detected,\n\t.slot_reset = igb_io_slot_reset,\n\t.resume = igb_io_resume,\n};\n\nstatic void igb_init_dmac(struct igb_adapter *adapter, u32 pba);\n\nstatic struct pci_driver igb_driver = {\n\t.name     = igb_driver_name,\n\t.id_table = igb_pci_tbl,\n\t.probe    = igb_probe,\n\t.remove   = igb_remove,\n#ifdef CONFIG_PM\n\t.driver.pm = &igb_pm_ops,\n#endif\n\t.shutdown = igb_shutdown,\n\t.sriov_configure = igb_pci_sriov_configure,\n\t.err_handler = &igb_err_handler\n};\n\nMODULE_AUTHOR(\"Intel Corporation, <e1000-devel@lists.sourceforge.net>\");\nMODULE_DESCRIPTION(\"Intel(R) Gigabit Ethernet Network Driver\");\nMODULE_LICENSE(\"GPL v2\");\n\n#define DEFAULT_MSG_ENABLE (NETIF_MSG_DRV|NETIF_MSG_PROBE|NETIF_MSG_LINK)\nstatic int debug = -1;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0=none,...,16=all)\");\n\nstruct igb_reg_info {\n\tu32 ofs;\n\tchar *name;\n};\n\nstatic const struct igb_reg_info igb_reg_info_tbl[] = {\n\n\t/* General Registers */\n\t{E1000_CTRL, \"CTRL\"},\n\t{E1000_STATUS, \"STATUS\"},\n\t{E1000_CTRL_EXT, \"CTRL_EXT\"},\n\n\t/* Interrupt Registers */\n\t{E1000_ICR, \"ICR\"},\n\n\t/* RX Registers */\n\t{E1000_RCTL, \"RCTL\"},\n\t{E1000_RDLEN(0), \"RDLEN\"},\n\t{E1000_RDH(0), \"RDH\"},\n\t{E1000_RDT(0), \"RDT\"},\n\t{E1000_RXDCTL(0), \"RXDCTL\"},\n\t{E1000_RDBAL(0), \"RDBAL\"},\n\t{E1000_RDBAH(0), \"RDBAH\"},\n\n\t/* TX Registers */\n\t{E1000_TCTL, \"TCTL\"},\n\t{E1000_TDBAL(0), \"TDBAL\"},\n\t{E1000_TDBAH(0), \"TDBAH\"},\n\t{E1000_TDLEN(0), \"TDLEN\"},\n\t{E1000_TDH(0), \"TDH\"},\n\t{E1000_TDT(0), \"TDT\"},\n\t{E1000_TXDCTL(0), \"TXDCTL\"},\n\t{E1000_TDFH, \"TDFH\"},\n\t{E1000_TDFT, \"TDFT\"},\n\t{E1000_TDFHS, \"TDFHS\"},\n\t{E1000_TDFPC, \"TDFPC\"},\n\n\t/* List Terminator */\n\t{}\n};\n\n/* igb_regdump - register printout routine */\nstatic void igb_regdump(struct e1000_hw *hw, struct igb_reg_info *reginfo)\n{\n\tint n = 0;\n\tchar rname[16];\n\tu32 regs[8];\n\n\tswitch (reginfo->ofs) {\n\tcase E1000_RDLEN(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(E1000_RDLEN(n));\n\t\tbreak;\n\tcase E1000_RDH(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(E1000_RDH(n));\n\t\tbreak;\n\tcase E1000_RDT(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(E1000_RDT(n));\n\t\tbreak;\n\tcase E1000_RXDCTL(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(E1000_RXDCTL(n));\n\t\tbreak;\n\tcase E1000_RDBAL(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(E1000_RDBAL(n));\n\t\tbreak;\n\tcase E1000_RDBAH(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(E1000_RDBAH(n));\n\t\tbreak;\n\tcase E1000_TDBAL(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(E1000_RDBAL(n));\n\t\tbreak;\n\tcase E1000_TDBAH(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(E1000_TDBAH(n));\n\t\tbreak;\n\tcase E1000_TDLEN(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(E1000_TDLEN(n));\n\t\tbreak;\n\tcase E1000_TDH(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(E1000_TDH(n));\n\t\tbreak;\n\tcase E1000_TDT(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(E1000_TDT(n));\n\t\tbreak;\n\tcase E1000_TXDCTL(0):\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tregs[n] = rd32(E1000_TXDCTL(n));\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%-15s %08x\\n\", reginfo->name, rd32(reginfo->ofs));\n\t\treturn;\n\t}\n\n\tsnprintf(rname, 16, \"%s%s\", reginfo->name, \"[0-3]\");\n\tpr_info(\"%-15s %08x %08x %08x %08x\\n\", rname, regs[0], regs[1],\n\t\tregs[2], regs[3]);\n}\n\n/* igb_dump - Print registers, Tx-rings and Rx-rings */\nstatic void igb_dump(struct igb_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct igb_reg_info *reginfo;\n\tstruct igb_ring *tx_ring;\n\tunion e1000_adv_tx_desc *tx_desc;\n\tstruct my_u0 { u64 a; u64 b; } *u0;\n\tstruct igb_ring *rx_ring;\n\tunion e1000_adv_rx_desc *rx_desc;\n\tu32 staterr;\n\tu16 i, n;\n\n\tif (!netif_msg_hw(adapter))\n\t\treturn;\n\n\t/* Print netdevice Info */\n\tif (netdev) {\n\t\tdev_info(&adapter->pdev->dev, \"Net device Info\\n\");\n\t\tpr_info(\"Device Name     state            trans_start\\n\");\n\t\tpr_info(\"%-15s %016lX %016lX\\n\", netdev->name,\n\t\t\tnetdev->state, dev_trans_start(netdev));\n\t}\n\n\t/* Print Registers */\n\tdev_info(&adapter->pdev->dev, \"Register Dump\\n\");\n\tpr_info(\" Register Name   Value\\n\");\n\tfor (reginfo = (struct igb_reg_info *)igb_reg_info_tbl;\n\t     reginfo->name; reginfo++) {\n\t\tigb_regdump(hw, reginfo);\n\t}\n\n\t/* Print TX Ring Summary */\n\tif (!netdev || !netif_running(netdev))\n\t\tgoto exit;\n\n\tdev_info(&adapter->pdev->dev, \"TX Rings Summary\\n\");\n\tpr_info(\"Queue [NTU] [NTC] [bi(ntc)->dma  ] leng ntw timestamp\\n\");\n\tfor (n = 0; n < adapter->num_tx_queues; n++) {\n\t\tstruct igb_tx_buffer *buffer_info;\n\t\ttx_ring = adapter->tx_ring[n];\n\t\tbuffer_info = &tx_ring->tx_buffer_info[tx_ring->next_to_clean];\n\t\tpr_info(\" %5d %5X %5X %016llX %04X %p %016llX\\n\",\n\t\t\tn, tx_ring->next_to_use, tx_ring->next_to_clean,\n\t\t\t(u64)dma_unmap_addr(buffer_info, dma),\n\t\t\tdma_unmap_len(buffer_info, len),\n\t\t\tbuffer_info->next_to_watch,\n\t\t\t(u64)buffer_info->time_stamp);\n\t}\n\n\t/* Print TX Rings */\n\tif (!netif_msg_tx_done(adapter))\n\t\tgoto rx_ring_summary;\n\n\tdev_info(&adapter->pdev->dev, \"TX Rings Dump\\n\");\n\n\t/* Transmit Descriptor Formats\n\t *\n\t * Advanced Transmit Descriptor\n\t *   +--------------------------------------------------------------+\n\t * 0 |         Buffer Address [63:0]                                |\n\t *   +--------------------------------------------------------------+\n\t * 8 | PAYLEN  | PORTS  |CC|IDX | STA | DCMD  |DTYP|MAC|RSV| DTALEN |\n\t *   +--------------------------------------------------------------+\n\t *   63      46 45    40 39 38 36 35 32 31   24             15       0\n\t */\n\n\tfor (n = 0; n < adapter->num_tx_queues; n++) {\n\t\ttx_ring = adapter->tx_ring[n];\n\t\tpr_info(\"------------------------------------\\n\");\n\t\tpr_info(\"TX QUEUE INDEX = %d\\n\", tx_ring->queue_index);\n\t\tpr_info(\"------------------------------------\\n\");\n\t\tpr_info(\"T [desc]     [address 63:0  ] [PlPOCIStDDM Ln] [bi->dma       ] leng  ntw timestamp        bi->skb\\n\");\n\n\t\tfor (i = 0; tx_ring->desc && (i < tx_ring->count); i++) {\n\t\t\tconst char *next_desc;\n\t\t\tstruct igb_tx_buffer *buffer_info;\n\t\t\ttx_desc = IGB_TX_DESC(tx_ring, i);\n\t\t\tbuffer_info = &tx_ring->tx_buffer_info[i];\n\t\t\tu0 = (struct my_u0 *)tx_desc;\n\t\t\tif (i == tx_ring->next_to_use &&\n\t\t\t    i == tx_ring->next_to_clean)\n\t\t\t\tnext_desc = \" NTC/U\";\n\t\t\telse if (i == tx_ring->next_to_use)\n\t\t\t\tnext_desc = \" NTU\";\n\t\t\telse if (i == tx_ring->next_to_clean)\n\t\t\t\tnext_desc = \" NTC\";\n\t\t\telse\n\t\t\t\tnext_desc = \"\";\n\n\t\t\tpr_info(\"T [0x%03X]    %016llX %016llX %016llX %04X  %p %016llX %p%s\\n\",\n\t\t\t\ti, le64_to_cpu(u0->a),\n\t\t\t\tle64_to_cpu(u0->b),\n\t\t\t\t(u64)dma_unmap_addr(buffer_info, dma),\n\t\t\t\tdma_unmap_len(buffer_info, len),\n\t\t\t\tbuffer_info->next_to_watch,\n\t\t\t\t(u64)buffer_info->time_stamp,\n\t\t\t\tbuffer_info->skb, next_desc);\n\n\t\t\tif (netif_msg_pktdata(adapter) && buffer_info->skb)\n\t\t\t\tprint_hex_dump(KERN_INFO, \"\",\n\t\t\t\t\tDUMP_PREFIX_ADDRESS,\n\t\t\t\t\t16, 1, buffer_info->skb->data,\n\t\t\t\t\tdma_unmap_len(buffer_info, len),\n\t\t\t\t\ttrue);\n\t\t}\n\t}\n\n\t/* Print RX Rings Summary */\nrx_ring_summary:\n\tdev_info(&adapter->pdev->dev, \"RX Rings Summary\\n\");\n\tpr_info(\"Queue [NTU] [NTC]\\n\");\n\tfor (n = 0; n < adapter->num_rx_queues; n++) {\n\t\trx_ring = adapter->rx_ring[n];\n\t\tpr_info(\" %5d %5X %5X\\n\",\n\t\t\tn, rx_ring->next_to_use, rx_ring->next_to_clean);\n\t}\n\n\t/* Print RX Rings */\n\tif (!netif_msg_rx_status(adapter))\n\t\tgoto exit;\n\n\tdev_info(&adapter->pdev->dev, \"RX Rings Dump\\n\");\n\n\t/* Advanced Receive Descriptor (Read) Format\n\t *    63                                           1        0\n\t *    +-----------------------------------------------------+\n\t *  0 |       Packet Buffer Address [63:1]           |A0/NSE|\n\t *    +----------------------------------------------+------+\n\t *  8 |       Header Buffer Address [63:1]           |  DD  |\n\t *    +-----------------------------------------------------+\n\t *\n\t *\n\t * Advanced Receive Descriptor (Write-Back) Format\n\t *\n\t *   63       48 47    32 31  30      21 20 17 16   4 3     0\n\t *   +------------------------------------------------------+\n\t * 0 | Packet     IP     |SPH| HDR_LEN   | RSV|Packet|  RSS |\n\t *   | Checksum   Ident  |   |           |    | Type | Type |\n\t *   +------------------------------------------------------+\n\t * 8 | VLAN Tag | Length | Extended Error | Extended Status |\n\t *   +------------------------------------------------------+\n\t *   63       48 47    32 31            20 19               0\n\t */\n\n\tfor (n = 0; n < adapter->num_rx_queues; n++) {\n\t\trx_ring = adapter->rx_ring[n];\n\t\tpr_info(\"------------------------------------\\n\");\n\t\tpr_info(\"RX QUEUE INDEX = %d\\n\", rx_ring->queue_index);\n\t\tpr_info(\"------------------------------------\\n\");\n\t\tpr_info(\"R  [desc]      [ PktBuf     A0] [  HeadBuf   DD] [bi->dma       ] [bi->skb] <-- Adv Rx Read format\\n\");\n\t\tpr_info(\"RWB[desc]      [PcsmIpSHl PtRs] [vl er S cks ln] ---------------- [bi->skb] <-- Adv Rx Write-Back format\\n\");\n\n\t\tfor (i = 0; i < rx_ring->count; i++) {\n\t\t\tconst char *next_desc;\n\t\t\tstruct igb_rx_buffer *buffer_info;\n\t\t\tbuffer_info = &rx_ring->rx_buffer_info[i];\n\t\t\trx_desc = IGB_RX_DESC(rx_ring, i);\n\t\t\tu0 = (struct my_u0 *)rx_desc;\n\t\t\tstaterr = le32_to_cpu(rx_desc->wb.upper.status_error);\n\n\t\t\tif (i == rx_ring->next_to_use)\n\t\t\t\tnext_desc = \" NTU\";\n\t\t\telse if (i == rx_ring->next_to_clean)\n\t\t\t\tnext_desc = \" NTC\";\n\t\t\telse\n\t\t\t\tnext_desc = \"\";\n\n\t\t\tif (staterr & E1000_RXD_STAT_DD) {\n\t\t\t\t/* Descriptor Done */\n\t\t\t\tpr_info(\"%s[0x%03X]     %016llX %016llX ---------------- %s\\n\",\n\t\t\t\t\t\"RWB\", i,\n\t\t\t\t\tle64_to_cpu(u0->a),\n\t\t\t\t\tle64_to_cpu(u0->b),\n\t\t\t\t\tnext_desc);\n\t\t\t} else {\n\t\t\t\tpr_info(\"%s[0x%03X]     %016llX %016llX %016llX %s\\n\",\n\t\t\t\t\t\"R  \", i,\n\t\t\t\t\tle64_to_cpu(u0->a),\n\t\t\t\t\tle64_to_cpu(u0->b),\n\t\t\t\t\t(u64)buffer_info->dma,\n\t\t\t\t\tnext_desc);\n\n\t\t\t\tif (netif_msg_pktdata(adapter) &&\n\t\t\t\t    buffer_info->dma && buffer_info->page) {\n\t\t\t\t\tprint_hex_dump(KERN_INFO, \"\",\n\t\t\t\t\t  DUMP_PREFIX_ADDRESS,\n\t\t\t\t\t  16, 1,\n\t\t\t\t\t  page_address(buffer_info->page) +\n\t\t\t\t\t\t      buffer_info->page_offset,\n\t\t\t\t\t  igb_rx_bufsz(rx_ring), true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n\treturn;\n}\n\n/**\n *  igb_get_i2c_data - Reads the I2C SDA data bit\n *  @data: opaque pointer to adapter struct\n *\n *  Returns the I2C data bit value\n **/\nstatic int igb_get_i2c_data(void *data)\n{\n\tstruct igb_adapter *adapter = (struct igb_adapter *)data;\n\tstruct e1000_hw *hw = &adapter->hw;\n\ts32 i2cctl = rd32(E1000_I2CPARAMS);\n\n\treturn !!(i2cctl & E1000_I2C_DATA_IN);\n}\n\n/**\n *  igb_set_i2c_data - Sets the I2C data bit\n *  @data: pointer to hardware structure\n *  @state: I2C data value (0 or 1) to set\n *\n *  Sets the I2C data bit\n **/\nstatic void igb_set_i2c_data(void *data, int state)\n{\n\tstruct igb_adapter *adapter = (struct igb_adapter *)data;\n\tstruct e1000_hw *hw = &adapter->hw;\n\ts32 i2cctl = rd32(E1000_I2CPARAMS);\n\n\tif (state)\n\t\ti2cctl |= E1000_I2C_DATA_OUT;\n\telse\n\t\ti2cctl &= ~E1000_I2C_DATA_OUT;\n\n\ti2cctl &= ~E1000_I2C_DATA_OE_N;\n\ti2cctl |= E1000_I2C_CLK_OE_N;\n\twr32(E1000_I2CPARAMS, i2cctl);\n\twrfl();\n\n}\n\n/**\n *  igb_set_i2c_clk - Sets the I2C SCL clock\n *  @data: pointer to hardware structure\n *  @state: state to set clock\n *\n *  Sets the I2C clock line to state\n **/\nstatic void igb_set_i2c_clk(void *data, int state)\n{\n\tstruct igb_adapter *adapter = (struct igb_adapter *)data;\n\tstruct e1000_hw *hw = &adapter->hw;\n\ts32 i2cctl = rd32(E1000_I2CPARAMS);\n\n\tif (state) {\n\t\ti2cctl |= E1000_I2C_CLK_OUT;\n\t\ti2cctl &= ~E1000_I2C_CLK_OE_N;\n\t} else {\n\t\ti2cctl &= ~E1000_I2C_CLK_OUT;\n\t\ti2cctl &= ~E1000_I2C_CLK_OE_N;\n\t}\n\twr32(E1000_I2CPARAMS, i2cctl);\n\twrfl();\n}\n\n/**\n *  igb_get_i2c_clk - Gets the I2C SCL clock state\n *  @data: pointer to hardware structure\n *\n *  Gets the I2C clock state\n **/\nstatic int igb_get_i2c_clk(void *data)\n{\n\tstruct igb_adapter *adapter = (struct igb_adapter *)data;\n\tstruct e1000_hw *hw = &adapter->hw;\n\ts32 i2cctl = rd32(E1000_I2CPARAMS);\n\n\treturn !!(i2cctl & E1000_I2C_CLK_IN);\n}\n\nstatic const struct i2c_algo_bit_data igb_i2c_algo = {\n\t.setsda\t\t= igb_set_i2c_data,\n\t.setscl\t\t= igb_set_i2c_clk,\n\t.getsda\t\t= igb_get_i2c_data,\n\t.getscl\t\t= igb_get_i2c_clk,\n\t.udelay\t\t= 5,\n\t.timeout\t= 20,\n};\n\n/**\n *  igb_get_hw_dev - return device\n *  @hw: pointer to hardware structure\n *\n *  used by hardware layer to print debugging information\n **/\nstruct net_device *igb_get_hw_dev(struct e1000_hw *hw)\n{\n\tstruct igb_adapter *adapter = hw->back;\n\treturn adapter->netdev;\n}\n\n/**\n *  igb_init_module - Driver Registration Routine\n *\n *  igb_init_module is the first routine called when the driver is\n *  loaded. All it does is register with the PCI subsystem.\n **/\nstatic int __init igb_init_module(void)\n{\n\tint ret;\n\n\tpr_info(\"%s\\n\", igb_driver_string);\n\tpr_info(\"%s\\n\", igb_copyright);\n\n#ifdef CONFIG_IGB_DCA\n\tdca_register_notify(&dca_notifier);\n#endif\n\tret = pci_register_driver(&igb_driver);\n\treturn ret;\n}\n\nmodule_init(igb_init_module);\n\n/**\n *  igb_exit_module - Driver Exit Cleanup Routine\n *\n *  igb_exit_module is called just before the driver is removed\n *  from memory.\n **/\nstatic void __exit igb_exit_module(void)\n{\n#ifdef CONFIG_IGB_DCA\n\tdca_unregister_notify(&dca_notifier);\n#endif\n\tpci_unregister_driver(&igb_driver);\n}\n\nmodule_exit(igb_exit_module);\n\n#define Q_IDX_82576(i) (((i & 0x1) << 3) + (i >> 1))\n/**\n *  igb_cache_ring_register - Descriptor ring to register mapping\n *  @adapter: board private structure to initialize\n *\n *  Once we know the feature-set enabled for the device, we'll cache\n *  the register offset the descriptor ring is assigned to.\n **/\nstatic void igb_cache_ring_register(struct igb_adapter *adapter)\n{\n\tint i = 0, j = 0;\n\tu32 rbase_offset = adapter->vfs_allocated_count;\n\n\tswitch (adapter->hw.mac.type) {\n\tcase e1000_82576:\n\t\t/* The queues are allocated for virtualization such that VF 0\n\t\t * is allocated queues 0 and 8, VF 1 queues 1 and 9, etc.\n\t\t * In order to avoid collision we start at the first free queue\n\t\t * and continue consuming queues in the same sequence\n\t\t */\n\t\tif (adapter->vfs_allocated_count) {\n\t\t\tfor (; i < adapter->rss_queues; i++)\n\t\t\t\tadapter->rx_ring[i]->reg_idx = rbase_offset +\n\t\t\t\t\t\t\t       Q_IDX_82576(i);\n\t\t}\n\t\tfallthrough;\n\tcase e1000_82575:\n\tcase e1000_82580:\n\tcase e1000_i350:\n\tcase e1000_i354:\n\tcase e1000_i210:\n\tcase e1000_i211:\n\tdefault:\n\t\tfor (; i < adapter->num_rx_queues; i++)\n\t\t\tadapter->rx_ring[i]->reg_idx = rbase_offset + i;\n\t\tfor (; j < adapter->num_tx_queues; j++)\n\t\t\tadapter->tx_ring[j]->reg_idx = rbase_offset + j;\n\t\tbreak;\n\t}\n}\n\nu32 igb_rd32(struct e1000_hw *hw, u32 reg)\n{\n\tstruct igb_adapter *igb = container_of(hw, struct igb_adapter, hw);\n\tu8 __iomem *hw_addr = READ_ONCE(hw->hw_addr);\n\tu32 value = 0;\n\n\tif (E1000_REMOVED(hw_addr))\n\t\treturn ~value;\n\n\tvalue = readl(&hw_addr[reg]);\n\n\t/* reads should not return all F's */\n\tif (!(~value) && (!reg || !(~readl(hw_addr)))) {\n\t\tstruct net_device *netdev = igb->netdev;\n\t\thw->hw_addr = NULL;\n\t\tnetdev_err(netdev, \"PCIe link lost\\n\");\n\t\tWARN(pci_device_is_present(igb->pdev),\n\t\t     \"igb: Failed to read reg 0x%x!\\n\", reg);\n\t}\n\n\treturn value;\n}\n\n/**\n *  igb_write_ivar - configure ivar for given MSI-X vector\n *  @hw: pointer to the HW structure\n *  @msix_vector: vector number we are allocating to a given ring\n *  @index: row index of IVAR register to write within IVAR table\n *  @offset: column offset of in IVAR, should be multiple of 8\n *\n *  This function is intended to handle the writing of the IVAR register\n *  for adapters 82576 and newer.  The IVAR table consists of 2 columns,\n *  each containing an cause allocation for an Rx and Tx ring, and a\n *  variable number of rows depending on the number of queues supported.\n **/\nstatic void igb_write_ivar(struct e1000_hw *hw, int msix_vector,\n\t\t\t   int index, int offset)\n{\n\tu32 ivar = array_rd32(E1000_IVAR0, index);\n\n\t/* clear any bits that are currently set */\n\tivar &= ~((u32)0xFF << offset);\n\n\t/* write vector and valid bit */\n\tivar |= (msix_vector | E1000_IVAR_VALID) << offset;\n\n\tarray_wr32(E1000_IVAR0, index, ivar);\n}\n\n#define IGB_N0_QUEUE -1\nstatic void igb_assign_vector(struct igb_q_vector *q_vector, int msix_vector)\n{\n\tstruct igb_adapter *adapter = q_vector->adapter;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint rx_queue = IGB_N0_QUEUE;\n\tint tx_queue = IGB_N0_QUEUE;\n\tu32 msixbm = 0;\n\n\tif (q_vector->rx.ring)\n\t\trx_queue = q_vector->rx.ring->reg_idx;\n\tif (q_vector->tx.ring)\n\t\ttx_queue = q_vector->tx.ring->reg_idx;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_82575:\n\t\t/* The 82575 assigns vectors using a bitmask, which matches the\n\t\t * bitmask for the EICR/EIMS/EIMC registers.  To assign one\n\t\t * or more queues to a vector, we write the appropriate bits\n\t\t * into the MSIXBM register for that vector.\n\t\t */\n\t\tif (rx_queue > IGB_N0_QUEUE)\n\t\t\tmsixbm = E1000_EICR_RX_QUEUE0 << rx_queue;\n\t\tif (tx_queue > IGB_N0_QUEUE)\n\t\t\tmsixbm |= E1000_EICR_TX_QUEUE0 << tx_queue;\n\t\tif (!(adapter->flags & IGB_FLAG_HAS_MSIX) && msix_vector == 0)\n\t\t\tmsixbm |= E1000_EIMS_OTHER;\n\t\tarray_wr32(E1000_MSIXBM(0), msix_vector, msixbm);\n\t\tq_vector->eims_value = msixbm;\n\t\tbreak;\n\tcase e1000_82576:\n\t\t/* 82576 uses a table that essentially consists of 2 columns\n\t\t * with 8 rows.  The ordering is column-major so we use the\n\t\t * lower 3 bits as the row index, and the 4th bit as the\n\t\t * column offset.\n\t\t */\n\t\tif (rx_queue > IGB_N0_QUEUE)\n\t\t\tigb_write_ivar(hw, msix_vector,\n\t\t\t\t       rx_queue & 0x7,\n\t\t\t\t       (rx_queue & 0x8) << 1);\n\t\tif (tx_queue > IGB_N0_QUEUE)\n\t\t\tigb_write_ivar(hw, msix_vector,\n\t\t\t\t       tx_queue & 0x7,\n\t\t\t\t       ((tx_queue & 0x8) << 1) + 8);\n\t\tq_vector->eims_value = BIT(msix_vector);\n\t\tbreak;\n\tcase e1000_82580:\n\tcase e1000_i350:\n\tcase e1000_i354:\n\tcase e1000_i210:\n\tcase e1000_i211:\n\t\t/* On 82580 and newer adapters the scheme is similar to 82576\n\t\t * however instead of ordering column-major we have things\n\t\t * ordered row-major.  So we traverse the table by using\n\t\t * bit 0 as the column offset, and the remaining bits as the\n\t\t * row index.\n\t\t */\n\t\tif (rx_queue > IGB_N0_QUEUE)\n\t\t\tigb_write_ivar(hw, msix_vector,\n\t\t\t\t       rx_queue >> 1,\n\t\t\t\t       (rx_queue & 0x1) << 4);\n\t\tif (tx_queue > IGB_N0_QUEUE)\n\t\t\tigb_write_ivar(hw, msix_vector,\n\t\t\t\t       tx_queue >> 1,\n\t\t\t\t       ((tx_queue & 0x1) << 4) + 8);\n\t\tq_vector->eims_value = BIT(msix_vector);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\t/* add q_vector eims value to global eims_enable_mask */\n\tadapter->eims_enable_mask |= q_vector->eims_value;\n\n\t/* configure q_vector to set itr on first interrupt */\n\tq_vector->set_itr = 1;\n}\n\n/**\n *  igb_configure_msix - Configure MSI-X hardware\n *  @adapter: board private structure to initialize\n *\n *  igb_configure_msix sets up the hardware to properly\n *  generate MSI-X interrupts.\n **/\nstatic void igb_configure_msix(struct igb_adapter *adapter)\n{\n\tu32 tmp;\n\tint i, vector = 0;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tadapter->eims_enable_mask = 0;\n\n\t/* set vector for other causes, i.e. link changes */\n\tswitch (hw->mac.type) {\n\tcase e1000_82575:\n\t\ttmp = rd32(E1000_CTRL_EXT);\n\t\t/* enable MSI-X PBA support*/\n\t\ttmp |= E1000_CTRL_EXT_PBA_CLR;\n\n\t\t/* Auto-Mask interrupts upon ICR read. */\n\t\ttmp |= E1000_CTRL_EXT_EIAME;\n\t\ttmp |= E1000_CTRL_EXT_IRCA;\n\n\t\twr32(E1000_CTRL_EXT, tmp);\n\n\t\t/* enable msix_other interrupt */\n\t\tarray_wr32(E1000_MSIXBM(0), vector++, E1000_EIMS_OTHER);\n\t\tadapter->eims_other = E1000_EIMS_OTHER;\n\n\t\tbreak;\n\n\tcase e1000_82576:\n\tcase e1000_82580:\n\tcase e1000_i350:\n\tcase e1000_i354:\n\tcase e1000_i210:\n\tcase e1000_i211:\n\t\t/* Turn on MSI-X capability first, or our settings\n\t\t * won't stick.  And it will take days to debug.\n\t\t */\n\t\twr32(E1000_GPIE, E1000_GPIE_MSIX_MODE |\n\t\t     E1000_GPIE_PBA | E1000_GPIE_EIAME |\n\t\t     E1000_GPIE_NSICR);\n\n\t\t/* enable msix_other interrupt */\n\t\tadapter->eims_other = BIT(vector);\n\t\ttmp = (vector++ | E1000_IVAR_VALID) << 8;\n\n\t\twr32(E1000_IVAR_MISC, tmp);\n\t\tbreak;\n\tdefault:\n\t\t/* do nothing, since nothing else supports MSI-X */\n\t\tbreak;\n\t} /* switch (hw->mac.type) */\n\n\tadapter->eims_enable_mask |= adapter->eims_other;\n\n\tfor (i = 0; i < adapter->num_q_vectors; i++)\n\t\tigb_assign_vector(adapter->q_vector[i], vector++);\n\n\twrfl();\n}\n\n/**\n *  igb_request_msix - Initialize MSI-X interrupts\n *  @adapter: board private structure to initialize\n *\n *  igb_request_msix allocates MSI-X vectors and requests interrupts from the\n *  kernel.\n **/\nstatic int igb_request_msix(struct igb_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint i, err = 0, vector = 0, free_vector = 0;\n\n\terr = request_irq(adapter->msix_entries[vector].vector,\n\t\t\t  igb_msix_other, 0, netdev->name, adapter);\n\tif (err)\n\t\tgoto err_out;\n\n\tfor (i = 0; i < adapter->num_q_vectors; i++) {\n\t\tstruct igb_q_vector *q_vector = adapter->q_vector[i];\n\n\t\tvector++;\n\n\t\tq_vector->itr_register = adapter->io_addr + E1000_EITR(vector);\n\n\t\tif (q_vector->rx.ring && q_vector->tx.ring)\n\t\t\tsprintf(q_vector->name, \"%s-TxRx-%u\", netdev->name,\n\t\t\t\tq_vector->rx.ring->queue_index);\n\t\telse if (q_vector->tx.ring)\n\t\t\tsprintf(q_vector->name, \"%s-tx-%u\", netdev->name,\n\t\t\t\tq_vector->tx.ring->queue_index);\n\t\telse if (q_vector->rx.ring)\n\t\t\tsprintf(q_vector->name, \"%s-rx-%u\", netdev->name,\n\t\t\t\tq_vector->rx.ring->queue_index);\n\t\telse\n\t\t\tsprintf(q_vector->name, \"%s-unused\", netdev->name);\n\n\t\terr = request_irq(adapter->msix_entries[vector].vector,\n\t\t\t\t  igb_msix_ring, 0, q_vector->name,\n\t\t\t\t  q_vector);\n\t\tif (err)\n\t\t\tgoto err_free;\n\t}\n\n\tigb_configure_msix(adapter);\n\treturn 0;\n\nerr_free:\n\t/* free already assigned IRQs */\n\tfree_irq(adapter->msix_entries[free_vector++].vector, adapter);\n\n\tvector--;\n\tfor (i = 0; i < vector; i++) {\n\t\tfree_irq(adapter->msix_entries[free_vector++].vector,\n\t\t\t adapter->q_vector[i]);\n\t}\nerr_out:\n\treturn err;\n}\n\n/**\n *  igb_free_q_vector - Free memory allocated for specific interrupt vector\n *  @adapter: board private structure to initialize\n *  @v_idx: Index of vector to be freed\n *\n *  This function frees the memory allocated to the q_vector.\n **/\nstatic void igb_free_q_vector(struct igb_adapter *adapter, int v_idx)\n{\n\tstruct igb_q_vector *q_vector = adapter->q_vector[v_idx];\n\n\tadapter->q_vector[v_idx] = NULL;\n\n\t/* igb_get_stats64() might access the rings on this vector,\n\t * we must wait a grace period before freeing it.\n\t */\n\tif (q_vector)\n\t\tkfree_rcu(q_vector, rcu);\n}\n\n/**\n *  igb_reset_q_vector - Reset config for interrupt vector\n *  @adapter: board private structure to initialize\n *  @v_idx: Index of vector to be reset\n *\n *  If NAPI is enabled it will delete any references to the\n *  NAPI struct. This is preparation for igb_free_q_vector.\n **/\nstatic void igb_reset_q_vector(struct igb_adapter *adapter, int v_idx)\n{\n\tstruct igb_q_vector *q_vector = adapter->q_vector[v_idx];\n\n\t/* Coming from igb_set_interrupt_capability, the vectors are not yet\n\t * allocated. So, q_vector is NULL so we should stop here.\n\t */\n\tif (!q_vector)\n\t\treturn;\n\n\tif (q_vector->tx.ring)\n\t\tadapter->tx_ring[q_vector->tx.ring->queue_index] = NULL;\n\n\tif (q_vector->rx.ring)\n\t\tadapter->rx_ring[q_vector->rx.ring->queue_index] = NULL;\n\n\tnetif_napi_del(&q_vector->napi);\n\n}\n\nstatic void igb_reset_interrupt_capability(struct igb_adapter *adapter)\n{\n\tint v_idx = adapter->num_q_vectors;\n\n\tif (adapter->flags & IGB_FLAG_HAS_MSIX)\n\t\tpci_disable_msix(adapter->pdev);\n\telse if (adapter->flags & IGB_FLAG_HAS_MSI)\n\t\tpci_disable_msi(adapter->pdev);\n\n\twhile (v_idx--)\n\t\tigb_reset_q_vector(adapter, v_idx);\n}\n\n/**\n *  igb_free_q_vectors - Free memory allocated for interrupt vectors\n *  @adapter: board private structure to initialize\n *\n *  This function frees the memory allocated to the q_vectors.  In addition if\n *  NAPI is enabled it will delete any references to the NAPI struct prior\n *  to freeing the q_vector.\n **/\nstatic void igb_free_q_vectors(struct igb_adapter *adapter)\n{\n\tint v_idx = adapter->num_q_vectors;\n\n\tadapter->num_tx_queues = 0;\n\tadapter->num_rx_queues = 0;\n\tadapter->num_q_vectors = 0;\n\n\twhile (v_idx--) {\n\t\tigb_reset_q_vector(adapter, v_idx);\n\t\tigb_free_q_vector(adapter, v_idx);\n\t}\n}\n\n/**\n *  igb_clear_interrupt_scheme - reset the device to a state of no interrupts\n *  @adapter: board private structure to initialize\n *\n *  This function resets the device so that it has 0 Rx queues, Tx queues, and\n *  MSI-X interrupts allocated.\n */\nstatic void igb_clear_interrupt_scheme(struct igb_adapter *adapter)\n{\n\tigb_free_q_vectors(adapter);\n\tigb_reset_interrupt_capability(adapter);\n}\n\n/**\n *  igb_set_interrupt_capability - set MSI or MSI-X if supported\n *  @adapter: board private structure to initialize\n *  @msix: boolean value of MSIX capability\n *\n *  Attempt to configure interrupts using the best available\n *  capabilities of the hardware and kernel.\n **/\nstatic void igb_set_interrupt_capability(struct igb_adapter *adapter, bool msix)\n{\n\tint err;\n\tint numvecs, i;\n\n\tif (!msix)\n\t\tgoto msi_only;\n\tadapter->flags |= IGB_FLAG_HAS_MSIX;\n\n\t/* Number of supported queues. */\n\tadapter->num_rx_queues = adapter->rss_queues;\n\tif (adapter->vfs_allocated_count)\n\t\tadapter->num_tx_queues = 1;\n\telse\n\t\tadapter->num_tx_queues = adapter->rss_queues;\n\n\t/* start with one vector for every Rx queue */\n\tnumvecs = adapter->num_rx_queues;\n\n\t/* if Tx handler is separate add 1 for every Tx queue */\n\tif (!(adapter->flags & IGB_FLAG_QUEUE_PAIRS))\n\t\tnumvecs += adapter->num_tx_queues;\n\n\t/* store the number of vectors reserved for queues */\n\tadapter->num_q_vectors = numvecs;\n\n\t/* add 1 vector for link status interrupts */\n\tnumvecs++;\n\tfor (i = 0; i < numvecs; i++)\n\t\tadapter->msix_entries[i].entry = i;\n\n\terr = pci_enable_msix_range(adapter->pdev,\n\t\t\t\t    adapter->msix_entries,\n\t\t\t\t    numvecs,\n\t\t\t\t    numvecs);\n\tif (err > 0)\n\t\treturn;\n\n\tigb_reset_interrupt_capability(adapter);\n\n\t/* If we can't do MSI-X, try MSI */\nmsi_only:\n\tadapter->flags &= ~IGB_FLAG_HAS_MSIX;\n#ifdef CONFIG_PCI_IOV\n\t/* disable SR-IOV for non MSI-X configurations */\n\tif (adapter->vf_data) {\n\t\tstruct e1000_hw *hw = &adapter->hw;\n\t\t/* disable iov and allow time for transactions to clear */\n\t\tpci_disable_sriov(adapter->pdev);\n\t\tmsleep(500);\n\n\t\tkfree(adapter->vf_mac_list);\n\t\tadapter->vf_mac_list = NULL;\n\t\tkfree(adapter->vf_data);\n\t\tadapter->vf_data = NULL;\n\t\twr32(E1000_IOVCTL, E1000_IOVCTL_REUSE_VFQ);\n\t\twrfl();\n\t\tmsleep(100);\n\t\tdev_info(&adapter->pdev->dev, \"IOV Disabled\\n\");\n\t}\n#endif\n\tadapter->vfs_allocated_count = 0;\n\tadapter->rss_queues = 1;\n\tadapter->flags |= IGB_FLAG_QUEUE_PAIRS;\n\tadapter->num_rx_queues = 1;\n\tadapter->num_tx_queues = 1;\n\tadapter->num_q_vectors = 1;\n\tif (!pci_enable_msi(adapter->pdev))\n\t\tadapter->flags |= IGB_FLAG_HAS_MSI;\n}\n\nstatic void igb_add_ring(struct igb_ring *ring,\n\t\t\t struct igb_ring_container *head)\n{\n\thead->ring = ring;\n\thead->count++;\n}\n\n/**\n *  igb_alloc_q_vector - Allocate memory for a single interrupt vector\n *  @adapter: board private structure to initialize\n *  @v_count: q_vectors allocated on adapter, used for ring interleaving\n *  @v_idx: index of vector in adapter struct\n *  @txr_count: total number of Tx rings to allocate\n *  @txr_idx: index of first Tx ring to allocate\n *  @rxr_count: total number of Rx rings to allocate\n *  @rxr_idx: index of first Rx ring to allocate\n *\n *  We allocate one q_vector.  If allocation fails we return -ENOMEM.\n **/\nstatic int igb_alloc_q_vector(struct igb_adapter *adapter,\n\t\t\t      int v_count, int v_idx,\n\t\t\t      int txr_count, int txr_idx,\n\t\t\t      int rxr_count, int rxr_idx)\n{\n\tstruct igb_q_vector *q_vector;\n\tstruct igb_ring *ring;\n\tint ring_count;\n\tsize_t size;\n\n\t/* igb only supports 1 Tx and/or 1 Rx queue per vector */\n\tif (txr_count > 1 || rxr_count > 1)\n\t\treturn -ENOMEM;\n\n\tring_count = txr_count + rxr_count;\n\tsize = struct_size(q_vector, ring, ring_count);\n\n\t/* allocate q_vector and rings */\n\tq_vector = adapter->q_vector[v_idx];\n\tif (!q_vector) {\n\t\tq_vector = kzalloc(size, GFP_KERNEL);\n\t} else if (size > ksize(q_vector)) {\n\t\tkfree_rcu(q_vector, rcu);\n\t\tq_vector = kzalloc(size, GFP_KERNEL);\n\t} else {\n\t\tmemset(q_vector, 0, size);\n\t}\n\tif (!q_vector)\n\t\treturn -ENOMEM;\n\n\t/* initialize NAPI */\n\tnetif_napi_add(adapter->netdev, &q_vector->napi,\n\t\t       igb_poll, 64);\n\n\t/* tie q_vector and adapter together */\n\tadapter->q_vector[v_idx] = q_vector;\n\tq_vector->adapter = adapter;\n\n\t/* initialize work limits */\n\tq_vector->tx.work_limit = adapter->tx_work_limit;\n\n\t/* initialize ITR configuration */\n\tq_vector->itr_register = adapter->io_addr + E1000_EITR(0);\n\tq_vector->itr_val = IGB_START_ITR;\n\n\t/* initialize pointer to rings */\n\tring = q_vector->ring;\n\n\t/* intialize ITR */\n\tif (rxr_count) {\n\t\t/* rx or rx/tx vector */\n\t\tif (!adapter->rx_itr_setting || adapter->rx_itr_setting > 3)\n\t\t\tq_vector->itr_val = adapter->rx_itr_setting;\n\t} else {\n\t\t/* tx only vector */\n\t\tif (!adapter->tx_itr_setting || adapter->tx_itr_setting > 3)\n\t\t\tq_vector->itr_val = adapter->tx_itr_setting;\n\t}\n\n\tif (txr_count) {\n\t\t/* assign generic ring traits */\n\t\tring->dev = &adapter->pdev->dev;\n\t\tring->netdev = adapter->netdev;\n\n\t\t/* configure backlink on ring */\n\t\tring->q_vector = q_vector;\n\n\t\t/* update q_vector Tx values */\n\t\tigb_add_ring(ring, &q_vector->tx);\n\n\t\t/* For 82575, context index must be unique per ring. */\n\t\tif (adapter->hw.mac.type == e1000_82575)\n\t\t\tset_bit(IGB_RING_FLAG_TX_CTX_IDX, &ring->flags);\n\n\t\t/* apply Tx specific ring traits */\n\t\tring->count = adapter->tx_ring_count;\n\t\tring->queue_index = txr_idx;\n\n\t\tring->cbs_enable = false;\n\t\tring->idleslope = 0;\n\t\tring->sendslope = 0;\n\t\tring->hicredit = 0;\n\t\tring->locredit = 0;\n\n\t\tu64_stats_init(&ring->tx_syncp);\n\t\tu64_stats_init(&ring->tx_syncp2);\n\n\t\t/* assign ring to adapter */\n\t\tadapter->tx_ring[txr_idx] = ring;\n\n\t\t/* push pointer to next ring */\n\t\tring++;\n\t}\n\n\tif (rxr_count) {\n\t\t/* assign generic ring traits */\n\t\tring->dev = &adapter->pdev->dev;\n\t\tring->netdev = adapter->netdev;\n\n\t\t/* configure backlink on ring */\n\t\tring->q_vector = q_vector;\n\n\t\t/* update q_vector Rx values */\n\t\tigb_add_ring(ring, &q_vector->rx);\n\n\t\t/* set flag indicating ring supports SCTP checksum offload */\n\t\tif (adapter->hw.mac.type >= e1000_82576)\n\t\t\tset_bit(IGB_RING_FLAG_RX_SCTP_CSUM, &ring->flags);\n\n\t\t/* On i350, i354, i210, and i211, loopback VLAN packets\n\t\t * have the tag byte-swapped.\n\t\t */\n\t\tif (adapter->hw.mac.type >= e1000_i350)\n\t\t\tset_bit(IGB_RING_FLAG_RX_LB_VLAN_BSWAP, &ring->flags);\n\n\t\t/* apply Rx specific ring traits */\n\t\tring->count = adapter->rx_ring_count;\n\t\tring->queue_index = rxr_idx;\n\n\t\tu64_stats_init(&ring->rx_syncp);\n\n\t\t/* assign ring to adapter */\n\t\tadapter->rx_ring[rxr_idx] = ring;\n\t}\n\n\treturn 0;\n}\n\n\n/**\n *  igb_alloc_q_vectors - Allocate memory for interrupt vectors\n *  @adapter: board private structure to initialize\n *\n *  We allocate one q_vector per queue interrupt.  If allocation fails we\n *  return -ENOMEM.\n **/\nstatic int igb_alloc_q_vectors(struct igb_adapter *adapter)\n{\n\tint q_vectors = adapter->num_q_vectors;\n\tint rxr_remaining = adapter->num_rx_queues;\n\tint txr_remaining = adapter->num_tx_queues;\n\tint rxr_idx = 0, txr_idx = 0, v_idx = 0;\n\tint err;\n\n\tif (q_vectors >= (rxr_remaining + txr_remaining)) {\n\t\tfor (; rxr_remaining; v_idx++) {\n\t\t\terr = igb_alloc_q_vector(adapter, q_vectors, v_idx,\n\t\t\t\t\t\t 0, 0, 1, rxr_idx);\n\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\n\t\t\t/* update counts and index */\n\t\t\trxr_remaining--;\n\t\t\trxr_idx++;\n\t\t}\n\t}\n\n\tfor (; v_idx < q_vectors; v_idx++) {\n\t\tint rqpv = DIV_ROUND_UP(rxr_remaining, q_vectors - v_idx);\n\t\tint tqpv = DIV_ROUND_UP(txr_remaining, q_vectors - v_idx);\n\n\t\terr = igb_alloc_q_vector(adapter, q_vectors, v_idx,\n\t\t\t\t\t tqpv, txr_idx, rqpv, rxr_idx);\n\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\t/* update counts and index */\n\t\trxr_remaining -= rqpv;\n\t\ttxr_remaining -= tqpv;\n\t\trxr_idx++;\n\t\ttxr_idx++;\n\t}\n\n\treturn 0;\n\nerr_out:\n\tadapter->num_tx_queues = 0;\n\tadapter->num_rx_queues = 0;\n\tadapter->num_q_vectors = 0;\n\n\twhile (v_idx--)\n\t\tigb_free_q_vector(adapter, v_idx);\n\n\treturn -ENOMEM;\n}\n\n/**\n *  igb_init_interrupt_scheme - initialize interrupts, allocate queues/vectors\n *  @adapter: board private structure to initialize\n *  @msix: boolean value of MSIX capability\n *\n *  This function initializes the interrupts and allocates all of the queues.\n **/\nstatic int igb_init_interrupt_scheme(struct igb_adapter *adapter, bool msix)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint err;\n\n\tigb_set_interrupt_capability(adapter, msix);\n\n\terr = igb_alloc_q_vectors(adapter);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Unable to allocate memory for vectors\\n\");\n\t\tgoto err_alloc_q_vectors;\n\t}\n\n\tigb_cache_ring_register(adapter);\n\n\treturn 0;\n\nerr_alloc_q_vectors:\n\tigb_reset_interrupt_capability(adapter);\n\treturn err;\n}\n\n/**\n *  igb_request_irq - initialize interrupts\n *  @adapter: board private structure to initialize\n *\n *  Attempts to configure interrupts using the best available\n *  capabilities of the hardware and kernel.\n **/\nstatic int igb_request_irq(struct igb_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint err = 0;\n\n\tif (adapter->flags & IGB_FLAG_HAS_MSIX) {\n\t\terr = igb_request_msix(adapter);\n\t\tif (!err)\n\t\t\tgoto request_done;\n\t\t/* fall back to MSI */\n\t\tigb_free_all_tx_resources(adapter);\n\t\tigb_free_all_rx_resources(adapter);\n\n\t\tigb_clear_interrupt_scheme(adapter);\n\t\terr = igb_init_interrupt_scheme(adapter, false);\n\t\tif (err)\n\t\t\tgoto request_done;\n\n\t\tigb_setup_all_tx_resources(adapter);\n\t\tigb_setup_all_rx_resources(adapter);\n\t\tigb_configure(adapter);\n\t}\n\n\tigb_assign_vector(adapter->q_vector[0], 0);\n\n\tif (adapter->flags & IGB_FLAG_HAS_MSI) {\n\t\terr = request_irq(pdev->irq, igb_intr_msi, 0,\n\t\t\t\t  netdev->name, adapter);\n\t\tif (!err)\n\t\t\tgoto request_done;\n\n\t\t/* fall back to legacy interrupts */\n\t\tigb_reset_interrupt_capability(adapter);\n\t\tadapter->flags &= ~IGB_FLAG_HAS_MSI;\n\t}\n\n\terr = request_irq(pdev->irq, igb_intr, IRQF_SHARED,\n\t\t\t  netdev->name, adapter);\n\n\tif (err)\n\t\tdev_err(&pdev->dev, \"Error %d getting interrupt\\n\",\n\t\t\terr);\n\nrequest_done:\n\treturn err;\n}\n\nstatic void igb_free_irq(struct igb_adapter *adapter)\n{\n\tif (adapter->flags & IGB_FLAG_HAS_MSIX) {\n\t\tint vector = 0, i;\n\n\t\tfree_irq(adapter->msix_entries[vector++].vector, adapter);\n\n\t\tfor (i = 0; i < adapter->num_q_vectors; i++)\n\t\t\tfree_irq(adapter->msix_entries[vector++].vector,\n\t\t\t\t adapter->q_vector[i]);\n\t} else {\n\t\tfree_irq(adapter->pdev->irq, adapter);\n\t}\n}\n\n/**\n *  igb_irq_disable - Mask off interrupt generation on the NIC\n *  @adapter: board private structure\n **/\nstatic void igb_irq_disable(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t/* we need to be careful when disabling interrupts.  The VFs are also\n\t * mapped into these registers and so clearing the bits can cause\n\t * issues on the VF drivers so we only need to clear what we set\n\t */\n\tif (adapter->flags & IGB_FLAG_HAS_MSIX) {\n\t\tu32 regval = rd32(E1000_EIAM);\n\n\t\twr32(E1000_EIAM, regval & ~adapter->eims_enable_mask);\n\t\twr32(E1000_EIMC, adapter->eims_enable_mask);\n\t\tregval = rd32(E1000_EIAC);\n\t\twr32(E1000_EIAC, regval & ~adapter->eims_enable_mask);\n\t}\n\n\twr32(E1000_IAM, 0);\n\twr32(E1000_IMC, ~0);\n\twrfl();\n\tif (adapter->flags & IGB_FLAG_HAS_MSIX) {\n\t\tint i;\n\n\t\tfor (i = 0; i < adapter->num_q_vectors; i++)\n\t\t\tsynchronize_irq(adapter->msix_entries[i].vector);\n\t} else {\n\t\tsynchronize_irq(adapter->pdev->irq);\n\t}\n}\n\n/**\n *  igb_irq_enable - Enable default interrupt generation settings\n *  @adapter: board private structure\n **/\nstatic void igb_irq_enable(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (adapter->flags & IGB_FLAG_HAS_MSIX) {\n\t\tu32 ims = E1000_IMS_LSC | E1000_IMS_DOUTSYNC | E1000_IMS_DRSTA;\n\t\tu32 regval = rd32(E1000_EIAC);\n\n\t\twr32(E1000_EIAC, regval | adapter->eims_enable_mask);\n\t\tregval = rd32(E1000_EIAM);\n\t\twr32(E1000_EIAM, regval | adapter->eims_enable_mask);\n\t\twr32(E1000_EIMS, adapter->eims_enable_mask);\n\t\tif (adapter->vfs_allocated_count) {\n\t\t\twr32(E1000_MBVFIMR, 0xFF);\n\t\t\tims |= E1000_IMS_VMMB;\n\t\t}\n\t\twr32(E1000_IMS, ims);\n\t} else {\n\t\twr32(E1000_IMS, IMS_ENABLE_MASK |\n\t\t\t\tE1000_IMS_DRSTA);\n\t\twr32(E1000_IAM, IMS_ENABLE_MASK |\n\t\t\t\tE1000_IMS_DRSTA);\n\t}\n}\n\nstatic void igb_update_mng_vlan(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 pf_id = adapter->vfs_allocated_count;\n\tu16 vid = adapter->hw.mng_cookie.vlan_id;\n\tu16 old_vid = adapter->mng_vlan_id;\n\n\tif (hw->mng_cookie.status & E1000_MNG_DHCP_COOKIE_STATUS_VLAN) {\n\t\t/* add VID to filter table */\n\t\tigb_vfta_set(hw, vid, pf_id, true, true);\n\t\tadapter->mng_vlan_id = vid;\n\t} else {\n\t\tadapter->mng_vlan_id = IGB_MNG_VLAN_NONE;\n\t}\n\n\tif ((old_vid != (u16)IGB_MNG_VLAN_NONE) &&\n\t    (vid != old_vid) &&\n\t    !test_bit(old_vid, adapter->active_vlans)) {\n\t\t/* remove VID from filter table */\n\t\tigb_vfta_set(hw, vid, pf_id, false, true);\n\t}\n}\n\n/**\n *  igb_release_hw_control - release control of the h/w to f/w\n *  @adapter: address of board private structure\n *\n *  igb_release_hw_control resets CTRL_EXT:DRV_LOAD bit.\n *  For ASF and Pass Through versions of f/w this means that the\n *  driver is no longer loaded.\n **/\nstatic void igb_release_hw_control(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl_ext;\n\n\t/* Let firmware take over control of h/w */\n\tctrl_ext = rd32(E1000_CTRL_EXT);\n\twr32(E1000_CTRL_EXT,\n\t\t\tctrl_ext & ~E1000_CTRL_EXT_DRV_LOAD);\n}\n\n/**\n *  igb_get_hw_control - get control of the h/w from f/w\n *  @adapter: address of board private structure\n *\n *  igb_get_hw_control sets CTRL_EXT:DRV_LOAD bit.\n *  For ASF and Pass Through versions of f/w this means that\n *  the driver is loaded.\n **/\nstatic void igb_get_hw_control(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl_ext;\n\n\t/* Let firmware know the driver has taken over */\n\tctrl_ext = rd32(E1000_CTRL_EXT);\n\twr32(E1000_CTRL_EXT,\n\t\t\tctrl_ext | E1000_CTRL_EXT_DRV_LOAD);\n}\n\nstatic void enable_fqtss(struct igb_adapter *adapter, bool enable)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tWARN_ON(hw->mac.type != e1000_i210);\n\n\tif (enable)\n\t\tadapter->flags |= IGB_FLAG_FQTSS;\n\telse\n\t\tadapter->flags &= ~IGB_FLAG_FQTSS;\n\n\tif (netif_running(netdev))\n\t\tschedule_work(&adapter->reset_task);\n}\n\nstatic bool is_fqtss_enabled(struct igb_adapter *adapter)\n{\n\treturn (adapter->flags & IGB_FLAG_FQTSS) ? true : false;\n}\n\nstatic void set_tx_desc_fetch_prio(struct e1000_hw *hw, int queue,\n\t\t\t\t   enum tx_queue_prio prio)\n{\n\tu32 val;\n\n\tWARN_ON(hw->mac.type != e1000_i210);\n\tWARN_ON(queue < 0 || queue > 4);\n\n\tval = rd32(E1000_I210_TXDCTL(queue));\n\n\tif (prio == TX_QUEUE_PRIO_HIGH)\n\t\tval |= E1000_TXDCTL_PRIORITY;\n\telse\n\t\tval &= ~E1000_TXDCTL_PRIORITY;\n\n\twr32(E1000_I210_TXDCTL(queue), val);\n}\n\nstatic void set_queue_mode(struct e1000_hw *hw, int queue, enum queue_mode mode)\n{\n\tu32 val;\n\n\tWARN_ON(hw->mac.type != e1000_i210);\n\tWARN_ON(queue < 0 || queue > 1);\n\n\tval = rd32(E1000_I210_TQAVCC(queue));\n\n\tif (mode == QUEUE_MODE_STREAM_RESERVATION)\n\t\tval |= E1000_TQAVCC_QUEUEMODE;\n\telse\n\t\tval &= ~E1000_TQAVCC_QUEUEMODE;\n\n\twr32(E1000_I210_TQAVCC(queue), val);\n}\n\nstatic bool is_any_cbs_enabled(struct igb_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\tif (adapter->tx_ring[i]->cbs_enable)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool is_any_txtime_enabled(struct igb_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\tif (adapter->tx_ring[i]->launchtime_enable)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n *  igb_config_tx_modes - Configure \"Qav Tx mode\" features on igb\n *  @adapter: pointer to adapter struct\n *  @queue: queue number\n *\n *  Configure CBS and Launchtime for a given hardware queue.\n *  Parameters are retrieved from the correct Tx ring, so\n *  igb_save_cbs_params() and igb_save_txtime_params() should be used\n *  for setting those correctly prior to this function being called.\n **/\nstatic void igb_config_tx_modes(struct igb_adapter *adapter, int queue)\n{\n\tstruct igb_ring *ring = adapter->tx_ring[queue];\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 tqavcc, tqavctrl;\n\tu16 value;\n\n\tWARN_ON(hw->mac.type != e1000_i210);\n\tWARN_ON(queue < 0 || queue > 1);\n\n\t/* If any of the Qav features is enabled, configure queues as SR and\n\t * with HIGH PRIO. If none is, then configure them with LOW PRIO and\n\t * as SP.\n\t */\n\tif (ring->cbs_enable || ring->launchtime_enable) {\n\t\tset_tx_desc_fetch_prio(hw, queue, TX_QUEUE_PRIO_HIGH);\n\t\tset_queue_mode(hw, queue, QUEUE_MODE_STREAM_RESERVATION);\n\t} else {\n\t\tset_tx_desc_fetch_prio(hw, queue, TX_QUEUE_PRIO_LOW);\n\t\tset_queue_mode(hw, queue, QUEUE_MODE_STRICT_PRIORITY);\n\t}\n\n\t/* If CBS is enabled, set DataTranARB and config its parameters. */\n\tif (ring->cbs_enable || queue == 0) {\n\t\t/* i210 does not allow the queue 0 to be in the Strict\n\t\t * Priority mode while the Qav mode is enabled, so,\n\t\t * instead of disabling strict priority mode, we give\n\t\t * queue 0 the maximum of credits possible.\n\t\t *\n\t\t * See section 8.12.19 of the i210 datasheet, \"Note:\n\t\t * Queue0 QueueMode must be set to 1b when\n\t\t * TransmitMode is set to Qav.\"\n\t\t */\n\t\tif (queue == 0 && !ring->cbs_enable) {\n\t\t\t/* max \"linkspeed\" idleslope in kbps */\n\t\t\tring->idleslope = 1000000;\n\t\t\tring->hicredit = ETH_FRAME_LEN;\n\t\t}\n\n\t\t/* Always set data transfer arbitration to credit-based\n\t\t * shaper algorithm on TQAVCTRL if CBS is enabled for any of\n\t\t * the queues.\n\t\t */\n\t\ttqavctrl = rd32(E1000_I210_TQAVCTRL);\n\t\ttqavctrl |= E1000_TQAVCTRL_DATATRANARB;\n\t\twr32(E1000_I210_TQAVCTRL, tqavctrl);\n\n\t\t/* According to i210 datasheet section 7.2.7.7, we should set\n\t\t * the 'idleSlope' field from TQAVCC register following the\n\t\t * equation:\n\t\t *\n\t\t * For 100 Mbps link speed:\n\t\t *\n\t\t *     value = BW * 0x7735 * 0.2                          (E1)\n\t\t *\n\t\t * For 1000Mbps link speed:\n\t\t *\n\t\t *     value = BW * 0x7735 * 2                            (E2)\n\t\t *\n\t\t * E1 and E2 can be merged into one equation as shown below.\n\t\t * Note that 'link-speed' is in Mbps.\n\t\t *\n\t\t *     value = BW * 0x7735 * 2 * link-speed\n\t\t *                           --------------               (E3)\n\t\t *                                1000\n\t\t *\n\t\t * 'BW' is the percentage bandwidth out of full link speed\n\t\t * which can be found with the following equation. Note that\n\t\t * idleSlope here is the parameter from this function which\n\t\t * is in kbps.\n\t\t *\n\t\t *     BW =     idleSlope\n\t\t *          -----------------                             (E4)\n\t\t *          link-speed * 1000\n\t\t *\n\t\t * That said, we can come up with a generic equation to\n\t\t * calculate the value we should set it TQAVCC register by\n\t\t * replacing 'BW' in E3 by E4. The resulting equation is:\n\t\t *\n\t\t * value =     idleSlope     * 0x7735 * 2 * link-speed\n\t\t *         -----------------            --------------    (E5)\n\t\t *         link-speed * 1000                 1000\n\t\t *\n\t\t * 'link-speed' is present in both sides of the fraction so\n\t\t * it is canceled out. The final equation is the following:\n\t\t *\n\t\t *     value = idleSlope * 61034\n\t\t *             -----------------                          (E6)\n\t\t *                  1000000\n\t\t *\n\t\t * NOTE: For i210, given the above, we can see that idleslope\n\t\t *       is represented in 16.38431 kbps units by the value at\n\t\t *       the TQAVCC register (1Gbps / 61034), which reduces\n\t\t *       the granularity for idleslope increments.\n\t\t *       For instance, if you want to configure a 2576kbps\n\t\t *       idleslope, the value to be written on the register\n\t\t *       would have to be 157.23. If rounded down, you end\n\t\t *       up with less bandwidth available than originally\n\t\t *       required (~2572 kbps). If rounded up, you end up\n\t\t *       with a higher bandwidth (~2589 kbps). Below the\n\t\t *       approach we take is to always round up the\n\t\t *       calculated value, so the resulting bandwidth might\n\t\t *       be slightly higher for some configurations.\n\t\t */\n\t\tvalue = DIV_ROUND_UP_ULL(ring->idleslope * 61034ULL, 1000000);\n\n\t\ttqavcc = rd32(E1000_I210_TQAVCC(queue));\n\t\ttqavcc &= ~E1000_TQAVCC_IDLESLOPE_MASK;\n\t\ttqavcc |= value;\n\t\twr32(E1000_I210_TQAVCC(queue), tqavcc);\n\n\t\twr32(E1000_I210_TQAVHC(queue),\n\t\t     0x80000000 + ring->hicredit * 0x7735);\n\t} else {\n\n\t\t/* Set idleSlope to zero. */\n\t\ttqavcc = rd32(E1000_I210_TQAVCC(queue));\n\t\ttqavcc &= ~E1000_TQAVCC_IDLESLOPE_MASK;\n\t\twr32(E1000_I210_TQAVCC(queue), tqavcc);\n\n\t\t/* Set hiCredit to zero. */\n\t\twr32(E1000_I210_TQAVHC(queue), 0);\n\n\t\t/* If CBS is not enabled for any queues anymore, then return to\n\t\t * the default state of Data Transmission Arbitration on\n\t\t * TQAVCTRL.\n\t\t */\n\t\tif (!is_any_cbs_enabled(adapter)) {\n\t\t\ttqavctrl = rd32(E1000_I210_TQAVCTRL);\n\t\t\ttqavctrl &= ~E1000_TQAVCTRL_DATATRANARB;\n\t\t\twr32(E1000_I210_TQAVCTRL, tqavctrl);\n\t\t}\n\t}\n\n\t/* If LaunchTime is enabled, set DataTranTIM. */\n\tif (ring->launchtime_enable) {\n\t\t/* Always set DataTranTIM on TQAVCTRL if LaunchTime is enabled\n\t\t * for any of the SR queues, and configure fetchtime delta.\n\t\t * XXX NOTE:\n\t\t *     - LaunchTime will be enabled for all SR queues.\n\t\t *     - A fixed offset can be added relative to the launch\n\t\t *       time of all packets if configured at reg LAUNCH_OS0.\n\t\t *       We are keeping it as 0 for now (default value).\n\t\t */\n\t\ttqavctrl = rd32(E1000_I210_TQAVCTRL);\n\t\ttqavctrl |= E1000_TQAVCTRL_DATATRANTIM |\n\t\t       E1000_TQAVCTRL_FETCHTIME_DELTA;\n\t\twr32(E1000_I210_TQAVCTRL, tqavctrl);\n\t} else {\n\t\t/* If Launchtime is not enabled for any SR queues anymore,\n\t\t * then clear DataTranTIM on TQAVCTRL and clear fetchtime delta,\n\t\t * effectively disabling Launchtime.\n\t\t */\n\t\tif (!is_any_txtime_enabled(adapter)) {\n\t\t\ttqavctrl = rd32(E1000_I210_TQAVCTRL);\n\t\t\ttqavctrl &= ~E1000_TQAVCTRL_DATATRANTIM;\n\t\t\ttqavctrl &= ~E1000_TQAVCTRL_FETCHTIME_DELTA;\n\t\t\twr32(E1000_I210_TQAVCTRL, tqavctrl);\n\t\t}\n\t}\n\n\t/* XXX: In i210 controller the sendSlope and loCredit parameters from\n\t * CBS are not configurable by software so we don't do any 'controller\n\t * configuration' in respect to these parameters.\n\t */\n\n\tnetdev_dbg(netdev, \"Qav Tx mode: cbs %s, launchtime %s, queue %d idleslope %d sendslope %d hiCredit %d locredit %d\\n\",\n\t\t   ring->cbs_enable ? \"enabled\" : \"disabled\",\n\t\t   ring->launchtime_enable ? \"enabled\" : \"disabled\",\n\t\t   queue,\n\t\t   ring->idleslope, ring->sendslope,\n\t\t   ring->hicredit, ring->locredit);\n}\n\nstatic int igb_save_txtime_params(struct igb_adapter *adapter, int queue,\n\t\t\t\t  bool enable)\n{\n\tstruct igb_ring *ring;\n\n\tif (queue < 0 || queue > adapter->num_tx_queues)\n\t\treturn -EINVAL;\n\n\tring = adapter->tx_ring[queue];\n\tring->launchtime_enable = enable;\n\n\treturn 0;\n}\n\nstatic int igb_save_cbs_params(struct igb_adapter *adapter, int queue,\n\t\t\t       bool enable, int idleslope, int sendslope,\n\t\t\t       int hicredit, int locredit)\n{\n\tstruct igb_ring *ring;\n\n\tif (queue < 0 || queue > adapter->num_tx_queues)\n\t\treturn -EINVAL;\n\n\tring = adapter->tx_ring[queue];\n\n\tring->cbs_enable = enable;\n\tring->idleslope = idleslope;\n\tring->sendslope = sendslope;\n\tring->hicredit = hicredit;\n\tring->locredit = locredit;\n\n\treturn 0;\n}\n\n/**\n *  igb_setup_tx_mode - Switch to/from Qav Tx mode when applicable\n *  @adapter: pointer to adapter struct\n *\n *  Configure TQAVCTRL register switching the controller's Tx mode\n *  if FQTSS mode is enabled or disabled. Additionally, will issue\n *  a call to igb_config_tx_modes() per queue so any previously saved\n *  Tx parameters are applied.\n **/\nstatic void igb_setup_tx_mode(struct igb_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 val;\n\n\t/* Only i210 controller supports changing the transmission mode. */\n\tif (hw->mac.type != e1000_i210)\n\t\treturn;\n\n\tif (is_fqtss_enabled(adapter)) {\n\t\tint i, max_queue;\n\n\t\t/* Configure TQAVCTRL register: set transmit mode to 'Qav',\n\t\t * set data fetch arbitration to 'round robin', set SP_WAIT_SR\n\t\t * so SP queues wait for SR ones.\n\t\t */\n\t\tval = rd32(E1000_I210_TQAVCTRL);\n\t\tval |= E1000_TQAVCTRL_XMIT_MODE | E1000_TQAVCTRL_SP_WAIT_SR;\n\t\tval &= ~E1000_TQAVCTRL_DATAFETCHARB;\n\t\twr32(E1000_I210_TQAVCTRL, val);\n\n\t\t/* Configure Tx and Rx packet buffers sizes as described in\n\t\t * i210 datasheet section 7.2.7.7.\n\t\t */\n\t\tval = rd32(E1000_TXPBS);\n\t\tval &= ~I210_TXPBSIZE_MASK;\n\t\tval |= I210_TXPBSIZE_PB0_8KB | I210_TXPBSIZE_PB1_8KB |\n\t\t\tI210_TXPBSIZE_PB2_4KB | I210_TXPBSIZE_PB3_4KB;\n\t\twr32(E1000_TXPBS, val);\n\n\t\tval = rd32(E1000_RXPBS);\n\t\tval &= ~I210_RXPBSIZE_MASK;\n\t\tval |= I210_RXPBSIZE_PB_30KB;\n\t\twr32(E1000_RXPBS, val);\n\n\t\t/* Section 8.12.9 states that MAX_TPKT_SIZE from DTXMXPKTSZ\n\t\t * register should not exceed the buffer size programmed in\n\t\t * TXPBS. The smallest buffer size programmed in TXPBS is 4kB\n\t\t * so according to the datasheet we should set MAX_TPKT_SIZE to\n\t\t * 4kB / 64.\n\t\t *\n\t\t * However, when we do so, no frame from queue 2 and 3 are\n\t\t * transmitted.  It seems the MAX_TPKT_SIZE should not be great\n\t\t * or _equal_ to the buffer size programmed in TXPBS. For this\n\t\t * reason, we set set MAX_ TPKT_SIZE to (4kB - 1) / 64.\n\t\t */\n\t\tval = (4096 - 1) / 64;\n\t\twr32(E1000_I210_DTXMXPKTSZ, val);\n\n\t\t/* Since FQTSS mode is enabled, apply any CBS configuration\n\t\t * previously set. If no previous CBS configuration has been\n\t\t * done, then the initial configuration is applied, which means\n\t\t * CBS is disabled.\n\t\t */\n\t\tmax_queue = (adapter->num_tx_queues < I210_SR_QUEUES_NUM) ?\n\t\t\t    adapter->num_tx_queues : I210_SR_QUEUES_NUM;\n\n\t\tfor (i = 0; i < max_queue; i++) {\n\t\t\tigb_config_tx_modes(adapter, i);\n\t\t}\n\t} else {\n\t\twr32(E1000_RXPBS, I210_RXPBSIZE_DEFAULT);\n\t\twr32(E1000_TXPBS, I210_TXPBSIZE_DEFAULT);\n\t\twr32(E1000_I210_DTXMXPKTSZ, I210_DTXMXPKTSZ_DEFAULT);\n\n\t\tval = rd32(E1000_I210_TQAVCTRL);\n\t\t/* According to Section 8.12.21, the other flags we've set when\n\t\t * enabling FQTSS are not relevant when disabling FQTSS so we\n\t\t * don't set they here.\n\t\t */\n\t\tval &= ~E1000_TQAVCTRL_XMIT_MODE;\n\t\twr32(E1000_I210_TQAVCTRL, val);\n\t}\n\n\tnetdev_dbg(netdev, \"FQTSS %s\\n\", (is_fqtss_enabled(adapter)) ?\n\t\t   \"enabled\" : \"disabled\");\n}\n\n/**\n *  igb_configure - configure the hardware for RX and TX\n *  @adapter: private board structure\n **/\nstatic void igb_configure(struct igb_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint i;\n\n\tigb_get_hw_control(adapter);\n\tigb_set_rx_mode(netdev);\n\tigb_setup_tx_mode(adapter);\n\n\tigb_restore_vlan(adapter);\n\n\tigb_setup_tctl(adapter);\n\tigb_setup_mrqc(adapter);\n\tigb_setup_rctl(adapter);\n\n\tigb_nfc_filter_restore(adapter);\n\tigb_configure_tx(adapter);\n\tigb_configure_rx(adapter);\n\n\tigb_rx_fifo_flush_82575(&adapter->hw);\n\n\t/* call igb_desc_unused which always leaves\n\t * at least 1 descriptor unused to make sure\n\t * next_to_use != next_to_clean\n\t */\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\tstruct igb_ring *ring = adapter->rx_ring[i];\n\t\tigb_alloc_rx_buffers(ring, igb_desc_unused(ring));\n\t}\n}\n\n/**\n *  igb_power_up_link - Power up the phy/serdes link\n *  @adapter: address of board private structure\n **/\nvoid igb_power_up_link(struct igb_adapter *adapter)\n{\n\tigb_reset_phy(&adapter->hw);\n\n\tif (adapter->hw.phy.media_type == e1000_media_type_copper)\n\t\tigb_power_up_phy_copper(&adapter->hw);\n\telse\n\t\tigb_power_up_serdes_link_82575(&adapter->hw);\n\n\tigb_setup_link(&adapter->hw);\n}\n\n/**\n *  igb_power_down_link - Power down the phy/serdes link\n *  @adapter: address of board private structure\n */\nstatic void igb_power_down_link(struct igb_adapter *adapter)\n{\n\tif (adapter->hw.phy.media_type == e1000_media_type_copper)\n\t\tigb_power_down_phy_copper_82575(&adapter->hw);\n\telse\n\t\tigb_shutdown_serdes_link_82575(&adapter->hw);\n}\n\n/**\n * Detect and switch function for Media Auto Sense\n * @adapter: address of the board private structure\n **/\nstatic void igb_check_swap_media(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl_ext, connsw;\n\tbool swap_now = false;\n\n\tctrl_ext = rd32(E1000_CTRL_EXT);\n\tconnsw = rd32(E1000_CONNSW);\n\n\t/* need to live swap if current media is copper and we have fiber/serdes\n\t * to go to.\n\t */\n\n\tif ((hw->phy.media_type == e1000_media_type_copper) &&\n\t    (!(connsw & E1000_CONNSW_AUTOSENSE_EN))) {\n\t\tswap_now = true;\n\t} else if ((hw->phy.media_type != e1000_media_type_copper) &&\n\t\t   !(connsw & E1000_CONNSW_SERDESD)) {\n\t\t/* copper signal takes time to appear */\n\t\tif (adapter->copper_tries < 4) {\n\t\t\tadapter->copper_tries++;\n\t\t\tconnsw |= E1000_CONNSW_AUTOSENSE_CONF;\n\t\t\twr32(E1000_CONNSW, connsw);\n\t\t\treturn;\n\t\t} else {\n\t\t\tadapter->copper_tries = 0;\n\t\t\tif ((connsw & E1000_CONNSW_PHYSD) &&\n\t\t\t    (!(connsw & E1000_CONNSW_PHY_PDN))) {\n\t\t\t\tswap_now = true;\n\t\t\t\tconnsw &= ~E1000_CONNSW_AUTOSENSE_CONF;\n\t\t\t\twr32(E1000_CONNSW, connsw);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!swap_now)\n\t\treturn;\n\n\tswitch (hw->phy.media_type) {\n\tcase e1000_media_type_copper:\n\t\tnetdev_info(adapter->netdev,\n\t\t\t\"MAS: changing media to fiber/serdes\\n\");\n\t\tctrl_ext |=\n\t\t\tE1000_CTRL_EXT_LINK_MODE_PCIE_SERDES;\n\t\tadapter->flags |= IGB_FLAG_MEDIA_RESET;\n\t\tadapter->copper_tries = 0;\n\t\tbreak;\n\tcase e1000_media_type_internal_serdes:\n\tcase e1000_media_type_fiber:\n\t\tnetdev_info(adapter->netdev,\n\t\t\t\"MAS: changing media to copper\\n\");\n\t\tctrl_ext &=\n\t\t\t~E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES;\n\t\tadapter->flags |= IGB_FLAG_MEDIA_RESET;\n\t\tbreak;\n\tdefault:\n\t\t/* shouldn't get here during regular operation */\n\t\tnetdev_err(adapter->netdev,\n\t\t\t\"AMS: Invalid media type found, returning\\n\");\n\t\tbreak;\n\t}\n\twr32(E1000_CTRL_EXT, ctrl_ext);\n}\n\n/**\n *  igb_up - Open the interface and prepare it to handle traffic\n *  @adapter: board private structure\n **/\nint igb_up(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint i;\n\n\t/* hardware has been reset, we need to reload some things */\n\tigb_configure(adapter);\n\n\tclear_bit(__IGB_DOWN, &adapter->state);\n\n\tfor (i = 0; i < adapter->num_q_vectors; i++)\n\t\tnapi_enable(&(adapter->q_vector[i]->napi));\n\n\tif (adapter->flags & IGB_FLAG_HAS_MSIX)\n\t\tigb_configure_msix(adapter);\n\telse\n\t\tigb_assign_vector(adapter->q_vector[0], 0);\n\n\t/* Clear any pending interrupts. */\n\trd32(E1000_TSICR);\n\trd32(E1000_ICR);\n\tigb_irq_enable(adapter);\n\n\t/* notify VFs that reset has been completed */\n\tif (adapter->vfs_allocated_count) {\n\t\tu32 reg_data = rd32(E1000_CTRL_EXT);\n\n\t\treg_data |= E1000_CTRL_EXT_PFRSTD;\n\t\twr32(E1000_CTRL_EXT, reg_data);\n\t}\n\n\tnetif_tx_start_all_queues(adapter->netdev);\n\n\t/* start the watchdog. */\n\thw->mac.get_link_status = 1;\n\tschedule_work(&adapter->watchdog_task);\n\n\tif ((adapter->flags & IGB_FLAG_EEE) &&\n\t    (!hw->dev_spec._82575.eee_disable))\n\t\tadapter->eee_advert = MDIO_EEE_100TX | MDIO_EEE_1000T;\n\n\treturn 0;\n}\n\nvoid igb_down(struct igb_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 tctl, rctl;\n\tint i;\n\n\t/* signal that we're down so the interrupt handler does not\n\t * reschedule our watchdog timer\n\t */\n\tset_bit(__IGB_DOWN, &adapter->state);\n\n\t/* disable receives in the hardware */\n\trctl = rd32(E1000_RCTL);\n\twr32(E1000_RCTL, rctl & ~E1000_RCTL_EN);\n\t/* flush and sleep below */\n\n\tigb_nfc_filter_exit(adapter);\n\n\tnetif_carrier_off(netdev);\n\tnetif_tx_stop_all_queues(netdev);\n\n\t/* disable transmits in the hardware */\n\ttctl = rd32(E1000_TCTL);\n\ttctl &= ~E1000_TCTL_EN;\n\twr32(E1000_TCTL, tctl);\n\t/* flush both disables and wait for them to finish */\n\twrfl();\n\tusleep_range(10000, 11000);\n\n\tigb_irq_disable(adapter);\n\n\tadapter->flags &= ~IGB_FLAG_NEED_LINK_UPDATE;\n\n\tfor (i = 0; i < adapter->num_q_vectors; i++) {\n\t\tif (adapter->q_vector[i]) {\n\t\t\tnapi_synchronize(&adapter->q_vector[i]->napi);\n\t\t\tnapi_disable(&adapter->q_vector[i]->napi);\n\t\t}\n\t}\n\n\tdel_timer_sync(&adapter->watchdog_timer);\n\tdel_timer_sync(&adapter->phy_info_timer);\n\n\t/* record the stats before reset*/\n\tspin_lock(&adapter->stats64_lock);\n\tigb_update_stats(adapter);\n\tspin_unlock(&adapter->stats64_lock);\n\n\tadapter->link_speed = 0;\n\tadapter->link_duplex = 0;\n\n\tif (!pci_channel_offline(adapter->pdev))\n\t\tigb_reset(adapter);\n\n\t/* clear VLAN promisc flag so VFTA will be updated if necessary */\n\tadapter->flags &= ~IGB_FLAG_VLAN_PROMISC;\n\n\tigb_clean_all_tx_rings(adapter);\n\tigb_clean_all_rx_rings(adapter);\n#ifdef CONFIG_IGB_DCA\n\n\t/* since we reset the hardware DCA settings were cleared */\n\tigb_setup_dca(adapter);\n#endif\n}\n\nvoid igb_reinit_locked(struct igb_adapter *adapter)\n{\n\twhile (test_and_set_bit(__IGB_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\tigb_down(adapter);\n\tigb_up(adapter);\n\tclear_bit(__IGB_RESETTING, &adapter->state);\n}\n\n/** igb_enable_mas - Media Autosense re-enable after swap\n *\n * @adapter: adapter struct\n **/\nstatic void igb_enable_mas(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 connsw = rd32(E1000_CONNSW);\n\n\t/* configure for SerDes media detect */\n\tif ((hw->phy.media_type == e1000_media_type_copper) &&\n\t    (!(connsw & E1000_CONNSW_SERDESD))) {\n\t\tconnsw |= E1000_CONNSW_ENRGSRC;\n\t\tconnsw |= E1000_CONNSW_AUTOSENSE_EN;\n\t\twr32(E1000_CONNSW, connsw);\n\t\twrfl();\n\t}\n}\n\nvoid igb_reset(struct igb_adapter *adapter)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tstruct e1000_fc_info *fc = &hw->fc;\n\tu32 pba, hwm;\n\n\t/* Repartition Pba for greater than 9k mtu\n\t * To take effect CTRL.RST is required.\n\t */\n\tswitch (mac->type) {\n\tcase e1000_i350:\n\tcase e1000_i354:\n\tcase e1000_82580:\n\t\tpba = rd32(E1000_RXPBS);\n\t\tpba = igb_rxpbs_adjust_82580(pba);\n\t\tbreak;\n\tcase e1000_82576:\n\t\tpba = rd32(E1000_RXPBS);\n\t\tpba &= E1000_RXPBS_SIZE_MASK_82576;\n\t\tbreak;\n\tcase e1000_82575:\n\tcase e1000_i210:\n\tcase e1000_i211:\n\tdefault:\n\t\tpba = E1000_PBA_34K;\n\t\tbreak;\n\t}\n\n\tif (mac->type == e1000_82575) {\n\t\tu32 min_rx_space, min_tx_space, needed_tx_space;\n\n\t\t/* write Rx PBA so that hardware can report correct Tx PBA */\n\t\twr32(E1000_PBA, pba);\n\n\t\t/* To maintain wire speed transmits, the Tx FIFO should be\n\t\t * large enough to accommodate two full transmit packets,\n\t\t * rounded up to the next 1KB and expressed in KB.  Likewise,\n\t\t * the Rx FIFO should be large enough to accommodate at least\n\t\t * one full receive packet and is similarly rounded up and\n\t\t * expressed in KB.\n\t\t */\n\t\tmin_rx_space = DIV_ROUND_UP(MAX_JUMBO_FRAME_SIZE, 1024);\n\n\t\t/* The Tx FIFO also stores 16 bytes of information about the Tx\n\t\t * but don't include Ethernet FCS because hardware appends it.\n\t\t * We only need to round down to the nearest 512 byte block\n\t\t * count since the value we care about is 2 frames, not 1.\n\t\t */\n\t\tmin_tx_space = adapter->max_frame_size;\n\t\tmin_tx_space += sizeof(union e1000_adv_tx_desc) - ETH_FCS_LEN;\n\t\tmin_tx_space = DIV_ROUND_UP(min_tx_space, 512);\n\n\t\t/* upper 16 bits has Tx packet buffer allocation size in KB */\n\t\tneeded_tx_space = min_tx_space - (rd32(E1000_PBA) >> 16);\n\n\t\t/* If current Tx allocation is less than the min Tx FIFO size,\n\t\t * and the min Tx FIFO size is less than the current Rx FIFO\n\t\t * allocation, take space away from current Rx allocation.\n\t\t */\n\t\tif (needed_tx_space < pba) {\n\t\t\tpba -= needed_tx_space;\n\n\t\t\t/* if short on Rx space, Rx wins and must trump Tx\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tif (pba < min_rx_space)\n\t\t\t\tpba = min_rx_space;\n\t\t}\n\n\t\t/* adjust PBA for jumbo frames */\n\t\twr32(E1000_PBA, pba);\n\t}\n\n\t/* flow control settings\n\t * The high water mark must be low enough to fit one full frame\n\t * after transmitting the pause frame.  As such we must have enough\n\t * space to allow for us to complete our current transmit and then\n\t * receive the frame that is in progress from the link partner.\n\t * Set it to:\n\t * - the full Rx FIFO size minus one full Tx plus one full Rx frame\n\t */\n\thwm = (pba << 10) - (adapter->max_frame_size + MAX_JUMBO_FRAME_SIZE);\n\n\tfc->high_water = hwm & 0xFFFFFFF0;\t/* 16-byte granularity */\n\tfc->low_water = fc->high_water - 16;\n\tfc->pause_time = 0xFFFF;\n\tfc->send_xon = 1;\n\tfc->current_mode = fc->requested_mode;\n\n\t/* disable receive for all VFs and wait one second */\n\tif (adapter->vfs_allocated_count) {\n\t\tint i;\n\n\t\tfor (i = 0 ; i < adapter->vfs_allocated_count; i++)\n\t\t\tadapter->vf_data[i].flags &= IGB_VF_FLAG_PF_SET_MAC;\n\n\t\t/* ping all the active vfs to let them know we are going down */\n\t\tigb_ping_all_vfs(adapter);\n\n\t\t/* disable transmits and receives */\n\t\twr32(E1000_VFRE, 0);\n\t\twr32(E1000_VFTE, 0);\n\t}\n\n\t/* Allow time for pending master requests to run */\n\thw->mac.ops.reset_hw(hw);\n\twr32(E1000_WUC, 0);\n\n\tif (adapter->flags & IGB_FLAG_MEDIA_RESET) {\n\t\t/* need to resetup here after media swap */\n\t\tadapter->ei.get_invariants(hw);\n\t\tadapter->flags &= ~IGB_FLAG_MEDIA_RESET;\n\t}\n\tif ((mac->type == e1000_82575 || mac->type == e1000_i350) &&\n\t    (adapter->flags & IGB_FLAG_MAS_ENABLE)) {\n\t\tigb_enable_mas(adapter);\n\t}\n\tif (hw->mac.ops.init_hw(hw))\n\t\tdev_err(&pdev->dev, \"Hardware Error\\n\");\n\n\t/* RAR registers were cleared during init_hw, clear mac table */\n\tigb_flush_mac_table(adapter);\n\t__dev_uc_unsync(adapter->netdev, NULL);\n\n\t/* Recover default RAR entry */\n\tigb_set_default_mac_filter(adapter);\n\n\t/* Flow control settings reset on hardware reset, so guarantee flow\n\t * control is off when forcing speed.\n\t */\n\tif (!hw->mac.autoneg)\n\t\tigb_force_mac_fc(hw);\n\n\tigb_init_dmac(adapter, pba);\n#ifdef CONFIG_IGB_HWMON\n\t/* Re-initialize the thermal sensor on i350 devices. */\n\tif (!test_bit(__IGB_DOWN, &adapter->state)) {\n\t\tif (mac->type == e1000_i350 && hw->bus.func == 0) {\n\t\t\t/* If present, re-initialize the external thermal sensor\n\t\t\t * interface.\n\t\t\t */\n\t\t\tif (adapter->ets)\n\t\t\t\tmac->ops.init_thermal_sensor_thresh(hw);\n\t\t}\n\t}\n#endif\n\t/* Re-establish EEE setting */\n\tif (hw->phy.media_type == e1000_media_type_copper) {\n\t\tswitch (mac->type) {\n\t\tcase e1000_i350:\n\t\tcase e1000_i210:\n\t\tcase e1000_i211:\n\t\t\tigb_set_eee_i350(hw, true, true);\n\t\t\tbreak;\n\t\tcase e1000_i354:\n\t\t\tigb_set_eee_i354(hw, true, true);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!netif_running(adapter->netdev))\n\t\tigb_power_down_link(adapter);\n\n\tigb_update_mng_vlan(adapter);\n\n\t/* Enable h/w to recognize an 802.1Q VLAN Ethernet packet */\n\twr32(E1000_VET, ETHERNET_IEEE_VLAN_TYPE);\n\n\t/* Re-enable PTP, where applicable. */\n\tif (adapter->ptp_flags & IGB_PTP_ENABLED)\n\t\tigb_ptp_reset(adapter);\n\n\tigb_get_phy_info(hw);\n}\n\nstatic netdev_features_t igb_fix_features(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\t/* Since there is no support for separate Rx/Tx vlan accel\n\t * enable/disable make sure Tx flag is always in same state as Rx.\n\t */\n\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\n\telse\n\t\tfeatures &= ~NETIF_F_HW_VLAN_CTAG_TX;\n\n\treturn features;\n}\n\nstatic int igb_set_features(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\tnetdev_features_t changed = netdev->features ^ features;\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tigb_vlan_mode(netdev, features);\n\n\tif (!(changed & (NETIF_F_RXALL | NETIF_F_NTUPLE)))\n\t\treturn 0;\n\n\tif (!(features & NETIF_F_NTUPLE)) {\n\t\tstruct hlist_node *node2;\n\t\tstruct igb_nfc_filter *rule;\n\n\t\tspin_lock(&adapter->nfc_lock);\n\t\thlist_for_each_entry_safe(rule, node2,\n\t\t\t\t\t  &adapter->nfc_filter_list, nfc_node) {\n\t\t\tigb_erase_filter(adapter, rule);\n\t\t\thlist_del(&rule->nfc_node);\n\t\t\tkfree(rule);\n\t\t}\n\t\tspin_unlock(&adapter->nfc_lock);\n\t\tadapter->nfc_filter_count = 0;\n\t}\n\n\tnetdev->features = features;\n\n\tif (netif_running(netdev))\n\t\tigb_reinit_locked(adapter);\n\telse\n\t\tigb_reset(adapter);\n\n\treturn 1;\n}\n\nstatic int igb_ndo_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],\n\t\t\t   struct net_device *dev,\n\t\t\t   const unsigned char *addr, u16 vid,\n\t\t\t   u16 flags,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\t/* guarantee we can provide a unique filter for the unicast address */\n\tif (is_unicast_ether_addr(addr) || is_link_local_ether_addr(addr)) {\n\t\tstruct igb_adapter *adapter = netdev_priv(dev);\n\t\tint vfn = adapter->vfs_allocated_count;\n\n\t\tif (netdev_uc_count(dev) >= igb_available_rars(adapter, vfn))\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn ndo_dflt_fdb_add(ndm, tb, dev, addr, vid, flags);\n}\n\n#define IGB_MAX_MAC_HDR_LEN\t127\n#define IGB_MAX_NETWORK_HDR_LEN\t511\n\nstatic netdev_features_t\nigb_features_check(struct sk_buff *skb, struct net_device *dev,\n\t\t   netdev_features_t features)\n{\n\tunsigned int network_hdr_len, mac_hdr_len;\n\n\t/* Make certain the headers can be described by a context descriptor */\n\tmac_hdr_len = skb_network_header(skb) - skb->data;\n\tif (unlikely(mac_hdr_len > IGB_MAX_MAC_HDR_LEN))\n\t\treturn features & ~(NETIF_F_HW_CSUM |\n\t\t\t\t    NETIF_F_SCTP_CRC |\n\t\t\t\t    NETIF_F_GSO_UDP_L4 |\n\t\t\t\t    NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t    NETIF_F_TSO |\n\t\t\t\t    NETIF_F_TSO6);\n\n\tnetwork_hdr_len = skb_checksum_start(skb) - skb_network_header(skb);\n\tif (unlikely(network_hdr_len >  IGB_MAX_NETWORK_HDR_LEN))\n\t\treturn features & ~(NETIF_F_HW_CSUM |\n\t\t\t\t    NETIF_F_SCTP_CRC |\n\t\t\t\t    NETIF_F_GSO_UDP_L4 |\n\t\t\t\t    NETIF_F_TSO |\n\t\t\t\t    NETIF_F_TSO6);\n\n\t/* We can only support IPV4 TSO in tunnels if we can mangle the\n\t * inner IP ID field, so strip TSO if MANGLEID is not supported.\n\t */\n\tif (skb->encapsulation && !(features & NETIF_F_TSO_MANGLEID))\n\t\tfeatures &= ~NETIF_F_TSO;\n\n\treturn features;\n}\n\nstatic void igb_offload_apply(struct igb_adapter *adapter, s32 queue)\n{\n\tif (!is_fqtss_enabled(adapter)) {\n\t\tenable_fqtss(adapter, true);\n\t\treturn;\n\t}\n\n\tigb_config_tx_modes(adapter, queue);\n\n\tif (!is_any_cbs_enabled(adapter) && !is_any_txtime_enabled(adapter))\n\t\tenable_fqtss(adapter, false);\n}\n\nstatic int igb_offload_cbs(struct igb_adapter *adapter,\n\t\t\t   struct tc_cbs_qopt_offload *qopt)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint err;\n\n\t/* CBS offloading is only supported by i210 controller. */\n\tif (hw->mac.type != e1000_i210)\n\t\treturn -EOPNOTSUPP;\n\n\t/* CBS offloading is only supported by queue 0 and queue 1. */\n\tif (qopt->queue < 0 || qopt->queue > 1)\n\t\treturn -EINVAL;\n\n\terr = igb_save_cbs_params(adapter, qopt->queue, qopt->enable,\n\t\t\t\t  qopt->idleslope, qopt->sendslope,\n\t\t\t\t  qopt->hicredit, qopt->locredit);\n\tif (err)\n\t\treturn err;\n\n\tigb_offload_apply(adapter, qopt->queue);\n\n\treturn 0;\n}\n\n#define ETHER_TYPE_FULL_MASK ((__force __be16)~0)\n#define VLAN_PRIO_FULL_MASK (0x07)\n\nstatic int igb_parse_cls_flower(struct igb_adapter *adapter,\n\t\t\t\tstruct flow_cls_offload *f,\n\t\t\t\tint traffic_class,\n\t\t\t\tstruct igb_nfc_filter *input)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\n\tif (dissector->used_keys &\n\t    ~(BIT(FLOW_DISSECTOR_KEY_BASIC) |\n\t      BIT(FLOW_DISSECTOR_KEY_CONTROL) |\n\t      BIT(FLOW_DISSECTOR_KEY_ETH_ADDRS) |\n\t      BIT(FLOW_DISSECTOR_KEY_VLAN))) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Unsupported key used, only BASIC, CONTROL, ETH_ADDRS and VLAN are supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct flow_match_eth_addrs match;\n\n\t\tflow_rule_match_eth_addrs(rule, &match);\n\t\tif (!is_zero_ether_addr(match.mask->dst)) {\n\t\t\tif (!is_broadcast_ether_addr(match.mask->dst)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Only full masks are supported for destination MAC address\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tinput->filter.match_flags |=\n\t\t\t\tIGB_FILTER_FLAG_DST_MAC_ADDR;\n\t\t\tether_addr_copy(input->filter.dst_addr, match.key->dst);\n\t\t}\n\n\t\tif (!is_zero_ether_addr(match.mask->src)) {\n\t\t\tif (!is_broadcast_ether_addr(match.mask->src)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Only full masks are supported for source MAC address\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tinput->filter.match_flags |=\n\t\t\t\tIGB_FILTER_FLAG_SRC_MAC_ADDR;\n\t\t\tether_addr_copy(input->filter.src_addr, match.key->src);\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_BASIC)) {\n\t\tstruct flow_match_basic match;\n\n\t\tflow_rule_match_basic(rule, &match);\n\t\tif (match.mask->n_proto) {\n\t\t\tif (match.mask->n_proto != ETHER_TYPE_FULL_MASK) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Only full mask is supported for EtherType filter\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tinput->filter.match_flags |= IGB_FILTER_FLAG_ETHER_TYPE;\n\t\t\tinput->filter.etype = match.key->n_proto;\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_VLAN)) {\n\t\tstruct flow_match_vlan match;\n\n\t\tflow_rule_match_vlan(rule, &match);\n\t\tif (match.mask->vlan_priority) {\n\t\t\tif (match.mask->vlan_priority != VLAN_PRIO_FULL_MASK) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Only full mask is supported for VLAN priority\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tinput->filter.match_flags |= IGB_FILTER_FLAG_VLAN_TCI;\n\t\t\tinput->filter.vlan_tci = match.key->vlan_priority;\n\t\t}\n\t}\n\n\tinput->action = traffic_class;\n\tinput->cookie = f->cookie;\n\n\treturn 0;\n}\n\nstatic int igb_configure_clsflower(struct igb_adapter *adapter,\n\t\t\t\t   struct flow_cls_offload *cls_flower)\n{\n\tstruct netlink_ext_ack *extack = cls_flower->common.extack;\n\tstruct igb_nfc_filter *filter, *f;\n\tint err, tc;\n\n\ttc = tc_classid_to_hwtc(adapter->netdev, cls_flower->classid);\n\tif (tc < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid traffic class\");\n\t\treturn -EINVAL;\n\t}\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (!filter)\n\t\treturn -ENOMEM;\n\n\terr = igb_parse_cls_flower(adapter, cls_flower, tc, filter);\n\tif (err < 0)\n\t\tgoto err_parse;\n\n\tspin_lock(&adapter->nfc_lock);\n\n\thlist_for_each_entry(f, &adapter->nfc_filter_list, nfc_node) {\n\t\tif (!memcmp(&f->filter, &filter->filter, sizeof(f->filter))) {\n\t\t\terr = -EEXIST;\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"This filter is already set in ethtool\");\n\t\t\tgoto err_locked;\n\t\t}\n\t}\n\n\thlist_for_each_entry(f, &adapter->cls_flower_list, nfc_node) {\n\t\tif (!memcmp(&f->filter, &filter->filter, sizeof(f->filter))) {\n\t\t\terr = -EEXIST;\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"This filter is already set in cls_flower\");\n\t\t\tgoto err_locked;\n\t\t}\n\t}\n\n\terr = igb_add_filter(adapter, filter);\n\tif (err < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Could not add filter to the adapter\");\n\t\tgoto err_locked;\n\t}\n\n\thlist_add_head(&filter->nfc_node, &adapter->cls_flower_list);\n\n\tspin_unlock(&adapter->nfc_lock);\n\n\treturn 0;\n\nerr_locked:\n\tspin_unlock(&adapter->nfc_lock);\n\nerr_parse:\n\tkfree(filter);\n\n\treturn err;\n}\n\nstatic int igb_delete_clsflower(struct igb_adapter *adapter,\n\t\t\t\tstruct flow_cls_offload *cls_flower)\n{\n\tstruct igb_nfc_filter *filter;\n\tint err;\n\n\tspin_lock(&adapter->nfc_lock);\n\n\thlist_for_each_entry(filter, &adapter->cls_flower_list, nfc_node)\n\t\tif (filter->cookie == cls_flower->cookie)\n\t\t\tbreak;\n\n\tif (!filter) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terr = igb_erase_filter(adapter, filter);\n\tif (err < 0)\n\t\tgoto out;\n\n\thlist_del(&filter->nfc_node);\n\tkfree(filter);\n\nout:\n\tspin_unlock(&adapter->nfc_lock);\n\n\treturn err;\n}\n\nstatic int igb_setup_tc_cls_flower(struct igb_adapter *adapter,\n\t\t\t\t   struct flow_cls_offload *cls_flower)\n{\n\tswitch (cls_flower->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\treturn igb_configure_clsflower(adapter, cls_flower);\n\tcase FLOW_CLS_DESTROY:\n\t\treturn igb_delete_clsflower(adapter, cls_flower);\n\tcase FLOW_CLS_STATS:\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int igb_setup_tc_block_cb(enum tc_setup_type type, void *type_data,\n\t\t\t\t void *cb_priv)\n{\n\tstruct igb_adapter *adapter = cb_priv;\n\n\tif (!tc_cls_can_offload_and_chain0(adapter->netdev, type_data))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn igb_setup_tc_cls_flower(adapter, type_data);\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int igb_offload_txtime(struct igb_adapter *adapter,\n\t\t\t      struct tc_etf_qopt_offload *qopt)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint err;\n\n\t/* Launchtime offloading is only supported by i210 controller. */\n\tif (hw->mac.type != e1000_i210)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Launchtime offloading is only supported by queues 0 and 1. */\n\tif (qopt->queue < 0 || qopt->queue > 1)\n\t\treturn -EINVAL;\n\n\terr = igb_save_txtime_params(adapter, qopt->queue, qopt->enable);\n\tif (err)\n\t\treturn err;\n\n\tigb_offload_apply(adapter, qopt->queue);\n\n\treturn 0;\n}\n\nstatic LIST_HEAD(igb_block_cb_list);\n\nstatic int igb_setup_tc(struct net_device *dev, enum tc_setup_type type,\n\t\t\tvoid *type_data)\n{\n\tstruct igb_adapter *adapter = netdev_priv(dev);\n\n\tswitch (type) {\n\tcase TC_SETUP_QDISC_CBS:\n\t\treturn igb_offload_cbs(adapter, type_data);\n\tcase TC_SETUP_BLOCK:\n\t\treturn flow_block_cb_setup_simple(type_data,\n\t\t\t\t\t\t  &igb_block_cb_list,\n\t\t\t\t\t\t  igb_setup_tc_block_cb,\n\t\t\t\t\t\t  adapter, adapter, true);\n\n\tcase TC_SETUP_QDISC_ETF:\n\t\treturn igb_offload_txtime(adapter, type_data);\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int igb_xdp_setup(struct net_device *dev, struct netdev_bpf *bpf)\n{\n\tint i, frame_size = dev->mtu + IGB_ETH_PKT_HDR_PAD;\n\tstruct igb_adapter *adapter = netdev_priv(dev);\n\tstruct bpf_prog *prog = bpf->prog, *old_prog;\n\tbool running = netif_running(dev);\n\tbool need_reset;\n\n\t/* verify igb ring attributes are sufficient for XDP */\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\tstruct igb_ring *ring = adapter->rx_ring[i];\n\n\t\tif (frame_size > igb_rx_bufsz(ring)) {\n\t\t\tNL_SET_ERR_MSG_MOD(bpf->extack,\n\t\t\t\t\t   \"The RX buffer size is too small for the frame size\");\n\t\t\tnetdev_warn(dev, \"XDP RX buffer size %d is too small for the frame size %d\\n\",\n\t\t\t\t    igb_rx_bufsz(ring), frame_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\told_prog = xchg(&adapter->xdp_prog, prog);\n\tneed_reset = (!!prog != !!old_prog);\n\n\t/* device is up and bpf is added/removed, must setup the RX queues */\n\tif (need_reset && running) {\n\t\tigb_close(dev);\n\t} else {\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\t\t(void)xchg(&adapter->rx_ring[i]->xdp_prog,\n\t\t\t    adapter->xdp_prog);\n\t}\n\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\n\t/* bpf is just replaced, RXQ and MTU are already setup */\n\tif (!need_reset)\n\t\treturn 0;\n\n\tif (running)\n\t\tigb_open(dev);\n\n\treturn 0;\n}\n\nstatic int igb_xdp(struct net_device *dev, struct netdev_bpf *xdp)\n{\n\tswitch (xdp->command) {\n\tcase XDP_SETUP_PROG:\n\t\treturn igb_xdp_setup(dev, xdp);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void igb_xdp_ring_update_tail(struct igb_ring *ring)\n{\n\t/* Force memory writes to complete before letting h/w know there\n\t * are new descriptors to fetch.\n\t */\n\twmb();\n\twritel(ring->next_to_use, ring->tail);\n}\n\nstatic struct igb_ring *igb_xdp_tx_queue_mapping(struct igb_adapter *adapter)\n{\n\tunsigned int r_idx = smp_processor_id();\n\n\tif (r_idx >= adapter->num_tx_queues)\n\t\tr_idx = r_idx % adapter->num_tx_queues;\n\n\treturn adapter->tx_ring[r_idx];\n}\n\nstatic int igb_xdp_xmit_back(struct igb_adapter *adapter, struct xdp_buff *xdp)\n{\n\tstruct xdp_frame *xdpf = xdp_convert_buff_to_frame(xdp);\n\tint cpu = smp_processor_id();\n\tstruct igb_ring *tx_ring;\n\tstruct netdev_queue *nq;\n\tu32 ret;\n\n\tif (unlikely(!xdpf))\n\t\treturn IGB_XDP_CONSUMED;\n\n\t/* During program transitions its possible adapter->xdp_prog is assigned\n\t * but ring has not been configured yet. In this case simply abort xmit.\n\t */\n\ttx_ring = adapter->xdp_prog ? igb_xdp_tx_queue_mapping(adapter) : NULL;\n\tif (unlikely(!tx_ring))\n\t\treturn IGB_XDP_CONSUMED;\n\n\tnq = txring_txq(tx_ring);\n\t__netif_tx_lock(nq, cpu);\n\t/* Avoid transmit queue timeout since we share it with the slow path */\n\tnq->trans_start = jiffies;\n\tret = igb_xmit_xdp_ring(adapter, tx_ring, xdpf);\n\t__netif_tx_unlock(nq);\n\n\treturn ret;\n}\n\nstatic int igb_xdp_xmit(struct net_device *dev, int n,\n\t\t\tstruct xdp_frame **frames, u32 flags)\n{\n\tstruct igb_adapter *adapter = netdev_priv(dev);\n\tint cpu = smp_processor_id();\n\tstruct igb_ring *tx_ring;\n\tstruct netdev_queue *nq;\n\tint drops = 0;\n\tint i;\n\n\tif (unlikely(test_bit(__IGB_DOWN, &adapter->state)))\n\t\treturn -ENETDOWN;\n\n\tif (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))\n\t\treturn -EINVAL;\n\n\t/* During program transitions its possible adapter->xdp_prog is assigned\n\t * but ring has not been configured yet. In this case simply abort xmit.\n\t */\n\ttx_ring = adapter->xdp_prog ? igb_xdp_tx_queue_mapping(adapter) : NULL;\n\tif (unlikely(!tx_ring))\n\t\treturn -ENXIO;\n\n\tnq = txring_txq(tx_ring);\n\t__netif_tx_lock(nq, cpu);\n\n\t/* Avoid transmit queue timeout since we share it with the slow path */\n\tnq->trans_start = jiffies;\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct xdp_frame *xdpf = frames[i];\n\t\tint err;\n\n\t\terr = igb_xmit_xdp_ring(adapter, tx_ring, xdpf);\n\t\tif (err != IGB_XDP_TX) {\n\t\t\txdp_return_frame_rx_napi(xdpf);\n\t\t\tdrops++;\n\t\t}\n\t}\n\n\t__netif_tx_unlock(nq);\n\n\tif (unlikely(flags & XDP_XMIT_FLUSH))\n\t\tigb_xdp_ring_update_tail(tx_ring);\n\n\treturn n - drops;\n}\n\nstatic const struct net_device_ops igb_netdev_ops = {\n\t.ndo_open\t\t= igb_open,\n\t.ndo_stop\t\t= igb_close,\n\t.ndo_start_xmit\t\t= igb_xmit_frame,\n\t.ndo_get_stats64\t= igb_get_stats64,\n\t.ndo_set_rx_mode\t= igb_set_rx_mode,\n\t.ndo_set_mac_address\t= igb_set_mac,\n\t.ndo_change_mtu\t\t= igb_change_mtu,\n\t.ndo_do_ioctl\t\t= igb_ioctl,\n\t.ndo_tx_timeout\t\t= igb_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_vlan_rx_add_vid\t= igb_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= igb_vlan_rx_kill_vid,\n\t.ndo_set_vf_mac\t\t= igb_ndo_set_vf_mac,\n\t.ndo_set_vf_vlan\t= igb_ndo_set_vf_vlan,\n\t.ndo_set_vf_rate\t= igb_ndo_set_vf_bw,\n\t.ndo_set_vf_spoofchk\t= igb_ndo_set_vf_spoofchk,\n\t.ndo_set_vf_trust\t= igb_ndo_set_vf_trust,\n\t.ndo_get_vf_config\t= igb_ndo_get_vf_config,\n\t.ndo_fix_features\t= igb_fix_features,\n\t.ndo_set_features\t= igb_set_features,\n\t.ndo_fdb_add\t\t= igb_ndo_fdb_add,\n\t.ndo_features_check\t= igb_features_check,\n\t.ndo_setup_tc\t\t= igb_setup_tc,\n\t.ndo_bpf\t\t= igb_xdp,\n\t.ndo_xdp_xmit\t\t= igb_xdp_xmit,\n};\n\n/**\n * igb_set_fw_version - Configure version string for ethtool\n * @adapter: adapter struct\n **/\nvoid igb_set_fw_version(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_fw_version fw;\n\n\tigb_get_fw_version(hw, &fw);\n\n\tswitch (hw->mac.type) {\n\tcase e1000_i210:\n\tcase e1000_i211:\n\t\tif (!(igb_get_flash_presence_i210(hw))) {\n\t\t\tsnprintf(adapter->fw_version,\n\t\t\t\t sizeof(adapter->fw_version),\n\t\t\t\t \"%2d.%2d-%d\",\n\t\t\t\t fw.invm_major, fw.invm_minor,\n\t\t\t\t fw.invm_img_type);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\t/* if option is rom valid, display its version too */\n\t\tif (fw.or_valid) {\n\t\t\tsnprintf(adapter->fw_version,\n\t\t\t\t sizeof(adapter->fw_version),\n\t\t\t\t \"%d.%d, 0x%08x, %d.%d.%d\",\n\t\t\t\t fw.eep_major, fw.eep_minor, fw.etrack_id,\n\t\t\t\t fw.or_major, fw.or_build, fw.or_patch);\n\t\t/* no option rom */\n\t\t} else if (fw.etrack_id != 0X0000) {\n\t\t\tsnprintf(adapter->fw_version,\n\t\t\t    sizeof(adapter->fw_version),\n\t\t\t    \"%d.%d, 0x%08x\",\n\t\t\t    fw.eep_major, fw.eep_minor, fw.etrack_id);\n\t\t} else {\n\t\tsnprintf(adapter->fw_version,\n\t\t    sizeof(adapter->fw_version),\n\t\t    \"%d.%d.%d\",\n\t\t    fw.eep_major, fw.eep_minor, fw.eep_build);\n\t\t}\n\t\tbreak;\n\t}\n}\n\n/**\n * igb_init_mas - init Media Autosense feature if enabled in the NVM\n *\n * @adapter: adapter struct\n **/\nstatic void igb_init_mas(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 eeprom_data;\n\n\thw->nvm.ops.read(hw, NVM_COMPAT, 1, &eeprom_data);\n\tswitch (hw->bus.func) {\n\tcase E1000_FUNC_0:\n\t\tif (eeprom_data & IGB_MAS_ENABLE_0) {\n\t\t\tadapter->flags |= IGB_FLAG_MAS_ENABLE;\n\t\t\tnetdev_info(adapter->netdev,\n\t\t\t\t\"MAS: Enabling Media Autosense for port %d\\n\",\n\t\t\t\thw->bus.func);\n\t\t}\n\t\tbreak;\n\tcase E1000_FUNC_1:\n\t\tif (eeprom_data & IGB_MAS_ENABLE_1) {\n\t\t\tadapter->flags |= IGB_FLAG_MAS_ENABLE;\n\t\t\tnetdev_info(adapter->netdev,\n\t\t\t\t\"MAS: Enabling Media Autosense for port %d\\n\",\n\t\t\t\thw->bus.func);\n\t\t}\n\t\tbreak;\n\tcase E1000_FUNC_2:\n\t\tif (eeprom_data & IGB_MAS_ENABLE_2) {\n\t\t\tadapter->flags |= IGB_FLAG_MAS_ENABLE;\n\t\t\tnetdev_info(adapter->netdev,\n\t\t\t\t\"MAS: Enabling Media Autosense for port %d\\n\",\n\t\t\t\thw->bus.func);\n\t\t}\n\t\tbreak;\n\tcase E1000_FUNC_3:\n\t\tif (eeprom_data & IGB_MAS_ENABLE_3) {\n\t\t\tadapter->flags |= IGB_FLAG_MAS_ENABLE;\n\t\t\tnetdev_info(adapter->netdev,\n\t\t\t\t\"MAS: Enabling Media Autosense for port %d\\n\",\n\t\t\t\thw->bus.func);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/* Shouldn't get here */\n\t\tnetdev_err(adapter->netdev,\n\t\t\t\"MAS: Invalid port configuration, returning\\n\");\n\t\tbreak;\n\t}\n}\n\n/**\n *  igb_init_i2c - Init I2C interface\n *  @adapter: pointer to adapter structure\n **/\nstatic s32 igb_init_i2c(struct igb_adapter *adapter)\n{\n\ts32 status = 0;\n\n\t/* I2C interface supported on i350 devices */\n\tif (adapter->hw.mac.type != e1000_i350)\n\t\treturn 0;\n\n\t/* Initialize the i2c bus which is controlled by the registers.\n\t * This bus will use the i2c_algo_bit structue that implements\n\t * the protocol through toggling of the 4 bits in the register.\n\t */\n\tadapter->i2c_adap.owner = THIS_MODULE;\n\tadapter->i2c_algo = igb_i2c_algo;\n\tadapter->i2c_algo.data = adapter;\n\tadapter->i2c_adap.algo_data = &adapter->i2c_algo;\n\tadapter->i2c_adap.dev.parent = &adapter->pdev->dev;\n\tstrlcpy(adapter->i2c_adap.name, \"igb BB\",\n\t\tsizeof(adapter->i2c_adap.name));\n\tstatus = i2c_bit_add_bus(&adapter->i2c_adap);\n\treturn status;\n}\n\n/**\n *  igb_probe - Device Initialization Routine\n *  @pdev: PCI device information struct\n *  @ent: entry in igb_pci_tbl\n *\n *  Returns 0 on success, negative on failure\n *\n *  igb_probe initializes an adapter identified by a pci_dev structure.\n *  The OS initialization, configuring of the adapter private structure,\n *  and a hardware reset occur.\n **/\nstatic int igb_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *netdev;\n\tstruct igb_adapter *adapter;\n\tstruct e1000_hw *hw;\n\tu16 eeprom_data = 0;\n\ts32 ret_val;\n\tstatic int global_quad_port_a; /* global quad port a indication */\n\tconst struct e1000_info *ei = igb_info_tbl[ent->driver_data];\n\tint err, pci_using_dac;\n\tu8 part_str[E1000_PBANUM_LENGTH];\n\n\t/* Catch broken hardware that put the wrong VF device ID in\n\t * the PCIe SR-IOV capability.\n\t */\n\tif (pdev->is_virtfn) {\n\t\tWARN(1, KERN_ERR \"%s (%hx:%hx) should not be a VF!\\n\",\n\t\t\tpci_name(pdev), pdev->vendor, pdev->device);\n\t\treturn -EINVAL;\n\t}\n\n\terr = pci_enable_device_mem(pdev);\n\tif (err)\n\t\treturn err;\n\n\tpci_using_dac = 0;\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (!err) {\n\t\tpci_using_dac = 1;\n\t} else {\n\t\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"No usable DMA configuration, aborting\\n\");\n\t\t\tgoto err_dma;\n\t\t}\n\t}\n\n\terr = pci_request_mem_regions(pdev, igb_driver_name);\n\tif (err)\n\t\tgoto err_pci_reg;\n\n\tpci_enable_pcie_error_reporting(pdev);\n\n\tpci_set_master(pdev);\n\tpci_save_state(pdev);\n\n\terr = -ENOMEM;\n\tnetdev = alloc_etherdev_mq(sizeof(struct igb_adapter),\n\t\t\t\t   IGB_MAX_TX_QUEUES);\n\tif (!netdev)\n\t\tgoto err_alloc_etherdev;\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\tpci_set_drvdata(pdev, netdev);\n\tadapter = netdev_priv(netdev);\n\tadapter->netdev = netdev;\n\tadapter->pdev = pdev;\n\thw = &adapter->hw;\n\thw->back = adapter;\n\tadapter->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);\n\n\terr = -EIO;\n\tadapter->io_addr = pci_iomap(pdev, 0, 0);\n\tif (!adapter->io_addr)\n\t\tgoto err_ioremap;\n\t/* hw->hw_addr can be altered, we'll use adapter->io_addr for unmap */\n\thw->hw_addr = adapter->io_addr;\n\n\tnetdev->netdev_ops = &igb_netdev_ops;\n\tigb_set_ethtool_ops(netdev);\n\tnetdev->watchdog_timeo = 5 * HZ;\n\n\tstrncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);\n\n\tnetdev->mem_start = pci_resource_start(pdev, 0);\n\tnetdev->mem_end = pci_resource_end(pdev, 0);\n\n\t/* PCI config space info */\n\thw->vendor_id = pdev->vendor;\n\thw->device_id = pdev->device;\n\thw->revision_id = pdev->revision;\n\thw->subsystem_vendor_id = pdev->subsystem_vendor;\n\thw->subsystem_device_id = pdev->subsystem_device;\n\n\t/* Copy the default MAC, PHY and NVM function pointers */\n\tmemcpy(&hw->mac.ops, ei->mac_ops, sizeof(hw->mac.ops));\n\tmemcpy(&hw->phy.ops, ei->phy_ops, sizeof(hw->phy.ops));\n\tmemcpy(&hw->nvm.ops, ei->nvm_ops, sizeof(hw->nvm.ops));\n\t/* Initialize skew-specific constants */\n\terr = ei->get_invariants(hw);\n\tif (err)\n\t\tgoto err_sw_init;\n\n\t/* setup the private structure */\n\terr = igb_sw_init(adapter);\n\tif (err)\n\t\tgoto err_sw_init;\n\n\tigb_get_bus_info_pcie(hw);\n\n\thw->phy.autoneg_wait_to_complete = false;\n\n\t/* Copper options */\n\tif (hw->phy.media_type == e1000_media_type_copper) {\n\t\thw->phy.mdix = AUTO_ALL_MODES;\n\t\thw->phy.disable_polarity_correction = false;\n\t\thw->phy.ms_type = e1000_ms_hw_default;\n\t}\n\n\tif (igb_check_reset_block(hw))\n\t\tdev_info(&pdev->dev,\n\t\t\t\"PHY reset is blocked due to SOL/IDER session.\\n\");\n\n\t/* features is initialized to 0 in allocation, it might have bits\n\t * set by igb_sw_init so we should use an or instead of an\n\t * assignment.\n\t */\n\tnetdev->features |= NETIF_F_SG |\n\t\t\t    NETIF_F_TSO |\n\t\t\t    NETIF_F_TSO6 |\n\t\t\t    NETIF_F_RXHASH |\n\t\t\t    NETIF_F_RXCSUM |\n\t\t\t    NETIF_F_HW_CSUM;\n\n\tif (hw->mac.type >= e1000_82576)\n\t\tnetdev->features |= NETIF_F_SCTP_CRC | NETIF_F_GSO_UDP_L4;\n\n\tif (hw->mac.type >= e1000_i350)\n\t\tnetdev->features |= NETIF_F_HW_TC;\n\n#define IGB_GSO_PARTIAL_FEATURES (NETIF_F_GSO_GRE | \\\n\t\t\t\t  NETIF_F_GSO_GRE_CSUM | \\\n\t\t\t\t  NETIF_F_GSO_IPXIP4 | \\\n\t\t\t\t  NETIF_F_GSO_IPXIP6 | \\\n\t\t\t\t  NETIF_F_GSO_UDP_TUNNEL | \\\n\t\t\t\t  NETIF_F_GSO_UDP_TUNNEL_CSUM)\n\n\tnetdev->gso_partial_features = IGB_GSO_PARTIAL_FEATURES;\n\tnetdev->features |= NETIF_F_GSO_PARTIAL | IGB_GSO_PARTIAL_FEATURES;\n\n\t/* copy netdev features into list of user selectable features */\n\tnetdev->hw_features |= netdev->features |\n\t\t\t       NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t       NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t       NETIF_F_RXALL;\n\n\tif (hw->mac.type >= e1000_i350)\n\t\tnetdev->hw_features |= NETIF_F_NTUPLE;\n\n\tif (pci_using_dac)\n\t\tnetdev->features |= NETIF_F_HIGHDMA;\n\n\tnetdev->vlan_features |= netdev->features | NETIF_F_TSO_MANGLEID;\n\tnetdev->mpls_features |= NETIF_F_HW_CSUM;\n\tnetdev->hw_enc_features |= netdev->vlan_features;\n\n\t/* set this bit last since it cannot be part of vlan_features */\n\tnetdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER |\n\t\t\t    NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t    NETIF_F_HW_VLAN_CTAG_TX;\n\n\tnetdev->priv_flags |= IFF_SUPP_NOFCS;\n\n\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\n\t/* MTU range: 68 - 9216 */\n\tnetdev->min_mtu = ETH_MIN_MTU;\n\tnetdev->max_mtu = MAX_STD_JUMBO_FRAME_SIZE;\n\n\tadapter->en_mng_pt = igb_enable_mng_pass_thru(hw);\n\n\t/* before reading the NVM, reset the controller to put the device in a\n\t * known good starting state\n\t */\n\thw->mac.ops.reset_hw(hw);\n\n\t/* make sure the NVM is good , i211/i210 parts can have special NVM\n\t * that doesn't contain a checksum\n\t */\n\tswitch (hw->mac.type) {\n\tcase e1000_i210:\n\tcase e1000_i211:\n\t\tif (igb_get_flash_presence_i210(hw)) {\n\t\t\tif (hw->nvm.ops.validate(hw) < 0) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"The NVM Checksum Is Not Valid\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_eeprom;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (hw->nvm.ops.validate(hw) < 0) {\n\t\t\tdev_err(&pdev->dev, \"The NVM Checksum Is Not Valid\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto err_eeprom;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (eth_platform_get_mac_address(&pdev->dev, hw->mac.addr)) {\n\t\t/* copy the MAC address out of the NVM */\n\t\tif (hw->mac.ops.read_mac_addr(hw))\n\t\t\tdev_err(&pdev->dev, \"NVM Read Error\\n\");\n\t}\n\n\tmemcpy(netdev->dev_addr, hw->mac.addr, netdev->addr_len);\n\n\tif (!is_valid_ether_addr(netdev->dev_addr)) {\n\t\tdev_err(&pdev->dev, \"Invalid MAC Address\\n\");\n\t\terr = -EIO;\n\t\tgoto err_eeprom;\n\t}\n\n\tigb_set_default_mac_filter(adapter);\n\n\t/* get firmware version for ethtool -i */\n\tigb_set_fw_version(adapter);\n\n\t/* configure RXPBSIZE and TXPBSIZE */\n\tif (hw->mac.type == e1000_i210) {\n\t\twr32(E1000_RXPBS, I210_RXPBSIZE_DEFAULT);\n\t\twr32(E1000_TXPBS, I210_TXPBSIZE_DEFAULT);\n\t}\n\n\ttimer_setup(&adapter->watchdog_timer, igb_watchdog, 0);\n\ttimer_setup(&adapter->phy_info_timer, igb_update_phy_info, 0);\n\n\tINIT_WORK(&adapter->reset_task, igb_reset_task);\n\tINIT_WORK(&adapter->watchdog_task, igb_watchdog_task);\n\n\t/* Initialize link properties that are user-changeable */\n\tadapter->fc_autoneg = true;\n\thw->mac.autoneg = true;\n\thw->phy.autoneg_advertised = 0x2f;\n\n\thw->fc.requested_mode = e1000_fc_default;\n\thw->fc.current_mode = e1000_fc_default;\n\n\tigb_validate_mdi_setting(hw);\n\n\t/* By default, support wake on port A */\n\tif (hw->bus.func == 0)\n\t\tadapter->flags |= IGB_FLAG_WOL_SUPPORTED;\n\n\t/* Check the NVM for wake support on non-port A ports */\n\tif (hw->mac.type >= e1000_82580)\n\t\thw->nvm.ops.read(hw, NVM_INIT_CONTROL3_PORT_A +\n\t\t\t\t NVM_82580_LAN_FUNC_OFFSET(hw->bus.func), 1,\n\t\t\t\t &eeprom_data);\n\telse if (hw->bus.func == 1)\n\t\thw->nvm.ops.read(hw, NVM_INIT_CONTROL3_PORT_B, 1, &eeprom_data);\n\n\tif (eeprom_data & IGB_EEPROM_APME)\n\t\tadapter->flags |= IGB_FLAG_WOL_SUPPORTED;\n\n\t/* now that we have the eeprom settings, apply the special cases where\n\t * the eeprom may be wrong or the board simply won't support wake on\n\t * lan on a particular port\n\t */\n\tswitch (pdev->device) {\n\tcase E1000_DEV_ID_82575GB_QUAD_COPPER:\n\t\tadapter->flags &= ~IGB_FLAG_WOL_SUPPORTED;\n\t\tbreak;\n\tcase E1000_DEV_ID_82575EB_FIBER_SERDES:\n\tcase E1000_DEV_ID_82576_FIBER:\n\tcase E1000_DEV_ID_82576_SERDES:\n\t\t/* Wake events only supported on port A for dual fiber\n\t\t * regardless of eeprom setting\n\t\t */\n\t\tif (rd32(E1000_STATUS) & E1000_STATUS_FUNC_1)\n\t\t\tadapter->flags &= ~IGB_FLAG_WOL_SUPPORTED;\n\t\tbreak;\n\tcase E1000_DEV_ID_82576_QUAD_COPPER:\n\tcase E1000_DEV_ID_82576_QUAD_COPPER_ET2:\n\t\t/* if quad port adapter, disable WoL on all but port A */\n\t\tif (global_quad_port_a != 0)\n\t\t\tadapter->flags &= ~IGB_FLAG_WOL_SUPPORTED;\n\t\telse\n\t\t\tadapter->flags |= IGB_FLAG_QUAD_PORT_A;\n\t\t/* Reset for multiple quad port adapters */\n\t\tif (++global_quad_port_a == 4)\n\t\t\tglobal_quad_port_a = 0;\n\t\tbreak;\n\tdefault:\n\t\t/* If the device can't wake, don't set software support */\n\t\tif (!device_can_wakeup(&adapter->pdev->dev))\n\t\t\tadapter->flags &= ~IGB_FLAG_WOL_SUPPORTED;\n\t}\n\n\t/* initialize the wol settings based on the eeprom settings */\n\tif (adapter->flags & IGB_FLAG_WOL_SUPPORTED)\n\t\tadapter->wol |= E1000_WUFC_MAG;\n\n\t/* Some vendors want WoL disabled by default, but still supported */\n\tif ((hw->mac.type == e1000_i350) &&\n\t    (pdev->subsystem_vendor == PCI_VENDOR_ID_HP)) {\n\t\tadapter->flags |= IGB_FLAG_WOL_SUPPORTED;\n\t\tadapter->wol = 0;\n\t}\n\n\t/* Some vendors want the ability to Use the EEPROM setting as\n\t * enable/disable only, and not for capability\n\t */\n\tif (((hw->mac.type == e1000_i350) ||\n\t     (hw->mac.type == e1000_i354)) &&\n\t    (pdev->subsystem_vendor == PCI_VENDOR_ID_DELL)) {\n\t\tadapter->flags |= IGB_FLAG_WOL_SUPPORTED;\n\t\tadapter->wol = 0;\n\t}\n\tif (hw->mac.type == e1000_i350) {\n\t\tif (((pdev->subsystem_device == 0x5001) ||\n\t\t     (pdev->subsystem_device == 0x5002)) &&\n\t\t\t\t(hw->bus.func == 0)) {\n\t\t\tadapter->flags |= IGB_FLAG_WOL_SUPPORTED;\n\t\t\tadapter->wol = 0;\n\t\t}\n\t\tif (pdev->subsystem_device == 0x1F52)\n\t\t\tadapter->flags |= IGB_FLAG_WOL_SUPPORTED;\n\t}\n\n\tdevice_set_wakeup_enable(&adapter->pdev->dev,\n\t\t\t\t adapter->flags & IGB_FLAG_WOL_SUPPORTED);\n\n\t/* reset the hardware with the new settings */\n\tigb_reset(adapter);\n\n\t/* Init the I2C interface */\n\terr = igb_init_i2c(adapter);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to init i2c interface\\n\");\n\t\tgoto err_eeprom;\n\t}\n\n\t/* let the f/w know that the h/w is now under the control of the\n\t * driver.\n\t */\n\tigb_get_hw_control(adapter);\n\n\tstrcpy(netdev->name, \"eth%d\");\n\terr = register_netdev(netdev);\n\tif (err)\n\t\tgoto err_register;\n\n\t/* carrier off reporting is important to ethtool even BEFORE open */\n\tnetif_carrier_off(netdev);\n\n#ifdef CONFIG_IGB_DCA\n\tif (dca_add_requester(&pdev->dev) == 0) {\n\t\tadapter->flags |= IGB_FLAG_DCA_ENABLED;\n\t\tdev_info(&pdev->dev, \"DCA enabled\\n\");\n\t\tigb_setup_dca(adapter);\n\t}\n\n#endif\n#ifdef CONFIG_IGB_HWMON\n\t/* Initialize the thermal sensor on i350 devices. */\n\tif (hw->mac.type == e1000_i350 && hw->bus.func == 0) {\n\t\tu16 ets_word;\n\n\t\t/* Read the NVM to determine if this i350 device supports an\n\t\t * external thermal sensor.\n\t\t */\n\t\thw->nvm.ops.read(hw, NVM_ETS_CFG, 1, &ets_word);\n\t\tif (ets_word != 0x0000 && ets_word != 0xFFFF)\n\t\t\tadapter->ets = true;\n\t\telse\n\t\t\tadapter->ets = false;\n\t\tif (igb_sysfs_init(adapter))\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to allocate sysfs resources\\n\");\n\t} else {\n\t\tadapter->ets = false;\n\t}\n#endif\n\t/* Check if Media Autosense is enabled */\n\tadapter->ei = *ei;\n\tif (hw->dev_spec._82575.mas_capable)\n\t\tigb_init_mas(adapter);\n\n\t/* do hw tstamp init after resetting */\n\tigb_ptp_init(adapter);\n\n\tdev_info(&pdev->dev, \"Intel(R) Gigabit Ethernet Network Connection\\n\");\n\t/* print bus type/speed/width info, not applicable to i354 */\n\tif (hw->mac.type != e1000_i354) {\n\t\tdev_info(&pdev->dev, \"%s: (PCIe:%s:%s) %pM\\n\",\n\t\t\t netdev->name,\n\t\t\t ((hw->bus.speed == e1000_bus_speed_2500) ? \"2.5Gb/s\" :\n\t\t\t  (hw->bus.speed == e1000_bus_speed_5000) ? \"5.0Gb/s\" :\n\t\t\t   \"unknown\"),\n\t\t\t ((hw->bus.width == e1000_bus_width_pcie_x4) ?\n\t\t\t  \"Width x4\" :\n\t\t\t  (hw->bus.width == e1000_bus_width_pcie_x2) ?\n\t\t\t  \"Width x2\" :\n\t\t\t  (hw->bus.width == e1000_bus_width_pcie_x1) ?\n\t\t\t  \"Width x1\" : \"unknown\"), netdev->dev_addr);\n\t}\n\n\tif ((hw->mac.type == e1000_82576 &&\n\t     rd32(E1000_EECD) & E1000_EECD_PRES) ||\n\t    (hw->mac.type >= e1000_i210 ||\n\t     igb_get_flash_presence_i210(hw))) {\n\t\tret_val = igb_read_part_string(hw, part_str,\n\t\t\t\t\t       E1000_PBANUM_LENGTH);\n\t} else {\n\t\tret_val = -E1000_ERR_INVM_VALUE_NOT_FOUND;\n\t}\n\n\tif (ret_val)\n\t\tstrcpy(part_str, \"Unknown\");\n\tdev_info(&pdev->dev, \"%s: PBA No: %s\\n\", netdev->name, part_str);\n\tdev_info(&pdev->dev,\n\t\t\"Using %s interrupts. %d rx queue(s), %d tx queue(s)\\n\",\n\t\t(adapter->flags & IGB_FLAG_HAS_MSIX) ? \"MSI-X\" :\n\t\t(adapter->flags & IGB_FLAG_HAS_MSI) ? \"MSI\" : \"legacy\",\n\t\tadapter->num_rx_queues, adapter->num_tx_queues);\n\tif (hw->phy.media_type == e1000_media_type_copper) {\n\t\tswitch (hw->mac.type) {\n\t\tcase e1000_i350:\n\t\tcase e1000_i210:\n\t\tcase e1000_i211:\n\t\t\t/* Enable EEE for internal copper PHY devices */\n\t\t\terr = igb_set_eee_i350(hw, true, true);\n\t\t\tif ((!err) &&\n\t\t\t    (!hw->dev_spec._82575.eee_disable)) {\n\t\t\t\tadapter->eee_advert =\n\t\t\t\t\tMDIO_EEE_100TX | MDIO_EEE_1000T;\n\t\t\t\tadapter->flags |= IGB_FLAG_EEE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase e1000_i354:\n\t\t\tif ((rd32(E1000_CTRL_EXT) &\n\t\t\t    E1000_CTRL_EXT_LINK_MODE_SGMII)) {\n\t\t\t\terr = igb_set_eee_i354(hw, true, true);\n\t\t\t\tif ((!err) &&\n\t\t\t\t\t(!hw->dev_spec._82575.eee_disable)) {\n\t\t\t\t\tadapter->eee_advert =\n\t\t\t\t\t   MDIO_EEE_100TX | MDIO_EEE_1000T;\n\t\t\t\t\tadapter->flags |= IGB_FLAG_EEE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdev_pm_set_driver_flags(&pdev->dev, DPM_FLAG_NO_DIRECT_COMPLETE);\n\n\tpm_runtime_put_noidle(&pdev->dev);\n\treturn 0;\n\nerr_register:\n\tigb_release_hw_control(adapter);\n\tmemset(&adapter->i2c_adap, 0, sizeof(adapter->i2c_adap));\nerr_eeprom:\n\tif (!igb_check_reset_block(hw))\n\t\tigb_reset_phy(hw);\n\n\tif (hw->flash_address)\n\t\tiounmap(hw->flash_address);\nerr_sw_init:\n\tkfree(adapter->mac_table);\n\tkfree(adapter->shadow_vfta);\n\tigb_clear_interrupt_scheme(adapter);\n#ifdef CONFIG_PCI_IOV\n\tigb_disable_sriov(pdev);\n#endif\n\tpci_iounmap(pdev, adapter->io_addr);\nerr_ioremap:\n\tfree_netdev(netdev);\nerr_alloc_etherdev:\n\tpci_release_mem_regions(pdev);\nerr_pci_reg:\nerr_dma:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\n#ifdef CONFIG_PCI_IOV\nstatic int igb_disable_sriov(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t/* reclaim resources allocated to VFs */\n\tif (adapter->vf_data) {\n\t\t/* disable iov and allow time for transactions to clear */\n\t\tif (pci_vfs_assigned(pdev)) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"Cannot deallocate SR-IOV virtual functions while they are assigned - VFs will not be deallocated\\n\");\n\t\t\treturn -EPERM;\n\t\t} else {\n\t\t\tpci_disable_sriov(pdev);\n\t\t\tmsleep(500);\n\t\t}\n\n\t\tkfree(adapter->vf_mac_list);\n\t\tadapter->vf_mac_list = NULL;\n\t\tkfree(adapter->vf_data);\n\t\tadapter->vf_data = NULL;\n\t\tadapter->vfs_allocated_count = 0;\n\t\twr32(E1000_IOVCTL, E1000_IOVCTL_REUSE_VFQ);\n\t\twrfl();\n\t\tmsleep(100);\n\t\tdev_info(&pdev->dev, \"IOV Disabled\\n\");\n\n\t\t/* Re-enable DMA Coalescing flag since IOV is turned off */\n\t\tadapter->flags |= IGB_FLAG_DMAC;\n\t}\n\n\treturn 0;\n}\n\nstatic int igb_enable_sriov(struct pci_dev *pdev, int num_vfs)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tint old_vfs = pci_num_vf(pdev);\n\tstruct vf_mac_filter *mac_list;\n\tint err = 0;\n\tint num_vf_mac_filters, i;\n\n\tif (!(adapter->flags & IGB_FLAG_HAS_MSIX) || num_vfs > 7) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\tif (!num_vfs)\n\t\tgoto out;\n\n\tif (old_vfs) {\n\t\tdev_info(&pdev->dev, \"%d pre-allocated VFs found - override max_vfs setting of %d\\n\",\n\t\t\t old_vfs, max_vfs);\n\t\tadapter->vfs_allocated_count = old_vfs;\n\t} else\n\t\tadapter->vfs_allocated_count = num_vfs;\n\n\tadapter->vf_data = kcalloc(adapter->vfs_allocated_count,\n\t\t\t\tsizeof(struct vf_data_storage), GFP_KERNEL);\n\n\t/* if allocation failed then we do not support SR-IOV */\n\tif (!adapter->vf_data) {\n\t\tadapter->vfs_allocated_count = 0;\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Due to the limited number of RAR entries calculate potential\n\t * number of MAC filters available for the VFs. Reserve entries\n\t * for PF default MAC, PF MAC filters and at least one RAR entry\n\t * for each VF for VF MAC.\n\t */\n\tnum_vf_mac_filters = adapter->hw.mac.rar_entry_count -\n\t\t\t     (1 + IGB_PF_MAC_FILTERS_RESERVED +\n\t\t\t      adapter->vfs_allocated_count);\n\n\tadapter->vf_mac_list = kcalloc(num_vf_mac_filters,\n\t\t\t\t       sizeof(struct vf_mac_filter),\n\t\t\t\t       GFP_KERNEL);\n\n\tmac_list = adapter->vf_mac_list;\n\tINIT_LIST_HEAD(&adapter->vf_macs.l);\n\n\tif (adapter->vf_mac_list) {\n\t\t/* Initialize list of VF MAC filters */\n\t\tfor (i = 0; i < num_vf_mac_filters; i++) {\n\t\t\tmac_list->vf = -1;\n\t\t\tmac_list->free = true;\n\t\t\tlist_add(&mac_list->l, &adapter->vf_macs.l);\n\t\t\tmac_list++;\n\t\t}\n\t} else {\n\t\t/* If we could not allocate memory for the VF MAC filters\n\t\t * we can continue without this feature but warn user.\n\t\t */\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to allocate memory for VF MAC filter list\\n\");\n\t}\n\n\t/* only call pci_enable_sriov() if no VFs are allocated already */\n\tif (!old_vfs) {\n\t\terr = pci_enable_sriov(pdev, adapter->vfs_allocated_count);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\tdev_info(&pdev->dev, \"%d VFs allocated\\n\",\n\t\t adapter->vfs_allocated_count);\n\tfor (i = 0; i < adapter->vfs_allocated_count; i++)\n\t\tigb_vf_configure(adapter, i);\n\n\t/* DMA Coalescing is not supported in IOV mode. */\n\tadapter->flags &= ~IGB_FLAG_DMAC;\n\tgoto out;\n\nerr_out:\n\tkfree(adapter->vf_mac_list);\n\tadapter->vf_mac_list = NULL;\n\tkfree(adapter->vf_data);\n\tadapter->vf_data = NULL;\n\tadapter->vfs_allocated_count = 0;\nout:\n\treturn err;\n}\n\n#endif\n/**\n *  igb_remove_i2c - Cleanup  I2C interface\n *  @adapter: pointer to adapter structure\n **/\nstatic void igb_remove_i2c(struct igb_adapter *adapter)\n{\n\t/* free the adapter bus structure */\n\ti2c_del_adapter(&adapter->i2c_adap);\n}\n\n/**\n *  igb_remove - Device Removal Routine\n *  @pdev: PCI device information struct\n *\n *  igb_remove is called by the PCI subsystem to alert the driver\n *  that it should release a PCI device.  The could be caused by a\n *  Hot-Plug event, or because the driver is going to be removed from\n *  memory.\n **/\nstatic void igb_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tpm_runtime_get_noresume(&pdev->dev);\n#ifdef CONFIG_IGB_HWMON\n\tigb_sysfs_exit(adapter);\n#endif\n\tigb_remove_i2c(adapter);\n\tigb_ptp_stop(adapter);\n\t/* The watchdog timer may be rescheduled, so explicitly\n\t * disable watchdog from being rescheduled.\n\t */\n\tset_bit(__IGB_DOWN, &adapter->state);\n\tdel_timer_sync(&adapter->watchdog_timer);\n\tdel_timer_sync(&adapter->phy_info_timer);\n\n\tcancel_work_sync(&adapter->reset_task);\n\tcancel_work_sync(&adapter->watchdog_task);\n\n#ifdef CONFIG_IGB_DCA\n\tif (adapter->flags & IGB_FLAG_DCA_ENABLED) {\n\t\tdev_info(&pdev->dev, \"DCA disabled\\n\");\n\t\tdca_remove_requester(&pdev->dev);\n\t\tadapter->flags &= ~IGB_FLAG_DCA_ENABLED;\n\t\twr32(E1000_DCA_CTRL, E1000_DCA_CTRL_DCA_MODE_DISABLE);\n\t}\n#endif\n\n\t/* Release control of h/w to f/w.  If f/w is AMT enabled, this\n\t * would have already happened in close and is redundant.\n\t */\n\tigb_release_hw_control(adapter);\n\n#ifdef CONFIG_PCI_IOV\n\tigb_disable_sriov(pdev);\n#endif\n\n\tunregister_netdev(netdev);\n\n\tigb_clear_interrupt_scheme(adapter);\n\n\tpci_iounmap(pdev, adapter->io_addr);\n\tif (hw->flash_address)\n\t\tiounmap(hw->flash_address);\n\tpci_release_mem_regions(pdev);\n\n\tkfree(adapter->mac_table);\n\tkfree(adapter->shadow_vfta);\n\tfree_netdev(netdev);\n\n\tpci_disable_pcie_error_reporting(pdev);\n\n\tpci_disable_device(pdev);\n}\n\n/**\n *  igb_probe_vfs - Initialize vf data storage and add VFs to pci config space\n *  @adapter: board private structure to initialize\n *\n *  This function initializes the vf specific data storage and then attempts to\n *  allocate the VFs.  The reason for ordering it this way is because it is much\n *  mor expensive time wise to disable SR-IOV than it is to allocate and free\n *  the memory for the VFs.\n **/\nstatic void igb_probe_vfs(struct igb_adapter *adapter)\n{\n#ifdef CONFIG_PCI_IOV\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t/* Virtualization features not supported on i210 family. */\n\tif ((hw->mac.type == e1000_i210) || (hw->mac.type == e1000_i211))\n\t\treturn;\n\n\t/* Of the below we really only want the effect of getting\n\t * IGB_FLAG_HAS_MSIX set (if available), without which\n\t * igb_enable_sriov() has no effect.\n\t */\n\tigb_set_interrupt_capability(adapter, true);\n\tigb_reset_interrupt_capability(adapter);\n\n\tpci_sriov_set_totalvfs(pdev, 7);\n\tigb_enable_sriov(pdev, max_vfs);\n\n#endif /* CONFIG_PCI_IOV */\n}\n\nunsigned int igb_get_max_rss_queues(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunsigned int max_rss_queues;\n\n\t/* Determine the maximum number of RSS queues supported. */\n\tswitch (hw->mac.type) {\n\tcase e1000_i211:\n\t\tmax_rss_queues = IGB_MAX_RX_QUEUES_I211;\n\t\tbreak;\n\tcase e1000_82575:\n\tcase e1000_i210:\n\t\tmax_rss_queues = IGB_MAX_RX_QUEUES_82575;\n\t\tbreak;\n\tcase e1000_i350:\n\t\t/* I350 cannot do RSS and SR-IOV at the same time */\n\t\tif (!!adapter->vfs_allocated_count) {\n\t\t\tmax_rss_queues = 1;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase e1000_82576:\n\t\tif (!!adapter->vfs_allocated_count) {\n\t\t\tmax_rss_queues = 2;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase e1000_82580:\n\tcase e1000_i354:\n\tdefault:\n\t\tmax_rss_queues = IGB_MAX_RX_QUEUES;\n\t\tbreak;\n\t}\n\n\treturn max_rss_queues;\n}\n\nstatic void igb_init_queue_configuration(struct igb_adapter *adapter)\n{\n\tu32 max_rss_queues;\n\n\tmax_rss_queues = igb_get_max_rss_queues(adapter);\n\tadapter->rss_queues = min_t(u32, max_rss_queues, num_online_cpus());\n\n\tigb_set_flag_queue_pairs(adapter, max_rss_queues);\n}\n\nvoid igb_set_flag_queue_pairs(struct igb_adapter *adapter,\n\t\t\t      const u32 max_rss_queues)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t/* Determine if we need to pair queues. */\n\tswitch (hw->mac.type) {\n\tcase e1000_82575:\n\tcase e1000_i211:\n\t\t/* Device supports enough interrupts without queue pairing. */\n\t\tbreak;\n\tcase e1000_82576:\n\tcase e1000_82580:\n\tcase e1000_i350:\n\tcase e1000_i354:\n\tcase e1000_i210:\n\tdefault:\n\t\t/* If rss_queues > half of max_rss_queues, pair the queues in\n\t\t * order to conserve interrupts due to limited supply.\n\t\t */\n\t\tif (adapter->rss_queues > (max_rss_queues / 2))\n\t\t\tadapter->flags |= IGB_FLAG_QUEUE_PAIRS;\n\t\telse\n\t\t\tadapter->flags &= ~IGB_FLAG_QUEUE_PAIRS;\n\t\tbreak;\n\t}\n}\n\n/**\n *  igb_sw_init - Initialize general software structures (struct igb_adapter)\n *  @adapter: board private structure to initialize\n *\n *  igb_sw_init initializes the Adapter private data structure.\n *  Fields are initialized based on PCI device information and\n *  OS network device settings (MTU size).\n **/\nstatic int igb_sw_init(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tpci_read_config_word(pdev, PCI_COMMAND, &hw->bus.pci_cmd_word);\n\n\t/* set default ring sizes */\n\tadapter->tx_ring_count = IGB_DEFAULT_TXD;\n\tadapter->rx_ring_count = IGB_DEFAULT_RXD;\n\n\t/* set default ITR values */\n\tadapter->rx_itr_setting = IGB_DEFAULT_ITR;\n\tadapter->tx_itr_setting = IGB_DEFAULT_ITR;\n\n\t/* set default work limits */\n\tadapter->tx_work_limit = IGB_DEFAULT_TX_WORK;\n\n\tadapter->max_frame_size = netdev->mtu + IGB_ETH_PKT_HDR_PAD;\n\tadapter->min_frame_size = ETH_ZLEN + ETH_FCS_LEN;\n\n\tspin_lock_init(&adapter->nfc_lock);\n\tspin_lock_init(&adapter->stats64_lock);\n#ifdef CONFIG_PCI_IOV\n\tswitch (hw->mac.type) {\n\tcase e1000_82576:\n\tcase e1000_i350:\n\t\tif (max_vfs > 7) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"Maximum of 7 VFs per PF, using max\\n\");\n\t\t\tmax_vfs = adapter->vfs_allocated_count = 7;\n\t\t} else\n\t\t\tadapter->vfs_allocated_count = max_vfs;\n\t\tif (adapter->vfs_allocated_count)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"Enabling SR-IOV VFs using the module parameter is deprecated - please use the pci sysfs interface.\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif /* CONFIG_PCI_IOV */\n\n\t/* Assume MSI-X interrupts, will be checked during IRQ allocation */\n\tadapter->flags |= IGB_FLAG_HAS_MSIX;\n\n\tadapter->mac_table = kcalloc(hw->mac.rar_entry_count,\n\t\t\t\t     sizeof(struct igb_mac_addr),\n\t\t\t\t     GFP_KERNEL);\n\tif (!adapter->mac_table)\n\t\treturn -ENOMEM;\n\n\tigb_probe_vfs(adapter);\n\n\tigb_init_queue_configuration(adapter);\n\n\t/* Setup and initialize a copy of the hw vlan table array */\n\tadapter->shadow_vfta = kcalloc(E1000_VLAN_FILTER_TBL_SIZE, sizeof(u32),\n\t\t\t\t       GFP_KERNEL);\n\tif (!adapter->shadow_vfta)\n\t\treturn -ENOMEM;\n\n\t/* This call may decrease the number of queues */\n\tif (igb_init_interrupt_scheme(adapter, true)) {\n\t\tdev_err(&pdev->dev, \"Unable to allocate memory for queues\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Explicitly disable IRQ since the NIC can be in any state. */\n\tigb_irq_disable(adapter);\n\n\tif (hw->mac.type >= e1000_i350)\n\t\tadapter->flags &= ~IGB_FLAG_DMAC;\n\n\tset_bit(__IGB_DOWN, &adapter->state);\n\treturn 0;\n}\n\n/**\n *  igb_open - Called when a network interface is made active\n *  @netdev: network interface device structure\n *  @resuming: indicates whether we are in a resume call\n *\n *  Returns 0 on success, negative value on failure\n *\n *  The open entry point is called when a network interface is made\n *  active by the system (IFF_UP).  At this point all resources needed\n *  for transmit and receive operations are allocated, the interrupt\n *  handler is registered with the OS, the watchdog timer is started,\n *  and the stack is notified that the interface is ready.\n **/\nstatic int __igb_open(struct net_device *netdev, bool resuming)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint err;\n\tint i;\n\n\t/* disallow open during test */\n\tif (test_bit(__IGB_TESTING, &adapter->state)) {\n\t\tWARN_ON(resuming);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!resuming)\n\t\tpm_runtime_get_sync(&pdev->dev);\n\n\tnetif_carrier_off(netdev);\n\n\t/* allocate transmit descriptors */\n\terr = igb_setup_all_tx_resources(adapter);\n\tif (err)\n\t\tgoto err_setup_tx;\n\n\t/* allocate receive descriptors */\n\terr = igb_setup_all_rx_resources(adapter);\n\tif (err)\n\t\tgoto err_setup_rx;\n\n\tigb_power_up_link(adapter);\n\n\t/* before we allocate an interrupt, we must be ready to handle it.\n\t * Setting DEBUG_SHIRQ in the kernel makes it fire an interrupt\n\t * as soon as we call pci_request_irq, so we have to setup our\n\t * clean_rx handler before we do so.\n\t */\n\tigb_configure(adapter);\n\n\terr = igb_request_irq(adapter);\n\tif (err)\n\t\tgoto err_req_irq;\n\n\t/* Notify the stack of the actual queue counts. */\n\terr = netif_set_real_num_tx_queues(adapter->netdev,\n\t\t\t\t\t   adapter->num_tx_queues);\n\tif (err)\n\t\tgoto err_set_queues;\n\n\terr = netif_set_real_num_rx_queues(adapter->netdev,\n\t\t\t\t\t   adapter->num_rx_queues);\n\tif (err)\n\t\tgoto err_set_queues;\n\n\t/* From here on the code is the same as igb_up() */\n\tclear_bit(__IGB_DOWN, &adapter->state);\n\n\tfor (i = 0; i < adapter->num_q_vectors; i++)\n\t\tnapi_enable(&(adapter->q_vector[i]->napi));\n\n\t/* Clear any pending interrupts. */\n\trd32(E1000_TSICR);\n\trd32(E1000_ICR);\n\n\tigb_irq_enable(adapter);\n\n\t/* notify VFs that reset has been completed */\n\tif (adapter->vfs_allocated_count) {\n\t\tu32 reg_data = rd32(E1000_CTRL_EXT);\n\n\t\treg_data |= E1000_CTRL_EXT_PFRSTD;\n\t\twr32(E1000_CTRL_EXT, reg_data);\n\t}\n\n\tnetif_tx_start_all_queues(netdev);\n\n\tif (!resuming)\n\t\tpm_runtime_put(&pdev->dev);\n\n\t/* start the watchdog. */\n\thw->mac.get_link_status = 1;\n\tschedule_work(&adapter->watchdog_task);\n\n\treturn 0;\n\nerr_set_queues:\n\tigb_free_irq(adapter);\nerr_req_irq:\n\tigb_release_hw_control(adapter);\n\tigb_power_down_link(adapter);\n\tigb_free_all_rx_resources(adapter);\nerr_setup_rx:\n\tigb_free_all_tx_resources(adapter);\nerr_setup_tx:\n\tigb_reset(adapter);\n\tif (!resuming)\n\t\tpm_runtime_put(&pdev->dev);\n\n\treturn err;\n}\n\nint igb_open(struct net_device *netdev)\n{\n\treturn __igb_open(netdev, false);\n}\n\n/**\n *  igb_close - Disables a network interface\n *  @netdev: network interface device structure\n *  @suspending: indicates we are in a suspend call\n *\n *  Returns 0, this is not allowed to fail\n *\n *  The close entry point is called when an interface is de-activated\n *  by the OS.  The hardware is still under the driver's control, but\n *  needs to be disabled.  A global MAC reset is issued to stop the\n *  hardware, and all transmit and receive resources are freed.\n **/\nstatic int __igb_close(struct net_device *netdev, bool suspending)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tWARN_ON(test_bit(__IGB_RESETTING, &adapter->state));\n\n\tif (!suspending)\n\t\tpm_runtime_get_sync(&pdev->dev);\n\n\tigb_down(adapter);\n\tigb_free_irq(adapter);\n\n\tigb_free_all_tx_resources(adapter);\n\tigb_free_all_rx_resources(adapter);\n\n\tif (!suspending)\n\t\tpm_runtime_put_sync(&pdev->dev);\n\treturn 0;\n}\n\nint igb_close(struct net_device *netdev)\n{\n\tif (netif_device_present(netdev) || netdev->dismantle)\n\t\treturn __igb_close(netdev, false);\n\treturn 0;\n}\n\n/**\n *  igb_setup_tx_resources - allocate Tx resources (Descriptors)\n *  @tx_ring: tx descriptor ring (for a specific queue) to setup\n *\n *  Return 0 on success, negative on failure\n **/\nint igb_setup_tx_resources(struct igb_ring *tx_ring)\n{\n\tstruct device *dev = tx_ring->dev;\n\tint size;\n\n\tsize = sizeof(struct igb_tx_buffer) * tx_ring->count;\n\n\ttx_ring->tx_buffer_info = vmalloc(size);\n\tif (!tx_ring->tx_buffer_info)\n\t\tgoto err;\n\n\t/* round up to nearest 4K */\n\ttx_ring->size = tx_ring->count * sizeof(union e1000_adv_tx_desc);\n\ttx_ring->size = ALIGN(tx_ring->size, 4096);\n\n\ttx_ring->desc = dma_alloc_coherent(dev, tx_ring->size,\n\t\t\t\t\t   &tx_ring->dma, GFP_KERNEL);\n\tif (!tx_ring->desc)\n\t\tgoto err;\n\n\ttx_ring->next_to_use = 0;\n\ttx_ring->next_to_clean = 0;\n\n\treturn 0;\n\nerr:\n\tvfree(tx_ring->tx_buffer_info);\n\ttx_ring->tx_buffer_info = NULL;\n\tdev_err(dev, \"Unable to allocate memory for the Tx descriptor ring\\n\");\n\treturn -ENOMEM;\n}\n\n/**\n *  igb_setup_all_tx_resources - wrapper to allocate Tx resources\n *\t\t\t\t (Descriptors) for all queues\n *  @adapter: board private structure\n *\n *  Return 0 on success, negative on failure\n **/\nstatic int igb_setup_all_tx_resources(struct igb_adapter *adapter)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint i, err = 0;\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\terr = igb_setup_tx_resources(adapter->tx_ring[i]);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Allocation for Tx Queue %u failed\\n\", i);\n\t\t\tfor (i--; i >= 0; i--)\n\t\t\t\tigb_free_tx_resources(adapter->tx_ring[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n/**\n *  igb_setup_tctl - configure the transmit control registers\n *  @adapter: Board private structure\n **/\nvoid igb_setup_tctl(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 tctl;\n\n\t/* disable queue 0 which is enabled by default on 82575 and 82576 */\n\twr32(E1000_TXDCTL(0), 0);\n\n\t/* Program the Transmit Control Register */\n\ttctl = rd32(E1000_TCTL);\n\ttctl &= ~E1000_TCTL_CT;\n\ttctl |= E1000_TCTL_PSP | E1000_TCTL_RTLC |\n\t\t(E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT);\n\n\tigb_config_collision_dist(hw);\n\n\t/* Enable transmits */\n\ttctl |= E1000_TCTL_EN;\n\n\twr32(E1000_TCTL, tctl);\n}\n\n/**\n *  igb_configure_tx_ring - Configure transmit ring after Reset\n *  @adapter: board private structure\n *  @ring: tx ring to configure\n *\n *  Configure a transmit ring after a reset.\n **/\nvoid igb_configure_tx_ring(struct igb_adapter *adapter,\n\t\t\t   struct igb_ring *ring)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 txdctl = 0;\n\tu64 tdba = ring->dma;\n\tint reg_idx = ring->reg_idx;\n\n\twr32(E1000_TDLEN(reg_idx),\n\t     ring->count * sizeof(union e1000_adv_tx_desc));\n\twr32(E1000_TDBAL(reg_idx),\n\t     tdba & 0x00000000ffffffffULL);\n\twr32(E1000_TDBAH(reg_idx), tdba >> 32);\n\n\tring->tail = adapter->io_addr + E1000_TDT(reg_idx);\n\twr32(E1000_TDH(reg_idx), 0);\n\twritel(0, ring->tail);\n\n\ttxdctl |= IGB_TX_PTHRESH;\n\ttxdctl |= IGB_TX_HTHRESH << 8;\n\ttxdctl |= IGB_TX_WTHRESH << 16;\n\n\t/* reinitialize tx_buffer_info */\n\tmemset(ring->tx_buffer_info, 0,\n\t       sizeof(struct igb_tx_buffer) * ring->count);\n\n\ttxdctl |= E1000_TXDCTL_QUEUE_ENABLE;\n\twr32(E1000_TXDCTL(reg_idx), txdctl);\n}\n\n/**\n *  igb_configure_tx - Configure transmit Unit after Reset\n *  @adapter: board private structure\n *\n *  Configure the Tx unit of the MAC after a reset.\n **/\nstatic void igb_configure_tx(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint i;\n\n\t/* disable the queues */\n\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\twr32(E1000_TXDCTL(adapter->tx_ring[i]->reg_idx), 0);\n\n\twrfl();\n\tusleep_range(10000, 20000);\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\tigb_configure_tx_ring(adapter, adapter->tx_ring[i]);\n}\n\n/**\n *  igb_setup_rx_resources - allocate Rx resources (Descriptors)\n *  @rx_ring: Rx descriptor ring (for a specific queue) to setup\n *\n *  Returns 0 on success, negative on failure\n **/\nint igb_setup_rx_resources(struct igb_ring *rx_ring)\n{\n\tstruct igb_adapter *adapter = netdev_priv(rx_ring->netdev);\n\tstruct device *dev = rx_ring->dev;\n\tint size;\n\n\tsize = sizeof(struct igb_rx_buffer) * rx_ring->count;\n\n\trx_ring->rx_buffer_info = vmalloc(size);\n\tif (!rx_ring->rx_buffer_info)\n\t\tgoto err;\n\n\t/* Round up to nearest 4K */\n\trx_ring->size = rx_ring->count * sizeof(union e1000_adv_rx_desc);\n\trx_ring->size = ALIGN(rx_ring->size, 4096);\n\n\trx_ring->desc = dma_alloc_coherent(dev, rx_ring->size,\n\t\t\t\t\t   &rx_ring->dma, GFP_KERNEL);\n\tif (!rx_ring->desc)\n\t\tgoto err;\n\n\trx_ring->next_to_alloc = 0;\n\trx_ring->next_to_clean = 0;\n\trx_ring->next_to_use = 0;\n\n\trx_ring->xdp_prog = adapter->xdp_prog;\n\n\t/* XDP RX-queue info */\n\tif (xdp_rxq_info_reg(&rx_ring->xdp_rxq, rx_ring->netdev,\n\t\t\t     rx_ring->queue_index, 0) < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tvfree(rx_ring->rx_buffer_info);\n\trx_ring->rx_buffer_info = NULL;\n\tdev_err(dev, \"Unable to allocate memory for the Rx descriptor ring\\n\");\n\treturn -ENOMEM;\n}\n\n/**\n *  igb_setup_all_rx_resources - wrapper to allocate Rx resources\n *\t\t\t\t (Descriptors) for all queues\n *  @adapter: board private structure\n *\n *  Return 0 on success, negative on failure\n **/\nstatic int igb_setup_all_rx_resources(struct igb_adapter *adapter)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint i, err = 0;\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\terr = igb_setup_rx_resources(adapter->rx_ring[i]);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Allocation for Rx Queue %u failed\\n\", i);\n\t\t\tfor (i--; i >= 0; i--)\n\t\t\t\tigb_free_rx_resources(adapter->rx_ring[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n/**\n *  igb_setup_mrqc - configure the multiple receive queue control registers\n *  @adapter: Board private structure\n **/\nstatic void igb_setup_mrqc(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 mrqc, rxcsum;\n\tu32 j, num_rx_queues;\n\tu32 rss_key[10];\n\n\tnetdev_rss_key_fill(rss_key, sizeof(rss_key));\n\tfor (j = 0; j < 10; j++)\n\t\twr32(E1000_RSSRK(j), rss_key[j]);\n\n\tnum_rx_queues = adapter->rss_queues;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_82576:\n\t\t/* 82576 supports 2 RSS queues for SR-IOV */\n\t\tif (adapter->vfs_allocated_count)\n\t\t\tnum_rx_queues = 2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (adapter->rss_indir_tbl_init != num_rx_queues) {\n\t\tfor (j = 0; j < IGB_RETA_SIZE; j++)\n\t\t\tadapter->rss_indir_tbl[j] =\n\t\t\t(j * num_rx_queues) / IGB_RETA_SIZE;\n\t\tadapter->rss_indir_tbl_init = num_rx_queues;\n\t}\n\tigb_write_rss_indir_tbl(adapter);\n\n\t/* Disable raw packet checksumming so that RSS hash is placed in\n\t * descriptor on writeback.  No need to enable TCP/UDP/IP checksum\n\t * offloads as they are enabled by default\n\t */\n\trxcsum = rd32(E1000_RXCSUM);\n\trxcsum |= E1000_RXCSUM_PCSD;\n\n\tif (adapter->hw.mac.type >= e1000_82576)\n\t\t/* Enable Receive Checksum Offload for SCTP */\n\t\trxcsum |= E1000_RXCSUM_CRCOFL;\n\n\t/* Don't need to set TUOFL or IPOFL, they default to 1 */\n\twr32(E1000_RXCSUM, rxcsum);\n\n\t/* Generate RSS hash based on packet types, TCP/UDP\n\t * port numbers and/or IPv4/v6 src and dst addresses\n\t */\n\tmrqc = E1000_MRQC_RSS_FIELD_IPV4 |\n\t       E1000_MRQC_RSS_FIELD_IPV4_TCP |\n\t       E1000_MRQC_RSS_FIELD_IPV6 |\n\t       E1000_MRQC_RSS_FIELD_IPV6_TCP |\n\t       E1000_MRQC_RSS_FIELD_IPV6_TCP_EX;\n\n\tif (adapter->flags & IGB_FLAG_RSS_FIELD_IPV4_UDP)\n\t\tmrqc |= E1000_MRQC_RSS_FIELD_IPV4_UDP;\n\tif (adapter->flags & IGB_FLAG_RSS_FIELD_IPV6_UDP)\n\t\tmrqc |= E1000_MRQC_RSS_FIELD_IPV6_UDP;\n\n\t/* If VMDq is enabled then we set the appropriate mode for that, else\n\t * we default to RSS so that an RSS hash is calculated per packet even\n\t * if we are only using one queue\n\t */\n\tif (adapter->vfs_allocated_count) {\n\t\tif (hw->mac.type > e1000_82575) {\n\t\t\t/* Set the default pool for the PF's first queue */\n\t\t\tu32 vtctl = rd32(E1000_VT_CTL);\n\n\t\t\tvtctl &= ~(E1000_VT_CTL_DEFAULT_POOL_MASK |\n\t\t\t\t   E1000_VT_CTL_DISABLE_DEF_POOL);\n\t\t\tvtctl |= adapter->vfs_allocated_count <<\n\t\t\t\tE1000_VT_CTL_DEFAULT_POOL_SHIFT;\n\t\t\twr32(E1000_VT_CTL, vtctl);\n\t\t}\n\t\tif (adapter->rss_queues > 1)\n\t\t\tmrqc |= E1000_MRQC_ENABLE_VMDQ_RSS_MQ;\n\t\telse\n\t\t\tmrqc |= E1000_MRQC_ENABLE_VMDQ;\n\t} else {\n\t\tif (hw->mac.type != e1000_i211)\n\t\t\tmrqc |= E1000_MRQC_ENABLE_RSS_MQ;\n\t}\n\tigb_vmm_control(adapter);\n\n\twr32(E1000_MRQC, mrqc);\n}\n\n/**\n *  igb_setup_rctl - configure the receive control registers\n *  @adapter: Board private structure\n **/\nvoid igb_setup_rctl(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl;\n\n\trctl = rd32(E1000_RCTL);\n\n\trctl &= ~(3 << E1000_RCTL_MO_SHIFT);\n\trctl &= ~(E1000_RCTL_LBM_TCVR | E1000_RCTL_LBM_MAC);\n\n\trctl |= E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_RDMTS_HALF |\n\t\t(hw->mac.mc_filter_type << E1000_RCTL_MO_SHIFT);\n\n\t/* enable stripping of CRC. It's unlikely this will break BMC\n\t * redirection as it did with e1000. Newer features require\n\t * that the HW strips the CRC.\n\t */\n\trctl |= E1000_RCTL_SECRC;\n\n\t/* disable store bad packets and clear size bits. */\n\trctl &= ~(E1000_RCTL_SBP | E1000_RCTL_SZ_256);\n\n\t/* enable LPE to allow for reception of jumbo frames */\n\trctl |= E1000_RCTL_LPE;\n\n\t/* disable queue 0 to prevent tail write w/o re-config */\n\twr32(E1000_RXDCTL(0), 0);\n\n\t/* Attention!!!  For SR-IOV PF driver operations you must enable\n\t * queue drop for all VF and PF queues to prevent head of line blocking\n\t * if an un-trusted VF does not provide descriptors to hardware.\n\t */\n\tif (adapter->vfs_allocated_count) {\n\t\t/* set all queue drop enable bits */\n\t\twr32(E1000_QDE, ALL_QUEUES);\n\t}\n\n\t/* This is useful for sniffing bad packets. */\n\tif (adapter->netdev->features & NETIF_F_RXALL) {\n\t\t/* UPE and MPE will be handled by normal PROMISC logic\n\t\t * in e1000e_set_rx_mode\n\t\t */\n\t\trctl |= (E1000_RCTL_SBP | /* Receive bad packets */\n\t\t\t E1000_RCTL_BAM | /* RX All Bcast Pkts */\n\t\t\t E1000_RCTL_PMCF); /* RX All MAC Ctrl Pkts */\n\n\t\trctl &= ~(E1000_RCTL_DPF | /* Allow filtered pause */\n\t\t\t  E1000_RCTL_CFIEN); /* Dis VLAN CFIEN Filter */\n\t\t/* Do not mess with E1000_CTRL_VME, it affects transmit as well,\n\t\t * and that breaks VLANs.\n\t\t */\n\t}\n\n\twr32(E1000_RCTL, rctl);\n}\n\nstatic inline int igb_set_vf_rlpml(struct igb_adapter *adapter, int size,\n\t\t\t\t   int vfn)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 vmolr;\n\n\tif (size > MAX_JUMBO_FRAME_SIZE)\n\t\tsize = MAX_JUMBO_FRAME_SIZE;\n\n\tvmolr = rd32(E1000_VMOLR(vfn));\n\tvmolr &= ~E1000_VMOLR_RLPML_MASK;\n\tvmolr |= size | E1000_VMOLR_LPE;\n\twr32(E1000_VMOLR(vfn), vmolr);\n\n\treturn 0;\n}\n\nstatic inline void igb_set_vf_vlan_strip(struct igb_adapter *adapter,\n\t\t\t\t\t int vfn, bool enable)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 val, reg;\n\n\tif (hw->mac.type < e1000_82576)\n\t\treturn;\n\n\tif (hw->mac.type == e1000_i350)\n\t\treg = E1000_DVMOLR(vfn);\n\telse\n\t\treg = E1000_VMOLR(vfn);\n\n\tval = rd32(reg);\n\tif (enable)\n\t\tval |= E1000_VMOLR_STRVLAN;\n\telse\n\t\tval &= ~(E1000_VMOLR_STRVLAN);\n\twr32(reg, val);\n}\n\nstatic inline void igb_set_vmolr(struct igb_adapter *adapter,\n\t\t\t\t int vfn, bool aupe)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 vmolr;\n\n\t/* This register exists only on 82576 and newer so if we are older then\n\t * we should exit and do nothing\n\t */\n\tif (hw->mac.type < e1000_82576)\n\t\treturn;\n\n\tvmolr = rd32(E1000_VMOLR(vfn));\n\tif (aupe)\n\t\tvmolr |= E1000_VMOLR_AUPE; /* Accept untagged packets */\n\telse\n\t\tvmolr &= ~(E1000_VMOLR_AUPE); /* Tagged packets ONLY */\n\n\t/* clear all bits that might not be set */\n\tvmolr &= ~(E1000_VMOLR_BAM | E1000_VMOLR_RSSE);\n\n\tif (adapter->rss_queues > 1 && vfn == adapter->vfs_allocated_count)\n\t\tvmolr |= E1000_VMOLR_RSSE; /* enable RSS */\n\t/* for VMDq only allow the VFs and pool 0 to accept broadcast and\n\t * multicast packets\n\t */\n\tif (vfn <= adapter->vfs_allocated_count)\n\t\tvmolr |= E1000_VMOLR_BAM; /* Accept broadcast */\n\n\twr32(E1000_VMOLR(vfn), vmolr);\n}\n\n/**\n *  igb_setup_srrctl - configure the split and replication receive control\n *                     registers\n *  @adapter: Board private structure\n *  @ring: receive ring to be configured\n **/\nvoid igb_setup_srrctl(struct igb_adapter *adapter, struct igb_ring *ring)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint reg_idx = ring->reg_idx;\n\tu32 srrctl = 0;\n\n\tsrrctl = IGB_RX_HDR_LEN << E1000_SRRCTL_BSIZEHDRSIZE_SHIFT;\n\tif (ring_uses_large_buffer(ring))\n\t\tsrrctl |= IGB_RXBUFFER_3072 >> E1000_SRRCTL_BSIZEPKT_SHIFT;\n\telse\n\t\tsrrctl |= IGB_RXBUFFER_2048 >> E1000_SRRCTL_BSIZEPKT_SHIFT;\n\tsrrctl |= E1000_SRRCTL_DESCTYPE_ADV_ONEBUF;\n\tif (hw->mac.type >= e1000_82580)\n\t\tsrrctl |= E1000_SRRCTL_TIMESTAMP;\n\t/* Only set Drop Enable if VFs allocated, or we are supporting multiple\n\t * queues and rx flow control is disabled\n\t */\n\tif (adapter->vfs_allocated_count ||\n\t    (!(hw->fc.current_mode & e1000_fc_rx_pause) &&\n\t     adapter->num_rx_queues > 1))\n\t\tsrrctl |= E1000_SRRCTL_DROP_EN;\n\n\twr32(E1000_SRRCTL(reg_idx), srrctl);\n}\n\n/**\n *  igb_configure_rx_ring - Configure a receive ring after Reset\n *  @adapter: board private structure\n *  @ring: receive ring to be configured\n *\n *  Configure the Rx unit of the MAC after a reset.\n **/\nvoid igb_configure_rx_ring(struct igb_adapter *adapter,\n\t\t\t   struct igb_ring *ring)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunion e1000_adv_rx_desc *rx_desc;\n\tu64 rdba = ring->dma;\n\tint reg_idx = ring->reg_idx;\n\tu32 rxdctl = 0;\n\n\txdp_rxq_info_unreg_mem_model(&ring->xdp_rxq);\n\tWARN_ON(xdp_rxq_info_reg_mem_model(&ring->xdp_rxq,\n\t\t\t\t\t   MEM_TYPE_PAGE_SHARED, NULL));\n\n\t/* disable the queue */\n\twr32(E1000_RXDCTL(reg_idx), 0);\n\n\t/* Set DMA base address registers */\n\twr32(E1000_RDBAL(reg_idx),\n\t     rdba & 0x00000000ffffffffULL);\n\twr32(E1000_RDBAH(reg_idx), rdba >> 32);\n\twr32(E1000_RDLEN(reg_idx),\n\t     ring->count * sizeof(union e1000_adv_rx_desc));\n\n\t/* initialize head and tail */\n\tring->tail = adapter->io_addr + E1000_RDT(reg_idx);\n\twr32(E1000_RDH(reg_idx), 0);\n\twritel(0, ring->tail);\n\n\t/* set descriptor configuration */\n\tigb_setup_srrctl(adapter, ring);\n\n\t/* set filtering for VMDQ pools */\n\tigb_set_vmolr(adapter, reg_idx & 0x7, true);\n\n\trxdctl |= IGB_RX_PTHRESH;\n\trxdctl |= IGB_RX_HTHRESH << 8;\n\trxdctl |= IGB_RX_WTHRESH << 16;\n\n\t/* initialize rx_buffer_info */\n\tmemset(ring->rx_buffer_info, 0,\n\t       sizeof(struct igb_rx_buffer) * ring->count);\n\n\t/* initialize Rx descriptor 0 */\n\trx_desc = IGB_RX_DESC(ring, 0);\n\trx_desc->wb.upper.length = 0;\n\n\t/* enable receive descriptor fetching */\n\trxdctl |= E1000_RXDCTL_QUEUE_ENABLE;\n\twr32(E1000_RXDCTL(reg_idx), rxdctl);\n}\n\nstatic void igb_set_rx_buffer_len(struct igb_adapter *adapter,\n\t\t\t\t  struct igb_ring *rx_ring)\n{\n\t/* set build_skb and buffer size flags */\n\tclear_ring_build_skb_enabled(rx_ring);\n\tclear_ring_uses_large_buffer(rx_ring);\n\n\tif (adapter->flags & IGB_FLAG_RX_LEGACY)\n\t\treturn;\n\n\tset_ring_build_skb_enabled(rx_ring);\n\n#if (PAGE_SIZE < 8192)\n\tif (adapter->max_frame_size <= IGB_MAX_FRAME_BUILD_SKB)\n\t\treturn;\n\n\tset_ring_uses_large_buffer(rx_ring);\n#endif\n}\n\n/**\n *  igb_configure_rx - Configure receive Unit after Reset\n *  @adapter: board private structure\n *\n *  Configure the Rx unit of the MAC after a reset.\n **/\nstatic void igb_configure_rx(struct igb_adapter *adapter)\n{\n\tint i;\n\n\t/* set the correct pool for the PF default MAC address in entry 0 */\n\tigb_set_default_mac_filter(adapter);\n\n\t/* Setup the HW Rx Head and Tail Descriptor Pointers and\n\t * the Base and Length of the Rx Descriptor Ring\n\t */\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\tstruct igb_ring *rx_ring = adapter->rx_ring[i];\n\n\t\tigb_set_rx_buffer_len(adapter, rx_ring);\n\t\tigb_configure_rx_ring(adapter, rx_ring);\n\t}\n}\n\n/**\n *  igb_free_tx_resources - Free Tx Resources per Queue\n *  @tx_ring: Tx descriptor ring for a specific queue\n *\n *  Free all transmit software resources\n **/\nvoid igb_free_tx_resources(struct igb_ring *tx_ring)\n{\n\tigb_clean_tx_ring(tx_ring);\n\n\tvfree(tx_ring->tx_buffer_info);\n\ttx_ring->tx_buffer_info = NULL;\n\n\t/* if not set, then don't free */\n\tif (!tx_ring->desc)\n\t\treturn;\n\n\tdma_free_coherent(tx_ring->dev, tx_ring->size,\n\t\t\t  tx_ring->desc, tx_ring->dma);\n\n\ttx_ring->desc = NULL;\n}\n\n/**\n *  igb_free_all_tx_resources - Free Tx Resources for All Queues\n *  @adapter: board private structure\n *\n *  Free all transmit software resources\n **/\nstatic void igb_free_all_tx_resources(struct igb_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\tif (adapter->tx_ring[i])\n\t\t\tigb_free_tx_resources(adapter->tx_ring[i]);\n}\n\n/**\n *  igb_clean_tx_ring - Free Tx Buffers\n *  @tx_ring: ring to be cleaned\n **/\nstatic void igb_clean_tx_ring(struct igb_ring *tx_ring)\n{\n\tu16 i = tx_ring->next_to_clean;\n\tstruct igb_tx_buffer *tx_buffer = &tx_ring->tx_buffer_info[i];\n\n\twhile (i != tx_ring->next_to_use) {\n\t\tunion e1000_adv_tx_desc *eop_desc, *tx_desc;\n\n\t\t/* Free all the Tx ring sk_buffs */\n\t\tdev_kfree_skb_any(tx_buffer->skb);\n\n\t\t/* unmap skb header data */\n\t\tdma_unmap_single(tx_ring->dev,\n\t\t\t\t dma_unmap_addr(tx_buffer, dma),\n\t\t\t\t dma_unmap_len(tx_buffer, len),\n\t\t\t\t DMA_TO_DEVICE);\n\n\t\t/* check for eop_desc to determine the end of the packet */\n\t\teop_desc = tx_buffer->next_to_watch;\n\t\ttx_desc = IGB_TX_DESC(tx_ring, i);\n\n\t\t/* unmap remaining buffers */\n\t\twhile (tx_desc != eop_desc) {\n\t\t\ttx_buffer++;\n\t\t\ttx_desc++;\n\t\t\ti++;\n\t\t\tif (unlikely(i == tx_ring->count)) {\n\t\t\t\ti = 0;\n\t\t\t\ttx_buffer = tx_ring->tx_buffer_info;\n\t\t\t\ttx_desc = IGB_TX_DESC(tx_ring, 0);\n\t\t\t}\n\n\t\t\t/* unmap any remaining paged data */\n\t\t\tif (dma_unmap_len(tx_buffer, len))\n\t\t\t\tdma_unmap_page(tx_ring->dev,\n\t\t\t\t\t       dma_unmap_addr(tx_buffer, dma),\n\t\t\t\t\t       dma_unmap_len(tx_buffer, len),\n\t\t\t\t\t       DMA_TO_DEVICE);\n\t\t}\n\n\t\t/* move us one more past the eop_desc for start of next pkt */\n\t\ttx_buffer++;\n\t\ti++;\n\t\tif (unlikely(i == tx_ring->count)) {\n\t\t\ti = 0;\n\t\t\ttx_buffer = tx_ring->tx_buffer_info;\n\t\t}\n\t}\n\n\t/* reset BQL for queue */\n\tnetdev_tx_reset_queue(txring_txq(tx_ring));\n\n\t/* reset next_to_use and next_to_clean */\n\ttx_ring->next_to_use = 0;\n\ttx_ring->next_to_clean = 0;\n}\n\n/**\n *  igb_clean_all_tx_rings - Free Tx Buffers for all queues\n *  @adapter: board private structure\n **/\nstatic void igb_clean_all_tx_rings(struct igb_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\tif (adapter->tx_ring[i])\n\t\t\tigb_clean_tx_ring(adapter->tx_ring[i]);\n}\n\n/**\n *  igb_free_rx_resources - Free Rx Resources\n *  @rx_ring: ring to clean the resources from\n *\n *  Free all receive software resources\n **/\nvoid igb_free_rx_resources(struct igb_ring *rx_ring)\n{\n\tigb_clean_rx_ring(rx_ring);\n\n\trx_ring->xdp_prog = NULL;\n\txdp_rxq_info_unreg(&rx_ring->xdp_rxq);\n\tvfree(rx_ring->rx_buffer_info);\n\trx_ring->rx_buffer_info = NULL;\n\n\t/* if not set, then don't free */\n\tif (!rx_ring->desc)\n\t\treturn;\n\n\tdma_free_coherent(rx_ring->dev, rx_ring->size,\n\t\t\t  rx_ring->desc, rx_ring->dma);\n\n\trx_ring->desc = NULL;\n}\n\n/**\n *  igb_free_all_rx_resources - Free Rx Resources for All Queues\n *  @adapter: board private structure\n *\n *  Free all receive software resources\n **/\nstatic void igb_free_all_rx_resources(struct igb_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\tif (adapter->rx_ring[i])\n\t\t\tigb_free_rx_resources(adapter->rx_ring[i]);\n}\n\n/**\n *  igb_clean_rx_ring - Free Rx Buffers per Queue\n *  @rx_ring: ring to free buffers from\n **/\nstatic void igb_clean_rx_ring(struct igb_ring *rx_ring)\n{\n\tu16 i = rx_ring->next_to_clean;\n\n\tdev_kfree_skb(rx_ring->skb);\n\trx_ring->skb = NULL;\n\n\t/* Free all the Rx ring sk_buffs */\n\twhile (i != rx_ring->next_to_alloc) {\n\t\tstruct igb_rx_buffer *buffer_info = &rx_ring->rx_buffer_info[i];\n\n\t\t/* Invalidate cache lines that may have been written to by\n\t\t * device so that we avoid corrupting memory.\n\t\t */\n\t\tdma_sync_single_range_for_cpu(rx_ring->dev,\n\t\t\t\t\t      buffer_info->dma,\n\t\t\t\t\t      buffer_info->page_offset,\n\t\t\t\t\t      igb_rx_bufsz(rx_ring),\n\t\t\t\t\t      DMA_FROM_DEVICE);\n\n\t\t/* free resources associated with mapping */\n\t\tdma_unmap_page_attrs(rx_ring->dev,\n\t\t\t\t     buffer_info->dma,\n\t\t\t\t     igb_rx_pg_size(rx_ring),\n\t\t\t\t     DMA_FROM_DEVICE,\n\t\t\t\t     IGB_RX_DMA_ATTR);\n\t\t__page_frag_cache_drain(buffer_info->page,\n\t\t\t\t\tbuffer_info->pagecnt_bias);\n\n\t\ti++;\n\t\tif (i == rx_ring->count)\n\t\t\ti = 0;\n\t}\n\n\trx_ring->next_to_alloc = 0;\n\trx_ring->next_to_clean = 0;\n\trx_ring->next_to_use = 0;\n}\n\n/**\n *  igb_clean_all_rx_rings - Free Rx Buffers for all queues\n *  @adapter: board private structure\n **/\nstatic void igb_clean_all_rx_rings(struct igb_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\tif (adapter->rx_ring[i])\n\t\t\tigb_clean_rx_ring(adapter->rx_ring[i]);\n}\n\n/**\n *  igb_set_mac - Change the Ethernet Address of the NIC\n *  @netdev: network interface device structure\n *  @p: pointer to an address structure\n *\n *  Returns 0 on success, negative on failure\n **/\nstatic int igb_set_mac(struct net_device *netdev, void *p)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\n\tmemcpy(hw->mac.addr, addr->sa_data, netdev->addr_len);\n\n\t/* set the correct pool for the new PF MAC address in entry 0 */\n\tigb_set_default_mac_filter(adapter);\n\n\treturn 0;\n}\n\n/**\n *  igb_write_mc_addr_list - write multicast addresses to MTA\n *  @netdev: network interface device structure\n *\n *  Writes multicast address list to the MTA hash table.\n *  Returns: -ENOMEM on failure\n *           0 on no addresses written\n *           X on writing X addresses to MTA\n **/\nstatic int igb_write_mc_addr_list(struct net_device *netdev)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct netdev_hw_addr *ha;\n\tu8  *mta_list;\n\tint i;\n\n\tif (netdev_mc_empty(netdev)) {\n\t\t/* nothing to program, so clear mc list */\n\t\tigb_update_mc_addr_list(hw, NULL, 0);\n\t\tigb_restore_vf_multicasts(adapter);\n\t\treturn 0;\n\t}\n\n\tmta_list = kcalloc(netdev_mc_count(netdev), 6, GFP_ATOMIC);\n\tif (!mta_list)\n\t\treturn -ENOMEM;\n\n\t/* The shared function expects a packed array of only addresses. */\n\ti = 0;\n\tnetdev_for_each_mc_addr(ha, netdev)\n\t\tmemcpy(mta_list + (i++ * ETH_ALEN), ha->addr, ETH_ALEN);\n\n\tigb_update_mc_addr_list(hw, mta_list, i);\n\tkfree(mta_list);\n\n\treturn netdev_mc_count(netdev);\n}\n\nstatic int igb_vlan_promisc_enable(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 i, pf_id;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_i210:\n\tcase e1000_i211:\n\tcase e1000_i350:\n\t\t/* VLAN filtering needed for VLAN prio filter */\n\t\tif (adapter->netdev->features & NETIF_F_NTUPLE)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase e1000_82576:\n\tcase e1000_82580:\n\tcase e1000_i354:\n\t\t/* VLAN filtering needed for pool filtering */\n\t\tif (adapter->vfs_allocated_count)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\t/* We are already in VLAN promisc, nothing to do */\n\tif (adapter->flags & IGB_FLAG_VLAN_PROMISC)\n\t\treturn 0;\n\n\tif (!adapter->vfs_allocated_count)\n\t\tgoto set_vfta;\n\n\t/* Add PF to all active pools */\n\tpf_id = adapter->vfs_allocated_count + E1000_VLVF_POOLSEL_SHIFT;\n\n\tfor (i = E1000_VLVF_ARRAY_SIZE; --i;) {\n\t\tu32 vlvf = rd32(E1000_VLVF(i));\n\n\t\tvlvf |= BIT(pf_id);\n\t\twr32(E1000_VLVF(i), vlvf);\n\t}\n\nset_vfta:\n\t/* Set all bits in the VLAN filter table array */\n\tfor (i = E1000_VLAN_FILTER_TBL_SIZE; i--;)\n\t\thw->mac.ops.write_vfta(hw, i, ~0U);\n\n\t/* Set flag so we don't redo unnecessary work */\n\tadapter->flags |= IGB_FLAG_VLAN_PROMISC;\n\n\treturn 0;\n}\n\n#define VFTA_BLOCK_SIZE 8\nstatic void igb_scrub_vfta(struct igb_adapter *adapter, u32 vfta_offset)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 vfta[VFTA_BLOCK_SIZE] = { 0 };\n\tu32 vid_start = vfta_offset * 32;\n\tu32 vid_end = vid_start + (VFTA_BLOCK_SIZE * 32);\n\tu32 i, vid, word, bits, pf_id;\n\n\t/* guarantee that we don't scrub out management VLAN */\n\tvid = adapter->mng_vlan_id;\n\tif (vid >= vid_start && vid < vid_end)\n\t\tvfta[(vid - vid_start) / 32] |= BIT(vid % 32);\n\n\tif (!adapter->vfs_allocated_count)\n\t\tgoto set_vfta;\n\n\tpf_id = adapter->vfs_allocated_count + E1000_VLVF_POOLSEL_SHIFT;\n\n\tfor (i = E1000_VLVF_ARRAY_SIZE; --i;) {\n\t\tu32 vlvf = rd32(E1000_VLVF(i));\n\n\t\t/* pull VLAN ID from VLVF */\n\t\tvid = vlvf & VLAN_VID_MASK;\n\n\t\t/* only concern ourselves with a certain range */\n\t\tif (vid < vid_start || vid >= vid_end)\n\t\t\tcontinue;\n\n\t\tif (vlvf & E1000_VLVF_VLANID_ENABLE) {\n\t\t\t/* record VLAN ID in VFTA */\n\t\t\tvfta[(vid - vid_start) / 32] |= BIT(vid % 32);\n\n\t\t\t/* if PF is part of this then continue */\n\t\t\tif (test_bit(vid, adapter->active_vlans))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* remove PF from the pool */\n\t\tbits = ~BIT(pf_id);\n\t\tbits &= rd32(E1000_VLVF(i));\n\t\twr32(E1000_VLVF(i), bits);\n\t}\n\nset_vfta:\n\t/* extract values from active_vlans and write back to VFTA */\n\tfor (i = VFTA_BLOCK_SIZE; i--;) {\n\t\tvid = (vfta_offset + i) * 32;\n\t\tword = vid / BITS_PER_LONG;\n\t\tbits = vid % BITS_PER_LONG;\n\n\t\tvfta[i] |= adapter->active_vlans[word] >> bits;\n\n\t\thw->mac.ops.write_vfta(hw, vfta_offset + i, vfta[i]);\n\t}\n}\n\nstatic void igb_vlan_promisc_disable(struct igb_adapter *adapter)\n{\n\tu32 i;\n\n\t/* We are not in VLAN promisc, nothing to do */\n\tif (!(adapter->flags & IGB_FLAG_VLAN_PROMISC))\n\t\treturn;\n\n\t/* Set flag so we don't redo unnecessary work */\n\tadapter->flags &= ~IGB_FLAG_VLAN_PROMISC;\n\n\tfor (i = 0; i < E1000_VLAN_FILTER_TBL_SIZE; i += VFTA_BLOCK_SIZE)\n\t\tigb_scrub_vfta(adapter, i);\n}\n\n/**\n *  igb_set_rx_mode - Secondary Unicast, Multicast and Promiscuous mode set\n *  @netdev: network interface device structure\n *\n *  The set_rx_mode entry point is called whenever the unicast or multicast\n *  address lists or the network interface flags are updated.  This routine is\n *  responsible for configuring the hardware for proper unicast, multicast,\n *  promiscuous mode, and all-multi behavior.\n **/\nstatic void igb_set_rx_mode(struct net_device *netdev)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunsigned int vfn = adapter->vfs_allocated_count;\n\tu32 rctl = 0, vmolr = 0, rlpml = MAX_JUMBO_FRAME_SIZE;\n\tint count;\n\n\t/* Check for Promiscuous and All Multicast modes */\n\tif (netdev->flags & IFF_PROMISC) {\n\t\trctl |= E1000_RCTL_UPE | E1000_RCTL_MPE;\n\t\tvmolr |= E1000_VMOLR_MPME;\n\n\t\t/* enable use of UTA filter to force packets to default pool */\n\t\tif (hw->mac.type == e1000_82576)\n\t\t\tvmolr |= E1000_VMOLR_ROPE;\n\t} else {\n\t\tif (netdev->flags & IFF_ALLMULTI) {\n\t\t\trctl |= E1000_RCTL_MPE;\n\t\t\tvmolr |= E1000_VMOLR_MPME;\n\t\t} else {\n\t\t\t/* Write addresses to the MTA, if the attempt fails\n\t\t\t * then we should just turn on promiscuous mode so\n\t\t\t * that we can at least receive multicast traffic\n\t\t\t */\n\t\t\tcount = igb_write_mc_addr_list(netdev);\n\t\t\tif (count < 0) {\n\t\t\t\trctl |= E1000_RCTL_MPE;\n\t\t\t\tvmolr |= E1000_VMOLR_MPME;\n\t\t\t} else if (count) {\n\t\t\t\tvmolr |= E1000_VMOLR_ROMPE;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Write addresses to available RAR registers, if there is not\n\t * sufficient space to store all the addresses then enable\n\t * unicast promiscuous mode\n\t */\n\tif (__dev_uc_sync(netdev, igb_uc_sync, igb_uc_unsync)) {\n\t\trctl |= E1000_RCTL_UPE;\n\t\tvmolr |= E1000_VMOLR_ROPE;\n\t}\n\n\t/* enable VLAN filtering by default */\n\trctl |= E1000_RCTL_VFE;\n\n\t/* disable VLAN filtering for modes that require it */\n\tif ((netdev->flags & IFF_PROMISC) ||\n\t    (netdev->features & NETIF_F_RXALL)) {\n\t\t/* if we fail to set all rules then just clear VFE */\n\t\tif (igb_vlan_promisc_enable(adapter))\n\t\t\trctl &= ~E1000_RCTL_VFE;\n\t} else {\n\t\tigb_vlan_promisc_disable(adapter);\n\t}\n\n\t/* update state of unicast, multicast, and VLAN filtering modes */\n\trctl |= rd32(E1000_RCTL) & ~(E1000_RCTL_UPE | E1000_RCTL_MPE |\n\t\t\t\t     E1000_RCTL_VFE);\n\twr32(E1000_RCTL, rctl);\n\n#if (PAGE_SIZE < 8192)\n\tif (!adapter->vfs_allocated_count) {\n\t\tif (adapter->max_frame_size <= IGB_MAX_FRAME_BUILD_SKB)\n\t\t\trlpml = IGB_MAX_FRAME_BUILD_SKB;\n\t}\n#endif\n\twr32(E1000_RLPML, rlpml);\n\n\t/* In order to support SR-IOV and eventually VMDq it is necessary to set\n\t * the VMOLR to enable the appropriate modes.  Without this workaround\n\t * we will have issues with VLAN tag stripping not being done for frames\n\t * that are only arriving because we are the default pool\n\t */\n\tif ((hw->mac.type < e1000_82576) || (hw->mac.type > e1000_i350))\n\t\treturn;\n\n\t/* set UTA to appropriate mode */\n\tigb_set_uta(adapter, !!(vmolr & E1000_VMOLR_ROPE));\n\n\tvmolr |= rd32(E1000_VMOLR(vfn)) &\n\t\t ~(E1000_VMOLR_ROPE | E1000_VMOLR_MPME | E1000_VMOLR_ROMPE);\n\n\t/* enable Rx jumbo frames, restrict as needed to support build_skb */\n\tvmolr &= ~E1000_VMOLR_RLPML_MASK;\n#if (PAGE_SIZE < 8192)\n\tif (adapter->max_frame_size <= IGB_MAX_FRAME_BUILD_SKB)\n\t\tvmolr |= IGB_MAX_FRAME_BUILD_SKB;\n\telse\n#endif\n\t\tvmolr |= MAX_JUMBO_FRAME_SIZE;\n\tvmolr |= E1000_VMOLR_LPE;\n\n\twr32(E1000_VMOLR(vfn), vmolr);\n\n\tigb_restore_vf_multicasts(adapter);\n}\n\nstatic void igb_check_wvbr(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 wvbr = 0;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_82576:\n\tcase e1000_i350:\n\t\twvbr = rd32(E1000_WVBR);\n\t\tif (!wvbr)\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tadapter->wvbr |= wvbr;\n}\n\n#define IGB_STAGGERED_QUEUE_OFFSET 8\n\nstatic void igb_spoof_check(struct igb_adapter *adapter)\n{\n\tint j;\n\n\tif (!adapter->wvbr)\n\t\treturn;\n\n\tfor (j = 0; j < adapter->vfs_allocated_count; j++) {\n\t\tif (adapter->wvbr & BIT(j) ||\n\t\t    adapter->wvbr & BIT(j + IGB_STAGGERED_QUEUE_OFFSET)) {\n\t\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t\t\"Spoof event(s) detected on VF %d\\n\", j);\n\t\t\tadapter->wvbr &=\n\t\t\t\t~(BIT(j) |\n\t\t\t\t  BIT(j + IGB_STAGGERED_QUEUE_OFFSET));\n\t\t}\n\t}\n}\n\n/* Need to wait a few seconds after link up to get diagnostic information from\n * the phy\n */\nstatic void igb_update_phy_info(struct timer_list *t)\n{\n\tstruct igb_adapter *adapter = from_timer(adapter, t, phy_info_timer);\n\tigb_get_phy_info(&adapter->hw);\n}\n\n/**\n *  igb_has_link - check shared code for link and determine up/down\n *  @adapter: pointer to driver private info\n **/\nbool igb_has_link(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tbool link_active = false;\n\n\t/* get_link_status is set on LSC (link status) interrupt or\n\t * rx sequence error interrupt.  get_link_status will stay\n\t * false until the e1000_check_for_link establishes link\n\t * for copper adapters ONLY\n\t */\n\tswitch (hw->phy.media_type) {\n\tcase e1000_media_type_copper:\n\t\tif (!hw->mac.get_link_status)\n\t\t\treturn true;\n\t\tfallthrough;\n\tcase e1000_media_type_internal_serdes:\n\t\thw->mac.ops.check_for_link(hw);\n\t\tlink_active = !hw->mac.get_link_status;\n\t\tbreak;\n\tdefault:\n\tcase e1000_media_type_unknown:\n\t\tbreak;\n\t}\n\n\tif (((hw->mac.type == e1000_i210) ||\n\t     (hw->mac.type == e1000_i211)) &&\n\t     (hw->phy.id == I210_I_PHY_ID)) {\n\t\tif (!netif_carrier_ok(adapter->netdev)) {\n\t\t\tadapter->flags &= ~IGB_FLAG_NEED_LINK_UPDATE;\n\t\t} else if (!(adapter->flags & IGB_FLAG_NEED_LINK_UPDATE)) {\n\t\t\tadapter->flags |= IGB_FLAG_NEED_LINK_UPDATE;\n\t\t\tadapter->link_check_timeout = jiffies;\n\t\t}\n\t}\n\n\treturn link_active;\n}\n\nstatic bool igb_thermal_sensor_event(struct e1000_hw *hw, u32 event)\n{\n\tbool ret = false;\n\tu32 ctrl_ext, thstat;\n\n\t/* check for thermal sensor event on i350 copper only */\n\tif (hw->mac.type == e1000_i350) {\n\t\tthstat = rd32(E1000_THSTAT);\n\t\tctrl_ext = rd32(E1000_CTRL_EXT);\n\n\t\tif ((hw->phy.media_type == e1000_media_type_copper) &&\n\t\t    !(ctrl_ext & E1000_CTRL_EXT_LINK_MODE_SGMII))\n\t\t\tret = !!(thstat & event);\n\t}\n\n\treturn ret;\n}\n\n/**\n *  igb_check_lvmmc - check for malformed packets received\n *  and indicated in LVMMC register\n *  @adapter: pointer to adapter\n **/\nstatic void igb_check_lvmmc(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 lvmmc;\n\n\tlvmmc = rd32(E1000_LVMMC);\n\tif (lvmmc) {\n\t\tif (unlikely(net_ratelimit())) {\n\t\t\tnetdev_warn(adapter->netdev,\n\t\t\t\t    \"malformed Tx packet detected and dropped, LVMMC:0x%08x\\n\",\n\t\t\t\t    lvmmc);\n\t\t}\n\t}\n}\n\n/**\n *  igb_watchdog - Timer Call-back\n *  @t: pointer to timer_list containing our private info pointer\n **/\nstatic void igb_watchdog(struct timer_list *t)\n{\n\tstruct igb_adapter *adapter = from_timer(adapter, t, watchdog_timer);\n\t/* Do the rest outside of interrupt context */\n\tschedule_work(&adapter->watchdog_task);\n}\n\nstatic void igb_watchdog_task(struct work_struct *work)\n{\n\tstruct igb_adapter *adapter = container_of(work,\n\t\t\t\t\t\t   struct igb_adapter,\n\t\t\t\t\t\t   watchdog_task);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_phy_info *phy = &hw->phy;\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 link;\n\tint i;\n\tu32 connsw;\n\tu16 phy_data, retry_count = 20;\n\n\tlink = igb_has_link(adapter);\n\n\tif (adapter->flags & IGB_FLAG_NEED_LINK_UPDATE) {\n\t\tif (time_after(jiffies, (adapter->link_check_timeout + HZ)))\n\t\t\tadapter->flags &= ~IGB_FLAG_NEED_LINK_UPDATE;\n\t\telse\n\t\t\tlink = false;\n\t}\n\n\t/* Force link down if we have fiber to swap to */\n\tif (adapter->flags & IGB_FLAG_MAS_ENABLE) {\n\t\tif (hw->phy.media_type == e1000_media_type_copper) {\n\t\t\tconnsw = rd32(E1000_CONNSW);\n\t\t\tif (!(connsw & E1000_CONNSW_AUTOSENSE_EN))\n\t\t\t\tlink = 0;\n\t\t}\n\t}\n\tif (link) {\n\t\t/* Perform a reset if the media type changed. */\n\t\tif (hw->dev_spec._82575.media_changed) {\n\t\t\thw->dev_spec._82575.media_changed = false;\n\t\t\tadapter->flags |= IGB_FLAG_MEDIA_RESET;\n\t\t\tigb_reset(adapter);\n\t\t}\n\t\t/* Cancel scheduled suspend requests. */\n\t\tpm_runtime_resume(netdev->dev.parent);\n\n\t\tif (!netif_carrier_ok(netdev)) {\n\t\t\tu32 ctrl;\n\n\t\t\thw->mac.ops.get_speed_and_duplex(hw,\n\t\t\t\t\t\t\t &adapter->link_speed,\n\t\t\t\t\t\t\t &adapter->link_duplex);\n\n\t\t\tctrl = rd32(E1000_CTRL);\n\t\t\t/* Links status message must follow this format */\n\t\t\tnetdev_info(netdev,\n\t\t\t       \"igb: %s NIC Link is Up %d Mbps %s Duplex, Flow Control: %s\\n\",\n\t\t\t       netdev->name,\n\t\t\t       adapter->link_speed,\n\t\t\t       adapter->link_duplex == FULL_DUPLEX ?\n\t\t\t       \"Full\" : \"Half\",\n\t\t\t       (ctrl & E1000_CTRL_TFCE) &&\n\t\t\t       (ctrl & E1000_CTRL_RFCE) ? \"RX/TX\" :\n\t\t\t       (ctrl & E1000_CTRL_RFCE) ?  \"RX\" :\n\t\t\t       (ctrl & E1000_CTRL_TFCE) ?  \"TX\" : \"None\");\n\n\t\t\t/* disable EEE if enabled */\n\t\t\tif ((adapter->flags & IGB_FLAG_EEE) &&\n\t\t\t\t(adapter->link_duplex == HALF_DUPLEX)) {\n\t\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t\"EEE Disabled: unsupported at half duplex. Re-enable using ethtool when at full duplex.\\n\");\n\t\t\t\tadapter->hw.dev_spec._82575.eee_disable = true;\n\t\t\t\tadapter->flags &= ~IGB_FLAG_EEE;\n\t\t\t}\n\n\t\t\t/* check if SmartSpeed worked */\n\t\t\tigb_check_downshift(hw);\n\t\t\tif (phy->speed_downgraded)\n\t\t\t\tnetdev_warn(netdev, \"Link Speed was downgraded by SmartSpeed\\n\");\n\n\t\t\t/* check for thermal sensor event */\n\t\t\tif (igb_thermal_sensor_event(hw,\n\t\t\t    E1000_THSTAT_LINK_THROTTLE))\n\t\t\t\tnetdev_info(netdev, \"The network adapter link speed was downshifted because it overheated\\n\");\n\n\t\t\t/* adjust timeout factor according to speed/duplex */\n\t\t\tadapter->tx_timeout_factor = 1;\n\t\t\tswitch (adapter->link_speed) {\n\t\t\tcase SPEED_10:\n\t\t\t\tadapter->tx_timeout_factor = 14;\n\t\t\t\tbreak;\n\t\t\tcase SPEED_100:\n\t\t\t\t/* maybe add some timeout factor ? */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (adapter->link_speed != SPEED_1000)\n\t\t\t\tgoto no_wait;\n\n\t\t\t/* wait for Remote receiver status OK */\nretry_read_status:\n\t\t\tif (!igb_read_phy_reg(hw, PHY_1000T_STATUS,\n\t\t\t\t\t      &phy_data)) {\n\t\t\t\tif (!(phy_data & SR_1000T_REMOTE_RX_STATUS) &&\n\t\t\t\t    retry_count) {\n\t\t\t\t\tmsleep(100);\n\t\t\t\t\tretry_count--;\n\t\t\t\t\tgoto retry_read_status;\n\t\t\t\t} else if (!retry_count) {\n\t\t\t\t\tdev_err(&adapter->pdev->dev, \"exceed max 2 second\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdev_err(&adapter->pdev->dev, \"read 1000Base-T Status Reg\\n\");\n\t\t\t}\nno_wait:\n\t\t\tnetif_carrier_on(netdev);\n\n\t\t\tigb_ping_all_vfs(adapter);\n\t\t\tigb_check_vf_rate_limit(adapter);\n\n\t\t\t/* link state has changed, schedule phy info update */\n\t\t\tif (!test_bit(__IGB_DOWN, &adapter->state))\n\t\t\t\tmod_timer(&adapter->phy_info_timer,\n\t\t\t\t\t  round_jiffies(jiffies + 2 * HZ));\n\t\t}\n\t} else {\n\t\tif (netif_carrier_ok(netdev)) {\n\t\t\tadapter->link_speed = 0;\n\t\t\tadapter->link_duplex = 0;\n\n\t\t\t/* check for thermal sensor event */\n\t\t\tif (igb_thermal_sensor_event(hw,\n\t\t\t    E1000_THSTAT_PWR_DOWN)) {\n\t\t\t\tnetdev_err(netdev, \"The network adapter was stopped because it overheated\\n\");\n\t\t\t}\n\n\t\t\t/* Links status message must follow this format */\n\t\t\tnetdev_info(netdev, \"igb: %s NIC Link is Down\\n\",\n\t\t\t       netdev->name);\n\t\t\tnetif_carrier_off(netdev);\n\n\t\t\tigb_ping_all_vfs(adapter);\n\n\t\t\t/* link state has changed, schedule phy info update */\n\t\t\tif (!test_bit(__IGB_DOWN, &adapter->state))\n\t\t\t\tmod_timer(&adapter->phy_info_timer,\n\t\t\t\t\t  round_jiffies(jiffies + 2 * HZ));\n\n\t\t\t/* link is down, time to check for alternate media */\n\t\t\tif (adapter->flags & IGB_FLAG_MAS_ENABLE) {\n\t\t\t\tigb_check_swap_media(adapter);\n\t\t\t\tif (adapter->flags & IGB_FLAG_MEDIA_RESET) {\n\t\t\t\t\tschedule_work(&adapter->reset_task);\n\t\t\t\t\t/* return immediately */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpm_schedule_suspend(netdev->dev.parent,\n\t\t\t\t\t    MSEC_PER_SEC * 5);\n\n\t\t/* also check for alternate media here */\n\t\t} else if (!netif_carrier_ok(netdev) &&\n\t\t\t   (adapter->flags & IGB_FLAG_MAS_ENABLE)) {\n\t\t\tigb_check_swap_media(adapter);\n\t\t\tif (adapter->flags & IGB_FLAG_MEDIA_RESET) {\n\t\t\t\tschedule_work(&adapter->reset_task);\n\t\t\t\t/* return immediately */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock(&adapter->stats64_lock);\n\tigb_update_stats(adapter);\n\tspin_unlock(&adapter->stats64_lock);\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\tstruct igb_ring *tx_ring = adapter->tx_ring[i];\n\t\tif (!netif_carrier_ok(netdev)) {\n\t\t\t/* We've lost link, so the controller stops DMA,\n\t\t\t * but we've got queued Tx work that's never going\n\t\t\t * to get done, so reset controller to flush Tx.\n\t\t\t * (Do the reset outside of interrupt context).\n\t\t\t */\n\t\t\tif (igb_desc_unused(tx_ring) + 1 < tx_ring->count) {\n\t\t\t\tadapter->tx_timeout_count++;\n\t\t\t\tschedule_work(&adapter->reset_task);\n\t\t\t\t/* return immediately since reset is imminent */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* Force detection of hung controller every watchdog period */\n\t\tset_bit(IGB_RING_FLAG_TX_DETECT_HANG, &tx_ring->flags);\n\t}\n\n\t/* Cause software interrupt to ensure Rx ring is cleaned */\n\tif (adapter->flags & IGB_FLAG_HAS_MSIX) {\n\t\tu32 eics = 0;\n\n\t\tfor (i = 0; i < adapter->num_q_vectors; i++)\n\t\t\teics |= adapter->q_vector[i]->eims_value;\n\t\twr32(E1000_EICS, eics);\n\t} else {\n\t\twr32(E1000_ICS, E1000_ICS_RXDMT0);\n\t}\n\n\tigb_spoof_check(adapter);\n\tigb_ptp_rx_hang(adapter);\n\tigb_ptp_tx_hang(adapter);\n\n\t/* Check LVMMC register on i350/i354 only */\n\tif ((adapter->hw.mac.type == e1000_i350) ||\n\t    (adapter->hw.mac.type == e1000_i354))\n\t\tigb_check_lvmmc(adapter);\n\n\t/* Reset the timer */\n\tif (!test_bit(__IGB_DOWN, &adapter->state)) {\n\t\tif (adapter->flags & IGB_FLAG_NEED_LINK_UPDATE)\n\t\t\tmod_timer(&adapter->watchdog_timer,\n\t\t\t\t  round_jiffies(jiffies +  HZ));\n\t\telse\n\t\t\tmod_timer(&adapter->watchdog_timer,\n\t\t\t\t  round_jiffies(jiffies + 2 * HZ));\n\t}\n}\n\nenum latency_range {\n\tlowest_latency = 0,\n\tlow_latency = 1,\n\tbulk_latency = 2,\n\tlatency_invalid = 255\n};\n\n/**\n *  igb_update_ring_itr - update the dynamic ITR value based on packet size\n *  @q_vector: pointer to q_vector\n *\n *  Stores a new ITR value based on strictly on packet size.  This\n *  algorithm is less sophisticated than that used in igb_update_itr,\n *  due to the difficulty of synchronizing statistics across multiple\n *  receive rings.  The divisors and thresholds used by this function\n *  were determined based on theoretical maximum wire speed and testing\n *  data, in order to minimize response time while increasing bulk\n *  throughput.\n *  This functionality is controlled by ethtool's coalescing settings.\n *  NOTE:  This function is called only when operating in a multiqueue\n *         receive environment.\n **/\nstatic void igb_update_ring_itr(struct igb_q_vector *q_vector)\n{\n\tint new_val = q_vector->itr_val;\n\tint avg_wire_size = 0;\n\tstruct igb_adapter *adapter = q_vector->adapter;\n\tunsigned int packets;\n\n\t/* For non-gigabit speeds, just fix the interrupt rate at 4000\n\t * ints/sec - ITR timer value of 120 ticks.\n\t */\n\tif (adapter->link_speed != SPEED_1000) {\n\t\tnew_val = IGB_4K_ITR;\n\t\tgoto set_itr_val;\n\t}\n\n\tpackets = q_vector->rx.total_packets;\n\tif (packets)\n\t\tavg_wire_size = q_vector->rx.total_bytes / packets;\n\n\tpackets = q_vector->tx.total_packets;\n\tif (packets)\n\t\tavg_wire_size = max_t(u32, avg_wire_size,\n\t\t\t\t      q_vector->tx.total_bytes / packets);\n\n\t/* if avg_wire_size isn't set no work was done */\n\tif (!avg_wire_size)\n\t\tgoto clear_counts;\n\n\t/* Add 24 bytes to size to account for CRC, preamble, and gap */\n\tavg_wire_size += 24;\n\n\t/* Don't starve jumbo frames */\n\tavg_wire_size = min(avg_wire_size, 3000);\n\n\t/* Give a little boost to mid-size frames */\n\tif ((avg_wire_size > 300) && (avg_wire_size < 1200))\n\t\tnew_val = avg_wire_size / 3;\n\telse\n\t\tnew_val = avg_wire_size / 2;\n\n\t/* conservative mode (itr 3) eliminates the lowest_latency setting */\n\tif (new_val < IGB_20K_ITR &&\n\t    ((q_vector->rx.ring && adapter->rx_itr_setting == 3) ||\n\t     (!q_vector->rx.ring && adapter->tx_itr_setting == 3)))\n\t\tnew_val = IGB_20K_ITR;\n\nset_itr_val:\n\tif (new_val != q_vector->itr_val) {\n\t\tq_vector->itr_val = new_val;\n\t\tq_vector->set_itr = 1;\n\t}\nclear_counts:\n\tq_vector->rx.total_bytes = 0;\n\tq_vector->rx.total_packets = 0;\n\tq_vector->tx.total_bytes = 0;\n\tq_vector->tx.total_packets = 0;\n}\n\n/**\n *  igb_update_itr - update the dynamic ITR value based on statistics\n *  @q_vector: pointer to q_vector\n *  @ring_container: ring info to update the itr for\n *\n *  Stores a new ITR value based on packets and byte\n *  counts during the last interrupt.  The advantage of per interrupt\n *  computation is faster updates and more accurate ITR for the current\n *  traffic pattern.  Constants in this function were computed\n *  based on theoretical maximum wire speed and thresholds were set based\n *  on testing data as well as attempting to minimize response time\n *  while increasing bulk throughput.\n *  This functionality is controlled by ethtool's coalescing settings.\n *  NOTE:  These calculations are only valid when operating in a single-\n *         queue environment.\n **/\nstatic void igb_update_itr(struct igb_q_vector *q_vector,\n\t\t\t   struct igb_ring_container *ring_container)\n{\n\tunsigned int packets = ring_container->total_packets;\n\tunsigned int bytes = ring_container->total_bytes;\n\tu8 itrval = ring_container->itr;\n\n\t/* no packets, exit with status unchanged */\n\tif (packets == 0)\n\t\treturn;\n\n\tswitch (itrval) {\n\tcase lowest_latency:\n\t\t/* handle TSO and jumbo frames */\n\t\tif (bytes/packets > 8000)\n\t\t\titrval = bulk_latency;\n\t\telse if ((packets < 5) && (bytes > 512))\n\t\t\titrval = low_latency;\n\t\tbreak;\n\tcase low_latency:  /* 50 usec aka 20000 ints/s */\n\t\tif (bytes > 10000) {\n\t\t\t/* this if handles the TSO accounting */\n\t\t\tif (bytes/packets > 8000)\n\t\t\t\titrval = bulk_latency;\n\t\t\telse if ((packets < 10) || ((bytes/packets) > 1200))\n\t\t\t\titrval = bulk_latency;\n\t\t\telse if ((packets > 35))\n\t\t\t\titrval = lowest_latency;\n\t\t} else if (bytes/packets > 2000) {\n\t\t\titrval = bulk_latency;\n\t\t} else if (packets <= 2 && bytes < 512) {\n\t\t\titrval = lowest_latency;\n\t\t}\n\t\tbreak;\n\tcase bulk_latency: /* 250 usec aka 4000 ints/s */\n\t\tif (bytes > 25000) {\n\t\t\tif (packets > 35)\n\t\t\t\titrval = low_latency;\n\t\t} else if (bytes < 1500) {\n\t\t\titrval = low_latency;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* clear work counters since we have the values we need */\n\tring_container->total_bytes = 0;\n\tring_container->total_packets = 0;\n\n\t/* write updated itr to ring container */\n\tring_container->itr = itrval;\n}\n\nstatic void igb_set_itr(struct igb_q_vector *q_vector)\n{\n\tstruct igb_adapter *adapter = q_vector->adapter;\n\tu32 new_itr = q_vector->itr_val;\n\tu8 current_itr = 0;\n\n\t/* for non-gigabit speeds, just fix the interrupt rate at 4000 */\n\tif (adapter->link_speed != SPEED_1000) {\n\t\tcurrent_itr = 0;\n\t\tnew_itr = IGB_4K_ITR;\n\t\tgoto set_itr_now;\n\t}\n\n\tigb_update_itr(q_vector, &q_vector->tx);\n\tigb_update_itr(q_vector, &q_vector->rx);\n\n\tcurrent_itr = max(q_vector->rx.itr, q_vector->tx.itr);\n\n\t/* conservative mode (itr 3) eliminates the lowest_latency setting */\n\tif (current_itr == lowest_latency &&\n\t    ((q_vector->rx.ring && adapter->rx_itr_setting == 3) ||\n\t     (!q_vector->rx.ring && adapter->tx_itr_setting == 3)))\n\t\tcurrent_itr = low_latency;\n\n\tswitch (current_itr) {\n\t/* counts and packets in update_itr are dependent on these numbers */\n\tcase lowest_latency:\n\t\tnew_itr = IGB_70K_ITR; /* 70,000 ints/sec */\n\t\tbreak;\n\tcase low_latency:\n\t\tnew_itr = IGB_20K_ITR; /* 20,000 ints/sec */\n\t\tbreak;\n\tcase bulk_latency:\n\t\tnew_itr = IGB_4K_ITR;  /* 4,000 ints/sec */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nset_itr_now:\n\tif (new_itr != q_vector->itr_val) {\n\t\t/* this attempts to bias the interrupt rate towards Bulk\n\t\t * by adding intermediate steps when interrupt rate is\n\t\t * increasing\n\t\t */\n\t\tnew_itr = new_itr > q_vector->itr_val ?\n\t\t\t  max((new_itr * q_vector->itr_val) /\n\t\t\t  (new_itr + (q_vector->itr_val >> 2)),\n\t\t\t  new_itr) : new_itr;\n\t\t/* Don't write the value here; it resets the adapter's\n\t\t * internal timer, and causes us to delay far longer than\n\t\t * we should between interrupts.  Instead, we write the ITR\n\t\t * value at the beginning of the next interrupt so the timing\n\t\t * ends up being correct.\n\t\t */\n\t\tq_vector->itr_val = new_itr;\n\t\tq_vector->set_itr = 1;\n\t}\n}\n\nstatic void igb_tx_ctxtdesc(struct igb_ring *tx_ring,\n\t\t\t    struct igb_tx_buffer *first,\n\t\t\t    u32 vlan_macip_lens, u32 type_tucmd,\n\t\t\t    u32 mss_l4len_idx)\n{\n\tstruct e1000_adv_tx_context_desc *context_desc;\n\tu16 i = tx_ring->next_to_use;\n\tstruct timespec64 ts;\n\n\tcontext_desc = IGB_TX_CTXTDESC(tx_ring, i);\n\n\ti++;\n\ttx_ring->next_to_use = (i < tx_ring->count) ? i : 0;\n\n\t/* set bits to identify this as an advanced context descriptor */\n\ttype_tucmd |= E1000_TXD_CMD_DEXT | E1000_ADVTXD_DTYP_CTXT;\n\n\t/* For 82575, context index must be unique per ring. */\n\tif (test_bit(IGB_RING_FLAG_TX_CTX_IDX, &tx_ring->flags))\n\t\tmss_l4len_idx |= tx_ring->reg_idx << 4;\n\n\tcontext_desc->vlan_macip_lens\t= cpu_to_le32(vlan_macip_lens);\n\tcontext_desc->type_tucmd_mlhl\t= cpu_to_le32(type_tucmd);\n\tcontext_desc->mss_l4len_idx\t= cpu_to_le32(mss_l4len_idx);\n\n\t/* We assume there is always a valid tx time available. Invalid times\n\t * should have been handled by the upper layers.\n\t */\n\tif (tx_ring->launchtime_enable) {\n\t\tts = ktime_to_timespec64(first->skb->tstamp);\n\t\tfirst->skb->tstamp = ktime_set(0, 0);\n\t\tcontext_desc->seqnum_seed = cpu_to_le32(ts.tv_nsec / 32);\n\t} else {\n\t\tcontext_desc->seqnum_seed = 0;\n\t}\n}\n\nstatic int igb_tso(struct igb_ring *tx_ring,\n\t\t   struct igb_tx_buffer *first,\n\t\t   u8 *hdr_len)\n{\n\tu32 vlan_macip_lens, type_tucmd, mss_l4len_idx;\n\tstruct sk_buff *skb = first->skb;\n\tunion {\n\t\tstruct iphdr *v4;\n\t\tstruct ipv6hdr *v6;\n\t\tunsigned char *hdr;\n\t} ip;\n\tunion {\n\t\tstruct tcphdr *tcp;\n\t\tstruct udphdr *udp;\n\t\tunsigned char *hdr;\n\t} l4;\n\tu32 paylen, l4_offset;\n\tint err;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn 0;\n\n\tif (!skb_is_gso(skb))\n\t\treturn 0;\n\n\terr = skb_cow_head(skb, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tip.hdr = skb_network_header(skb);\n\tl4.hdr = skb_checksum_start(skb);\n\n\t/* ADV DTYP TUCMD MKRLOC/ISCSIHEDLEN */\n\ttype_tucmd = (skb_shinfo(skb)->gso_type & SKB_GSO_UDP_L4) ?\n\t\t      E1000_ADVTXD_TUCMD_L4T_UDP : E1000_ADVTXD_TUCMD_L4T_TCP;\n\n\t/* initialize outer IP header fields */\n\tif (ip.v4->version == 4) {\n\t\tunsigned char *csum_start = skb_checksum_start(skb);\n\t\tunsigned char *trans_start = ip.hdr + (ip.v4->ihl * 4);\n\n\t\t/* IP header will have to cancel out any data that\n\t\t * is not a part of the outer IP header\n\t\t */\n\t\tip.v4->check = csum_fold(csum_partial(trans_start,\n\t\t\t\t\t\t      csum_start - trans_start,\n\t\t\t\t\t\t      0));\n\t\ttype_tucmd |= E1000_ADVTXD_TUCMD_IPV4;\n\n\t\tip.v4->tot_len = 0;\n\t\tfirst->tx_flags |= IGB_TX_FLAGS_TSO |\n\t\t\t\t   IGB_TX_FLAGS_CSUM |\n\t\t\t\t   IGB_TX_FLAGS_IPV4;\n\t} else {\n\t\tip.v6->payload_len = 0;\n\t\tfirst->tx_flags |= IGB_TX_FLAGS_TSO |\n\t\t\t\t   IGB_TX_FLAGS_CSUM;\n\t}\n\n\t/* determine offset of inner transport header */\n\tl4_offset = l4.hdr - skb->data;\n\n\t/* remove payload length from inner checksum */\n\tpaylen = skb->len - l4_offset;\n\tif (type_tucmd & E1000_ADVTXD_TUCMD_L4T_TCP) {\n\t\t/* compute length of segmentation header */\n\t\t*hdr_len = (l4.tcp->doff * 4) + l4_offset;\n\t\tcsum_replace_by_diff(&l4.tcp->check,\n\t\t\t(__force __wsum)htonl(paylen));\n\t} else {\n\t\t/* compute length of segmentation header */\n\t\t*hdr_len = sizeof(*l4.udp) + l4_offset;\n\t\tcsum_replace_by_diff(&l4.udp->check,\n\t\t\t\t     (__force __wsum)htonl(paylen));\n\t}\n\n\t/* update gso size and bytecount with header size */\n\tfirst->gso_segs = skb_shinfo(skb)->gso_segs;\n\tfirst->bytecount += (first->gso_segs - 1) * *hdr_len;\n\n\t/* MSS L4LEN IDX */\n\tmss_l4len_idx = (*hdr_len - l4_offset) << E1000_ADVTXD_L4LEN_SHIFT;\n\tmss_l4len_idx |= skb_shinfo(skb)->gso_size << E1000_ADVTXD_MSS_SHIFT;\n\n\t/* VLAN MACLEN IPLEN */\n\tvlan_macip_lens = l4.hdr - ip.hdr;\n\tvlan_macip_lens |= (ip.hdr - skb->data) << E1000_ADVTXD_MACLEN_SHIFT;\n\tvlan_macip_lens |= first->tx_flags & IGB_TX_FLAGS_VLAN_MASK;\n\n\tigb_tx_ctxtdesc(tx_ring, first, vlan_macip_lens,\n\t\t\ttype_tucmd, mss_l4len_idx);\n\n\treturn 1;\n}\n\nstatic inline bool igb_ipv6_csum_is_sctp(struct sk_buff *skb)\n{\n\tunsigned int offset = 0;\n\n\tipv6_find_hdr(skb, &offset, IPPROTO_SCTP, NULL, NULL);\n\n\treturn offset == skb_checksum_start_offset(skb);\n}\n\nstatic void igb_tx_csum(struct igb_ring *tx_ring, struct igb_tx_buffer *first)\n{\n\tstruct sk_buff *skb = first->skb;\n\tu32 vlan_macip_lens = 0;\n\tu32 type_tucmd = 0;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL) {\ncsum_failed:\n\t\tif (!(first->tx_flags & IGB_TX_FLAGS_VLAN) &&\n\t\t    !tx_ring->launchtime_enable)\n\t\t\treturn;\n\t\tgoto no_csum;\n\t}\n\n\tswitch (skb->csum_offset) {\n\tcase offsetof(struct tcphdr, check):\n\t\ttype_tucmd = E1000_ADVTXD_TUCMD_L4T_TCP;\n\t\tfallthrough;\n\tcase offsetof(struct udphdr, check):\n\t\tbreak;\n\tcase offsetof(struct sctphdr, checksum):\n\t\t/* validate that this is actually an SCTP request */\n\t\tif (((first->protocol == htons(ETH_P_IP)) &&\n\t\t     (ip_hdr(skb)->protocol == IPPROTO_SCTP)) ||\n\t\t    ((first->protocol == htons(ETH_P_IPV6)) &&\n\t\t     igb_ipv6_csum_is_sctp(skb))) {\n\t\t\ttype_tucmd = E1000_ADVTXD_TUCMD_L4T_SCTP;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tskb_checksum_help(skb);\n\t\tgoto csum_failed;\n\t}\n\n\t/* update TX checksum flag */\n\tfirst->tx_flags |= IGB_TX_FLAGS_CSUM;\n\tvlan_macip_lens = skb_checksum_start_offset(skb) -\n\t\t\t  skb_network_offset(skb);\nno_csum:\n\tvlan_macip_lens |= skb_network_offset(skb) << E1000_ADVTXD_MACLEN_SHIFT;\n\tvlan_macip_lens |= first->tx_flags & IGB_TX_FLAGS_VLAN_MASK;\n\n\tigb_tx_ctxtdesc(tx_ring, first, vlan_macip_lens, type_tucmd, 0);\n}\n\n#define IGB_SET_FLAG(_input, _flag, _result) \\\n\t((_flag <= _result) ? \\\n\t ((u32)(_input & _flag) * (_result / _flag)) : \\\n\t ((u32)(_input & _flag) / (_flag / _result)))\n\nstatic u32 igb_tx_cmd_type(struct sk_buff *skb, u32 tx_flags)\n{\n\t/* set type for advanced descriptor with frame checksum insertion */\n\tu32 cmd_type = E1000_ADVTXD_DTYP_DATA |\n\t\t       E1000_ADVTXD_DCMD_DEXT |\n\t\t       E1000_ADVTXD_DCMD_IFCS;\n\n\t/* set HW vlan bit if vlan is present */\n\tcmd_type |= IGB_SET_FLAG(tx_flags, IGB_TX_FLAGS_VLAN,\n\t\t\t\t (E1000_ADVTXD_DCMD_VLE));\n\n\t/* set segmentation bits for TSO */\n\tcmd_type |= IGB_SET_FLAG(tx_flags, IGB_TX_FLAGS_TSO,\n\t\t\t\t (E1000_ADVTXD_DCMD_TSE));\n\n\t/* set timestamp bit if present */\n\tcmd_type |= IGB_SET_FLAG(tx_flags, IGB_TX_FLAGS_TSTAMP,\n\t\t\t\t (E1000_ADVTXD_MAC_TSTAMP));\n\n\t/* insert frame checksum */\n\tcmd_type ^= IGB_SET_FLAG(skb->no_fcs, 1, E1000_ADVTXD_DCMD_IFCS);\n\n\treturn cmd_type;\n}\n\nstatic void igb_tx_olinfo_status(struct igb_ring *tx_ring,\n\t\t\t\t union e1000_adv_tx_desc *tx_desc,\n\t\t\t\t u32 tx_flags, unsigned int paylen)\n{\n\tu32 olinfo_status = paylen << E1000_ADVTXD_PAYLEN_SHIFT;\n\n\t/* 82575 requires a unique index per ring */\n\tif (test_bit(IGB_RING_FLAG_TX_CTX_IDX, &tx_ring->flags))\n\t\tolinfo_status |= tx_ring->reg_idx << 4;\n\n\t/* insert L4 checksum */\n\tolinfo_status |= IGB_SET_FLAG(tx_flags,\n\t\t\t\t      IGB_TX_FLAGS_CSUM,\n\t\t\t\t      (E1000_TXD_POPTS_TXSM << 8));\n\n\t/* insert IPv4 checksum */\n\tolinfo_status |= IGB_SET_FLAG(tx_flags,\n\t\t\t\t      IGB_TX_FLAGS_IPV4,\n\t\t\t\t      (E1000_TXD_POPTS_IXSM << 8));\n\n\ttx_desc->read.olinfo_status = cpu_to_le32(olinfo_status);\n}\n\nstatic int __igb_maybe_stop_tx(struct igb_ring *tx_ring, const u16 size)\n{\n\tstruct net_device *netdev = tx_ring->netdev;\n\n\tnetif_stop_subqueue(netdev, tx_ring->queue_index);\n\n\t/* Herbert's original patch had:\n\t *  smp_mb__after_netif_stop_queue();\n\t * but since that doesn't exist yet, just open code it.\n\t */\n\tsmp_mb();\n\n\t/* We need to check again in a case another CPU has just\n\t * made room available.\n\t */\n\tif (igb_desc_unused(tx_ring) < size)\n\t\treturn -EBUSY;\n\n\t/* A reprieve! */\n\tnetif_wake_subqueue(netdev, tx_ring->queue_index);\n\n\tu64_stats_update_begin(&tx_ring->tx_syncp2);\n\ttx_ring->tx_stats.restart_queue2++;\n\tu64_stats_update_end(&tx_ring->tx_syncp2);\n\n\treturn 0;\n}\n\nstatic inline int igb_maybe_stop_tx(struct igb_ring *tx_ring, const u16 size)\n{\n\tif (igb_desc_unused(tx_ring) >= size)\n\t\treturn 0;\n\treturn __igb_maybe_stop_tx(tx_ring, size);\n}\n\nstatic int igb_tx_map(struct igb_ring *tx_ring,\n\t\t      struct igb_tx_buffer *first,\n\t\t      const u8 hdr_len)\n{\n\tstruct sk_buff *skb = first->skb;\n\tstruct igb_tx_buffer *tx_buffer;\n\tunion e1000_adv_tx_desc *tx_desc;\n\tskb_frag_t *frag;\n\tdma_addr_t dma;\n\tunsigned int data_len, size;\n\tu32 tx_flags = first->tx_flags;\n\tu32 cmd_type = igb_tx_cmd_type(skb, tx_flags);\n\tu16 i = tx_ring->next_to_use;\n\n\ttx_desc = IGB_TX_DESC(tx_ring, i);\n\n\tigb_tx_olinfo_status(tx_ring, tx_desc, tx_flags, skb->len - hdr_len);\n\n\tsize = skb_headlen(skb);\n\tdata_len = skb->data_len;\n\n\tdma = dma_map_single(tx_ring->dev, skb->data, size, DMA_TO_DEVICE);\n\n\ttx_buffer = first;\n\n\tfor (frag = &skb_shinfo(skb)->frags[0];; frag++) {\n\t\tif (dma_mapping_error(tx_ring->dev, dma))\n\t\t\tgoto dma_error;\n\n\t\t/* record length, and DMA address */\n\t\tdma_unmap_len_set(tx_buffer, len, size);\n\t\tdma_unmap_addr_set(tx_buffer, dma, dma);\n\n\t\ttx_desc->read.buffer_addr = cpu_to_le64(dma);\n\n\t\twhile (unlikely(size > IGB_MAX_DATA_PER_TXD)) {\n\t\t\ttx_desc->read.cmd_type_len =\n\t\t\t\tcpu_to_le32(cmd_type ^ IGB_MAX_DATA_PER_TXD);\n\n\t\t\ti++;\n\t\t\ttx_desc++;\n\t\t\tif (i == tx_ring->count) {\n\t\t\t\ttx_desc = IGB_TX_DESC(tx_ring, 0);\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\ttx_desc->read.olinfo_status = 0;\n\n\t\t\tdma += IGB_MAX_DATA_PER_TXD;\n\t\t\tsize -= IGB_MAX_DATA_PER_TXD;\n\n\t\t\ttx_desc->read.buffer_addr = cpu_to_le64(dma);\n\t\t}\n\n\t\tif (likely(!data_len))\n\t\t\tbreak;\n\n\t\ttx_desc->read.cmd_type_len = cpu_to_le32(cmd_type ^ size);\n\n\t\ti++;\n\t\ttx_desc++;\n\t\tif (i == tx_ring->count) {\n\t\t\ttx_desc = IGB_TX_DESC(tx_ring, 0);\n\t\t\ti = 0;\n\t\t}\n\t\ttx_desc->read.olinfo_status = 0;\n\n\t\tsize = skb_frag_size(frag);\n\t\tdata_len -= size;\n\n\t\tdma = skb_frag_dma_map(tx_ring->dev, frag, 0,\n\t\t\t\t       size, DMA_TO_DEVICE);\n\n\t\ttx_buffer = &tx_ring->tx_buffer_info[i];\n\t}\n\n\t/* write last descriptor with RS and EOP bits */\n\tcmd_type |= size | IGB_TXD_DCMD;\n\ttx_desc->read.cmd_type_len = cpu_to_le32(cmd_type);\n\n\tnetdev_tx_sent_queue(txring_txq(tx_ring), first->bytecount);\n\n\t/* set the timestamp */\n\tfirst->time_stamp = jiffies;\n\n\tskb_tx_timestamp(skb);\n\n\t/* Force memory writes to complete before letting h/w know there\n\t * are new descriptors to fetch.  (Only applicable for weak-ordered\n\t * memory model archs, such as IA-64).\n\t *\n\t * We also need this memory barrier to make certain all of the\n\t * status bits have been updated before next_to_watch is written.\n\t */\n\tdma_wmb();\n\n\t/* set next_to_watch value indicating a packet is present */\n\tfirst->next_to_watch = tx_desc;\n\n\ti++;\n\tif (i == tx_ring->count)\n\t\ti = 0;\n\n\ttx_ring->next_to_use = i;\n\n\t/* Make sure there is space in the ring for the next send. */\n\tigb_maybe_stop_tx(tx_ring, DESC_NEEDED);\n\n\tif (netif_xmit_stopped(txring_txq(tx_ring)) || !netdev_xmit_more()) {\n\t\twritel(i, tx_ring->tail);\n\t}\n\treturn 0;\n\ndma_error:\n\tdev_err(tx_ring->dev, \"TX DMA map failed\\n\");\n\ttx_buffer = &tx_ring->tx_buffer_info[i];\n\n\t/* clear dma mappings for failed tx_buffer_info map */\n\twhile (tx_buffer != first) {\n\t\tif (dma_unmap_len(tx_buffer, len))\n\t\t\tdma_unmap_page(tx_ring->dev,\n\t\t\t\t       dma_unmap_addr(tx_buffer, dma),\n\t\t\t\t       dma_unmap_len(tx_buffer, len),\n\t\t\t\t       DMA_TO_DEVICE);\n\t\tdma_unmap_len_set(tx_buffer, len, 0);\n\n\t\tif (i-- == 0)\n\t\t\ti += tx_ring->count;\n\t\ttx_buffer = &tx_ring->tx_buffer_info[i];\n\t}\n\n\tif (dma_unmap_len(tx_buffer, len))\n\t\tdma_unmap_single(tx_ring->dev,\n\t\t\t\t dma_unmap_addr(tx_buffer, dma),\n\t\t\t\t dma_unmap_len(tx_buffer, len),\n\t\t\t\t DMA_TO_DEVICE);\n\tdma_unmap_len_set(tx_buffer, len, 0);\n\n\tdev_kfree_skb_any(tx_buffer->skb);\n\ttx_buffer->skb = NULL;\n\n\ttx_ring->next_to_use = i;\n\n\treturn -1;\n}\n\nint igb_xmit_xdp_ring(struct igb_adapter *adapter,\n\t\t      struct igb_ring *tx_ring,\n\t\t      struct xdp_frame *xdpf)\n{\n\tunion e1000_adv_tx_desc *tx_desc;\n\tu32 len, cmd_type, olinfo_status;\n\tstruct igb_tx_buffer *tx_buffer;\n\tdma_addr_t dma;\n\tu16 i;\n\n\tlen = xdpf->len;\n\n\tif (unlikely(!igb_desc_unused(tx_ring)))\n\t\treturn IGB_XDP_CONSUMED;\n\n\tdma = dma_map_single(tx_ring->dev, xdpf->data, len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(tx_ring->dev, dma))\n\t\treturn IGB_XDP_CONSUMED;\n\n\t/* record the location of the first descriptor for this packet */\n\ttx_buffer = &tx_ring->tx_buffer_info[tx_ring->next_to_use];\n\ttx_buffer->bytecount = len;\n\ttx_buffer->gso_segs = 1;\n\ttx_buffer->protocol = 0;\n\n\ti = tx_ring->next_to_use;\n\ttx_desc = IGB_TX_DESC(tx_ring, i);\n\n\tdma_unmap_len_set(tx_buffer, len, len);\n\tdma_unmap_addr_set(tx_buffer, dma, dma);\n\ttx_buffer->type = IGB_TYPE_XDP;\n\ttx_buffer->xdpf = xdpf;\n\n\ttx_desc->read.buffer_addr = cpu_to_le64(dma);\n\n\t/* put descriptor type bits */\n\tcmd_type = E1000_ADVTXD_DTYP_DATA |\n\t\t   E1000_ADVTXD_DCMD_DEXT |\n\t\t   E1000_ADVTXD_DCMD_IFCS;\n\tcmd_type |= len | IGB_TXD_DCMD;\n\ttx_desc->read.cmd_type_len = cpu_to_le32(cmd_type);\n\n\tolinfo_status = cpu_to_le32(len << E1000_ADVTXD_PAYLEN_SHIFT);\n\t/* 82575 requires a unique index per ring */\n\tif (test_bit(IGB_RING_FLAG_TX_CTX_IDX, &tx_ring->flags))\n\t\tolinfo_status |= tx_ring->reg_idx << 4;\n\n\ttx_desc->read.olinfo_status = olinfo_status;\n\n\tnetdev_tx_sent_queue(txring_txq(tx_ring), tx_buffer->bytecount);\n\n\t/* set the timestamp */\n\ttx_buffer->time_stamp = jiffies;\n\n\t/* Avoid any potential race with xdp_xmit and cleanup */\n\tsmp_wmb();\n\n\t/* set next_to_watch value indicating a packet is present */\n\ti++;\n\tif (i == tx_ring->count)\n\t\ti = 0;\n\n\ttx_buffer->next_to_watch = tx_desc;\n\ttx_ring->next_to_use = i;\n\n\t/* Make sure there is space in the ring for the next send. */\n\tigb_maybe_stop_tx(tx_ring, DESC_NEEDED);\n\n\tif (netif_xmit_stopped(txring_txq(tx_ring)) || !netdev_xmit_more())\n\t\twritel(i, tx_ring->tail);\n\n\treturn IGB_XDP_TX;\n}\n\nnetdev_tx_t igb_xmit_frame_ring(struct sk_buff *skb,\n\t\t\t\tstruct igb_ring *tx_ring)\n{\n\tstruct igb_tx_buffer *first;\n\tint tso;\n\tu32 tx_flags = 0;\n\tunsigned short f;\n\tu16 count = TXD_USE_COUNT(skb_headlen(skb));\n\t__be16 protocol = vlan_get_protocol(skb);\n\tu8 hdr_len = 0;\n\n\t/* need: 1 descriptor per page * PAGE_SIZE/IGB_MAX_DATA_PER_TXD,\n\t *       + 1 desc for skb_headlen/IGB_MAX_DATA_PER_TXD,\n\t *       + 2 desc gap to keep tail from touching head,\n\t *       + 1 desc for context descriptor,\n\t * otherwise try next time\n\t */\n\tfor (f = 0; f < skb_shinfo(skb)->nr_frags; f++)\n\t\tcount += TXD_USE_COUNT(skb_frag_size(\n\t\t\t\t\t\t&skb_shinfo(skb)->frags[f]));\n\n\tif (igb_maybe_stop_tx(tx_ring, count + 3)) {\n\t\t/* this is a hard error */\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t/* record the location of the first descriptor for this packet */\n\tfirst = &tx_ring->tx_buffer_info[tx_ring->next_to_use];\n\tfirst->type = IGB_TYPE_SKB;\n\tfirst->skb = skb;\n\tfirst->bytecount = skb->len;\n\tfirst->gso_segs = 1;\n\n\tif (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) {\n\t\tstruct igb_adapter *adapter = netdev_priv(tx_ring->netdev);\n\n\t\tif (adapter->tstamp_config.tx_type == HWTSTAMP_TX_ON &&\n\t\t    !test_and_set_bit_lock(__IGB_PTP_TX_IN_PROGRESS,\n\t\t\t\t\t   &adapter->state)) {\n\t\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\t\t\ttx_flags |= IGB_TX_FLAGS_TSTAMP;\n\n\t\t\tadapter->ptp_tx_skb = skb_get(skb);\n\t\t\tadapter->ptp_tx_start = jiffies;\n\t\t\tif (adapter->hw.mac.type == e1000_82576)\n\t\t\t\tschedule_work(&adapter->ptp_tx_work);\n\t\t} else {\n\t\t\tadapter->tx_hwtstamp_skipped++;\n\t\t}\n\t}\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\ttx_flags |= IGB_TX_FLAGS_VLAN;\n\t\ttx_flags |= (skb_vlan_tag_get(skb) << IGB_TX_FLAGS_VLAN_SHIFT);\n\t}\n\n\t/* record initial flags and protocol */\n\tfirst->tx_flags = tx_flags;\n\tfirst->protocol = protocol;\n\n\ttso = igb_tso(tx_ring, first, &hdr_len);\n\tif (tso < 0)\n\t\tgoto out_drop;\n\telse if (!tso)\n\t\tigb_tx_csum(tx_ring, first);\n\n\tif (igb_tx_map(tx_ring, first, hdr_len))\n\t\tgoto cleanup_tx_tstamp;\n\n\treturn NETDEV_TX_OK;\n\nout_drop:\n\tdev_kfree_skb_any(first->skb);\n\tfirst->skb = NULL;\ncleanup_tx_tstamp:\n\tif (unlikely(tx_flags & IGB_TX_FLAGS_TSTAMP)) {\n\t\tstruct igb_adapter *adapter = netdev_priv(tx_ring->netdev);\n\n\t\tdev_kfree_skb_any(adapter->ptp_tx_skb);\n\t\tadapter->ptp_tx_skb = NULL;\n\t\tif (adapter->hw.mac.type == e1000_82576)\n\t\t\tcancel_work_sync(&adapter->ptp_tx_work);\n\t\tclear_bit_unlock(__IGB_PTP_TX_IN_PROGRESS, &adapter->state);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic inline struct igb_ring *igb_tx_queue_mapping(struct igb_adapter *adapter,\n\t\t\t\t\t\t    struct sk_buff *skb)\n{\n\tunsigned int r_idx = skb->queue_mapping;\n\n\tif (r_idx >= adapter->num_tx_queues)\n\t\tr_idx = r_idx % adapter->num_tx_queues;\n\n\treturn adapter->tx_ring[r_idx];\n}\n\nstatic netdev_tx_t igb_xmit_frame(struct sk_buff *skb,\n\t\t\t\t  struct net_device *netdev)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\n\t/* The minimum packet size with TCTL.PSP set is 17 so pad the skb\n\t * in order to meet this minimum size requirement.\n\t */\n\tif (skb_put_padto(skb, 17))\n\t\treturn NETDEV_TX_OK;\n\n\treturn igb_xmit_frame_ring(skb, igb_tx_queue_mapping(adapter, skb));\n}\n\n/**\n *  igb_tx_timeout - Respond to a Tx Hang\n *  @netdev: network interface device structure\n *  @txqueue: number of the Tx queue that hung (unused)\n **/\nstatic void igb_tx_timeout(struct net_device *netdev, unsigned int __always_unused txqueue)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t/* Do the reset outside of interrupt context */\n\tadapter->tx_timeout_count++;\n\n\tif (hw->mac.type >= e1000_82580)\n\t\thw->dev_spec._82575.global_device_reset = true;\n\n\tschedule_work(&adapter->reset_task);\n\twr32(E1000_EICS,\n\t     (adapter->eims_enable_mask & ~adapter->eims_other));\n}\n\nstatic void igb_reset_task(struct work_struct *work)\n{\n\tstruct igb_adapter *adapter;\n\tadapter = container_of(work, struct igb_adapter, reset_task);\n\n\trtnl_lock();\n\t/* If we're already down or resetting, just bail */\n\tif (test_bit(__IGB_DOWN, &adapter->state) ||\n\t    test_bit(__IGB_RESETTING, &adapter->state)) {\n\t\trtnl_unlock();\n\t\treturn;\n\t}\n\n\tigb_dump(adapter);\n\tnetdev_err(adapter->netdev, \"Reset adapter\\n\");\n\tigb_reinit_locked(adapter);\n\trtnl_unlock();\n}\n\n/**\n *  igb_get_stats64 - Get System Network Statistics\n *  @netdev: network interface device structure\n *  @stats: rtnl_link_stats64 pointer\n **/\nstatic void igb_get_stats64(struct net_device *netdev,\n\t\t\t    struct rtnl_link_stats64 *stats)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\n\tspin_lock(&adapter->stats64_lock);\n\tigb_update_stats(adapter);\n\tmemcpy(stats, &adapter->stats64, sizeof(*stats));\n\tspin_unlock(&adapter->stats64_lock);\n}\n\n/**\n *  igb_change_mtu - Change the Maximum Transfer Unit\n *  @netdev: network interface device structure\n *  @new_mtu: new value for maximum frame size\n *\n *  Returns 0 on success, negative on failure\n **/\nstatic int igb_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tint max_frame = new_mtu + IGB_ETH_PKT_HDR_PAD;\n\n\tif (adapter->xdp_prog) {\n\t\tint i;\n\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\t\tstruct igb_ring *ring = adapter->rx_ring[i];\n\n\t\t\tif (max_frame > igb_rx_bufsz(ring)) {\n\t\t\t\tnetdev_warn(adapter->netdev,\n\t\t\t\t\t    \"Requested MTU size is not supported with XDP. Max frame size is %d\\n\",\n\t\t\t\t\t    max_frame);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* adjust max frame to be at least the size of a standard frame */\n\tif (max_frame < (ETH_FRAME_LEN + ETH_FCS_LEN))\n\t\tmax_frame = ETH_FRAME_LEN + ETH_FCS_LEN;\n\n\twhile (test_and_set_bit(__IGB_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\t/* igb_down has a dependency on max_frame_size */\n\tadapter->max_frame_size = max_frame;\n\n\tif (netif_running(netdev))\n\t\tigb_down(adapter);\n\n\tnetdev_dbg(netdev, \"changing MTU from %d to %d\\n\",\n\t\t   netdev->mtu, new_mtu);\n\tnetdev->mtu = new_mtu;\n\n\tif (netif_running(netdev))\n\t\tigb_up(adapter);\n\telse\n\t\tigb_reset(adapter);\n\n\tclear_bit(__IGB_RESETTING, &adapter->state);\n\n\treturn 0;\n}\n\n/**\n *  igb_update_stats - Update the board statistics counters\n *  @adapter: board private structure\n **/\nvoid igb_update_stats(struct igb_adapter *adapter)\n{\n\tstruct rtnl_link_stats64 *net_stats = &adapter->stats64;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tu32 reg, mpc;\n\tint i;\n\tu64 bytes, packets;\n\tunsigned int start;\n\tu64 _bytes, _packets;\n\n\t/* Prevent stats update while adapter is being reset, or if the pci\n\t * connection is down.\n\t */\n\tif (adapter->link_speed == 0)\n\t\treturn;\n\tif (pci_channel_offline(pdev))\n\t\treturn;\n\n\tbytes = 0;\n\tpackets = 0;\n\n\trcu_read_lock();\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\tstruct igb_ring *ring = adapter->rx_ring[i];\n\t\tu32 rqdpc = rd32(E1000_RQDPC(i));\n\t\tif (hw->mac.type >= e1000_i210)\n\t\t\twr32(E1000_RQDPC(i), 0);\n\n\t\tif (rqdpc) {\n\t\t\tring->rx_stats.drops += rqdpc;\n\t\t\tnet_stats->rx_fifo_errors += rqdpc;\n\t\t}\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin_irq(&ring->rx_syncp);\n\t\t\t_bytes = ring->rx_stats.bytes;\n\t\t\t_packets = ring->rx_stats.packets;\n\t\t} while (u64_stats_fetch_retry_irq(&ring->rx_syncp, start));\n\t\tbytes += _bytes;\n\t\tpackets += _packets;\n\t}\n\n\tnet_stats->rx_bytes = bytes;\n\tnet_stats->rx_packets = packets;\n\n\tbytes = 0;\n\tpackets = 0;\n\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\tstruct igb_ring *ring = adapter->tx_ring[i];\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin_irq(&ring->tx_syncp);\n\t\t\t_bytes = ring->tx_stats.bytes;\n\t\t\t_packets = ring->tx_stats.packets;\n\t\t} while (u64_stats_fetch_retry_irq(&ring->tx_syncp, start));\n\t\tbytes += _bytes;\n\t\tpackets += _packets;\n\t}\n\tnet_stats->tx_bytes = bytes;\n\tnet_stats->tx_packets = packets;\n\trcu_read_unlock();\n\n\t/* read stats registers */\n\tadapter->stats.crcerrs += rd32(E1000_CRCERRS);\n\tadapter->stats.gprc += rd32(E1000_GPRC);\n\tadapter->stats.gorc += rd32(E1000_GORCL);\n\trd32(E1000_GORCH); /* clear GORCL */\n\tadapter->stats.bprc += rd32(E1000_BPRC);\n\tadapter->stats.mprc += rd32(E1000_MPRC);\n\tadapter->stats.roc += rd32(E1000_ROC);\n\n\tadapter->stats.prc64 += rd32(E1000_PRC64);\n\tadapter->stats.prc127 += rd32(E1000_PRC127);\n\tadapter->stats.prc255 += rd32(E1000_PRC255);\n\tadapter->stats.prc511 += rd32(E1000_PRC511);\n\tadapter->stats.prc1023 += rd32(E1000_PRC1023);\n\tadapter->stats.prc1522 += rd32(E1000_PRC1522);\n\tadapter->stats.symerrs += rd32(E1000_SYMERRS);\n\tadapter->stats.sec += rd32(E1000_SEC);\n\n\tmpc = rd32(E1000_MPC);\n\tadapter->stats.mpc += mpc;\n\tnet_stats->rx_fifo_errors += mpc;\n\tadapter->stats.scc += rd32(E1000_SCC);\n\tadapter->stats.ecol += rd32(E1000_ECOL);\n\tadapter->stats.mcc += rd32(E1000_MCC);\n\tadapter->stats.latecol += rd32(E1000_LATECOL);\n\tadapter->stats.dc += rd32(E1000_DC);\n\tadapter->stats.rlec += rd32(E1000_RLEC);\n\tadapter->stats.xonrxc += rd32(E1000_XONRXC);\n\tadapter->stats.xontxc += rd32(E1000_XONTXC);\n\tadapter->stats.xoffrxc += rd32(E1000_XOFFRXC);\n\tadapter->stats.xofftxc += rd32(E1000_XOFFTXC);\n\tadapter->stats.fcruc += rd32(E1000_FCRUC);\n\tadapter->stats.gptc += rd32(E1000_GPTC);\n\tadapter->stats.gotc += rd32(E1000_GOTCL);\n\trd32(E1000_GOTCH); /* clear GOTCL */\n\tadapter->stats.rnbc += rd32(E1000_RNBC);\n\tadapter->stats.ruc += rd32(E1000_RUC);\n\tadapter->stats.rfc += rd32(E1000_RFC);\n\tadapter->stats.rjc += rd32(E1000_RJC);\n\tadapter->stats.tor += rd32(E1000_TORH);\n\tadapter->stats.tot += rd32(E1000_TOTH);\n\tadapter->stats.tpr += rd32(E1000_TPR);\n\n\tadapter->stats.ptc64 += rd32(E1000_PTC64);\n\tadapter->stats.ptc127 += rd32(E1000_PTC127);\n\tadapter->stats.ptc255 += rd32(E1000_PTC255);\n\tadapter->stats.ptc511 += rd32(E1000_PTC511);\n\tadapter->stats.ptc1023 += rd32(E1000_PTC1023);\n\tadapter->stats.ptc1522 += rd32(E1000_PTC1522);\n\n\tadapter->stats.mptc += rd32(E1000_MPTC);\n\tadapter->stats.bptc += rd32(E1000_BPTC);\n\n\tadapter->stats.tpt += rd32(E1000_TPT);\n\tadapter->stats.colc += rd32(E1000_COLC);\n\n\tadapter->stats.algnerrc += rd32(E1000_ALGNERRC);\n\t/* read internal phy specific stats */\n\treg = rd32(E1000_CTRL_EXT);\n\tif (!(reg & E1000_CTRL_EXT_LINK_MODE_MASK)) {\n\t\tadapter->stats.rxerrc += rd32(E1000_RXERRC);\n\n\t\t/* this stat has invalid values on i210/i211 */\n\t\tif ((hw->mac.type != e1000_i210) &&\n\t\t    (hw->mac.type != e1000_i211))\n\t\t\tadapter->stats.tncrs += rd32(E1000_TNCRS);\n\t}\n\n\tadapter->stats.tsctc += rd32(E1000_TSCTC);\n\tadapter->stats.tsctfc += rd32(E1000_TSCTFC);\n\n\tadapter->stats.iac += rd32(E1000_IAC);\n\tadapter->stats.icrxoc += rd32(E1000_ICRXOC);\n\tadapter->stats.icrxptc += rd32(E1000_ICRXPTC);\n\tadapter->stats.icrxatc += rd32(E1000_ICRXATC);\n\tadapter->stats.ictxptc += rd32(E1000_ICTXPTC);\n\tadapter->stats.ictxatc += rd32(E1000_ICTXATC);\n\tadapter->stats.ictxqec += rd32(E1000_ICTXQEC);\n\tadapter->stats.ictxqmtc += rd32(E1000_ICTXQMTC);\n\tadapter->stats.icrxdmtc += rd32(E1000_ICRXDMTC);\n\n\t/* Fill out the OS statistics structure */\n\tnet_stats->multicast = adapter->stats.mprc;\n\tnet_stats->collisions = adapter->stats.colc;\n\n\t/* Rx Errors */\n\n\t/* RLEC on some newer hardware can be incorrect so build\n\t * our own version based on RUC and ROC\n\t */\n\tnet_stats->rx_errors = adapter->stats.rxerrc +\n\t\tadapter->stats.crcerrs + adapter->stats.algnerrc +\n\t\tadapter->stats.ruc + adapter->stats.roc +\n\t\tadapter->stats.cexterr;\n\tnet_stats->rx_length_errors = adapter->stats.ruc +\n\t\t\t\t      adapter->stats.roc;\n\tnet_stats->rx_crc_errors = adapter->stats.crcerrs;\n\tnet_stats->rx_frame_errors = adapter->stats.algnerrc;\n\tnet_stats->rx_missed_errors = adapter->stats.mpc;\n\n\t/* Tx Errors */\n\tnet_stats->tx_errors = adapter->stats.ecol +\n\t\t\t       adapter->stats.latecol;\n\tnet_stats->tx_aborted_errors = adapter->stats.ecol;\n\tnet_stats->tx_window_errors = adapter->stats.latecol;\n\tnet_stats->tx_carrier_errors = adapter->stats.tncrs;\n\n\t/* Tx Dropped needs to be maintained elsewhere */\n\n\t/* Management Stats */\n\tadapter->stats.mgptc += rd32(E1000_MGTPTC);\n\tadapter->stats.mgprc += rd32(E1000_MGTPRC);\n\tadapter->stats.mgpdc += rd32(E1000_MGTPDC);\n\n\t/* OS2BMC Stats */\n\treg = rd32(E1000_MANC);\n\tif (reg & E1000_MANC_EN_BMC2OS) {\n\t\tadapter->stats.o2bgptc += rd32(E1000_O2BGPTC);\n\t\tadapter->stats.o2bspc += rd32(E1000_O2BSPC);\n\t\tadapter->stats.b2ospc += rd32(E1000_B2OSPC);\n\t\tadapter->stats.b2ogprc += rd32(E1000_B2OGPRC);\n\t}\n}\n\nstatic void igb_tsync_interrupt(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct ptp_clock_event event;\n\tstruct timespec64 ts;\n\tu32 ack = 0, tsauxc, sec, nsec, tsicr = rd32(E1000_TSICR);\n\n\tif (tsicr & TSINTR_SYS_WRAP) {\n\t\tevent.type = PTP_CLOCK_PPS;\n\t\tif (adapter->ptp_caps.pps)\n\t\t\tptp_clock_event(adapter->ptp_clock, &event);\n\t\tack |= TSINTR_SYS_WRAP;\n\t}\n\n\tif (tsicr & E1000_TSICR_TXTS) {\n\t\t/* retrieve hardware timestamp */\n\t\tschedule_work(&adapter->ptp_tx_work);\n\t\tack |= E1000_TSICR_TXTS;\n\t}\n\n\tif (tsicr & TSINTR_TT0) {\n\t\tspin_lock(&adapter->tmreg_lock);\n\t\tts = timespec64_add(adapter->perout[0].start,\n\t\t\t\t    adapter->perout[0].period);\n\t\t/* u32 conversion of tv_sec is safe until y2106 */\n\t\twr32(E1000_TRGTTIML0, ts.tv_nsec);\n\t\twr32(E1000_TRGTTIMH0, (u32)ts.tv_sec);\n\t\ttsauxc = rd32(E1000_TSAUXC);\n\t\ttsauxc |= TSAUXC_EN_TT0;\n\t\twr32(E1000_TSAUXC, tsauxc);\n\t\tadapter->perout[0].start = ts;\n\t\tspin_unlock(&adapter->tmreg_lock);\n\t\tack |= TSINTR_TT0;\n\t}\n\n\tif (tsicr & TSINTR_TT1) {\n\t\tspin_lock(&adapter->tmreg_lock);\n\t\tts = timespec64_add(adapter->perout[1].start,\n\t\t\t\t    adapter->perout[1].period);\n\t\twr32(E1000_TRGTTIML1, ts.tv_nsec);\n\t\twr32(E1000_TRGTTIMH1, (u32)ts.tv_sec);\n\t\ttsauxc = rd32(E1000_TSAUXC);\n\t\ttsauxc |= TSAUXC_EN_TT1;\n\t\twr32(E1000_TSAUXC, tsauxc);\n\t\tadapter->perout[1].start = ts;\n\t\tspin_unlock(&adapter->tmreg_lock);\n\t\tack |= TSINTR_TT1;\n\t}\n\n\tif (tsicr & TSINTR_AUTT0) {\n\t\tnsec = rd32(E1000_AUXSTMPL0);\n\t\tsec  = rd32(E1000_AUXSTMPH0);\n\t\tevent.type = PTP_CLOCK_EXTTS;\n\t\tevent.index = 0;\n\t\tevent.timestamp = sec * 1000000000ULL + nsec;\n\t\tptp_clock_event(adapter->ptp_clock, &event);\n\t\tack |= TSINTR_AUTT0;\n\t}\n\n\tif (tsicr & TSINTR_AUTT1) {\n\t\tnsec = rd32(E1000_AUXSTMPL1);\n\t\tsec  = rd32(E1000_AUXSTMPH1);\n\t\tevent.type = PTP_CLOCK_EXTTS;\n\t\tevent.index = 1;\n\t\tevent.timestamp = sec * 1000000000ULL + nsec;\n\t\tptp_clock_event(adapter->ptp_clock, &event);\n\t\tack |= TSINTR_AUTT1;\n\t}\n\n\t/* acknowledge the interrupts */\n\twr32(E1000_TSICR, ack);\n}\n\nstatic irqreturn_t igb_msix_other(int irq, void *data)\n{\n\tstruct igb_adapter *adapter = data;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 icr = rd32(E1000_ICR);\n\t/* reading ICR causes bit 31 of EICR to be cleared */\n\n\tif (icr & E1000_ICR_DRSTA)\n\t\tschedule_work(&adapter->reset_task);\n\n\tif (icr & E1000_ICR_DOUTSYNC) {\n\t\t/* HW is reporting DMA is out of sync */\n\t\tadapter->stats.doosync++;\n\t\t/* The DMA Out of Sync is also indication of a spoof event\n\t\t * in IOV mode. Check the Wrong VM Behavior register to\n\t\t * see if it is really a spoof event.\n\t\t */\n\t\tigb_check_wvbr(adapter);\n\t}\n\n\t/* Check for a mailbox event */\n\tif (icr & E1000_ICR_VMMB)\n\t\tigb_msg_task(adapter);\n\n\tif (icr & E1000_ICR_LSC) {\n\t\thw->mac.get_link_status = 1;\n\t\t/* guard against interrupt when we're going down */\n\t\tif (!test_bit(__IGB_DOWN, &adapter->state))\n\t\t\tmod_timer(&adapter->watchdog_timer, jiffies + 1);\n\t}\n\n\tif (icr & E1000_ICR_TS)\n\t\tigb_tsync_interrupt(adapter);\n\n\twr32(E1000_EIMS, adapter->eims_other);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void igb_write_itr(struct igb_q_vector *q_vector)\n{\n\tstruct igb_adapter *adapter = q_vector->adapter;\n\tu32 itr_val = q_vector->itr_val & 0x7FFC;\n\n\tif (!q_vector->set_itr)\n\t\treturn;\n\n\tif (!itr_val)\n\t\titr_val = 0x4;\n\n\tif (adapter->hw.mac.type == e1000_82575)\n\t\titr_val |= itr_val << 16;\n\telse\n\t\titr_val |= E1000_EITR_CNT_IGNR;\n\n\twritel(itr_val, q_vector->itr_register);\n\tq_vector->set_itr = 0;\n}\n\nstatic irqreturn_t igb_msix_ring(int irq, void *data)\n{\n\tstruct igb_q_vector *q_vector = data;\n\n\t/* Write the ITR value calculated from the previous interrupt. */\n\tigb_write_itr(q_vector);\n\n\tnapi_schedule(&q_vector->napi);\n\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_IGB_DCA\nstatic void igb_update_tx_dca(struct igb_adapter *adapter,\n\t\t\t      struct igb_ring *tx_ring,\n\t\t\t      int cpu)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 txctrl = dca3_get_tag(tx_ring->dev, cpu);\n\n\tif (hw->mac.type != e1000_82575)\n\t\ttxctrl <<= E1000_DCA_TXCTRL_CPUID_SHIFT;\n\n\t/* We can enable relaxed ordering for reads, but not writes when\n\t * DCA is enabled.  This is due to a known issue in some chipsets\n\t * which will cause the DCA tag to be cleared.\n\t */\n\ttxctrl |= E1000_DCA_TXCTRL_DESC_RRO_EN |\n\t\t  E1000_DCA_TXCTRL_DATA_RRO_EN |\n\t\t  E1000_DCA_TXCTRL_DESC_DCA_EN;\n\n\twr32(E1000_DCA_TXCTRL(tx_ring->reg_idx), txctrl);\n}\n\nstatic void igb_update_rx_dca(struct igb_adapter *adapter,\n\t\t\t      struct igb_ring *rx_ring,\n\t\t\t      int cpu)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rxctrl = dca3_get_tag(&adapter->pdev->dev, cpu);\n\n\tif (hw->mac.type != e1000_82575)\n\t\trxctrl <<= E1000_DCA_RXCTRL_CPUID_SHIFT;\n\n\t/* We can enable relaxed ordering for reads, but not writes when\n\t * DCA is enabled.  This is due to a known issue in some chipsets\n\t * which will cause the DCA tag to be cleared.\n\t */\n\trxctrl |= E1000_DCA_RXCTRL_DESC_RRO_EN |\n\t\t  E1000_DCA_RXCTRL_DESC_DCA_EN;\n\n\twr32(E1000_DCA_RXCTRL(rx_ring->reg_idx), rxctrl);\n}\n\nstatic void igb_update_dca(struct igb_q_vector *q_vector)\n{\n\tstruct igb_adapter *adapter = q_vector->adapter;\n\tint cpu = get_cpu();\n\n\tif (q_vector->cpu == cpu)\n\t\tgoto out_no_update;\n\n\tif (q_vector->tx.ring)\n\t\tigb_update_tx_dca(adapter, q_vector->tx.ring, cpu);\n\n\tif (q_vector->rx.ring)\n\t\tigb_update_rx_dca(adapter, q_vector->rx.ring, cpu);\n\n\tq_vector->cpu = cpu;\nout_no_update:\n\tput_cpu();\n}\n\nstatic void igb_setup_dca(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint i;\n\n\tif (!(adapter->flags & IGB_FLAG_DCA_ENABLED))\n\t\treturn;\n\n\t/* Always use CB2 mode, difference is masked in the CB driver. */\n\twr32(E1000_DCA_CTRL, E1000_DCA_CTRL_DCA_MODE_CB2);\n\n\tfor (i = 0; i < adapter->num_q_vectors; i++) {\n\t\tadapter->q_vector[i]->cpu = -1;\n\t\tigb_update_dca(adapter->q_vector[i]);\n\t}\n}\n\nstatic int __igb_notify_dca(struct device *dev, void *data)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev);\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunsigned long event = *(unsigned long *)data;\n\n\tswitch (event) {\n\tcase DCA_PROVIDER_ADD:\n\t\t/* if already enabled, don't do it again */\n\t\tif (adapter->flags & IGB_FLAG_DCA_ENABLED)\n\t\t\tbreak;\n\t\tif (dca_add_requester(dev) == 0) {\n\t\t\tadapter->flags |= IGB_FLAG_DCA_ENABLED;\n\t\t\tdev_info(&pdev->dev, \"DCA enabled\\n\");\n\t\t\tigb_setup_dca(adapter);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough; /* since DCA is disabled. */\n\tcase DCA_PROVIDER_REMOVE:\n\t\tif (adapter->flags & IGB_FLAG_DCA_ENABLED) {\n\t\t\t/* without this a class_device is left\n\t\t\t * hanging around in the sysfs model\n\t\t\t */\n\t\t\tdca_remove_requester(dev);\n\t\t\tdev_info(&pdev->dev, \"DCA disabled\\n\");\n\t\t\tadapter->flags &= ~IGB_FLAG_DCA_ENABLED;\n\t\t\twr32(E1000_DCA_CTRL, E1000_DCA_CTRL_DCA_MODE_DISABLE);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int igb_notify_dca(struct notifier_block *nb, unsigned long event,\n\t\t\t  void *p)\n{\n\tint ret_val;\n\n\tret_val = driver_for_each_device(&igb_driver.driver, NULL, &event,\n\t\t\t\t\t __igb_notify_dca);\n\n\treturn ret_val ? NOTIFY_BAD : NOTIFY_DONE;\n}\n#endif /* CONFIG_IGB_DCA */\n\n#ifdef CONFIG_PCI_IOV\nstatic int igb_vf_configure(struct igb_adapter *adapter, int vf)\n{\n\tunsigned char mac_addr[ETH_ALEN];\n\n\teth_zero_addr(mac_addr);\n\tigb_set_vf_mac(adapter, vf, mac_addr);\n\n\t/* By default spoof check is enabled for all VFs */\n\tadapter->vf_data[vf].spoofchk_enabled = true;\n\n\t/* By default VFs are not trusted */\n\tadapter->vf_data[vf].trusted = false;\n\n\treturn 0;\n}\n\n#endif\nstatic void igb_ping_all_vfs(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ping;\n\tint i;\n\n\tfor (i = 0 ; i < adapter->vfs_allocated_count; i++) {\n\t\tping = E1000_PF_CONTROL_MSG;\n\t\tif (adapter->vf_data[i].flags & IGB_VF_FLAG_CTS)\n\t\t\tping |= E1000_VT_MSGTYPE_CTS;\n\t\tigb_write_mbx(hw, &ping, 1, i);\n\t}\n}\n\nstatic int igb_set_vf_promisc(struct igb_adapter *adapter, u32 *msgbuf, u32 vf)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 vmolr = rd32(E1000_VMOLR(vf));\n\tstruct vf_data_storage *vf_data = &adapter->vf_data[vf];\n\n\tvf_data->flags &= ~(IGB_VF_FLAG_UNI_PROMISC |\n\t\t\t    IGB_VF_FLAG_MULTI_PROMISC);\n\tvmolr &= ~(E1000_VMOLR_ROPE | E1000_VMOLR_ROMPE | E1000_VMOLR_MPME);\n\n\tif (*msgbuf & E1000_VF_SET_PROMISC_MULTICAST) {\n\t\tvmolr |= E1000_VMOLR_MPME;\n\t\tvf_data->flags |= IGB_VF_FLAG_MULTI_PROMISC;\n\t\t*msgbuf &= ~E1000_VF_SET_PROMISC_MULTICAST;\n\t} else {\n\t\t/* if we have hashes and we are clearing a multicast promisc\n\t\t * flag we need to write the hashes to the MTA as this step\n\t\t * was previously skipped\n\t\t */\n\t\tif (vf_data->num_vf_mc_hashes > 30) {\n\t\t\tvmolr |= E1000_VMOLR_MPME;\n\t\t} else if (vf_data->num_vf_mc_hashes) {\n\t\t\tint j;\n\n\t\t\tvmolr |= E1000_VMOLR_ROMPE;\n\t\t\tfor (j = 0; j < vf_data->num_vf_mc_hashes; j++)\n\t\t\t\tigb_mta_set(hw, vf_data->vf_mc_hashes[j]);\n\t\t}\n\t}\n\n\twr32(E1000_VMOLR(vf), vmolr);\n\n\t/* there are flags left unprocessed, likely not supported */\n\tif (*msgbuf & E1000_VT_MSGINFO_MASK)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int igb_set_vf_multicasts(struct igb_adapter *adapter,\n\t\t\t\t  u32 *msgbuf, u32 vf)\n{\n\tint n = (msgbuf[0] & E1000_VT_MSGINFO_MASK) >> E1000_VT_MSGINFO_SHIFT;\n\tu16 *hash_list = (u16 *)&msgbuf[1];\n\tstruct vf_data_storage *vf_data = &adapter->vf_data[vf];\n\tint i;\n\n\t/* salt away the number of multicast addresses assigned\n\t * to this VF for later use to restore when the PF multi cast\n\t * list changes\n\t */\n\tvf_data->num_vf_mc_hashes = n;\n\n\t/* only up to 30 hash values supported */\n\tif (n > 30)\n\t\tn = 30;\n\n\t/* store the hashes for later use */\n\tfor (i = 0; i < n; i++)\n\t\tvf_data->vf_mc_hashes[i] = hash_list[i];\n\n\t/* Flush and reset the mta with the new values */\n\tigb_set_rx_mode(adapter->netdev);\n\n\treturn 0;\n}\n\nstatic void igb_restore_vf_multicasts(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct vf_data_storage *vf_data;\n\tint i, j;\n\n\tfor (i = 0; i < adapter->vfs_allocated_count; i++) {\n\t\tu32 vmolr = rd32(E1000_VMOLR(i));\n\n\t\tvmolr &= ~(E1000_VMOLR_ROMPE | E1000_VMOLR_MPME);\n\n\t\tvf_data = &adapter->vf_data[i];\n\n\t\tif ((vf_data->num_vf_mc_hashes > 30) ||\n\t\t    (vf_data->flags & IGB_VF_FLAG_MULTI_PROMISC)) {\n\t\t\tvmolr |= E1000_VMOLR_MPME;\n\t\t} else if (vf_data->num_vf_mc_hashes) {\n\t\t\tvmolr |= E1000_VMOLR_ROMPE;\n\t\t\tfor (j = 0; j < vf_data->num_vf_mc_hashes; j++)\n\t\t\t\tigb_mta_set(hw, vf_data->vf_mc_hashes[j]);\n\t\t}\n\t\twr32(E1000_VMOLR(i), vmolr);\n\t}\n}\n\nstatic void igb_clear_vf_vfta(struct igb_adapter *adapter, u32 vf)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 pool_mask, vlvf_mask, i;\n\n\t/* create mask for VF and other pools */\n\tpool_mask = E1000_VLVF_POOLSEL_MASK;\n\tvlvf_mask = BIT(E1000_VLVF_POOLSEL_SHIFT + vf);\n\n\t/* drop PF from pool bits */\n\tpool_mask &= ~BIT(E1000_VLVF_POOLSEL_SHIFT +\n\t\t\t     adapter->vfs_allocated_count);\n\n\t/* Find the vlan filter for this id */\n\tfor (i = E1000_VLVF_ARRAY_SIZE; i--;) {\n\t\tu32 vlvf = rd32(E1000_VLVF(i));\n\t\tu32 vfta_mask, vid, vfta;\n\n\t\t/* remove the vf from the pool */\n\t\tif (!(vlvf & vlvf_mask))\n\t\t\tcontinue;\n\n\t\t/* clear out bit from VLVF */\n\t\tvlvf ^= vlvf_mask;\n\n\t\t/* if other pools are present, just remove ourselves */\n\t\tif (vlvf & pool_mask)\n\t\t\tgoto update_vlvfb;\n\n\t\t/* if PF is present, leave VFTA */\n\t\tif (vlvf & E1000_VLVF_POOLSEL_MASK)\n\t\t\tgoto update_vlvf;\n\n\t\tvid = vlvf & E1000_VLVF_VLANID_MASK;\n\t\tvfta_mask = BIT(vid % 32);\n\n\t\t/* clear bit from VFTA */\n\t\tvfta = adapter->shadow_vfta[vid / 32];\n\t\tif (vfta & vfta_mask)\n\t\t\thw->mac.ops.write_vfta(hw, vid / 32, vfta ^ vfta_mask);\nupdate_vlvf:\n\t\t/* clear pool selection enable */\n\t\tif (adapter->flags & IGB_FLAG_VLAN_PROMISC)\n\t\t\tvlvf &= E1000_VLVF_POOLSEL_MASK;\n\t\telse\n\t\t\tvlvf = 0;\nupdate_vlvfb:\n\t\t/* clear pool bits */\n\t\twr32(E1000_VLVF(i), vlvf);\n\t}\n}\n\nstatic int igb_find_vlvf_entry(struct e1000_hw *hw, u32 vlan)\n{\n\tu32 vlvf;\n\tint idx;\n\n\t/* short cut the special case */\n\tif (vlan == 0)\n\t\treturn 0;\n\n\t/* Search for the VLAN id in the VLVF entries */\n\tfor (idx = E1000_VLVF_ARRAY_SIZE; --idx;) {\n\t\tvlvf = rd32(E1000_VLVF(idx));\n\t\tif ((vlvf & VLAN_VID_MASK) == vlan)\n\t\t\tbreak;\n\t}\n\n\treturn idx;\n}\n\nstatic void igb_update_pf_vlvf(struct igb_adapter *adapter, u32 vid)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 bits, pf_id;\n\tint idx;\n\n\tidx = igb_find_vlvf_entry(hw, vid);\n\tif (!idx)\n\t\treturn;\n\n\t/* See if any other pools are set for this VLAN filter\n\t * entry other than the PF.\n\t */\n\tpf_id = adapter->vfs_allocated_count + E1000_VLVF_POOLSEL_SHIFT;\n\tbits = ~BIT(pf_id) & E1000_VLVF_POOLSEL_MASK;\n\tbits &= rd32(E1000_VLVF(idx));\n\n\t/* Disable the filter so this falls into the default pool. */\n\tif (!bits) {\n\t\tif (adapter->flags & IGB_FLAG_VLAN_PROMISC)\n\t\t\twr32(E1000_VLVF(idx), BIT(pf_id));\n\t\telse\n\t\t\twr32(E1000_VLVF(idx), 0);\n\t}\n}\n\nstatic s32 igb_set_vf_vlan(struct igb_adapter *adapter, u32 vid,\n\t\t\t   bool add, u32 vf)\n{\n\tint pf_id = adapter->vfs_allocated_count;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint err;\n\n\t/* If VLAN overlaps with one the PF is currently monitoring make\n\t * sure that we are able to allocate a VLVF entry.  This may be\n\t * redundant but it guarantees PF will maintain visibility to\n\t * the VLAN.\n\t */\n\tif (add && test_bit(vid, adapter->active_vlans)) {\n\t\terr = igb_vfta_set(hw, vid, pf_id, true, false);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = igb_vfta_set(hw, vid, vf, add, false);\n\n\tif (add && !err)\n\t\treturn err;\n\n\t/* If we failed to add the VF VLAN or we are removing the VF VLAN\n\t * we may need to drop the PF pool bit in order to allow us to free\n\t * up the VLVF resources.\n\t */\n\tif (test_bit(vid, adapter->active_vlans) ||\n\t    (adapter->flags & IGB_FLAG_VLAN_PROMISC))\n\t\tigb_update_pf_vlvf(adapter, vid);\n\n\treturn err;\n}\n\nstatic void igb_set_vmvir(struct igb_adapter *adapter, u32 vid, u32 vf)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (vid)\n\t\twr32(E1000_VMVIR(vf), (vid | E1000_VMVIR_VLANA_DEFAULT));\n\telse\n\t\twr32(E1000_VMVIR(vf), 0);\n}\n\nstatic int igb_enable_port_vlan(struct igb_adapter *adapter, int vf,\n\t\t\t\tu16 vlan, u8 qos)\n{\n\tint err;\n\n\terr = igb_set_vf_vlan(adapter, vlan, true, vf);\n\tif (err)\n\t\treturn err;\n\n\tigb_set_vmvir(adapter, vlan | (qos << VLAN_PRIO_SHIFT), vf);\n\tigb_set_vmolr(adapter, vf, !vlan);\n\n\t/* revoke access to previous VLAN */\n\tif (vlan != adapter->vf_data[vf].pf_vlan)\n\t\tigb_set_vf_vlan(adapter, adapter->vf_data[vf].pf_vlan,\n\t\t\t\tfalse, vf);\n\n\tadapter->vf_data[vf].pf_vlan = vlan;\n\tadapter->vf_data[vf].pf_qos = qos;\n\tigb_set_vf_vlan_strip(adapter, vf, true);\n\tdev_info(&adapter->pdev->dev,\n\t\t \"Setting VLAN %d, QOS 0x%x on VF %d\\n\", vlan, qos, vf);\n\tif (test_bit(__IGB_DOWN, &adapter->state)) {\n\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t \"The VF VLAN has been set, but the PF device is not up.\\n\");\n\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t \"Bring the PF device up before attempting to use the VF device.\\n\");\n\t}\n\n\treturn err;\n}\n\nstatic int igb_disable_port_vlan(struct igb_adapter *adapter, int vf)\n{\n\t/* Restore tagless access via VLAN 0 */\n\tigb_set_vf_vlan(adapter, 0, true, vf);\n\n\tigb_set_vmvir(adapter, 0, vf);\n\tigb_set_vmolr(adapter, vf, true);\n\n\t/* Remove any PF assigned VLAN */\n\tif (adapter->vf_data[vf].pf_vlan)\n\t\tigb_set_vf_vlan(adapter, adapter->vf_data[vf].pf_vlan,\n\t\t\t\tfalse, vf);\n\n\tadapter->vf_data[vf].pf_vlan = 0;\n\tadapter->vf_data[vf].pf_qos = 0;\n\tigb_set_vf_vlan_strip(adapter, vf, false);\n\n\treturn 0;\n}\n\nstatic int igb_ndo_set_vf_vlan(struct net_device *netdev, int vf,\n\t\t\t       u16 vlan, u8 qos, __be16 vlan_proto)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\n\tif ((vf >= adapter->vfs_allocated_count) || (vlan > 4095) || (qos > 7))\n\t\treturn -EINVAL;\n\n\tif (vlan_proto != htons(ETH_P_8021Q))\n\t\treturn -EPROTONOSUPPORT;\n\n\treturn (vlan || qos) ? igb_enable_port_vlan(adapter, vf, vlan, qos) :\n\t\t\t       igb_disable_port_vlan(adapter, vf);\n}\n\nstatic int igb_set_vf_vlan_msg(struct igb_adapter *adapter, u32 *msgbuf, u32 vf)\n{\n\tint add = (msgbuf[0] & E1000_VT_MSGINFO_MASK) >> E1000_VT_MSGINFO_SHIFT;\n\tint vid = (msgbuf[1] & E1000_VLVF_VLANID_MASK);\n\tint ret;\n\n\tif (adapter->vf_data[vf].pf_vlan)\n\t\treturn -1;\n\n\t/* VLAN 0 is a special case, don't allow it to be removed */\n\tif (!vid && !add)\n\t\treturn 0;\n\n\tret = igb_set_vf_vlan(adapter, vid, !!add, vf);\n\tif (!ret)\n\t\tigb_set_vf_vlan_strip(adapter, vf, !!vid);\n\treturn ret;\n}\n\nstatic inline void igb_vf_reset(struct igb_adapter *adapter, u32 vf)\n{\n\tstruct vf_data_storage *vf_data = &adapter->vf_data[vf];\n\n\t/* clear flags - except flag that indicates PF has set the MAC */\n\tvf_data->flags &= IGB_VF_FLAG_PF_SET_MAC;\n\tvf_data->last_nack = jiffies;\n\n\t/* reset vlans for device */\n\tigb_clear_vf_vfta(adapter, vf);\n\tigb_set_vf_vlan(adapter, vf_data->pf_vlan, true, vf);\n\tigb_set_vmvir(adapter, vf_data->pf_vlan |\n\t\t\t       (vf_data->pf_qos << VLAN_PRIO_SHIFT), vf);\n\tigb_set_vmolr(adapter, vf, !vf_data->pf_vlan);\n\tigb_set_vf_vlan_strip(adapter, vf, !!(vf_data->pf_vlan));\n\n\t/* reset multicast table array for vf */\n\tadapter->vf_data[vf].num_vf_mc_hashes = 0;\n\n\t/* Flush and reset the mta with the new values */\n\tigb_set_rx_mode(adapter->netdev);\n}\n\nstatic void igb_vf_reset_event(struct igb_adapter *adapter, u32 vf)\n{\n\tunsigned char *vf_mac = adapter->vf_data[vf].vf_mac_addresses;\n\n\t/* clear mac address as we were hotplug removed/added */\n\tif (!(adapter->vf_data[vf].flags & IGB_VF_FLAG_PF_SET_MAC))\n\t\teth_zero_addr(vf_mac);\n\n\t/* process remaining reset events */\n\tigb_vf_reset(adapter, vf);\n}\n\nstatic void igb_vf_reset_msg(struct igb_adapter *adapter, u32 vf)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunsigned char *vf_mac = adapter->vf_data[vf].vf_mac_addresses;\n\tu32 reg, msgbuf[3];\n\tu8 *addr = (u8 *)(&msgbuf[1]);\n\n\t/* process all the same items cleared in a function level reset */\n\tigb_vf_reset(adapter, vf);\n\n\t/* set vf mac address */\n\tigb_set_vf_mac(adapter, vf, vf_mac);\n\n\t/* enable transmit and receive for vf */\n\treg = rd32(E1000_VFTE);\n\twr32(E1000_VFTE, reg | BIT(vf));\n\treg = rd32(E1000_VFRE);\n\twr32(E1000_VFRE, reg | BIT(vf));\n\n\tadapter->vf_data[vf].flags |= IGB_VF_FLAG_CTS;\n\n\t/* reply to reset with ack and vf mac address */\n\tif (!is_zero_ether_addr(vf_mac)) {\n\t\tmsgbuf[0] = E1000_VF_RESET | E1000_VT_MSGTYPE_ACK;\n\t\tmemcpy(addr, vf_mac, ETH_ALEN);\n\t} else {\n\t\tmsgbuf[0] = E1000_VF_RESET | E1000_VT_MSGTYPE_NACK;\n\t}\n\tigb_write_mbx(hw, msgbuf, 3, vf);\n}\n\nstatic void igb_flush_mac_table(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint i;\n\n\tfor (i = 0; i < hw->mac.rar_entry_count; i++) {\n\t\tadapter->mac_table[i].state &= ~IGB_MAC_STATE_IN_USE;\n\t\teth_zero_addr(adapter->mac_table[i].addr);\n\t\tadapter->mac_table[i].queue = 0;\n\t\tigb_rar_set_index(adapter, i);\n\t}\n}\n\nstatic int igb_available_rars(struct igb_adapter *adapter, u8 queue)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\t/* do not count rar entries reserved for VFs MAC addresses */\n\tint rar_entries = hw->mac.rar_entry_count -\n\t\t\t  adapter->vfs_allocated_count;\n\tint i, count = 0;\n\n\tfor (i = 0; i < rar_entries; i++) {\n\t\t/* do not count default entries */\n\t\tif (adapter->mac_table[i].state & IGB_MAC_STATE_DEFAULT)\n\t\t\tcontinue;\n\n\t\t/* do not count \"in use\" entries for different queues */\n\t\tif ((adapter->mac_table[i].state & IGB_MAC_STATE_IN_USE) &&\n\t\t    (adapter->mac_table[i].queue != queue))\n\t\t\tcontinue;\n\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\n/* Set default MAC address for the PF in the first RAR entry */\nstatic void igb_set_default_mac_filter(struct igb_adapter *adapter)\n{\n\tstruct igb_mac_addr *mac_table = &adapter->mac_table[0];\n\n\tether_addr_copy(mac_table->addr, adapter->hw.mac.addr);\n\tmac_table->queue = adapter->vfs_allocated_count;\n\tmac_table->state = IGB_MAC_STATE_DEFAULT | IGB_MAC_STATE_IN_USE;\n\n\tigb_rar_set_index(adapter, 0);\n}\n\n/* If the filter to be added and an already existing filter express\n * the same address and address type, it should be possible to only\n * override the other configurations, for example the queue to steer\n * traffic.\n */\nstatic bool igb_mac_entry_can_be_used(const struct igb_mac_addr *entry,\n\t\t\t\t      const u8 *addr, const u8 flags)\n{\n\tif (!(entry->state & IGB_MAC_STATE_IN_USE))\n\t\treturn true;\n\n\tif ((entry->state & IGB_MAC_STATE_SRC_ADDR) !=\n\t    (flags & IGB_MAC_STATE_SRC_ADDR))\n\t\treturn false;\n\n\tif (!ether_addr_equal(addr, entry->addr))\n\t\treturn false;\n\n\treturn true;\n}\n\n/* Add a MAC filter for 'addr' directing matching traffic to 'queue',\n * 'flags' is used to indicate what kind of match is made, match is by\n * default for the destination address, if matching by source address\n * is desired the flag IGB_MAC_STATE_SRC_ADDR can be used.\n */\nstatic int igb_add_mac_filter_flags(struct igb_adapter *adapter,\n\t\t\t\t    const u8 *addr, const u8 queue,\n\t\t\t\t    const u8 flags)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint rar_entries = hw->mac.rar_entry_count -\n\t\t\t  adapter->vfs_allocated_count;\n\tint i;\n\n\tif (is_zero_ether_addr(addr))\n\t\treturn -EINVAL;\n\n\t/* Search for the first empty entry in the MAC table.\n\t * Do not touch entries at the end of the table reserved for the VF MAC\n\t * addresses.\n\t */\n\tfor (i = 0; i < rar_entries; i++) {\n\t\tif (!igb_mac_entry_can_be_used(&adapter->mac_table[i],\n\t\t\t\t\t       addr, flags))\n\t\t\tcontinue;\n\n\t\tether_addr_copy(adapter->mac_table[i].addr, addr);\n\t\tadapter->mac_table[i].queue = queue;\n\t\tadapter->mac_table[i].state |= IGB_MAC_STATE_IN_USE | flags;\n\n\t\tigb_rar_set_index(adapter, i);\n\t\treturn i;\n\t}\n\n\treturn -ENOSPC;\n}\n\nstatic int igb_add_mac_filter(struct igb_adapter *adapter, const u8 *addr,\n\t\t\t      const u8 queue)\n{\n\treturn igb_add_mac_filter_flags(adapter, addr, queue, 0);\n}\n\n/* Remove a MAC filter for 'addr' directing matching traffic to\n * 'queue', 'flags' is used to indicate what kind of match need to be\n * removed, match is by default for the destination address, if\n * matching by source address is to be removed the flag\n * IGB_MAC_STATE_SRC_ADDR can be used.\n */\nstatic int igb_del_mac_filter_flags(struct igb_adapter *adapter,\n\t\t\t\t    const u8 *addr, const u8 queue,\n\t\t\t\t    const u8 flags)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint rar_entries = hw->mac.rar_entry_count -\n\t\t\t  adapter->vfs_allocated_count;\n\tint i;\n\n\tif (is_zero_ether_addr(addr))\n\t\treturn -EINVAL;\n\n\t/* Search for matching entry in the MAC table based on given address\n\t * and queue. Do not touch entries at the end of the table reserved\n\t * for the VF MAC addresses.\n\t */\n\tfor (i = 0; i < rar_entries; i++) {\n\t\tif (!(adapter->mac_table[i].state & IGB_MAC_STATE_IN_USE))\n\t\t\tcontinue;\n\t\tif ((adapter->mac_table[i].state & flags) != flags)\n\t\t\tcontinue;\n\t\tif (adapter->mac_table[i].queue != queue)\n\t\t\tcontinue;\n\t\tif (!ether_addr_equal(adapter->mac_table[i].addr, addr))\n\t\t\tcontinue;\n\n\t\t/* When a filter for the default address is \"deleted\",\n\t\t * we return it to its initial configuration\n\t\t */\n\t\tif (adapter->mac_table[i].state & IGB_MAC_STATE_DEFAULT) {\n\t\t\tadapter->mac_table[i].state =\n\t\t\t\tIGB_MAC_STATE_DEFAULT | IGB_MAC_STATE_IN_USE;\n\t\t\tadapter->mac_table[i].queue =\n\t\t\t\tadapter->vfs_allocated_count;\n\t\t} else {\n\t\t\tadapter->mac_table[i].state = 0;\n\t\t\tadapter->mac_table[i].queue = 0;\n\t\t\teth_zero_addr(adapter->mac_table[i].addr);\n\t\t}\n\n\t\tigb_rar_set_index(adapter, i);\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int igb_del_mac_filter(struct igb_adapter *adapter, const u8 *addr,\n\t\t\t      const u8 queue)\n{\n\treturn igb_del_mac_filter_flags(adapter, addr, queue, 0);\n}\n\nint igb_add_mac_steering_filter(struct igb_adapter *adapter,\n\t\t\t\tconst u8 *addr, u8 queue, u8 flags)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t/* In theory, this should be supported on 82575 as well, but\n\t * that part wasn't easily accessible during development.\n\t */\n\tif (hw->mac.type != e1000_i210)\n\t\treturn -EOPNOTSUPP;\n\n\treturn igb_add_mac_filter_flags(adapter, addr, queue,\n\t\t\t\t\tIGB_MAC_STATE_QUEUE_STEERING | flags);\n}\n\nint igb_del_mac_steering_filter(struct igb_adapter *adapter,\n\t\t\t\tconst u8 *addr, u8 queue, u8 flags)\n{\n\treturn igb_del_mac_filter_flags(adapter, addr, queue,\n\t\t\t\t\tIGB_MAC_STATE_QUEUE_STEERING | flags);\n}\n\nstatic int igb_uc_sync(struct net_device *netdev, const unsigned char *addr)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tint ret;\n\n\tret = igb_add_mac_filter(adapter, addr, adapter->vfs_allocated_count);\n\n\treturn min_t(int, ret, 0);\n}\n\nstatic int igb_uc_unsync(struct net_device *netdev, const unsigned char *addr)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\n\tigb_del_mac_filter(adapter, addr, adapter->vfs_allocated_count);\n\n\treturn 0;\n}\n\nstatic int igb_set_vf_mac_filter(struct igb_adapter *adapter, const int vf,\n\t\t\t\t const u32 info, const u8 *addr)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct vf_data_storage *vf_data = &adapter->vf_data[vf];\n\tstruct list_head *pos;\n\tstruct vf_mac_filter *entry = NULL;\n\tint ret = 0;\n\n\tswitch (info) {\n\tcase E1000_VF_MAC_FILTER_CLR:\n\t\t/* remove all unicast MAC filters related to the current VF */\n\t\tlist_for_each(pos, &adapter->vf_macs.l) {\n\t\t\tentry = list_entry(pos, struct vf_mac_filter, l);\n\t\t\tif (entry->vf == vf) {\n\t\t\t\tentry->vf = -1;\n\t\t\t\tentry->free = true;\n\t\t\t\tigb_del_mac_filter(adapter, entry->vf_mac, vf);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase E1000_VF_MAC_FILTER_ADD:\n\t\tif ((vf_data->flags & IGB_VF_FLAG_PF_SET_MAC) &&\n\t\t    !vf_data->trusted) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"VF %d requested MAC filter but is administratively denied\\n\",\n\t\t\t\t vf);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!is_valid_ether_addr(addr)) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"VF %d attempted to set invalid MAC filter\\n\",\n\t\t\t\t vf);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* try to find empty slot in the list */\n\t\tlist_for_each(pos, &adapter->vf_macs.l) {\n\t\t\tentry = list_entry(pos, struct vf_mac_filter, l);\n\t\t\tif (entry->free)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (entry && entry->free) {\n\t\t\tentry->free = false;\n\t\t\tentry->vf = vf;\n\t\t\tether_addr_copy(entry->vf_mac, addr);\n\n\t\t\tret = igb_add_mac_filter(adapter, addr, vf);\n\t\t\tret = min_t(int, ret, 0);\n\t\t} else {\n\t\t\tret = -ENOSPC;\n\t\t}\n\n\t\tif (ret == -ENOSPC)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"VF %d has requested MAC filter but there is no space for it\\n\",\n\t\t\t\t vf);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int igb_set_vf_mac_addr(struct igb_adapter *adapter, u32 *msg, int vf)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct vf_data_storage *vf_data = &adapter->vf_data[vf];\n\tu32 info = msg[0] & E1000_VT_MSGINFO_MASK;\n\n\t/* The VF MAC Address is stored in a packed array of bytes\n\t * starting at the second 32 bit word of the msg array\n\t */\n\tunsigned char *addr = (unsigned char *)&msg[1];\n\tint ret = 0;\n\n\tif (!info) {\n\t\tif ((vf_data->flags & IGB_VF_FLAG_PF_SET_MAC) &&\n\t\t    !vf_data->trusted) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"VF %d attempted to override administratively set MAC address\\nReload the VF driver to resume operations\\n\",\n\t\t\t\t vf);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!is_valid_ether_addr(addr)) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"VF %d attempted to set invalid MAC\\n\",\n\t\t\t\t vf);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = igb_set_vf_mac(adapter, vf, addr);\n\t} else {\n\t\tret = igb_set_vf_mac_filter(adapter, vf, info, addr);\n\t}\n\n\treturn ret;\n}\n\nstatic void igb_rcv_ack_from_vf(struct igb_adapter *adapter, u32 vf)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct vf_data_storage *vf_data = &adapter->vf_data[vf];\n\tu32 msg = E1000_VT_MSGTYPE_NACK;\n\n\t/* if device isn't clear to send it shouldn't be reading either */\n\tif (!(vf_data->flags & IGB_VF_FLAG_CTS) &&\n\t    time_after(jiffies, vf_data->last_nack + (2 * HZ))) {\n\t\tigb_write_mbx(hw, &msg, 1, vf);\n\t\tvf_data->last_nack = jiffies;\n\t}\n}\n\nstatic void igb_rcv_msg_from_vf(struct igb_adapter *adapter, u32 vf)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tu32 msgbuf[E1000_VFMAILBOX_SIZE];\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct vf_data_storage *vf_data = &adapter->vf_data[vf];\n\ts32 retval;\n\n\tretval = igb_read_mbx(hw, msgbuf, E1000_VFMAILBOX_SIZE, vf, false);\n\n\tif (retval) {\n\t\t/* if receive failed revoke VF CTS stats and restart init */\n\t\tdev_err(&pdev->dev, \"Error receiving message from VF\\n\");\n\t\tvf_data->flags &= ~IGB_VF_FLAG_CTS;\n\t\tif (!time_after(jiffies, vf_data->last_nack + (2 * HZ)))\n\t\t\tgoto unlock;\n\t\tgoto out;\n\t}\n\n\t/* this is a message we already processed, do nothing */\n\tif (msgbuf[0] & (E1000_VT_MSGTYPE_ACK | E1000_VT_MSGTYPE_NACK))\n\t\tgoto unlock;\n\n\t/* until the vf completes a reset it should not be\n\t * allowed to start any configuration.\n\t */\n\tif (msgbuf[0] == E1000_VF_RESET) {\n\t\t/* unlocks mailbox */\n\t\tigb_vf_reset_msg(adapter, vf);\n\t\treturn;\n\t}\n\n\tif (!(vf_data->flags & IGB_VF_FLAG_CTS)) {\n\t\tif (!time_after(jiffies, vf_data->last_nack + (2 * HZ)))\n\t\t\tgoto unlock;\n\t\tretval = -1;\n\t\tgoto out;\n\t}\n\n\tswitch ((msgbuf[0] & 0xFFFF)) {\n\tcase E1000_VF_SET_MAC_ADDR:\n\t\tretval = igb_set_vf_mac_addr(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase E1000_VF_SET_PROMISC:\n\t\tretval = igb_set_vf_promisc(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase E1000_VF_SET_MULTICAST:\n\t\tretval = igb_set_vf_multicasts(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase E1000_VF_SET_LPE:\n\t\tretval = igb_set_vf_rlpml(adapter, msgbuf[1], vf);\n\t\tbreak;\n\tcase E1000_VF_SET_VLAN:\n\t\tretval = -1;\n\t\tif (vf_data->pf_vlan)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"VF %d attempted to override administratively set VLAN tag\\nReload the VF driver to resume operations\\n\",\n\t\t\t\t vf);\n\t\telse\n\t\t\tretval = igb_set_vf_vlan_msg(adapter, msgbuf, vf);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unhandled Msg %08x\\n\", msgbuf[0]);\n\t\tretval = -1;\n\t\tbreak;\n\t}\n\n\tmsgbuf[0] |= E1000_VT_MSGTYPE_CTS;\nout:\n\t/* notify the VF of the results of what it sent us */\n\tif (retval)\n\t\tmsgbuf[0] |= E1000_VT_MSGTYPE_NACK;\n\telse\n\t\tmsgbuf[0] |= E1000_VT_MSGTYPE_ACK;\n\n\t/* unlocks mailbox */\n\tigb_write_mbx(hw, msgbuf, 1, vf);\n\treturn;\n\nunlock:\n\tigb_unlock_mbx(hw, vf);\n}\n\nstatic void igb_msg_task(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 vf;\n\n\tfor (vf = 0; vf < adapter->vfs_allocated_count; vf++) {\n\t\t/* process any reset requests */\n\t\tif (!igb_check_for_rst(hw, vf))\n\t\t\tigb_vf_reset_event(adapter, vf);\n\n\t\t/* process any messages pending */\n\t\tif (!igb_check_for_msg(hw, vf))\n\t\t\tigb_rcv_msg_from_vf(adapter, vf);\n\n\t\t/* process any acks */\n\t\tif (!igb_check_for_ack(hw, vf))\n\t\t\tigb_rcv_ack_from_vf(adapter, vf);\n\t}\n}\n\n/**\n *  igb_set_uta - Set unicast filter table address\n *  @adapter: board private structure\n *  @set: boolean indicating if we are setting or clearing bits\n *\n *  The unicast table address is a register array of 32-bit registers.\n *  The table is meant to be used in a way similar to how the MTA is used\n *  however due to certain limitations in the hardware it is necessary to\n *  set all the hash bits to 1 and use the VMOLR ROPE bit as a promiscuous\n *  enable bit to allow vlan tag stripping when promiscuous mode is enabled\n **/\nstatic void igb_set_uta(struct igb_adapter *adapter, bool set)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 uta = set ? ~0 : 0;\n\tint i;\n\n\t/* we only need to do this if VMDq is enabled */\n\tif (!adapter->vfs_allocated_count)\n\t\treturn;\n\n\tfor (i = hw->mac.uta_reg_count; i--;)\n\t\tarray_wr32(E1000_UTA, i, uta);\n}\n\n/**\n *  igb_intr_msi - Interrupt Handler\n *  @irq: interrupt number\n *  @data: pointer to a network interface device structure\n **/\nstatic irqreturn_t igb_intr_msi(int irq, void *data)\n{\n\tstruct igb_adapter *adapter = data;\n\tstruct igb_q_vector *q_vector = adapter->q_vector[0];\n\tstruct e1000_hw *hw = &adapter->hw;\n\t/* read ICR disables interrupts using IAM */\n\tu32 icr = rd32(E1000_ICR);\n\n\tigb_write_itr(q_vector);\n\n\tif (icr & E1000_ICR_DRSTA)\n\t\tschedule_work(&adapter->reset_task);\n\n\tif (icr & E1000_ICR_DOUTSYNC) {\n\t\t/* HW is reporting DMA is out of sync */\n\t\tadapter->stats.doosync++;\n\t}\n\n\tif (icr & (E1000_ICR_RXSEQ | E1000_ICR_LSC)) {\n\t\thw->mac.get_link_status = 1;\n\t\tif (!test_bit(__IGB_DOWN, &adapter->state))\n\t\t\tmod_timer(&adapter->watchdog_timer, jiffies + 1);\n\t}\n\n\tif (icr & E1000_ICR_TS)\n\t\tigb_tsync_interrupt(adapter);\n\n\tnapi_schedule(&q_vector->napi);\n\n\treturn IRQ_HANDLED;\n}\n\n/**\n *  igb_intr - Legacy Interrupt Handler\n *  @irq: interrupt number\n *  @data: pointer to a network interface device structure\n **/\nstatic irqreturn_t igb_intr(int irq, void *data)\n{\n\tstruct igb_adapter *adapter = data;\n\tstruct igb_q_vector *q_vector = adapter->q_vector[0];\n\tstruct e1000_hw *hw = &adapter->hw;\n\t/* Interrupt Auto-Mask...upon reading ICR, interrupts are masked.  No\n\t * need for the IMC write\n\t */\n\tu32 icr = rd32(E1000_ICR);\n\n\t/* IMS will not auto-mask if INT_ASSERTED is not set, and if it is\n\t * not set, then the adapter didn't send an interrupt\n\t */\n\tif (!(icr & E1000_ICR_INT_ASSERTED))\n\t\treturn IRQ_NONE;\n\n\tigb_write_itr(q_vector);\n\n\tif (icr & E1000_ICR_DRSTA)\n\t\tschedule_work(&adapter->reset_task);\n\n\tif (icr & E1000_ICR_DOUTSYNC) {\n\t\t/* HW is reporting DMA is out of sync */\n\t\tadapter->stats.doosync++;\n\t}\n\n\tif (icr & (E1000_ICR_RXSEQ | E1000_ICR_LSC)) {\n\t\thw->mac.get_link_status = 1;\n\t\t/* guard against interrupt when we're going down */\n\t\tif (!test_bit(__IGB_DOWN, &adapter->state))\n\t\t\tmod_timer(&adapter->watchdog_timer, jiffies + 1);\n\t}\n\n\tif (icr & E1000_ICR_TS)\n\t\tigb_tsync_interrupt(adapter);\n\n\tnapi_schedule(&q_vector->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void igb_ring_irq_enable(struct igb_q_vector *q_vector)\n{\n\tstruct igb_adapter *adapter = q_vector->adapter;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif ((q_vector->rx.ring && (adapter->rx_itr_setting & 3)) ||\n\t    (!q_vector->rx.ring && (adapter->tx_itr_setting & 3))) {\n\t\tif ((adapter->num_q_vectors == 1) && !adapter->vf_data)\n\t\t\tigb_set_itr(q_vector);\n\t\telse\n\t\t\tigb_update_ring_itr(q_vector);\n\t}\n\n\tif (!test_bit(__IGB_DOWN, &adapter->state)) {\n\t\tif (adapter->flags & IGB_FLAG_HAS_MSIX)\n\t\t\twr32(E1000_EIMS, q_vector->eims_value);\n\t\telse\n\t\t\tigb_irq_enable(adapter);\n\t}\n}\n\n/**\n *  igb_poll - NAPI Rx polling callback\n *  @napi: napi polling structure\n *  @budget: count of how many packets we should handle\n **/\nstatic int igb_poll(struct napi_struct *napi, int budget)\n{\n\tstruct igb_q_vector *q_vector = container_of(napi,\n\t\t\t\t\t\t     struct igb_q_vector,\n\t\t\t\t\t\t     napi);\n\tbool clean_complete = true;\n\tint work_done = 0;\n\n#ifdef CONFIG_IGB_DCA\n\tif (q_vector->adapter->flags & IGB_FLAG_DCA_ENABLED)\n\t\tigb_update_dca(q_vector);\n#endif\n\tif (q_vector->tx.ring)\n\t\tclean_complete = igb_clean_tx_irq(q_vector, budget);\n\n\tif (q_vector->rx.ring) {\n\t\tint cleaned = igb_clean_rx_irq(q_vector, budget);\n\n\t\twork_done += cleaned;\n\t\tif (cleaned >= budget)\n\t\t\tclean_complete = false;\n\t}\n\n\t/* If all work not completed, return budget and keep polling */\n\tif (!clean_complete)\n\t\treturn budget;\n\n\t/* Exit the polling mode, but don't re-enable interrupts if stack might\n\t * poll us due to busy-polling\n\t */\n\tif (likely(napi_complete_done(napi, work_done)))\n\t\tigb_ring_irq_enable(q_vector);\n\n\treturn min(work_done, budget - 1);\n}\n\n/**\n *  igb_clean_tx_irq - Reclaim resources after transmit completes\n *  @q_vector: pointer to q_vector containing needed info\n *  @napi_budget: Used to determine if we are in netpoll\n *\n *  returns true if ring is completely cleaned\n **/\nstatic bool igb_clean_tx_irq(struct igb_q_vector *q_vector, int napi_budget)\n{\n\tstruct igb_adapter *adapter = q_vector->adapter;\n\tstruct igb_ring *tx_ring = q_vector->tx.ring;\n\tstruct igb_tx_buffer *tx_buffer;\n\tunion e1000_adv_tx_desc *tx_desc;\n\tunsigned int total_bytes = 0, total_packets = 0;\n\tunsigned int budget = q_vector->tx.work_limit;\n\tunsigned int i = tx_ring->next_to_clean;\n\n\tif (test_bit(__IGB_DOWN, &adapter->state))\n\t\treturn true;\n\n\ttx_buffer = &tx_ring->tx_buffer_info[i];\n\ttx_desc = IGB_TX_DESC(tx_ring, i);\n\ti -= tx_ring->count;\n\n\tdo {\n\t\tunion e1000_adv_tx_desc *eop_desc = tx_buffer->next_to_watch;\n\n\t\t/* if next_to_watch is not set then there is no work pending */\n\t\tif (!eop_desc)\n\t\t\tbreak;\n\n\t\t/* prevent any other reads prior to eop_desc */\n\t\tsmp_rmb();\n\n\t\t/* if DD is not set pending work has not been completed */\n\t\tif (!(eop_desc->wb.status & cpu_to_le32(E1000_TXD_STAT_DD)))\n\t\t\tbreak;\n\n\t\t/* clear next_to_watch to prevent false hangs */\n\t\ttx_buffer->next_to_watch = NULL;\n\n\t\t/* update the statistics for this packet */\n\t\ttotal_bytes += tx_buffer->bytecount;\n\t\ttotal_packets += tx_buffer->gso_segs;\n\n\t\t/* free the skb */\n\t\tif (tx_buffer->type == IGB_TYPE_SKB)\n\t\t\tnapi_consume_skb(tx_buffer->skb, napi_budget);\n\t\telse\n\t\t\txdp_return_frame(tx_buffer->xdpf);\n\n\t\t/* unmap skb header data */\n\t\tdma_unmap_single(tx_ring->dev,\n\t\t\t\t dma_unmap_addr(tx_buffer, dma),\n\t\t\t\t dma_unmap_len(tx_buffer, len),\n\t\t\t\t DMA_TO_DEVICE);\n\n\t\t/* clear tx_buffer data */\n\t\tdma_unmap_len_set(tx_buffer, len, 0);\n\n\t\t/* clear last DMA location and unmap remaining buffers */\n\t\twhile (tx_desc != eop_desc) {\n\t\t\ttx_buffer++;\n\t\t\ttx_desc++;\n\t\t\ti++;\n\t\t\tif (unlikely(!i)) {\n\t\t\t\ti -= tx_ring->count;\n\t\t\t\ttx_buffer = tx_ring->tx_buffer_info;\n\t\t\t\ttx_desc = IGB_TX_DESC(tx_ring, 0);\n\t\t\t}\n\n\t\t\t/* unmap any remaining paged data */\n\t\t\tif (dma_unmap_len(tx_buffer, len)) {\n\t\t\t\tdma_unmap_page(tx_ring->dev,\n\t\t\t\t\t       dma_unmap_addr(tx_buffer, dma),\n\t\t\t\t\t       dma_unmap_len(tx_buffer, len),\n\t\t\t\t\t       DMA_TO_DEVICE);\n\t\t\t\tdma_unmap_len_set(tx_buffer, len, 0);\n\t\t\t}\n\t\t}\n\n\t\t/* move us one more past the eop_desc for start of next pkt */\n\t\ttx_buffer++;\n\t\ttx_desc++;\n\t\ti++;\n\t\tif (unlikely(!i)) {\n\t\t\ti -= tx_ring->count;\n\t\t\ttx_buffer = tx_ring->tx_buffer_info;\n\t\t\ttx_desc = IGB_TX_DESC(tx_ring, 0);\n\t\t}\n\n\t\t/* issue prefetch for next Tx descriptor */\n\t\tprefetch(tx_desc);\n\n\t\t/* update budget accounting */\n\t\tbudget--;\n\t} while (likely(budget));\n\n\tnetdev_tx_completed_queue(txring_txq(tx_ring),\n\t\t\t\t  total_packets, total_bytes);\n\ti += tx_ring->count;\n\ttx_ring->next_to_clean = i;\n\tu64_stats_update_begin(&tx_ring->tx_syncp);\n\ttx_ring->tx_stats.bytes += total_bytes;\n\ttx_ring->tx_stats.packets += total_packets;\n\tu64_stats_update_end(&tx_ring->tx_syncp);\n\tq_vector->tx.total_bytes += total_bytes;\n\tq_vector->tx.total_packets += total_packets;\n\n\tif (test_bit(IGB_RING_FLAG_TX_DETECT_HANG, &tx_ring->flags)) {\n\t\tstruct e1000_hw *hw = &adapter->hw;\n\n\t\t/* Detect a transmit hang in hardware, this serializes the\n\t\t * check with the clearing of time_stamp and movement of i\n\t\t */\n\t\tclear_bit(IGB_RING_FLAG_TX_DETECT_HANG, &tx_ring->flags);\n\t\tif (tx_buffer->next_to_watch &&\n\t\t    time_after(jiffies, tx_buffer->time_stamp +\n\t\t\t       (adapter->tx_timeout_factor * HZ)) &&\n\t\t    !(rd32(E1000_STATUS) & E1000_STATUS_TXOFF)) {\n\n\t\t\t/* detected Tx unit hang */\n\t\t\tdev_err(tx_ring->dev,\n\t\t\t\t\"Detected Tx Unit Hang\\n\"\n\t\t\t\t\"  Tx Queue             <%d>\\n\"\n\t\t\t\t\"  TDH                  <%x>\\n\"\n\t\t\t\t\"  TDT                  <%x>\\n\"\n\t\t\t\t\"  next_to_use          <%x>\\n\"\n\t\t\t\t\"  next_to_clean        <%x>\\n\"\n\t\t\t\t\"buffer_info[next_to_clean]\\n\"\n\t\t\t\t\"  time_stamp           <%lx>\\n\"\n\t\t\t\t\"  next_to_watch        <%p>\\n\"\n\t\t\t\t\"  jiffies              <%lx>\\n\"\n\t\t\t\t\"  desc.status          <%x>\\n\",\n\t\t\t\ttx_ring->queue_index,\n\t\t\t\trd32(E1000_TDH(tx_ring->reg_idx)),\n\t\t\t\treadl(tx_ring->tail),\n\t\t\t\ttx_ring->next_to_use,\n\t\t\t\ttx_ring->next_to_clean,\n\t\t\t\ttx_buffer->time_stamp,\n\t\t\t\ttx_buffer->next_to_watch,\n\t\t\t\tjiffies,\n\t\t\t\ttx_buffer->next_to_watch->wb.status);\n\t\t\tnetif_stop_subqueue(tx_ring->netdev,\n\t\t\t\t\t    tx_ring->queue_index);\n\n\t\t\t/* we are about to reset, no point in enabling stuff */\n\t\t\treturn true;\n\t\t}\n\t}\n\n#define TX_WAKE_THRESHOLD (DESC_NEEDED * 2)\n\tif (unlikely(total_packets &&\n\t    netif_carrier_ok(tx_ring->netdev) &&\n\t    igb_desc_unused(tx_ring) >= TX_WAKE_THRESHOLD)) {\n\t\t/* Make sure that anybody stopping the queue after this\n\t\t * sees the new next_to_clean.\n\t\t */\n\t\tsmp_mb();\n\t\tif (__netif_subqueue_stopped(tx_ring->netdev,\n\t\t\t\t\t     tx_ring->queue_index) &&\n\t\t    !(test_bit(__IGB_DOWN, &adapter->state))) {\n\t\t\tnetif_wake_subqueue(tx_ring->netdev,\n\t\t\t\t\t    tx_ring->queue_index);\n\n\t\t\tu64_stats_update_begin(&tx_ring->tx_syncp);\n\t\t\ttx_ring->tx_stats.restart_queue++;\n\t\t\tu64_stats_update_end(&tx_ring->tx_syncp);\n\t\t}\n\t}\n\n\treturn !!budget;\n}\n\n/**\n *  igb_reuse_rx_page - page flip buffer and store it back on the ring\n *  @rx_ring: rx descriptor ring to store buffers on\n *  @old_buff: donor buffer to have page reused\n *\n *  Synchronizes page for reuse by the adapter\n **/\nstatic void igb_reuse_rx_page(struct igb_ring *rx_ring,\n\t\t\t      struct igb_rx_buffer *old_buff)\n{\n\tstruct igb_rx_buffer *new_buff;\n\tu16 nta = rx_ring->next_to_alloc;\n\n\tnew_buff = &rx_ring->rx_buffer_info[nta];\n\n\t/* update, and store next to alloc */\n\tnta++;\n\trx_ring->next_to_alloc = (nta < rx_ring->count) ? nta : 0;\n\n\t/* Transfer page from old buffer to new buffer.\n\t * Move each member individually to avoid possible store\n\t * forwarding stalls.\n\t */\n\tnew_buff->dma\t\t= old_buff->dma;\n\tnew_buff->page\t\t= old_buff->page;\n\tnew_buff->page_offset\t= old_buff->page_offset;\n\tnew_buff->pagecnt_bias\t= old_buff->pagecnt_bias;\n}\n\nstatic inline bool igb_page_is_reserved(struct page *page)\n{\n\treturn (page_to_nid(page) != numa_mem_id()) || page_is_pfmemalloc(page);\n}\n\nstatic bool igb_can_reuse_rx_page(struct igb_rx_buffer *rx_buffer)\n{\n\tunsigned int pagecnt_bias = rx_buffer->pagecnt_bias;\n\tstruct page *page = rx_buffer->page;\n\n\t/* avoid re-using remote pages */\n\tif (unlikely(igb_page_is_reserved(page)))\n\t\treturn false;\n\n#if (PAGE_SIZE < 8192)\n\t/* if we are only owner of page we can reuse it */\n\tif (unlikely((page_ref_count(page) - pagecnt_bias) > 1))\n\t\treturn false;\n#else\n#define IGB_LAST_OFFSET \\\n\t(SKB_WITH_OVERHEAD(PAGE_SIZE) - IGB_RXBUFFER_2048)\n\n\tif (rx_buffer->page_offset > IGB_LAST_OFFSET)\n\t\treturn false;\n#endif\n\n\t/* If we have drained the page fragment pool we need to update\n\t * the pagecnt_bias and page count so that we fully restock the\n\t * number of references the driver holds.\n\t */\n\tif (unlikely(pagecnt_bias == 1)) {\n\t\tpage_ref_add(page, USHRT_MAX - 1);\n\t\trx_buffer->pagecnt_bias = USHRT_MAX;\n\t}\n\n\treturn true;\n}\n\n/**\n *  igb_add_rx_frag - Add contents of Rx buffer to sk_buff\n *  @rx_ring: rx descriptor ring to transact packets on\n *  @rx_buffer: buffer containing page to add\n *  @skb: sk_buff to place the data into\n *  @size: size of buffer to be added\n *\n *  This function will add the data contained in rx_buffer->page to the skb.\n **/\nstatic void igb_add_rx_frag(struct igb_ring *rx_ring,\n\t\t\t    struct igb_rx_buffer *rx_buffer,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    unsigned int size)\n{\n#if (PAGE_SIZE < 8192)\n\tunsigned int truesize = igb_rx_pg_size(rx_ring) / 2;\n#else\n\tunsigned int truesize = ring_uses_build_skb(rx_ring) ?\n\t\t\t\tSKB_DATA_ALIGN(IGB_SKB_PAD + size) :\n\t\t\t\tSKB_DATA_ALIGN(size);\n#endif\n\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, rx_buffer->page,\n\t\t\trx_buffer->page_offset, size, truesize);\n#if (PAGE_SIZE < 8192)\n\trx_buffer->page_offset ^= truesize;\n#else\n\trx_buffer->page_offset += truesize;\n#endif\n}\n\nstatic struct sk_buff *igb_construct_skb(struct igb_ring *rx_ring,\n\t\t\t\t\t struct igb_rx_buffer *rx_buffer,\n\t\t\t\t\t struct xdp_buff *xdp,\n\t\t\t\t\t union e1000_adv_rx_desc *rx_desc)\n{\n#if (PAGE_SIZE < 8192)\n\tunsigned int truesize = igb_rx_pg_size(rx_ring) / 2;\n#else\n\tunsigned int truesize = SKB_DATA_ALIGN(xdp->data_end -\n\t\t\t\t\t       xdp->data_hard_start);\n#endif\n\tunsigned int size = xdp->data_end - xdp->data;\n\tunsigned int headlen;\n\tstruct sk_buff *skb;\n\n\t/* prefetch first cache line of first page */\n\tnet_prefetch(xdp->data);\n\n\t/* allocate a skb to store the frags */\n\tskb = napi_alloc_skb(&rx_ring->q_vector->napi, IGB_RX_HDR_LEN);\n\tif (unlikely(!skb))\n\t\treturn NULL;\n\n\tif (unlikely(igb_test_staterr(rx_desc, E1000_RXDADV_STAT_TSIP))) {\n\t\tigb_ptp_rx_pktstamp(rx_ring->q_vector, xdp->data, skb);\n\t\txdp->data += IGB_TS_HDR_LEN;\n\t\tsize -= IGB_TS_HDR_LEN;\n\t}\n\n\t/* Determine available headroom for copy */\n\theadlen = size;\n\tif (headlen > IGB_RX_HDR_LEN)\n\t\theadlen = eth_get_headlen(skb->dev, xdp->data, IGB_RX_HDR_LEN);\n\n\t/* align pull length to size of long to optimize memcpy performance */\n\tmemcpy(__skb_put(skb, headlen), xdp->data, ALIGN(headlen, sizeof(long)));\n\n\t/* update all of the pointers */\n\tsize -= headlen;\n\tif (size) {\n\t\tskb_add_rx_frag(skb, 0, rx_buffer->page,\n\t\t\t\t(xdp->data + headlen) - page_address(rx_buffer->page),\n\t\t\t\tsize, truesize);\n#if (PAGE_SIZE < 8192)\n\t\trx_buffer->page_offset ^= truesize;\n#else\n\t\trx_buffer->page_offset += truesize;\n#endif\n\t} else {\n\t\trx_buffer->pagecnt_bias++;\n\t}\n\n\treturn skb;\n}\n\nstatic struct sk_buff *igb_build_skb(struct igb_ring *rx_ring,\n\t\t\t\t     struct igb_rx_buffer *rx_buffer,\n\t\t\t\t     struct xdp_buff *xdp,\n\t\t\t\t     union e1000_adv_rx_desc *rx_desc)\n{\n#if (PAGE_SIZE < 8192)\n\tunsigned int truesize = igb_rx_pg_size(rx_ring) / 2;\n#else\n\tunsigned int truesize = SKB_DATA_ALIGN(sizeof(struct skb_shared_info)) +\n\t\t\t\tSKB_DATA_ALIGN(xdp->data_end -\n\t\t\t\t\t       xdp->data_hard_start);\n#endif\n\tunsigned int metasize = xdp->data - xdp->data_meta;\n\tstruct sk_buff *skb;\n\n\t/* prefetch first cache line of first page */\n\tnet_prefetch(xdp->data_meta);\n\n\t/* build an skb around the page buffer */\n\tskb = build_skb(xdp->data_hard_start, truesize);\n\tif (unlikely(!skb))\n\t\treturn NULL;\n\n\t/* update pointers within the skb to store the data */\n\tskb_reserve(skb, xdp->data - xdp->data_hard_start);\n\t__skb_put(skb, xdp->data_end - xdp->data);\n\n\tif (metasize)\n\t\tskb_metadata_set(skb, metasize);\n\n\t/* pull timestamp out of packet data */\n\tif (igb_test_staterr(rx_desc, E1000_RXDADV_STAT_TSIP)) {\n\t\tigb_ptp_rx_pktstamp(rx_ring->q_vector, skb->data, skb);\n\t\t__skb_pull(skb, IGB_TS_HDR_LEN);\n\t}\n\n\t/* update buffer offset */\n#if (PAGE_SIZE < 8192)\n\trx_buffer->page_offset ^= truesize;\n#else\n\trx_buffer->page_offset += truesize;\n#endif\n\n\treturn skb;\n}\n\nstatic struct sk_buff *igb_run_xdp(struct igb_adapter *adapter,\n\t\t\t\t   struct igb_ring *rx_ring,\n\t\t\t\t   struct xdp_buff *xdp)\n{\n\tint err, result = IGB_XDP_PASS;\n\tstruct bpf_prog *xdp_prog;\n\tu32 act;\n\n\trcu_read_lock();\n\txdp_prog = READ_ONCE(rx_ring->xdp_prog);\n\n\tif (!xdp_prog)\n\t\tgoto xdp_out;\n\n\tprefetchw(xdp->data_hard_start); /* xdp_frame write */\n\n\tact = bpf_prog_run_xdp(xdp_prog, xdp);\n\tswitch (act) {\n\tcase XDP_PASS:\n\t\tbreak;\n\tcase XDP_TX:\n\t\tresult = igb_xdp_xmit_back(adapter, xdp);\n\t\tbreak;\n\tcase XDP_REDIRECT:\n\t\terr = xdp_do_redirect(adapter->netdev, xdp, xdp_prog);\n\t\tif (!err)\n\t\t\tresult = IGB_XDP_REDIR;\n\t\telse\n\t\t\tresult = IGB_XDP_CONSUMED;\n\t\tbreak;\n\tdefault:\n\t\tbpf_warn_invalid_xdp_action(act);\n\t\tfallthrough;\n\tcase XDP_ABORTED:\n\t\ttrace_xdp_exception(rx_ring->netdev, xdp_prog, act);\n\t\tfallthrough;\n\tcase XDP_DROP:\n\t\tresult = IGB_XDP_CONSUMED;\n\t\tbreak;\n\t}\nxdp_out:\n\trcu_read_unlock();\n\treturn ERR_PTR(-result);\n}\n\nstatic unsigned int igb_rx_frame_truesize(struct igb_ring *rx_ring,\n\t\t\t\t\t  unsigned int size)\n{\n\tunsigned int truesize;\n\n#if (PAGE_SIZE < 8192)\n\ttruesize = igb_rx_pg_size(rx_ring) / 2; /* Must be power-of-2 */\n#else\n\ttruesize = ring_uses_build_skb(rx_ring) ?\n\t\tSKB_DATA_ALIGN(IGB_SKB_PAD + size) +\n\t\tSKB_DATA_ALIGN(sizeof(struct skb_shared_info)) :\n\t\tSKB_DATA_ALIGN(size);\n#endif\n\treturn truesize;\n}\n\nstatic void igb_rx_buffer_flip(struct igb_ring *rx_ring,\n\t\t\t       struct igb_rx_buffer *rx_buffer,\n\t\t\t       unsigned int size)\n{\n\tunsigned int truesize = igb_rx_frame_truesize(rx_ring, size);\n#if (PAGE_SIZE < 8192)\n\trx_buffer->page_offset ^= truesize;\n#else\n\trx_buffer->page_offset += truesize;\n#endif\n}\n\nstatic inline void igb_rx_checksum(struct igb_ring *ring,\n\t\t\t\t   union e1000_adv_rx_desc *rx_desc,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tskb_checksum_none_assert(skb);\n\n\t/* Ignore Checksum bit is set */\n\tif (igb_test_staterr(rx_desc, E1000_RXD_STAT_IXSM))\n\t\treturn;\n\n\t/* Rx checksum disabled via ethtool */\n\tif (!(ring->netdev->features & NETIF_F_RXCSUM))\n\t\treturn;\n\n\t/* TCP/UDP checksum error bit is set */\n\tif (igb_test_staterr(rx_desc,\n\t\t\t     E1000_RXDEXT_STATERR_TCPE |\n\t\t\t     E1000_RXDEXT_STATERR_IPE)) {\n\t\t/* work around errata with sctp packets where the TCPE aka\n\t\t * L4E bit is set incorrectly on 64 byte (60 byte w/o crc)\n\t\t * packets, (aka let the stack check the crc32c)\n\t\t */\n\t\tif (!((skb->len == 60) &&\n\t\t      test_bit(IGB_RING_FLAG_RX_SCTP_CSUM, &ring->flags))) {\n\t\t\tu64_stats_update_begin(&ring->rx_syncp);\n\t\t\tring->rx_stats.csum_err++;\n\t\t\tu64_stats_update_end(&ring->rx_syncp);\n\t\t}\n\t\t/* let the stack verify checksum errors */\n\t\treturn;\n\t}\n\t/* It must be a TCP or UDP packet with a valid checksum */\n\tif (igb_test_staterr(rx_desc, E1000_RXD_STAT_TCPCS |\n\t\t\t\t      E1000_RXD_STAT_UDPCS))\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tdev_dbg(ring->dev, \"cksum success: bits %08X\\n\",\n\t\tle32_to_cpu(rx_desc->wb.upper.status_error));\n}\n\nstatic inline void igb_rx_hash(struct igb_ring *ring,\n\t\t\t       union e1000_adv_rx_desc *rx_desc,\n\t\t\t       struct sk_buff *skb)\n{\n\tif (ring->netdev->features & NETIF_F_RXHASH)\n\t\tskb_set_hash(skb,\n\t\t\t     le32_to_cpu(rx_desc->wb.lower.hi_dword.rss),\n\t\t\t     PKT_HASH_TYPE_L3);\n}\n\n/**\n *  igb_is_non_eop - process handling of non-EOP buffers\n *  @rx_ring: Rx ring being processed\n *  @rx_desc: Rx descriptor for current buffer\n *\n *  This function updates next to clean.  If the buffer is an EOP buffer\n *  this function exits returning false, otherwise it will place the\n *  sk_buff in the next buffer to be chained and return true indicating\n *  that this is in fact a non-EOP buffer.\n **/\nstatic bool igb_is_non_eop(struct igb_ring *rx_ring,\n\t\t\t   union e1000_adv_rx_desc *rx_desc)\n{\n\tu32 ntc = rx_ring->next_to_clean + 1;\n\n\t/* fetch, update, and store next to clean */\n\tntc = (ntc < rx_ring->count) ? ntc : 0;\n\trx_ring->next_to_clean = ntc;\n\n\tprefetch(IGB_RX_DESC(rx_ring, ntc));\n\n\tif (likely(igb_test_staterr(rx_desc, E1000_RXD_STAT_EOP)))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n *  igb_cleanup_headers - Correct corrupted or empty headers\n *  @rx_ring: rx descriptor ring packet is being transacted on\n *  @rx_desc: pointer to the EOP Rx descriptor\n *  @skb: pointer to current skb being fixed\n *\n *  Address the case where we are pulling data in on pages only\n *  and as such no data is present in the skb header.\n *\n *  In addition if skb is not at least 60 bytes we need to pad it so that\n *  it is large enough to qualify as a valid Ethernet frame.\n *\n *  Returns true if an error was encountered and skb was freed.\n **/\nstatic bool igb_cleanup_headers(struct igb_ring *rx_ring,\n\t\t\t\tunion e1000_adv_rx_desc *rx_desc,\n\t\t\t\tstruct sk_buff *skb)\n{\n\t/* XDP packets use error pointer so abort at this point */\n\tif (IS_ERR(skb))\n\t\treturn true;\n\n\tif (unlikely((igb_test_staterr(rx_desc,\n\t\t\t\t       E1000_RXDEXT_ERR_FRAME_ERR_MASK)))) {\n\t\tstruct net_device *netdev = rx_ring->netdev;\n\t\tif (!(netdev->features & NETIF_F_RXALL)) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* if eth_skb_pad returns an error the skb was freed */\n\tif (eth_skb_pad(skb))\n\t\treturn true;\n\n\treturn false;\n}\n\n/**\n *  igb_process_skb_fields - Populate skb header fields from Rx descriptor\n *  @rx_ring: rx descriptor ring packet is being transacted on\n *  @rx_desc: pointer to the EOP Rx descriptor\n *  @skb: pointer to current skb being populated\n *\n *  This function checks the ring, descriptor, and packet information in\n *  order to populate the hash, checksum, VLAN, timestamp, protocol, and\n *  other fields within the skb.\n **/\nstatic void igb_process_skb_fields(struct igb_ring *rx_ring,\n\t\t\t\t   union e1000_adv_rx_desc *rx_desc,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct net_device *dev = rx_ring->netdev;\n\n\tigb_rx_hash(rx_ring, rx_desc, skb);\n\n\tigb_rx_checksum(rx_ring, rx_desc, skb);\n\n\tif (igb_test_staterr(rx_desc, E1000_RXDADV_STAT_TS) &&\n\t    !igb_test_staterr(rx_desc, E1000_RXDADV_STAT_TSIP))\n\t\tigb_ptp_rx_rgtstamp(rx_ring->q_vector, skb);\n\n\tif ((dev->features & NETIF_F_HW_VLAN_CTAG_RX) &&\n\t    igb_test_staterr(rx_desc, E1000_RXD_STAT_VP)) {\n\t\tu16 vid;\n\n\t\tif (igb_test_staterr(rx_desc, E1000_RXDEXT_STATERR_LB) &&\n\t\t    test_bit(IGB_RING_FLAG_RX_LB_VLAN_BSWAP, &rx_ring->flags))\n\t\t\tvid = be16_to_cpu(rx_desc->wb.upper.vlan);\n\t\telse\n\t\t\tvid = le16_to_cpu(rx_desc->wb.upper.vlan);\n\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);\n\t}\n\n\tskb_record_rx_queue(skb, rx_ring->queue_index);\n\n\tskb->protocol = eth_type_trans(skb, rx_ring->netdev);\n}\n\nstatic unsigned int igb_rx_offset(struct igb_ring *rx_ring)\n{\n\treturn ring_uses_build_skb(rx_ring) ? IGB_SKB_PAD : 0;\n}\n\nstatic struct igb_rx_buffer *igb_get_rx_buffer(struct igb_ring *rx_ring,\n\t\t\t\t\t       const unsigned int size)\n{\n\tstruct igb_rx_buffer *rx_buffer;\n\n\trx_buffer = &rx_ring->rx_buffer_info[rx_ring->next_to_clean];\n\tprefetchw(rx_buffer->page);\n\n\t/* we are reusing so sync this buffer for CPU use */\n\tdma_sync_single_range_for_cpu(rx_ring->dev,\n\t\t\t\t      rx_buffer->dma,\n\t\t\t\t      rx_buffer->page_offset,\n\t\t\t\t      size,\n\t\t\t\t      DMA_FROM_DEVICE);\n\n\trx_buffer->pagecnt_bias--;\n\n\treturn rx_buffer;\n}\n\nstatic void igb_put_rx_buffer(struct igb_ring *rx_ring,\n\t\t\t      struct igb_rx_buffer *rx_buffer)\n{\n\tif (igb_can_reuse_rx_page(rx_buffer)) {\n\t\t/* hand second half of page back to the ring */\n\t\tigb_reuse_rx_page(rx_ring, rx_buffer);\n\t} else {\n\t\t/* We are not reusing the buffer so unmap it and free\n\t\t * any references we are holding to it\n\t\t */\n\t\tdma_unmap_page_attrs(rx_ring->dev, rx_buffer->dma,\n\t\t\t\t     igb_rx_pg_size(rx_ring), DMA_FROM_DEVICE,\n\t\t\t\t     IGB_RX_DMA_ATTR);\n\t\t__page_frag_cache_drain(rx_buffer->page,\n\t\t\t\t\trx_buffer->pagecnt_bias);\n\t}\n\n\t/* clear contents of rx_buffer */\n\trx_buffer->page = NULL;\n}\n\nstatic int igb_clean_rx_irq(struct igb_q_vector *q_vector, const int budget)\n{\n\tstruct igb_adapter *adapter = q_vector->adapter;\n\tstruct igb_ring *rx_ring = q_vector->rx.ring;\n\tstruct sk_buff *skb = rx_ring->skb;\n\tunsigned int total_bytes = 0, total_packets = 0;\n\tu16 cleaned_count = igb_desc_unused(rx_ring);\n\tunsigned int xdp_xmit = 0;\n\tstruct xdp_buff xdp;\n\tu32 frame_sz = 0;\n\n\t/* Frame size depend on rx_ring setup when PAGE_SIZE=4K */\n#if (PAGE_SIZE < 8192)\n\tframe_sz = igb_rx_frame_truesize(rx_ring, 0);\n#endif\n\txdp_init_buff(&xdp, frame_sz, &rx_ring->xdp_rxq);\n\n\twhile (likely(total_packets < budget)) {\n\t\tunion e1000_adv_rx_desc *rx_desc;\n\t\tstruct igb_rx_buffer *rx_buffer;\n\t\tunsigned int size;\n\n\t\t/* return some buffers to hardware, one at a time is too slow */\n\t\tif (cleaned_count >= IGB_RX_BUFFER_WRITE) {\n\t\t\tigb_alloc_rx_buffers(rx_ring, cleaned_count);\n\t\t\tcleaned_count = 0;\n\t\t}\n\n\t\trx_desc = IGB_RX_DESC(rx_ring, rx_ring->next_to_clean);\n\t\tsize = le16_to_cpu(rx_desc->wb.upper.length);\n\t\tif (!size)\n\t\t\tbreak;\n\n\t\t/* This memory barrier is needed to keep us from reading\n\t\t * any other fields out of the rx_desc until we know the\n\t\t * descriptor has been written back\n\t\t */\n\t\tdma_rmb();\n\n\t\trx_buffer = igb_get_rx_buffer(rx_ring, size);\n\n\t\t/* retrieve a buffer from the ring */\n\t\tif (!skb) {\n\t\t\tunsigned int offset = igb_rx_offset(rx_ring);\n\t\t\tunsigned char *hard_start;\n\n\t\t\thard_start = page_address(rx_buffer->page) +\n\t\t\t\t     rx_buffer->page_offset - offset;\n\t\t\txdp_prepare_buff(&xdp, hard_start, offset, size, true);\n#if (PAGE_SIZE > 4096)\n\t\t\t/* At larger PAGE_SIZE, frame_sz depend on len size */\n\t\t\txdp.frame_sz = igb_rx_frame_truesize(rx_ring, size);\n#endif\n\t\t\tskb = igb_run_xdp(adapter, rx_ring, &xdp);\n\t\t}\n\n\t\tif (IS_ERR(skb)) {\n\t\t\tunsigned int xdp_res = -PTR_ERR(skb);\n\n\t\t\tif (xdp_res & (IGB_XDP_TX | IGB_XDP_REDIR)) {\n\t\t\t\txdp_xmit |= xdp_res;\n\t\t\t\tigb_rx_buffer_flip(rx_ring, rx_buffer, size);\n\t\t\t} else {\n\t\t\t\trx_buffer->pagecnt_bias++;\n\t\t\t}\n\t\t\ttotal_packets++;\n\t\t\ttotal_bytes += size;\n\t\t} else if (skb)\n\t\t\tigb_add_rx_frag(rx_ring, rx_buffer, skb, size);\n\t\telse if (ring_uses_build_skb(rx_ring))\n\t\t\tskb = igb_build_skb(rx_ring, rx_buffer, &xdp, rx_desc);\n\t\telse\n\t\t\tskb = igb_construct_skb(rx_ring, rx_buffer,\n\t\t\t\t\t\t&xdp, rx_desc);\n\n\t\t/* exit if we failed to retrieve a buffer */\n\t\tif (!skb) {\n\t\t\trx_ring->rx_stats.alloc_failed++;\n\t\t\trx_buffer->pagecnt_bias++;\n\t\t\tbreak;\n\t\t}\n\n\t\tigb_put_rx_buffer(rx_ring, rx_buffer);\n\t\tcleaned_count++;\n\n\t\t/* fetch next buffer in frame if non-eop */\n\t\tif (igb_is_non_eop(rx_ring, rx_desc))\n\t\t\tcontinue;\n\n\t\t/* verify the packet layout is correct */\n\t\tif (igb_cleanup_headers(rx_ring, rx_desc, skb)) {\n\t\t\tskb = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* probably a little skewed due to removing CRC */\n\t\ttotal_bytes += skb->len;\n\n\t\t/* populate checksum, timestamp, VLAN, and protocol */\n\t\tigb_process_skb_fields(rx_ring, rx_desc, skb);\n\n\t\tnapi_gro_receive(&q_vector->napi, skb);\n\n\t\t/* reset skb pointer */\n\t\tskb = NULL;\n\n\t\t/* update budget accounting */\n\t\ttotal_packets++;\n\t}\n\n\t/* place incomplete frames back on ring for completion */\n\trx_ring->skb = skb;\n\n\tif (xdp_xmit & IGB_XDP_REDIR)\n\t\txdp_do_flush();\n\n\tif (xdp_xmit & IGB_XDP_TX) {\n\t\tstruct igb_ring *tx_ring = igb_xdp_tx_queue_mapping(adapter);\n\n\t\tigb_xdp_ring_update_tail(tx_ring);\n\t}\n\n\tu64_stats_update_begin(&rx_ring->rx_syncp);\n\trx_ring->rx_stats.packets += total_packets;\n\trx_ring->rx_stats.bytes += total_bytes;\n\tu64_stats_update_end(&rx_ring->rx_syncp);\n\tq_vector->rx.total_packets += total_packets;\n\tq_vector->rx.total_bytes += total_bytes;\n\n\tif (cleaned_count)\n\t\tigb_alloc_rx_buffers(rx_ring, cleaned_count);\n\n\treturn total_packets;\n}\n\nstatic bool igb_alloc_mapped_page(struct igb_ring *rx_ring,\n\t\t\t\t  struct igb_rx_buffer *bi)\n{\n\tstruct page *page = bi->page;\n\tdma_addr_t dma;\n\n\t/* since we are recycling buffers we should seldom need to alloc */\n\tif (likely(page))\n\t\treturn true;\n\n\t/* alloc new page for storage */\n\tpage = dev_alloc_pages(igb_rx_pg_order(rx_ring));\n\tif (unlikely(!page)) {\n\t\trx_ring->rx_stats.alloc_failed++;\n\t\treturn false;\n\t}\n\n\t/* map page for use */\n\tdma = dma_map_page_attrs(rx_ring->dev, page, 0,\n\t\t\t\t igb_rx_pg_size(rx_ring),\n\t\t\t\t DMA_FROM_DEVICE,\n\t\t\t\t IGB_RX_DMA_ATTR);\n\n\t/* if mapping failed free memory back to system since\n\t * there isn't much point in holding memory we can't use\n\t */\n\tif (dma_mapping_error(rx_ring->dev, dma)) {\n\t\t__free_pages(page, igb_rx_pg_order(rx_ring));\n\n\t\trx_ring->rx_stats.alloc_failed++;\n\t\treturn false;\n\t}\n\n\tbi->dma = dma;\n\tbi->page = page;\n\tbi->page_offset = igb_rx_offset(rx_ring);\n\tpage_ref_add(page, USHRT_MAX - 1);\n\tbi->pagecnt_bias = USHRT_MAX;\n\n\treturn true;\n}\n\n/**\n *  igb_alloc_rx_buffers - Replace used receive buffers\n *  @rx_ring: rx descriptor ring to allocate new receive buffers\n *  @cleaned_count: count of buffers to allocate\n **/\nvoid igb_alloc_rx_buffers(struct igb_ring *rx_ring, u16 cleaned_count)\n{\n\tunion e1000_adv_rx_desc *rx_desc;\n\tstruct igb_rx_buffer *bi;\n\tu16 i = rx_ring->next_to_use;\n\tu16 bufsz;\n\n\t/* nothing to do */\n\tif (!cleaned_count)\n\t\treturn;\n\n\trx_desc = IGB_RX_DESC(rx_ring, i);\n\tbi = &rx_ring->rx_buffer_info[i];\n\ti -= rx_ring->count;\n\n\tbufsz = igb_rx_bufsz(rx_ring);\n\n\tdo {\n\t\tif (!igb_alloc_mapped_page(rx_ring, bi))\n\t\t\tbreak;\n\n\t\t/* sync the buffer for use by the device */\n\t\tdma_sync_single_range_for_device(rx_ring->dev, bi->dma,\n\t\t\t\t\t\t bi->page_offset, bufsz,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\n\t\t/* Refresh the desc even if buffer_addrs didn't change\n\t\t * because each write-back erases this info.\n\t\t */\n\t\trx_desc->read.pkt_addr = cpu_to_le64(bi->dma + bi->page_offset);\n\n\t\trx_desc++;\n\t\tbi++;\n\t\ti++;\n\t\tif (unlikely(!i)) {\n\t\t\trx_desc = IGB_RX_DESC(rx_ring, 0);\n\t\t\tbi = rx_ring->rx_buffer_info;\n\t\t\ti -= rx_ring->count;\n\t\t}\n\n\t\t/* clear the length for the next_to_use descriptor */\n\t\trx_desc->wb.upper.length = 0;\n\n\t\tcleaned_count--;\n\t} while (cleaned_count);\n\n\ti += rx_ring->count;\n\n\tif (rx_ring->next_to_use != i) {\n\t\t/* record the next descriptor to use */\n\t\trx_ring->next_to_use = i;\n\n\t\t/* update next to alloc since we have filled the ring */\n\t\trx_ring->next_to_alloc = i;\n\n\t\t/* Force memory writes to complete before letting h/w\n\t\t * know there are new descriptors to fetch.  (Only\n\t\t * applicable for weak-ordered memory model archs,\n\t\t * such as IA-64).\n\t\t */\n\t\tdma_wmb();\n\t\twritel(i, rx_ring->tail);\n\t}\n}\n\n/**\n * igb_mii_ioctl -\n * @netdev: pointer to netdev struct\n * @ifr: interface structure\n * @cmd: ioctl command to execute\n **/\nstatic int igb_mii_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct mii_ioctl_data *data = if_mii(ifr);\n\n\tif (adapter->hw.phy.media_type != e1000_media_type_copper)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tdata->phy_id = adapter->hw.phy.addr;\n\t\tbreak;\n\tcase SIOCGMIIREG:\n\t\tif (igb_read_phy_reg(&adapter->hw, data->reg_num & 0x1F,\n\t\t\t\t     &data->val_out))\n\t\t\treturn -EIO;\n\t\tbreak;\n\tcase SIOCSMIIREG:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n/**\n * igb_ioctl -\n * @netdev: pointer to netdev struct\n * @ifr: interface structure\n * @cmd: ioctl command to execute\n **/\nstatic int igb_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\treturn igb_mii_ioctl(netdev, ifr, cmd);\n\tcase SIOCGHWTSTAMP:\n\t\treturn igb_ptp_get_ts_config(netdev, ifr);\n\tcase SIOCSHWTSTAMP:\n\t\treturn igb_ptp_set_ts_config(netdev, ifr);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nvoid igb_read_pci_cfg(struct e1000_hw *hw, u32 reg, u16 *value)\n{\n\tstruct igb_adapter *adapter = hw->back;\n\n\tpci_read_config_word(adapter->pdev, reg, value);\n}\n\nvoid igb_write_pci_cfg(struct e1000_hw *hw, u32 reg, u16 *value)\n{\n\tstruct igb_adapter *adapter = hw->back;\n\n\tpci_write_config_word(adapter->pdev, reg, *value);\n}\n\ns32 igb_read_pcie_cap_reg(struct e1000_hw *hw, u32 reg, u16 *value)\n{\n\tstruct igb_adapter *adapter = hw->back;\n\n\tif (pcie_capability_read_word(adapter->pdev, reg, value))\n\t\treturn -E1000_ERR_CONFIG;\n\n\treturn 0;\n}\n\ns32 igb_write_pcie_cap_reg(struct e1000_hw *hw, u32 reg, u16 *value)\n{\n\tstruct igb_adapter *adapter = hw->back;\n\n\tif (pcie_capability_write_word(adapter->pdev, reg, *value))\n\t\treturn -E1000_ERR_CONFIG;\n\n\treturn 0;\n}\n\nstatic void igb_vlan_mode(struct net_device *netdev, netdev_features_t features)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl, rctl;\n\tbool enable = !!(features & NETIF_F_HW_VLAN_CTAG_RX);\n\n\tif (enable) {\n\t\t/* enable VLAN tag insert/strip */\n\t\tctrl = rd32(E1000_CTRL);\n\t\tctrl |= E1000_CTRL_VME;\n\t\twr32(E1000_CTRL, ctrl);\n\n\t\t/* Disable CFI check */\n\t\trctl = rd32(E1000_RCTL);\n\t\trctl &= ~E1000_RCTL_CFIEN;\n\t\twr32(E1000_RCTL, rctl);\n\t} else {\n\t\t/* disable VLAN tag insert/strip */\n\t\tctrl = rd32(E1000_CTRL);\n\t\tctrl &= ~E1000_CTRL_VME;\n\t\twr32(E1000_CTRL, ctrl);\n\t}\n\n\tigb_set_vf_vlan_strip(adapter, adapter->vfs_allocated_count, enable);\n}\n\nstatic int igb_vlan_rx_add_vid(struct net_device *netdev,\n\t\t\t       __be16 proto, u16 vid)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint pf_id = adapter->vfs_allocated_count;\n\n\t/* add the filter since PF can receive vlans w/o entry in vlvf */\n\tif (!vid || !(adapter->flags & IGB_FLAG_VLAN_PROMISC))\n\t\tigb_vfta_set(hw, vid, pf_id, true, !!vid);\n\n\tset_bit(vid, adapter->active_vlans);\n\n\treturn 0;\n}\n\nstatic int igb_vlan_rx_kill_vid(struct net_device *netdev,\n\t\t\t\t__be16 proto, u16 vid)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tint pf_id = adapter->vfs_allocated_count;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t/* remove VID from filter table */\n\tif (vid && !(adapter->flags & IGB_FLAG_VLAN_PROMISC))\n\t\tigb_vfta_set(hw, vid, pf_id, false, true);\n\n\tclear_bit(vid, adapter->active_vlans);\n\n\treturn 0;\n}\n\nstatic void igb_restore_vlan(struct igb_adapter *adapter)\n{\n\tu16 vid = 1;\n\n\tigb_vlan_mode(adapter->netdev, adapter->netdev->features);\n\tigb_vlan_rx_add_vid(adapter->netdev, htons(ETH_P_8021Q), 0);\n\n\tfor_each_set_bit_from(vid, adapter->active_vlans, VLAN_N_VID)\n\t\tigb_vlan_rx_add_vid(adapter->netdev, htons(ETH_P_8021Q), vid);\n}\n\nint igb_set_spd_dplx(struct igb_adapter *adapter, u32 spd, u8 dplx)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_mac_info *mac = &adapter->hw.mac;\n\n\tmac->autoneg = 0;\n\n\t/* Make sure dplx is at most 1 bit and lsb of speed is not set\n\t * for the switch() below to work\n\t */\n\tif ((spd & 1) || (dplx & ~1))\n\t\tgoto err_inval;\n\n\t/* Fiber NIC's only allow 1000 gbps Full duplex\n\t * and 100Mbps Full duplex for 100baseFx sfp\n\t */\n\tif (adapter->hw.phy.media_type == e1000_media_type_internal_serdes) {\n\t\tswitch (spd + dplx) {\n\t\tcase SPEED_10 + DUPLEX_HALF:\n\t\tcase SPEED_10 + DUPLEX_FULL:\n\t\tcase SPEED_100 + DUPLEX_HALF:\n\t\t\tgoto err_inval;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (spd + dplx) {\n\tcase SPEED_10 + DUPLEX_HALF:\n\t\tmac->forced_speed_duplex = ADVERTISE_10_HALF;\n\t\tbreak;\n\tcase SPEED_10 + DUPLEX_FULL:\n\t\tmac->forced_speed_duplex = ADVERTISE_10_FULL;\n\t\tbreak;\n\tcase SPEED_100 + DUPLEX_HALF:\n\t\tmac->forced_speed_duplex = ADVERTISE_100_HALF;\n\t\tbreak;\n\tcase SPEED_100 + DUPLEX_FULL:\n\t\tmac->forced_speed_duplex = ADVERTISE_100_FULL;\n\t\tbreak;\n\tcase SPEED_1000 + DUPLEX_FULL:\n\t\tmac->autoneg = 1;\n\t\tadapter->hw.phy.autoneg_advertised = ADVERTISE_1000_FULL;\n\t\tbreak;\n\tcase SPEED_1000 + DUPLEX_HALF: /* not supported */\n\tdefault:\n\t\tgoto err_inval;\n\t}\n\n\t/* clear MDI, MDI(-X) override is only allowed when autoneg enabled */\n\tadapter->hw.phy.mdix = AUTO_ALL_MODES;\n\n\treturn 0;\n\nerr_inval:\n\tdev_err(&pdev->dev, \"Unsupported Speed/Duplex configuration\\n\");\n\treturn -EINVAL;\n}\n\nstatic int __igb_shutdown(struct pci_dev *pdev, bool *enable_wake,\n\t\t\t  bool runtime)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl, rctl, status;\n\tu32 wufc = runtime ? E1000_WUFC_LNKC : adapter->wol;\n\tbool wake;\n\n\trtnl_lock();\n\tnetif_device_detach(netdev);\n\n\tif (netif_running(netdev))\n\t\t__igb_close(netdev, true);\n\n\tigb_ptp_suspend(adapter);\n\n\tigb_clear_interrupt_scheme(adapter);\n\trtnl_unlock();\n\n\tstatus = rd32(E1000_STATUS);\n\tif (status & E1000_STATUS_LU)\n\t\twufc &= ~E1000_WUFC_LNKC;\n\n\tif (wufc) {\n\t\tigb_setup_rctl(adapter);\n\t\tigb_set_rx_mode(netdev);\n\n\t\t/* turn on all-multi mode if wake on multicast is enabled */\n\t\tif (wufc & E1000_WUFC_MC) {\n\t\t\trctl = rd32(E1000_RCTL);\n\t\t\trctl |= E1000_RCTL_MPE;\n\t\t\twr32(E1000_RCTL, rctl);\n\t\t}\n\n\t\tctrl = rd32(E1000_CTRL);\n\t\tctrl |= E1000_CTRL_ADVD3WUC;\n\t\twr32(E1000_CTRL, ctrl);\n\n\t\t/* Allow time for pending master requests to run */\n\t\tigb_disable_pcie_master(hw);\n\n\t\twr32(E1000_WUC, E1000_WUC_PME_EN);\n\t\twr32(E1000_WUFC, wufc);\n\t} else {\n\t\twr32(E1000_WUC, 0);\n\t\twr32(E1000_WUFC, 0);\n\t}\n\n\twake = wufc || adapter->en_mng_pt;\n\tif (!wake)\n\t\tigb_power_down_link(adapter);\n\telse\n\t\tigb_power_up_link(adapter);\n\n\tif (enable_wake)\n\t\t*enable_wake = wake;\n\n\t/* Release control of h/w to f/w.  If f/w is AMT enabled, this\n\t * would have already happened in close and is redundant.\n\t */\n\tigb_release_hw_control(adapter);\n\n\tpci_disable_device(pdev);\n\n\treturn 0;\n}\n\nstatic void igb_deliver_wake_packet(struct net_device *netdev)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct sk_buff *skb;\n\tu32 wupl;\n\n\twupl = rd32(E1000_WUPL) & E1000_WUPL_MASK;\n\n\t/* WUPM stores only the first 128 bytes of the wake packet.\n\t * Read the packet only if we have the whole thing.\n\t */\n\tif ((wupl == 0) || (wupl > E1000_WUPM_BYTES))\n\t\treturn;\n\n\tskb = netdev_alloc_skb_ip_align(netdev, E1000_WUPM_BYTES);\n\tif (!skb)\n\t\treturn;\n\n\tskb_put(skb, wupl);\n\n\t/* Ensure reads are 32-bit aligned */\n\twupl = roundup(wupl, 4);\n\n\tmemcpy_fromio(skb->data, hw->hw_addr + E1000_WUPM_REG(0), wupl);\n\n\tskb->protocol = eth_type_trans(skb, netdev);\n\tnetif_rx(skb);\n}\n\nstatic int __maybe_unused igb_suspend(struct device *dev)\n{\n\treturn __igb_shutdown(to_pci_dev(dev), NULL, 0);\n}\n\nstatic int __maybe_unused igb_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 err, val;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_restore_state(pdev);\n\tpci_save_state(pdev);\n\n\tif (!pci_device_is_present(pdev))\n\t\treturn -ENODEV;\n\terr = pci_enable_device_mem(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"igb: Cannot enable PCI device from suspend\\n\");\n\t\treturn err;\n\t}\n\tpci_set_master(pdev);\n\n\tpci_enable_wake(pdev, PCI_D3hot, 0);\n\tpci_enable_wake(pdev, PCI_D3cold, 0);\n\n\tif (igb_init_interrupt_scheme(adapter, true)) {\n\t\tdev_err(&pdev->dev, \"Unable to allocate memory for queues\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tigb_reset(adapter);\n\n\t/* let the f/w know that the h/w is now under the control of the\n\t * driver.\n\t */\n\tigb_get_hw_control(adapter);\n\n\tval = rd32(E1000_WUS);\n\tif (val & WAKE_PKT_WUS)\n\t\tigb_deliver_wake_packet(netdev);\n\n\twr32(E1000_WUS, ~0);\n\n\trtnl_lock();\n\tif (!err && netif_running(netdev))\n\t\terr = __igb_open(netdev, true);\n\n\tif (!err)\n\t\tnetif_device_attach(netdev);\n\trtnl_unlock();\n\n\treturn err;\n}\n\nstatic int __maybe_unused igb_runtime_idle(struct device *dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev);\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\n\tif (!igb_has_link(adapter))\n\t\tpm_schedule_suspend(dev, MSEC_PER_SEC * 5);\n\n\treturn -EBUSY;\n}\n\nstatic int __maybe_unused igb_runtime_suspend(struct device *dev)\n{\n\treturn __igb_shutdown(to_pci_dev(dev), NULL, 1);\n}\n\nstatic int __maybe_unused igb_runtime_resume(struct device *dev)\n{\n\treturn igb_resume(dev);\n}\n\nstatic void igb_shutdown(struct pci_dev *pdev)\n{\n\tbool wake;\n\n\t__igb_shutdown(pdev, &wake, 0);\n\n\tif (system_state == SYSTEM_POWER_OFF) {\n\t\tpci_wake_from_d3(pdev, wake);\n\t\tpci_set_power_state(pdev, PCI_D3hot);\n\t}\n}\n\n#ifdef CONFIG_PCI_IOV\nstatic int igb_sriov_reinit(struct pci_dev *dev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(dev);\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\trtnl_lock();\n\n\tif (netif_running(netdev))\n\t\tigb_close(netdev);\n\telse\n\t\tigb_reset(adapter);\n\n\tigb_clear_interrupt_scheme(adapter);\n\n\tigb_init_queue_configuration(adapter);\n\n\tif (igb_init_interrupt_scheme(adapter, true)) {\n\t\trtnl_unlock();\n\t\tdev_err(&pdev->dev, \"Unable to allocate memory for queues\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (netif_running(netdev))\n\t\tigb_open(netdev);\n\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nstatic int igb_pci_disable_sriov(struct pci_dev *dev)\n{\n\tint err = igb_disable_sriov(dev);\n\n\tif (!err)\n\t\terr = igb_sriov_reinit(dev);\n\n\treturn err;\n}\n\nstatic int igb_pci_enable_sriov(struct pci_dev *dev, int num_vfs)\n{\n\tint err = igb_enable_sriov(dev, num_vfs);\n\n\tif (err)\n\t\tgoto out;\n\n\terr = igb_sriov_reinit(dev);\n\tif (!err)\n\t\treturn num_vfs;\n\nout:\n\treturn err;\n}\n\n#endif\nstatic int igb_pci_sriov_configure(struct pci_dev *dev, int num_vfs)\n{\n#ifdef CONFIG_PCI_IOV\n\tif (num_vfs == 0)\n\t\treturn igb_pci_disable_sriov(dev);\n\telse\n\t\treturn igb_pci_enable_sriov(dev, num_vfs);\n#endif\n\treturn 0;\n}\n\n/**\n *  igb_io_error_detected - called when PCI error is detected\n *  @pdev: Pointer to PCI device\n *  @state: The current pci connection state\n *\n *  This function is called after a PCI bus error affecting\n *  this device has been detected.\n **/\nstatic pci_ers_result_t igb_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t      pci_channel_state_t state)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\n\tnetif_device_detach(netdev);\n\n\tif (state == pci_channel_io_perm_failure)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tif (netif_running(netdev))\n\t\tigb_down(adapter);\n\tpci_disable_device(pdev);\n\n\t/* Request a slot slot reset. */\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n/**\n *  igb_io_slot_reset - called after the pci bus has been reset.\n *  @pdev: Pointer to PCI device\n *\n *  Restart the card from scratch, as if from a cold-boot. Implementation\n *  resembles the first-half of the igb_resume routine.\n **/\nstatic pci_ers_result_t igb_io_slot_reset(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tpci_ers_result_t result;\n\n\tif (pci_enable_device_mem(pdev)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot re-enable PCI device after reset.\\n\");\n\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t} else {\n\t\tpci_set_master(pdev);\n\t\tpci_restore_state(pdev);\n\t\tpci_save_state(pdev);\n\n\t\tpci_enable_wake(pdev, PCI_D3hot, 0);\n\t\tpci_enable_wake(pdev, PCI_D3cold, 0);\n\n\t\t/* In case of PCI error, adapter lose its HW address\n\t\t * so we should re-assign it here.\n\t\t */\n\t\thw->hw_addr = adapter->io_addr;\n\n\t\tigb_reset(adapter);\n\t\twr32(E1000_WUS, ~0);\n\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t}\n\n\treturn result;\n}\n\n/**\n *  igb_io_resume - called when traffic can start flowing again.\n *  @pdev: Pointer to PCI device\n *\n *  This callback is called when the error recovery driver tells us that\n *  its OK to resume normal operation. Implementation resembles the\n *  second-half of the igb_resume routine.\n */\nstatic void igb_io_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\n\tif (netif_running(netdev)) {\n\t\tif (igb_up(adapter)) {\n\t\t\tdev_err(&pdev->dev, \"igb_up failed after reset\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tnetif_device_attach(netdev);\n\n\t/* let the f/w know that the h/w is now under the control of the\n\t * driver.\n\t */\n\tigb_get_hw_control(adapter);\n}\n\n/**\n *  igb_rar_set_index - Sync RAL[index] and RAH[index] registers with MAC table\n *  @adapter: Pointer to adapter structure\n *  @index: Index of the RAR entry which need to be synced with MAC table\n **/\nstatic void igb_rar_set_index(struct igb_adapter *adapter, u32 index)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rar_low, rar_high;\n\tu8 *addr = adapter->mac_table[index].addr;\n\n\t/* HW expects these to be in network order when they are plugged\n\t * into the registers which are little endian.  In order to guarantee\n\t * that ordering we need to do an leXX_to_cpup here in order to be\n\t * ready for the byteswap that occurs with writel\n\t */\n\trar_low = le32_to_cpup((__le32 *)(addr));\n\trar_high = le16_to_cpup((__le16 *)(addr + 4));\n\n\t/* Indicate to hardware the Address is Valid. */\n\tif (adapter->mac_table[index].state & IGB_MAC_STATE_IN_USE) {\n\t\tif (is_valid_ether_addr(addr))\n\t\t\trar_high |= E1000_RAH_AV;\n\n\t\tif (adapter->mac_table[index].state & IGB_MAC_STATE_SRC_ADDR)\n\t\t\trar_high |= E1000_RAH_ASEL_SRC_ADDR;\n\n\t\tswitch (hw->mac.type) {\n\t\tcase e1000_82575:\n\t\tcase e1000_i210:\n\t\t\tif (adapter->mac_table[index].state &\n\t\t\t    IGB_MAC_STATE_QUEUE_STEERING)\n\t\t\t\trar_high |= E1000_RAH_QSEL_ENABLE;\n\n\t\t\trar_high |= E1000_RAH_POOL_1 *\n\t\t\t\t    adapter->mac_table[index].queue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trar_high |= E1000_RAH_POOL_1 <<\n\t\t\t\t    adapter->mac_table[index].queue;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twr32(E1000_RAL(index), rar_low);\n\twrfl();\n\twr32(E1000_RAH(index), rar_high);\n\twrfl();\n}\n\nstatic int igb_set_vf_mac(struct igb_adapter *adapter,\n\t\t\t  int vf, unsigned char *mac_addr)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\t/* VF MAC addresses start at end of receive addresses and moves\n\t * towards the first, as a result a collision should not be possible\n\t */\n\tint rar_entry = hw->mac.rar_entry_count - (vf + 1);\n\tunsigned char *vf_mac_addr = adapter->vf_data[vf].vf_mac_addresses;\n\n\tether_addr_copy(vf_mac_addr, mac_addr);\n\tether_addr_copy(adapter->mac_table[rar_entry].addr, mac_addr);\n\tadapter->mac_table[rar_entry].queue = vf;\n\tadapter->mac_table[rar_entry].state |= IGB_MAC_STATE_IN_USE;\n\tigb_rar_set_index(adapter, rar_entry);\n\n\treturn 0;\n}\n\nstatic int igb_ndo_set_vf_mac(struct net_device *netdev, int vf, u8 *mac)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\n\tif (vf >= adapter->vfs_allocated_count)\n\t\treturn -EINVAL;\n\n\t/* Setting the VF MAC to 0 reverts the IGB_VF_FLAG_PF_SET_MAC\n\t * flag and allows to overwrite the MAC via VF netdev.  This\n\t * is necessary to allow libvirt a way to restore the original\n\t * MAC after unbinding vfio-pci and reloading igbvf after shutting\n\t * down a VM.\n\t */\n\tif (is_zero_ether_addr(mac)) {\n\t\tadapter->vf_data[vf].flags &= ~IGB_VF_FLAG_PF_SET_MAC;\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"remove administratively set MAC on VF %d\\n\",\n\t\t\t vf);\n\t} else if (is_valid_ether_addr(mac)) {\n\t\tadapter->vf_data[vf].flags |= IGB_VF_FLAG_PF_SET_MAC;\n\t\tdev_info(&adapter->pdev->dev, \"setting MAC %pM on VF %d\\n\",\n\t\t\t mac, vf);\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"Reload the VF driver to make this change effective.\");\n\t\t/* Generate additional warning if PF is down */\n\t\tif (test_bit(__IGB_DOWN, &adapter->state)) {\n\t\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t\t \"The VF MAC address has been set, but the PF device is not up.\\n\");\n\t\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t\t \"Bring the PF device up before attempting to use the VF device.\\n\");\n\t\t}\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn igb_set_vf_mac(adapter, vf, mac);\n}\n\nstatic int igb_link_mbps(int internal_link_speed)\n{\n\tswitch (internal_link_speed) {\n\tcase SPEED_100:\n\t\treturn 100;\n\tcase SPEED_1000:\n\t\treturn 1000;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void igb_set_vf_rate_limit(struct e1000_hw *hw, int vf, int tx_rate,\n\t\t\t\t  int link_speed)\n{\n\tint rf_dec, rf_int;\n\tu32 bcnrc_val;\n\n\tif (tx_rate != 0) {\n\t\t/* Calculate the rate factor values to set */\n\t\trf_int = link_speed / tx_rate;\n\t\trf_dec = (link_speed - (rf_int * tx_rate));\n\t\trf_dec = (rf_dec * BIT(E1000_RTTBCNRC_RF_INT_SHIFT)) /\n\t\t\t tx_rate;\n\n\t\tbcnrc_val = E1000_RTTBCNRC_RS_ENA;\n\t\tbcnrc_val |= ((rf_int << E1000_RTTBCNRC_RF_INT_SHIFT) &\n\t\t\t      E1000_RTTBCNRC_RF_INT_MASK);\n\t\tbcnrc_val |= (rf_dec & E1000_RTTBCNRC_RF_DEC_MASK);\n\t} else {\n\t\tbcnrc_val = 0;\n\t}\n\n\twr32(E1000_RTTDQSEL, vf); /* vf X uses queue X */\n\t/* Set global transmit compensation time to the MMW_SIZE in RTTBCNRM\n\t * register. MMW_SIZE=0x014 if 9728-byte jumbo is supported.\n\t */\n\twr32(E1000_RTTBCNRM, 0x14);\n\twr32(E1000_RTTBCNRC, bcnrc_val);\n}\n\nstatic void igb_check_vf_rate_limit(struct igb_adapter *adapter)\n{\n\tint actual_link_speed, i;\n\tbool reset_rate = false;\n\n\t/* VF TX rate limit was not set or not supported */\n\tif ((adapter->vf_rate_link_speed == 0) ||\n\t    (adapter->hw.mac.type != e1000_82576))\n\t\treturn;\n\n\tactual_link_speed = igb_link_mbps(adapter->link_speed);\n\tif (actual_link_speed != adapter->vf_rate_link_speed) {\n\t\treset_rate = true;\n\t\tadapter->vf_rate_link_speed = 0;\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"Link speed has been changed. VF Transmit rate is disabled\\n\");\n\t}\n\n\tfor (i = 0; i < adapter->vfs_allocated_count; i++) {\n\t\tif (reset_rate)\n\t\t\tadapter->vf_data[i].tx_rate = 0;\n\n\t\tigb_set_vf_rate_limit(&adapter->hw, i,\n\t\t\t\t      adapter->vf_data[i].tx_rate,\n\t\t\t\t      actual_link_speed);\n\t}\n}\n\nstatic int igb_ndo_set_vf_bw(struct net_device *netdev, int vf,\n\t\t\t     int min_tx_rate, int max_tx_rate)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint actual_link_speed;\n\n\tif (hw->mac.type != e1000_82576)\n\t\treturn -EOPNOTSUPP;\n\n\tif (min_tx_rate)\n\t\treturn -EINVAL;\n\n\tactual_link_speed = igb_link_mbps(adapter->link_speed);\n\tif ((vf >= adapter->vfs_allocated_count) ||\n\t    (!(rd32(E1000_STATUS) & E1000_STATUS_LU)) ||\n\t    (max_tx_rate < 0) ||\n\t    (max_tx_rate > actual_link_speed))\n\t\treturn -EINVAL;\n\n\tadapter->vf_rate_link_speed = actual_link_speed;\n\tadapter->vf_data[vf].tx_rate = (u16)max_tx_rate;\n\tigb_set_vf_rate_limit(hw, vf, max_tx_rate, actual_link_speed);\n\n\treturn 0;\n}\n\nstatic int igb_ndo_set_vf_spoofchk(struct net_device *netdev, int vf,\n\t\t\t\t   bool setting)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 reg_val, reg_offset;\n\n\tif (!adapter->vfs_allocated_count)\n\t\treturn -EOPNOTSUPP;\n\n\tif (vf >= adapter->vfs_allocated_count)\n\t\treturn -EINVAL;\n\n\treg_offset = (hw->mac.type == e1000_82576) ? E1000_DTXSWC : E1000_TXSWC;\n\treg_val = rd32(reg_offset);\n\tif (setting)\n\t\treg_val |= (BIT(vf) |\n\t\t\t    BIT(vf + E1000_DTXSWC_VLAN_SPOOF_SHIFT));\n\telse\n\t\treg_val &= ~(BIT(vf) |\n\t\t\t     BIT(vf + E1000_DTXSWC_VLAN_SPOOF_SHIFT));\n\twr32(reg_offset, reg_val);\n\n\tadapter->vf_data[vf].spoofchk_enabled = setting;\n\treturn 0;\n}\n\nstatic int igb_ndo_set_vf_trust(struct net_device *netdev, int vf, bool setting)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\n\tif (vf >= adapter->vfs_allocated_count)\n\t\treturn -EINVAL;\n\tif (adapter->vf_data[vf].trusted == setting)\n\t\treturn 0;\n\n\tadapter->vf_data[vf].trusted = setting;\n\n\tdev_info(&adapter->pdev->dev, \"VF %u is %strusted\\n\",\n\t\t vf, setting ? \"\" : \"not \");\n\treturn 0;\n}\n\nstatic int igb_ndo_get_vf_config(struct net_device *netdev,\n\t\t\t\t int vf, struct ifla_vf_info *ivi)\n{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tif (vf >= adapter->vfs_allocated_count)\n\t\treturn -EINVAL;\n\tivi->vf = vf;\n\tmemcpy(&ivi->mac, adapter->vf_data[vf].vf_mac_addresses, ETH_ALEN);\n\tivi->max_tx_rate = adapter->vf_data[vf].tx_rate;\n\tivi->min_tx_rate = 0;\n\tivi->vlan = adapter->vf_data[vf].pf_vlan;\n\tivi->qos = adapter->vf_data[vf].pf_qos;\n\tivi->spoofchk = adapter->vf_data[vf].spoofchk_enabled;\n\tivi->trusted = adapter->vf_data[vf].trusted;\n\treturn 0;\n}\n\nstatic void igb_vmm_control(struct igb_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 reg;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_82575:\n\tcase e1000_i210:\n\tcase e1000_i211:\n\tcase e1000_i354:\n\tdefault:\n\t\t/* replication is not supported for 82575 */\n\t\treturn;\n\tcase e1000_82576:\n\t\t/* notify HW that the MAC is adding vlan tags */\n\t\treg = rd32(E1000_DTXCTL);\n\t\treg |= E1000_DTXCTL_VLAN_ADDED;\n\t\twr32(E1000_DTXCTL, reg);\n\t\tfallthrough;\n\tcase e1000_82580:\n\t\t/* enable replication vlan tag stripping */\n\t\treg = rd32(E1000_RPLOLR);\n\t\treg |= E1000_RPLOLR_STRVLAN;\n\t\twr32(E1000_RPLOLR, reg);\n\t\tfallthrough;\n\tcase e1000_i350:\n\t\t/* none of the above registers are supported by i350 */\n\t\tbreak;\n\t}\n\n\tif (adapter->vfs_allocated_count) {\n\t\tigb_vmdq_set_loopback_pf(hw, true);\n\t\tigb_vmdq_set_replication_pf(hw, true);\n\t\tigb_vmdq_set_anti_spoofing_pf(hw, true,\n\t\t\t\t\t      adapter->vfs_allocated_count);\n\t} else {\n\t\tigb_vmdq_set_loopback_pf(hw, false);\n\t\tigb_vmdq_set_replication_pf(hw, false);\n\t}\n}\n\nstatic void igb_init_dmac(struct igb_adapter *adapter, u32 pba)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 dmac_thr;\n\tu16 hwm;\n\n\tif (hw->mac.type > e1000_82580) {\n\t\tif (adapter->flags & IGB_FLAG_DMAC) {\n\t\t\tu32 reg;\n\n\t\t\t/* force threshold to 0. */\n\t\t\twr32(E1000_DMCTXTH, 0);\n\n\t\t\t/* DMA Coalescing high water mark needs to be greater\n\t\t\t * than the Rx threshold. Set hwm to PBA - max frame\n\t\t\t * size in 16B units, capping it at PBA - 6KB.\n\t\t\t */\n\t\t\thwm = 64 * (pba - 6);\n\t\t\treg = rd32(E1000_FCRTC);\n\t\t\treg &= ~E1000_FCRTC_RTH_COAL_MASK;\n\t\t\treg |= ((hwm << E1000_FCRTC_RTH_COAL_SHIFT)\n\t\t\t\t& E1000_FCRTC_RTH_COAL_MASK);\n\t\t\twr32(E1000_FCRTC, reg);\n\n\t\t\t/* Set the DMA Coalescing Rx threshold to PBA - 2 * max\n\t\t\t * frame size, capping it at PBA - 10KB.\n\t\t\t */\n\t\t\tdmac_thr = pba - 10;\n\t\t\treg = rd32(E1000_DMACR);\n\t\t\treg &= ~E1000_DMACR_DMACTHR_MASK;\n\t\t\treg |= ((dmac_thr << E1000_DMACR_DMACTHR_SHIFT)\n\t\t\t\t& E1000_DMACR_DMACTHR_MASK);\n\n\t\t\t/* transition to L0x or L1 if available..*/\n\t\t\treg |= (E1000_DMACR_DMAC_EN | E1000_DMACR_DMAC_LX_MASK);\n\n\t\t\t/* watchdog timer= +-1000 usec in 32usec intervals */\n\t\t\treg |= (1000 >> 5);\n\n\t\t\t/* Disable BMC-to-OS Watchdog Enable */\n\t\t\tif (hw->mac.type != e1000_i354)\n\t\t\t\treg &= ~E1000_DMACR_DC_BMC2OSW_EN;\n\n\t\t\twr32(E1000_DMACR, reg);\n\n\t\t\t/* no lower threshold to disable\n\t\t\t * coalescing(smart fifb)-UTRESH=0\n\t\t\t */\n\t\t\twr32(E1000_DMCRTRH, 0);\n\n\t\t\treg = (IGB_DMCTLX_DCFLUSH_DIS | 0x4);\n\n\t\t\twr32(E1000_DMCTLX, reg);\n\n\t\t\t/* free space in tx packet buffer to wake from\n\t\t\t * DMA coal\n\t\t\t */\n\t\t\twr32(E1000_DMCTXTH, (IGB_MIN_TXPBSIZE -\n\t\t\t     (IGB_TX_BUF_4096 + adapter->max_frame_size)) >> 6);\n\n\t\t\t/* make low power state decision controlled\n\t\t\t * by DMA coal\n\t\t\t */\n\t\t\treg = rd32(E1000_PCIEMISC);\n\t\t\treg &= ~E1000_PCIEMISC_LX_DECISION;\n\t\t\twr32(E1000_PCIEMISC, reg);\n\t\t} /* endif adapter->dmac is not disabled */\n\t} else if (hw->mac.type == e1000_82580) {\n\t\tu32 reg = rd32(E1000_PCIEMISC);\n\n\t\twr32(E1000_PCIEMISC, reg & ~E1000_PCIEMISC_LX_DECISION);\n\t\twr32(E1000_DMACR, 0);\n\t}\n}\n\n/**\n *  igb_read_i2c_byte - Reads 8 bit word over I2C\n *  @hw: pointer to hardware structure\n *  @byte_offset: byte offset to read\n *  @dev_addr: device address\n *  @data: value read\n *\n *  Performs byte read operation over I2C interface at\n *  a specified device address.\n **/\ns32 igb_read_i2c_byte(struct e1000_hw *hw, u8 byte_offset,\n\t\t      u8 dev_addr, u8 *data)\n{\n\tstruct igb_adapter *adapter = container_of(hw, struct igb_adapter, hw);\n\tstruct i2c_client *this_client = adapter->i2c_client;\n\ts32 status;\n\tu16 swfw_mask = 0;\n\n\tif (!this_client)\n\t\treturn E1000_ERR_I2C;\n\n\tswfw_mask = E1000_SWFW_PHY0_SM;\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, swfw_mask))\n\t\treturn E1000_ERR_SWFW_SYNC;\n\n\tstatus = i2c_smbus_read_byte_data(this_client, byte_offset);\n\thw->mac.ops.release_swfw_sync(hw, swfw_mask);\n\n\tif (status < 0)\n\t\treturn E1000_ERR_I2C;\n\telse {\n\t\t*data = status;\n\t\treturn 0;\n\t}\n}\n\n/**\n *  igb_write_i2c_byte - Writes 8 bit word over I2C\n *  @hw: pointer to hardware structure\n *  @byte_offset: byte offset to write\n *  @dev_addr: device address\n *  @data: value to write\n *\n *  Performs byte write operation over I2C interface at\n *  a specified device address.\n **/\ns32 igb_write_i2c_byte(struct e1000_hw *hw, u8 byte_offset,\n\t\t       u8 dev_addr, u8 data)\n{\n\tstruct igb_adapter *adapter = container_of(hw, struct igb_adapter, hw);\n\tstruct i2c_client *this_client = adapter->i2c_client;\n\ts32 status;\n\tu16 swfw_mask = E1000_SWFW_PHY0_SM;\n\n\tif (!this_client)\n\t\treturn E1000_ERR_I2C;\n\n\tif (hw->mac.ops.acquire_swfw_sync(hw, swfw_mask))\n\t\treturn E1000_ERR_SWFW_SYNC;\n\tstatus = i2c_smbus_write_byte_data(this_client, byte_offset, data);\n\thw->mac.ops.release_swfw_sync(hw, swfw_mask);\n\n\tif (status)\n\t\treturn E1000_ERR_I2C;\n\telse\n\t\treturn 0;\n\n}\n\nint igb_reinit_queues(struct igb_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint err = 0;\n\n\tif (netif_running(netdev))\n\t\tigb_close(netdev);\n\n\tigb_reset_interrupt_capability(adapter);\n\n\tif (igb_init_interrupt_scheme(adapter, true)) {\n\t\tdev_err(&pdev->dev, \"Unable to allocate memory for queues\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (netif_running(netdev))\n\t\terr = igb_open(netdev);\n\n\treturn err;\n}\n\nstatic void igb_nfc_filter_exit(struct igb_adapter *adapter)\n{\n\tstruct igb_nfc_filter *rule;\n\n\tspin_lock(&adapter->nfc_lock);\n\n\thlist_for_each_entry(rule, &adapter->nfc_filter_list, nfc_node)\n\t\tigb_erase_filter(adapter, rule);\n\n\thlist_for_each_entry(rule, &adapter->cls_flower_list, nfc_node)\n\t\tigb_erase_filter(adapter, rule);\n\n\tspin_unlock(&adapter->nfc_lock);\n}\n\nstatic void igb_nfc_filter_restore(struct igb_adapter *adapter)\n{\n\tstruct igb_nfc_filter *rule;\n\n\tspin_lock(&adapter->nfc_lock);\n\n\thlist_for_each_entry(rule, &adapter->nfc_filter_list, nfc_node)\n\t\tigb_add_filter(adapter, rule);\n\n\tspin_unlock(&adapter->nfc_lock);\n}\n/* igb_main.c */\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 8771}, "message": "error: 'skb' dereferencing possible ERR_PTR()"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/intel/igb/igb_main.c", "reportHash": "b2e865365db33b20377b5a663caf281d", "checkerName": "smatch.check_err_ptr_deref", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
