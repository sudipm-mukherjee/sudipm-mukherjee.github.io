<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/net/ethernet/sun/niu.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/* niu.c: Neptune ethernet driver.\n *\n * Copyright (C) 2007, 2008 David S. Miller (davem@davemloft.net)\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/etherdevice.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n#include <linux/mii.h>\n#include <linux/if.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/ip.h>\n#include <linux/in.h>\n#include <linux/ipv6.h>\n#include <linux/log2.h>\n#include <linux/jiffies.h>\n#include <linux/crc32.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include <linux/io.h>\n#include <linux/of_device.h>\n\n#include \"niu.h\"\n\n#define DRV_MODULE_NAME\t\t\"niu\"\n#define DRV_MODULE_VERSION\t\"1.1\"\n#define DRV_MODULE_RELDATE\t\"Apr 22, 2010\"\n\nstatic char version[] =\n\tDRV_MODULE_NAME \".c:v\" DRV_MODULE_VERSION \" (\" DRV_MODULE_RELDATE \")\\n\";\n\nMODULE_AUTHOR(\"David S. Miller (davem@davemloft.net)\");\nMODULE_DESCRIPTION(\"NIU ethernet driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_MODULE_VERSION);\n\n#ifndef readq\nstatic u64 readq(void __iomem *reg)\n{\n\treturn ((u64) readl(reg)) | (((u64) readl(reg + 4UL)) << 32);\n}\n\nstatic void writeq(u64 val, void __iomem *reg)\n{\n\twritel(val & 0xffffffff, reg);\n\twritel(val >> 32, reg + 0x4UL);\n}\n#endif\n\nstatic const struct pci_device_id niu_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_SUN, 0xabcd)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, niu_pci_tbl);\n\n#define NIU_TX_TIMEOUT\t\t\t(5 * HZ)\n\n#define nr64(reg)\t\treadq(np->regs + (reg))\n#define nw64(reg, val)\t\twriteq((val), np->regs + (reg))\n\n#define nr64_mac(reg)\t\treadq(np->mac_regs + (reg))\n#define nw64_mac(reg, val)\twriteq((val), np->mac_regs + (reg))\n\n#define nr64_ipp(reg)\t\treadq(np->regs + np->ipp_off + (reg))\n#define nw64_ipp(reg, val)\twriteq((val), np->regs + np->ipp_off + (reg))\n\n#define nr64_pcs(reg)\t\treadq(np->regs + np->pcs_off + (reg))\n#define nw64_pcs(reg, val)\twriteq((val), np->regs + np->pcs_off + (reg))\n\n#define nr64_xpcs(reg)\t\treadq(np->regs + np->xpcs_off + (reg))\n#define nw64_xpcs(reg, val)\twriteq((val), np->regs + np->xpcs_off + (reg))\n\n#define NIU_MSG_DEFAULT (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)\n\nstatic int niu_debug;\nstatic int debug = -1;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"NIU debug level\");\n\n#define niu_lock_parent(np, flags) \\\n\tspin_lock_irqsave(&np->parent->lock, flags)\n#define niu_unlock_parent(np, flags) \\\n\tspin_unlock_irqrestore(&np->parent->lock, flags)\n\nstatic int serdes_init_10g_serdes(struct niu *np);\n\nstatic int __niu_wait_bits_clear_mac(struct niu *np, unsigned long reg,\n\t\t\t\t     u64 bits, int limit, int delay)\n{\n\twhile (--limit >= 0) {\n\t\tu64 val = nr64_mac(reg);\n\n\t\tif (!(val & bits))\n\t\t\tbreak;\n\t\tudelay(delay);\n\t}\n\tif (limit < 0)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int __niu_set_and_wait_clear_mac(struct niu *np, unsigned long reg,\n\t\t\t\t\tu64 bits, int limit, int delay,\n\t\t\t\t\tconst char *reg_name)\n{\n\tint err;\n\n\tnw64_mac(reg, bits);\n\terr = __niu_wait_bits_clear_mac(np, reg, bits, limit, delay);\n\tif (err)\n\t\tnetdev_err(np->dev, \"bits (%llx) of register %s would not clear, val[%llx]\\n\",\n\t\t\t   (unsigned long long)bits, reg_name,\n\t\t\t   (unsigned long long)nr64_mac(reg));\n\treturn err;\n}\n\n#define niu_set_and_wait_clear_mac(NP, REG, BITS, LIMIT, DELAY, REG_NAME) \\\n({\tBUILD_BUG_ON(LIMIT <= 0 || DELAY < 0); \\\n\t__niu_set_and_wait_clear_mac(NP, REG, BITS, LIMIT, DELAY, REG_NAME); \\\n})\n\nstatic int __niu_wait_bits_clear_ipp(struct niu *np, unsigned long reg,\n\t\t\t\t     u64 bits, int limit, int delay)\n{\n\twhile (--limit >= 0) {\n\t\tu64 val = nr64_ipp(reg);\n\n\t\tif (!(val & bits))\n\t\t\tbreak;\n\t\tudelay(delay);\n\t}\n\tif (limit < 0)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int __niu_set_and_wait_clear_ipp(struct niu *np, unsigned long reg,\n\t\t\t\t\tu64 bits, int limit, int delay,\n\t\t\t\t\tconst char *reg_name)\n{\n\tint err;\n\tu64 val;\n\n\tval = nr64_ipp(reg);\n\tval |= bits;\n\tnw64_ipp(reg, val);\n\n\terr = __niu_wait_bits_clear_ipp(np, reg, bits, limit, delay);\n\tif (err)\n\t\tnetdev_err(np->dev, \"bits (%llx) of register %s would not clear, val[%llx]\\n\",\n\t\t\t   (unsigned long long)bits, reg_name,\n\t\t\t   (unsigned long long)nr64_ipp(reg));\n\treturn err;\n}\n\n#define niu_set_and_wait_clear_ipp(NP, REG, BITS, LIMIT, DELAY, REG_NAME) \\\n({\tBUILD_BUG_ON(LIMIT <= 0 || DELAY < 0); \\\n\t__niu_set_and_wait_clear_ipp(NP, REG, BITS, LIMIT, DELAY, REG_NAME); \\\n})\n\nstatic int __niu_wait_bits_clear(struct niu *np, unsigned long reg,\n\t\t\t\t u64 bits, int limit, int delay)\n{\n\twhile (--limit >= 0) {\n\t\tu64 val = nr64(reg);\n\n\t\tif (!(val & bits))\n\t\t\tbreak;\n\t\tudelay(delay);\n\t}\n\tif (limit < 0)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\n#define niu_wait_bits_clear(NP, REG, BITS, LIMIT, DELAY) \\\n({\tBUILD_BUG_ON(LIMIT <= 0 || DELAY < 0); \\\n\t__niu_wait_bits_clear(NP, REG, BITS, LIMIT, DELAY); \\\n})\n\nstatic int __niu_set_and_wait_clear(struct niu *np, unsigned long reg,\n\t\t\t\t    u64 bits, int limit, int delay,\n\t\t\t\t    const char *reg_name)\n{\n\tint err;\n\n\tnw64(reg, bits);\n\terr = __niu_wait_bits_clear(np, reg, bits, limit, delay);\n\tif (err)\n\t\tnetdev_err(np->dev, \"bits (%llx) of register %s would not clear, val[%llx]\\n\",\n\t\t\t   (unsigned long long)bits, reg_name,\n\t\t\t   (unsigned long long)nr64(reg));\n\treturn err;\n}\n\n#define niu_set_and_wait_clear(NP, REG, BITS, LIMIT, DELAY, REG_NAME) \\\n({\tBUILD_BUG_ON(LIMIT <= 0 || DELAY < 0); \\\n\t__niu_set_and_wait_clear(NP, REG, BITS, LIMIT, DELAY, REG_NAME); \\\n})\n\nstatic void niu_ldg_rearm(struct niu *np, struct niu_ldg *lp, int on)\n{\n\tu64 val = (u64) lp->timer;\n\n\tif (on)\n\t\tval |= LDG_IMGMT_ARM;\n\n\tnw64(LDG_IMGMT(lp->ldg_num), val);\n}\n\nstatic int niu_ldn_irq_enable(struct niu *np, int ldn, int on)\n{\n\tunsigned long mask_reg, bits;\n\tu64 val;\n\n\tif (ldn < 0 || ldn > LDN_MAX)\n\t\treturn -EINVAL;\n\n\tif (ldn < 64) {\n\t\tmask_reg = LD_IM0(ldn);\n\t\tbits = LD_IM0_MASK;\n\t} else {\n\t\tmask_reg = LD_IM1(ldn - 64);\n\t\tbits = LD_IM1_MASK;\n\t}\n\n\tval = nr64(mask_reg);\n\tif (on)\n\t\tval &= ~bits;\n\telse\n\t\tval |= bits;\n\tnw64(mask_reg, val);\n\n\treturn 0;\n}\n\nstatic int niu_enable_ldn_in_ldg(struct niu *np, struct niu_ldg *lp, int on)\n{\n\tstruct niu_parent *parent = np->parent;\n\tint i;\n\n\tfor (i = 0; i <= LDN_MAX; i++) {\n\t\tint err;\n\n\t\tif (parent->ldg_map[i] != lp->ldg_num)\n\t\t\tcontinue;\n\n\t\terr = niu_ldn_irq_enable(np, i, on);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int niu_enable_interrupts(struct niu *np, int on)\n{\n\tint i;\n\n\tfor (i = 0; i < np->num_ldg; i++) {\n\t\tstruct niu_ldg *lp = &np->ldg[i];\n\t\tint err;\n\n\t\terr = niu_enable_ldn_in_ldg(np, lp, on);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tfor (i = 0; i < np->num_ldg; i++)\n\t\tniu_ldg_rearm(np, &np->ldg[i], on);\n\n\treturn 0;\n}\n\nstatic u32 phy_encode(u32 type, int port)\n{\n\treturn type << (port * 2);\n}\n\nstatic u32 phy_decode(u32 val, int port)\n{\n\treturn (val >> (port * 2)) & PORT_TYPE_MASK;\n}\n\nstatic int mdio_wait(struct niu *np)\n{\n\tint limit = 1000;\n\tu64 val;\n\n\twhile (--limit > 0) {\n\t\tval = nr64(MIF_FRAME_OUTPUT);\n\t\tif ((val >> MIF_FRAME_OUTPUT_TA_SHIFT) & 0x1)\n\t\t\treturn val & MIF_FRAME_OUTPUT_DATA;\n\n\t\tudelay(10);\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int mdio_read(struct niu *np, int port, int dev, int reg)\n{\n\tint err;\n\n\tnw64(MIF_FRAME_OUTPUT, MDIO_ADDR_OP(port, dev, reg));\n\terr = mdio_wait(np);\n\tif (err < 0)\n\t\treturn err;\n\n\tnw64(MIF_FRAME_OUTPUT, MDIO_READ_OP(port, dev));\n\treturn mdio_wait(np);\n}\n\nstatic int mdio_write(struct niu *np, int port, int dev, int reg, int data)\n{\n\tint err;\n\n\tnw64(MIF_FRAME_OUTPUT, MDIO_ADDR_OP(port, dev, reg));\n\terr = mdio_wait(np);\n\tif (err < 0)\n\t\treturn err;\n\n\tnw64(MIF_FRAME_OUTPUT, MDIO_WRITE_OP(port, dev, data));\n\terr = mdio_wait(np);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int mii_read(struct niu *np, int port, int reg)\n{\n\tnw64(MIF_FRAME_OUTPUT, MII_READ_OP(port, reg));\n\treturn mdio_wait(np);\n}\n\nstatic int mii_write(struct niu *np, int port, int reg, int data)\n{\n\tint err;\n\n\tnw64(MIF_FRAME_OUTPUT, MII_WRITE_OP(port, reg, data));\n\terr = mdio_wait(np);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int esr2_set_tx_cfg(struct niu *np, unsigned long channel, u32 val)\n{\n\tint err;\n\n\terr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t ESR2_TI_PLL_TX_CFG_L(channel),\n\t\t\t val & 0xffff);\n\tif (!err)\n\t\terr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t\t ESR2_TI_PLL_TX_CFG_H(channel),\n\t\t\t\t val >> 16);\n\treturn err;\n}\n\nstatic int esr2_set_rx_cfg(struct niu *np, unsigned long channel, u32 val)\n{\n\tint err;\n\n\terr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t ESR2_TI_PLL_RX_CFG_L(channel),\n\t\t\t val & 0xffff);\n\tif (!err)\n\t\terr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t\t ESR2_TI_PLL_RX_CFG_H(channel),\n\t\t\t\t val >> 16);\n\treturn err;\n}\n\n/* Mode is always 10G fiber.  */\nstatic int serdes_init_niu_10g_fiber(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tu32 tx_cfg, rx_cfg;\n\tunsigned long i;\n\n\ttx_cfg = (PLL_TX_CFG_ENTX | PLL_TX_CFG_SWING_1375MV);\n\trx_cfg = (PLL_RX_CFG_ENRX | PLL_RX_CFG_TERM_0P8VDDT |\n\t\t  PLL_RX_CFG_ALIGN_ENA | PLL_RX_CFG_LOS_LTHRESH |\n\t\t  PLL_RX_CFG_EQ_LP_ADAPTIVE);\n\n\tif (lp->loopback_mode == LOOPBACK_PHY) {\n\t\tu16 test_cfg = PLL_TEST_CFG_LOOPBACK_CML_DIS;\n\n\t\tmdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t   ESR2_TI_PLL_TEST_CFG_L, test_cfg);\n\n\t\ttx_cfg |= PLL_TX_CFG_ENTEST;\n\t\trx_cfg |= PLL_RX_CFG_ENTEST;\n\t}\n\n\t/* Initialize all 4 lanes of the SERDES.  */\n\tfor (i = 0; i < 4; i++) {\n\t\tint err = esr2_set_tx_cfg(np, i, tx_cfg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tint err = esr2_set_rx_cfg(np, i, rx_cfg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int serdes_init_niu_1g_serdes(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tu16 pll_cfg, pll_sts;\n\tint max_retry = 100;\n\tu64 sig, mask, val;\n\tu32 tx_cfg, rx_cfg;\n\tunsigned long i;\n\tint err;\n\n\ttx_cfg = (PLL_TX_CFG_ENTX | PLL_TX_CFG_SWING_1375MV |\n\t\t  PLL_TX_CFG_RATE_HALF);\n\trx_cfg = (PLL_RX_CFG_ENRX | PLL_RX_CFG_TERM_0P8VDDT |\n\t\t  PLL_RX_CFG_ALIGN_ENA | PLL_RX_CFG_LOS_LTHRESH |\n\t\t  PLL_RX_CFG_RATE_HALF);\n\n\tif (np->port == 0)\n\t\trx_cfg |= PLL_RX_CFG_EQ_LP_ADAPTIVE;\n\n\tif (lp->loopback_mode == LOOPBACK_PHY) {\n\t\tu16 test_cfg = PLL_TEST_CFG_LOOPBACK_CML_DIS;\n\n\t\tmdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t   ESR2_TI_PLL_TEST_CFG_L, test_cfg);\n\n\t\ttx_cfg |= PLL_TX_CFG_ENTEST;\n\t\trx_cfg |= PLL_RX_CFG_ENTEST;\n\t}\n\n\t/* Initialize PLL for 1G */\n\tpll_cfg = (PLL_CFG_ENPLL | PLL_CFG_MPY_8X);\n\n\terr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t ESR2_TI_PLL_CFG_L, pll_cfg);\n\tif (err) {\n\t\tnetdev_err(np->dev, \"NIU Port %d %s() mdio write to ESR2_TI_PLL_CFG_L failed\\n\",\n\t\t\t   np->port, __func__);\n\t\treturn err;\n\t}\n\n\tpll_sts = PLL_CFG_ENPLL;\n\n\terr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t ESR2_TI_PLL_STS_L, pll_sts);\n\tif (err) {\n\t\tnetdev_err(np->dev, \"NIU Port %d %s() mdio write to ESR2_TI_PLL_STS_L failed\\n\",\n\t\t\t   np->port, __func__);\n\t\treturn err;\n\t}\n\n\tudelay(200);\n\n\t/* Initialize all 4 lanes of the SERDES.  */\n\tfor (i = 0; i < 4; i++) {\n\t\terr = esr2_set_tx_cfg(np, i, tx_cfg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\terr = esr2_set_rx_cfg(np, i, rx_cfg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tswitch (np->port) {\n\tcase 0:\n\t\tval = (ESR_INT_SRDY0_P0 | ESR_INT_DET0_P0);\n\t\tmask = val;\n\t\tbreak;\n\n\tcase 1:\n\t\tval = (ESR_INT_SRDY0_P1 | ESR_INT_DET0_P1);\n\t\tmask = val;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twhile (max_retry--) {\n\t\tsig = nr64(ESR_INT_SIGNALS);\n\t\tif ((sig & mask) == val)\n\t\t\tbreak;\n\n\t\tmdelay(500);\n\t}\n\n\tif ((sig & mask) != val) {\n\t\tnetdev_err(np->dev, \"Port %u signal bits [%08x] are not [%08x]\\n\",\n\t\t\t   np->port, (int)(sig & mask), (int)val);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int serdes_init_niu_10g_serdes(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tu32 tx_cfg, rx_cfg, pll_cfg, pll_sts;\n\tint max_retry = 100;\n\tu64 sig, mask, val;\n\tunsigned long i;\n\tint err;\n\n\ttx_cfg = (PLL_TX_CFG_ENTX | PLL_TX_CFG_SWING_1375MV);\n\trx_cfg = (PLL_RX_CFG_ENRX | PLL_RX_CFG_TERM_0P8VDDT |\n\t\t  PLL_RX_CFG_ALIGN_ENA | PLL_RX_CFG_LOS_LTHRESH |\n\t\t  PLL_RX_CFG_EQ_LP_ADAPTIVE);\n\n\tif (lp->loopback_mode == LOOPBACK_PHY) {\n\t\tu16 test_cfg = PLL_TEST_CFG_LOOPBACK_CML_DIS;\n\n\t\tmdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t   ESR2_TI_PLL_TEST_CFG_L, test_cfg);\n\n\t\ttx_cfg |= PLL_TX_CFG_ENTEST;\n\t\trx_cfg |= PLL_RX_CFG_ENTEST;\n\t}\n\n\t/* Initialize PLL for 10G */\n\tpll_cfg = (PLL_CFG_ENPLL | PLL_CFG_MPY_10X);\n\n\terr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t ESR2_TI_PLL_CFG_L, pll_cfg & 0xffff);\n\tif (err) {\n\t\tnetdev_err(np->dev, \"NIU Port %d %s() mdio write to ESR2_TI_PLL_CFG_L failed\\n\",\n\t\t\t   np->port, __func__);\n\t\treturn err;\n\t}\n\n\tpll_sts = PLL_CFG_ENPLL;\n\n\terr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t ESR2_TI_PLL_STS_L, pll_sts & 0xffff);\n\tif (err) {\n\t\tnetdev_err(np->dev, \"NIU Port %d %s() mdio write to ESR2_TI_PLL_STS_L failed\\n\",\n\t\t\t   np->port, __func__);\n\t\treturn err;\n\t}\n\n\tudelay(200);\n\n\t/* Initialize all 4 lanes of the SERDES.  */\n\tfor (i = 0; i < 4; i++) {\n\t\terr = esr2_set_tx_cfg(np, i, tx_cfg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\terr = esr2_set_rx_cfg(np, i, rx_cfg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* check if serdes is ready */\n\n\tswitch (np->port) {\n\tcase 0:\n\t\tmask = ESR_INT_SIGNALS_P0_BITS;\n\t\tval = (ESR_INT_SRDY0_P0 |\n\t\t       ESR_INT_DET0_P0 |\n\t\t       ESR_INT_XSRDY_P0 |\n\t\t       ESR_INT_XDP_P0_CH3 |\n\t\t       ESR_INT_XDP_P0_CH2 |\n\t\t       ESR_INT_XDP_P0_CH1 |\n\t\t       ESR_INT_XDP_P0_CH0);\n\t\tbreak;\n\n\tcase 1:\n\t\tmask = ESR_INT_SIGNALS_P1_BITS;\n\t\tval = (ESR_INT_SRDY0_P1 |\n\t\t       ESR_INT_DET0_P1 |\n\t\t       ESR_INT_XSRDY_P1 |\n\t\t       ESR_INT_XDP_P1_CH3 |\n\t\t       ESR_INT_XDP_P1_CH2 |\n\t\t       ESR_INT_XDP_P1_CH1 |\n\t\t       ESR_INT_XDP_P1_CH0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twhile (max_retry--) {\n\t\tsig = nr64(ESR_INT_SIGNALS);\n\t\tif ((sig & mask) == val)\n\t\t\tbreak;\n\n\t\tmdelay(500);\n\t}\n\n\tif ((sig & mask) != val) {\n\t\tpr_info(\"NIU Port %u signal bits [%08x] are not [%08x] for 10G...trying 1G\\n\",\n\t\t\tnp->port, (int)(sig & mask), (int)val);\n\n\t\t/* 10G failed, try initializing at 1G */\n\t\terr = serdes_init_niu_1g_serdes(np);\n\t\tif (!err) {\n\t\t\tnp->flags &= ~NIU_FLAGS_10G;\n\t\t\tnp->mac_xcvr = MAC_XCVR_PCS;\n\t\t}  else {\n\t\t\tnetdev_err(np->dev, \"Port %u 10G/1G SERDES Link Failed\\n\",\n\t\t\t\t   np->port);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int esr_read_rxtx_ctrl(struct niu *np, unsigned long chan, u32 *val)\n{\n\tint err;\n\n\terr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR, ESR_RXTX_CTRL_L(chan));\n\tif (err >= 0) {\n\t\t*val = (err & 0xffff);\n\t\terr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t\tESR_RXTX_CTRL_H(chan));\n\t\tif (err >= 0)\n\t\t\t*val |= ((err & 0xffff) << 16);\n\t\terr = 0;\n\t}\n\treturn err;\n}\n\nstatic int esr_read_glue0(struct niu *np, unsigned long chan, u32 *val)\n{\n\tint err;\n\n\terr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\tESR_GLUE_CTRL0_L(chan));\n\tif (err >= 0) {\n\t\t*val = (err & 0xffff);\n\t\terr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t\tESR_GLUE_CTRL0_H(chan));\n\t\tif (err >= 0) {\n\t\t\t*val |= ((err & 0xffff) << 16);\n\t\t\terr = 0;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int esr_read_reset(struct niu *np, u32 *val)\n{\n\tint err;\n\n\terr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\tESR_RXTX_RESET_CTRL_L);\n\tif (err >= 0) {\n\t\t*val = (err & 0xffff);\n\t\terr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t\tESR_RXTX_RESET_CTRL_H);\n\t\tif (err >= 0) {\n\t\t\t*val |= ((err & 0xffff) << 16);\n\t\t\terr = 0;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int esr_write_rxtx_ctrl(struct niu *np, unsigned long chan, u32 val)\n{\n\tint err;\n\n\terr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t ESR_RXTX_CTRL_L(chan), val & 0xffff);\n\tif (!err)\n\t\terr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t\t ESR_RXTX_CTRL_H(chan), (val >> 16));\n\treturn err;\n}\n\nstatic int esr_write_glue0(struct niu *np, unsigned long chan, u32 val)\n{\n\tint err;\n\n\terr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\tESR_GLUE_CTRL0_L(chan), val & 0xffff);\n\tif (!err)\n\t\terr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t\t ESR_GLUE_CTRL0_H(chan), (val >> 16));\n\treturn err;\n}\n\nstatic int esr_reset(struct niu *np)\n{\n\tu32 reset;\n\tint err;\n\n\terr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t ESR_RXTX_RESET_CTRL_L, 0x0000);\n\tif (err)\n\t\treturn err;\n\terr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t ESR_RXTX_RESET_CTRL_H, 0xffff);\n\tif (err)\n\t\treturn err;\n\tudelay(200);\n\n\terr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t ESR_RXTX_RESET_CTRL_L, 0xffff);\n\tif (err)\n\t\treturn err;\n\tudelay(200);\n\n\terr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t ESR_RXTX_RESET_CTRL_H, 0x0000);\n\tif (err)\n\t\treturn err;\n\tudelay(200);\n\n\terr = esr_read_reset(np, &reset);\n\tif (err)\n\t\treturn err;\n\tif (reset != 0) {\n\t\tnetdev_err(np->dev, \"Port %u ESR_RESET did not clear [%08x]\\n\",\n\t\t\t   np->port, reset);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int serdes_init_10g(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tunsigned long ctrl_reg, test_cfg_reg, i;\n\tu64 ctrl_val, test_cfg_val, sig, mask, val;\n\tint err;\n\n\tswitch (np->port) {\n\tcase 0:\n\t\tctrl_reg = ENET_SERDES_0_CTRL_CFG;\n\t\ttest_cfg_reg = ENET_SERDES_0_TEST_CFG;\n\t\tbreak;\n\tcase 1:\n\t\tctrl_reg = ENET_SERDES_1_CTRL_CFG;\n\t\ttest_cfg_reg = ENET_SERDES_1_TEST_CFG;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tctrl_val = (ENET_SERDES_CTRL_SDET_0 |\n\t\t    ENET_SERDES_CTRL_SDET_1 |\n\t\t    ENET_SERDES_CTRL_SDET_2 |\n\t\t    ENET_SERDES_CTRL_SDET_3 |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_0_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_1_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_2_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_3_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_0_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_1_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_2_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_3_SHIFT));\n\ttest_cfg_val = 0;\n\n\tif (lp->loopback_mode == LOOPBACK_PHY) {\n\t\ttest_cfg_val |= ((ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_0_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_1_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_2_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_3_SHIFT));\n\t}\n\n\tnw64(ctrl_reg, ctrl_val);\n\tnw64(test_cfg_reg, test_cfg_val);\n\n\t/* Initialize all 4 lanes of the SERDES.  */\n\tfor (i = 0; i < 4; i++) {\n\t\tu32 rxtx_ctrl, glue0;\n\n\t\terr = esr_read_rxtx_ctrl(np, i, &rxtx_ctrl);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = esr_read_glue0(np, i, &glue0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\trxtx_ctrl &= ~(ESR_RXTX_CTRL_VMUXLO);\n\t\trxtx_ctrl |= (ESR_RXTX_CTRL_ENSTRETCH |\n\t\t\t      (2 << ESR_RXTX_CTRL_VMUXLO_SHIFT));\n\n\t\tglue0 &= ~(ESR_GLUE_CTRL0_SRATE |\n\t\t\t   ESR_GLUE_CTRL0_THCNT |\n\t\t\t   ESR_GLUE_CTRL0_BLTIME);\n\t\tglue0 |= (ESR_GLUE_CTRL0_RXLOSENAB |\n\t\t\t  (0xf << ESR_GLUE_CTRL0_SRATE_SHIFT) |\n\t\t\t  (0xff << ESR_GLUE_CTRL0_THCNT_SHIFT) |\n\t\t\t  (BLTIME_300_CYCLES <<\n\t\t\t   ESR_GLUE_CTRL0_BLTIME_SHIFT));\n\n\t\terr = esr_write_rxtx_ctrl(np, i, rxtx_ctrl);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = esr_write_glue0(np, i, glue0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = esr_reset(np);\n\tif (err)\n\t\treturn err;\n\n\tsig = nr64(ESR_INT_SIGNALS);\n\tswitch (np->port) {\n\tcase 0:\n\t\tmask = ESR_INT_SIGNALS_P0_BITS;\n\t\tval = (ESR_INT_SRDY0_P0 |\n\t\t       ESR_INT_DET0_P0 |\n\t\t       ESR_INT_XSRDY_P0 |\n\t\t       ESR_INT_XDP_P0_CH3 |\n\t\t       ESR_INT_XDP_P0_CH2 |\n\t\t       ESR_INT_XDP_P0_CH1 |\n\t\t       ESR_INT_XDP_P0_CH0);\n\t\tbreak;\n\n\tcase 1:\n\t\tmask = ESR_INT_SIGNALS_P1_BITS;\n\t\tval = (ESR_INT_SRDY0_P1 |\n\t\t       ESR_INT_DET0_P1 |\n\t\t       ESR_INT_XSRDY_P1 |\n\t\t       ESR_INT_XDP_P1_CH3 |\n\t\t       ESR_INT_XDP_P1_CH2 |\n\t\t       ESR_INT_XDP_P1_CH1 |\n\t\t       ESR_INT_XDP_P1_CH0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((sig & mask) != val) {\n\t\tif (np->flags & NIU_FLAGS_HOTPLUG_PHY) {\n\t\t\tnp->flags &= ~NIU_FLAGS_HOTPLUG_PHY_PRESENT;\n\t\t\treturn 0;\n\t\t}\n\t\tnetdev_err(np->dev, \"Port %u signal bits [%08x] are not [%08x]\\n\",\n\t\t\t   np->port, (int)(sig & mask), (int)val);\n\t\treturn -ENODEV;\n\t}\n\tif (np->flags & NIU_FLAGS_HOTPLUG_PHY)\n\t\tnp->flags |= NIU_FLAGS_HOTPLUG_PHY_PRESENT;\n\treturn 0;\n}\n\nstatic int serdes_init_1g(struct niu *np)\n{\n\tu64 val;\n\n\tval = nr64(ENET_SERDES_1_PLL_CFG);\n\tval &= ~ENET_SERDES_PLL_FBDIV2;\n\tswitch (np->port) {\n\tcase 0:\n\t\tval |= ENET_SERDES_PLL_HRATE0;\n\t\tbreak;\n\tcase 1:\n\t\tval |= ENET_SERDES_PLL_HRATE1;\n\t\tbreak;\n\tcase 2:\n\t\tval |= ENET_SERDES_PLL_HRATE2;\n\t\tbreak;\n\tcase 3:\n\t\tval |= ENET_SERDES_PLL_HRATE3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tnw64(ENET_SERDES_1_PLL_CFG, val);\n\n\treturn 0;\n}\n\nstatic int serdes_init_1g_serdes(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tunsigned long ctrl_reg, test_cfg_reg, pll_cfg, i;\n\tu64 ctrl_val, test_cfg_val, sig, mask, val;\n\tint err;\n\tu64 reset_val, val_rd;\n\n\tval = ENET_SERDES_PLL_HRATE0 | ENET_SERDES_PLL_HRATE1 |\n\t\tENET_SERDES_PLL_HRATE2 | ENET_SERDES_PLL_HRATE3 |\n\t\tENET_SERDES_PLL_FBDIV0;\n\tswitch (np->port) {\n\tcase 0:\n\t\treset_val =  ENET_SERDES_RESET_0;\n\t\tctrl_reg = ENET_SERDES_0_CTRL_CFG;\n\t\ttest_cfg_reg = ENET_SERDES_0_TEST_CFG;\n\t\tpll_cfg = ENET_SERDES_0_PLL_CFG;\n\t\tbreak;\n\tcase 1:\n\t\treset_val =  ENET_SERDES_RESET_1;\n\t\tctrl_reg = ENET_SERDES_1_CTRL_CFG;\n\t\ttest_cfg_reg = ENET_SERDES_1_TEST_CFG;\n\t\tpll_cfg = ENET_SERDES_1_PLL_CFG;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tctrl_val = (ENET_SERDES_CTRL_SDET_0 |\n\t\t    ENET_SERDES_CTRL_SDET_1 |\n\t\t    ENET_SERDES_CTRL_SDET_2 |\n\t\t    ENET_SERDES_CTRL_SDET_3 |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_0_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_1_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_2_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_3_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_0_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_1_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_2_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_3_SHIFT));\n\ttest_cfg_val = 0;\n\n\tif (lp->loopback_mode == LOOPBACK_PHY) {\n\t\ttest_cfg_val |= ((ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_0_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_1_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_2_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_3_SHIFT));\n\t}\n\n\tnw64(ENET_SERDES_RESET, reset_val);\n\tmdelay(20);\n\tval_rd = nr64(ENET_SERDES_RESET);\n\tval_rd &= ~reset_val;\n\tnw64(pll_cfg, val);\n\tnw64(ctrl_reg, ctrl_val);\n\tnw64(test_cfg_reg, test_cfg_val);\n\tnw64(ENET_SERDES_RESET, val_rd);\n\tmdelay(2000);\n\n\t/* Initialize all 4 lanes of the SERDES.  */\n\tfor (i = 0; i < 4; i++) {\n\t\tu32 rxtx_ctrl, glue0;\n\n\t\terr = esr_read_rxtx_ctrl(np, i, &rxtx_ctrl);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = esr_read_glue0(np, i, &glue0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\trxtx_ctrl &= ~(ESR_RXTX_CTRL_VMUXLO);\n\t\trxtx_ctrl |= (ESR_RXTX_CTRL_ENSTRETCH |\n\t\t\t      (2 << ESR_RXTX_CTRL_VMUXLO_SHIFT));\n\n\t\tglue0 &= ~(ESR_GLUE_CTRL0_SRATE |\n\t\t\t   ESR_GLUE_CTRL0_THCNT |\n\t\t\t   ESR_GLUE_CTRL0_BLTIME);\n\t\tglue0 |= (ESR_GLUE_CTRL0_RXLOSENAB |\n\t\t\t  (0xf << ESR_GLUE_CTRL0_SRATE_SHIFT) |\n\t\t\t  (0xff << ESR_GLUE_CTRL0_THCNT_SHIFT) |\n\t\t\t  (BLTIME_300_CYCLES <<\n\t\t\t   ESR_GLUE_CTRL0_BLTIME_SHIFT));\n\n\t\terr = esr_write_rxtx_ctrl(np, i, rxtx_ctrl);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = esr_write_glue0(np, i, glue0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\n\tsig = nr64(ESR_INT_SIGNALS);\n\tswitch (np->port) {\n\tcase 0:\n\t\tval = (ESR_INT_SRDY0_P0 | ESR_INT_DET0_P0);\n\t\tmask = val;\n\t\tbreak;\n\n\tcase 1:\n\t\tval = (ESR_INT_SRDY0_P1 | ESR_INT_DET0_P1);\n\t\tmask = val;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((sig & mask) != val) {\n\t\tnetdev_err(np->dev, \"Port %u signal bits [%08x] are not [%08x]\\n\",\n\t\t\t   np->port, (int)(sig & mask), (int)val);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int link_status_1g_serdes(struct niu *np, int *link_up_p)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tint link_up;\n\tu64 val;\n\tu16 current_speed;\n\tunsigned long flags;\n\tu8 current_duplex;\n\n\tlink_up = 0;\n\tcurrent_speed = SPEED_INVALID;\n\tcurrent_duplex = DUPLEX_INVALID;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\tval = nr64_pcs(PCS_MII_STAT);\n\n\tif (val & PCS_MII_STAT_LINK_STATUS) {\n\t\tlink_up = 1;\n\t\tcurrent_speed = SPEED_1000;\n\t\tcurrent_duplex = DUPLEX_FULL;\n\t}\n\n\tlp->active_speed = current_speed;\n\tlp->active_duplex = current_duplex;\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\t*link_up_p = link_up;\n\treturn 0;\n}\n\nstatic int link_status_10g_serdes(struct niu *np, int *link_up_p)\n{\n\tunsigned long flags;\n\tstruct niu_link_config *lp = &np->link_config;\n\tint link_up = 0;\n\tint link_ok = 1;\n\tu64 val, val2;\n\tu16 current_speed;\n\tu8 current_duplex;\n\n\tif (!(np->flags & NIU_FLAGS_10G))\n\t\treturn link_status_1g_serdes(np, link_up_p);\n\n\tcurrent_speed = SPEED_INVALID;\n\tcurrent_duplex = DUPLEX_INVALID;\n\tspin_lock_irqsave(&np->lock, flags);\n\n\tval = nr64_xpcs(XPCS_STATUS(0));\n\tval2 = nr64_mac(XMAC_INTER2);\n\tif (val2 & 0x01000000)\n\t\tlink_ok = 0;\n\n\tif ((val & 0x1000ULL) && link_ok) {\n\t\tlink_up = 1;\n\t\tcurrent_speed = SPEED_10000;\n\t\tcurrent_duplex = DUPLEX_FULL;\n\t}\n\tlp->active_speed = current_speed;\n\tlp->active_duplex = current_duplex;\n\tspin_unlock_irqrestore(&np->lock, flags);\n\t*link_up_p = link_up;\n\treturn 0;\n}\n\nstatic int link_status_mii(struct niu *np, int *link_up_p)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tint err;\n\tint bmsr, advert, ctrl1000, stat1000, lpa, bmcr, estatus;\n\tint supported, advertising, active_speed, active_duplex;\n\n\terr = mii_read(np, np->phy_addr, MII_BMCR);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tbmcr = err;\n\n\terr = mii_read(np, np->phy_addr, MII_BMSR);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tbmsr = err;\n\n\terr = mii_read(np, np->phy_addr, MII_ADVERTISE);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tadvert = err;\n\n\terr = mii_read(np, np->phy_addr, MII_LPA);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tlpa = err;\n\n\tif (likely(bmsr & BMSR_ESTATEN)) {\n\t\terr = mii_read(np, np->phy_addr, MII_ESTATUS);\n\t\tif (unlikely(err < 0))\n\t\t\treturn err;\n\t\testatus = err;\n\n\t\terr = mii_read(np, np->phy_addr, MII_CTRL1000);\n\t\tif (unlikely(err < 0))\n\t\t\treturn err;\n\t\tctrl1000 = err;\n\n\t\terr = mii_read(np, np->phy_addr, MII_STAT1000);\n\t\tif (unlikely(err < 0))\n\t\t\treturn err;\n\t\tstat1000 = err;\n\t} else\n\t\testatus = ctrl1000 = stat1000 = 0;\n\n\tsupported = 0;\n\tif (bmsr & BMSR_ANEGCAPABLE)\n\t\tsupported |= SUPPORTED_Autoneg;\n\tif (bmsr & BMSR_10HALF)\n\t\tsupported |= SUPPORTED_10baseT_Half;\n\tif (bmsr & BMSR_10FULL)\n\t\tsupported |= SUPPORTED_10baseT_Full;\n\tif (bmsr & BMSR_100HALF)\n\t\tsupported |= SUPPORTED_100baseT_Half;\n\tif (bmsr & BMSR_100FULL)\n\t\tsupported |= SUPPORTED_100baseT_Full;\n\tif (estatus & ESTATUS_1000_THALF)\n\t\tsupported |= SUPPORTED_1000baseT_Half;\n\tif (estatus & ESTATUS_1000_TFULL)\n\t\tsupported |= SUPPORTED_1000baseT_Full;\n\tlp->supported = supported;\n\n\tadvertising = mii_adv_to_ethtool_adv_t(advert);\n\tadvertising |= mii_ctrl1000_to_ethtool_adv_t(ctrl1000);\n\n\tif (bmcr & BMCR_ANENABLE) {\n\t\tint neg, neg1000;\n\n\t\tlp->active_autoneg = 1;\n\t\tadvertising |= ADVERTISED_Autoneg;\n\n\t\tneg = advert & lpa;\n\t\tneg1000 = (ctrl1000 << 2) & stat1000;\n\n\t\tif (neg1000 & (LPA_1000FULL | LPA_1000HALF))\n\t\t\tactive_speed = SPEED_1000;\n\t\telse if (neg & LPA_100)\n\t\t\tactive_speed = SPEED_100;\n\t\telse if (neg & (LPA_10HALF | LPA_10FULL))\n\t\t\tactive_speed = SPEED_10;\n\t\telse\n\t\t\tactive_speed = SPEED_INVALID;\n\n\t\tif ((neg1000 & LPA_1000FULL) || (neg & LPA_DUPLEX))\n\t\t\tactive_duplex = DUPLEX_FULL;\n\t\telse if (active_speed != SPEED_INVALID)\n\t\t\tactive_duplex = DUPLEX_HALF;\n\t\telse\n\t\t\tactive_duplex = DUPLEX_INVALID;\n\t} else {\n\t\tlp->active_autoneg = 0;\n\n\t\tif ((bmcr & BMCR_SPEED1000) && !(bmcr & BMCR_SPEED100))\n\t\t\tactive_speed = SPEED_1000;\n\t\telse if (bmcr & BMCR_SPEED100)\n\t\t\tactive_speed = SPEED_100;\n\t\telse\n\t\t\tactive_speed = SPEED_10;\n\n\t\tif (bmcr & BMCR_FULLDPLX)\n\t\t\tactive_duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tactive_duplex = DUPLEX_HALF;\n\t}\n\n\tlp->active_advertising = advertising;\n\tlp->active_speed = active_speed;\n\tlp->active_duplex = active_duplex;\n\t*link_up_p = !!(bmsr & BMSR_LSTATUS);\n\n\treturn 0;\n}\n\nstatic int link_status_1g_rgmii(struct niu *np, int *link_up_p)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tu16 current_speed, bmsr;\n\tunsigned long flags;\n\tu8 current_duplex;\n\tint err, link_up;\n\n\tlink_up = 0;\n\tcurrent_speed = SPEED_INVALID;\n\tcurrent_duplex = DUPLEX_INVALID;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\terr = mii_read(np, np->phy_addr, MII_BMSR);\n\tif (err < 0)\n\t\tgoto out;\n\n\tbmsr = err;\n\tif (bmsr & BMSR_LSTATUS) {\n\t\tlink_up = 1;\n\t\tcurrent_speed = SPEED_1000;\n\t\tcurrent_duplex = DUPLEX_FULL;\n\t}\n\tlp->active_speed = current_speed;\n\tlp->active_duplex = current_duplex;\n\terr = 0;\n\nout:\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\t*link_up_p = link_up;\n\treturn err;\n}\n\nstatic int link_status_1g(struct niu *np, int *link_up_p)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\terr = link_status_mii(np, link_up_p);\n\tlp->supported |= SUPPORTED_TP;\n\tlp->active_advertising |= ADVERTISED_TP;\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\treturn err;\n}\n\nstatic int bcm8704_reset(struct niu *np)\n{\n\tint err, limit;\n\n\terr = mdio_read(np, np->phy_addr,\n\t\t\tBCM8704_PHYXS_DEV_ADDR, MII_BMCR);\n\tif (err < 0 || err == 0xffff)\n\t\treturn err;\n\terr |= BMCR_RESET;\n\terr = mdio_write(np, np->phy_addr, BCM8704_PHYXS_DEV_ADDR,\n\t\t\t MII_BMCR, err);\n\tif (err)\n\t\treturn err;\n\n\tlimit = 1000;\n\twhile (--limit >= 0) {\n\t\terr = mdio_read(np, np->phy_addr,\n\t\t\t\tBCM8704_PHYXS_DEV_ADDR, MII_BMCR);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (!(err & BMCR_RESET))\n\t\t\tbreak;\n\t}\n\tif (limit < 0) {\n\t\tnetdev_err(np->dev, \"Port %u PHY will not reset (bmcr=%04x)\\n\",\n\t\t\t   np->port, (err & 0xffff));\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\n/* When written, certain PHY registers need to be read back twice\n * in order for the bits to settle properly.\n */\nstatic int bcm8704_user_dev3_readback(struct niu *np, int reg)\n{\n\tint err = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR, reg);\n\tif (err < 0)\n\t\treturn err;\n\terr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR, reg);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int bcm8706_init_user_dev3(struct niu *np)\n{\n\tint err;\n\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\n\t\t\tBCM8704_USER_OPT_DIGITAL_CTRL);\n\tif (err < 0)\n\t\treturn err;\n\terr &= ~USER_ODIG_CTRL_GPIOS;\n\terr |= (0x3 << USER_ODIG_CTRL_GPIOS_SHIFT);\n\terr |=  USER_ODIG_CTRL_RESV2;\n\terr = mdio_write(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\n\t\t\t BCM8704_USER_OPT_DIGITAL_CTRL, err);\n\tif (err)\n\t\treturn err;\n\n\tmdelay(1000);\n\n\treturn 0;\n}\n\nstatic int bcm8704_init_user_dev3(struct niu *np)\n{\n\tint err;\n\n\terr = mdio_write(np, np->phy_addr,\n\t\t\t BCM8704_USER_DEV3_ADDR, BCM8704_USER_CONTROL,\n\t\t\t (USER_CONTROL_OPTXRST_LVL |\n\t\t\t  USER_CONTROL_OPBIASFLT_LVL |\n\t\t\t  USER_CONTROL_OBTMPFLT_LVL |\n\t\t\t  USER_CONTROL_OPPRFLT_LVL |\n\t\t\t  USER_CONTROL_OPTXFLT_LVL |\n\t\t\t  USER_CONTROL_OPRXLOS_LVL |\n\t\t\t  USER_CONTROL_OPRXFLT_LVL |\n\t\t\t  USER_CONTROL_OPTXON_LVL |\n\t\t\t  (0x3f << USER_CONTROL_RES1_SHIFT)));\n\tif (err)\n\t\treturn err;\n\n\terr = mdio_write(np, np->phy_addr,\n\t\t\t BCM8704_USER_DEV3_ADDR, BCM8704_USER_PMD_TX_CONTROL,\n\t\t\t (USER_PMD_TX_CTL_XFP_CLKEN |\n\t\t\t  (1 << USER_PMD_TX_CTL_TX_DAC_TXD_SH) |\n\t\t\t  (2 << USER_PMD_TX_CTL_TX_DAC_TXCK_SH) |\n\t\t\t  USER_PMD_TX_CTL_TSCK_LPWREN));\n\tif (err)\n\t\treturn err;\n\n\terr = bcm8704_user_dev3_readback(np, BCM8704_USER_CONTROL);\n\tif (err)\n\t\treturn err;\n\terr = bcm8704_user_dev3_readback(np, BCM8704_USER_PMD_TX_CONTROL);\n\tif (err)\n\t\treturn err;\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\n\t\t\tBCM8704_USER_OPT_DIGITAL_CTRL);\n\tif (err < 0)\n\t\treturn err;\n\terr &= ~USER_ODIG_CTRL_GPIOS;\n\terr |= (0x3 << USER_ODIG_CTRL_GPIOS_SHIFT);\n\terr = mdio_write(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\n\t\t\t BCM8704_USER_OPT_DIGITAL_CTRL, err);\n\tif (err)\n\t\treturn err;\n\n\tmdelay(1000);\n\n\treturn 0;\n}\n\nstatic int mrvl88x2011_act_led(struct niu *np, int val)\n{\n\tint\terr;\n\n\terr  = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV2_ADDR,\n\t\tMRVL88X2011_LED_8_TO_11_CTL);\n\tif (err < 0)\n\t\treturn err;\n\n\terr &= ~MRVL88X2011_LED(MRVL88X2011_LED_ACT,MRVL88X2011_LED_CTL_MASK);\n\terr |=  MRVL88X2011_LED(MRVL88X2011_LED_ACT,val);\n\n\treturn mdio_write(np, np->phy_addr, MRVL88X2011_USER_DEV2_ADDR,\n\t\t\t  MRVL88X2011_LED_8_TO_11_CTL, err);\n}\n\nstatic int mrvl88x2011_led_blink_rate(struct niu *np, int rate)\n{\n\tint\terr;\n\n\terr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV2_ADDR,\n\t\t\tMRVL88X2011_LED_BLINK_CTL);\n\tif (err >= 0) {\n\t\terr &= ~MRVL88X2011_LED_BLKRATE_MASK;\n\t\terr |= (rate << 4);\n\n\t\terr = mdio_write(np, np->phy_addr, MRVL88X2011_USER_DEV2_ADDR,\n\t\t\t\t MRVL88X2011_LED_BLINK_CTL, err);\n\t}\n\n\treturn err;\n}\n\nstatic int xcvr_init_10g_mrvl88x2011(struct niu *np)\n{\n\tint\terr;\n\n\t/* Set LED functions */\n\terr = mrvl88x2011_led_blink_rate(np, MRVL88X2011_LED_BLKRATE_134MS);\n\tif (err)\n\t\treturn err;\n\n\t/* led activity */\n\terr = mrvl88x2011_act_led(np, MRVL88X2011_LED_CTL_OFF);\n\tif (err)\n\t\treturn err;\n\n\terr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV3_ADDR,\n\t\t\tMRVL88X2011_GENERAL_CTL);\n\tif (err < 0)\n\t\treturn err;\n\n\terr |= MRVL88X2011_ENA_XFPREFCLK;\n\n\terr = mdio_write(np, np->phy_addr, MRVL88X2011_USER_DEV3_ADDR,\n\t\t\t MRVL88X2011_GENERAL_CTL, err);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV1_ADDR,\n\t\t\tMRVL88X2011_PMA_PMD_CTL_1);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (np->link_config.loopback_mode == LOOPBACK_MAC)\n\t\terr |= MRVL88X2011_LOOPBACK;\n\telse\n\t\terr &= ~MRVL88X2011_LOOPBACK;\n\n\terr = mdio_write(np, np->phy_addr, MRVL88X2011_USER_DEV1_ADDR,\n\t\t\t MRVL88X2011_PMA_PMD_CTL_1, err);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* Enable PMD  */\n\treturn mdio_write(np, np->phy_addr, MRVL88X2011_USER_DEV1_ADDR,\n\t\t\t  MRVL88X2011_10G_PMD_TX_DIS, MRVL88X2011_ENA_PMDTX);\n}\n\n\nstatic int xcvr_diag_bcm870x(struct niu *np)\n{\n\tu16 analog_stat0, tx_alarm_status;\n\tint err = 0;\n\n#if 1\n\terr = mdio_read(np, np->phy_addr, BCM8704_PMA_PMD_DEV_ADDR,\n\t\t\tMII_STAT1000);\n\tif (err < 0)\n\t\treturn err;\n\tpr_info(\"Port %u PMA_PMD(MII_STAT1000) [%04x]\\n\", np->port, err);\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR, 0x20);\n\tif (err < 0)\n\t\treturn err;\n\tpr_info(\"Port %u USER_DEV3(0x20) [%04x]\\n\", np->port, err);\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_PHYXS_DEV_ADDR,\n\t\t\tMII_NWAYTEST);\n\tif (err < 0)\n\t\treturn err;\n\tpr_info(\"Port %u PHYXS(MII_NWAYTEST) [%04x]\\n\", np->port, err);\n#endif\n\n\t/* XXX dig this out it might not be so useful XXX */\n\terr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\n\t\t\tBCM8704_USER_ANALOG_STATUS0);\n\tif (err < 0)\n\t\treturn err;\n\terr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\n\t\t\tBCM8704_USER_ANALOG_STATUS0);\n\tif (err < 0)\n\t\treturn err;\n\tanalog_stat0 = err;\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\n\t\t\tBCM8704_USER_TX_ALARM_STATUS);\n\tif (err < 0)\n\t\treturn err;\n\terr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\n\t\t\tBCM8704_USER_TX_ALARM_STATUS);\n\tif (err < 0)\n\t\treturn err;\n\ttx_alarm_status = err;\n\n\tif (analog_stat0 != 0x03fc) {\n\t\tif ((analog_stat0 == 0x43bc) && (tx_alarm_status != 0)) {\n\t\t\tpr_info(\"Port %u cable not connected or bad cable\\n\",\n\t\t\t\tnp->port);\n\t\t} else if (analog_stat0 == 0x639c) {\n\t\t\tpr_info(\"Port %u optical module is bad or missing\\n\",\n\t\t\t\tnp->port);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int xcvr_10g_set_lb_bcm870x(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tint err;\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_PCS_DEV_ADDR,\n\t\t\tMII_BMCR);\n\tif (err < 0)\n\t\treturn err;\n\n\terr &= ~BMCR_LOOPBACK;\n\n\tif (lp->loopback_mode == LOOPBACK_MAC)\n\t\terr |= BMCR_LOOPBACK;\n\n\terr = mdio_write(np, np->phy_addr, BCM8704_PCS_DEV_ADDR,\n\t\t\t MII_BMCR, err);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int xcvr_init_10g_bcm8706(struct niu *np)\n{\n\tint err = 0;\n\tu64 val;\n\n\tif ((np->flags & NIU_FLAGS_HOTPLUG_PHY) &&\n\t    (np->flags & NIU_FLAGS_HOTPLUG_PHY_PRESENT) == 0)\n\t\t\treturn err;\n\n\tval = nr64_mac(XMAC_CONFIG);\n\tval &= ~XMAC_CONFIG_LED_POLARITY;\n\tval |= XMAC_CONFIG_FORCE_LED_ON;\n\tnw64_mac(XMAC_CONFIG, val);\n\n\tval = nr64(MIF_CONFIG);\n\tval |= MIF_CONFIG_INDIRECT_MODE;\n\tnw64(MIF_CONFIG, val);\n\n\terr = bcm8704_reset(np);\n\tif (err)\n\t\treturn err;\n\n\terr = xcvr_10g_set_lb_bcm870x(np);\n\tif (err)\n\t\treturn err;\n\n\terr = bcm8706_init_user_dev3(np);\n\tif (err)\n\t\treturn err;\n\n\terr = xcvr_diag_bcm870x(np);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int xcvr_init_10g_bcm8704(struct niu *np)\n{\n\tint err;\n\n\terr = bcm8704_reset(np);\n\tif (err)\n\t\treturn err;\n\n\terr = bcm8704_init_user_dev3(np);\n\tif (err)\n\t\treturn err;\n\n\terr = xcvr_10g_set_lb_bcm870x(np);\n\tif (err)\n\t\treturn err;\n\n\terr =  xcvr_diag_bcm870x(np);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int xcvr_init_10g(struct niu *np)\n{\n\tint phy_id, err;\n\tu64 val;\n\n\tval = nr64_mac(XMAC_CONFIG);\n\tval &= ~XMAC_CONFIG_LED_POLARITY;\n\tval |= XMAC_CONFIG_FORCE_LED_ON;\n\tnw64_mac(XMAC_CONFIG, val);\n\n\t/* XXX shared resource, lock parent XXX */\n\tval = nr64(MIF_CONFIG);\n\tval |= MIF_CONFIG_INDIRECT_MODE;\n\tnw64(MIF_CONFIG, val);\n\n\tphy_id = phy_decode(np->parent->port_phy, np->port);\n\tphy_id = np->parent->phy_probe_info.phy_id[phy_id][np->port];\n\n\t/* handle different phy types */\n\tswitch (phy_id & NIU_PHY_ID_MASK) {\n\tcase NIU_PHY_ID_MRVL88X2011:\n\t\terr = xcvr_init_10g_mrvl88x2011(np);\n\t\tbreak;\n\n\tdefault: /* bcom 8704 */\n\t\terr = xcvr_init_10g_bcm8704(np);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int mii_reset(struct niu *np)\n{\n\tint limit, err;\n\n\terr = mii_write(np, np->phy_addr, MII_BMCR, BMCR_RESET);\n\tif (err)\n\t\treturn err;\n\n\tlimit = 1000;\n\twhile (--limit >= 0) {\n\t\tudelay(500);\n\t\terr = mii_read(np, np->phy_addr, MII_BMCR);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (!(err & BMCR_RESET))\n\t\t\tbreak;\n\t}\n\tif (limit < 0) {\n\t\tnetdev_err(np->dev, \"Port %u MII would not reset, bmcr[%04x]\\n\",\n\t\t\t   np->port, err);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int xcvr_init_1g_rgmii(struct niu *np)\n{\n\tint err;\n\tu64 val;\n\tu16 bmcr, bmsr, estat;\n\n\tval = nr64(MIF_CONFIG);\n\tval &= ~MIF_CONFIG_INDIRECT_MODE;\n\tnw64(MIF_CONFIG, val);\n\n\terr = mii_reset(np);\n\tif (err)\n\t\treturn err;\n\n\terr = mii_read(np, np->phy_addr, MII_BMSR);\n\tif (err < 0)\n\t\treturn err;\n\tbmsr = err;\n\n\testat = 0;\n\tif (bmsr & BMSR_ESTATEN) {\n\t\terr = mii_read(np, np->phy_addr, MII_ESTATUS);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\testat = err;\n\t}\n\n\tbmcr = 0;\n\terr = mii_write(np, np->phy_addr, MII_BMCR, bmcr);\n\tif (err)\n\t\treturn err;\n\n\tif (bmsr & BMSR_ESTATEN) {\n\t\tu16 ctrl1000 = 0;\n\n\t\tif (estat & ESTATUS_1000_TFULL)\n\t\t\tctrl1000 |= ADVERTISE_1000FULL;\n\t\terr = mii_write(np, np->phy_addr, MII_CTRL1000, ctrl1000);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tbmcr = (BMCR_SPEED1000 | BMCR_FULLDPLX);\n\n\terr = mii_write(np, np->phy_addr, MII_BMCR, bmcr);\n\tif (err)\n\t\treturn err;\n\n\terr = mii_read(np, np->phy_addr, MII_BMCR);\n\tif (err < 0)\n\t\treturn err;\n\tbmcr = mii_read(np, np->phy_addr, MII_BMCR);\n\n\terr = mii_read(np, np->phy_addr, MII_BMSR);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int mii_init_common(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tu16 bmcr, bmsr, adv, estat;\n\tint err;\n\n\terr = mii_reset(np);\n\tif (err)\n\t\treturn err;\n\n\terr = mii_read(np, np->phy_addr, MII_BMSR);\n\tif (err < 0)\n\t\treturn err;\n\tbmsr = err;\n\n\testat = 0;\n\tif (bmsr & BMSR_ESTATEN) {\n\t\terr = mii_read(np, np->phy_addr, MII_ESTATUS);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\testat = err;\n\t}\n\n\tbmcr = 0;\n\terr = mii_write(np, np->phy_addr, MII_BMCR, bmcr);\n\tif (err)\n\t\treturn err;\n\n\tif (lp->loopback_mode == LOOPBACK_MAC) {\n\t\tbmcr |= BMCR_LOOPBACK;\n\t\tif (lp->active_speed == SPEED_1000)\n\t\t\tbmcr |= BMCR_SPEED1000;\n\t\tif (lp->active_duplex == DUPLEX_FULL)\n\t\t\tbmcr |= BMCR_FULLDPLX;\n\t}\n\n\tif (lp->loopback_mode == LOOPBACK_PHY) {\n\t\tu16 aux;\n\n\t\taux = (BCM5464R_AUX_CTL_EXT_LB |\n\t\t       BCM5464R_AUX_CTL_WRITE_1);\n\t\terr = mii_write(np, np->phy_addr, BCM5464R_AUX_CTL, aux);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (lp->autoneg) {\n\t\tu16 ctrl1000;\n\n\t\tadv = ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP;\n\t\tif ((bmsr & BMSR_10HALF) &&\n\t\t\t(lp->advertising & ADVERTISED_10baseT_Half))\n\t\t\tadv |= ADVERTISE_10HALF;\n\t\tif ((bmsr & BMSR_10FULL) &&\n\t\t\t(lp->advertising & ADVERTISED_10baseT_Full))\n\t\t\tadv |= ADVERTISE_10FULL;\n\t\tif ((bmsr & BMSR_100HALF) &&\n\t\t\t(lp->advertising & ADVERTISED_100baseT_Half))\n\t\t\tadv |= ADVERTISE_100HALF;\n\t\tif ((bmsr & BMSR_100FULL) &&\n\t\t\t(lp->advertising & ADVERTISED_100baseT_Full))\n\t\t\tadv |= ADVERTISE_100FULL;\n\t\terr = mii_write(np, np->phy_addr, MII_ADVERTISE, adv);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (likely(bmsr & BMSR_ESTATEN)) {\n\t\t\tctrl1000 = 0;\n\t\t\tif ((estat & ESTATUS_1000_THALF) &&\n\t\t\t\t(lp->advertising & ADVERTISED_1000baseT_Half))\n\t\t\t\tctrl1000 |= ADVERTISE_1000HALF;\n\t\t\tif ((estat & ESTATUS_1000_TFULL) &&\n\t\t\t\t(lp->advertising & ADVERTISED_1000baseT_Full))\n\t\t\t\tctrl1000 |= ADVERTISE_1000FULL;\n\t\t\terr = mii_write(np, np->phy_addr,\n\t\t\t\t\tMII_CTRL1000, ctrl1000);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tbmcr |= (BMCR_ANENABLE | BMCR_ANRESTART);\n\t} else {\n\t\t/* !lp->autoneg */\n\t\tint fulldpx;\n\n\t\tif (lp->duplex == DUPLEX_FULL) {\n\t\t\tbmcr |= BMCR_FULLDPLX;\n\t\t\tfulldpx = 1;\n\t\t} else if (lp->duplex == DUPLEX_HALF)\n\t\t\tfulldpx = 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (lp->speed == SPEED_1000) {\n\t\t\t/* if X-full requested while not supported, or\n\t\t\t   X-half requested while not supported... */\n\t\t\tif ((fulldpx && !(estat & ESTATUS_1000_TFULL)) ||\n\t\t\t\t(!fulldpx && !(estat & ESTATUS_1000_THALF)))\n\t\t\t\treturn -EINVAL;\n\t\t\tbmcr |= BMCR_SPEED1000;\n\t\t} else if (lp->speed == SPEED_100) {\n\t\t\tif ((fulldpx && !(bmsr & BMSR_100FULL)) ||\n\t\t\t\t(!fulldpx && !(bmsr & BMSR_100HALF)))\n\t\t\t\treturn -EINVAL;\n\t\t\tbmcr |= BMCR_SPEED100;\n\t\t} else if (lp->speed == SPEED_10) {\n\t\t\tif ((fulldpx && !(bmsr & BMSR_10FULL)) ||\n\t\t\t\t(!fulldpx && !(bmsr & BMSR_10HALF)))\n\t\t\t\treturn -EINVAL;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\n\terr = mii_write(np, np->phy_addr, MII_BMCR, bmcr);\n\tif (err)\n\t\treturn err;\n\n#if 0\n\terr = mii_read(np, np->phy_addr, MII_BMCR);\n\tif (err < 0)\n\t\treturn err;\n\tbmcr = err;\n\n\terr = mii_read(np, np->phy_addr, MII_BMSR);\n\tif (err < 0)\n\t\treturn err;\n\tbmsr = err;\n\n\tpr_info(\"Port %u after MII init bmcr[%04x] bmsr[%04x]\\n\",\n\t\tnp->port, bmcr, bmsr);\n#endif\n\n\treturn 0;\n}\n\nstatic int xcvr_init_1g(struct niu *np)\n{\n\tu64 val;\n\n\t/* XXX shared resource, lock parent XXX */\n\tval = nr64(MIF_CONFIG);\n\tval &= ~MIF_CONFIG_INDIRECT_MODE;\n\tnw64(MIF_CONFIG, val);\n\n\treturn mii_init_common(np);\n}\n\nstatic int niu_xcvr_init(struct niu *np)\n{\n\tconst struct niu_phy_ops *ops = np->phy_ops;\n\tint err;\n\n\terr = 0;\n\tif (ops->xcvr_init)\n\t\terr = ops->xcvr_init(np);\n\n\treturn err;\n}\n\nstatic int niu_serdes_init(struct niu *np)\n{\n\tconst struct niu_phy_ops *ops = np->phy_ops;\n\tint err;\n\n\terr = 0;\n\tif (ops->serdes_init)\n\t\terr = ops->serdes_init(np);\n\n\treturn err;\n}\n\nstatic void niu_init_xif(struct niu *);\nstatic void niu_handle_led(struct niu *, int status);\n\nstatic int niu_link_status_common(struct niu *np, int link_up)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tstruct net_device *dev = np->dev;\n\tunsigned long flags;\n\n\tif (!netif_carrier_ok(dev) && link_up) {\n\t\tnetif_info(np, link, dev, \"Link is up at %s, %s duplex\\n\",\n\t\t\t   lp->active_speed == SPEED_10000 ? \"10Gb/sec\" :\n\t\t\t   lp->active_speed == SPEED_1000 ? \"1Gb/sec\" :\n\t\t\t   lp->active_speed == SPEED_100 ? \"100Mbit/sec\" :\n\t\t\t   \"10Mbit/sec\",\n\t\t\t   lp->active_duplex == DUPLEX_FULL ? \"full\" : \"half\");\n\n\t\tspin_lock_irqsave(&np->lock, flags);\n\t\tniu_init_xif(np);\n\t\tniu_handle_led(np, 1);\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\n\t\tnetif_carrier_on(dev);\n\t} else if (netif_carrier_ok(dev) && !link_up) {\n\t\tnetif_warn(np, link, dev, \"Link is down\\n\");\n\t\tspin_lock_irqsave(&np->lock, flags);\n\t\tniu_handle_led(np, 0);\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\tnetif_carrier_off(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int link_status_10g_mrvl(struct niu *np, int *link_up_p)\n{\n\tint err, link_up, pma_status, pcs_status;\n\n\tlink_up = 0;\n\n\terr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV1_ADDR,\n\t\t\tMRVL88X2011_10G_PMD_STATUS_2);\n\tif (err < 0)\n\t\tgoto out;\n\n\t/* Check PMA/PMD Register: 1.0001.2 == 1 */\n\terr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV1_ADDR,\n\t\t\tMRVL88X2011_PMA_PMD_STATUS_1);\n\tif (err < 0)\n\t\tgoto out;\n\n\tpma_status = ((err & MRVL88X2011_LNK_STATUS_OK) ? 1 : 0);\n\n        /* Check PMC Register : 3.0001.2 == 1: read twice */\n\terr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV3_ADDR,\n\t\t\tMRVL88X2011_PMA_PMD_STATUS_1);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV3_ADDR,\n\t\t\tMRVL88X2011_PMA_PMD_STATUS_1);\n\tif (err < 0)\n\t\tgoto out;\n\n\tpcs_status = ((err & MRVL88X2011_LNK_STATUS_OK) ? 1 : 0);\n\n        /* Check XGXS Register : 4.0018.[0-3,12] */\n\terr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV4_ADDR,\n\t\t\tMRVL88X2011_10G_XGXS_LANE_STAT);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (err == (PHYXS_XGXS_LANE_STAT_ALINGED | PHYXS_XGXS_LANE_STAT_LANE3 |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE2 | PHYXS_XGXS_LANE_STAT_LANE1 |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE0 | PHYXS_XGXS_LANE_STAT_MAGIC |\n\t\t    0x800))\n\t\tlink_up = (pma_status && pcs_status) ? 1 : 0;\n\n\tnp->link_config.active_speed = SPEED_10000;\n\tnp->link_config.active_duplex = DUPLEX_FULL;\n\terr = 0;\nout:\n\tmrvl88x2011_act_led(np, (link_up ?\n\t\t\t\t MRVL88X2011_LED_CTL_PCS_ACT :\n\t\t\t\t MRVL88X2011_LED_CTL_OFF));\n\n\t*link_up_p = link_up;\n\treturn err;\n}\n\nstatic int link_status_10g_bcm8706(struct niu *np, int *link_up_p)\n{\n\tint err, link_up;\n\tlink_up = 0;\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_PMA_PMD_DEV_ADDR,\n\t\t\tBCM8704_PMD_RCV_SIGDET);\n\tif (err < 0 || err == 0xffff)\n\t\tgoto out;\n\tif (!(err & PMD_RCV_SIGDET_GLOBAL)) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_PCS_DEV_ADDR,\n\t\t\tBCM8704_PCS_10G_R_STATUS);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (!(err & PCS_10G_R_STATUS_BLK_LOCK)) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_PHYXS_DEV_ADDR,\n\t\t\tBCM8704_PHYXS_XGXS_LANE_STAT);\n\tif (err < 0)\n\t\tgoto out;\n\tif (err != (PHYXS_XGXS_LANE_STAT_ALINGED |\n\t\t    PHYXS_XGXS_LANE_STAT_MAGIC |\n\t\t    PHYXS_XGXS_LANE_STAT_PATTEST |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE3 |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE2 |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE1 |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE0)) {\n\t\terr = 0;\n\t\tnp->link_config.active_speed = SPEED_INVALID;\n\t\tnp->link_config.active_duplex = DUPLEX_INVALID;\n\t\tgoto out;\n\t}\n\n\tlink_up = 1;\n\tnp->link_config.active_speed = SPEED_10000;\n\tnp->link_config.active_duplex = DUPLEX_FULL;\n\terr = 0;\n\nout:\n\t*link_up_p = link_up;\n\treturn err;\n}\n\nstatic int link_status_10g_bcom(struct niu *np, int *link_up_p)\n{\n\tint err, link_up;\n\n\tlink_up = 0;\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_PMA_PMD_DEV_ADDR,\n\t\t\tBCM8704_PMD_RCV_SIGDET);\n\tif (err < 0)\n\t\tgoto out;\n\tif (!(err & PMD_RCV_SIGDET_GLOBAL)) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_PCS_DEV_ADDR,\n\t\t\tBCM8704_PCS_10G_R_STATUS);\n\tif (err < 0)\n\t\tgoto out;\n\tif (!(err & PCS_10G_R_STATUS_BLK_LOCK)) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_PHYXS_DEV_ADDR,\n\t\t\tBCM8704_PHYXS_XGXS_LANE_STAT);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (err != (PHYXS_XGXS_LANE_STAT_ALINGED |\n\t\t    PHYXS_XGXS_LANE_STAT_MAGIC |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE3 |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE2 |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE1 |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE0)) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tlink_up = 1;\n\tnp->link_config.active_speed = SPEED_10000;\n\tnp->link_config.active_duplex = DUPLEX_FULL;\n\terr = 0;\n\nout:\n\t*link_up_p = link_up;\n\treturn err;\n}\n\nstatic int link_status_10g(struct niu *np, int *link_up_p)\n{\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\tif (np->link_config.loopback_mode == LOOPBACK_DISABLED) {\n\t\tint phy_id;\n\n\t\tphy_id = phy_decode(np->parent->port_phy, np->port);\n\t\tphy_id = np->parent->phy_probe_info.phy_id[phy_id][np->port];\n\n\t\t/* handle different phy types */\n\t\tswitch (phy_id & NIU_PHY_ID_MASK) {\n\t\tcase NIU_PHY_ID_MRVL88X2011:\n\t\t\terr = link_status_10g_mrvl(np, link_up_p);\n\t\t\tbreak;\n\n\t\tdefault: /* bcom 8704 */\n\t\t\terr = link_status_10g_bcom(np, link_up_p);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\treturn err;\n}\n\nstatic int niu_10g_phy_present(struct niu *np)\n{\n\tu64 sig, mask, val;\n\n\tsig = nr64(ESR_INT_SIGNALS);\n\tswitch (np->port) {\n\tcase 0:\n\t\tmask = ESR_INT_SIGNALS_P0_BITS;\n\t\tval = (ESR_INT_SRDY0_P0 |\n\t\t       ESR_INT_DET0_P0 |\n\t\t       ESR_INT_XSRDY_P0 |\n\t\t       ESR_INT_XDP_P0_CH3 |\n\t\t       ESR_INT_XDP_P0_CH2 |\n\t\t       ESR_INT_XDP_P0_CH1 |\n\t\t       ESR_INT_XDP_P0_CH0);\n\t\tbreak;\n\n\tcase 1:\n\t\tmask = ESR_INT_SIGNALS_P1_BITS;\n\t\tval = (ESR_INT_SRDY0_P1 |\n\t\t       ESR_INT_DET0_P1 |\n\t\t       ESR_INT_XSRDY_P1 |\n\t\t       ESR_INT_XDP_P1_CH3 |\n\t\t       ESR_INT_XDP_P1_CH2 |\n\t\t       ESR_INT_XDP_P1_CH1 |\n\t\t       ESR_INT_XDP_P1_CH0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif ((sig & mask) != val)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int link_status_10g_hotplug(struct niu *np, int *link_up_p)\n{\n\tunsigned long flags;\n\tint err = 0;\n\tint phy_present;\n\tint phy_present_prev;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\tif (np->link_config.loopback_mode == LOOPBACK_DISABLED) {\n\t\tphy_present_prev = (np->flags & NIU_FLAGS_HOTPLUG_PHY_PRESENT) ?\n\t\t\t1 : 0;\n\t\tphy_present = niu_10g_phy_present(np);\n\t\tif (phy_present != phy_present_prev) {\n\t\t\t/* state change */\n\t\t\tif (phy_present) {\n\t\t\t\t/* A NEM was just plugged in */\n\t\t\t\tnp->flags |= NIU_FLAGS_HOTPLUG_PHY_PRESENT;\n\t\t\t\tif (np->phy_ops->xcvr_init)\n\t\t\t\t\terr = np->phy_ops->xcvr_init(np);\n\t\t\t\tif (err) {\n\t\t\t\t\terr = mdio_read(np, np->phy_addr,\n\t\t\t\t\t\tBCM8704_PHYXS_DEV_ADDR, MII_BMCR);\n\t\t\t\t\tif (err == 0xffff) {\n\t\t\t\t\t\t/* No mdio, back-to-back XAUI */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/* debounce */\n\t\t\t\t\tnp->flags &= ~NIU_FLAGS_HOTPLUG_PHY_PRESENT;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnp->flags &= ~NIU_FLAGS_HOTPLUG_PHY_PRESENT;\n\t\t\t\t*link_up_p = 0;\n\t\t\t\tnetif_warn(np, link, np->dev,\n\t\t\t\t\t   \"Hotplug PHY Removed\\n\");\n\t\t\t}\n\t\t}\nout:\n\t\tif (np->flags & NIU_FLAGS_HOTPLUG_PHY_PRESENT) {\n\t\t\terr = link_status_10g_bcm8706(np, link_up_p);\n\t\t\tif (err == 0xffff) {\n\t\t\t\t/* No mdio, back-to-back XAUI: it is C10NEM */\n\t\t\t\t*link_up_p = 1;\n\t\t\t\tnp->link_config.active_speed = SPEED_10000;\n\t\t\t\tnp->link_config.active_duplex = DUPLEX_FULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\treturn 0;\n}\n\nstatic int niu_link_status(struct niu *np, int *link_up_p)\n{\n\tconst struct niu_phy_ops *ops = np->phy_ops;\n\tint err;\n\n\terr = 0;\n\tif (ops->link_status)\n\t\terr = ops->link_status(np, link_up_p);\n\n\treturn err;\n}\n\nstatic void niu_timer(struct timer_list *t)\n{\n\tstruct niu *np = from_timer(np, t, timer);\n\tunsigned long off;\n\tint err, link_up;\n\n\terr = niu_link_status(np, &link_up);\n\tif (!err)\n\t\tniu_link_status_common(np, link_up);\n\n\tif (netif_carrier_ok(np->dev))\n\t\toff = 5 * HZ;\n\telse\n\t\toff = 1 * HZ;\n\tnp->timer.expires = jiffies + off;\n\n\tadd_timer(&np->timer);\n}\n\nstatic const struct niu_phy_ops phy_ops_10g_serdes = {\n\t.serdes_init\t\t= serdes_init_10g_serdes,\n\t.link_status\t\t= link_status_10g_serdes,\n};\n\nstatic const struct niu_phy_ops phy_ops_10g_serdes_niu = {\n\t.serdes_init\t\t= serdes_init_niu_10g_serdes,\n\t.link_status\t\t= link_status_10g_serdes,\n};\n\nstatic const struct niu_phy_ops phy_ops_1g_serdes_niu = {\n\t.serdes_init\t\t= serdes_init_niu_1g_serdes,\n\t.link_status\t\t= link_status_1g_serdes,\n};\n\nstatic const struct niu_phy_ops phy_ops_1g_rgmii = {\n\t.xcvr_init\t\t= xcvr_init_1g_rgmii,\n\t.link_status\t\t= link_status_1g_rgmii,\n};\n\nstatic const struct niu_phy_ops phy_ops_10g_fiber_niu = {\n\t.serdes_init\t\t= serdes_init_niu_10g_fiber,\n\t.xcvr_init\t\t= xcvr_init_10g,\n\t.link_status\t\t= link_status_10g,\n};\n\nstatic const struct niu_phy_ops phy_ops_10g_fiber = {\n\t.serdes_init\t\t= serdes_init_10g,\n\t.xcvr_init\t\t= xcvr_init_10g,\n\t.link_status\t\t= link_status_10g,\n};\n\nstatic const struct niu_phy_ops phy_ops_10g_fiber_hotplug = {\n\t.serdes_init\t\t= serdes_init_10g,\n\t.xcvr_init\t\t= xcvr_init_10g_bcm8706,\n\t.link_status\t\t= link_status_10g_hotplug,\n};\n\nstatic const struct niu_phy_ops phy_ops_niu_10g_hotplug = {\n\t.serdes_init\t\t= serdes_init_niu_10g_fiber,\n\t.xcvr_init\t\t= xcvr_init_10g_bcm8706,\n\t.link_status\t\t= link_status_10g_hotplug,\n};\n\nstatic const struct niu_phy_ops phy_ops_10g_copper = {\n\t.serdes_init\t\t= serdes_init_10g,\n\t.link_status\t\t= link_status_10g, /* XXX */\n};\n\nstatic const struct niu_phy_ops phy_ops_1g_fiber = {\n\t.serdes_init\t\t= serdes_init_1g,\n\t.xcvr_init\t\t= xcvr_init_1g,\n\t.link_status\t\t= link_status_1g,\n};\n\nstatic const struct niu_phy_ops phy_ops_1g_copper = {\n\t.xcvr_init\t\t= xcvr_init_1g,\n\t.link_status\t\t= link_status_1g,\n};\n\nstruct niu_phy_template {\n\tconst struct niu_phy_ops\t*ops;\n\tu32\t\t\t\tphy_addr_base;\n};\n\nstatic const struct niu_phy_template phy_template_niu_10g_fiber = {\n\t.ops\t\t= &phy_ops_10g_fiber_niu,\n\t.phy_addr_base\t= 16,\n};\n\nstatic const struct niu_phy_template phy_template_niu_10g_serdes = {\n\t.ops\t\t= &phy_ops_10g_serdes_niu,\n\t.phy_addr_base\t= 0,\n};\n\nstatic const struct niu_phy_template phy_template_niu_1g_serdes = {\n\t.ops\t\t= &phy_ops_1g_serdes_niu,\n\t.phy_addr_base\t= 0,\n};\n\nstatic const struct niu_phy_template phy_template_10g_fiber = {\n\t.ops\t\t= &phy_ops_10g_fiber,\n\t.phy_addr_base\t= 8,\n};\n\nstatic const struct niu_phy_template phy_template_10g_fiber_hotplug = {\n\t.ops\t\t= &phy_ops_10g_fiber_hotplug,\n\t.phy_addr_base\t= 8,\n};\n\nstatic const struct niu_phy_template phy_template_niu_10g_hotplug = {\n\t.ops\t\t= &phy_ops_niu_10g_hotplug,\n\t.phy_addr_base\t= 8,\n};\n\nstatic const struct niu_phy_template phy_template_10g_copper = {\n\t.ops\t\t= &phy_ops_10g_copper,\n\t.phy_addr_base\t= 10,\n};\n\nstatic const struct niu_phy_template phy_template_1g_fiber = {\n\t.ops\t\t= &phy_ops_1g_fiber,\n\t.phy_addr_base\t= 0,\n};\n\nstatic const struct niu_phy_template phy_template_1g_copper = {\n\t.ops\t\t= &phy_ops_1g_copper,\n\t.phy_addr_base\t= 0,\n};\n\nstatic const struct niu_phy_template phy_template_1g_rgmii = {\n\t.ops\t\t= &phy_ops_1g_rgmii,\n\t.phy_addr_base\t= 0,\n};\n\nstatic const struct niu_phy_template phy_template_10g_serdes = {\n\t.ops\t\t= &phy_ops_10g_serdes,\n\t.phy_addr_base\t= 0,\n};\n\nstatic int niu_atca_port_num[4] = {\n\t0, 0,  11, 10\n};\n\nstatic int serdes_init_10g_serdes(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tunsigned long ctrl_reg, test_cfg_reg, pll_cfg, i;\n\tu64 ctrl_val, test_cfg_val, sig, mask, val;\n\n\tswitch (np->port) {\n\tcase 0:\n\t\tctrl_reg = ENET_SERDES_0_CTRL_CFG;\n\t\ttest_cfg_reg = ENET_SERDES_0_TEST_CFG;\n\t\tpll_cfg = ENET_SERDES_0_PLL_CFG;\n\t\tbreak;\n\tcase 1:\n\t\tctrl_reg = ENET_SERDES_1_CTRL_CFG;\n\t\ttest_cfg_reg = ENET_SERDES_1_TEST_CFG;\n\t\tpll_cfg = ENET_SERDES_1_PLL_CFG;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tctrl_val = (ENET_SERDES_CTRL_SDET_0 |\n\t\t    ENET_SERDES_CTRL_SDET_1 |\n\t\t    ENET_SERDES_CTRL_SDET_2 |\n\t\t    ENET_SERDES_CTRL_SDET_3 |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_0_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_1_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_2_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_3_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_0_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_1_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_2_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_3_SHIFT));\n\ttest_cfg_val = 0;\n\n\tif (lp->loopback_mode == LOOPBACK_PHY) {\n\t\ttest_cfg_val |= ((ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_0_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_1_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_2_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_3_SHIFT));\n\t}\n\n\tesr_reset(np);\n\tnw64(pll_cfg, ENET_SERDES_PLL_FBDIV2);\n\tnw64(ctrl_reg, ctrl_val);\n\tnw64(test_cfg_reg, test_cfg_val);\n\n\t/* Initialize all 4 lanes of the SERDES.  */\n\tfor (i = 0; i < 4; i++) {\n\t\tu32 rxtx_ctrl, glue0;\n\t\tint err;\n\n\t\terr = esr_read_rxtx_ctrl(np, i, &rxtx_ctrl);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = esr_read_glue0(np, i, &glue0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\trxtx_ctrl &= ~(ESR_RXTX_CTRL_VMUXLO);\n\t\trxtx_ctrl |= (ESR_RXTX_CTRL_ENSTRETCH |\n\t\t\t      (2 << ESR_RXTX_CTRL_VMUXLO_SHIFT));\n\n\t\tglue0 &= ~(ESR_GLUE_CTRL0_SRATE |\n\t\t\t   ESR_GLUE_CTRL0_THCNT |\n\t\t\t   ESR_GLUE_CTRL0_BLTIME);\n\t\tglue0 |= (ESR_GLUE_CTRL0_RXLOSENAB |\n\t\t\t  (0xf << ESR_GLUE_CTRL0_SRATE_SHIFT) |\n\t\t\t  (0xff << ESR_GLUE_CTRL0_THCNT_SHIFT) |\n\t\t\t  (BLTIME_300_CYCLES <<\n\t\t\t   ESR_GLUE_CTRL0_BLTIME_SHIFT));\n\n\t\terr = esr_write_rxtx_ctrl(np, i, rxtx_ctrl);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = esr_write_glue0(np, i, glue0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\n\tsig = nr64(ESR_INT_SIGNALS);\n\tswitch (np->port) {\n\tcase 0:\n\t\tmask = ESR_INT_SIGNALS_P0_BITS;\n\t\tval = (ESR_INT_SRDY0_P0 |\n\t\t       ESR_INT_DET0_P0 |\n\t\t       ESR_INT_XSRDY_P0 |\n\t\t       ESR_INT_XDP_P0_CH3 |\n\t\t       ESR_INT_XDP_P0_CH2 |\n\t\t       ESR_INT_XDP_P0_CH1 |\n\t\t       ESR_INT_XDP_P0_CH0);\n\t\tbreak;\n\n\tcase 1:\n\t\tmask = ESR_INT_SIGNALS_P1_BITS;\n\t\tval = (ESR_INT_SRDY0_P1 |\n\t\t       ESR_INT_DET0_P1 |\n\t\t       ESR_INT_XSRDY_P1 |\n\t\t       ESR_INT_XDP_P1_CH3 |\n\t\t       ESR_INT_XDP_P1_CH2 |\n\t\t       ESR_INT_XDP_P1_CH1 |\n\t\t       ESR_INT_XDP_P1_CH0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((sig & mask) != val) {\n\t\tint err;\n\t\terr = serdes_init_1g_serdes(np);\n\t\tif (!err) {\n\t\t\tnp->flags &= ~NIU_FLAGS_10G;\n\t\t\tnp->mac_xcvr = MAC_XCVR_PCS;\n\t\t}  else {\n\t\t\tnetdev_err(np->dev, \"Port %u 10G/1G SERDES Link Failed\\n\",\n\t\t\t\t   np->port);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_determine_phy_disposition(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tu8 plat_type = parent->plat_type;\n\tconst struct niu_phy_template *tp;\n\tu32 phy_addr_off = 0;\n\n\tif (plat_type == PLAT_TYPE_NIU) {\n\t\tswitch (np->flags &\n\t\t\t(NIU_FLAGS_10G |\n\t\t\t NIU_FLAGS_FIBER |\n\t\t\t NIU_FLAGS_XCVR_SERDES)) {\n\t\tcase NIU_FLAGS_10G | NIU_FLAGS_XCVR_SERDES:\n\t\t\t/* 10G Serdes */\n\t\t\ttp = &phy_template_niu_10g_serdes;\n\t\t\tbreak;\n\t\tcase NIU_FLAGS_XCVR_SERDES:\n\t\t\t/* 1G Serdes */\n\t\t\ttp = &phy_template_niu_1g_serdes;\n\t\t\tbreak;\n\t\tcase NIU_FLAGS_10G | NIU_FLAGS_FIBER:\n\t\t\t/* 10G Fiber */\n\t\tdefault:\n\t\t\tif (np->flags & NIU_FLAGS_HOTPLUG_PHY) {\n\t\t\t\ttp = &phy_template_niu_10g_hotplug;\n\t\t\t\tif (np->port == 0)\n\t\t\t\t\tphy_addr_off = 8;\n\t\t\t\tif (np->port == 1)\n\t\t\t\t\tphy_addr_off = 12;\n\t\t\t} else {\n\t\t\t\ttp = &phy_template_niu_10g_fiber;\n\t\t\t\tphy_addr_off += np->port;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (np->flags &\n\t\t\t(NIU_FLAGS_10G |\n\t\t\t NIU_FLAGS_FIBER |\n\t\t\t NIU_FLAGS_XCVR_SERDES)) {\n\t\tcase 0:\n\t\t\t/* 1G copper */\n\t\t\ttp = &phy_template_1g_copper;\n\t\t\tif (plat_type == PLAT_TYPE_VF_P0)\n\t\t\t\tphy_addr_off = 10;\n\t\t\telse if (plat_type == PLAT_TYPE_VF_P1)\n\t\t\t\tphy_addr_off = 26;\n\n\t\t\tphy_addr_off += (np->port ^ 0x3);\n\t\t\tbreak;\n\n\t\tcase NIU_FLAGS_10G:\n\t\t\t/* 10G copper */\n\t\t\ttp = &phy_template_10g_copper;\n\t\t\tbreak;\n\n\t\tcase NIU_FLAGS_FIBER:\n\t\t\t/* 1G fiber */\n\t\t\ttp = &phy_template_1g_fiber;\n\t\t\tbreak;\n\n\t\tcase NIU_FLAGS_10G | NIU_FLAGS_FIBER:\n\t\t\t/* 10G fiber */\n\t\t\ttp = &phy_template_10g_fiber;\n\t\t\tif (plat_type == PLAT_TYPE_VF_P0 ||\n\t\t\t    plat_type == PLAT_TYPE_VF_P1)\n\t\t\t\tphy_addr_off = 8;\n\t\t\tphy_addr_off += np->port;\n\t\t\tif (np->flags & NIU_FLAGS_HOTPLUG_PHY) {\n\t\t\t\ttp = &phy_template_10g_fiber_hotplug;\n\t\t\t\tif (np->port == 0)\n\t\t\t\t\tphy_addr_off = 8;\n\t\t\t\tif (np->port == 1)\n\t\t\t\t\tphy_addr_off = 12;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NIU_FLAGS_10G | NIU_FLAGS_XCVR_SERDES:\n\t\tcase NIU_FLAGS_XCVR_SERDES | NIU_FLAGS_FIBER:\n\t\tcase NIU_FLAGS_XCVR_SERDES:\n\t\t\tswitch(np->port) {\n\t\t\tcase 0:\n\t\t\tcase 1:\n\t\t\t\ttp = &phy_template_10g_serdes;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\t\ttp = &phy_template_1g_rgmii;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tphy_addr_off = niu_atca_port_num[np->port];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tnp->phy_ops = tp->ops;\n\tnp->phy_addr = tp->phy_addr_base + phy_addr_off;\n\n\treturn 0;\n}\n\nstatic int niu_init_link(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tint err, ignore;\n\n\tif (parent->plat_type == PLAT_TYPE_NIU) {\n\t\terr = niu_xcvr_init(np);\n\t\tif (err)\n\t\t\treturn err;\n\t\tmsleep(200);\n\t}\n\terr = niu_serdes_init(np);\n\tif (err && !(np->flags & NIU_FLAGS_HOTPLUG_PHY))\n\t\treturn err;\n\tmsleep(200);\n\terr = niu_xcvr_init(np);\n\tif (!err || (np->flags & NIU_FLAGS_HOTPLUG_PHY))\n\t\tniu_link_status(np, &ignore);\n\treturn 0;\n}\n\nstatic void niu_set_primary_mac(struct niu *np, unsigned char *addr)\n{\n\tu16 reg0 = addr[4] << 8 | addr[5];\n\tu16 reg1 = addr[2] << 8 | addr[3];\n\tu16 reg2 = addr[0] << 8 | addr[1];\n\n\tif (np->flags & NIU_FLAGS_XMAC) {\n\t\tnw64_mac(XMAC_ADDR0, reg0);\n\t\tnw64_mac(XMAC_ADDR1, reg1);\n\t\tnw64_mac(XMAC_ADDR2, reg2);\n\t} else {\n\t\tnw64_mac(BMAC_ADDR0, reg0);\n\t\tnw64_mac(BMAC_ADDR1, reg1);\n\t\tnw64_mac(BMAC_ADDR2, reg2);\n\t}\n}\n\nstatic int niu_num_alt_addr(struct niu *np)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\treturn XMAC_NUM_ALT_ADDR;\n\telse\n\t\treturn BMAC_NUM_ALT_ADDR;\n}\n\nstatic int niu_set_alt_mac(struct niu *np, int index, unsigned char *addr)\n{\n\tu16 reg0 = addr[4] << 8 | addr[5];\n\tu16 reg1 = addr[2] << 8 | addr[3];\n\tu16 reg2 = addr[0] << 8 | addr[1];\n\n\tif (index >= niu_num_alt_addr(np))\n\t\treturn -EINVAL;\n\n\tif (np->flags & NIU_FLAGS_XMAC) {\n\t\tnw64_mac(XMAC_ALT_ADDR0(index), reg0);\n\t\tnw64_mac(XMAC_ALT_ADDR1(index), reg1);\n\t\tnw64_mac(XMAC_ALT_ADDR2(index), reg2);\n\t} else {\n\t\tnw64_mac(BMAC_ALT_ADDR0(index), reg0);\n\t\tnw64_mac(BMAC_ALT_ADDR1(index), reg1);\n\t\tnw64_mac(BMAC_ALT_ADDR2(index), reg2);\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_enable_alt_mac(struct niu *np, int index, int on)\n{\n\tunsigned long reg;\n\tu64 val, mask;\n\n\tif (index >= niu_num_alt_addr(np))\n\t\treturn -EINVAL;\n\n\tif (np->flags & NIU_FLAGS_XMAC) {\n\t\treg = XMAC_ADDR_CMPEN;\n\t\tmask = 1 << index;\n\t} else {\n\t\treg = BMAC_ADDR_CMPEN;\n\t\tmask = 1 << (index + 1);\n\t}\n\n\tval = nr64_mac(reg);\n\tif (on)\n\t\tval |= mask;\n\telse\n\t\tval &= ~mask;\n\tnw64_mac(reg, val);\n\n\treturn 0;\n}\n\nstatic void __set_rdc_table_num_hw(struct niu *np, unsigned long reg,\n\t\t\t\t   int num, int mac_pref)\n{\n\tu64 val = nr64_mac(reg);\n\tval &= ~(HOST_INFO_MACRDCTBLN | HOST_INFO_MPR);\n\tval |= num;\n\tif (mac_pref)\n\t\tval |= HOST_INFO_MPR;\n\tnw64_mac(reg, val);\n}\n\nstatic int __set_rdc_table_num(struct niu *np,\n\t\t\t       int xmac_index, int bmac_index,\n\t\t\t       int rdc_table_num, int mac_pref)\n{\n\tunsigned long reg;\n\n\tif (rdc_table_num & ~HOST_INFO_MACRDCTBLN)\n\t\treturn -EINVAL;\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\treg = XMAC_HOST_INFO(xmac_index);\n\telse\n\t\treg = BMAC_HOST_INFO(bmac_index);\n\t__set_rdc_table_num_hw(np, reg, rdc_table_num, mac_pref);\n\treturn 0;\n}\n\nstatic int niu_set_primary_mac_rdc_table(struct niu *np, int table_num,\n\t\t\t\t\t int mac_pref)\n{\n\treturn __set_rdc_table_num(np, 17, 0, table_num, mac_pref);\n}\n\nstatic int niu_set_multicast_mac_rdc_table(struct niu *np, int table_num,\n\t\t\t\t\t   int mac_pref)\n{\n\treturn __set_rdc_table_num(np, 16, 8, table_num, mac_pref);\n}\n\nstatic int niu_set_alt_mac_rdc_table(struct niu *np, int idx,\n\t\t\t\t     int table_num, int mac_pref)\n{\n\tif (idx >= niu_num_alt_addr(np))\n\t\treturn -EINVAL;\n\treturn __set_rdc_table_num(np, idx, idx + 1, table_num, mac_pref);\n}\n\nstatic u64 vlan_entry_set_parity(u64 reg_val)\n{\n\tu64 port01_mask;\n\tu64 port23_mask;\n\n\tport01_mask = 0x00ff;\n\tport23_mask = 0xff00;\n\n\tif (hweight64(reg_val & port01_mask) & 1)\n\t\treg_val |= ENET_VLAN_TBL_PARITY0;\n\telse\n\t\treg_val &= ~ENET_VLAN_TBL_PARITY0;\n\n\tif (hweight64(reg_val & port23_mask) & 1)\n\t\treg_val |= ENET_VLAN_TBL_PARITY1;\n\telse\n\t\treg_val &= ~ENET_VLAN_TBL_PARITY1;\n\n\treturn reg_val;\n}\n\nstatic void vlan_tbl_write(struct niu *np, unsigned long index,\n\t\t\t   int port, int vpr, int rdc_table)\n{\n\tu64 reg_val = nr64(ENET_VLAN_TBL(index));\n\n\treg_val &= ~((ENET_VLAN_TBL_VPR |\n\t\t      ENET_VLAN_TBL_VLANRDCTBLN) <<\n\t\t     ENET_VLAN_TBL_SHIFT(port));\n\tif (vpr)\n\t\treg_val |= (ENET_VLAN_TBL_VPR <<\n\t\t\t    ENET_VLAN_TBL_SHIFT(port));\n\treg_val |= (rdc_table << ENET_VLAN_TBL_SHIFT(port));\n\n\treg_val = vlan_entry_set_parity(reg_val);\n\n\tnw64(ENET_VLAN_TBL(index), reg_val);\n}\n\nstatic void vlan_tbl_clear(struct niu *np)\n{\n\tint i;\n\n\tfor (i = 0; i < ENET_VLAN_TBL_NUM_ENTRIES; i++)\n\t\tnw64(ENET_VLAN_TBL(i), 0);\n}\n\nstatic int tcam_wait_bit(struct niu *np, u64 bit)\n{\n\tint limit = 1000;\n\n\twhile (--limit > 0) {\n\t\tif (nr64(TCAM_CTL) & bit)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (limit <= 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int tcam_flush(struct niu *np, int index)\n{\n\tnw64(TCAM_KEY_0, 0x00);\n\tnw64(TCAM_KEY_MASK_0, 0xff);\n\tnw64(TCAM_CTL, (TCAM_CTL_RWC_TCAM_WRITE | index));\n\n\treturn tcam_wait_bit(np, TCAM_CTL_STAT);\n}\n\n#if 0\nstatic int tcam_read(struct niu *np, int index,\n\t\t     u64 *key, u64 *mask)\n{\n\tint err;\n\n\tnw64(TCAM_CTL, (TCAM_CTL_RWC_TCAM_READ | index));\n\terr = tcam_wait_bit(np, TCAM_CTL_STAT);\n\tif (!err) {\n\t\tkey[0] = nr64(TCAM_KEY_0);\n\t\tkey[1] = nr64(TCAM_KEY_1);\n\t\tkey[2] = nr64(TCAM_KEY_2);\n\t\tkey[3] = nr64(TCAM_KEY_3);\n\t\tmask[0] = nr64(TCAM_KEY_MASK_0);\n\t\tmask[1] = nr64(TCAM_KEY_MASK_1);\n\t\tmask[2] = nr64(TCAM_KEY_MASK_2);\n\t\tmask[3] = nr64(TCAM_KEY_MASK_3);\n\t}\n\treturn err;\n}\n#endif\n\nstatic int tcam_write(struct niu *np, int index,\n\t\t      u64 *key, u64 *mask)\n{\n\tnw64(TCAM_KEY_0, key[0]);\n\tnw64(TCAM_KEY_1, key[1]);\n\tnw64(TCAM_KEY_2, key[2]);\n\tnw64(TCAM_KEY_3, key[3]);\n\tnw64(TCAM_KEY_MASK_0, mask[0]);\n\tnw64(TCAM_KEY_MASK_1, mask[1]);\n\tnw64(TCAM_KEY_MASK_2, mask[2]);\n\tnw64(TCAM_KEY_MASK_3, mask[3]);\n\tnw64(TCAM_CTL, (TCAM_CTL_RWC_TCAM_WRITE | index));\n\n\treturn tcam_wait_bit(np, TCAM_CTL_STAT);\n}\n\n#if 0\nstatic int tcam_assoc_read(struct niu *np, int index, u64 *data)\n{\n\tint err;\n\n\tnw64(TCAM_CTL, (TCAM_CTL_RWC_RAM_READ | index));\n\terr = tcam_wait_bit(np, TCAM_CTL_STAT);\n\tif (!err)\n\t\t*data = nr64(TCAM_KEY_1);\n\n\treturn err;\n}\n#endif\n\nstatic int tcam_assoc_write(struct niu *np, int index, u64 assoc_data)\n{\n\tnw64(TCAM_KEY_1, assoc_data);\n\tnw64(TCAM_CTL, (TCAM_CTL_RWC_RAM_WRITE | index));\n\n\treturn tcam_wait_bit(np, TCAM_CTL_STAT);\n}\n\nstatic void tcam_enable(struct niu *np, int on)\n{\n\tu64 val = nr64(FFLP_CFG_1);\n\n\tif (on)\n\t\tval &= ~FFLP_CFG_1_TCAM_DIS;\n\telse\n\t\tval |= FFLP_CFG_1_TCAM_DIS;\n\tnw64(FFLP_CFG_1, val);\n}\n\nstatic void tcam_set_lat_and_ratio(struct niu *np, u64 latency, u64 ratio)\n{\n\tu64 val = nr64(FFLP_CFG_1);\n\n\tval &= ~(FFLP_CFG_1_FFLPINITDONE |\n\t\t FFLP_CFG_1_CAMLAT |\n\t\t FFLP_CFG_1_CAMRATIO);\n\tval |= (latency << FFLP_CFG_1_CAMLAT_SHIFT);\n\tval |= (ratio << FFLP_CFG_1_CAMRATIO_SHIFT);\n\tnw64(FFLP_CFG_1, val);\n\n\tval = nr64(FFLP_CFG_1);\n\tval |= FFLP_CFG_1_FFLPINITDONE;\n\tnw64(FFLP_CFG_1, val);\n}\n\nstatic int tcam_user_eth_class_enable(struct niu *np, unsigned long class,\n\t\t\t\t      int on)\n{\n\tunsigned long reg;\n\tu64 val;\n\n\tif (class < CLASS_CODE_ETHERTYPE1 ||\n\t    class > CLASS_CODE_ETHERTYPE2)\n\t\treturn -EINVAL;\n\n\treg = L2_CLS(class - CLASS_CODE_ETHERTYPE1);\n\tval = nr64(reg);\n\tif (on)\n\t\tval |= L2_CLS_VLD;\n\telse\n\t\tval &= ~L2_CLS_VLD;\n\tnw64(reg, val);\n\n\treturn 0;\n}\n\n#if 0\nstatic int tcam_user_eth_class_set(struct niu *np, unsigned long class,\n\t\t\t\t   u64 ether_type)\n{\n\tunsigned long reg;\n\tu64 val;\n\n\tif (class < CLASS_CODE_ETHERTYPE1 ||\n\t    class > CLASS_CODE_ETHERTYPE2 ||\n\t    (ether_type & ~(u64)0xffff) != 0)\n\t\treturn -EINVAL;\n\n\treg = L2_CLS(class - CLASS_CODE_ETHERTYPE1);\n\tval = nr64(reg);\n\tval &= ~L2_CLS_ETYPE;\n\tval |= (ether_type << L2_CLS_ETYPE_SHIFT);\n\tnw64(reg, val);\n\n\treturn 0;\n}\n#endif\n\nstatic int tcam_user_ip_class_enable(struct niu *np, unsigned long class,\n\t\t\t\t     int on)\n{\n\tunsigned long reg;\n\tu64 val;\n\n\tif (class < CLASS_CODE_USER_PROG1 ||\n\t    class > CLASS_CODE_USER_PROG4)\n\t\treturn -EINVAL;\n\n\treg = L3_CLS(class - CLASS_CODE_USER_PROG1);\n\tval = nr64(reg);\n\tif (on)\n\t\tval |= L3_CLS_VALID;\n\telse\n\t\tval &= ~L3_CLS_VALID;\n\tnw64(reg, val);\n\n\treturn 0;\n}\n\nstatic int tcam_user_ip_class_set(struct niu *np, unsigned long class,\n\t\t\t\t  int ipv6, u64 protocol_id,\n\t\t\t\t  u64 tos_mask, u64 tos_val)\n{\n\tunsigned long reg;\n\tu64 val;\n\n\tif (class < CLASS_CODE_USER_PROG1 ||\n\t    class > CLASS_CODE_USER_PROG4 ||\n\t    (protocol_id & ~(u64)0xff) != 0 ||\n\t    (tos_mask & ~(u64)0xff) != 0 ||\n\t    (tos_val & ~(u64)0xff) != 0)\n\t\treturn -EINVAL;\n\n\treg = L3_CLS(class - CLASS_CODE_USER_PROG1);\n\tval = nr64(reg);\n\tval &= ~(L3_CLS_IPVER | L3_CLS_PID |\n\t\t L3_CLS_TOSMASK | L3_CLS_TOS);\n\tif (ipv6)\n\t\tval |= L3_CLS_IPVER;\n\tval |= (protocol_id << L3_CLS_PID_SHIFT);\n\tval |= (tos_mask << L3_CLS_TOSMASK_SHIFT);\n\tval |= (tos_val << L3_CLS_TOS_SHIFT);\n\tnw64(reg, val);\n\n\treturn 0;\n}\n\nstatic int tcam_early_init(struct niu *np)\n{\n\tunsigned long i;\n\tint err;\n\n\ttcam_enable(np, 0);\n\ttcam_set_lat_and_ratio(np,\n\t\t\t       DEFAULT_TCAM_LATENCY,\n\t\t\t       DEFAULT_TCAM_ACCESS_RATIO);\n\tfor (i = CLASS_CODE_ETHERTYPE1; i <= CLASS_CODE_ETHERTYPE2; i++) {\n\t\terr = tcam_user_eth_class_enable(np, i, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tfor (i = CLASS_CODE_USER_PROG1; i <= CLASS_CODE_USER_PROG4; i++) {\n\t\terr = tcam_user_ip_class_enable(np, i, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int tcam_flush_all(struct niu *np)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < np->parent->tcam_num_entries; i++) {\n\t\tint err = tcam_flush(np, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic u64 hash_addr_regval(unsigned long index, unsigned long num_entries)\n{\n\treturn (u64)index | (num_entries == 1 ? HASH_TBL_ADDR_AUTOINC : 0);\n}\n\n#if 0\nstatic int hash_read(struct niu *np, unsigned long partition,\n\t\t     unsigned long index, unsigned long num_entries,\n\t\t     u64 *data)\n{\n\tu64 val = hash_addr_regval(index, num_entries);\n\tunsigned long i;\n\n\tif (partition >= FCRAM_NUM_PARTITIONS ||\n\t    index + num_entries > FCRAM_SIZE)\n\t\treturn -EINVAL;\n\n\tnw64(HASH_TBL_ADDR(partition), val);\n\tfor (i = 0; i < num_entries; i++)\n\t\tdata[i] = nr64(HASH_TBL_DATA(partition));\n\n\treturn 0;\n}\n#endif\n\nstatic int hash_write(struct niu *np, unsigned long partition,\n\t\t      unsigned long index, unsigned long num_entries,\n\t\t      u64 *data)\n{\n\tu64 val = hash_addr_regval(index, num_entries);\n\tunsigned long i;\n\n\tif (partition >= FCRAM_NUM_PARTITIONS ||\n\t    index + (num_entries * 8) > FCRAM_SIZE)\n\t\treturn -EINVAL;\n\n\tnw64(HASH_TBL_ADDR(partition), val);\n\tfor (i = 0; i < num_entries; i++)\n\t\tnw64(HASH_TBL_DATA(partition), data[i]);\n\n\treturn 0;\n}\n\nstatic void fflp_reset(struct niu *np)\n{\n\tu64 val;\n\n\tnw64(FFLP_CFG_1, FFLP_CFG_1_PIO_FIO_RST);\n\tudelay(10);\n\tnw64(FFLP_CFG_1, 0);\n\n\tval = FFLP_CFG_1_FCRAMOUTDR_NORMAL | FFLP_CFG_1_FFLPINITDONE;\n\tnw64(FFLP_CFG_1, val);\n}\n\nstatic void fflp_set_timings(struct niu *np)\n{\n\tu64 val = nr64(FFLP_CFG_1);\n\n\tval &= ~FFLP_CFG_1_FFLPINITDONE;\n\tval |= (DEFAULT_FCRAMRATIO << FFLP_CFG_1_FCRAMRATIO_SHIFT);\n\tnw64(FFLP_CFG_1, val);\n\n\tval = nr64(FFLP_CFG_1);\n\tval |= FFLP_CFG_1_FFLPINITDONE;\n\tnw64(FFLP_CFG_1, val);\n\n\tval = nr64(FCRAM_REF_TMR);\n\tval &= ~(FCRAM_REF_TMR_MAX | FCRAM_REF_TMR_MIN);\n\tval |= (DEFAULT_FCRAM_REFRESH_MAX << FCRAM_REF_TMR_MAX_SHIFT);\n\tval |= (DEFAULT_FCRAM_REFRESH_MIN << FCRAM_REF_TMR_MIN_SHIFT);\n\tnw64(FCRAM_REF_TMR, val);\n}\n\nstatic int fflp_set_partition(struct niu *np, u64 partition,\n\t\t\t      u64 mask, u64 base, int enable)\n{\n\tunsigned long reg;\n\tu64 val;\n\n\tif (partition >= FCRAM_NUM_PARTITIONS ||\n\t    (mask & ~(u64)0x1f) != 0 ||\n\t    (base & ~(u64)0x1f) != 0)\n\t\treturn -EINVAL;\n\n\treg = FLW_PRT_SEL(partition);\n\n\tval = nr64(reg);\n\tval &= ~(FLW_PRT_SEL_EXT | FLW_PRT_SEL_MASK | FLW_PRT_SEL_BASE);\n\tval |= (mask << FLW_PRT_SEL_MASK_SHIFT);\n\tval |= (base << FLW_PRT_SEL_BASE_SHIFT);\n\tif (enable)\n\t\tval |= FLW_PRT_SEL_EXT;\n\tnw64(reg, val);\n\n\treturn 0;\n}\n\nstatic int fflp_disable_all_partitions(struct niu *np)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < FCRAM_NUM_PARTITIONS; i++) {\n\t\tint err = fflp_set_partition(np, 0, 0, 0, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void fflp_llcsnap_enable(struct niu *np, int on)\n{\n\tu64 val = nr64(FFLP_CFG_1);\n\n\tif (on)\n\t\tval |= FFLP_CFG_1_LLCSNAP;\n\telse\n\t\tval &= ~FFLP_CFG_1_LLCSNAP;\n\tnw64(FFLP_CFG_1, val);\n}\n\nstatic void fflp_errors_enable(struct niu *np, int on)\n{\n\tu64 val = nr64(FFLP_CFG_1);\n\n\tif (on)\n\t\tval &= ~FFLP_CFG_1_ERRORDIS;\n\telse\n\t\tval |= FFLP_CFG_1_ERRORDIS;\n\tnw64(FFLP_CFG_1, val);\n}\n\nstatic int fflp_hash_clear(struct niu *np)\n{\n\tstruct fcram_hash_ipv4 ent;\n\tunsigned long i;\n\n\t/* IPV4 hash entry with valid bit clear, rest is don't care.  */\n\tmemset(&ent, 0, sizeof(ent));\n\tent.header = HASH_HEADER_EXT;\n\n\tfor (i = 0; i < FCRAM_SIZE; i += sizeof(ent)) {\n\t\tint err = hash_write(np, 0, i, 1, (u64 *) &ent);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int fflp_early_init(struct niu *np)\n{\n\tstruct niu_parent *parent;\n\tunsigned long flags;\n\tint err;\n\n\tniu_lock_parent(np, flags);\n\n\tparent = np->parent;\n\terr = 0;\n\tif (!(parent->flags & PARENT_FLGS_CLS_HWINIT)) {\n\t\tif (np->parent->plat_type != PLAT_TYPE_NIU) {\n\t\t\tfflp_reset(np);\n\t\t\tfflp_set_timings(np);\n\t\t\terr = fflp_disable_all_partitions(np);\n\t\t\tif (err) {\n\t\t\t\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t\t\t\t     \"fflp_disable_all_partitions failed, err=%d\\n\",\n\t\t\t\t\t     err);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\terr = tcam_early_init(np);\n\t\tif (err) {\n\t\t\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t\t\t     \"tcam_early_init failed, err=%d\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\t\tfflp_llcsnap_enable(np, 1);\n\t\tfflp_errors_enable(np, 0);\n\t\tnw64(H1POLY, 0);\n\t\tnw64(H2POLY, 0);\n\n\t\terr = tcam_flush_all(np);\n\t\tif (err) {\n\t\t\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t\t\t     \"tcam_flush_all failed, err=%d\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\t\tif (np->parent->plat_type != PLAT_TYPE_NIU) {\n\t\t\terr = fflp_hash_clear(np);\n\t\t\tif (err) {\n\t\t\t\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t\t\t\t     \"fflp_hash_clear failed, err=%d\\n\",\n\t\t\t\t\t     err);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tvlan_tbl_clear(np);\n\n\t\tparent->flags |= PARENT_FLGS_CLS_HWINIT;\n\t}\nout:\n\tniu_unlock_parent(np, flags);\n\treturn err;\n}\n\nstatic int niu_set_flow_key(struct niu *np, unsigned long class_code, u64 key)\n{\n\tif (class_code < CLASS_CODE_USER_PROG1 ||\n\t    class_code > CLASS_CODE_SCTP_IPV6)\n\t\treturn -EINVAL;\n\n\tnw64(FLOW_KEY(class_code - CLASS_CODE_USER_PROG1), key);\n\treturn 0;\n}\n\nstatic int niu_set_tcam_key(struct niu *np, unsigned long class_code, u64 key)\n{\n\tif (class_code < CLASS_CODE_USER_PROG1 ||\n\t    class_code > CLASS_CODE_SCTP_IPV6)\n\t\treturn -EINVAL;\n\n\tnw64(TCAM_KEY(class_code - CLASS_CODE_USER_PROG1), key);\n\treturn 0;\n}\n\n/* Entries for the ports are interleaved in the TCAM */\nstatic u16 tcam_get_index(struct niu *np, u16 idx)\n{\n\t/* One entry reserved for IP fragment rule */\n\tif (idx >= (np->clas.tcam_sz - 1))\n\t\tidx = 0;\n\treturn np->clas.tcam_top + ((idx+1) * np->parent->num_ports);\n}\n\nstatic u16 tcam_get_size(struct niu *np)\n{\n\t/* One entry reserved for IP fragment rule */\n\treturn np->clas.tcam_sz - 1;\n}\n\nstatic u16 tcam_get_valid_entry_cnt(struct niu *np)\n{\n\t/* One entry reserved for IP fragment rule */\n\treturn np->clas.tcam_valid_entries - 1;\n}\n\nstatic void niu_rx_skb_append(struct sk_buff *skb, struct page *page,\n\t\t\t      u32 offset, u32 size, u32 truesize)\n{\n\tskb_fill_page_desc(skb, skb_shinfo(skb)->nr_frags, page, offset, size);\n\n\tskb->len += size;\n\tskb->data_len += size;\n\tskb->truesize += truesize;\n}\n\nstatic unsigned int niu_hash_rxaddr(struct rx_ring_info *rp, u64 a)\n{\n\ta >>= PAGE_SHIFT;\n\ta ^= (a >> ilog2(MAX_RBR_RING_SIZE));\n\n\treturn a & (MAX_RBR_RING_SIZE - 1);\n}\n\nstatic struct page *niu_find_rxpage(struct rx_ring_info *rp, u64 addr,\n\t\t\t\t    struct page ***link)\n{\n\tunsigned int h = niu_hash_rxaddr(rp, addr);\n\tstruct page *p, **pp;\n\n\taddr &= PAGE_MASK;\n\tpp = &rp->rxhash[h];\n\tfor (; (p = *pp) != NULL; pp = (struct page **) &p->mapping) {\n\t\tif (p->index == addr) {\n\t\t\t*link = pp;\n\t\t\tgoto found;\n\t\t}\n\t}\n\tBUG();\n\nfound:\n\treturn p;\n}\n\nstatic void niu_hash_page(struct rx_ring_info *rp, struct page *page, u64 base)\n{\n\tunsigned int h = niu_hash_rxaddr(rp, base);\n\n\tpage->index = base;\n\tpage->mapping = (struct address_space *) rp->rxhash[h];\n\trp->rxhash[h] = page;\n}\n\nstatic int niu_rbr_add_page(struct niu *np, struct rx_ring_info *rp,\n\t\t\t    gfp_t mask, int start_index)\n{\n\tstruct page *page;\n\tu64 addr;\n\tint i;\n\n\tpage = alloc_page(mask);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\taddr = np->ops->map_page(np->device, page, 0,\n\t\t\t\t PAGE_SIZE, DMA_FROM_DEVICE);\n\tif (!addr) {\n\t\t__free_page(page);\n\t\treturn -ENOMEM;\n\t}\n\n\tniu_hash_page(rp, page, addr);\n\tif (rp->rbr_blocks_per_page > 1)\n\t\tpage_ref_add(page, rp->rbr_blocks_per_page - 1);\n\n\tfor (i = 0; i < rp->rbr_blocks_per_page; i++) {\n\t\t__le32 *rbr = &rp->rbr[start_index + i];\n\n\t\t*rbr = cpu_to_le32(addr >> RBR_DESCR_ADDR_SHIFT);\n\t\taddr += rp->rbr_block_size;\n\t}\n\n\treturn 0;\n}\n\nstatic void niu_rbr_refill(struct niu *np, struct rx_ring_info *rp, gfp_t mask)\n{\n\tint index = rp->rbr_index;\n\n\trp->rbr_pending++;\n\tif ((rp->rbr_pending % rp->rbr_blocks_per_page) == 0) {\n\t\tint err = niu_rbr_add_page(np, rp, mask, index);\n\n\t\tif (unlikely(err)) {\n\t\t\trp->rbr_pending--;\n\t\t\treturn;\n\t\t}\n\n\t\trp->rbr_index += rp->rbr_blocks_per_page;\n\t\tBUG_ON(rp->rbr_index > rp->rbr_table_size);\n\t\tif (rp->rbr_index == rp->rbr_table_size)\n\t\t\trp->rbr_index = 0;\n\n\t\tif (rp->rbr_pending >= rp->rbr_kick_thresh) {\n\t\t\tnw64(RBR_KICK(rp->rx_channel), rp->rbr_pending);\n\t\t\trp->rbr_pending = 0;\n\t\t}\n\t}\n}\n\nstatic int niu_rx_pkt_ignore(struct niu *np, struct rx_ring_info *rp)\n{\n\tunsigned int index = rp->rcr_index;\n\tint num_rcr = 0;\n\n\trp->rx_dropped++;\n\twhile (1) {\n\t\tstruct page *page, **link;\n\t\tu64 addr, val;\n\t\tu32 rcr_size;\n\n\t\tnum_rcr++;\n\n\t\tval = le64_to_cpup(&rp->rcr[index]);\n\t\taddr = (val & RCR_ENTRY_PKT_BUF_ADDR) <<\n\t\t\tRCR_ENTRY_PKT_BUF_ADDR_SHIFT;\n\t\tpage = niu_find_rxpage(rp, addr, &link);\n\n\t\trcr_size = rp->rbr_sizes[(val & RCR_ENTRY_PKTBUFSZ) >>\n\t\t\t\t\t RCR_ENTRY_PKTBUFSZ_SHIFT];\n\t\tif ((page->index + PAGE_SIZE) - rcr_size == addr) {\n\t\t\t*link = (struct page *) page->mapping;\n\t\t\tnp->ops->unmap_page(np->device, page->index,\n\t\t\t\t\t    PAGE_SIZE, DMA_FROM_DEVICE);\n\t\t\tpage->index = 0;\n\t\t\tpage->mapping = NULL;\n\t\t\t__free_page(page);\n\t\t\trp->rbr_refill_pending++;\n\t\t}\n\n\t\tindex = NEXT_RCR(rp, index);\n\t\tif (!(val & RCR_ENTRY_MULTI))\n\t\t\tbreak;\n\n\t}\n\trp->rcr_index = index;\n\n\treturn num_rcr;\n}\n\nstatic int niu_process_rx_pkt(struct napi_struct *napi, struct niu *np,\n\t\t\t      struct rx_ring_info *rp)\n{\n\tunsigned int index = rp->rcr_index;\n\tstruct rx_pkt_hdr1 *rh;\n\tstruct sk_buff *skb;\n\tint len, num_rcr;\n\n\tskb = netdev_alloc_skb(np->dev, RX_SKB_ALLOC_SIZE);\n\tif (unlikely(!skb))\n\t\treturn niu_rx_pkt_ignore(np, rp);\n\n\tnum_rcr = 0;\n\twhile (1) {\n\t\tstruct page *page, **link;\n\t\tu32 rcr_size, append_size;\n\t\tu64 addr, val, off;\n\n\t\tnum_rcr++;\n\n\t\tval = le64_to_cpup(&rp->rcr[index]);\n\n\t\tlen = (val & RCR_ENTRY_L2_LEN) >>\n\t\t\tRCR_ENTRY_L2_LEN_SHIFT;\n\t\tappend_size = len + ETH_HLEN + ETH_FCS_LEN;\n\n\t\taddr = (val & RCR_ENTRY_PKT_BUF_ADDR) <<\n\t\t\tRCR_ENTRY_PKT_BUF_ADDR_SHIFT;\n\t\tpage = niu_find_rxpage(rp, addr, &link);\n\n\t\trcr_size = rp->rbr_sizes[(val & RCR_ENTRY_PKTBUFSZ) >>\n\t\t\t\t\t RCR_ENTRY_PKTBUFSZ_SHIFT];\n\n\t\toff = addr & ~PAGE_MASK;\n\t\tif (num_rcr == 1) {\n\t\t\tint ptype;\n\n\t\t\tptype = (val >> RCR_ENTRY_PKT_TYPE_SHIFT);\n\t\t\tif ((ptype == RCR_PKT_TYPE_TCP ||\n\t\t\t     ptype == RCR_PKT_TYPE_UDP) &&\n\t\t\t    !(val & (RCR_ENTRY_NOPORT |\n\t\t\t\t     RCR_ENTRY_ERROR)))\n\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\telse\n\t\t\t\tskb_checksum_none_assert(skb);\n\t\t} else if (!(val & RCR_ENTRY_MULTI))\n\t\t\tappend_size = append_size - skb->len;\n\n\t\tniu_rx_skb_append(skb, page, off, append_size, rcr_size);\n\t\tif ((page->index + rp->rbr_block_size) - rcr_size == addr) {\n\t\t\t*link = (struct page *) page->mapping;\n\t\t\tnp->ops->unmap_page(np->device, page->index,\n\t\t\t\t\t    PAGE_SIZE, DMA_FROM_DEVICE);\n\t\t\tpage->index = 0;\n\t\t\tpage->mapping = NULL;\n\t\t\trp->rbr_refill_pending++;\n\t\t} else\n\t\t\tget_page(page);\n\n\t\tindex = NEXT_RCR(rp, index);\n\t\tif (!(val & RCR_ENTRY_MULTI))\n\t\t\tbreak;\n\n\t}\n\trp->rcr_index = index;\n\n\tlen += sizeof(*rh);\n\tlen = min_t(int, len, sizeof(*rh) + VLAN_ETH_HLEN);\n\t__pskb_pull_tail(skb, len);\n\n\trh = (struct rx_pkt_hdr1 *) skb->data;\n\tif (np->dev->features & NETIF_F_RXHASH)\n\t\tskb_set_hash(skb,\n\t\t\t     ((u32)rh->hashval2_0 << 24 |\n\t\t\t      (u32)rh->hashval2_1 << 16 |\n\t\t\t      (u32)rh->hashval1_1 << 8 |\n\t\t\t      (u32)rh->hashval1_2 << 0),\n\t\t\t     PKT_HASH_TYPE_L3);\n\tskb_pull(skb, sizeof(*rh));\n\n\trp->rx_packets++;\n\trp->rx_bytes += skb->len;\n\n\tskb->protocol = eth_type_trans(skb, np->dev);\n\tskb_record_rx_queue(skb, rp->rx_channel);\n\tnapi_gro_receive(napi, skb);\n\n\treturn num_rcr;\n}\n\nstatic int niu_rbr_fill(struct niu *np, struct rx_ring_info *rp, gfp_t mask)\n{\n\tint blocks_per_page = rp->rbr_blocks_per_page;\n\tint err, index = rp->rbr_index;\n\n\terr = 0;\n\twhile (index < (rp->rbr_table_size - blocks_per_page)) {\n\t\terr = niu_rbr_add_page(np, rp, mask, index);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\n\t\tindex += blocks_per_page;\n\t}\n\n\trp->rbr_index = index;\n\treturn err;\n}\n\nstatic void niu_rbr_free(struct niu *np, struct rx_ring_info *rp)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_RBR_RING_SIZE; i++) {\n\t\tstruct page *page;\n\n\t\tpage = rp->rxhash[i];\n\t\twhile (page) {\n\t\t\tstruct page *next = (struct page *) page->mapping;\n\t\t\tu64 base = page->index;\n\n\t\t\tnp->ops->unmap_page(np->device, base, PAGE_SIZE,\n\t\t\t\t\t    DMA_FROM_DEVICE);\n\t\t\tpage->index = 0;\n\t\t\tpage->mapping = NULL;\n\n\t\t\t__free_page(page);\n\n\t\t\tpage = next;\n\t\t}\n\t}\n\n\tfor (i = 0; i < rp->rbr_table_size; i++)\n\t\trp->rbr[i] = cpu_to_le32(0);\n\trp->rbr_index = 0;\n}\n\nstatic int release_tx_packet(struct niu *np, struct tx_ring_info *rp, int idx)\n{\n\tstruct tx_buff_info *tb = &rp->tx_buffs[idx];\n\tstruct sk_buff *skb = tb->skb;\n\tstruct tx_pkt_hdr *tp;\n\tu64 tx_flags;\n\tint i, len;\n\n\ttp = (struct tx_pkt_hdr *) skb->data;\n\ttx_flags = le64_to_cpup(&tp->flags);\n\n\trp->tx_packets++;\n\trp->tx_bytes += (((tx_flags & TXHDR_LEN) >> TXHDR_LEN_SHIFT) -\n\t\t\t ((tx_flags & TXHDR_PAD) / 2));\n\n\tlen = skb_headlen(skb);\n\tnp->ops->unmap_single(np->device, tb->mapping,\n\t\t\t      len, DMA_TO_DEVICE);\n\n\tif (le64_to_cpu(rp->descr[idx]) & TX_DESC_MARK)\n\t\trp->mark_pending--;\n\n\ttb->skb = NULL;\n\tdo {\n\t\tidx = NEXT_TX(rp, idx);\n\t\tlen -= MAX_TX_DESC_LEN;\n\t} while (len > 0);\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\ttb = &rp->tx_buffs[idx];\n\t\tBUG_ON(tb->skb != NULL);\n\t\tnp->ops->unmap_page(np->device, tb->mapping,\n\t\t\t\t    skb_frag_size(&skb_shinfo(skb)->frags[i]),\n\t\t\t\t    DMA_TO_DEVICE);\n\t\tidx = NEXT_TX(rp, idx);\n\t}\n\n\tdev_kfree_skb(skb);\n\n\treturn idx;\n}\n\n#define NIU_TX_WAKEUP_THRESH(rp)\t\t((rp)->pending / 4)\n\nstatic void niu_tx_work(struct niu *np, struct tx_ring_info *rp)\n{\n\tstruct netdev_queue *txq;\n\tu16 pkt_cnt, tmp;\n\tint cons, index;\n\tu64 cs;\n\n\tindex = (rp - np->tx_rings);\n\ttxq = netdev_get_tx_queue(np->dev, index);\n\n\tcs = rp->tx_cs;\n\tif (unlikely(!(cs & (TX_CS_MK | TX_CS_MMK))))\n\t\tgoto out;\n\n\ttmp = pkt_cnt = (cs & TX_CS_PKT_CNT) >> TX_CS_PKT_CNT_SHIFT;\n\tpkt_cnt = (pkt_cnt - rp->last_pkt_cnt) &\n\t\t(TX_CS_PKT_CNT >> TX_CS_PKT_CNT_SHIFT);\n\n\trp->last_pkt_cnt = tmp;\n\n\tcons = rp->cons;\n\n\tnetif_printk(np, tx_done, KERN_DEBUG, np->dev,\n\t\t     \"%s() pkt_cnt[%u] cons[%d]\\n\", __func__, pkt_cnt, cons);\n\n\twhile (pkt_cnt--)\n\t\tcons = release_tx_packet(np, rp, cons);\n\n\trp->cons = cons;\n\tsmp_mb();\n\nout:\n\tif (unlikely(netif_tx_queue_stopped(txq) &&\n\t\t     (niu_tx_avail(rp) > NIU_TX_WAKEUP_THRESH(rp)))) {\n\t\t__netif_tx_lock(txq, smp_processor_id());\n\t\tif (netif_tx_queue_stopped(txq) &&\n\t\t    (niu_tx_avail(rp) > NIU_TX_WAKEUP_THRESH(rp)))\n\t\t\tnetif_tx_wake_queue(txq);\n\t\t__netif_tx_unlock(txq);\n\t}\n}\n\nstatic inline void niu_sync_rx_discard_stats(struct niu *np,\n\t\t\t\t\t     struct rx_ring_info *rp,\n\t\t\t\t\t     const int limit)\n{\n\t/* This elaborate scheme is needed for reading the RX discard\n\t * counters, as they are only 16-bit and can overflow quickly,\n\t * and because the overflow indication bit is not usable as\n\t * the counter value does not wrap, but remains at max value\n\t * 0xFFFF.\n\t *\n\t * In theory and in practice counters can be lost in between\n\t * reading nr64() and clearing the counter nw64().  For this\n\t * reason, the number of counter clearings nw64() is\n\t * limited/reduced though the limit parameter.\n\t */\n\tint rx_channel = rp->rx_channel;\n\tu32 misc, wred;\n\n\t/* RXMISC (Receive Miscellaneous Discard Count), covers the\n\t * following discard events: IPP (Input Port Process),\n\t * FFLP/TCAM, Full RCR (Receive Completion Ring) RBR (Receive\n\t * Block Ring) prefetch buffer is empty.\n\t */\n\tmisc = nr64(RXMISC(rx_channel));\n\tif (unlikely((misc & RXMISC_COUNT) > limit)) {\n\t\tnw64(RXMISC(rx_channel), 0);\n\t\trp->rx_errors += misc & RXMISC_COUNT;\n\n\t\tif (unlikely(misc & RXMISC_OFLOW))\n\t\t\tdev_err(np->device, \"rx-%d: Counter overflow RXMISC discard\\n\",\n\t\t\t\trx_channel);\n\n\t\tnetif_printk(np, rx_err, KERN_DEBUG, np->dev,\n\t\t\t     \"rx-%d: MISC drop=%u over=%u\\n\",\n\t\t\t     rx_channel, misc, misc-limit);\n\t}\n\n\t/* WRED (Weighted Random Early Discard) by hardware */\n\twred = nr64(RED_DIS_CNT(rx_channel));\n\tif (unlikely((wred & RED_DIS_CNT_COUNT) > limit)) {\n\t\tnw64(RED_DIS_CNT(rx_channel), 0);\n\t\trp->rx_dropped += wred & RED_DIS_CNT_COUNT;\n\n\t\tif (unlikely(wred & RED_DIS_CNT_OFLOW))\n\t\t\tdev_err(np->device, \"rx-%d: Counter overflow WRED discard\\n\", rx_channel);\n\n\t\tnetif_printk(np, rx_err, KERN_DEBUG, np->dev,\n\t\t\t     \"rx-%d: WRED drop=%u over=%u\\n\",\n\t\t\t     rx_channel, wred, wred-limit);\n\t}\n}\n\nstatic int niu_rx_work(struct napi_struct *napi, struct niu *np,\n\t\t       struct rx_ring_info *rp, int budget)\n{\n\tint qlen, rcr_done = 0, work_done = 0;\n\tstruct rxdma_mailbox *mbox = rp->mbox;\n\tu64 stat;\n\n#if 1\n\tstat = nr64(RX_DMA_CTL_STAT(rp->rx_channel));\n\tqlen = nr64(RCRSTAT_A(rp->rx_channel)) & RCRSTAT_A_QLEN;\n#else\n\tstat = le64_to_cpup(&mbox->rx_dma_ctl_stat);\n\tqlen = (le64_to_cpup(&mbox->rcrstat_a) & RCRSTAT_A_QLEN);\n#endif\n\tmbox->rx_dma_ctl_stat = 0;\n\tmbox->rcrstat_a = 0;\n\n\tnetif_printk(np, rx_status, KERN_DEBUG, np->dev,\n\t\t     \"%s(chan[%d]), stat[%llx] qlen=%d\\n\",\n\t\t     __func__, rp->rx_channel, (unsigned long long)stat, qlen);\n\n\trcr_done = work_done = 0;\n\tqlen = min(qlen, budget);\n\twhile (work_done < qlen) {\n\t\trcr_done += niu_process_rx_pkt(napi, np, rp);\n\t\twork_done++;\n\t}\n\n\tif (rp->rbr_refill_pending >= rp->rbr_kick_thresh) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < rp->rbr_refill_pending; i++)\n\t\t\tniu_rbr_refill(np, rp, GFP_ATOMIC);\n\t\trp->rbr_refill_pending = 0;\n\t}\n\n\tstat = (RX_DMA_CTL_STAT_MEX |\n\t\t((u64)work_done << RX_DMA_CTL_STAT_PKTREAD_SHIFT) |\n\t\t((u64)rcr_done << RX_DMA_CTL_STAT_PTRREAD_SHIFT));\n\n\tnw64(RX_DMA_CTL_STAT(rp->rx_channel), stat);\n\n\t/* Only sync discards stats when qlen indicate potential for drops */\n\tif (qlen > 10)\n\t\tniu_sync_rx_discard_stats(np, rp, 0x7FFF);\n\n\treturn work_done;\n}\n\nstatic int niu_poll_core(struct niu *np, struct niu_ldg *lp, int budget)\n{\n\tu64 v0 = lp->v0;\n\tu32 tx_vec = (v0 >> 32);\n\tu32 rx_vec = (v0 & 0xffffffff);\n\tint i, work_done = 0;\n\n\tnetif_printk(np, intr, KERN_DEBUG, np->dev,\n\t\t     \"%s() v0[%016llx]\\n\", __func__, (unsigned long long)v0);\n\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\t\tif (tx_vec & (1 << rp->tx_channel))\n\t\t\tniu_tx_work(np, rp);\n\t\tnw64(LD_IM0(LDN_TXDMA(rp->tx_channel)), 0);\n\t}\n\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\tif (rx_vec & (1 << rp->rx_channel)) {\n\t\t\tint this_work_done;\n\n\t\t\tthis_work_done = niu_rx_work(&lp->napi, np, rp,\n\t\t\t\t\t\t     budget);\n\n\t\t\tbudget -= this_work_done;\n\t\t\twork_done += this_work_done;\n\t\t}\n\t\tnw64(LD_IM0(LDN_RXDMA(rp->rx_channel)), 0);\n\t}\n\n\treturn work_done;\n}\n\nstatic int niu_poll(struct napi_struct *napi, int budget)\n{\n\tstruct niu_ldg *lp = container_of(napi, struct niu_ldg, napi);\n\tstruct niu *np = lp->np;\n\tint work_done;\n\n\twork_done = niu_poll_core(np, lp, budget);\n\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\t\tniu_ldg_rearm(np, lp, 1);\n\t}\n\treturn work_done;\n}\n\nstatic void niu_log_rxchan_errors(struct niu *np, struct rx_ring_info *rp,\n\t\t\t\t  u64 stat)\n{\n\tnetdev_err(np->dev, \"RX channel %u errors ( \", rp->rx_channel);\n\n\tif (stat & RX_DMA_CTL_STAT_RBR_TMOUT)\n\t\tpr_cont(\"RBR_TMOUT \");\n\tif (stat & RX_DMA_CTL_STAT_RSP_CNT_ERR)\n\t\tpr_cont(\"RSP_CNT \");\n\tif (stat & RX_DMA_CTL_STAT_BYTE_EN_BUS)\n\t\tpr_cont(\"BYTE_EN_BUS \");\n\tif (stat & RX_DMA_CTL_STAT_RSP_DAT_ERR)\n\t\tpr_cont(\"RSP_DAT \");\n\tif (stat & RX_DMA_CTL_STAT_RCR_ACK_ERR)\n\t\tpr_cont(\"RCR_ACK \");\n\tif (stat & RX_DMA_CTL_STAT_RCR_SHA_PAR)\n\t\tpr_cont(\"RCR_SHA_PAR \");\n\tif (stat & RX_DMA_CTL_STAT_RBR_PRE_PAR)\n\t\tpr_cont(\"RBR_PRE_PAR \");\n\tif (stat & RX_DMA_CTL_STAT_CONFIG_ERR)\n\t\tpr_cont(\"CONFIG \");\n\tif (stat & RX_DMA_CTL_STAT_RCRINCON)\n\t\tpr_cont(\"RCRINCON \");\n\tif (stat & RX_DMA_CTL_STAT_RCRFULL)\n\t\tpr_cont(\"RCRFULL \");\n\tif (stat & RX_DMA_CTL_STAT_RBRFULL)\n\t\tpr_cont(\"RBRFULL \");\n\tif (stat & RX_DMA_CTL_STAT_RBRLOGPAGE)\n\t\tpr_cont(\"RBRLOGPAGE \");\n\tif (stat & RX_DMA_CTL_STAT_CFIGLOGPAGE)\n\t\tpr_cont(\"CFIGLOGPAGE \");\n\tif (stat & RX_DMA_CTL_STAT_DC_FIFO_ERR)\n\t\tpr_cont(\"DC_FIDO \");\n\n\tpr_cont(\")\\n\");\n}\n\nstatic int niu_rx_error(struct niu *np, struct rx_ring_info *rp)\n{\n\tu64 stat = nr64(RX_DMA_CTL_STAT(rp->rx_channel));\n\tint err = 0;\n\n\n\tif (stat & (RX_DMA_CTL_STAT_CHAN_FATAL |\n\t\t    RX_DMA_CTL_STAT_PORT_FATAL))\n\t\terr = -EINVAL;\n\n\tif (err) {\n\t\tnetdev_err(np->dev, \"RX channel %u error, stat[%llx]\\n\",\n\t\t\t   rp->rx_channel,\n\t\t\t   (unsigned long long) stat);\n\n\t\tniu_log_rxchan_errors(np, rp, stat);\n\t}\n\n\tnw64(RX_DMA_CTL_STAT(rp->rx_channel),\n\t     stat & RX_DMA_CTL_WRITE_CLEAR_ERRS);\n\n\treturn err;\n}\n\nstatic void niu_log_txchan_errors(struct niu *np, struct tx_ring_info *rp,\n\t\t\t\t  u64 cs)\n{\n\tnetdev_err(np->dev, \"TX channel %u errors ( \", rp->tx_channel);\n\n\tif (cs & TX_CS_MBOX_ERR)\n\t\tpr_cont(\"MBOX \");\n\tif (cs & TX_CS_PKT_SIZE_ERR)\n\t\tpr_cont(\"PKT_SIZE \");\n\tif (cs & TX_CS_TX_RING_OFLOW)\n\t\tpr_cont(\"TX_RING_OFLOW \");\n\tif (cs & TX_CS_PREF_BUF_PAR_ERR)\n\t\tpr_cont(\"PREF_BUF_PAR \");\n\tif (cs & TX_CS_NACK_PREF)\n\t\tpr_cont(\"NACK_PREF \");\n\tif (cs & TX_CS_NACK_PKT_RD)\n\t\tpr_cont(\"NACK_PKT_RD \");\n\tif (cs & TX_CS_CONF_PART_ERR)\n\t\tpr_cont(\"CONF_PART \");\n\tif (cs & TX_CS_PKT_PRT_ERR)\n\t\tpr_cont(\"PKT_PTR \");\n\n\tpr_cont(\")\\n\");\n}\n\nstatic int niu_tx_error(struct niu *np, struct tx_ring_info *rp)\n{\n\tu64 cs, logh, logl;\n\n\tcs = nr64(TX_CS(rp->tx_channel));\n\tlogh = nr64(TX_RNG_ERR_LOGH(rp->tx_channel));\n\tlogl = nr64(TX_RNG_ERR_LOGL(rp->tx_channel));\n\n\tnetdev_err(np->dev, \"TX channel %u error, cs[%llx] logh[%llx] logl[%llx]\\n\",\n\t\t   rp->tx_channel,\n\t\t   (unsigned long long)cs,\n\t\t   (unsigned long long)logh,\n\t\t   (unsigned long long)logl);\n\n\tniu_log_txchan_errors(np, rp, cs);\n\n\treturn -ENODEV;\n}\n\nstatic int niu_mif_interrupt(struct niu *np)\n{\n\tu64 mif_status = nr64(MIF_STATUS);\n\tint phy_mdint = 0;\n\n\tif (np->flags & NIU_FLAGS_XMAC) {\n\t\tu64 xrxmac_stat = nr64_mac(XRXMAC_STATUS);\n\n\t\tif (xrxmac_stat & XRXMAC_STATUS_PHY_MDINT)\n\t\t\tphy_mdint = 1;\n\t}\n\n\tnetdev_err(np->dev, \"MIF interrupt, stat[%llx] phy_mdint(%d)\\n\",\n\t\t   (unsigned long long)mif_status, phy_mdint);\n\n\treturn -ENODEV;\n}\n\nstatic void niu_xmac_interrupt(struct niu *np)\n{\n\tstruct niu_xmac_stats *mp = &np->mac_stats.xmac;\n\tu64 val;\n\n\tval = nr64_mac(XTXMAC_STATUS);\n\tif (val & XTXMAC_STATUS_FRAME_CNT_EXP)\n\t\tmp->tx_frames += TXMAC_FRM_CNT_COUNT;\n\tif (val & XTXMAC_STATUS_BYTE_CNT_EXP)\n\t\tmp->tx_bytes += TXMAC_BYTE_CNT_COUNT;\n\tif (val & XTXMAC_STATUS_TXFIFO_XFR_ERR)\n\t\tmp->tx_fifo_errors++;\n\tif (val & XTXMAC_STATUS_TXMAC_OFLOW)\n\t\tmp->tx_overflow_errors++;\n\tif (val & XTXMAC_STATUS_MAX_PSIZE_ERR)\n\t\tmp->tx_max_pkt_size_errors++;\n\tif (val & XTXMAC_STATUS_TXMAC_UFLOW)\n\t\tmp->tx_underflow_errors++;\n\n\tval = nr64_mac(XRXMAC_STATUS);\n\tif (val & XRXMAC_STATUS_LCL_FLT_STATUS)\n\t\tmp->rx_local_faults++;\n\tif (val & XRXMAC_STATUS_RFLT_DET)\n\t\tmp->rx_remote_faults++;\n\tif (val & XRXMAC_STATUS_LFLT_CNT_EXP)\n\t\tmp->rx_link_faults += LINK_FAULT_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_ALIGNERR_CNT_EXP)\n\t\tmp->rx_align_errors += RXMAC_ALIGN_ERR_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_RXFRAG_CNT_EXP)\n\t\tmp->rx_frags += RXMAC_FRAG_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_RXMULTF_CNT_EXP)\n\t\tmp->rx_mcasts += RXMAC_MC_FRM_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_RXBCAST_CNT_EXP)\n\t\tmp->rx_bcasts += RXMAC_BC_FRM_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_RXBCAST_CNT_EXP)\n\t\tmp->rx_bcasts += RXMAC_BC_FRM_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_RXHIST1_CNT_EXP)\n\t\tmp->rx_hist_cnt1 += RXMAC_HIST_CNT1_COUNT;\n\tif (val & XRXMAC_STATUS_RXHIST2_CNT_EXP)\n\t\tmp->rx_hist_cnt2 += RXMAC_HIST_CNT2_COUNT;\n\tif (val & XRXMAC_STATUS_RXHIST3_CNT_EXP)\n\t\tmp->rx_hist_cnt3 += RXMAC_HIST_CNT3_COUNT;\n\tif (val & XRXMAC_STATUS_RXHIST4_CNT_EXP)\n\t\tmp->rx_hist_cnt4 += RXMAC_HIST_CNT4_COUNT;\n\tif (val & XRXMAC_STATUS_RXHIST5_CNT_EXP)\n\t\tmp->rx_hist_cnt5 += RXMAC_HIST_CNT5_COUNT;\n\tif (val & XRXMAC_STATUS_RXHIST6_CNT_EXP)\n\t\tmp->rx_hist_cnt6 += RXMAC_HIST_CNT6_COUNT;\n\tif (val & XRXMAC_STATUS_RXHIST7_CNT_EXP)\n\t\tmp->rx_hist_cnt7 += RXMAC_HIST_CNT7_COUNT;\n\tif (val & XRXMAC_STATUS_RXOCTET_CNT_EXP)\n\t\tmp->rx_octets += RXMAC_BT_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_CVIOLERR_CNT_EXP)\n\t\tmp->rx_code_violations += RXMAC_CD_VIO_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_LENERR_CNT_EXP)\n\t\tmp->rx_len_errors += RXMAC_MPSZER_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_CRCERR_CNT_EXP)\n\t\tmp->rx_crc_errors += RXMAC_CRC_ER_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_RXUFLOW)\n\t\tmp->rx_underflows++;\n\tif (val & XRXMAC_STATUS_RXOFLOW)\n\t\tmp->rx_overflows++;\n\n\tval = nr64_mac(XMAC_FC_STAT);\n\tif (val & XMAC_FC_STAT_TX_MAC_NPAUSE)\n\t\tmp->pause_off_state++;\n\tif (val & XMAC_FC_STAT_TX_MAC_PAUSE)\n\t\tmp->pause_on_state++;\n\tif (val & XMAC_FC_STAT_RX_MAC_RPAUSE)\n\t\tmp->pause_received++;\n}\n\nstatic void niu_bmac_interrupt(struct niu *np)\n{\n\tstruct niu_bmac_stats *mp = &np->mac_stats.bmac;\n\tu64 val;\n\n\tval = nr64_mac(BTXMAC_STATUS);\n\tif (val & BTXMAC_STATUS_UNDERRUN)\n\t\tmp->tx_underflow_errors++;\n\tif (val & BTXMAC_STATUS_MAX_PKT_ERR)\n\t\tmp->tx_max_pkt_size_errors++;\n\tif (val & BTXMAC_STATUS_BYTE_CNT_EXP)\n\t\tmp->tx_bytes += BTXMAC_BYTE_CNT_COUNT;\n\tif (val & BTXMAC_STATUS_FRAME_CNT_EXP)\n\t\tmp->tx_frames += BTXMAC_FRM_CNT_COUNT;\n\n\tval = nr64_mac(BRXMAC_STATUS);\n\tif (val & BRXMAC_STATUS_OVERFLOW)\n\t\tmp->rx_overflows++;\n\tif (val & BRXMAC_STATUS_FRAME_CNT_EXP)\n\t\tmp->rx_frames += BRXMAC_FRAME_CNT_COUNT;\n\tif (val & BRXMAC_STATUS_ALIGN_ERR_EXP)\n\t\tmp->rx_align_errors += BRXMAC_ALIGN_ERR_CNT_COUNT;\n\tif (val & BRXMAC_STATUS_CRC_ERR_EXP)\n\t\tmp->rx_crc_errors += BRXMAC_ALIGN_ERR_CNT_COUNT;\n\tif (val & BRXMAC_STATUS_LEN_ERR_EXP)\n\t\tmp->rx_len_errors += BRXMAC_CODE_VIOL_ERR_CNT_COUNT;\n\n\tval = nr64_mac(BMAC_CTRL_STATUS);\n\tif (val & BMAC_CTRL_STATUS_NOPAUSE)\n\t\tmp->pause_off_state++;\n\tif (val & BMAC_CTRL_STATUS_PAUSE)\n\t\tmp->pause_on_state++;\n\tif (val & BMAC_CTRL_STATUS_PAUSE_RECV)\n\t\tmp->pause_received++;\n}\n\nstatic int niu_mac_interrupt(struct niu *np)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tniu_xmac_interrupt(np);\n\telse\n\t\tniu_bmac_interrupt(np);\n\n\treturn 0;\n}\n\nstatic void niu_log_device_error(struct niu *np, u64 stat)\n{\n\tnetdev_err(np->dev, \"Core device errors ( \");\n\n\tif (stat & SYS_ERR_MASK_META2)\n\t\tpr_cont(\"META2 \");\n\tif (stat & SYS_ERR_MASK_META1)\n\t\tpr_cont(\"META1 \");\n\tif (stat & SYS_ERR_MASK_PEU)\n\t\tpr_cont(\"PEU \");\n\tif (stat & SYS_ERR_MASK_TXC)\n\t\tpr_cont(\"TXC \");\n\tif (stat & SYS_ERR_MASK_RDMC)\n\t\tpr_cont(\"RDMC \");\n\tif (stat & SYS_ERR_MASK_TDMC)\n\t\tpr_cont(\"TDMC \");\n\tif (stat & SYS_ERR_MASK_ZCP)\n\t\tpr_cont(\"ZCP \");\n\tif (stat & SYS_ERR_MASK_FFLP)\n\t\tpr_cont(\"FFLP \");\n\tif (stat & SYS_ERR_MASK_IPP)\n\t\tpr_cont(\"IPP \");\n\tif (stat & SYS_ERR_MASK_MAC)\n\t\tpr_cont(\"MAC \");\n\tif (stat & SYS_ERR_MASK_SMX)\n\t\tpr_cont(\"SMX \");\n\n\tpr_cont(\")\\n\");\n}\n\nstatic int niu_device_error(struct niu *np)\n{\n\tu64 stat = nr64(SYS_ERR_STAT);\n\n\tnetdev_err(np->dev, \"Core device error, stat[%llx]\\n\",\n\t\t   (unsigned long long)stat);\n\n\tniu_log_device_error(np, stat);\n\n\treturn -ENODEV;\n}\n\nstatic int niu_slowpath_interrupt(struct niu *np, struct niu_ldg *lp,\n\t\t\t      u64 v0, u64 v1, u64 v2)\n{\n\n\tint i, err = 0;\n\n\tlp->v0 = v0;\n\tlp->v1 = v1;\n\tlp->v2 = v2;\n\n\tif (v1 & 0x00000000ffffffffULL) {\n\t\tu32 rx_vec = (v1 & 0xffffffff);\n\n\t\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\t\tif (rx_vec & (1 << rp->rx_channel)) {\n\t\t\t\tint r = niu_rx_error(np, rp);\n\t\t\t\tif (r) {\n\t\t\t\t\terr = r;\n\t\t\t\t} else {\n\t\t\t\t\tif (!v0)\n\t\t\t\t\t\tnw64(RX_DMA_CTL_STAT(rp->rx_channel),\n\t\t\t\t\t\t     RX_DMA_CTL_STAT_MEX);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (v1 & 0x7fffffff00000000ULL) {\n\t\tu32 tx_vec = (v1 >> 32) & 0x7fffffff;\n\n\t\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\n\t\t\tif (tx_vec & (1 << rp->tx_channel)) {\n\t\t\t\tint r = niu_tx_error(np, rp);\n\t\t\t\tif (r)\n\t\t\t\t\terr = r;\n\t\t\t}\n\t\t}\n\t}\n\tif ((v0 | v1) & 0x8000000000000000ULL) {\n\t\tint r = niu_mif_interrupt(np);\n\t\tif (r)\n\t\t\terr = r;\n\t}\n\tif (v2) {\n\t\tif (v2 & 0x01ef) {\n\t\t\tint r = niu_mac_interrupt(np);\n\t\t\tif (r)\n\t\t\t\terr = r;\n\t\t}\n\t\tif (v2 & 0x0210) {\n\t\t\tint r = niu_device_error(np);\n\t\t\tif (r)\n\t\t\t\terr = r;\n\t\t}\n\t}\n\n\tif (err)\n\t\tniu_enable_interrupts(np, 0);\n\n\treturn err;\n}\n\nstatic void niu_rxchan_intr(struct niu *np, struct rx_ring_info *rp,\n\t\t\t    int ldn)\n{\n\tstruct rxdma_mailbox *mbox = rp->mbox;\n\tu64 stat_write, stat = le64_to_cpup(&mbox->rx_dma_ctl_stat);\n\n\tstat_write = (RX_DMA_CTL_STAT_RCRTHRES |\n\t\t      RX_DMA_CTL_STAT_RCRTO);\n\tnw64(RX_DMA_CTL_STAT(rp->rx_channel), stat_write);\n\n\tnetif_printk(np, intr, KERN_DEBUG, np->dev,\n\t\t     \"%s() stat[%llx]\\n\", __func__, (unsigned long long)stat);\n}\n\nstatic void niu_txchan_intr(struct niu *np, struct tx_ring_info *rp,\n\t\t\t    int ldn)\n{\n\trp->tx_cs = nr64(TX_CS(rp->tx_channel));\n\n\tnetif_printk(np, intr, KERN_DEBUG, np->dev,\n\t\t     \"%s() cs[%llx]\\n\", __func__, (unsigned long long)rp->tx_cs);\n}\n\nstatic void __niu_fastpath_interrupt(struct niu *np, int ldg, u64 v0)\n{\n\tstruct niu_parent *parent = np->parent;\n\tu32 rx_vec, tx_vec;\n\tint i;\n\n\ttx_vec = (v0 >> 32);\n\trx_vec = (v0 & 0xffffffff);\n\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\t\tint ldn = LDN_RXDMA(rp->rx_channel);\n\n\t\tif (parent->ldg_map[ldn] != ldg)\n\t\t\tcontinue;\n\n\t\tnw64(LD_IM0(ldn), LD_IM0_MASK);\n\t\tif (rx_vec & (1 << rp->rx_channel))\n\t\t\tniu_rxchan_intr(np, rp, ldn);\n\t}\n\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\t\tint ldn = LDN_TXDMA(rp->tx_channel);\n\n\t\tif (parent->ldg_map[ldn] != ldg)\n\t\t\tcontinue;\n\n\t\tnw64(LD_IM0(ldn), LD_IM0_MASK);\n\t\tif (tx_vec & (1 << rp->tx_channel))\n\t\t\tniu_txchan_intr(np, rp, ldn);\n\t}\n}\n\nstatic void niu_schedule_napi(struct niu *np, struct niu_ldg *lp,\n\t\t\t      u64 v0, u64 v1, u64 v2)\n{\n\tif (likely(napi_schedule_prep(&lp->napi))) {\n\t\tlp->v0 = v0;\n\t\tlp->v1 = v1;\n\t\tlp->v2 = v2;\n\t\t__niu_fastpath_interrupt(np, lp->ldg_num, v0);\n\t\t__napi_schedule(&lp->napi);\n\t}\n}\n\nstatic irqreturn_t niu_interrupt(int irq, void *dev_id)\n{\n\tstruct niu_ldg *lp = dev_id;\n\tstruct niu *np = lp->np;\n\tint ldg = lp->ldg_num;\n\tunsigned long flags;\n\tu64 v0, v1, v2;\n\n\tif (netif_msg_intr(np))\n\t\tprintk(KERN_DEBUG KBUILD_MODNAME \": \" \"%s() ldg[%p](%d)\",\n\t\t       __func__, lp, ldg);\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\tv0 = nr64(LDSV0(ldg));\n\tv1 = nr64(LDSV1(ldg));\n\tv2 = nr64(LDSV2(ldg));\n\n\tif (netif_msg_intr(np))\n\t\tpr_cont(\" v0[%llx] v1[%llx] v2[%llx]\\n\",\n\t\t       (unsigned long long) v0,\n\t\t       (unsigned long long) v1,\n\t\t       (unsigned long long) v2);\n\n\tif (unlikely(!v0 && !v1 && !v2)) {\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (unlikely((v0 & ((u64)1 << LDN_MIF)) || v1 || v2)) {\n\t\tint err = niu_slowpath_interrupt(np, lp, v0, v1, v2);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tif (likely(v0 & ~((u64)1 << LDN_MIF)))\n\t\tniu_schedule_napi(np, lp, v0, v1, v2);\n\telse\n\t\tniu_ldg_rearm(np, lp, 1);\nout:\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void niu_free_rx_ring_info(struct niu *np, struct rx_ring_info *rp)\n{\n\tif (rp->mbox) {\n\t\tnp->ops->free_coherent(np->device,\n\t\t\t\t       sizeof(struct rxdma_mailbox),\n\t\t\t\t       rp->mbox, rp->mbox_dma);\n\t\trp->mbox = NULL;\n\t}\n\tif (rp->rcr) {\n\t\tnp->ops->free_coherent(np->device,\n\t\t\t\t       MAX_RCR_RING_SIZE * sizeof(__le64),\n\t\t\t\t       rp->rcr, rp->rcr_dma);\n\t\trp->rcr = NULL;\n\t\trp->rcr_table_size = 0;\n\t\trp->rcr_index = 0;\n\t}\n\tif (rp->rbr) {\n\t\tniu_rbr_free(np, rp);\n\n\t\tnp->ops->free_coherent(np->device,\n\t\t\t\t       MAX_RBR_RING_SIZE * sizeof(__le32),\n\t\t\t\t       rp->rbr, rp->rbr_dma);\n\t\trp->rbr = NULL;\n\t\trp->rbr_table_size = 0;\n\t\trp->rbr_index = 0;\n\t}\n\tkfree(rp->rxhash);\n\trp->rxhash = NULL;\n}\n\nstatic void niu_free_tx_ring_info(struct niu *np, struct tx_ring_info *rp)\n{\n\tif (rp->mbox) {\n\t\tnp->ops->free_coherent(np->device,\n\t\t\t\t       sizeof(struct txdma_mailbox),\n\t\t\t\t       rp->mbox, rp->mbox_dma);\n\t\trp->mbox = NULL;\n\t}\n\tif (rp->descr) {\n\t\tint i;\n\n\t\tfor (i = 0; i < MAX_TX_RING_SIZE; i++) {\n\t\t\tif (rp->tx_buffs[i].skb)\n\t\t\t\t(void) release_tx_packet(np, rp, i);\n\t\t}\n\n\t\tnp->ops->free_coherent(np->device,\n\t\t\t\t       MAX_TX_RING_SIZE * sizeof(__le64),\n\t\t\t\t       rp->descr, rp->descr_dma);\n\t\trp->descr = NULL;\n\t\trp->pending = 0;\n\t\trp->prod = 0;\n\t\trp->cons = 0;\n\t\trp->wrap_bit = 0;\n\t}\n}\n\nstatic void niu_free_channels(struct niu *np)\n{\n\tint i;\n\n\tif (np->rx_rings) {\n\t\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\t\tniu_free_rx_ring_info(np, rp);\n\t\t}\n\t\tkfree(np->rx_rings);\n\t\tnp->rx_rings = NULL;\n\t\tnp->num_rx_rings = 0;\n\t}\n\n\tif (np->tx_rings) {\n\t\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\n\t\t\tniu_free_tx_ring_info(np, rp);\n\t\t}\n\t\tkfree(np->tx_rings);\n\t\tnp->tx_rings = NULL;\n\t\tnp->num_tx_rings = 0;\n\t}\n}\n\nstatic int niu_alloc_rx_ring_info(struct niu *np,\n\t\t\t\t  struct rx_ring_info *rp)\n{\n\tBUILD_BUG_ON(sizeof(struct rxdma_mailbox) != 64);\n\n\trp->rxhash = kcalloc(MAX_RBR_RING_SIZE, sizeof(struct page *),\n\t\t\t     GFP_KERNEL);\n\tif (!rp->rxhash)\n\t\treturn -ENOMEM;\n\n\trp->mbox = np->ops->alloc_coherent(np->device,\n\t\t\t\t\t   sizeof(struct rxdma_mailbox),\n\t\t\t\t\t   &rp->mbox_dma, GFP_KERNEL);\n\tif (!rp->mbox)\n\t\treturn -ENOMEM;\n\tif ((unsigned long)rp->mbox & (64UL - 1)) {\n\t\tnetdev_err(np->dev, \"Coherent alloc gives misaligned RXDMA mailbox %p\\n\",\n\t\t\t   rp->mbox);\n\t\treturn -EINVAL;\n\t}\n\n\trp->rcr = np->ops->alloc_coherent(np->device,\n\t\t\t\t\t  MAX_RCR_RING_SIZE * sizeof(__le64),\n\t\t\t\t\t  &rp->rcr_dma, GFP_KERNEL);\n\tif (!rp->rcr)\n\t\treturn -ENOMEM;\n\tif ((unsigned long)rp->rcr & (64UL - 1)) {\n\t\tnetdev_err(np->dev, \"Coherent alloc gives misaligned RXDMA RCR table %p\\n\",\n\t\t\t   rp->rcr);\n\t\treturn -EINVAL;\n\t}\n\trp->rcr_table_size = MAX_RCR_RING_SIZE;\n\trp->rcr_index = 0;\n\n\trp->rbr = np->ops->alloc_coherent(np->device,\n\t\t\t\t\t  MAX_RBR_RING_SIZE * sizeof(__le32),\n\t\t\t\t\t  &rp->rbr_dma, GFP_KERNEL);\n\tif (!rp->rbr)\n\t\treturn -ENOMEM;\n\tif ((unsigned long)rp->rbr & (64UL - 1)) {\n\t\tnetdev_err(np->dev, \"Coherent alloc gives misaligned RXDMA RBR table %p\\n\",\n\t\t\t   rp->rbr);\n\t\treturn -EINVAL;\n\t}\n\trp->rbr_table_size = MAX_RBR_RING_SIZE;\n\trp->rbr_index = 0;\n\trp->rbr_pending = 0;\n\n\treturn 0;\n}\n\nstatic void niu_set_max_burst(struct niu *np, struct tx_ring_info *rp)\n{\n\tint mtu = np->dev->mtu;\n\n\t/* These values are recommended by the HW designers for fair\n\t * utilization of DRR amongst the rings.\n\t */\n\trp->max_burst = mtu + 32;\n\tif (rp->max_burst > 4096)\n\t\trp->max_burst = 4096;\n}\n\nstatic int niu_alloc_tx_ring_info(struct niu *np,\n\t\t\t\t  struct tx_ring_info *rp)\n{\n\tBUILD_BUG_ON(sizeof(struct txdma_mailbox) != 64);\n\n\trp->mbox = np->ops->alloc_coherent(np->device,\n\t\t\t\t\t   sizeof(struct txdma_mailbox),\n\t\t\t\t\t   &rp->mbox_dma, GFP_KERNEL);\n\tif (!rp->mbox)\n\t\treturn -ENOMEM;\n\tif ((unsigned long)rp->mbox & (64UL - 1)) {\n\t\tnetdev_err(np->dev, \"Coherent alloc gives misaligned TXDMA mailbox %p\\n\",\n\t\t\t   rp->mbox);\n\t\treturn -EINVAL;\n\t}\n\n\trp->descr = np->ops->alloc_coherent(np->device,\n\t\t\t\t\t    MAX_TX_RING_SIZE * sizeof(__le64),\n\t\t\t\t\t    &rp->descr_dma, GFP_KERNEL);\n\tif (!rp->descr)\n\t\treturn -ENOMEM;\n\tif ((unsigned long)rp->descr & (64UL - 1)) {\n\t\tnetdev_err(np->dev, \"Coherent alloc gives misaligned TXDMA descr table %p\\n\",\n\t\t\t   rp->descr);\n\t\treturn -EINVAL;\n\t}\n\n\trp->pending = MAX_TX_RING_SIZE;\n\trp->prod = 0;\n\trp->cons = 0;\n\trp->wrap_bit = 0;\n\n\t/* XXX make these configurable... XXX */\n\trp->mark_freq = rp->pending / 4;\n\n\tniu_set_max_burst(np, rp);\n\n\treturn 0;\n}\n\nstatic void niu_size_rbr(struct niu *np, struct rx_ring_info *rp)\n{\n\tu16 bss;\n\n\tbss = min(PAGE_SHIFT, 15);\n\n\trp->rbr_block_size = 1 << bss;\n\trp->rbr_blocks_per_page = 1 << (PAGE_SHIFT-bss);\n\n\trp->rbr_sizes[0] = 256;\n\trp->rbr_sizes[1] = 1024;\n\tif (np->dev->mtu > ETH_DATA_LEN) {\n\t\tswitch (PAGE_SIZE) {\n\t\tcase 4 * 1024:\n\t\t\trp->rbr_sizes[2] = 4096;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trp->rbr_sizes[2] = 8192;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\trp->rbr_sizes[2] = 2048;\n\t}\n\trp->rbr_sizes[3] = rp->rbr_block_size;\n}\n\nstatic int niu_alloc_channels(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tint first_rx_channel, first_tx_channel;\n\tint num_rx_rings, num_tx_rings;\n\tstruct rx_ring_info *rx_rings;\n\tstruct tx_ring_info *tx_rings;\n\tint i, port, err;\n\n\tport = np->port;\n\tfirst_rx_channel = first_tx_channel = 0;\n\tfor (i = 0; i < port; i++) {\n\t\tfirst_rx_channel += parent->rxchan_per_port[i];\n\t\tfirst_tx_channel += parent->txchan_per_port[i];\n\t}\n\n\tnum_rx_rings = parent->rxchan_per_port[port];\n\tnum_tx_rings = parent->txchan_per_port[port];\n\n\trx_rings = kcalloc(num_rx_rings, sizeof(struct rx_ring_info),\n\t\t\t   GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!rx_rings)\n\t\tgoto out_err;\n\n\tnp->num_rx_rings = num_rx_rings;\n\tsmp_wmb();\n\tnp->rx_rings = rx_rings;\n\n\tnetif_set_real_num_rx_queues(np->dev, num_rx_rings);\n\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\trp->np = np;\n\t\trp->rx_channel = first_rx_channel + i;\n\n\t\terr = niu_alloc_rx_ring_info(np, rp);\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tniu_size_rbr(np, rp);\n\n\t\t/* XXX better defaults, configurable, etc... XXX */\n\t\trp->nonsyn_window = 64;\n\t\trp->nonsyn_threshold = rp->rcr_table_size - 64;\n\t\trp->syn_window = 64;\n\t\trp->syn_threshold = rp->rcr_table_size - 64;\n\t\trp->rcr_pkt_threshold = 16;\n\t\trp->rcr_timeout = 8;\n\t\trp->rbr_kick_thresh = RBR_REFILL_MIN;\n\t\tif (rp->rbr_kick_thresh < rp->rbr_blocks_per_page)\n\t\t\trp->rbr_kick_thresh = rp->rbr_blocks_per_page;\n\n\t\terr = niu_rbr_fill(np, rp, GFP_KERNEL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\ttx_rings = kcalloc(num_tx_rings, sizeof(struct tx_ring_info),\n\t\t\t   GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!tx_rings)\n\t\tgoto out_err;\n\n\tnp->num_tx_rings = num_tx_rings;\n\tsmp_wmb();\n\tnp->tx_rings = tx_rings;\n\n\tnetif_set_real_num_tx_queues(np->dev, num_tx_rings);\n\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\n\t\trp->np = np;\n\t\trp->tx_channel = first_tx_channel + i;\n\n\t\terr = niu_alloc_tx_ring_info(np, rp);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\treturn 0;\n\nout_err:\n\tniu_free_channels(np);\n\treturn err;\n}\n\nstatic int niu_tx_cs_sng_poll(struct niu *np, int channel)\n{\n\tint limit = 1000;\n\n\twhile (--limit > 0) {\n\t\tu64 val = nr64(TX_CS(channel));\n\t\tif (val & TX_CS_SNG_STATE)\n\t\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nstatic int niu_tx_channel_stop(struct niu *np, int channel)\n{\n\tu64 val = nr64(TX_CS(channel));\n\n\tval |= TX_CS_STOP_N_GO;\n\tnw64(TX_CS(channel), val);\n\n\treturn niu_tx_cs_sng_poll(np, channel);\n}\n\nstatic int niu_tx_cs_reset_poll(struct niu *np, int channel)\n{\n\tint limit = 1000;\n\n\twhile (--limit > 0) {\n\t\tu64 val = nr64(TX_CS(channel));\n\t\tif (!(val & TX_CS_RST))\n\t\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nstatic int niu_tx_channel_reset(struct niu *np, int channel)\n{\n\tu64 val = nr64(TX_CS(channel));\n\tint err;\n\n\tval |= TX_CS_RST;\n\tnw64(TX_CS(channel), val);\n\n\terr = niu_tx_cs_reset_poll(np, channel);\n\tif (!err)\n\t\tnw64(TX_RING_KICK(channel), 0);\n\n\treturn err;\n}\n\nstatic int niu_tx_channel_lpage_init(struct niu *np, int channel)\n{\n\tu64 val;\n\n\tnw64(TX_LOG_MASK1(channel), 0);\n\tnw64(TX_LOG_VAL1(channel), 0);\n\tnw64(TX_LOG_MASK2(channel), 0);\n\tnw64(TX_LOG_VAL2(channel), 0);\n\tnw64(TX_LOG_PAGE_RELO1(channel), 0);\n\tnw64(TX_LOG_PAGE_RELO2(channel), 0);\n\tnw64(TX_LOG_PAGE_HDL(channel), 0);\n\n\tval  = (u64)np->port << TX_LOG_PAGE_VLD_FUNC_SHIFT;\n\tval |= (TX_LOG_PAGE_VLD_PAGE0 | TX_LOG_PAGE_VLD_PAGE1);\n\tnw64(TX_LOG_PAGE_VLD(channel), val);\n\n\t/* XXX TXDMA 32bit mode? XXX */\n\n\treturn 0;\n}\n\nstatic void niu_txc_enable_port(struct niu *np, int on)\n{\n\tunsigned long flags;\n\tu64 val, mask;\n\n\tniu_lock_parent(np, flags);\n\tval = nr64(TXC_CONTROL);\n\tmask = (u64)1 << np->port;\n\tif (on) {\n\t\tval |= TXC_CONTROL_ENABLE | mask;\n\t} else {\n\t\tval &= ~mask;\n\t\tif ((val & ~TXC_CONTROL_ENABLE) == 0)\n\t\t\tval &= ~TXC_CONTROL_ENABLE;\n\t}\n\tnw64(TXC_CONTROL, val);\n\tniu_unlock_parent(np, flags);\n}\n\nstatic void niu_txc_set_imask(struct niu *np, u64 imask)\n{\n\tunsigned long flags;\n\tu64 val;\n\n\tniu_lock_parent(np, flags);\n\tval = nr64(TXC_INT_MASK);\n\tval &= ~TXC_INT_MASK_VAL(np->port);\n\tval |= (imask << TXC_INT_MASK_VAL_SHIFT(np->port));\n\tniu_unlock_parent(np, flags);\n}\n\nstatic void niu_txc_port_dma_enable(struct niu *np, int on)\n{\n\tu64 val = 0;\n\n\tif (on) {\n\t\tint i;\n\n\t\tfor (i = 0; i < np->num_tx_rings; i++)\n\t\t\tval |= (1 << np->tx_rings[i].tx_channel);\n\t}\n\tnw64(TXC_PORT_DMA(np->port), val);\n}\n\nstatic int niu_init_one_tx_channel(struct niu *np, struct tx_ring_info *rp)\n{\n\tint err, channel = rp->tx_channel;\n\tu64 val, ring_len;\n\n\terr = niu_tx_channel_stop(np, channel);\n\tif (err)\n\t\treturn err;\n\n\terr = niu_tx_channel_reset(np, channel);\n\tif (err)\n\t\treturn err;\n\n\terr = niu_tx_channel_lpage_init(np, channel);\n\tif (err)\n\t\treturn err;\n\n\tnw64(TXC_DMA_MAX(channel), rp->max_burst);\n\tnw64(TX_ENT_MSK(channel), 0);\n\n\tif (rp->descr_dma & ~(TX_RNG_CFIG_STADDR_BASE |\n\t\t\t      TX_RNG_CFIG_STADDR)) {\n\t\tnetdev_err(np->dev, \"TX ring channel %d DMA addr (%llx) is not aligned\\n\",\n\t\t\t   channel, (unsigned long long)rp->descr_dma);\n\t\treturn -EINVAL;\n\t}\n\n\t/* The length field in TX_RNG_CFIG is measured in 64-byte\n\t * blocks.  rp->pending is the number of TX descriptors in\n\t * our ring, 8 bytes each, thus we divide by 8 bytes more\n\t * to get the proper value the chip wants.\n\t */\n\tring_len = (rp->pending / 8);\n\n\tval = ((ring_len << TX_RNG_CFIG_LEN_SHIFT) |\n\t       rp->descr_dma);\n\tnw64(TX_RNG_CFIG(channel), val);\n\n\tif (((rp->mbox_dma >> 32) & ~TXDMA_MBH_MBADDR) ||\n\t    ((u32)rp->mbox_dma & ~TXDMA_MBL_MBADDR)) {\n\t\tnetdev_err(np->dev, \"TX ring channel %d MBOX addr (%llx) has invalid bits\\n\",\n\t\t\t    channel, (unsigned long long)rp->mbox_dma);\n\t\treturn -EINVAL;\n\t}\n\tnw64(TXDMA_MBH(channel), rp->mbox_dma >> 32);\n\tnw64(TXDMA_MBL(channel), rp->mbox_dma & TXDMA_MBL_MBADDR);\n\n\tnw64(TX_CS(channel), 0);\n\n\trp->last_pkt_cnt = 0;\n\n\treturn 0;\n}\n\nstatic void niu_init_rdc_groups(struct niu *np)\n{\n\tstruct niu_rdc_tables *tp = &np->parent->rdc_group_cfg[np->port];\n\tint i, first_table_num = tp->first_table_num;\n\n\tfor (i = 0; i < tp->num_tables; i++) {\n\t\tstruct rdc_table *tbl = &tp->tables[i];\n\t\tint this_table = first_table_num + i;\n\t\tint slot;\n\n\t\tfor (slot = 0; slot < NIU_RDC_TABLE_SLOTS; slot++)\n\t\t\tnw64(RDC_TBL(this_table, slot),\n\t\t\t     tbl->rxdma_channel[slot]);\n\t}\n\n\tnw64(DEF_RDC(np->port), np->parent->rdc_default[np->port]);\n}\n\nstatic void niu_init_drr_weight(struct niu *np)\n{\n\tint type = phy_decode(np->parent->port_phy, np->port);\n\tu64 val;\n\n\tswitch (type) {\n\tcase PORT_TYPE_10G:\n\t\tval = PT_DRR_WEIGHT_DEFAULT_10G;\n\t\tbreak;\n\n\tcase PORT_TYPE_1G:\n\tdefault:\n\t\tval = PT_DRR_WEIGHT_DEFAULT_1G;\n\t\tbreak;\n\t}\n\tnw64(PT_DRR_WT(np->port), val);\n}\n\nstatic int niu_init_hostinfo(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_rdc_tables *tp = &parent->rdc_group_cfg[np->port];\n\tint i, err, num_alt = niu_num_alt_addr(np);\n\tint first_rdc_table = tp->first_table_num;\n\n\terr = niu_set_primary_mac_rdc_table(np, first_rdc_table, 1);\n\tif (err)\n\t\treturn err;\n\n\terr = niu_set_multicast_mac_rdc_table(np, first_rdc_table, 1);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < num_alt; i++) {\n\t\terr = niu_set_alt_mac_rdc_table(np, i, first_rdc_table, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_rx_channel_reset(struct niu *np, int channel)\n{\n\treturn niu_set_and_wait_clear(np, RXDMA_CFIG1(channel),\n\t\t\t\t      RXDMA_CFIG1_RST, 1000, 10,\n\t\t\t\t      \"RXDMA_CFIG1\");\n}\n\nstatic int niu_rx_channel_lpage_init(struct niu *np, int channel)\n{\n\tu64 val;\n\n\tnw64(RX_LOG_MASK1(channel), 0);\n\tnw64(RX_LOG_VAL1(channel), 0);\n\tnw64(RX_LOG_MASK2(channel), 0);\n\tnw64(RX_LOG_VAL2(channel), 0);\n\tnw64(RX_LOG_PAGE_RELO1(channel), 0);\n\tnw64(RX_LOG_PAGE_RELO2(channel), 0);\n\tnw64(RX_LOG_PAGE_HDL(channel), 0);\n\n\tval  = (u64)np->port << RX_LOG_PAGE_VLD_FUNC_SHIFT;\n\tval |= (RX_LOG_PAGE_VLD_PAGE0 | RX_LOG_PAGE_VLD_PAGE1);\n\tnw64(RX_LOG_PAGE_VLD(channel), val);\n\n\treturn 0;\n}\n\nstatic void niu_rx_channel_wred_init(struct niu *np, struct rx_ring_info *rp)\n{\n\tu64 val;\n\n\tval = (((u64)rp->nonsyn_window << RDC_RED_PARA_WIN_SHIFT) |\n\t       ((u64)rp->nonsyn_threshold << RDC_RED_PARA_THRE_SHIFT) |\n\t       ((u64)rp->syn_window << RDC_RED_PARA_WIN_SYN_SHIFT) |\n\t       ((u64)rp->syn_threshold << RDC_RED_PARA_THRE_SYN_SHIFT));\n\tnw64(RDC_RED_PARA(rp->rx_channel), val);\n}\n\nstatic int niu_compute_rbr_cfig_b(struct rx_ring_info *rp, u64 *ret)\n{\n\tu64 val = 0;\n\n\t*ret = 0;\n\tswitch (rp->rbr_block_size) {\n\tcase 4 * 1024:\n\t\tval |= (RBR_BLKSIZE_4K << RBR_CFIG_B_BLKSIZE_SHIFT);\n\t\tbreak;\n\tcase 8 * 1024:\n\t\tval |= (RBR_BLKSIZE_8K << RBR_CFIG_B_BLKSIZE_SHIFT);\n\t\tbreak;\n\tcase 16 * 1024:\n\t\tval |= (RBR_BLKSIZE_16K << RBR_CFIG_B_BLKSIZE_SHIFT);\n\t\tbreak;\n\tcase 32 * 1024:\n\t\tval |= (RBR_BLKSIZE_32K << RBR_CFIG_B_BLKSIZE_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tval |= RBR_CFIG_B_VLD2;\n\tswitch (rp->rbr_sizes[2]) {\n\tcase 2 * 1024:\n\t\tval |= (RBR_BUFSZ2_2K << RBR_CFIG_B_BUFSZ2_SHIFT);\n\t\tbreak;\n\tcase 4 * 1024:\n\t\tval |= (RBR_BUFSZ2_4K << RBR_CFIG_B_BUFSZ2_SHIFT);\n\t\tbreak;\n\tcase 8 * 1024:\n\t\tval |= (RBR_BUFSZ2_8K << RBR_CFIG_B_BUFSZ2_SHIFT);\n\t\tbreak;\n\tcase 16 * 1024:\n\t\tval |= (RBR_BUFSZ2_16K << RBR_CFIG_B_BUFSZ2_SHIFT);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tval |= RBR_CFIG_B_VLD1;\n\tswitch (rp->rbr_sizes[1]) {\n\tcase 1 * 1024:\n\t\tval |= (RBR_BUFSZ1_1K << RBR_CFIG_B_BUFSZ1_SHIFT);\n\t\tbreak;\n\tcase 2 * 1024:\n\t\tval |= (RBR_BUFSZ1_2K << RBR_CFIG_B_BUFSZ1_SHIFT);\n\t\tbreak;\n\tcase 4 * 1024:\n\t\tval |= (RBR_BUFSZ1_4K << RBR_CFIG_B_BUFSZ1_SHIFT);\n\t\tbreak;\n\tcase 8 * 1024:\n\t\tval |= (RBR_BUFSZ1_8K << RBR_CFIG_B_BUFSZ1_SHIFT);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tval |= RBR_CFIG_B_VLD0;\n\tswitch (rp->rbr_sizes[0]) {\n\tcase 256:\n\t\tval |= (RBR_BUFSZ0_256 << RBR_CFIG_B_BUFSZ0_SHIFT);\n\t\tbreak;\n\tcase 512:\n\t\tval |= (RBR_BUFSZ0_512 << RBR_CFIG_B_BUFSZ0_SHIFT);\n\t\tbreak;\n\tcase 1 * 1024:\n\t\tval |= (RBR_BUFSZ0_1K << RBR_CFIG_B_BUFSZ0_SHIFT);\n\t\tbreak;\n\tcase 2 * 1024:\n\t\tval |= (RBR_BUFSZ0_2K << RBR_CFIG_B_BUFSZ0_SHIFT);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*ret = val;\n\treturn 0;\n}\n\nstatic int niu_enable_rx_channel(struct niu *np, int channel, int on)\n{\n\tu64 val = nr64(RXDMA_CFIG1(channel));\n\tint limit;\n\n\tif (on)\n\t\tval |= RXDMA_CFIG1_EN;\n\telse\n\t\tval &= ~RXDMA_CFIG1_EN;\n\tnw64(RXDMA_CFIG1(channel), val);\n\n\tlimit = 1000;\n\twhile (--limit > 0) {\n\t\tif (nr64(RXDMA_CFIG1(channel)) & RXDMA_CFIG1_QST)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tif (limit <= 0)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int niu_init_one_rx_channel(struct niu *np, struct rx_ring_info *rp)\n{\n\tint err, channel = rp->rx_channel;\n\tu64 val;\n\n\terr = niu_rx_channel_reset(np, channel);\n\tif (err)\n\t\treturn err;\n\n\terr = niu_rx_channel_lpage_init(np, channel);\n\tif (err)\n\t\treturn err;\n\n\tniu_rx_channel_wred_init(np, rp);\n\n\tnw64(RX_DMA_ENT_MSK(channel), RX_DMA_ENT_MSK_RBR_EMPTY);\n\tnw64(RX_DMA_CTL_STAT(channel),\n\t     (RX_DMA_CTL_STAT_MEX |\n\t      RX_DMA_CTL_STAT_RCRTHRES |\n\t      RX_DMA_CTL_STAT_RCRTO |\n\t      RX_DMA_CTL_STAT_RBR_EMPTY));\n\tnw64(RXDMA_CFIG1(channel), rp->mbox_dma >> 32);\n\tnw64(RXDMA_CFIG2(channel),\n\t     ((rp->mbox_dma & RXDMA_CFIG2_MBADDR_L) |\n\t      RXDMA_CFIG2_FULL_HDR));\n\tnw64(RBR_CFIG_A(channel),\n\t     ((u64)rp->rbr_table_size << RBR_CFIG_A_LEN_SHIFT) |\n\t     (rp->rbr_dma & (RBR_CFIG_A_STADDR_BASE | RBR_CFIG_A_STADDR)));\n\terr = niu_compute_rbr_cfig_b(rp, &val);\n\tif (err)\n\t\treturn err;\n\tnw64(RBR_CFIG_B(channel), val);\n\tnw64(RCRCFIG_A(channel),\n\t     ((u64)rp->rcr_table_size << RCRCFIG_A_LEN_SHIFT) |\n\t     (rp->rcr_dma & (RCRCFIG_A_STADDR_BASE | RCRCFIG_A_STADDR)));\n\tnw64(RCRCFIG_B(channel),\n\t     ((u64)rp->rcr_pkt_threshold << RCRCFIG_B_PTHRES_SHIFT) |\n\t     RCRCFIG_B_ENTOUT |\n\t     ((u64)rp->rcr_timeout << RCRCFIG_B_TIMEOUT_SHIFT));\n\n\terr = niu_enable_rx_channel(np, channel, 1);\n\tif (err)\n\t\treturn err;\n\n\tnw64(RBR_KICK(channel), rp->rbr_index);\n\n\tval = nr64(RX_DMA_CTL_STAT(channel));\n\tval |= RX_DMA_CTL_STAT_RBR_EMPTY;\n\tnw64(RX_DMA_CTL_STAT(channel), val);\n\n\treturn 0;\n}\n\nstatic int niu_init_rx_channels(struct niu *np)\n{\n\tunsigned long flags;\n\tu64 seed = jiffies_64;\n\tint err, i;\n\n\tniu_lock_parent(np, flags);\n\tnw64(RX_DMA_CK_DIV, np->parent->rxdma_clock_divider);\n\tnw64(RED_RAN_INIT, RED_RAN_INIT_OPMODE | (seed & RED_RAN_INIT_VAL));\n\tniu_unlock_parent(np, flags);\n\n\t/* XXX RXDMA 32bit mode? XXX */\n\n\tniu_init_rdc_groups(np);\n\tniu_init_drr_weight(np);\n\n\terr = niu_init_hostinfo(np);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\terr = niu_init_one_rx_channel(np, rp);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_set_ip_frag_rule(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_classifier *cp = &np->clas;\n\tstruct niu_tcam_entry *tp;\n\tint index, err;\n\n\tindex = cp->tcam_top;\n\ttp = &parent->tcam[index];\n\n\t/* Note that the noport bit is the same in both ipv4 and\n\t * ipv6 format TCAM entries.\n\t */\n\tmemset(tp, 0, sizeof(*tp));\n\ttp->key[1] = TCAM_V4KEY1_NOPORT;\n\ttp->key_mask[1] = TCAM_V4KEY1_NOPORT;\n\ttp->assoc_data = (TCAM_ASSOCDATA_TRES_USE_OFFSET |\n\t\t\t  ((u64)0 << TCAM_ASSOCDATA_OFFSET_SHIFT));\n\terr = tcam_write(np, index, tp->key, tp->key_mask);\n\tif (err)\n\t\treturn err;\n\terr = tcam_assoc_write(np, index, tp->assoc_data);\n\tif (err)\n\t\treturn err;\n\ttp->valid = 1;\n\tcp->tcam_valid_entries++;\n\n\treturn 0;\n}\n\nstatic int niu_init_classifier_hw(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_classifier *cp = &np->clas;\n\tint i, err;\n\n\tnw64(H1POLY, cp->h1_init);\n\tnw64(H2POLY, cp->h2_init);\n\n\terr = niu_init_hostinfo(np);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < ENET_VLAN_TBL_NUM_ENTRIES; i++) {\n\t\tstruct niu_vlan_rdc *vp = &cp->vlan_mappings[i];\n\n\t\tvlan_tbl_write(np, i, np->port,\n\t\t\t       vp->vlan_pref, vp->rdc_num);\n\t}\n\n\tfor (i = 0; i < cp->num_alt_mac_mappings; i++) {\n\t\tstruct niu_altmac_rdc *ap = &cp->alt_mac_mappings[i];\n\n\t\terr = niu_set_alt_mac_rdc_table(np, ap->alt_mac_num,\n\t\t\t\t\t\tap->rdc_num, ap->mac_pref);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = CLASS_CODE_USER_PROG1; i <= CLASS_CODE_SCTP_IPV6; i++) {\n\t\tint index = i - CLASS_CODE_USER_PROG1;\n\n\t\terr = niu_set_tcam_key(np, i, parent->tcam_key[index]);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = niu_set_flow_key(np, i, parent->flow_key[index]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = niu_set_ip_frag_rule(np);\n\tif (err)\n\t\treturn err;\n\n\ttcam_enable(np, 1);\n\n\treturn 0;\n}\n\nstatic int niu_zcp_write(struct niu *np, int index, u64 *data)\n{\n\tnw64(ZCP_RAM_DATA0, data[0]);\n\tnw64(ZCP_RAM_DATA1, data[1]);\n\tnw64(ZCP_RAM_DATA2, data[2]);\n\tnw64(ZCP_RAM_DATA3, data[3]);\n\tnw64(ZCP_RAM_DATA4, data[4]);\n\tnw64(ZCP_RAM_BE, ZCP_RAM_BE_VAL);\n\tnw64(ZCP_RAM_ACC,\n\t     (ZCP_RAM_ACC_WRITE |\n\t      (0 << ZCP_RAM_ACC_ZFCID_SHIFT) |\n\t      (ZCP_RAM_SEL_CFIFO(np->port) << ZCP_RAM_ACC_RAM_SEL_SHIFT)));\n\n\treturn niu_wait_bits_clear(np, ZCP_RAM_ACC, ZCP_RAM_ACC_BUSY,\n\t\t\t\t   1000, 100);\n}\n\nstatic int niu_zcp_read(struct niu *np, int index, u64 *data)\n{\n\tint err;\n\n\terr = niu_wait_bits_clear(np, ZCP_RAM_ACC, ZCP_RAM_ACC_BUSY,\n\t\t\t\t  1000, 100);\n\tif (err) {\n\t\tnetdev_err(np->dev, \"ZCP read busy won't clear, ZCP_RAM_ACC[%llx]\\n\",\n\t\t\t   (unsigned long long)nr64(ZCP_RAM_ACC));\n\t\treturn err;\n\t}\n\n\tnw64(ZCP_RAM_ACC,\n\t     (ZCP_RAM_ACC_READ |\n\t      (0 << ZCP_RAM_ACC_ZFCID_SHIFT) |\n\t      (ZCP_RAM_SEL_CFIFO(np->port) << ZCP_RAM_ACC_RAM_SEL_SHIFT)));\n\n\terr = niu_wait_bits_clear(np, ZCP_RAM_ACC, ZCP_RAM_ACC_BUSY,\n\t\t\t\t  1000, 100);\n\tif (err) {\n\t\tnetdev_err(np->dev, \"ZCP read busy2 won't clear, ZCP_RAM_ACC[%llx]\\n\",\n\t\t\t   (unsigned long long)nr64(ZCP_RAM_ACC));\n\t\treturn err;\n\t}\n\n\tdata[0] = nr64(ZCP_RAM_DATA0);\n\tdata[1] = nr64(ZCP_RAM_DATA1);\n\tdata[2] = nr64(ZCP_RAM_DATA2);\n\tdata[3] = nr64(ZCP_RAM_DATA3);\n\tdata[4] = nr64(ZCP_RAM_DATA4);\n\n\treturn 0;\n}\n\nstatic void niu_zcp_cfifo_reset(struct niu *np)\n{\n\tu64 val = nr64(RESET_CFIFO);\n\n\tval |= RESET_CFIFO_RST(np->port);\n\tnw64(RESET_CFIFO, val);\n\tudelay(10);\n\n\tval &= ~RESET_CFIFO_RST(np->port);\n\tnw64(RESET_CFIFO, val);\n}\n\nstatic int niu_init_zcp(struct niu *np)\n{\n\tu64 data[5], rbuf[5];\n\tint i, max, err;\n\n\tif (np->parent->plat_type != PLAT_TYPE_NIU) {\n\t\tif (np->port == 0 || np->port == 1)\n\t\t\tmax = ATLAS_P0_P1_CFIFO_ENTRIES;\n\t\telse\n\t\t\tmax = ATLAS_P2_P3_CFIFO_ENTRIES;\n\t} else\n\t\tmax = NIU_CFIFO_ENTRIES;\n\n\tdata[0] = 0;\n\tdata[1] = 0;\n\tdata[2] = 0;\n\tdata[3] = 0;\n\tdata[4] = 0;\n\n\tfor (i = 0; i < max; i++) {\n\t\terr = niu_zcp_write(np, i, data);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = niu_zcp_read(np, i, rbuf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tniu_zcp_cfifo_reset(np);\n\tnw64(CFIFO_ECC(np->port), 0);\n\tnw64(ZCP_INT_STAT, ZCP_INT_STAT_ALL);\n\t(void) nr64(ZCP_INT_STAT);\n\tnw64(ZCP_INT_MASK, ZCP_INT_MASK_ALL);\n\n\treturn 0;\n}\n\nstatic void niu_ipp_write(struct niu *np, int index, u64 *data)\n{\n\tu64 val = nr64_ipp(IPP_CFIG);\n\n\tnw64_ipp(IPP_CFIG, val | IPP_CFIG_DFIFO_PIO_W);\n\tnw64_ipp(IPP_DFIFO_WR_PTR, index);\n\tnw64_ipp(IPP_DFIFO_WR0, data[0]);\n\tnw64_ipp(IPP_DFIFO_WR1, data[1]);\n\tnw64_ipp(IPP_DFIFO_WR2, data[2]);\n\tnw64_ipp(IPP_DFIFO_WR3, data[3]);\n\tnw64_ipp(IPP_DFIFO_WR4, data[4]);\n\tnw64_ipp(IPP_CFIG, val & ~IPP_CFIG_DFIFO_PIO_W);\n}\n\nstatic void niu_ipp_read(struct niu *np, int index, u64 *data)\n{\n\tnw64_ipp(IPP_DFIFO_RD_PTR, index);\n\tdata[0] = nr64_ipp(IPP_DFIFO_RD0);\n\tdata[1] = nr64_ipp(IPP_DFIFO_RD1);\n\tdata[2] = nr64_ipp(IPP_DFIFO_RD2);\n\tdata[3] = nr64_ipp(IPP_DFIFO_RD3);\n\tdata[4] = nr64_ipp(IPP_DFIFO_RD4);\n}\n\nstatic int niu_ipp_reset(struct niu *np)\n{\n\treturn niu_set_and_wait_clear_ipp(np, IPP_CFIG, IPP_CFIG_SOFT_RST,\n\t\t\t\t\t  1000, 100, \"IPP_CFIG\");\n}\n\nstatic int niu_init_ipp(struct niu *np)\n{\n\tu64 data[5], rbuf[5], val;\n\tint i, max, err;\n\n\tif (np->parent->plat_type != PLAT_TYPE_NIU) {\n\t\tif (np->port == 0 || np->port == 1)\n\t\t\tmax = ATLAS_P0_P1_DFIFO_ENTRIES;\n\t\telse\n\t\t\tmax = ATLAS_P2_P3_DFIFO_ENTRIES;\n\t} else\n\t\tmax = NIU_DFIFO_ENTRIES;\n\n\tdata[0] = 0;\n\tdata[1] = 0;\n\tdata[2] = 0;\n\tdata[3] = 0;\n\tdata[4] = 0;\n\n\tfor (i = 0; i < max; i++) {\n\t\tniu_ipp_write(np, i, data);\n\t\tniu_ipp_read(np, i, rbuf);\n\t}\n\n\t(void) nr64_ipp(IPP_INT_STAT);\n\t(void) nr64_ipp(IPP_INT_STAT);\n\n\terr = niu_ipp_reset(np);\n\tif (err)\n\t\treturn err;\n\n\t(void) nr64_ipp(IPP_PKT_DIS);\n\t(void) nr64_ipp(IPP_BAD_CS_CNT);\n\t(void) nr64_ipp(IPP_ECC);\n\n\t(void) nr64_ipp(IPP_INT_STAT);\n\n\tnw64_ipp(IPP_MSK, ~IPP_MSK_ALL);\n\n\tval = nr64_ipp(IPP_CFIG);\n\tval &= ~IPP_CFIG_IP_MAX_PKT;\n\tval |= (IPP_CFIG_IPP_ENABLE |\n\t\tIPP_CFIG_DFIFO_ECC_EN |\n\t\tIPP_CFIG_DROP_BAD_CRC |\n\t\tIPP_CFIG_CKSUM_EN |\n\t\t(0x1ffff << IPP_CFIG_IP_MAX_PKT_SHIFT));\n\tnw64_ipp(IPP_CFIG, val);\n\n\treturn 0;\n}\n\nstatic void niu_handle_led(struct niu *np, int status)\n{\n\tu64 val;\n\tval = nr64_mac(XMAC_CONFIG);\n\n\tif ((np->flags & NIU_FLAGS_10G) != 0 &&\n\t    (np->flags & NIU_FLAGS_FIBER) != 0) {\n\t\tif (status) {\n\t\t\tval |= XMAC_CONFIG_LED_POLARITY;\n\t\t\tval &= ~XMAC_CONFIG_FORCE_LED_ON;\n\t\t} else {\n\t\t\tval |= XMAC_CONFIG_FORCE_LED_ON;\n\t\t\tval &= ~XMAC_CONFIG_LED_POLARITY;\n\t\t}\n\t}\n\n\tnw64_mac(XMAC_CONFIG, val);\n}\n\nstatic void niu_init_xif_xmac(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tu64 val;\n\n\tif (np->flags & NIU_FLAGS_XCVR_SERDES) {\n\t\tval = nr64(MIF_CONFIG);\n\t\tval |= MIF_CONFIG_ATCA_GE;\n\t\tnw64(MIF_CONFIG, val);\n\t}\n\n\tval = nr64_mac(XMAC_CONFIG);\n\tval &= ~XMAC_CONFIG_SEL_POR_CLK_SRC;\n\n\tval |= XMAC_CONFIG_TX_OUTPUT_EN;\n\n\tif (lp->loopback_mode == LOOPBACK_MAC) {\n\t\tval &= ~XMAC_CONFIG_SEL_POR_CLK_SRC;\n\t\tval |= XMAC_CONFIG_LOOPBACK;\n\t} else {\n\t\tval &= ~XMAC_CONFIG_LOOPBACK;\n\t}\n\n\tif (np->flags & NIU_FLAGS_10G) {\n\t\tval &= ~XMAC_CONFIG_LFS_DISABLE;\n\t} else {\n\t\tval |= XMAC_CONFIG_LFS_DISABLE;\n\t\tif (!(np->flags & NIU_FLAGS_FIBER) &&\n\t\t    !(np->flags & NIU_FLAGS_XCVR_SERDES))\n\t\t\tval |= XMAC_CONFIG_1G_PCS_BYPASS;\n\t\telse\n\t\t\tval &= ~XMAC_CONFIG_1G_PCS_BYPASS;\n\t}\n\n\tval &= ~XMAC_CONFIG_10G_XPCS_BYPASS;\n\n\tif (lp->active_speed == SPEED_100)\n\t\tval |= XMAC_CONFIG_SEL_CLK_25MHZ;\n\telse\n\t\tval &= ~XMAC_CONFIG_SEL_CLK_25MHZ;\n\n\tnw64_mac(XMAC_CONFIG, val);\n\n\tval = nr64_mac(XMAC_CONFIG);\n\tval &= ~XMAC_CONFIG_MODE_MASK;\n\tif (np->flags & NIU_FLAGS_10G) {\n\t\tval |= XMAC_CONFIG_MODE_XGMII;\n\t} else {\n\t\tif (lp->active_speed == SPEED_1000)\n\t\t\tval |= XMAC_CONFIG_MODE_GMII;\n\t\telse\n\t\t\tval |= XMAC_CONFIG_MODE_MII;\n\t}\n\n\tnw64_mac(XMAC_CONFIG, val);\n}\n\nstatic void niu_init_xif_bmac(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tu64 val;\n\n\tval = BMAC_XIF_CONFIG_TX_OUTPUT_EN;\n\n\tif (lp->loopback_mode == LOOPBACK_MAC)\n\t\tval |= BMAC_XIF_CONFIG_MII_LOOPBACK;\n\telse\n\t\tval &= ~BMAC_XIF_CONFIG_MII_LOOPBACK;\n\n\tif (lp->active_speed == SPEED_1000)\n\t\tval |= BMAC_XIF_CONFIG_GMII_MODE;\n\telse\n\t\tval &= ~BMAC_XIF_CONFIG_GMII_MODE;\n\n\tval &= ~(BMAC_XIF_CONFIG_LINK_LED |\n\t\t BMAC_XIF_CONFIG_LED_POLARITY);\n\n\tif (!(np->flags & NIU_FLAGS_10G) &&\n\t    !(np->flags & NIU_FLAGS_FIBER) &&\n\t    lp->active_speed == SPEED_100)\n\t\tval |= BMAC_XIF_CONFIG_25MHZ_CLOCK;\n\telse\n\t\tval &= ~BMAC_XIF_CONFIG_25MHZ_CLOCK;\n\n\tnw64_mac(BMAC_XIF_CONFIG, val);\n}\n\nstatic void niu_init_xif(struct niu *np)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tniu_init_xif_xmac(np);\n\telse\n\t\tniu_init_xif_bmac(np);\n}\n\nstatic void niu_pcs_mii_reset(struct niu *np)\n{\n\tint limit = 1000;\n\tu64 val = nr64_pcs(PCS_MII_CTL);\n\tval |= PCS_MII_CTL_RST;\n\tnw64_pcs(PCS_MII_CTL, val);\n\twhile ((--limit >= 0) && (val & PCS_MII_CTL_RST)) {\n\t\tudelay(100);\n\t\tval = nr64_pcs(PCS_MII_CTL);\n\t}\n}\n\nstatic void niu_xpcs_reset(struct niu *np)\n{\n\tint limit = 1000;\n\tu64 val = nr64_xpcs(XPCS_CONTROL1);\n\tval |= XPCS_CONTROL1_RESET;\n\tnw64_xpcs(XPCS_CONTROL1, val);\n\twhile ((--limit >= 0) && (val & XPCS_CONTROL1_RESET)) {\n\t\tudelay(100);\n\t\tval = nr64_xpcs(XPCS_CONTROL1);\n\t}\n}\n\nstatic int niu_init_pcs(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tu64 val;\n\n\tswitch (np->flags & (NIU_FLAGS_10G |\n\t\t\t     NIU_FLAGS_FIBER |\n\t\t\t     NIU_FLAGS_XCVR_SERDES)) {\n\tcase NIU_FLAGS_FIBER:\n\t\t/* 1G fiber */\n\t\tnw64_pcs(PCS_CONF, PCS_CONF_MASK | PCS_CONF_ENABLE);\n\t\tnw64_pcs(PCS_DPATH_MODE, 0);\n\t\tniu_pcs_mii_reset(np);\n\t\tbreak;\n\n\tcase NIU_FLAGS_10G:\n\tcase NIU_FLAGS_10G | NIU_FLAGS_FIBER:\n\tcase NIU_FLAGS_10G | NIU_FLAGS_XCVR_SERDES:\n\t\t/* 10G SERDES */\n\t\tif (!(np->flags & NIU_FLAGS_XMAC))\n\t\t\treturn -EINVAL;\n\n\t\t/* 10G copper or fiber */\n\t\tval = nr64_mac(XMAC_CONFIG);\n\t\tval &= ~XMAC_CONFIG_10G_XPCS_BYPASS;\n\t\tnw64_mac(XMAC_CONFIG, val);\n\n\t\tniu_xpcs_reset(np);\n\n\t\tval = nr64_xpcs(XPCS_CONTROL1);\n\t\tif (lp->loopback_mode == LOOPBACK_PHY)\n\t\t\tval |= XPCS_CONTROL1_LOOPBACK;\n\t\telse\n\t\t\tval &= ~XPCS_CONTROL1_LOOPBACK;\n\t\tnw64_xpcs(XPCS_CONTROL1, val);\n\n\t\tnw64_xpcs(XPCS_DESKEW_ERR_CNT, 0);\n\t\t(void) nr64_xpcs(XPCS_SYMERR_CNT01);\n\t\t(void) nr64_xpcs(XPCS_SYMERR_CNT23);\n\t\tbreak;\n\n\n\tcase NIU_FLAGS_XCVR_SERDES:\n\t\t/* 1G SERDES */\n\t\tniu_pcs_mii_reset(np);\n\t\tnw64_pcs(PCS_CONF, PCS_CONF_MASK | PCS_CONF_ENABLE);\n\t\tnw64_pcs(PCS_DPATH_MODE, 0);\n\t\tbreak;\n\n\tcase 0:\n\t\t/* 1G copper */\n\tcase NIU_FLAGS_XCVR_SERDES | NIU_FLAGS_FIBER:\n\t\t/* 1G RGMII FIBER */\n\t\tnw64_pcs(PCS_DPATH_MODE, PCS_DPATH_MODE_MII);\n\t\tniu_pcs_mii_reset(np);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_reset_tx_xmac(struct niu *np)\n{\n\treturn niu_set_and_wait_clear_mac(np, XTXMAC_SW_RST,\n\t\t\t\t\t  (XTXMAC_SW_RST_REG_RS |\n\t\t\t\t\t   XTXMAC_SW_RST_SOFT_RST),\n\t\t\t\t\t  1000, 100, \"XTXMAC_SW_RST\");\n}\n\nstatic int niu_reset_tx_bmac(struct niu *np)\n{\n\tint limit;\n\n\tnw64_mac(BTXMAC_SW_RST, BTXMAC_SW_RST_RESET);\n\tlimit = 1000;\n\twhile (--limit >= 0) {\n\t\tif (!(nr64_mac(BTXMAC_SW_RST) & BTXMAC_SW_RST_RESET))\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\tif (limit < 0) {\n\t\tdev_err(np->device, \"Port %u TX BMAC would not reset, BTXMAC_SW_RST[%llx]\\n\",\n\t\t\tnp->port,\n\t\t\t(unsigned long long) nr64_mac(BTXMAC_SW_RST));\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_reset_tx_mac(struct niu *np)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\treturn niu_reset_tx_xmac(np);\n\telse\n\t\treturn niu_reset_tx_bmac(np);\n}\n\nstatic void niu_init_tx_xmac(struct niu *np, u64 min, u64 max)\n{\n\tu64 val;\n\n\tval = nr64_mac(XMAC_MIN);\n\tval &= ~(XMAC_MIN_TX_MIN_PKT_SIZE |\n\t\t XMAC_MIN_RX_MIN_PKT_SIZE);\n\tval |= (min << XMAC_MIN_RX_MIN_PKT_SIZE_SHFT);\n\tval |= (min << XMAC_MIN_TX_MIN_PKT_SIZE_SHFT);\n\tnw64_mac(XMAC_MIN, val);\n\n\tnw64_mac(XMAC_MAX, max);\n\n\tnw64_mac(XTXMAC_STAT_MSK, ~(u64)0);\n\n\tval = nr64_mac(XMAC_IPG);\n\tif (np->flags & NIU_FLAGS_10G) {\n\t\tval &= ~XMAC_IPG_IPG_XGMII;\n\t\tval |= (IPG_12_15_XGMII << XMAC_IPG_IPG_XGMII_SHIFT);\n\t} else {\n\t\tval &= ~XMAC_IPG_IPG_MII_GMII;\n\t\tval |= (IPG_12_MII_GMII << XMAC_IPG_IPG_MII_GMII_SHIFT);\n\t}\n\tnw64_mac(XMAC_IPG, val);\n\n\tval = nr64_mac(XMAC_CONFIG);\n\tval &= ~(XMAC_CONFIG_ALWAYS_NO_CRC |\n\t\t XMAC_CONFIG_STRETCH_MODE |\n\t\t XMAC_CONFIG_VAR_MIN_IPG_EN |\n\t\t XMAC_CONFIG_TX_ENABLE);\n\tnw64_mac(XMAC_CONFIG, val);\n\n\tnw64_mac(TXMAC_FRM_CNT, 0);\n\tnw64_mac(TXMAC_BYTE_CNT, 0);\n}\n\nstatic void niu_init_tx_bmac(struct niu *np, u64 min, u64 max)\n{\n\tu64 val;\n\n\tnw64_mac(BMAC_MIN_FRAME, min);\n\tnw64_mac(BMAC_MAX_FRAME, max);\n\n\tnw64_mac(BTXMAC_STATUS_MASK, ~(u64)0);\n\tnw64_mac(BMAC_CTRL_TYPE, 0x8808);\n\tnw64_mac(BMAC_PREAMBLE_SIZE, 7);\n\n\tval = nr64_mac(BTXMAC_CONFIG);\n\tval &= ~(BTXMAC_CONFIG_FCS_DISABLE |\n\t\t BTXMAC_CONFIG_ENABLE);\n\tnw64_mac(BTXMAC_CONFIG, val);\n}\n\nstatic void niu_init_tx_mac(struct niu *np)\n{\n\tu64 min, max;\n\n\tmin = 64;\n\tif (np->dev->mtu > ETH_DATA_LEN)\n\t\tmax = 9216;\n\telse\n\t\tmax = 1522;\n\n\t/* The XMAC_MIN register only accepts values for TX min which\n\t * have the low 3 bits cleared.\n\t */\n\tBUG_ON(min & 0x7);\n\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tniu_init_tx_xmac(np, min, max);\n\telse\n\t\tniu_init_tx_bmac(np, min, max);\n}\n\nstatic int niu_reset_rx_xmac(struct niu *np)\n{\n\tint limit;\n\n\tnw64_mac(XRXMAC_SW_RST,\n\t\t XRXMAC_SW_RST_REG_RS | XRXMAC_SW_RST_SOFT_RST);\n\tlimit = 1000;\n\twhile (--limit >= 0) {\n\t\tif (!(nr64_mac(XRXMAC_SW_RST) & (XRXMAC_SW_RST_REG_RS |\n\t\t\t\t\t\t XRXMAC_SW_RST_SOFT_RST)))\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\tif (limit < 0) {\n\t\tdev_err(np->device, \"Port %u RX XMAC would not reset, XRXMAC_SW_RST[%llx]\\n\",\n\t\t\tnp->port,\n\t\t\t(unsigned long long) nr64_mac(XRXMAC_SW_RST));\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_reset_rx_bmac(struct niu *np)\n{\n\tint limit;\n\n\tnw64_mac(BRXMAC_SW_RST, BRXMAC_SW_RST_RESET);\n\tlimit = 1000;\n\twhile (--limit >= 0) {\n\t\tif (!(nr64_mac(BRXMAC_SW_RST) & BRXMAC_SW_RST_RESET))\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\tif (limit < 0) {\n\t\tdev_err(np->device, \"Port %u RX BMAC would not reset, BRXMAC_SW_RST[%llx]\\n\",\n\t\t\tnp->port,\n\t\t\t(unsigned long long) nr64_mac(BRXMAC_SW_RST));\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_reset_rx_mac(struct niu *np)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\treturn niu_reset_rx_xmac(np);\n\telse\n\t\treturn niu_reset_rx_bmac(np);\n}\n\nstatic void niu_init_rx_xmac(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_rdc_tables *tp = &parent->rdc_group_cfg[np->port];\n\tint first_rdc_table = tp->first_table_num;\n\tunsigned long i;\n\tu64 val;\n\n\tnw64_mac(XMAC_ADD_FILT0, 0);\n\tnw64_mac(XMAC_ADD_FILT1, 0);\n\tnw64_mac(XMAC_ADD_FILT2, 0);\n\tnw64_mac(XMAC_ADD_FILT12_MASK, 0);\n\tnw64_mac(XMAC_ADD_FILT00_MASK, 0);\n\tfor (i = 0; i < MAC_NUM_HASH; i++)\n\t\tnw64_mac(XMAC_HASH_TBL(i), 0);\n\tnw64_mac(XRXMAC_STAT_MSK, ~(u64)0);\n\tniu_set_primary_mac_rdc_table(np, first_rdc_table, 1);\n\tniu_set_multicast_mac_rdc_table(np, first_rdc_table, 1);\n\n\tval = nr64_mac(XMAC_CONFIG);\n\tval &= ~(XMAC_CONFIG_RX_MAC_ENABLE |\n\t\t XMAC_CONFIG_PROMISCUOUS |\n\t\t XMAC_CONFIG_PROMISC_GROUP |\n\t\t XMAC_CONFIG_ERR_CHK_DIS |\n\t\t XMAC_CONFIG_RX_CRC_CHK_DIS |\n\t\t XMAC_CONFIG_RESERVED_MULTICAST |\n\t\t XMAC_CONFIG_RX_CODEV_CHK_DIS |\n\t\t XMAC_CONFIG_ADDR_FILTER_EN |\n\t\t XMAC_CONFIG_RCV_PAUSE_ENABLE |\n\t\t XMAC_CONFIG_STRIP_CRC |\n\t\t XMAC_CONFIG_PASS_FLOW_CTRL |\n\t\t XMAC_CONFIG_MAC2IPP_PKT_CNT_EN);\n\tval |= (XMAC_CONFIG_HASH_FILTER_EN);\n\tnw64_mac(XMAC_CONFIG, val);\n\n\tnw64_mac(RXMAC_BT_CNT, 0);\n\tnw64_mac(RXMAC_BC_FRM_CNT, 0);\n\tnw64_mac(RXMAC_MC_FRM_CNT, 0);\n\tnw64_mac(RXMAC_FRAG_CNT, 0);\n\tnw64_mac(RXMAC_HIST_CNT1, 0);\n\tnw64_mac(RXMAC_HIST_CNT2, 0);\n\tnw64_mac(RXMAC_HIST_CNT3, 0);\n\tnw64_mac(RXMAC_HIST_CNT4, 0);\n\tnw64_mac(RXMAC_HIST_CNT5, 0);\n\tnw64_mac(RXMAC_HIST_CNT6, 0);\n\tnw64_mac(RXMAC_HIST_CNT7, 0);\n\tnw64_mac(RXMAC_MPSZER_CNT, 0);\n\tnw64_mac(RXMAC_CRC_ER_CNT, 0);\n\tnw64_mac(RXMAC_CD_VIO_CNT, 0);\n\tnw64_mac(LINK_FAULT_CNT, 0);\n}\n\nstatic void niu_init_rx_bmac(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_rdc_tables *tp = &parent->rdc_group_cfg[np->port];\n\tint first_rdc_table = tp->first_table_num;\n\tunsigned long i;\n\tu64 val;\n\n\tnw64_mac(BMAC_ADD_FILT0, 0);\n\tnw64_mac(BMAC_ADD_FILT1, 0);\n\tnw64_mac(BMAC_ADD_FILT2, 0);\n\tnw64_mac(BMAC_ADD_FILT12_MASK, 0);\n\tnw64_mac(BMAC_ADD_FILT00_MASK, 0);\n\tfor (i = 0; i < MAC_NUM_HASH; i++)\n\t\tnw64_mac(BMAC_HASH_TBL(i), 0);\n\tniu_set_primary_mac_rdc_table(np, first_rdc_table, 1);\n\tniu_set_multicast_mac_rdc_table(np, first_rdc_table, 1);\n\tnw64_mac(BRXMAC_STATUS_MASK, ~(u64)0);\n\n\tval = nr64_mac(BRXMAC_CONFIG);\n\tval &= ~(BRXMAC_CONFIG_ENABLE |\n\t\t BRXMAC_CONFIG_STRIP_PAD |\n\t\t BRXMAC_CONFIG_STRIP_FCS |\n\t\t BRXMAC_CONFIG_PROMISC |\n\t\t BRXMAC_CONFIG_PROMISC_GRP |\n\t\t BRXMAC_CONFIG_ADDR_FILT_EN |\n\t\t BRXMAC_CONFIG_DISCARD_DIS);\n\tval |= (BRXMAC_CONFIG_HASH_FILT_EN);\n\tnw64_mac(BRXMAC_CONFIG, val);\n\n\tval = nr64_mac(BMAC_ADDR_CMPEN);\n\tval |= BMAC_ADDR_CMPEN_EN0;\n\tnw64_mac(BMAC_ADDR_CMPEN, val);\n}\n\nstatic void niu_init_rx_mac(struct niu *np)\n{\n\tniu_set_primary_mac(np, np->dev->dev_addr);\n\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tniu_init_rx_xmac(np);\n\telse\n\t\tniu_init_rx_bmac(np);\n}\n\nstatic void niu_enable_tx_xmac(struct niu *np, int on)\n{\n\tu64 val = nr64_mac(XMAC_CONFIG);\n\n\tif (on)\n\t\tval |= XMAC_CONFIG_TX_ENABLE;\n\telse\n\t\tval &= ~XMAC_CONFIG_TX_ENABLE;\n\tnw64_mac(XMAC_CONFIG, val);\n}\n\nstatic void niu_enable_tx_bmac(struct niu *np, int on)\n{\n\tu64 val = nr64_mac(BTXMAC_CONFIG);\n\n\tif (on)\n\t\tval |= BTXMAC_CONFIG_ENABLE;\n\telse\n\t\tval &= ~BTXMAC_CONFIG_ENABLE;\n\tnw64_mac(BTXMAC_CONFIG, val);\n}\n\nstatic void niu_enable_tx_mac(struct niu *np, int on)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tniu_enable_tx_xmac(np, on);\n\telse\n\t\tniu_enable_tx_bmac(np, on);\n}\n\nstatic void niu_enable_rx_xmac(struct niu *np, int on)\n{\n\tu64 val = nr64_mac(XMAC_CONFIG);\n\n\tval &= ~(XMAC_CONFIG_HASH_FILTER_EN |\n\t\t XMAC_CONFIG_PROMISCUOUS);\n\n\tif (np->flags & NIU_FLAGS_MCAST)\n\t\tval |= XMAC_CONFIG_HASH_FILTER_EN;\n\tif (np->flags & NIU_FLAGS_PROMISC)\n\t\tval |= XMAC_CONFIG_PROMISCUOUS;\n\n\tif (on)\n\t\tval |= XMAC_CONFIG_RX_MAC_ENABLE;\n\telse\n\t\tval &= ~XMAC_CONFIG_RX_MAC_ENABLE;\n\tnw64_mac(XMAC_CONFIG, val);\n}\n\nstatic void niu_enable_rx_bmac(struct niu *np, int on)\n{\n\tu64 val = nr64_mac(BRXMAC_CONFIG);\n\n\tval &= ~(BRXMAC_CONFIG_HASH_FILT_EN |\n\t\t BRXMAC_CONFIG_PROMISC);\n\n\tif (np->flags & NIU_FLAGS_MCAST)\n\t\tval |= BRXMAC_CONFIG_HASH_FILT_EN;\n\tif (np->flags & NIU_FLAGS_PROMISC)\n\t\tval |= BRXMAC_CONFIG_PROMISC;\n\n\tif (on)\n\t\tval |= BRXMAC_CONFIG_ENABLE;\n\telse\n\t\tval &= ~BRXMAC_CONFIG_ENABLE;\n\tnw64_mac(BRXMAC_CONFIG, val);\n}\n\nstatic void niu_enable_rx_mac(struct niu *np, int on)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tniu_enable_rx_xmac(np, on);\n\telse\n\t\tniu_enable_rx_bmac(np, on);\n}\n\nstatic int niu_init_mac(struct niu *np)\n{\n\tint err;\n\n\tniu_init_xif(np);\n\terr = niu_init_pcs(np);\n\tif (err)\n\t\treturn err;\n\n\terr = niu_reset_tx_mac(np);\n\tif (err)\n\t\treturn err;\n\tniu_init_tx_mac(np);\n\terr = niu_reset_rx_mac(np);\n\tif (err)\n\t\treturn err;\n\tniu_init_rx_mac(np);\n\n\t/* This looks hookey but the RX MAC reset we just did will\n\t * undo some of the state we setup in niu_init_tx_mac() so we\n\t * have to call it again.  In particular, the RX MAC reset will\n\t * set the XMAC_MAX register back to it's default value.\n\t */\n\tniu_init_tx_mac(np);\n\tniu_enable_tx_mac(np, 1);\n\n\tniu_enable_rx_mac(np, 1);\n\n\treturn 0;\n}\n\nstatic void niu_stop_one_tx_channel(struct niu *np, struct tx_ring_info *rp)\n{\n\t(void) niu_tx_channel_stop(np, rp->tx_channel);\n}\n\nstatic void niu_stop_tx_channels(struct niu *np)\n{\n\tint i;\n\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\n\t\tniu_stop_one_tx_channel(np, rp);\n\t}\n}\n\nstatic void niu_reset_one_tx_channel(struct niu *np, struct tx_ring_info *rp)\n{\n\t(void) niu_tx_channel_reset(np, rp->tx_channel);\n}\n\nstatic void niu_reset_tx_channels(struct niu *np)\n{\n\tint i;\n\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\n\t\tniu_reset_one_tx_channel(np, rp);\n\t}\n}\n\nstatic void niu_stop_one_rx_channel(struct niu *np, struct rx_ring_info *rp)\n{\n\t(void) niu_enable_rx_channel(np, rp->rx_channel, 0);\n}\n\nstatic void niu_stop_rx_channels(struct niu *np)\n{\n\tint i;\n\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\tniu_stop_one_rx_channel(np, rp);\n\t}\n}\n\nstatic void niu_reset_one_rx_channel(struct niu *np, struct rx_ring_info *rp)\n{\n\tint channel = rp->rx_channel;\n\n\t(void) niu_rx_channel_reset(np, channel);\n\tnw64(RX_DMA_ENT_MSK(channel), RX_DMA_ENT_MSK_ALL);\n\tnw64(RX_DMA_CTL_STAT(channel), 0);\n\t(void) niu_enable_rx_channel(np, channel, 0);\n}\n\nstatic void niu_reset_rx_channels(struct niu *np)\n{\n\tint i;\n\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\tniu_reset_one_rx_channel(np, rp);\n\t}\n}\n\nstatic void niu_disable_ipp(struct niu *np)\n{\n\tu64 rd, wr, val;\n\tint limit;\n\n\trd = nr64_ipp(IPP_DFIFO_RD_PTR);\n\twr = nr64_ipp(IPP_DFIFO_WR_PTR);\n\tlimit = 100;\n\twhile (--limit >= 0 && (rd != wr)) {\n\t\trd = nr64_ipp(IPP_DFIFO_RD_PTR);\n\t\twr = nr64_ipp(IPP_DFIFO_WR_PTR);\n\t}\n\tif (limit < 0 &&\n\t    (rd != 0 && wr != 1)) {\n\t\tnetdev_err(np->dev, \"IPP would not quiesce, rd_ptr[%llx] wr_ptr[%llx]\\n\",\n\t\t\t   (unsigned long long)nr64_ipp(IPP_DFIFO_RD_PTR),\n\t\t\t   (unsigned long long)nr64_ipp(IPP_DFIFO_WR_PTR));\n\t}\n\n\tval = nr64_ipp(IPP_CFIG);\n\tval &= ~(IPP_CFIG_IPP_ENABLE |\n\t\t IPP_CFIG_DFIFO_ECC_EN |\n\t\t IPP_CFIG_DROP_BAD_CRC |\n\t\t IPP_CFIG_CKSUM_EN);\n\tnw64_ipp(IPP_CFIG, val);\n\n\t(void) niu_ipp_reset(np);\n}\n\nstatic int niu_init_hw(struct niu *np)\n{\n\tint i, err;\n\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Initialize TXC\\n\");\n\tniu_txc_enable_port(np, 1);\n\tniu_txc_port_dma_enable(np, 1);\n\tniu_txc_set_imask(np, 0);\n\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Initialize TX channels\\n\");\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\n\t\terr = niu_init_one_tx_channel(np, rp);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Initialize RX channels\\n\");\n\terr = niu_init_rx_channels(np);\n\tif (err)\n\t\tgoto out_uninit_tx_channels;\n\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Initialize classifier\\n\");\n\terr = niu_init_classifier_hw(np);\n\tif (err)\n\t\tgoto out_uninit_rx_channels;\n\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Initialize ZCP\\n\");\n\terr = niu_init_zcp(np);\n\tif (err)\n\t\tgoto out_uninit_rx_channels;\n\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Initialize IPP\\n\");\n\terr = niu_init_ipp(np);\n\tif (err)\n\t\tgoto out_uninit_rx_channels;\n\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Initialize MAC\\n\");\n\terr = niu_init_mac(np);\n\tif (err)\n\t\tgoto out_uninit_ipp;\n\n\treturn 0;\n\nout_uninit_ipp:\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Uninit IPP\\n\");\n\tniu_disable_ipp(np);\n\nout_uninit_rx_channels:\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Uninit RX channels\\n\");\n\tniu_stop_rx_channels(np);\n\tniu_reset_rx_channels(np);\n\nout_uninit_tx_channels:\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Uninit TX channels\\n\");\n\tniu_stop_tx_channels(np);\n\tniu_reset_tx_channels(np);\n\n\treturn err;\n}\n\nstatic void niu_stop_hw(struct niu *np)\n{\n\tnetif_printk(np, ifdown, KERN_DEBUG, np->dev, \"Disable interrupts\\n\");\n\tniu_enable_interrupts(np, 0);\n\n\tnetif_printk(np, ifdown, KERN_DEBUG, np->dev, \"Disable RX MAC\\n\");\n\tniu_enable_rx_mac(np, 0);\n\n\tnetif_printk(np, ifdown, KERN_DEBUG, np->dev, \"Disable IPP\\n\");\n\tniu_disable_ipp(np);\n\n\tnetif_printk(np, ifdown, KERN_DEBUG, np->dev, \"Stop TX channels\\n\");\n\tniu_stop_tx_channels(np);\n\n\tnetif_printk(np, ifdown, KERN_DEBUG, np->dev, \"Stop RX channels\\n\");\n\tniu_stop_rx_channels(np);\n\n\tnetif_printk(np, ifdown, KERN_DEBUG, np->dev, \"Reset TX channels\\n\");\n\tniu_reset_tx_channels(np);\n\n\tnetif_printk(np, ifdown, KERN_DEBUG, np->dev, \"Reset RX channels\\n\");\n\tniu_reset_rx_channels(np);\n}\n\nstatic void niu_set_irq_name(struct niu *np)\n{\n\tint port = np->port;\n\tint i, j = 1;\n\n\tsprintf(np->irq_name[0], \"%s:MAC\", np->dev->name);\n\n\tif (port == 0) {\n\t\tsprintf(np->irq_name[1], \"%s:MIF\", np->dev->name);\n\t\tsprintf(np->irq_name[2], \"%s:SYSERR\", np->dev->name);\n\t\tj = 3;\n\t}\n\n\tfor (i = 0; i < np->num_ldg - j; i++) {\n\t\tif (i < np->num_rx_rings)\n\t\t\tsprintf(np->irq_name[i+j], \"%s-rx-%d\",\n\t\t\t\tnp->dev->name, i);\n\t\telse if (i < np->num_tx_rings + np->num_rx_rings)\n\t\t\tsprintf(np->irq_name[i+j], \"%s-tx-%d\", np->dev->name,\n\t\t\t\ti - np->num_rx_rings);\n\t}\n}\n\nstatic int niu_request_irq(struct niu *np)\n{\n\tint i, j, err;\n\n\tniu_set_irq_name(np);\n\n\terr = 0;\n\tfor (i = 0; i < np->num_ldg; i++) {\n\t\tstruct niu_ldg *lp = &np->ldg[i];\n\n\t\terr = request_irq(lp->irq, niu_interrupt, IRQF_SHARED,\n\t\t\t\t  np->irq_name[i], lp);\n\t\tif (err)\n\t\t\tgoto out_free_irqs;\n\n\t}\n\n\treturn 0;\n\nout_free_irqs:\n\tfor (j = 0; j < i; j++) {\n\t\tstruct niu_ldg *lp = &np->ldg[j];\n\n\t\tfree_irq(lp->irq, lp);\n\t}\n\treturn err;\n}\n\nstatic void niu_free_irq(struct niu *np)\n{\n\tint i;\n\n\tfor (i = 0; i < np->num_ldg; i++) {\n\t\tstruct niu_ldg *lp = &np->ldg[i];\n\n\t\tfree_irq(lp->irq, lp);\n\t}\n}\n\nstatic void niu_enable_napi(struct niu *np)\n{\n\tint i;\n\n\tfor (i = 0; i < np->num_ldg; i++)\n\t\tnapi_enable(&np->ldg[i].napi);\n}\n\nstatic void niu_disable_napi(struct niu *np)\n{\n\tint i;\n\n\tfor (i = 0; i < np->num_ldg; i++)\n\t\tnapi_disable(&np->ldg[i].napi);\n}\n\nstatic int niu_open(struct net_device *dev)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tint err;\n\n\tnetif_carrier_off(dev);\n\n\terr = niu_alloc_channels(np);\n\tif (err)\n\t\tgoto out_err;\n\n\terr = niu_enable_interrupts(np, 0);\n\tif (err)\n\t\tgoto out_free_channels;\n\n\terr = niu_request_irq(np);\n\tif (err)\n\t\tgoto out_free_channels;\n\n\tniu_enable_napi(np);\n\n\tspin_lock_irq(&np->lock);\n\n\terr = niu_init_hw(np);\n\tif (!err) {\n\t\ttimer_setup(&np->timer, niu_timer, 0);\n\t\tnp->timer.expires = jiffies + HZ;\n\n\t\terr = niu_enable_interrupts(np, 1);\n\t\tif (err)\n\t\t\tniu_stop_hw(np);\n\t}\n\n\tspin_unlock_irq(&np->lock);\n\n\tif (err) {\n\t\tniu_disable_napi(np);\n\t\tgoto out_free_irq;\n\t}\n\n\tnetif_tx_start_all_queues(dev);\n\n\tif (np->link_config.loopback_mode != LOOPBACK_DISABLED)\n\t\tnetif_carrier_on(dev);\n\n\tadd_timer(&np->timer);\n\n\treturn 0;\n\nout_free_irq:\n\tniu_free_irq(np);\n\nout_free_channels:\n\tniu_free_channels(np);\n\nout_err:\n\treturn err;\n}\n\nstatic void niu_full_shutdown(struct niu *np, struct net_device *dev)\n{\n\tcancel_work_sync(&np->reset_task);\n\n\tniu_disable_napi(np);\n\tnetif_tx_stop_all_queues(dev);\n\n\tdel_timer_sync(&np->timer);\n\n\tspin_lock_irq(&np->lock);\n\n\tniu_stop_hw(np);\n\n\tspin_unlock_irq(&np->lock);\n}\n\nstatic int niu_close(struct net_device *dev)\n{\n\tstruct niu *np = netdev_priv(dev);\n\n\tniu_full_shutdown(np, dev);\n\n\tniu_free_irq(np);\n\n\tniu_free_channels(np);\n\n\tniu_handle_led(np, 0);\n\n\treturn 0;\n}\n\nstatic void niu_sync_xmac_stats(struct niu *np)\n{\n\tstruct niu_xmac_stats *mp = &np->mac_stats.xmac;\n\n\tmp->tx_frames += nr64_mac(TXMAC_FRM_CNT);\n\tmp->tx_bytes += nr64_mac(TXMAC_BYTE_CNT);\n\n\tmp->rx_link_faults += nr64_mac(LINK_FAULT_CNT);\n\tmp->rx_align_errors += nr64_mac(RXMAC_ALIGN_ERR_CNT);\n\tmp->rx_frags += nr64_mac(RXMAC_FRAG_CNT);\n\tmp->rx_mcasts += nr64_mac(RXMAC_MC_FRM_CNT);\n\tmp->rx_bcasts += nr64_mac(RXMAC_BC_FRM_CNT);\n\tmp->rx_hist_cnt1 += nr64_mac(RXMAC_HIST_CNT1);\n\tmp->rx_hist_cnt2 += nr64_mac(RXMAC_HIST_CNT2);\n\tmp->rx_hist_cnt3 += nr64_mac(RXMAC_HIST_CNT3);\n\tmp->rx_hist_cnt4 += nr64_mac(RXMAC_HIST_CNT4);\n\tmp->rx_hist_cnt5 += nr64_mac(RXMAC_HIST_CNT5);\n\tmp->rx_hist_cnt6 += nr64_mac(RXMAC_HIST_CNT6);\n\tmp->rx_hist_cnt7 += nr64_mac(RXMAC_HIST_CNT7);\n\tmp->rx_octets += nr64_mac(RXMAC_BT_CNT);\n\tmp->rx_code_violations += nr64_mac(RXMAC_CD_VIO_CNT);\n\tmp->rx_len_errors += nr64_mac(RXMAC_MPSZER_CNT);\n\tmp->rx_crc_errors += nr64_mac(RXMAC_CRC_ER_CNT);\n}\n\nstatic void niu_sync_bmac_stats(struct niu *np)\n{\n\tstruct niu_bmac_stats *mp = &np->mac_stats.bmac;\n\n\tmp->tx_bytes += nr64_mac(BTXMAC_BYTE_CNT);\n\tmp->tx_frames += nr64_mac(BTXMAC_FRM_CNT);\n\n\tmp->rx_frames += nr64_mac(BRXMAC_FRAME_CNT);\n\tmp->rx_align_errors += nr64_mac(BRXMAC_ALIGN_ERR_CNT);\n\tmp->rx_crc_errors += nr64_mac(BRXMAC_ALIGN_ERR_CNT);\n\tmp->rx_len_errors += nr64_mac(BRXMAC_CODE_VIOL_ERR_CNT);\n}\n\nstatic void niu_sync_mac_stats(struct niu *np)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tniu_sync_xmac_stats(np);\n\telse\n\t\tniu_sync_bmac_stats(np);\n}\n\nstatic void niu_get_rx_stats(struct niu *np,\n\t\t\t     struct rtnl_link_stats64 *stats)\n{\n\tu64 pkts, dropped, errors, bytes;\n\tstruct rx_ring_info *rx_rings;\n\tint i;\n\n\tpkts = dropped = errors = bytes = 0;\n\n\trx_rings = READ_ONCE(np->rx_rings);\n\tif (!rx_rings)\n\t\tgoto no_rings;\n\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tstruct rx_ring_info *rp = &rx_rings[i];\n\n\t\tniu_sync_rx_discard_stats(np, rp, 0);\n\n\t\tpkts += rp->rx_packets;\n\t\tbytes += rp->rx_bytes;\n\t\tdropped += rp->rx_dropped;\n\t\terrors += rp->rx_errors;\n\t}\n\nno_rings:\n\tstats->rx_packets = pkts;\n\tstats->rx_bytes = bytes;\n\tstats->rx_dropped = dropped;\n\tstats->rx_errors = errors;\n}\n\nstatic void niu_get_tx_stats(struct niu *np,\n\t\t\t     struct rtnl_link_stats64 *stats)\n{\n\tu64 pkts, errors, bytes;\n\tstruct tx_ring_info *tx_rings;\n\tint i;\n\n\tpkts = errors = bytes = 0;\n\n\ttx_rings = READ_ONCE(np->tx_rings);\n\tif (!tx_rings)\n\t\tgoto no_rings;\n\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tstruct tx_ring_info *rp = &tx_rings[i];\n\n\t\tpkts += rp->tx_packets;\n\t\tbytes += rp->tx_bytes;\n\t\terrors += rp->tx_errors;\n\t}\n\nno_rings:\n\tstats->tx_packets = pkts;\n\tstats->tx_bytes = bytes;\n\tstats->tx_errors = errors;\n}\n\nstatic void niu_get_stats(struct net_device *dev,\n\t\t\t  struct rtnl_link_stats64 *stats)\n{\n\tstruct niu *np = netdev_priv(dev);\n\n\tif (netif_running(dev)) {\n\t\tniu_get_rx_stats(np, stats);\n\t\tniu_get_tx_stats(np, stats);\n\t}\n}\n\nstatic void niu_load_hash_xmac(struct niu *np, u16 *hash)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tnw64_mac(XMAC_HASH_TBL(i), hash[i]);\n}\n\nstatic void niu_load_hash_bmac(struct niu *np, u16 *hash)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tnw64_mac(BMAC_HASH_TBL(i), hash[i]);\n}\n\nstatic void niu_load_hash(struct niu *np, u16 *hash)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tniu_load_hash_xmac(np, hash);\n\telse\n\t\tniu_load_hash_bmac(np, hash);\n}\n\nstatic void niu_set_rx_mode(struct net_device *dev)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tint i, alt_cnt, err;\n\tstruct netdev_hw_addr *ha;\n\tunsigned long flags;\n\tu16 hash[16] = { 0, };\n\n\tspin_lock_irqsave(&np->lock, flags);\n\tniu_enable_rx_mac(np, 0);\n\n\tnp->flags &= ~(NIU_FLAGS_MCAST | NIU_FLAGS_PROMISC);\n\tif (dev->flags & IFF_PROMISC)\n\t\tnp->flags |= NIU_FLAGS_PROMISC;\n\tif ((dev->flags & IFF_ALLMULTI) || (!netdev_mc_empty(dev)))\n\t\tnp->flags |= NIU_FLAGS_MCAST;\n\n\talt_cnt = netdev_uc_count(dev);\n\tif (alt_cnt > niu_num_alt_addr(np)) {\n\t\talt_cnt = 0;\n\t\tnp->flags |= NIU_FLAGS_PROMISC;\n\t}\n\n\tif (alt_cnt) {\n\t\tint index = 0;\n\n\t\tnetdev_for_each_uc_addr(ha, dev) {\n\t\t\terr = niu_set_alt_mac(np, index, ha->addr);\n\t\t\tif (err)\n\t\t\t\tnetdev_warn(dev, \"Error %d adding alt mac %d\\n\",\n\t\t\t\t\t    err, index);\n\t\t\terr = niu_enable_alt_mac(np, index, 1);\n\t\t\tif (err)\n\t\t\t\tnetdev_warn(dev, \"Error %d enabling alt mac %d\\n\",\n\t\t\t\t\t    err, index);\n\n\t\t\tindex++;\n\t\t}\n\t} else {\n\t\tint alt_start;\n\t\tif (np->flags & NIU_FLAGS_XMAC)\n\t\t\talt_start = 0;\n\t\telse\n\t\t\talt_start = 1;\n\t\tfor (i = alt_start; i < niu_num_alt_addr(np); i++) {\n\t\t\terr = niu_enable_alt_mac(np, i, 0);\n\t\t\tif (err)\n\t\t\t\tnetdev_warn(dev, \"Error %d disabling alt mac %d\\n\",\n\t\t\t\t\t    err, i);\n\t\t}\n\t}\n\tif (dev->flags & IFF_ALLMULTI) {\n\t\tfor (i = 0; i < 16; i++)\n\t\t\thash[i] = 0xffff;\n\t} else if (!netdev_mc_empty(dev)) {\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tu32 crc = ether_crc_le(ETH_ALEN, ha->addr);\n\n\t\t\tcrc >>= 24;\n\t\t\thash[crc >> 4] |= (1 << (15 - (crc & 0xf)));\n\t\t}\n\t}\n\n\tif (np->flags & NIU_FLAGS_MCAST)\n\t\tniu_load_hash(np, hash);\n\n\tniu_enable_rx_mac(np, 1);\n\tspin_unlock_irqrestore(&np->lock, flags);\n}\n\nstatic int niu_set_mac_addr(struct net_device *dev, void *p)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tstruct sockaddr *addr = p;\n\tunsigned long flags;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\tniu_enable_rx_mac(np, 0);\n\tniu_set_primary_mac(np, dev->dev_addr);\n\tniu_enable_rx_mac(np, 1);\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\treturn 0;\n}\n\nstatic int niu_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void niu_netif_stop(struct niu *np)\n{\n\tnetif_trans_update(np->dev);\t/* prevent tx timeout */\n\n\tniu_disable_napi(np);\n\n\tnetif_tx_disable(np->dev);\n}\n\nstatic void niu_netif_start(struct niu *np)\n{\n\t/* NOTE: unconditional netif_wake_queue is only appropriate\n\t * so long as all callers are assured to have free tx slots\n\t * (such as after niu_init_hw).\n\t */\n\tnetif_tx_wake_all_queues(np->dev);\n\n\tniu_enable_napi(np);\n\n\tniu_enable_interrupts(np, 1);\n}\n\nstatic void niu_reset_buffers(struct niu *np)\n{\n\tint i, j, k, err;\n\n\tif (np->rx_rings) {\n\t\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\t\tfor (j = 0, k = 0; j < MAX_RBR_RING_SIZE; j++) {\n\t\t\t\tstruct page *page;\n\n\t\t\t\tpage = rp->rxhash[j];\n\t\t\t\twhile (page) {\n\t\t\t\t\tstruct page *next =\n\t\t\t\t\t\t(struct page *) page->mapping;\n\t\t\t\t\tu64 base = page->index;\n\t\t\t\t\tbase = base >> RBR_DESCR_ADDR_SHIFT;\n\t\t\t\t\trp->rbr[k++] = cpu_to_le32(base);\n\t\t\t\t\tpage = next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (; k < MAX_RBR_RING_SIZE; k++) {\n\t\t\t\terr = niu_rbr_add_page(np, rp, GFP_ATOMIC, k);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trp->rbr_index = rp->rbr_table_size - 1;\n\t\t\trp->rcr_index = 0;\n\t\t\trp->rbr_pending = 0;\n\t\t\trp->rbr_refill_pending = 0;\n\t\t}\n\t}\n\tif (np->tx_rings) {\n\t\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\n\t\t\tfor (j = 0; j < MAX_TX_RING_SIZE; j++) {\n\t\t\t\tif (rp->tx_buffs[j].skb)\n\t\t\t\t\t(void) release_tx_packet(np, rp, j);\n\t\t\t}\n\n\t\t\trp->pending = MAX_TX_RING_SIZE;\n\t\t\trp->prod = 0;\n\t\t\trp->cons = 0;\n\t\t\trp->wrap_bit = 0;\n\t\t}\n\t}\n}\n\nstatic void niu_reset_task(struct work_struct *work)\n{\n\tstruct niu *np = container_of(work, struct niu, reset_task);\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\tif (!netif_running(np->dev)) {\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\treturn;\n\t}\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\tdel_timer_sync(&np->timer);\n\n\tniu_netif_stop(np);\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\tniu_stop_hw(np);\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\tniu_reset_buffers(np);\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\terr = niu_init_hw(np);\n\tif (!err) {\n\t\tnp->timer.expires = jiffies + HZ;\n\t\tadd_timer(&np->timer);\n\t\tniu_netif_start(np);\n\t}\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n}\n\nstatic void niu_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct niu *np = netdev_priv(dev);\n\n\tdev_err(np->device, \"%s: Transmit timed out, resetting\\n\",\n\t\tdev->name);\n\n\tschedule_work(&np->reset_task);\n}\n\nstatic void niu_set_txd(struct tx_ring_info *rp, int index,\n\t\t\tu64 mapping, u64 len, u64 mark,\n\t\t\tu64 n_frags)\n{\n\t__le64 *desc = &rp->descr[index];\n\n\t*desc = cpu_to_le64(mark |\n\t\t\t    (n_frags << TX_DESC_NUM_PTR_SHIFT) |\n\t\t\t    (len << TX_DESC_TR_LEN_SHIFT) |\n\t\t\t    (mapping & TX_DESC_SAD));\n}\n\nstatic u64 niu_compute_tx_flags(struct sk_buff *skb, struct ethhdr *ehdr,\n\t\t\t\tu64 pad_bytes, u64 len)\n{\n\tu16 eth_proto, eth_proto_inner;\n\tu64 csum_bits, l3off, ihl, ret;\n\tu8 ip_proto;\n\tint ipv6;\n\n\teth_proto = be16_to_cpu(ehdr->h_proto);\n\teth_proto_inner = eth_proto;\n\tif (eth_proto == ETH_P_8021Q) {\n\t\tstruct vlan_ethhdr *vp = (struct vlan_ethhdr *) ehdr;\n\t\t__be16 val = vp->h_vlan_encapsulated_proto;\n\n\t\teth_proto_inner = be16_to_cpu(val);\n\t}\n\n\tipv6 = ihl = 0;\n\tswitch (skb->protocol) {\n\tcase cpu_to_be16(ETH_P_IP):\n\t\tip_proto = ip_hdr(skb)->protocol;\n\t\tihl = ip_hdr(skb)->ihl;\n\t\tbreak;\n\tcase cpu_to_be16(ETH_P_IPV6):\n\t\tip_proto = ipv6_hdr(skb)->nexthdr;\n\t\tihl = (40 >> 2);\n\t\tipv6 = 1;\n\t\tbreak;\n\tdefault:\n\t\tip_proto = ihl = 0;\n\t\tbreak;\n\t}\n\n\tcsum_bits = TXHDR_CSUM_NONE;\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tu64 start, stuff;\n\n\t\tcsum_bits = (ip_proto == IPPROTO_TCP ?\n\t\t\t     TXHDR_CSUM_TCP :\n\t\t\t     (ip_proto == IPPROTO_UDP ?\n\t\t\t      TXHDR_CSUM_UDP : TXHDR_CSUM_SCTP));\n\n\t\tstart = skb_checksum_start_offset(skb) -\n\t\t\t(pad_bytes + sizeof(struct tx_pkt_hdr));\n\t\tstuff = start + skb->csum_offset;\n\n\t\tcsum_bits |= (start / 2) << TXHDR_L4START_SHIFT;\n\t\tcsum_bits |= (stuff / 2) << TXHDR_L4STUFF_SHIFT;\n\t}\n\n\tl3off = skb_network_offset(skb) -\n\t\t(pad_bytes + sizeof(struct tx_pkt_hdr));\n\n\tret = (((pad_bytes / 2) << TXHDR_PAD_SHIFT) |\n\t       (len << TXHDR_LEN_SHIFT) |\n\t       ((l3off / 2) << TXHDR_L3START_SHIFT) |\n\t       (ihl << TXHDR_IHL_SHIFT) |\n\t       ((eth_proto_inner < ETH_P_802_3_MIN) ? TXHDR_LLC : 0) |\n\t       ((eth_proto == ETH_P_8021Q) ? TXHDR_VLAN : 0) |\n\t       (ipv6 ? TXHDR_IP_VER : 0) |\n\t       csum_bits);\n\n\treturn ret;\n}\n\nstatic netdev_tx_t niu_start_xmit(struct sk_buff *skb,\n\t\t\t\t  struct net_device *dev)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tunsigned long align, headroom;\n\tstruct netdev_queue *txq;\n\tstruct tx_ring_info *rp;\n\tstruct tx_pkt_hdr *tp;\n\tunsigned int len, nfg;\n\tstruct ethhdr *ehdr;\n\tint prod, i, tlen;\n\tu64 mapping, mrk;\n\n\ti = skb_get_queue_mapping(skb);\n\trp = &np->tx_rings[i];\n\ttxq = netdev_get_tx_queue(dev, i);\n\n\tif (niu_tx_avail(rp) <= (skb_shinfo(skb)->nr_frags + 1)) {\n\t\tnetif_tx_stop_queue(txq);\n\t\tdev_err(np->device, \"%s: BUG! Tx ring full when queue awake!\\n\", dev->name);\n\t\trp->tx_errors++;\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (eth_skb_pad(skb))\n\t\tgoto out;\n\n\tlen = sizeof(struct tx_pkt_hdr) + 15;\n\tif (skb_headroom(skb) < len) {\n\t\tstruct sk_buff *skb_new;\n\n\t\tskb_new = skb_realloc_headroom(skb, len);\n\t\tif (!skb_new)\n\t\t\tgoto out_drop;\n\t\tkfree_skb(skb);\n\t\tskb = skb_new;\n\t} else\n\t\tskb_orphan(skb);\n\n\talign = ((unsigned long) skb->data & (16 - 1));\n\theadroom = align + sizeof(struct tx_pkt_hdr);\n\n\tehdr = (struct ethhdr *) skb->data;\n\ttp = skb_push(skb, headroom);\n\n\tlen = skb->len - sizeof(struct tx_pkt_hdr);\n\ttp->flags = cpu_to_le64(niu_compute_tx_flags(skb, ehdr, align, len));\n\ttp->resv = 0;\n\n\tlen = skb_headlen(skb);\n\tmapping = np->ops->map_single(np->device, skb->data,\n\t\t\t\t      len, DMA_TO_DEVICE);\n\n\tprod = rp->prod;\n\n\trp->tx_buffs[prod].skb = skb;\n\trp->tx_buffs[prod].mapping = mapping;\n\n\tmrk = TX_DESC_SOP;\n\tif (++rp->mark_counter == rp->mark_freq) {\n\t\trp->mark_counter = 0;\n\t\tmrk |= TX_DESC_MARK;\n\t\trp->mark_pending++;\n\t}\n\n\ttlen = len;\n\tnfg = skb_shinfo(skb)->nr_frags;\n\twhile (tlen > 0) {\n\t\ttlen -= MAX_TX_DESC_LEN;\n\t\tnfg++;\n\t}\n\n\twhile (len > 0) {\n\t\tunsigned int this_len = len;\n\n\t\tif (this_len > MAX_TX_DESC_LEN)\n\t\t\tthis_len = MAX_TX_DESC_LEN;\n\n\t\tniu_set_txd(rp, prod, mapping, this_len, mrk, nfg);\n\t\tmrk = nfg = 0;\n\n\t\tprod = NEXT_TX(rp, prod);\n\t\tmapping += this_len;\n\t\tlen -= this_len;\n\t}\n\n\tfor (i = 0; i <  skb_shinfo(skb)->nr_frags; i++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tlen = skb_frag_size(frag);\n\t\tmapping = np->ops->map_page(np->device, skb_frag_page(frag),\n\t\t\t\t\t    skb_frag_off(frag), len,\n\t\t\t\t\t    DMA_TO_DEVICE);\n\n\t\trp->tx_buffs[prod].skb = NULL;\n\t\trp->tx_buffs[prod].mapping = mapping;\n\n\t\tniu_set_txd(rp, prod, mapping, len, 0, 0);\n\n\t\tprod = NEXT_TX(rp, prod);\n\t}\n\n\tif (prod < rp->prod)\n\t\trp->wrap_bit ^= TX_RING_KICK_WRAP;\n\trp->prod = prod;\n\n\tnw64(TX_RING_KICK(rp->tx_channel), rp->wrap_bit | (prod << 3));\n\n\tif (unlikely(niu_tx_avail(rp) <= (MAX_SKB_FRAGS + 1))) {\n\t\tnetif_tx_stop_queue(txq);\n\t\tif (niu_tx_avail(rp) > NIU_TX_WAKEUP_THRESH(rp))\n\t\t\tnetif_tx_wake_queue(txq);\n\t}\n\nout:\n\treturn NETDEV_TX_OK;\n\nout_drop:\n\trp->tx_errors++;\n\tkfree_skb(skb);\n\tgoto out;\n}\n\nstatic int niu_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tint err, orig_jumbo, new_jumbo;\n\n\torig_jumbo = (dev->mtu > ETH_DATA_LEN);\n\tnew_jumbo = (new_mtu > ETH_DATA_LEN);\n\n\tdev->mtu = new_mtu;\n\n\tif (!netif_running(dev) ||\n\t    (orig_jumbo == new_jumbo))\n\t\treturn 0;\n\n\tniu_full_shutdown(np, dev);\n\n\tniu_free_channels(np);\n\n\tniu_enable_napi(np);\n\n\terr = niu_alloc_channels(np);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock_irq(&np->lock);\n\n\terr = niu_init_hw(np);\n\tif (!err) {\n\t\ttimer_setup(&np->timer, niu_timer, 0);\n\t\tnp->timer.expires = jiffies + HZ;\n\n\t\terr = niu_enable_interrupts(np, 1);\n\t\tif (err)\n\t\t\tniu_stop_hw(np);\n\t}\n\n\tspin_unlock_irq(&np->lock);\n\n\tif (!err) {\n\t\tnetif_tx_start_all_queues(dev);\n\t\tif (np->link_config.loopback_mode != LOOPBACK_DISABLED)\n\t\t\tnetif_carrier_on(dev);\n\n\t\tadd_timer(&np->timer);\n\t}\n\n\treturn err;\n}\n\nstatic void niu_get_drvinfo(struct net_device *dev,\n\t\t\t    struct ethtool_drvinfo *info)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tstruct niu_vpd *vpd = &np->vpd;\n\n\tstrlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\n\tstrlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\n\tsnprintf(info->fw_version, sizeof(info->fw_version), \"%d.%d\",\n\t\tvpd->fcode_major, vpd->fcode_minor);\n\tif (np->parent->plat_type != PLAT_TYPE_NIU)\n\t\tstrlcpy(info->bus_info, pci_name(np->pdev),\n\t\t\tsizeof(info->bus_info));\n}\n\nstatic int niu_get_link_ksettings(struct net_device *dev,\n\t\t\t\t  struct ethtool_link_ksettings *cmd)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tstruct niu_link_config *lp;\n\n\tlp = &np->link_config;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->base.phy_address = np->phy_addr;\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tlp->supported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tlp->active_advertising);\n\tcmd->base.autoneg = lp->active_autoneg;\n\tcmd->base.speed = lp->active_speed;\n\tcmd->base.duplex = lp->active_duplex;\n\tcmd->base.port = (np->flags & NIU_FLAGS_FIBER) ? PORT_FIBRE : PORT_TP;\n\n\treturn 0;\n}\n\nstatic int niu_set_link_ksettings(struct net_device *dev,\n\t\t\t\t  const struct ethtool_link_ksettings *cmd)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tstruct niu_link_config *lp = &np->link_config;\n\n\tethtool_convert_link_mode_to_legacy_u32(&lp->advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\tlp->speed = cmd->base.speed;\n\tlp->duplex = cmd->base.duplex;\n\tlp->autoneg = cmd->base.autoneg;\n\treturn niu_init_link(np);\n}\n\nstatic u32 niu_get_msglevel(struct net_device *dev)\n{\n\tstruct niu *np = netdev_priv(dev);\n\treturn np->msg_enable;\n}\n\nstatic void niu_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tnp->msg_enable = value;\n}\n\nstatic int niu_nway_reset(struct net_device *dev)\n{\n\tstruct niu *np = netdev_priv(dev);\n\n\tif (np->link_config.autoneg)\n\t\treturn niu_init_link(np);\n\n\treturn 0;\n}\n\nstatic int niu_get_eeprom_len(struct net_device *dev)\n{\n\tstruct niu *np = netdev_priv(dev);\n\n\treturn np->eeprom_len;\n}\n\nstatic int niu_get_eeprom(struct net_device *dev,\n\t\t\t  struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tu32 offset, len, val;\n\n\toffset = eeprom->offset;\n\tlen = eeprom->len;\n\n\tif (offset + len < offset)\n\t\treturn -EINVAL;\n\tif (offset >= np->eeprom_len)\n\t\treturn -EINVAL;\n\tif (offset + len > np->eeprom_len)\n\t\tlen = eeprom->len = np->eeprom_len - offset;\n\n\tif (offset & 3) {\n\t\tu32 b_offset, b_count;\n\n\t\tb_offset = offset & 3;\n\t\tb_count = 4 - b_offset;\n\t\tif (b_count > len)\n\t\t\tb_count = len;\n\n\t\tval = nr64(ESPC_NCR((offset - b_offset) / 4));\n\t\tmemcpy(data, ((char *)&val) + b_offset, b_count);\n\t\tdata += b_count;\n\t\tlen -= b_count;\n\t\toffset += b_count;\n\t}\n\twhile (len >= 4) {\n\t\tval = nr64(ESPC_NCR(offset / 4));\n\t\tmemcpy(data, &val, 4);\n\t\tdata += 4;\n\t\tlen -= 4;\n\t\toffset += 4;\n\t}\n\tif (len) {\n\t\tval = nr64(ESPC_NCR(offset / 4));\n\t\tmemcpy(data, &val, len);\n\t}\n\treturn 0;\n}\n\nstatic void niu_ethflow_to_l3proto(int flow_type, u8 *pid)\n{\n\tswitch (flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\t*pid = IPPROTO_TCP;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\tcase UDP_V6_FLOW:\n\t\t*pid = IPPROTO_UDP;\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\tcase SCTP_V6_FLOW:\n\t\t*pid = IPPROTO_SCTP;\n\t\tbreak;\n\tcase AH_V4_FLOW:\n\tcase AH_V6_FLOW:\n\t\t*pid = IPPROTO_AH;\n\t\tbreak;\n\tcase ESP_V4_FLOW:\n\tcase ESP_V6_FLOW:\n\t\t*pid = IPPROTO_ESP;\n\t\tbreak;\n\tdefault:\n\t\t*pid = 0;\n\t\tbreak;\n\t}\n}\n\nstatic int niu_class_to_ethflow(u64 class, int *flow_type)\n{\n\tswitch (class) {\n\tcase CLASS_CODE_TCP_IPV4:\n\t\t*flow_type = TCP_V4_FLOW;\n\t\tbreak;\n\tcase CLASS_CODE_UDP_IPV4:\n\t\t*flow_type = UDP_V4_FLOW;\n\t\tbreak;\n\tcase CLASS_CODE_AH_ESP_IPV4:\n\t\t*flow_type = AH_V4_FLOW;\n\t\tbreak;\n\tcase CLASS_CODE_SCTP_IPV4:\n\t\t*flow_type = SCTP_V4_FLOW;\n\t\tbreak;\n\tcase CLASS_CODE_TCP_IPV6:\n\t\t*flow_type = TCP_V6_FLOW;\n\t\tbreak;\n\tcase CLASS_CODE_UDP_IPV6:\n\t\t*flow_type = UDP_V6_FLOW;\n\t\tbreak;\n\tcase CLASS_CODE_AH_ESP_IPV6:\n\t\t*flow_type = AH_V6_FLOW;\n\t\tbreak;\n\tcase CLASS_CODE_SCTP_IPV6:\n\t\t*flow_type = SCTP_V6_FLOW;\n\t\tbreak;\n\tcase CLASS_CODE_USER_PROG1:\n\tcase CLASS_CODE_USER_PROG2:\n\tcase CLASS_CODE_USER_PROG3:\n\tcase CLASS_CODE_USER_PROG4:\n\t\t*flow_type = IP_USER_FLOW;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_ethflow_to_class(int flow_type, u64 *class)\n{\n\tswitch (flow_type) {\n\tcase TCP_V4_FLOW:\n\t\t*class = CLASS_CODE_TCP_IPV4;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\t*class = CLASS_CODE_UDP_IPV4;\n\t\tbreak;\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\t\t*class = CLASS_CODE_AH_ESP_IPV4;\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\t\t*class = CLASS_CODE_SCTP_IPV4;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\t*class = CLASS_CODE_TCP_IPV6;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\t*class = CLASS_CODE_UDP_IPV6;\n\t\tbreak;\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\t\t*class = CLASS_CODE_AH_ESP_IPV6;\n\t\tbreak;\n\tcase SCTP_V6_FLOW:\n\t\t*class = CLASS_CODE_SCTP_IPV6;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic u64 niu_flowkey_to_ethflow(u64 flow_key)\n{\n\tu64 ethflow = 0;\n\n\tif (flow_key & FLOW_KEY_L2DA)\n\t\tethflow |= RXH_L2DA;\n\tif (flow_key & FLOW_KEY_VLAN)\n\t\tethflow |= RXH_VLAN;\n\tif (flow_key & FLOW_KEY_IPSA)\n\t\tethflow |= RXH_IP_SRC;\n\tif (flow_key & FLOW_KEY_IPDA)\n\t\tethflow |= RXH_IP_DST;\n\tif (flow_key & FLOW_KEY_PROTO)\n\t\tethflow |= RXH_L3_PROTO;\n\tif (flow_key & (FLOW_KEY_L4_BYTE12 << FLOW_KEY_L4_0_SHIFT))\n\t\tethflow |= RXH_L4_B_0_1;\n\tif (flow_key & (FLOW_KEY_L4_BYTE12 << FLOW_KEY_L4_1_SHIFT))\n\t\tethflow |= RXH_L4_B_2_3;\n\n\treturn ethflow;\n\n}\n\nstatic int niu_ethflow_to_flowkey(u64 ethflow, u64 *flow_key)\n{\n\tu64 key = 0;\n\n\tif (ethflow & RXH_L2DA)\n\t\tkey |= FLOW_KEY_L2DA;\n\tif (ethflow & RXH_VLAN)\n\t\tkey |= FLOW_KEY_VLAN;\n\tif (ethflow & RXH_IP_SRC)\n\t\tkey |= FLOW_KEY_IPSA;\n\tif (ethflow & RXH_IP_DST)\n\t\tkey |= FLOW_KEY_IPDA;\n\tif (ethflow & RXH_L3_PROTO)\n\t\tkey |= FLOW_KEY_PROTO;\n\tif (ethflow & RXH_L4_B_0_1)\n\t\tkey |= (FLOW_KEY_L4_BYTE12 << FLOW_KEY_L4_0_SHIFT);\n\tif (ethflow & RXH_L4_B_2_3)\n\t\tkey |= (FLOW_KEY_L4_BYTE12 << FLOW_KEY_L4_1_SHIFT);\n\n\t*flow_key = key;\n\n\treturn 1;\n\n}\n\nstatic int niu_get_hash_opts(struct niu *np, struct ethtool_rxnfc *nfc)\n{\n\tu64 class;\n\n\tnfc->data = 0;\n\n\tif (!niu_ethflow_to_class(nfc->flow_type, &class))\n\t\treturn -EINVAL;\n\n\tif (np->parent->tcam_key[class - CLASS_CODE_USER_PROG1] &\n\t    TCAM_KEY_DISC)\n\t\tnfc->data = RXH_DISCARD;\n\telse\n\t\tnfc->data = niu_flowkey_to_ethflow(np->parent->flow_key[class -\n\t\t\t\t\t\t      CLASS_CODE_USER_PROG1]);\n\treturn 0;\n}\n\nstatic void niu_get_ip4fs_from_tcam_key(struct niu_tcam_entry *tp,\n\t\t\t\t\tstruct ethtool_rx_flow_spec *fsp)\n{\n\tu32 tmp;\n\tu16 prt;\n\n\ttmp = (tp->key[3] & TCAM_V4KEY3_SADDR) >> TCAM_V4KEY3_SADDR_SHIFT;\n\tfsp->h_u.tcp_ip4_spec.ip4src = cpu_to_be32(tmp);\n\n\ttmp = (tp->key[3] & TCAM_V4KEY3_DADDR) >> TCAM_V4KEY3_DADDR_SHIFT;\n\tfsp->h_u.tcp_ip4_spec.ip4dst = cpu_to_be32(tmp);\n\n\ttmp = (tp->key_mask[3] & TCAM_V4KEY3_SADDR) >> TCAM_V4KEY3_SADDR_SHIFT;\n\tfsp->m_u.tcp_ip4_spec.ip4src = cpu_to_be32(tmp);\n\n\ttmp = (tp->key_mask[3] & TCAM_V4KEY3_DADDR) >> TCAM_V4KEY3_DADDR_SHIFT;\n\tfsp->m_u.tcp_ip4_spec.ip4dst = cpu_to_be32(tmp);\n\n\tfsp->h_u.tcp_ip4_spec.tos = (tp->key[2] & TCAM_V4KEY2_TOS) >>\n\t\tTCAM_V4KEY2_TOS_SHIFT;\n\tfsp->m_u.tcp_ip4_spec.tos = (tp->key_mask[2] & TCAM_V4KEY2_TOS) >>\n\t\tTCAM_V4KEY2_TOS_SHIFT;\n\n\tswitch (fsp->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\t\tprt = ((tp->key[2] & TCAM_V4KEY2_PORT_SPI) >>\n\t\t\tTCAM_V4KEY2_PORT_SPI_SHIFT) >> 16;\n\t\tfsp->h_u.tcp_ip4_spec.psrc = cpu_to_be16(prt);\n\n\t\tprt = ((tp->key[2] & TCAM_V4KEY2_PORT_SPI) >>\n\t\t\tTCAM_V4KEY2_PORT_SPI_SHIFT) & 0xffff;\n\t\tfsp->h_u.tcp_ip4_spec.pdst = cpu_to_be16(prt);\n\n\t\tprt = ((tp->key_mask[2] & TCAM_V4KEY2_PORT_SPI) >>\n\t\t\tTCAM_V4KEY2_PORT_SPI_SHIFT) >> 16;\n\t\tfsp->m_u.tcp_ip4_spec.psrc = cpu_to_be16(prt);\n\n\t\tprt = ((tp->key_mask[2] & TCAM_V4KEY2_PORT_SPI) >>\n\t\t\t TCAM_V4KEY2_PORT_SPI_SHIFT) & 0xffff;\n\t\tfsp->m_u.tcp_ip4_spec.pdst = cpu_to_be16(prt);\n\t\tbreak;\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\t\ttmp = (tp->key[2] & TCAM_V4KEY2_PORT_SPI) >>\n\t\t\tTCAM_V4KEY2_PORT_SPI_SHIFT;\n\t\tfsp->h_u.ah_ip4_spec.spi = cpu_to_be32(tmp);\n\n\t\ttmp = (tp->key_mask[2] & TCAM_V4KEY2_PORT_SPI) >>\n\t\t\tTCAM_V4KEY2_PORT_SPI_SHIFT;\n\t\tfsp->m_u.ah_ip4_spec.spi = cpu_to_be32(tmp);\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\ttmp = (tp->key[2] & TCAM_V4KEY2_PORT_SPI) >>\n\t\t\tTCAM_V4KEY2_PORT_SPI_SHIFT;\n\t\tfsp->h_u.usr_ip4_spec.l4_4_bytes = cpu_to_be32(tmp);\n\n\t\ttmp = (tp->key_mask[2] & TCAM_V4KEY2_PORT_SPI) >>\n\t\t\tTCAM_V4KEY2_PORT_SPI_SHIFT;\n\t\tfsp->m_u.usr_ip4_spec.l4_4_bytes = cpu_to_be32(tmp);\n\n\t\tfsp->h_u.usr_ip4_spec.proto =\n\t\t\t(tp->key[2] & TCAM_V4KEY2_PROTO) >>\n\t\t\tTCAM_V4KEY2_PROTO_SHIFT;\n\t\tfsp->m_u.usr_ip4_spec.proto =\n\t\t\t(tp->key_mask[2] & TCAM_V4KEY2_PROTO) >>\n\t\t\tTCAM_V4KEY2_PROTO_SHIFT;\n\n\t\tfsp->h_u.usr_ip4_spec.ip_ver = ETH_RX_NFC_IP4;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int niu_get_ethtool_tcam_entry(struct niu *np,\n\t\t\t\t      struct ethtool_rxnfc *nfc)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_tcam_entry *tp;\n\tstruct ethtool_rx_flow_spec *fsp = &nfc->fs;\n\tu16 idx;\n\tu64 class;\n\tint ret = 0;\n\n\tidx = tcam_get_index(np, (u16)nfc->fs.location);\n\n\ttp = &parent->tcam[idx];\n\tif (!tp->valid) {\n\t\tnetdev_info(np->dev, \"niu%d: entry [%d] invalid for idx[%d]\\n\",\n\t\t\t    parent->index, (u16)nfc->fs.location, idx);\n\t\treturn -EINVAL;\n\t}\n\n\t/* fill the flow spec entry */\n\tclass = (tp->key[0] & TCAM_V4KEY0_CLASS_CODE) >>\n\t\tTCAM_V4KEY0_CLASS_CODE_SHIFT;\n\tret = niu_class_to_ethflow(class, &fsp->flow_type);\n\tif (ret < 0) {\n\t\tnetdev_info(np->dev, \"niu%d: niu_class_to_ethflow failed\\n\",\n\t\t\t    parent->index);\n\t\tgoto out;\n\t}\n\n\tif (fsp->flow_type == AH_V4_FLOW || fsp->flow_type == AH_V6_FLOW) {\n\t\tu32 proto = (tp->key[2] & TCAM_V4KEY2_PROTO) >>\n\t\t\tTCAM_V4KEY2_PROTO_SHIFT;\n\t\tif (proto == IPPROTO_ESP) {\n\t\t\tif (fsp->flow_type == AH_V4_FLOW)\n\t\t\t\tfsp->flow_type = ESP_V4_FLOW;\n\t\t\telse\n\t\t\t\tfsp->flow_type = ESP_V6_FLOW;\n\t\t}\n\t}\n\n\tswitch (fsp->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\t\tniu_get_ip4fs_from_tcam_key(tp, fsp);\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\tcase SCTP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\t\t/* Not yet implemented */\n\t\tret = -EINVAL;\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\tniu_get_ip4fs_from_tcam_key(tp, fsp);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (tp->assoc_data & TCAM_ASSOCDATA_DISC)\n\t\tfsp->ring_cookie = RX_CLS_FLOW_DISC;\n\telse\n\t\tfsp->ring_cookie = (tp->assoc_data & TCAM_ASSOCDATA_OFFSET) >>\n\t\t\tTCAM_ASSOCDATA_OFFSET_SHIFT;\n\n\t/* put the tcam size here */\n\tnfc->data = tcam_get_size(np);\nout:\n\treturn ret;\n}\n\nstatic int niu_get_ethtool_tcam_all(struct niu *np,\n\t\t\t\t    struct ethtool_rxnfc *nfc,\n\t\t\t\t    u32 *rule_locs)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_tcam_entry *tp;\n\tint i, idx, cnt;\n\tunsigned long flags;\n\tint ret = 0;\n\n\t/* put the tcam size here */\n\tnfc->data = tcam_get_size(np);\n\n\tniu_lock_parent(np, flags);\n\tfor (cnt = 0, i = 0; i < nfc->data; i++) {\n\t\tidx = tcam_get_index(np, i);\n\t\ttp = &parent->tcam[idx];\n\t\tif (!tp->valid)\n\t\t\tcontinue;\n\t\tif (cnt == nfc->rule_cnt) {\n\t\t\tret = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\t\trule_locs[cnt] = i;\n\t\tcnt++;\n\t}\n\tniu_unlock_parent(np, flags);\n\n\tnfc->rule_cnt = cnt;\n\n\treturn ret;\n}\n\nstatic int niu_get_nfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\n\t\t       u32 *rule_locs)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tint ret = 0;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXFH:\n\t\tret = niu_get_hash_opts(np, cmd);\n\t\tbreak;\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = np->num_rx_rings;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tcmd->rule_cnt = tcam_get_valid_entry_cnt(np);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tret = niu_get_ethtool_tcam_entry(np, cmd);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\tret = niu_get_ethtool_tcam_all(np, cmd, rule_locs);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int niu_set_hash_opts(struct niu *np, struct ethtool_rxnfc *nfc)\n{\n\tu64 class;\n\tu64 flow_key = 0;\n\tunsigned long flags;\n\n\tif (!niu_ethflow_to_class(nfc->flow_type, &class))\n\t\treturn -EINVAL;\n\n\tif (class < CLASS_CODE_USER_PROG1 ||\n\t    class > CLASS_CODE_SCTP_IPV6)\n\t\treturn -EINVAL;\n\n\tif (nfc->data & RXH_DISCARD) {\n\t\tniu_lock_parent(np, flags);\n\t\tflow_key = np->parent->tcam_key[class -\n\t\t\t\t\t       CLASS_CODE_USER_PROG1];\n\t\tflow_key |= TCAM_KEY_DISC;\n\t\tnw64(TCAM_KEY(class - CLASS_CODE_USER_PROG1), flow_key);\n\t\tnp->parent->tcam_key[class - CLASS_CODE_USER_PROG1] = flow_key;\n\t\tniu_unlock_parent(np, flags);\n\t\treturn 0;\n\t} else {\n\t\t/* Discard was set before, but is not set now */\n\t\tif (np->parent->tcam_key[class - CLASS_CODE_USER_PROG1] &\n\t\t    TCAM_KEY_DISC) {\n\t\t\tniu_lock_parent(np, flags);\n\t\t\tflow_key = np->parent->tcam_key[class -\n\t\t\t\t\t       CLASS_CODE_USER_PROG1];\n\t\t\tflow_key &= ~TCAM_KEY_DISC;\n\t\t\tnw64(TCAM_KEY(class - CLASS_CODE_USER_PROG1),\n\t\t\t     flow_key);\n\t\t\tnp->parent->tcam_key[class - CLASS_CODE_USER_PROG1] =\n\t\t\t\tflow_key;\n\t\t\tniu_unlock_parent(np, flags);\n\t\t}\n\t}\n\n\tif (!niu_ethflow_to_flowkey(nfc->data, &flow_key))\n\t\treturn -EINVAL;\n\n\tniu_lock_parent(np, flags);\n\tnw64(FLOW_KEY(class - CLASS_CODE_USER_PROG1), flow_key);\n\tnp->parent->flow_key[class - CLASS_CODE_USER_PROG1] = flow_key;\n\tniu_unlock_parent(np, flags);\n\n\treturn 0;\n}\n\nstatic void niu_get_tcamkey_from_ip4fs(struct ethtool_rx_flow_spec *fsp,\n\t\t\t\t       struct niu_tcam_entry *tp,\n\t\t\t\t       int l2_rdc_tab, u64 class)\n{\n\tu8 pid = 0;\n\tu32 sip, dip, sipm, dipm, spi, spim;\n\tu16 sport, dport, spm, dpm;\n\n\tsip = be32_to_cpu(fsp->h_u.tcp_ip4_spec.ip4src);\n\tsipm = be32_to_cpu(fsp->m_u.tcp_ip4_spec.ip4src);\n\tdip = be32_to_cpu(fsp->h_u.tcp_ip4_spec.ip4dst);\n\tdipm = be32_to_cpu(fsp->m_u.tcp_ip4_spec.ip4dst);\n\n\ttp->key[0] = class << TCAM_V4KEY0_CLASS_CODE_SHIFT;\n\ttp->key_mask[0] = TCAM_V4KEY0_CLASS_CODE;\n\ttp->key[1] = (u64)l2_rdc_tab << TCAM_V4KEY1_L2RDCNUM_SHIFT;\n\ttp->key_mask[1] = TCAM_V4KEY1_L2RDCNUM;\n\n\ttp->key[3] = (u64)sip << TCAM_V4KEY3_SADDR_SHIFT;\n\ttp->key[3] |= dip;\n\n\ttp->key_mask[3] = (u64)sipm << TCAM_V4KEY3_SADDR_SHIFT;\n\ttp->key_mask[3] |= dipm;\n\n\ttp->key[2] |= ((u64)fsp->h_u.tcp_ip4_spec.tos <<\n\t\t       TCAM_V4KEY2_TOS_SHIFT);\n\ttp->key_mask[2] |= ((u64)fsp->m_u.tcp_ip4_spec.tos <<\n\t\t\t    TCAM_V4KEY2_TOS_SHIFT);\n\tswitch (fsp->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\t\tsport = be16_to_cpu(fsp->h_u.tcp_ip4_spec.psrc);\n\t\tspm = be16_to_cpu(fsp->m_u.tcp_ip4_spec.psrc);\n\t\tdport = be16_to_cpu(fsp->h_u.tcp_ip4_spec.pdst);\n\t\tdpm = be16_to_cpu(fsp->m_u.tcp_ip4_spec.pdst);\n\n\t\ttp->key[2] |= (((u64)sport << 16) | dport);\n\t\ttp->key_mask[2] |= (((u64)spm << 16) | dpm);\n\t\tniu_ethflow_to_l3proto(fsp->flow_type, &pid);\n\t\tbreak;\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\t\tspi = be32_to_cpu(fsp->h_u.ah_ip4_spec.spi);\n\t\tspim = be32_to_cpu(fsp->m_u.ah_ip4_spec.spi);\n\n\t\ttp->key[2] |= spi;\n\t\ttp->key_mask[2] |= spim;\n\t\tniu_ethflow_to_l3proto(fsp->flow_type, &pid);\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\tspi = be32_to_cpu(fsp->h_u.usr_ip4_spec.l4_4_bytes);\n\t\tspim = be32_to_cpu(fsp->m_u.usr_ip4_spec.l4_4_bytes);\n\n\t\ttp->key[2] |= spi;\n\t\ttp->key_mask[2] |= spim;\n\t\tpid = fsp->h_u.usr_ip4_spec.proto;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttp->key[2] |= ((u64)pid << TCAM_V4KEY2_PROTO_SHIFT);\n\tif (pid) {\n\t\ttp->key_mask[2] |= TCAM_V4KEY2_PROTO;\n\t}\n}\n\nstatic int niu_add_ethtool_tcam_entry(struct niu *np,\n\t\t\t\t      struct ethtool_rxnfc *nfc)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_tcam_entry *tp;\n\tstruct ethtool_rx_flow_spec *fsp = &nfc->fs;\n\tstruct niu_rdc_tables *rdc_table = &parent->rdc_group_cfg[np->port];\n\tint l2_rdc_table = rdc_table->first_table_num;\n\tu16 idx;\n\tu64 class;\n\tunsigned long flags;\n\tint err, ret;\n\n\tret = 0;\n\n\tidx = nfc->fs.location;\n\tif (idx >= tcam_get_size(np))\n\t\treturn -EINVAL;\n\n\tif (fsp->flow_type == IP_USER_FLOW) {\n\t\tint i;\n\t\tint add_usr_cls = 0;\n\t\tstruct ethtool_usrip4_spec *uspec = &fsp->h_u.usr_ip4_spec;\n\t\tstruct ethtool_usrip4_spec *umask = &fsp->m_u.usr_ip4_spec;\n\n\t\tif (uspec->ip_ver != ETH_RX_NFC_IP4)\n\t\t\treturn -EINVAL;\n\n\t\tniu_lock_parent(np, flags);\n\n\t\tfor (i = 0; i < NIU_L3_PROG_CLS; i++) {\n\t\t\tif (parent->l3_cls[i]) {\n\t\t\t\tif (uspec->proto == parent->l3_cls_pid[i]) {\n\t\t\t\t\tclass = parent->l3_cls[i];\n\t\t\t\t\tparent->l3_cls_refcnt[i]++;\n\t\t\t\t\tadd_usr_cls = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Program new user IP class */\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tclass = CLASS_CODE_USER_PROG1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tclass = CLASS_CODE_USER_PROG2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tclass = CLASS_CODE_USER_PROG3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tclass = CLASS_CODE_USER_PROG4;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tclass = CLASS_CODE_UNRECOG;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tret = tcam_user_ip_class_set(np, class, 0,\n\t\t\t\t\t\t\t     uspec->proto,\n\t\t\t\t\t\t\t     uspec->tos,\n\t\t\t\t\t\t\t     umask->tos);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tret = tcam_user_ip_class_enable(np, class, 1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t\tparent->l3_cls[i] = class;\n\t\t\t\tparent->l3_cls_pid[i] = uspec->proto;\n\t\t\t\tparent->l3_cls_refcnt[i]++;\n\t\t\t\tadd_usr_cls = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!add_usr_cls) {\n\t\t\tnetdev_info(np->dev, \"niu%d: %s(): Could not find/insert class for pid %d\\n\",\n\t\t\t\t    parent->index, __func__, uspec->proto);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tniu_unlock_parent(np, flags);\n\t} else {\n\t\tif (!niu_ethflow_to_class(fsp->flow_type, &class)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tniu_lock_parent(np, flags);\n\n\tidx = tcam_get_index(np, idx);\n\ttp = &parent->tcam[idx];\n\n\tmemset(tp, 0, sizeof(*tp));\n\n\t/* fill in the tcam key and mask */\n\tswitch (fsp->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\t\tniu_get_tcamkey_from_ip4fs(fsp, tp, l2_rdc_table, class);\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\tcase SCTP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\t\t/* Not yet implemented */\n\t\tnetdev_info(np->dev, \"niu%d: In %s(): flow %d for IPv6 not implemented\\n\",\n\t\t\t    parent->index, __func__, fsp->flow_type);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\tcase IP_USER_FLOW:\n\t\tniu_get_tcamkey_from_ip4fs(fsp, tp, l2_rdc_table, class);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_info(np->dev, \"niu%d: In %s(): Unknown flow type %d\\n\",\n\t\t\t    parent->index, __func__, fsp->flow_type);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* fill in the assoc data */\n\tif (fsp->ring_cookie == RX_CLS_FLOW_DISC) {\n\t\ttp->assoc_data = TCAM_ASSOCDATA_DISC;\n\t} else {\n\t\tif (fsp->ring_cookie >= np->num_rx_rings) {\n\t\t\tnetdev_info(np->dev, \"niu%d: In %s(): Invalid RX ring %lld\\n\",\n\t\t\t\t    parent->index, __func__,\n\t\t\t\t    (long long)fsp->ring_cookie);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ttp->assoc_data = (TCAM_ASSOCDATA_TRES_USE_OFFSET |\n\t\t\t\t  (fsp->ring_cookie <<\n\t\t\t\t   TCAM_ASSOCDATA_OFFSET_SHIFT));\n\t}\n\n\terr = tcam_write(np, idx, tp->key, tp->key_mask);\n\tif (err) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\terr = tcam_assoc_write(np, idx, tp->assoc_data);\n\tif (err) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* validate the entry */\n\ttp->valid = 1;\n\tnp->clas.tcam_valid_entries++;\nout:\n\tniu_unlock_parent(np, flags);\n\n\treturn ret;\n}\n\nstatic int niu_del_ethtool_tcam_entry(struct niu *np, u32 loc)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_tcam_entry *tp;\n\tu16 idx;\n\tunsigned long flags;\n\tu64 class;\n\tint ret = 0;\n\n\tif (loc >= tcam_get_size(np))\n\t\treturn -EINVAL;\n\n\tniu_lock_parent(np, flags);\n\n\tidx = tcam_get_index(np, loc);\n\ttp = &parent->tcam[idx];\n\n\t/* if the entry is of a user defined class, then update*/\n\tclass = (tp->key[0] & TCAM_V4KEY0_CLASS_CODE) >>\n\t\tTCAM_V4KEY0_CLASS_CODE_SHIFT;\n\n\tif (class >= CLASS_CODE_USER_PROG1 && class <= CLASS_CODE_USER_PROG4) {\n\t\tint i;\n\t\tfor (i = 0; i < NIU_L3_PROG_CLS; i++) {\n\t\t\tif (parent->l3_cls[i] == class) {\n\t\t\t\tparent->l3_cls_refcnt[i]--;\n\t\t\t\tif (!parent->l3_cls_refcnt[i]) {\n\t\t\t\t\t/* disable class */\n\t\t\t\t\tret = tcam_user_ip_class_enable(np,\n\t\t\t\t\t\t\t\t\tclass,\n\t\t\t\t\t\t\t\t\t0);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\tparent->l3_cls[i] = 0;\n\t\t\t\t\tparent->l3_cls_pid[i] = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == NIU_L3_PROG_CLS) {\n\t\t\tnetdev_info(np->dev, \"niu%d: In %s(): Usr class 0x%llx not found\\n\",\n\t\t\t\t    parent->index, __func__,\n\t\t\t\t    (unsigned long long)class);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = tcam_flush(np, idx);\n\tif (ret)\n\t\tgoto out;\n\n\t/* invalidate the entry */\n\ttp->valid = 0;\n\tnp->clas.tcam_valid_entries--;\nout:\n\tniu_unlock_parent(np, flags);\n\n\treturn ret;\n}\n\nstatic int niu_set_nfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tint ret = 0;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\tret = niu_set_hash_opts(np, cmd);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\tret = niu_add_ethtool_tcam_entry(np, cmd);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\tret = niu_del_ethtool_tcam_entry(np, cmd->fs.location);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct {\n\tconst char string[ETH_GSTRING_LEN];\n} niu_xmac_stat_keys[] = {\n\t{ \"tx_frames\" },\n\t{ \"tx_bytes\" },\n\t{ \"tx_fifo_errors\" },\n\t{ \"tx_overflow_errors\" },\n\t{ \"tx_max_pkt_size_errors\" },\n\t{ \"tx_underflow_errors\" },\n\t{ \"rx_local_faults\" },\n\t{ \"rx_remote_faults\" },\n\t{ \"rx_link_faults\" },\n\t{ \"rx_align_errors\" },\n\t{ \"rx_frags\" },\n\t{ \"rx_mcasts\" },\n\t{ \"rx_bcasts\" },\n\t{ \"rx_hist_cnt1\" },\n\t{ \"rx_hist_cnt2\" },\n\t{ \"rx_hist_cnt3\" },\n\t{ \"rx_hist_cnt4\" },\n\t{ \"rx_hist_cnt5\" },\n\t{ \"rx_hist_cnt6\" },\n\t{ \"rx_hist_cnt7\" },\n\t{ \"rx_octets\" },\n\t{ \"rx_code_violations\" },\n\t{ \"rx_len_errors\" },\n\t{ \"rx_crc_errors\" },\n\t{ \"rx_underflows\" },\n\t{ \"rx_overflows\" },\n\t{ \"pause_off_state\" },\n\t{ \"pause_on_state\" },\n\t{ \"pause_received\" },\n};\n\n#define NUM_XMAC_STAT_KEYS\tARRAY_SIZE(niu_xmac_stat_keys)\n\nstatic const struct {\n\tconst char string[ETH_GSTRING_LEN];\n} niu_bmac_stat_keys[] = {\n\t{ \"tx_underflow_errors\" },\n\t{ \"tx_max_pkt_size_errors\" },\n\t{ \"tx_bytes\" },\n\t{ \"tx_frames\" },\n\t{ \"rx_overflows\" },\n\t{ \"rx_frames\" },\n\t{ \"rx_align_errors\" },\n\t{ \"rx_crc_errors\" },\n\t{ \"rx_len_errors\" },\n\t{ \"pause_off_state\" },\n\t{ \"pause_on_state\" },\n\t{ \"pause_received\" },\n};\n\n#define NUM_BMAC_STAT_KEYS\tARRAY_SIZE(niu_bmac_stat_keys)\n\nstatic const struct {\n\tconst char string[ETH_GSTRING_LEN];\n} niu_rxchan_stat_keys[] = {\n\t{ \"rx_channel\" },\n\t{ \"rx_packets\" },\n\t{ \"rx_bytes\" },\n\t{ \"rx_dropped\" },\n\t{ \"rx_errors\" },\n};\n\n#define NUM_RXCHAN_STAT_KEYS\tARRAY_SIZE(niu_rxchan_stat_keys)\n\nstatic const struct {\n\tconst char string[ETH_GSTRING_LEN];\n} niu_txchan_stat_keys[] = {\n\t{ \"tx_channel\" },\n\t{ \"tx_packets\" },\n\t{ \"tx_bytes\" },\n\t{ \"tx_errors\" },\n};\n\n#define NUM_TXCHAN_STAT_KEYS\tARRAY_SIZE(niu_txchan_stat_keys)\n\nstatic void niu_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tint i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tif (np->flags & NIU_FLAGS_XMAC) {\n\t\tmemcpy(data, niu_xmac_stat_keys,\n\t\t       sizeof(niu_xmac_stat_keys));\n\t\tdata += sizeof(niu_xmac_stat_keys);\n\t} else {\n\t\tmemcpy(data, niu_bmac_stat_keys,\n\t\t       sizeof(niu_bmac_stat_keys));\n\t\tdata += sizeof(niu_bmac_stat_keys);\n\t}\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tmemcpy(data, niu_rxchan_stat_keys,\n\t\t       sizeof(niu_rxchan_stat_keys));\n\t\tdata += sizeof(niu_rxchan_stat_keys);\n\t}\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tmemcpy(data, niu_txchan_stat_keys,\n\t\t       sizeof(niu_txchan_stat_keys));\n\t\tdata += sizeof(niu_txchan_stat_keys);\n\t}\n}\n\nstatic int niu_get_sset_count(struct net_device *dev, int stringset)\n{\n\tstruct niu *np = netdev_priv(dev);\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn -EINVAL;\n\n\treturn (np->flags & NIU_FLAGS_XMAC ?\n\t\t NUM_XMAC_STAT_KEYS :\n\t\t NUM_BMAC_STAT_KEYS) +\n\t\t(np->num_rx_rings * NUM_RXCHAN_STAT_KEYS) +\n\t\t(np->num_tx_rings * NUM_TXCHAN_STAT_KEYS);\n}\n\nstatic void niu_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t  struct ethtool_stats *stats, u64 *data)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tint i;\n\n\tniu_sync_mac_stats(np);\n\tif (np->flags & NIU_FLAGS_XMAC) {\n\t\tmemcpy(data, &np->mac_stats.xmac,\n\t\t       sizeof(struct niu_xmac_stats));\n\t\tdata += (sizeof(struct niu_xmac_stats) / sizeof(u64));\n\t} else {\n\t\tmemcpy(data, &np->mac_stats.bmac,\n\t\t       sizeof(struct niu_bmac_stats));\n\t\tdata += (sizeof(struct niu_bmac_stats) / sizeof(u64));\n\t}\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\tniu_sync_rx_discard_stats(np, rp, 0);\n\n\t\tdata[0] = rp->rx_channel;\n\t\tdata[1] = rp->rx_packets;\n\t\tdata[2] = rp->rx_bytes;\n\t\tdata[3] = rp->rx_dropped;\n\t\tdata[4] = rp->rx_errors;\n\t\tdata += 5;\n\t}\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\n\t\tdata[0] = rp->tx_channel;\n\t\tdata[1] = rp->tx_packets;\n\t\tdata[2] = rp->tx_bytes;\n\t\tdata[3] = rp->tx_errors;\n\t\tdata += 4;\n\t}\n}\n\nstatic u64 niu_led_state_save(struct niu *np)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\treturn nr64_mac(XMAC_CONFIG);\n\telse\n\t\treturn nr64_mac(BMAC_XIF_CONFIG);\n}\n\nstatic void niu_led_state_restore(struct niu *np, u64 val)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tnw64_mac(XMAC_CONFIG, val);\n\telse\n\t\tnw64_mac(BMAC_XIF_CONFIG, val);\n}\n\nstatic void niu_force_led(struct niu *np, int on)\n{\n\tu64 val, reg, bit;\n\n\tif (np->flags & NIU_FLAGS_XMAC) {\n\t\treg = XMAC_CONFIG;\n\t\tbit = XMAC_CONFIG_FORCE_LED_ON;\n\t} else {\n\t\treg = BMAC_XIF_CONFIG;\n\t\tbit = BMAC_XIF_CONFIG_LINK_LED;\n\t}\n\n\tval = nr64_mac(reg);\n\tif (on)\n\t\tval |= bit;\n\telse\n\t\tval &= ~bit;\n\tnw64_mac(reg, val);\n}\n\nstatic int niu_set_phys_id(struct net_device *dev,\n\t\t\t   enum ethtool_phys_id_state state)\n\n{\n\tstruct niu *np = netdev_priv(dev);\n\n\tif (!netif_running(dev))\n\t\treturn -EAGAIN;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\tnp->orig_led_state = niu_led_state_save(np);\n\t\treturn 1;\t/* cycle on/off once per second */\n\n\tcase ETHTOOL_ID_ON:\n\t\tniu_force_led(np, 1);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_OFF:\n\t\tniu_force_led(np, 0);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tniu_led_state_restore(np, np->orig_led_state);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops niu_ethtool_ops = {\n\t.get_drvinfo\t\t= niu_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_msglevel\t\t= niu_get_msglevel,\n\t.set_msglevel\t\t= niu_set_msglevel,\n\t.nway_reset\t\t= niu_nway_reset,\n\t.get_eeprom_len\t\t= niu_get_eeprom_len,\n\t.get_eeprom\t\t= niu_get_eeprom,\n\t.get_strings\t\t= niu_get_strings,\n\t.get_sset_count\t\t= niu_get_sset_count,\n\t.get_ethtool_stats\t= niu_get_ethtool_stats,\n\t.set_phys_id\t\t= niu_set_phys_id,\n\t.get_rxnfc\t\t= niu_get_nfc,\n\t.set_rxnfc\t\t= niu_set_nfc,\n\t.get_link_ksettings\t= niu_get_link_ksettings,\n\t.set_link_ksettings\t= niu_set_link_ksettings,\n};\n\nstatic int niu_ldg_assign_ldn(struct niu *np, struct niu_parent *parent,\n\t\t\t      int ldg, int ldn)\n{\n\tif (ldg < NIU_LDG_MIN || ldg > NIU_LDG_MAX)\n\t\treturn -EINVAL;\n\tif (ldn < 0 || ldn > LDN_MAX)\n\t\treturn -EINVAL;\n\n\tparent->ldg_map[ldn] = ldg;\n\n\tif (np->parent->plat_type == PLAT_TYPE_NIU) {\n\t\t/* On N2 NIU, the ldn-->ldg assignments are setup and fixed by\n\t\t * the firmware, and we're not supposed to change them.\n\t\t * Validate the mapping, because if it's wrong we probably\n\t\t * won't get any interrupts and that's painful to debug.\n\t\t */\n\t\tif (nr64(LDG_NUM(ldn)) != ldg) {\n\t\t\tdev_err(np->device, \"Port %u, mis-matched LDG assignment for ldn %d, should be %d is %llu\\n\",\n\t\t\t\tnp->port, ldn, ldg,\n\t\t\t\t(unsigned long long) nr64(LDG_NUM(ldn)));\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else\n\t\tnw64(LDG_NUM(ldn), ldg);\n\n\treturn 0;\n}\n\nstatic int niu_set_ldg_timer_res(struct niu *np, int res)\n{\n\tif (res < 0 || res > LDG_TIMER_RES_VAL)\n\t\treturn -EINVAL;\n\n\n\tnw64(LDG_TIMER_RES, res);\n\n\treturn 0;\n}\n\nstatic int niu_set_ldg_sid(struct niu *np, int ldg, int func, int vector)\n{\n\tif ((ldg < NIU_LDG_MIN || ldg > NIU_LDG_MAX) ||\n\t    (func < 0 || func > 3) ||\n\t    (vector < 0 || vector > 0x1f))\n\t\treturn -EINVAL;\n\n\tnw64(SID(ldg), (func << SID_FUNC_SHIFT) | vector);\n\n\treturn 0;\n}\n\nstatic int niu_pci_eeprom_read(struct niu *np, u32 addr)\n{\n\tu64 frame, frame_base = (ESPC_PIO_STAT_READ_START |\n\t\t\t\t (addr << ESPC_PIO_STAT_ADDR_SHIFT));\n\tint limit;\n\n\tif (addr > (ESPC_PIO_STAT_ADDR >> ESPC_PIO_STAT_ADDR_SHIFT))\n\t\treturn -EINVAL;\n\n\tframe = frame_base;\n\tnw64(ESPC_PIO_STAT, frame);\n\tlimit = 64;\n\tdo {\n\t\tudelay(5);\n\t\tframe = nr64(ESPC_PIO_STAT);\n\t\tif (frame & ESPC_PIO_STAT_READ_END)\n\t\t\tbreak;\n\t} while (limit--);\n\tif (!(frame & ESPC_PIO_STAT_READ_END)) {\n\t\tdev_err(np->device, \"EEPROM read timeout frame[%llx]\\n\",\n\t\t\t(unsigned long long) frame);\n\t\treturn -ENODEV;\n\t}\n\n\tframe = frame_base;\n\tnw64(ESPC_PIO_STAT, frame);\n\tlimit = 64;\n\tdo {\n\t\tudelay(5);\n\t\tframe = nr64(ESPC_PIO_STAT);\n\t\tif (frame & ESPC_PIO_STAT_READ_END)\n\t\t\tbreak;\n\t} while (limit--);\n\tif (!(frame & ESPC_PIO_STAT_READ_END)) {\n\t\tdev_err(np->device, \"EEPROM read timeout frame[%llx]\\n\",\n\t\t\t(unsigned long long) frame);\n\t\treturn -ENODEV;\n\t}\n\n\tframe = nr64(ESPC_PIO_STAT);\n\treturn (frame & ESPC_PIO_STAT_DATA) >> ESPC_PIO_STAT_DATA_SHIFT;\n}\n\nstatic int niu_pci_eeprom_read16(struct niu *np, u32 off)\n{\n\tint err = niu_pci_eeprom_read(np, off);\n\tu16 val;\n\n\tif (err < 0)\n\t\treturn err;\n\tval = (err << 8);\n\terr = niu_pci_eeprom_read(np, off + 1);\n\tif (err < 0)\n\t\treturn err;\n\tval |= (err & 0xff);\n\n\treturn val;\n}\n\nstatic int niu_pci_eeprom_read16_swp(struct niu *np, u32 off)\n{\n\tint err = niu_pci_eeprom_read(np, off);\n\tu16 val;\n\n\tif (err < 0)\n\t\treturn err;\n\n\tval = (err & 0xff);\n\terr = niu_pci_eeprom_read(np, off + 1);\n\tif (err < 0)\n\t\treturn err;\n\n\tval |= (err & 0xff) << 8;\n\n\treturn val;\n}\n\nstatic int niu_pci_vpd_get_propname(struct niu *np, u32 off, char *namebuf,\n\t\t\t\t    int namebuf_len)\n{\n\tint i;\n\n\tfor (i = 0; i < namebuf_len; i++) {\n\t\tint err = niu_pci_eeprom_read(np, off + i);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*namebuf++ = err;\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\tif (i >= namebuf_len)\n\t\treturn -EINVAL;\n\n\treturn i + 1;\n}\n\nstatic void niu_vpd_parse_version(struct niu *np)\n{\n\tstruct niu_vpd *vpd = &np->vpd;\n\tint len = strlen(vpd->version) + 1;\n\tconst char *s = vpd->version;\n\tint i;\n\n\tfor (i = 0; i < len - 5; i++) {\n\t\tif (!strncmp(s + i, \"FCode \", 6))\n\t\t\tbreak;\n\t}\n\tif (i >= len - 5)\n\t\treturn;\n\n\ts += i + 5;\n\tsscanf(s, \"%d.%d\", &vpd->fcode_major, &vpd->fcode_minor);\n\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"VPD_SCAN: FCODE major(%d) minor(%d)\\n\",\n\t\t     vpd->fcode_major, vpd->fcode_minor);\n\tif (vpd->fcode_major > NIU_VPD_MIN_MAJOR ||\n\t    (vpd->fcode_major == NIU_VPD_MIN_MAJOR &&\n\t     vpd->fcode_minor >= NIU_VPD_MIN_MINOR))\n\t\tnp->flags |= NIU_FLAGS_VPD_VALID;\n}\n\n/* ESPC_PIO_EN_ENABLE must be set */\nstatic int niu_pci_vpd_scan_props(struct niu *np, u32 start, u32 end)\n{\n\tunsigned int found_mask = 0;\n#define FOUND_MASK_MODEL\t0x00000001\n#define FOUND_MASK_BMODEL\t0x00000002\n#define FOUND_MASK_VERS\t\t0x00000004\n#define FOUND_MASK_MAC\t\t0x00000008\n#define FOUND_MASK_NMAC\t\t0x00000010\n#define FOUND_MASK_PHY\t\t0x00000020\n#define FOUND_MASK_ALL\t\t0x0000003f\n\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"VPD_SCAN: start[%x] end[%x]\\n\", start, end);\n\twhile (start < end) {\n\t\tint len, err, prop_len;\n\t\tchar namebuf[64];\n\t\tu8 *prop_buf;\n\t\tint max_len;\n\n\t\tif (found_mask == FOUND_MASK_ALL) {\n\t\t\tniu_vpd_parse_version(np);\n\t\t\treturn 1;\n\t\t}\n\n\t\terr = niu_pci_eeprom_read(np, start + 2);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tlen = err;\n\t\tstart += 3;\n\n\t\tprop_len = niu_pci_eeprom_read(np, start + 4);\n\t\tif (prop_len < 0)\n\t\t\treturn prop_len;\n\t\terr = niu_pci_vpd_get_propname(np, start + 5, namebuf, 64);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tprop_buf = NULL;\n\t\tmax_len = 0;\n\t\tif (!strcmp(namebuf, \"model\")) {\n\t\t\tprop_buf = np->vpd.model;\n\t\t\tmax_len = NIU_VPD_MODEL_MAX;\n\t\t\tfound_mask |= FOUND_MASK_MODEL;\n\t\t} else if (!strcmp(namebuf, \"board-model\")) {\n\t\t\tprop_buf = np->vpd.board_model;\n\t\t\tmax_len = NIU_VPD_BD_MODEL_MAX;\n\t\t\tfound_mask |= FOUND_MASK_BMODEL;\n\t\t} else if (!strcmp(namebuf, \"version\")) {\n\t\t\tprop_buf = np->vpd.version;\n\t\t\tmax_len = NIU_VPD_VERSION_MAX;\n\t\t\tfound_mask |= FOUND_MASK_VERS;\n\t\t} else if (!strcmp(namebuf, \"local-mac-address\")) {\n\t\t\tprop_buf = np->vpd.local_mac;\n\t\t\tmax_len = ETH_ALEN;\n\t\t\tfound_mask |= FOUND_MASK_MAC;\n\t\t} else if (!strcmp(namebuf, \"num-mac-addresses\")) {\n\t\t\tprop_buf = &np->vpd.mac_num;\n\t\t\tmax_len = 1;\n\t\t\tfound_mask |= FOUND_MASK_NMAC;\n\t\t} else if (!strcmp(namebuf, \"phy-type\")) {\n\t\t\tprop_buf = np->vpd.phy_type;\n\t\t\tmax_len = NIU_VPD_PHY_TYPE_MAX;\n\t\t\tfound_mask |= FOUND_MASK_PHY;\n\t\t}\n\n\t\tif (max_len && prop_len > max_len) {\n\t\t\tdev_err(np->device, \"Property '%s' length (%d) is too long\\n\", namebuf, prop_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (prop_buf) {\n\t\t\tu32 off = start + 5 + err;\n\t\t\tint i;\n\n\t\t\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t\t\t     \"VPD_SCAN: Reading in property [%s] len[%d]\\n\",\n\t\t\t\t     namebuf, prop_len);\n\t\t\tfor (i = 0; i < prop_len; i++) {\n\t\t\t\terr = niu_pci_eeprom_read(np, off + i);\n\t\t\t\tif (err >= 0)\n\t\t\t\t\t*prop_buf = err;\n\t\t\t\t++prop_buf;\n\t\t\t}\n\t\t}\n\n\t\tstart += len;\n\t}\n\n\treturn 0;\n}\n\n/* ESPC_PIO_EN_ENABLE must be set */\nstatic void niu_pci_vpd_fetch(struct niu *np, u32 start)\n{\n\tu32 offset;\n\tint err;\n\n\terr = niu_pci_eeprom_read16_swp(np, start + 1);\n\tif (err < 0)\n\t\treturn;\n\n\toffset = err + 3;\n\n\twhile (start + offset < ESPC_EEPROM_SIZE) {\n\t\tu32 here = start + offset;\n\t\tu32 end;\n\n\t\terr = niu_pci_eeprom_read(np, here);\n\t\tif (err != 0x90)\n\t\t\treturn;\n\n\t\terr = niu_pci_eeprom_read16_swp(np, here + 1);\n\t\tif (err < 0)\n\t\t\treturn;\n\n\t\there = start + offset + 3;\n\t\tend = start + offset + err;\n\n\t\toffset += err;\n\n\t\terr = niu_pci_vpd_scan_props(np, here, end);\n\t\tif (err < 0 || err == 1)\n\t\t\treturn;\n\t}\n}\n\n/* ESPC_PIO_EN_ENABLE must be set */\nstatic u32 niu_pci_vpd_offset(struct niu *np)\n{\n\tu32 start = 0, end = ESPC_EEPROM_SIZE, ret;\n\tint err;\n\n\twhile (start < end) {\n\t\tret = start;\n\n\t\t/* ROM header signature?  */\n\t\terr = niu_pci_eeprom_read16(np, start +  0);\n\t\tif (err != 0x55aa)\n\t\t\treturn 0;\n\n\t\t/* Apply offset to PCI data structure.  */\n\t\terr = niu_pci_eeprom_read16(np, start + 23);\n\t\tif (err < 0)\n\t\t\treturn 0;\n\t\tstart += err;\n\n\t\t/* Check for \"PCIR\" signature.  */\n\t\terr = niu_pci_eeprom_read16(np, start +  0);\n\t\tif (err != 0x5043)\n\t\t\treturn 0;\n\t\terr = niu_pci_eeprom_read16(np, start +  2);\n\t\tif (err != 0x4952)\n\t\t\treturn 0;\n\n\t\t/* Check for OBP image type.  */\n\t\terr = niu_pci_eeprom_read(np, start + 20);\n\t\tif (err < 0)\n\t\t\treturn 0;\n\t\tif (err != 0x01) {\n\t\t\terr = niu_pci_eeprom_read(np, ret + 2);\n\t\t\tif (err < 0)\n\t\t\t\treturn 0;\n\n\t\t\tstart = ret + (err * 512);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = niu_pci_eeprom_read16_swp(np, start + 8);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tret += err;\n\n\t\terr = niu_pci_eeprom_read(np, ret + 0);\n\t\tif (err != 0x82)\n\t\t\treturn 0;\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_phy_type_prop_decode(struct niu *np, const char *phy_prop)\n{\n\tif (!strcmp(phy_prop, \"mif\")) {\n\t\t/* 1G copper, MII */\n\t\tnp->flags &= ~(NIU_FLAGS_FIBER |\n\t\t\t       NIU_FLAGS_10G);\n\t\tnp->mac_xcvr = MAC_XCVR_MII;\n\t} else if (!strcmp(phy_prop, \"xgf\")) {\n\t\t/* 10G fiber, XPCS */\n\t\tnp->flags |= (NIU_FLAGS_10G |\n\t\t\t      NIU_FLAGS_FIBER);\n\t\tnp->mac_xcvr = MAC_XCVR_XPCS;\n\t} else if (!strcmp(phy_prop, \"pcs\")) {\n\t\t/* 1G fiber, PCS */\n\t\tnp->flags &= ~NIU_FLAGS_10G;\n\t\tnp->flags |= NIU_FLAGS_FIBER;\n\t\tnp->mac_xcvr = MAC_XCVR_PCS;\n\t} else if (!strcmp(phy_prop, \"xgc\")) {\n\t\t/* 10G copper, XPCS */\n\t\tnp->flags |= NIU_FLAGS_10G;\n\t\tnp->flags &= ~NIU_FLAGS_FIBER;\n\t\tnp->mac_xcvr = MAC_XCVR_XPCS;\n\t} else if (!strcmp(phy_prop, \"xgsd\") || !strcmp(phy_prop, \"gsd\")) {\n\t\t/* 10G Serdes or 1G Serdes, default to 10G */\n\t\tnp->flags |= NIU_FLAGS_10G;\n\t\tnp->flags &= ~NIU_FLAGS_FIBER;\n\t\tnp->flags |= NIU_FLAGS_XCVR_SERDES;\n\t\tnp->mac_xcvr = MAC_XCVR_XPCS;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int niu_pci_vpd_get_nports(struct niu *np)\n{\n\tint ports = 0;\n\n\tif ((!strcmp(np->vpd.model, NIU_QGC_LP_MDL_STR)) ||\n\t    (!strcmp(np->vpd.model, NIU_QGC_PEM_MDL_STR)) ||\n\t    (!strcmp(np->vpd.model, NIU_MARAMBA_MDL_STR)) ||\n\t    (!strcmp(np->vpd.model, NIU_KIMI_MDL_STR)) ||\n\t    (!strcmp(np->vpd.model, NIU_ALONSO_MDL_STR))) {\n\t\tports = 4;\n\t} else if ((!strcmp(np->vpd.model, NIU_2XGF_LP_MDL_STR)) ||\n\t\t   (!strcmp(np->vpd.model, NIU_2XGF_PEM_MDL_STR)) ||\n\t\t   (!strcmp(np->vpd.model, NIU_FOXXY_MDL_STR)) ||\n\t\t   (!strcmp(np->vpd.model, NIU_2XGF_MRVL_MDL_STR))) {\n\t\tports = 2;\n\t}\n\n\treturn ports;\n}\n\nstatic void niu_pci_vpd_validate(struct niu *np)\n{\n\tstruct net_device *dev = np->dev;\n\tstruct niu_vpd *vpd = &np->vpd;\n\tu8 val8;\n\n\tif (!is_valid_ether_addr(&vpd->local_mac[0])) {\n\t\tdev_err(np->device, \"VPD MAC invalid, falling back to SPROM\\n\");\n\n\t\tnp->flags &= ~NIU_FLAGS_VPD_VALID;\n\t\treturn;\n\t}\n\n\tif (!strcmp(np->vpd.model, NIU_ALONSO_MDL_STR) ||\n\t    !strcmp(np->vpd.model, NIU_KIMI_MDL_STR)) {\n\t\tnp->flags |= NIU_FLAGS_10G;\n\t\tnp->flags &= ~NIU_FLAGS_FIBER;\n\t\tnp->flags |= NIU_FLAGS_XCVR_SERDES;\n\t\tnp->mac_xcvr = MAC_XCVR_PCS;\n\t\tif (np->port > 1) {\n\t\t\tnp->flags |= NIU_FLAGS_FIBER;\n\t\t\tnp->flags &= ~NIU_FLAGS_10G;\n\t\t}\n\t\tif (np->flags & NIU_FLAGS_10G)\n\t\t\tnp->mac_xcvr = MAC_XCVR_XPCS;\n\t} else if (!strcmp(np->vpd.model, NIU_FOXXY_MDL_STR)) {\n\t\tnp->flags |= (NIU_FLAGS_10G | NIU_FLAGS_FIBER |\n\t\t\t      NIU_FLAGS_HOTPLUG_PHY);\n\t} else if (niu_phy_type_prop_decode(np, np->vpd.phy_type)) {\n\t\tdev_err(np->device, \"Illegal phy string [%s]\\n\",\n\t\t\tnp->vpd.phy_type);\n\t\tdev_err(np->device, \"Falling back to SPROM\\n\");\n\t\tnp->flags &= ~NIU_FLAGS_VPD_VALID;\n\t\treturn;\n\t}\n\n\tmemcpy(dev->dev_addr, vpd->local_mac, ETH_ALEN);\n\n\tval8 = dev->dev_addr[5];\n\tdev->dev_addr[5] += np->port;\n\tif (dev->dev_addr[5] < val8)\n\t\tdev->dev_addr[4]++;\n}\n\nstatic int niu_pci_probe_sprom(struct niu *np)\n{\n\tstruct net_device *dev = np->dev;\n\tint len, i;\n\tu64 val, sum;\n\tu8 val8;\n\n\tval = (nr64(ESPC_VER_IMGSZ) & ESPC_VER_IMGSZ_IMGSZ);\n\tval >>= ESPC_VER_IMGSZ_IMGSZ_SHIFT;\n\tlen = val / 4;\n\n\tnp->eeprom_len = len;\n\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"SPROM: Image size %llu\\n\", (unsigned long long)val);\n\n\tsum = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tval = nr64(ESPC_NCR(i));\n\t\tsum += (val >>  0) & 0xff;\n\t\tsum += (val >>  8) & 0xff;\n\t\tsum += (val >> 16) & 0xff;\n\t\tsum += (val >> 24) & 0xff;\n\t}\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"SPROM: Checksum %x\\n\", (int)(sum & 0xff));\n\tif ((sum & 0xff) != 0xab) {\n\t\tdev_err(np->device, \"Bad SPROM checksum (%x, should be 0xab)\\n\", (int)(sum & 0xff));\n\t\treturn -EINVAL;\n\t}\n\n\tval = nr64(ESPC_PHY_TYPE);\n\tswitch (np->port) {\n\tcase 0:\n\t\tval8 = (val & ESPC_PHY_TYPE_PORT0) >>\n\t\t\tESPC_PHY_TYPE_PORT0_SHIFT;\n\t\tbreak;\n\tcase 1:\n\t\tval8 = (val & ESPC_PHY_TYPE_PORT1) >>\n\t\t\tESPC_PHY_TYPE_PORT1_SHIFT;\n\t\tbreak;\n\tcase 2:\n\t\tval8 = (val & ESPC_PHY_TYPE_PORT2) >>\n\t\t\tESPC_PHY_TYPE_PORT2_SHIFT;\n\t\tbreak;\n\tcase 3:\n\t\tval8 = (val & ESPC_PHY_TYPE_PORT3) >>\n\t\t\tESPC_PHY_TYPE_PORT3_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(np->device, \"Bogus port number %u\\n\",\n\t\t\tnp->port);\n\t\treturn -EINVAL;\n\t}\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"SPROM: PHY type %x\\n\", val8);\n\n\tswitch (val8) {\n\tcase ESPC_PHY_TYPE_1G_COPPER:\n\t\t/* 1G copper, MII */\n\t\tnp->flags &= ~(NIU_FLAGS_FIBER |\n\t\t\t       NIU_FLAGS_10G);\n\t\tnp->mac_xcvr = MAC_XCVR_MII;\n\t\tbreak;\n\n\tcase ESPC_PHY_TYPE_1G_FIBER:\n\t\t/* 1G fiber, PCS */\n\t\tnp->flags &= ~NIU_FLAGS_10G;\n\t\tnp->flags |= NIU_FLAGS_FIBER;\n\t\tnp->mac_xcvr = MAC_XCVR_PCS;\n\t\tbreak;\n\n\tcase ESPC_PHY_TYPE_10G_COPPER:\n\t\t/* 10G copper, XPCS */\n\t\tnp->flags |= NIU_FLAGS_10G;\n\t\tnp->flags &= ~NIU_FLAGS_FIBER;\n\t\tnp->mac_xcvr = MAC_XCVR_XPCS;\n\t\tbreak;\n\n\tcase ESPC_PHY_TYPE_10G_FIBER:\n\t\t/* 10G fiber, XPCS */\n\t\tnp->flags |= (NIU_FLAGS_10G |\n\t\t\t      NIU_FLAGS_FIBER);\n\t\tnp->mac_xcvr = MAC_XCVR_XPCS;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(np->device, \"Bogus SPROM phy type %u\\n\", val8);\n\t\treturn -EINVAL;\n\t}\n\n\tval = nr64(ESPC_MAC_ADDR0);\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"SPROM: MAC_ADDR0[%08llx]\\n\", (unsigned long long)val);\n\tdev->dev_addr[0] = (val >>  0) & 0xff;\n\tdev->dev_addr[1] = (val >>  8) & 0xff;\n\tdev->dev_addr[2] = (val >> 16) & 0xff;\n\tdev->dev_addr[3] = (val >> 24) & 0xff;\n\n\tval = nr64(ESPC_MAC_ADDR1);\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"SPROM: MAC_ADDR1[%08llx]\\n\", (unsigned long long)val);\n\tdev->dev_addr[4] = (val >>  0) & 0xff;\n\tdev->dev_addr[5] = (val >>  8) & 0xff;\n\n\tif (!is_valid_ether_addr(&dev->dev_addr[0])) {\n\t\tdev_err(np->device, \"SPROM MAC address invalid [ %pM ]\\n\",\n\t\t\tdev->dev_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tval8 = dev->dev_addr[5];\n\tdev->dev_addr[5] += np->port;\n\tif (dev->dev_addr[5] < val8)\n\t\tdev->dev_addr[4]++;\n\n\tval = nr64(ESPC_MOD_STR_LEN);\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"SPROM: MOD_STR_LEN[%llu]\\n\", (unsigned long long)val);\n\tif (val >= 8 * 4)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < val; i += 4) {\n\t\tu64 tmp = nr64(ESPC_NCR(5 + (i / 4)));\n\n\t\tnp->vpd.model[i + 3] = (tmp >>  0) & 0xff;\n\t\tnp->vpd.model[i + 2] = (tmp >>  8) & 0xff;\n\t\tnp->vpd.model[i + 1] = (tmp >> 16) & 0xff;\n\t\tnp->vpd.model[i + 0] = (tmp >> 24) & 0xff;\n\t}\n\tnp->vpd.model[val] = '\\0';\n\n\tval = nr64(ESPC_BD_MOD_STR_LEN);\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"SPROM: BD_MOD_STR_LEN[%llu]\\n\", (unsigned long long)val);\n\tif (val >= 4 * 4)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < val; i += 4) {\n\t\tu64 tmp = nr64(ESPC_NCR(14 + (i / 4)));\n\n\t\tnp->vpd.board_model[i + 3] = (tmp >>  0) & 0xff;\n\t\tnp->vpd.board_model[i + 2] = (tmp >>  8) & 0xff;\n\t\tnp->vpd.board_model[i + 1] = (tmp >> 16) & 0xff;\n\t\tnp->vpd.board_model[i + 0] = (tmp >> 24) & 0xff;\n\t}\n\tnp->vpd.board_model[val] = '\\0';\n\n\tnp->vpd.mac_num =\n\t\tnr64(ESPC_NUM_PORTS_MACS) & ESPC_NUM_PORTS_MACS_VAL;\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"SPROM: NUM_PORTS_MACS[%d]\\n\", np->vpd.mac_num);\n\n\treturn 0;\n}\n\nstatic int niu_get_and_validate_port(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\n\tif (np->port <= 1)\n\t\tnp->flags |= NIU_FLAGS_XMAC;\n\n\tif (!parent->num_ports) {\n\t\tif (parent->plat_type == PLAT_TYPE_NIU) {\n\t\t\tparent->num_ports = 2;\n\t\t} else {\n\t\t\tparent->num_ports = niu_pci_vpd_get_nports(np);\n\t\t\tif (!parent->num_ports) {\n\t\t\t\t/* Fall back to SPROM as last resort.\n\t\t\t\t * This will fail on most cards.\n\t\t\t\t */\n\t\t\t\tparent->num_ports = nr64(ESPC_NUM_PORTS_MACS) &\n\t\t\t\t\tESPC_NUM_PORTS_MACS_VAL;\n\n\t\t\t\t/* All of the current probing methods fail on\n\t\t\t\t * Maramba on-board parts.\n\t\t\t\t */\n\t\t\t\tif (!parent->num_ports)\n\t\t\t\t\tparent->num_ports = 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (np->port >= parent->num_ports)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int phy_record(struct niu_parent *parent, struct phy_probe_info *p,\n\t\t      int dev_id_1, int dev_id_2, u8 phy_port, int type)\n{\n\tu32 id = (dev_id_1 << 16) | dev_id_2;\n\tu8 idx;\n\n\tif (dev_id_1 < 0 || dev_id_2 < 0)\n\t\treturn 0;\n\tif (type == PHY_TYPE_PMA_PMD || type == PHY_TYPE_PCS) {\n\t\t/* Because of the NIU_PHY_ID_MASK being applied, the 8704\n\t\t * test covers the 8706 as well.\n\t\t */\n\t\tif (((id & NIU_PHY_ID_MASK) != NIU_PHY_ID_BCM8704) &&\n\t\t    ((id & NIU_PHY_ID_MASK) != NIU_PHY_ID_MRVL88X2011))\n\t\t\treturn 0;\n\t} else {\n\t\tif ((id & NIU_PHY_ID_MASK) != NIU_PHY_ID_BCM5464R)\n\t\t\treturn 0;\n\t}\n\n\tpr_info(\"niu%d: Found PHY %08x type %s at phy_port %u\\n\",\n\t\tparent->index, id,\n\t\ttype == PHY_TYPE_PMA_PMD ? \"PMA/PMD\" :\n\t\ttype == PHY_TYPE_PCS ? \"PCS\" : \"MII\",\n\t\tphy_port);\n\n\tif (p->cur[type] >= NIU_MAX_PORTS) {\n\t\tpr_err(\"Too many PHY ports\\n\");\n\t\treturn -EINVAL;\n\t}\n\tidx = p->cur[type];\n\tp->phy_id[type][idx] = id;\n\tp->phy_port[type][idx] = phy_port;\n\tp->cur[type] = idx + 1;\n\treturn 0;\n}\n\nstatic int port_has_10g(struct phy_probe_info *p, int port)\n{\n\tint i;\n\n\tfor (i = 0; i < p->cur[PHY_TYPE_PMA_PMD]; i++) {\n\t\tif (p->phy_port[PHY_TYPE_PMA_PMD][i] == port)\n\t\t\treturn 1;\n\t}\n\tfor (i = 0; i < p->cur[PHY_TYPE_PCS]; i++) {\n\t\tif (p->phy_port[PHY_TYPE_PCS][i] == port)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int count_10g_ports(struct phy_probe_info *p, int *lowest)\n{\n\tint port, cnt;\n\n\tcnt = 0;\n\t*lowest = 32;\n\tfor (port = 8; port < 32; port++) {\n\t\tif (port_has_10g(p, port)) {\n\t\t\tif (!cnt)\n\t\t\t\t*lowest = port;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nstatic int count_1g_ports(struct phy_probe_info *p, int *lowest)\n{\n\t*lowest = 32;\n\tif (p->cur[PHY_TYPE_MII])\n\t\t*lowest = p->phy_port[PHY_TYPE_MII][0];\n\n\treturn p->cur[PHY_TYPE_MII];\n}\n\nstatic void niu_n2_divide_channels(struct niu_parent *parent)\n{\n\tint num_ports = parent->num_ports;\n\tint i;\n\n\tfor (i = 0; i < num_ports; i++) {\n\t\tparent->rxchan_per_port[i] = (16 / num_ports);\n\t\tparent->txchan_per_port[i] = (16 / num_ports);\n\n\t\tpr_info(\"niu%d: Port %u [%u RX chans] [%u TX chans]\\n\",\n\t\t\tparent->index, i,\n\t\t\tparent->rxchan_per_port[i],\n\t\t\tparent->txchan_per_port[i]);\n\t}\n}\n\nstatic void niu_divide_channels(struct niu_parent *parent,\n\t\t\t\tint num_10g, int num_1g)\n{\n\tint num_ports = parent->num_ports;\n\tint rx_chans_per_10g, rx_chans_per_1g;\n\tint tx_chans_per_10g, tx_chans_per_1g;\n\tint i, tot_rx, tot_tx;\n\n\tif (!num_10g || !num_1g) {\n\t\trx_chans_per_10g = rx_chans_per_1g =\n\t\t\t(NIU_NUM_RXCHAN / num_ports);\n\t\ttx_chans_per_10g = tx_chans_per_1g =\n\t\t\t(NIU_NUM_TXCHAN / num_ports);\n\t} else {\n\t\trx_chans_per_1g = NIU_NUM_RXCHAN / 8;\n\t\trx_chans_per_10g = (NIU_NUM_RXCHAN -\n\t\t\t\t    (rx_chans_per_1g * num_1g)) /\n\t\t\tnum_10g;\n\n\t\ttx_chans_per_1g = NIU_NUM_TXCHAN / 6;\n\t\ttx_chans_per_10g = (NIU_NUM_TXCHAN -\n\t\t\t\t    (tx_chans_per_1g * num_1g)) /\n\t\t\tnum_10g;\n\t}\n\n\ttot_rx = tot_tx = 0;\n\tfor (i = 0; i < num_ports; i++) {\n\t\tint type = phy_decode(parent->port_phy, i);\n\n\t\tif (type == PORT_TYPE_10G) {\n\t\t\tparent->rxchan_per_port[i] = rx_chans_per_10g;\n\t\t\tparent->txchan_per_port[i] = tx_chans_per_10g;\n\t\t} else {\n\t\t\tparent->rxchan_per_port[i] = rx_chans_per_1g;\n\t\t\tparent->txchan_per_port[i] = tx_chans_per_1g;\n\t\t}\n\t\tpr_info(\"niu%d: Port %u [%u RX chans] [%u TX chans]\\n\",\n\t\t\tparent->index, i,\n\t\t\tparent->rxchan_per_port[i],\n\t\t\tparent->txchan_per_port[i]);\n\t\ttot_rx += parent->rxchan_per_port[i];\n\t\ttot_tx += parent->txchan_per_port[i];\n\t}\n\n\tif (tot_rx > NIU_NUM_RXCHAN) {\n\t\tpr_err(\"niu%d: Too many RX channels (%d), resetting to one per port\\n\",\n\t\t       parent->index, tot_rx);\n\t\tfor (i = 0; i < num_ports; i++)\n\t\t\tparent->rxchan_per_port[i] = 1;\n\t}\n\tif (tot_tx > NIU_NUM_TXCHAN) {\n\t\tpr_err(\"niu%d: Too many TX channels (%d), resetting to one per port\\n\",\n\t\t       parent->index, tot_tx);\n\t\tfor (i = 0; i < num_ports; i++)\n\t\t\tparent->txchan_per_port[i] = 1;\n\t}\n\tif (tot_rx < NIU_NUM_RXCHAN || tot_tx < NIU_NUM_TXCHAN) {\n\t\tpr_warn(\"niu%d: Driver bug, wasted channels, RX[%d] TX[%d]\\n\",\n\t\t\tparent->index, tot_rx, tot_tx);\n\t}\n}\n\nstatic void niu_divide_rdc_groups(struct niu_parent *parent,\n\t\t\t\t  int num_10g, int num_1g)\n{\n\tint i, num_ports = parent->num_ports;\n\tint rdc_group, rdc_groups_per_port;\n\tint rdc_channel_base;\n\n\trdc_group = 0;\n\trdc_groups_per_port = NIU_NUM_RDC_TABLES / num_ports;\n\n\trdc_channel_base = 0;\n\n\tfor (i = 0; i < num_ports; i++) {\n\t\tstruct niu_rdc_tables *tp = &parent->rdc_group_cfg[i];\n\t\tint grp, num_channels = parent->rxchan_per_port[i];\n\t\tint this_channel_offset;\n\n\t\ttp->first_table_num = rdc_group;\n\t\ttp->num_tables = rdc_groups_per_port;\n\t\tthis_channel_offset = 0;\n\t\tfor (grp = 0; grp < tp->num_tables; grp++) {\n\t\t\tstruct rdc_table *rt = &tp->tables[grp];\n\t\t\tint slot;\n\n\t\t\tpr_info(\"niu%d: Port %d RDC tbl(%d) [ \",\n\t\t\t\tparent->index, i, tp->first_table_num + grp);\n\t\t\tfor (slot = 0; slot < NIU_RDC_TABLE_SLOTS; slot++) {\n\t\t\t\trt->rxdma_channel[slot] =\n\t\t\t\t\trdc_channel_base + this_channel_offset;\n\n\t\t\t\tpr_cont(\"%d \", rt->rxdma_channel[slot]);\n\n\t\t\t\tif (++this_channel_offset == num_channels)\n\t\t\t\t\tthis_channel_offset = 0;\n\t\t\t}\n\t\t\tpr_cont(\"]\\n\");\n\t\t}\n\n\t\tparent->rdc_default[i] = rdc_channel_base;\n\n\t\trdc_channel_base += num_channels;\n\t\trdc_group += rdc_groups_per_port;\n\t}\n}\n\nstatic int fill_phy_probe_info(struct niu *np, struct niu_parent *parent,\n\t\t\t       struct phy_probe_info *info)\n{\n\tunsigned long flags;\n\tint port, err;\n\n\tmemset(info, 0, sizeof(*info));\n\n\t/* Port 0 to 7 are reserved for onboard Serdes, probe the rest.  */\n\tniu_lock_parent(np, flags);\n\terr = 0;\n\tfor (port = 8; port < 32; port++) {\n\t\tint dev_id_1, dev_id_2;\n\n\t\tdev_id_1 = mdio_read(np, port,\n\t\t\t\t     NIU_PMA_PMD_DEV_ADDR, MII_PHYSID1);\n\t\tdev_id_2 = mdio_read(np, port,\n\t\t\t\t     NIU_PMA_PMD_DEV_ADDR, MII_PHYSID2);\n\t\terr = phy_record(parent, info, dev_id_1, dev_id_2, port,\n\t\t\t\t PHY_TYPE_PMA_PMD);\n\t\tif (err)\n\t\t\tbreak;\n\t\tdev_id_1 = mdio_read(np, port,\n\t\t\t\t     NIU_PCS_DEV_ADDR, MII_PHYSID1);\n\t\tdev_id_2 = mdio_read(np, port,\n\t\t\t\t     NIU_PCS_DEV_ADDR, MII_PHYSID2);\n\t\terr = phy_record(parent, info, dev_id_1, dev_id_2, port,\n\t\t\t\t PHY_TYPE_PCS);\n\t\tif (err)\n\t\t\tbreak;\n\t\tdev_id_1 = mii_read(np, port, MII_PHYSID1);\n\t\tdev_id_2 = mii_read(np, port, MII_PHYSID2);\n\t\terr = phy_record(parent, info, dev_id_1, dev_id_2, port,\n\t\t\t\t PHY_TYPE_MII);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tniu_unlock_parent(np, flags);\n\n\treturn err;\n}\n\nstatic int walk_phys(struct niu *np, struct niu_parent *parent)\n{\n\tstruct phy_probe_info *info = &parent->phy_probe_info;\n\tint lowest_10g, lowest_1g;\n\tint num_10g, num_1g;\n\tu32 val;\n\tint err;\n\n\tnum_10g = num_1g = 0;\n\n\tif (!strcmp(np->vpd.model, NIU_ALONSO_MDL_STR) ||\n\t    !strcmp(np->vpd.model, NIU_KIMI_MDL_STR)) {\n\t\tnum_10g = 0;\n\t\tnum_1g = 2;\n\t\tparent->plat_type = PLAT_TYPE_ATCA_CP3220;\n\t\tparent->num_ports = 4;\n\t\tval = (phy_encode(PORT_TYPE_1G, 0) |\n\t\t       phy_encode(PORT_TYPE_1G, 1) |\n\t\t       phy_encode(PORT_TYPE_1G, 2) |\n\t\t       phy_encode(PORT_TYPE_1G, 3));\n\t} else if (!strcmp(np->vpd.model, NIU_FOXXY_MDL_STR)) {\n\t\tnum_10g = 2;\n\t\tnum_1g = 0;\n\t\tparent->num_ports = 2;\n\t\tval = (phy_encode(PORT_TYPE_10G, 0) |\n\t\t       phy_encode(PORT_TYPE_10G, 1));\n\t} else if ((np->flags & NIU_FLAGS_XCVR_SERDES) &&\n\t\t   (parent->plat_type == PLAT_TYPE_NIU)) {\n\t\t/* this is the Monza case */\n\t\tif (np->flags & NIU_FLAGS_10G) {\n\t\t\tval = (phy_encode(PORT_TYPE_10G, 0) |\n\t\t\t       phy_encode(PORT_TYPE_10G, 1));\n\t\t} else {\n\t\t\tval = (phy_encode(PORT_TYPE_1G, 0) |\n\t\t\t       phy_encode(PORT_TYPE_1G, 1));\n\t\t}\n\t} else {\n\t\terr = fill_phy_probe_info(np, parent, info);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tnum_10g = count_10g_ports(info, &lowest_10g);\n\t\tnum_1g = count_1g_ports(info, &lowest_1g);\n\n\t\tswitch ((num_10g << 4) | num_1g) {\n\t\tcase 0x24:\n\t\t\tif (lowest_1g == 10)\n\t\t\t\tparent->plat_type = PLAT_TYPE_VF_P0;\n\t\t\telse if (lowest_1g == 26)\n\t\t\t\tparent->plat_type = PLAT_TYPE_VF_P1;\n\t\t\telse\n\t\t\t\tgoto unknown_vg_1g_port;\n\n\t\t\tfallthrough;\n\t\tcase 0x22:\n\t\t\tval = (phy_encode(PORT_TYPE_10G, 0) |\n\t\t\t       phy_encode(PORT_TYPE_10G, 1) |\n\t\t\t       phy_encode(PORT_TYPE_1G, 2) |\n\t\t\t       phy_encode(PORT_TYPE_1G, 3));\n\t\t\tbreak;\n\n\t\tcase 0x20:\n\t\t\tval = (phy_encode(PORT_TYPE_10G, 0) |\n\t\t\t       phy_encode(PORT_TYPE_10G, 1));\n\t\t\tbreak;\n\n\t\tcase 0x10:\n\t\t\tval = phy_encode(PORT_TYPE_10G, np->port);\n\t\t\tbreak;\n\n\t\tcase 0x14:\n\t\t\tif (lowest_1g == 10)\n\t\t\t\tparent->plat_type = PLAT_TYPE_VF_P0;\n\t\t\telse if (lowest_1g == 26)\n\t\t\t\tparent->plat_type = PLAT_TYPE_VF_P1;\n\t\t\telse\n\t\t\t\tgoto unknown_vg_1g_port;\n\n\t\t\tfallthrough;\n\t\tcase 0x13:\n\t\t\tif ((lowest_10g & 0x7) == 0)\n\t\t\t\tval = (phy_encode(PORT_TYPE_10G, 0) |\n\t\t\t\t       phy_encode(PORT_TYPE_1G, 1) |\n\t\t\t\t       phy_encode(PORT_TYPE_1G, 2) |\n\t\t\t\t       phy_encode(PORT_TYPE_1G, 3));\n\t\t\telse\n\t\t\t\tval = (phy_encode(PORT_TYPE_1G, 0) |\n\t\t\t\t       phy_encode(PORT_TYPE_10G, 1) |\n\t\t\t\t       phy_encode(PORT_TYPE_1G, 2) |\n\t\t\t\t       phy_encode(PORT_TYPE_1G, 3));\n\t\t\tbreak;\n\n\t\tcase 0x04:\n\t\t\tif (lowest_1g == 10)\n\t\t\t\tparent->plat_type = PLAT_TYPE_VF_P0;\n\t\t\telse if (lowest_1g == 26)\n\t\t\t\tparent->plat_type = PLAT_TYPE_VF_P1;\n\t\t\telse\n\t\t\t\tgoto unknown_vg_1g_port;\n\n\t\t\tval = (phy_encode(PORT_TYPE_1G, 0) |\n\t\t\t       phy_encode(PORT_TYPE_1G, 1) |\n\t\t\t       phy_encode(PORT_TYPE_1G, 2) |\n\t\t\t       phy_encode(PORT_TYPE_1G, 3));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"Unsupported port config 10G[%d] 1G[%d]\\n\",\n\t\t\t       num_10g, num_1g);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tparent->port_phy = val;\n\n\tif (parent->plat_type == PLAT_TYPE_NIU)\n\t\tniu_n2_divide_channels(parent);\n\telse\n\t\tniu_divide_channels(parent, num_10g, num_1g);\n\n\tniu_divide_rdc_groups(parent, num_10g, num_1g);\n\n\treturn 0;\n\nunknown_vg_1g_port:\n\tpr_err(\"Cannot identify platform type, 1gport=%d\\n\", lowest_1g);\n\treturn -EINVAL;\n}\n\nstatic int niu_probe_ports(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tint err, i;\n\n\tif (parent->port_phy == PORT_PHY_UNKNOWN) {\n\t\terr = walk_phys(np, parent);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tniu_set_ldg_timer_res(np, 2);\n\t\tfor (i = 0; i <= LDN_MAX; i++)\n\t\t\tniu_ldn_irq_enable(np, i, 0);\n\t}\n\n\tif (parent->port_phy == PORT_PHY_INVALID)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int niu_classifier_swstate_init(struct niu *np)\n{\n\tstruct niu_classifier *cp = &np->clas;\n\n\tcp->tcam_top = (u16) np->port;\n\tcp->tcam_sz = np->parent->tcam_num_entries / np->parent->num_ports;\n\tcp->h1_init = 0xffffffff;\n\tcp->h2_init = 0xffff;\n\n\treturn fflp_early_init(np);\n}\n\nstatic void niu_link_config_init(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\n\tlp->advertising = (ADVERTISED_10baseT_Half |\n\t\t\t   ADVERTISED_10baseT_Full |\n\t\t\t   ADVERTISED_100baseT_Half |\n\t\t\t   ADVERTISED_100baseT_Full |\n\t\t\t   ADVERTISED_1000baseT_Half |\n\t\t\t   ADVERTISED_1000baseT_Full |\n\t\t\t   ADVERTISED_10000baseT_Full |\n\t\t\t   ADVERTISED_Autoneg);\n\tlp->speed = lp->active_speed = SPEED_INVALID;\n\tlp->duplex = DUPLEX_FULL;\n\tlp->active_duplex = DUPLEX_INVALID;\n\tlp->autoneg = 1;\n#if 0\n\tlp->loopback_mode = LOOPBACK_MAC;\n\tlp->active_speed = SPEED_10000;\n\tlp->active_duplex = DUPLEX_FULL;\n#else\n\tlp->loopback_mode = LOOPBACK_DISABLED;\n#endif\n}\n\nstatic int niu_init_mac_ipp_pcs_base(struct niu *np)\n{\n\tswitch (np->port) {\n\tcase 0:\n\t\tnp->mac_regs = np->regs + XMAC_PORT0_OFF;\n\t\tnp->ipp_off  = 0x00000;\n\t\tnp->pcs_off  = 0x04000;\n\t\tnp->xpcs_off = 0x02000;\n\t\tbreak;\n\n\tcase 1:\n\t\tnp->mac_regs = np->regs + XMAC_PORT1_OFF;\n\t\tnp->ipp_off  = 0x08000;\n\t\tnp->pcs_off  = 0x0a000;\n\t\tnp->xpcs_off = 0x08000;\n\t\tbreak;\n\n\tcase 2:\n\t\tnp->mac_regs = np->regs + BMAC_PORT2_OFF;\n\t\tnp->ipp_off  = 0x04000;\n\t\tnp->pcs_off  = 0x0e000;\n\t\tnp->xpcs_off = ~0UL;\n\t\tbreak;\n\n\tcase 3:\n\t\tnp->mac_regs = np->regs + BMAC_PORT3_OFF;\n\t\tnp->ipp_off  = 0x0c000;\n\t\tnp->pcs_off  = 0x12000;\n\t\tnp->xpcs_off = ~0UL;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(np->device, \"Port %u is invalid, cannot compute MAC block offset\\n\", np->port);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void niu_try_msix(struct niu *np, u8 *ldg_num_map)\n{\n\tstruct msix_entry msi_vec[NIU_NUM_LDG];\n\tstruct niu_parent *parent = np->parent;\n\tstruct pci_dev *pdev = np->pdev;\n\tint i, num_irqs;\n\tu8 first_ldg;\n\n\tfirst_ldg = (NIU_NUM_LDG / parent->num_ports) * np->port;\n\tfor (i = 0; i < (NIU_NUM_LDG / parent->num_ports); i++)\n\t\tldg_num_map[i] = first_ldg + i;\n\n\tnum_irqs = (parent->rxchan_per_port[np->port] +\n\t\t    parent->txchan_per_port[np->port] +\n\t\t    (np->port == 0 ? 3 : 1));\n\tBUG_ON(num_irqs > (NIU_NUM_LDG / parent->num_ports));\n\n\tfor (i = 0; i < num_irqs; i++) {\n\t\tmsi_vec[i].vector = 0;\n\t\tmsi_vec[i].entry = i;\n\t}\n\n\tnum_irqs = pci_enable_msix_range(pdev, msi_vec, 1, num_irqs);\n\tif (num_irqs < 0) {\n\t\tnp->flags &= ~NIU_FLAGS_MSIX;\n\t\treturn;\n\t}\n\n\tnp->flags |= NIU_FLAGS_MSIX;\n\tfor (i = 0; i < num_irqs; i++)\n\t\tnp->ldg[i].irq = msi_vec[i].vector;\n\tnp->num_ldg = num_irqs;\n}\n\nstatic int niu_n2_irq_init(struct niu *np, u8 *ldg_num_map)\n{\n#ifdef CONFIG_SPARC64\n\tstruct platform_device *op = np->op;\n\tconst u32 *int_prop;\n\tint i;\n\n\tint_prop = of_get_property(op->dev.of_node, \"interrupts\", NULL);\n\tif (!int_prop)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < op->archdata.num_irqs; i++) {\n\t\tldg_num_map[i] = int_prop[i];\n\t\tnp->ldg[i].irq = op->archdata.irqs[i];\n\t}\n\n\tnp->num_ldg = op->archdata.num_irqs;\n\n\treturn 0;\n#else\n\treturn -EINVAL;\n#endif\n}\n\nstatic int niu_ldg_init(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tu8 ldg_num_map[NIU_NUM_LDG];\n\tint first_chan, num_chan;\n\tint i, err, ldg_rotor;\n\tu8 port;\n\n\tnp->num_ldg = 1;\n\tnp->ldg[0].irq = np->dev->irq;\n\tif (parent->plat_type == PLAT_TYPE_NIU) {\n\t\terr = niu_n2_irq_init(np, ldg_num_map);\n\t\tif (err)\n\t\t\treturn err;\n\t} else\n\t\tniu_try_msix(np, ldg_num_map);\n\n\tport = np->port;\n\tfor (i = 0; i < np->num_ldg; i++) {\n\t\tstruct niu_ldg *lp = &np->ldg[i];\n\n\t\tnetif_napi_add(np->dev, &lp->napi, niu_poll, 64);\n\n\t\tlp->np = np;\n\t\tlp->ldg_num = ldg_num_map[i];\n\t\tlp->timer = 2; /* XXX */\n\n\t\t/* On N2 NIU the firmware has setup the SID mappings so they go\n\t\t * to the correct values that will route the LDG to the proper\n\t\t * interrupt in the NCU interrupt table.\n\t\t */\n\t\tif (np->parent->plat_type != PLAT_TYPE_NIU) {\n\t\t\terr = niu_set_ldg_sid(np, lp->ldg_num, port, i);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t/* We adopt the LDG assignment ordering used by the N2 NIU\n\t * 'interrupt' properties because that simplifies a lot of\n\t * things.  This ordering is:\n\t *\n\t *\tMAC\n\t *\tMIF\t(if port zero)\n\t *\tSYSERR\t(if port zero)\n\t *\tRX channels\n\t *\tTX channels\n\t */\n\n\tldg_rotor = 0;\n\n\terr = niu_ldg_assign_ldn(np, parent, ldg_num_map[ldg_rotor],\n\t\t\t\t  LDN_MAC(port));\n\tif (err)\n\t\treturn err;\n\n\tldg_rotor++;\n\tif (ldg_rotor == np->num_ldg)\n\t\tldg_rotor = 0;\n\n\tif (port == 0) {\n\t\terr = niu_ldg_assign_ldn(np, parent,\n\t\t\t\t\t ldg_num_map[ldg_rotor],\n\t\t\t\t\t LDN_MIF);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tldg_rotor++;\n\t\tif (ldg_rotor == np->num_ldg)\n\t\t\tldg_rotor = 0;\n\n\t\terr = niu_ldg_assign_ldn(np, parent,\n\t\t\t\t\t ldg_num_map[ldg_rotor],\n\t\t\t\t\t LDN_DEVICE_ERROR);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tldg_rotor++;\n\t\tif (ldg_rotor == np->num_ldg)\n\t\t\tldg_rotor = 0;\n\n\t}\n\n\tfirst_chan = 0;\n\tfor (i = 0; i < port; i++)\n\t\tfirst_chan += parent->rxchan_per_port[i];\n\tnum_chan = parent->rxchan_per_port[port];\n\n\tfor (i = first_chan; i < (first_chan + num_chan); i++) {\n\t\terr = niu_ldg_assign_ldn(np, parent,\n\t\t\t\t\t ldg_num_map[ldg_rotor],\n\t\t\t\t\t LDN_RXDMA(i));\n\t\tif (err)\n\t\t\treturn err;\n\t\tldg_rotor++;\n\t\tif (ldg_rotor == np->num_ldg)\n\t\t\tldg_rotor = 0;\n\t}\n\n\tfirst_chan = 0;\n\tfor (i = 0; i < port; i++)\n\t\tfirst_chan += parent->txchan_per_port[i];\n\tnum_chan = parent->txchan_per_port[port];\n\tfor (i = first_chan; i < (first_chan + num_chan); i++) {\n\t\terr = niu_ldg_assign_ldn(np, parent,\n\t\t\t\t\t ldg_num_map[ldg_rotor],\n\t\t\t\t\t LDN_TXDMA(i));\n\t\tif (err)\n\t\t\treturn err;\n\t\tldg_rotor++;\n\t\tif (ldg_rotor == np->num_ldg)\n\t\t\tldg_rotor = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void niu_ldg_free(struct niu *np)\n{\n\tif (np->flags & NIU_FLAGS_MSIX)\n\t\tpci_disable_msix(np->pdev);\n}\n\nstatic int niu_get_of_props(struct niu *np)\n{\n#ifdef CONFIG_SPARC64\n\tstruct net_device *dev = np->dev;\n\tstruct device_node *dp;\n\tconst char *phy_type;\n\tconst u8 *mac_addr;\n\tconst char *model;\n\tint prop_len;\n\n\tif (np->parent->plat_type == PLAT_TYPE_NIU)\n\t\tdp = np->op->dev.of_node;\n\telse\n\t\tdp = pci_device_to_OF_node(np->pdev);\n\n\tphy_type = of_get_property(dp, \"phy-type\", &prop_len);\n\tif (!phy_type) {\n\t\tnetdev_err(dev, \"%pOF: OF node lacks phy-type property\\n\", dp);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!strcmp(phy_type, \"none\"))\n\t\treturn -ENODEV;\n\n\tstrcpy(np->vpd.phy_type, phy_type);\n\n\tif (niu_phy_type_prop_decode(np, np->vpd.phy_type)) {\n\t\tnetdev_err(dev, \"%pOF: Illegal phy string [%s]\\n\",\n\t\t\t   dp, np->vpd.phy_type);\n\t\treturn -EINVAL;\n\t}\n\n\tmac_addr = of_get_property(dp, \"local-mac-address\", &prop_len);\n\tif (!mac_addr) {\n\t\tnetdev_err(dev, \"%pOF: OF node lacks local-mac-address property\\n\",\n\t\t\t   dp);\n\t\treturn -EINVAL;\n\t}\n\tif (prop_len != dev->addr_len) {\n\t\tnetdev_err(dev, \"%pOF: OF MAC address prop len (%d) is wrong\\n\",\n\t\t\t   dp, prop_len);\n\t}\n\tmemcpy(dev->dev_addr, mac_addr, dev->addr_len);\n\tif (!is_valid_ether_addr(&dev->dev_addr[0])) {\n\t\tnetdev_err(dev, \"%pOF: OF MAC address is invalid\\n\", dp);\n\t\tnetdev_err(dev, \"%pOF: [ %pM ]\\n\", dp, dev->dev_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tmodel = of_get_property(dp, \"model\", &prop_len);\n\n\tif (model)\n\t\tstrcpy(np->vpd.model, model);\n\n\tif (of_find_property(dp, \"hot-swappable-phy\", &prop_len)) {\n\t\tnp->flags |= (NIU_FLAGS_10G | NIU_FLAGS_FIBER |\n\t\t\tNIU_FLAGS_HOTPLUG_PHY);\n\t}\n\n\treturn 0;\n#else\n\treturn -EINVAL;\n#endif\n}\n\nstatic int niu_get_invariants(struct niu *np)\n{\n\tint err, have_props;\n\tu32 offset;\n\n\terr = niu_get_of_props(np);\n\tif (err == -ENODEV)\n\t\treturn err;\n\n\thave_props = !err;\n\n\terr = niu_init_mac_ipp_pcs_base(np);\n\tif (err)\n\t\treturn err;\n\n\tif (have_props) {\n\t\terr = niu_get_and_validate_port(np);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else  {\n\t\tif (np->parent->plat_type == PLAT_TYPE_NIU)\n\t\t\treturn -EINVAL;\n\n\t\tnw64(ESPC_PIO_EN, ESPC_PIO_EN_ENABLE);\n\t\toffset = niu_pci_vpd_offset(np);\n\t\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t\t     \"%s() VPD offset [%08x]\\n\", __func__, offset);\n\t\tif (offset)\n\t\t\tniu_pci_vpd_fetch(np, offset);\n\t\tnw64(ESPC_PIO_EN, 0);\n\n\t\tif (np->flags & NIU_FLAGS_VPD_VALID) {\n\t\t\tniu_pci_vpd_validate(np);\n\t\t\terr = niu_get_and_validate_port(np);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (!(np->flags & NIU_FLAGS_VPD_VALID)) {\n\t\t\terr = niu_get_and_validate_port(np);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\terr = niu_pci_probe_sprom(np);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = niu_probe_ports(np);\n\tif (err)\n\t\treturn err;\n\n\tniu_ldg_init(np);\n\n\tniu_classifier_swstate_init(np);\n\tniu_link_config_init(np);\n\n\terr = niu_determine_phy_disposition(np);\n\tif (!err)\n\t\terr = niu_init_link(np);\n\n\treturn err;\n}\n\nstatic LIST_HEAD(niu_parent_list);\nstatic DEFINE_MUTEX(niu_parent_lock);\nstatic int niu_parent_index;\n\nstatic ssize_t show_port_phy(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *plat_dev = to_platform_device(dev);\n\tstruct niu_parent *p = dev_get_platdata(&plat_dev->dev);\n\tu32 port_phy = p->port_phy;\n\tchar *orig_buf = buf;\n\tint i;\n\n\tif (port_phy == PORT_PHY_UNKNOWN ||\n\t    port_phy == PORT_PHY_INVALID)\n\t\treturn 0;\n\n\tfor (i = 0; i < p->num_ports; i++) {\n\t\tconst char *type_str;\n\t\tint type;\n\n\t\ttype = phy_decode(port_phy, i);\n\t\tif (type == PORT_TYPE_10G)\n\t\t\ttype_str = \"10G\";\n\t\telse\n\t\t\ttype_str = \"1G\";\n\t\tbuf += sprintf(buf,\n\t\t\t       (i == 0) ? \"%s\" : \" %s\",\n\t\t\t       type_str);\n\t}\n\tbuf += sprintf(buf, \"\\n\");\n\treturn buf - orig_buf;\n}\n\nstatic ssize_t show_plat_type(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *plat_dev = to_platform_device(dev);\n\tstruct niu_parent *p = dev_get_platdata(&plat_dev->dev);\n\tconst char *type_str;\n\n\tswitch (p->plat_type) {\n\tcase PLAT_TYPE_ATLAS:\n\t\ttype_str = \"atlas\";\n\t\tbreak;\n\tcase PLAT_TYPE_NIU:\n\t\ttype_str = \"niu\";\n\t\tbreak;\n\tcase PLAT_TYPE_VF_P0:\n\t\ttype_str = \"vf_p0\";\n\t\tbreak;\n\tcase PLAT_TYPE_VF_P1:\n\t\ttype_str = \"vf_p1\";\n\t\tbreak;\n\tdefault:\n\t\ttype_str = \"unknown\";\n\t\tbreak;\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", type_str);\n}\n\nstatic ssize_t __show_chan_per_port(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf,\n\t\t\t\t    int rx)\n{\n\tstruct platform_device *plat_dev = to_platform_device(dev);\n\tstruct niu_parent *p = dev_get_platdata(&plat_dev->dev);\n\tchar *orig_buf = buf;\n\tu8 *arr;\n\tint i;\n\n\tarr = (rx ? p->rxchan_per_port : p->txchan_per_port);\n\n\tfor (i = 0; i < p->num_ports; i++) {\n\t\tbuf += sprintf(buf,\n\t\t\t       (i == 0) ? \"%d\" : \" %d\",\n\t\t\t       arr[i]);\n\t}\n\tbuf += sprintf(buf, \"\\n\");\n\n\treturn buf - orig_buf;\n}\n\nstatic ssize_t show_rxchan_per_port(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\treturn __show_chan_per_port(dev, attr, buf, 1);\n}\n\nstatic ssize_t show_txchan_per_port(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\treturn __show_chan_per_port(dev, attr, buf, 1);\n}\n\nstatic ssize_t show_num_ports(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *plat_dev = to_platform_device(dev);\n\tstruct niu_parent *p = dev_get_platdata(&plat_dev->dev);\n\n\treturn sprintf(buf, \"%d\\n\", p->num_ports);\n}\n\nstatic struct device_attribute niu_parent_attributes[] = {\n\t__ATTR(port_phy, 0444, show_port_phy, NULL),\n\t__ATTR(plat_type, 0444, show_plat_type, NULL),\n\t__ATTR(rxchan_per_port, 0444, show_rxchan_per_port, NULL),\n\t__ATTR(txchan_per_port, 0444, show_txchan_per_port, NULL),\n\t__ATTR(num_ports, 0444, show_num_ports, NULL),\n\t{}\n};\n\nstatic struct niu_parent *niu_new_parent(struct niu *np,\n\t\t\t\t\t union niu_parent_id *id, u8 ptype)\n{\n\tstruct platform_device *plat_dev;\n\tstruct niu_parent *p;\n\tint i;\n\n\tplat_dev = platform_device_register_simple(\"niu-board\", niu_parent_index,\n\t\t\t\t\t\t   NULL, 0);\n\tif (IS_ERR(plat_dev))\n\t\treturn NULL;\n\n\tfor (i = 0; niu_parent_attributes[i].attr.name; i++) {\n\t\tint err = device_create_file(&plat_dev->dev,\n\t\t\t\t\t     &niu_parent_attributes[i]);\n\t\tif (err)\n\t\t\tgoto fail_unregister;\n\t}\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\tgoto fail_unregister;\n\n\tp->index = niu_parent_index++;\n\n\tplat_dev->dev.platform_data = p;\n\tp->plat_dev = plat_dev;\n\n\tmemcpy(&p->id, id, sizeof(*id));\n\tp->plat_type = ptype;\n\tINIT_LIST_HEAD(&p->list);\n\tatomic_set(&p->refcnt, 0);\n\tlist_add(&p->list, &niu_parent_list);\n\tspin_lock_init(&p->lock);\n\n\tp->rxdma_clock_divider = 7500;\n\n\tp->tcam_num_entries = NIU_PCI_TCAM_ENTRIES;\n\tif (p->plat_type == PLAT_TYPE_NIU)\n\t\tp->tcam_num_entries = NIU_NONPCI_TCAM_ENTRIES;\n\n\tfor (i = CLASS_CODE_USER_PROG1; i <= CLASS_CODE_SCTP_IPV6; i++) {\n\t\tint index = i - CLASS_CODE_USER_PROG1;\n\n\t\tp->tcam_key[index] = TCAM_KEY_TSEL;\n\t\tp->flow_key[index] = (FLOW_KEY_IPSA |\n\t\t\t\t      FLOW_KEY_IPDA |\n\t\t\t\t      FLOW_KEY_PROTO |\n\t\t\t\t      (FLOW_KEY_L4_BYTE12 <<\n\t\t\t\t       FLOW_KEY_L4_0_SHIFT) |\n\t\t\t\t      (FLOW_KEY_L4_BYTE12 <<\n\t\t\t\t       FLOW_KEY_L4_1_SHIFT));\n\t}\n\n\tfor (i = 0; i < LDN_MAX + 1; i++)\n\t\tp->ldg_map[i] = LDG_INVALID;\n\n\treturn p;\n\nfail_unregister:\n\tplatform_device_unregister(plat_dev);\n\treturn NULL;\n}\n\nstatic struct niu_parent *niu_get_parent(struct niu *np,\n\t\t\t\t\t union niu_parent_id *id, u8 ptype)\n{\n\tstruct niu_parent *p, *tmp;\n\tint port = np->port;\n\n\tmutex_lock(&niu_parent_lock);\n\tp = NULL;\n\tlist_for_each_entry(tmp, &niu_parent_list, list) {\n\t\tif (!memcmp(id, &tmp->id, sizeof(*id))) {\n\t\t\tp = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!p)\n\t\tp = niu_new_parent(np, id, ptype);\n\n\tif (p) {\n\t\tchar port_name[8];\n\t\tint err;\n\n\t\tsprintf(port_name, \"port%d\", port);\n\t\terr = sysfs_create_link(&p->plat_dev->dev.kobj,\n\t\t\t\t\t&np->device->kobj,\n\t\t\t\t\tport_name);\n\t\tif (!err) {\n\t\t\tp->ports[port] = np;\n\t\t\tatomic_inc(&p->refcnt);\n\t\t}\n\t}\n\tmutex_unlock(&niu_parent_lock);\n\n\treturn p;\n}\n\nstatic void niu_put_parent(struct niu *np)\n{\n\tstruct niu_parent *p = np->parent;\n\tu8 port = np->port;\n\tchar port_name[8];\n\n\tBUG_ON(!p || p->ports[port] != np);\n\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"%s() port[%u]\\n\", __func__, port);\n\n\tsprintf(port_name, \"port%d\", port);\n\n\tmutex_lock(&niu_parent_lock);\n\n\tsysfs_remove_link(&p->plat_dev->dev.kobj, port_name);\n\n\tp->ports[port] = NULL;\n\tnp->parent = NULL;\n\n\tif (atomic_dec_and_test(&p->refcnt)) {\n\t\tlist_del(&p->list);\n\t\tplatform_device_unregister(p->plat_dev);\n\t}\n\n\tmutex_unlock(&niu_parent_lock);\n}\n\nstatic void *niu_pci_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t    u64 *handle, gfp_t flag)\n{\n\tdma_addr_t dh;\n\tvoid *ret;\n\n\tret = dma_alloc_coherent(dev, size, &dh, flag);\n\tif (ret)\n\t\t*handle = dh;\n\treturn ret;\n}\n\nstatic void niu_pci_free_coherent(struct device *dev, size_t size,\n\t\t\t\t  void *cpu_addr, u64 handle)\n{\n\tdma_free_coherent(dev, size, cpu_addr, handle);\n}\n\nstatic u64 niu_pci_map_page(struct device *dev, struct page *page,\n\t\t\t    unsigned long offset, size_t size,\n\t\t\t    enum dma_data_direction direction)\n{\n\treturn dma_map_page(dev, page, offset, size, direction);\n}\n\nstatic void niu_pci_unmap_page(struct device *dev, u64 dma_address,\n\t\t\t       size_t size, enum dma_data_direction direction)\n{\n\tdma_unmap_page(dev, dma_address, size, direction);\n}\n\nstatic u64 niu_pci_map_single(struct device *dev, void *cpu_addr,\n\t\t\t      size_t size,\n\t\t\t      enum dma_data_direction direction)\n{\n\treturn dma_map_single(dev, cpu_addr, size, direction);\n}\n\nstatic void niu_pci_unmap_single(struct device *dev, u64 dma_address,\n\t\t\t\t size_t size,\n\t\t\t\t enum dma_data_direction direction)\n{\n\tdma_unmap_single(dev, dma_address, size, direction);\n}\n\nstatic const struct niu_ops niu_pci_ops = {\n\t.alloc_coherent\t= niu_pci_alloc_coherent,\n\t.free_coherent\t= niu_pci_free_coherent,\n\t.map_page\t= niu_pci_map_page,\n\t.unmap_page\t= niu_pci_unmap_page,\n\t.map_single\t= niu_pci_map_single,\n\t.unmap_single\t= niu_pci_unmap_single,\n};\n\nstatic void niu_driver_version(void)\n{\n\tstatic int niu_version_printed;\n\n\tif (niu_version_printed++ == 0)\n\t\tpr_info(\"%s\", version);\n}\n\nstatic struct net_device *niu_alloc_and_init(struct device *gen_dev,\n\t\t\t\t\t     struct pci_dev *pdev,\n\t\t\t\t\t     struct platform_device *op,\n\t\t\t\t\t     const struct niu_ops *ops, u8 port)\n{\n\tstruct net_device *dev;\n\tstruct niu *np;\n\n\tdev = alloc_etherdev_mq(sizeof(struct niu), NIU_NUM_TXCHAN);\n\tif (!dev)\n\t\treturn NULL;\n\n\tSET_NETDEV_DEV(dev, gen_dev);\n\n\tnp = netdev_priv(dev);\n\tnp->dev = dev;\n\tnp->pdev = pdev;\n\tnp->op = op;\n\tnp->device = gen_dev;\n\tnp->ops = ops;\n\n\tnp->msg_enable = niu_debug;\n\n\tspin_lock_init(&np->lock);\n\tINIT_WORK(&np->reset_task, niu_reset_task);\n\n\tnp->port = port;\n\n\treturn dev;\n}\n\nstatic const struct net_device_ops niu_netdev_ops = {\n\t.ndo_open\t\t= niu_open,\n\t.ndo_stop\t\t= niu_close,\n\t.ndo_start_xmit\t\t= niu_start_xmit,\n\t.ndo_get_stats64\t= niu_get_stats,\n\t.ndo_set_rx_mode\t= niu_set_rx_mode,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= niu_set_mac_addr,\n\t.ndo_do_ioctl\t\t= niu_ioctl,\n\t.ndo_tx_timeout\t\t= niu_tx_timeout,\n\t.ndo_change_mtu\t\t= niu_change_mtu,\n};\n\nstatic void niu_assign_netdev_ops(struct net_device *dev)\n{\n\tdev->netdev_ops = &niu_netdev_ops;\n\tdev->ethtool_ops = &niu_ethtool_ops;\n\tdev->watchdog_timeo = NIU_TX_TIMEOUT;\n}\n\nstatic void niu_device_announce(struct niu *np)\n{\n\tstruct net_device *dev = np->dev;\n\n\tpr_info(\"%s: NIU Ethernet %pM\\n\", dev->name, dev->dev_addr);\n\n\tif (np->parent->plat_type == PLAT_TYPE_ATCA_CP3220) {\n\t\tpr_info(\"%s: Port type[%s] mode[%s:%s] XCVR[%s] phy[%s]\\n\",\n\t\t\t\tdev->name,\n\t\t\t\t(np->flags & NIU_FLAGS_XMAC ? \"XMAC\" : \"BMAC\"),\n\t\t\t\t(np->flags & NIU_FLAGS_10G ? \"10G\" : \"1G\"),\n\t\t\t\t(np->flags & NIU_FLAGS_FIBER ? \"RGMII FIBER\" : \"SERDES\"),\n\t\t\t\t(np->mac_xcvr == MAC_XCVR_MII ? \"MII\" :\n\t\t\t\t (np->mac_xcvr == MAC_XCVR_PCS ? \"PCS\" : \"XPCS\")),\n\t\t\t\tnp->vpd.phy_type);\n\t} else {\n\t\tpr_info(\"%s: Port type[%s] mode[%s:%s] XCVR[%s] phy[%s]\\n\",\n\t\t\t\tdev->name,\n\t\t\t\t(np->flags & NIU_FLAGS_XMAC ? \"XMAC\" : \"BMAC\"),\n\t\t\t\t(np->flags & NIU_FLAGS_10G ? \"10G\" : \"1G\"),\n\t\t\t\t(np->flags & NIU_FLAGS_FIBER ? \"FIBER\" :\n\t\t\t\t (np->flags & NIU_FLAGS_XCVR_SERDES ? \"SERDES\" :\n\t\t\t\t  \"COPPER\")),\n\t\t\t\t(np->mac_xcvr == MAC_XCVR_MII ? \"MII\" :\n\t\t\t\t (np->mac_xcvr == MAC_XCVR_PCS ? \"PCS\" : \"XPCS\")),\n\t\t\t\tnp->vpd.phy_type);\n\t}\n}\n\nstatic void niu_set_basic_features(struct net_device *dev)\n{\n\tdev->hw_features = NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_RXHASH;\n\tdev->features |= dev->hw_features | NETIF_F_RXCSUM;\n}\n\nstatic int niu_pci_init_one(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tunion niu_parent_id parent_id;\n\tstruct net_device *dev;\n\tstruct niu *np;\n\tint err;\n\tu64 dma_mask;\n\n\tniu_driver_version();\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot enable PCI device, aborting\\n\");\n\t\treturn err;\n\t}\n\n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM) ||\n\t    !(pci_resource_flags(pdev, 2) & IORESOURCE_MEM)) {\n\t\tdev_err(&pdev->dev, \"Cannot find proper PCI device base addresses, aborting\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_disable_pdev;\n\t}\n\n\terr = pci_request_regions(pdev, DRV_MODULE_NAME);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot obtain PCI resources, aborting\\n\");\n\t\tgoto err_out_disable_pdev;\n\t}\n\n\tif (!pci_is_pcie(pdev)) {\n\t\tdev_err(&pdev->dev, \"Cannot find PCI Express capability, aborting\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_free_res;\n\t}\n\n\tdev = niu_alloc_and_init(&pdev->dev, pdev, NULL,\n\t\t\t\t &niu_pci_ops, PCI_FUNC(pdev->devfn));\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_res;\n\t}\n\tnp = netdev_priv(dev);\n\n\tmemset(&parent_id, 0, sizeof(parent_id));\n\tparent_id.pci.domain = pci_domain_nr(pdev->bus);\n\tparent_id.pci.bus = pdev->bus->number;\n\tparent_id.pci.device = PCI_SLOT(pdev->devfn);\n\n\tnp->parent = niu_get_parent(np, &parent_id,\n\t\t\t\t    PLAT_TYPE_ATLAS);\n\tif (!np->parent) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_dev;\n\t}\n\n\tpcie_capability_clear_and_set_word(pdev, PCI_EXP_DEVCTL,\n\t\tPCI_EXP_DEVCTL_NOSNOOP_EN,\n\t\tPCI_EXP_DEVCTL_CERE | PCI_EXP_DEVCTL_NFERE |\n\t\tPCI_EXP_DEVCTL_FERE | PCI_EXP_DEVCTL_URRE |\n\t\tPCI_EXP_DEVCTL_RELAX_EN);\n\n\tdma_mask = DMA_BIT_MASK(44);\n\terr = pci_set_dma_mask(pdev, dma_mask);\n\tif (!err) {\n\t\tdev->features |= NETIF_F_HIGHDMA;\n\t\terr = pci_set_consistent_dma_mask(pdev, dma_mask);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Unable to obtain 44 bit DMA for consistent allocations, aborting\\n\");\n\t\t\tgoto err_out_release_parent;\n\t\t}\n\t}\n\tif (err) {\n\t\terr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"No usable DMA configuration, aborting\\n\");\n\t\t\tgoto err_out_release_parent;\n\t\t}\n\t}\n\n\tniu_set_basic_features(dev);\n\n\tdev->priv_flags |= IFF_UNICAST_FLT;\n\n\tnp->regs = pci_ioremap_bar(pdev, 0);\n\tif (!np->regs) {\n\t\tdev_err(&pdev->dev, \"Cannot map device registers, aborting\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out_release_parent;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_save_state(pdev);\n\n\tdev->irq = pdev->irq;\n\n\t/* MTU range: 68 - 9216 */\n\tdev->min_mtu = ETH_MIN_MTU;\n\tdev->max_mtu = NIU_MAX_MTU;\n\n\tniu_assign_netdev_ops(dev);\n\n\terr = niu_get_invariants(np);\n\tif (err) {\n\t\tif (err != -ENODEV)\n\t\t\tdev_err(&pdev->dev, \"Problem fetching invariants of chip, aborting\\n\");\n\t\tgoto err_out_iounmap;\n\t}\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot register net device, aborting\\n\");\n\t\tgoto err_out_iounmap;\n\t}\n\n\tpci_set_drvdata(pdev, dev);\n\n\tniu_device_announce(np);\n\n\treturn 0;\n\nerr_out_iounmap:\n\tif (np->regs) {\n\t\tiounmap(np->regs);\n\t\tnp->regs = NULL;\n\t}\n\nerr_out_release_parent:\n\tniu_put_parent(np);\n\nerr_out_free_dev:\n\tfree_netdev(dev);\n\nerr_out_free_res:\n\tpci_release_regions(pdev);\n\nerr_out_disable_pdev:\n\tpci_disable_device(pdev);\n\n\treturn err;\n}\n\nstatic void niu_pci_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\n\tif (dev) {\n\t\tstruct niu *np = netdev_priv(dev);\n\n\t\tunregister_netdev(dev);\n\t\tif (np->regs) {\n\t\t\tiounmap(np->regs);\n\t\t\tnp->regs = NULL;\n\t\t}\n\n\t\tniu_ldg_free(np);\n\n\t\tniu_put_parent(np);\n\n\t\tfree_netdev(dev);\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t}\n}\n\nstatic int __maybe_unused niu_suspend(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct niu *np = netdev_priv(dev);\n\tunsigned long flags;\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tflush_work(&np->reset_task);\n\tniu_netif_stop(np);\n\n\tdel_timer_sync(&np->timer);\n\n\tspin_lock_irqsave(&np->lock, flags);\n\tniu_enable_interrupts(np, 0);\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\tnetif_device_detach(dev);\n\n\tspin_lock_irqsave(&np->lock, flags);\n\tniu_stop_hw(np);\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused niu_resume(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct niu *np = netdev_priv(dev);\n\tunsigned long flags;\n\tint err;\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tnetif_device_attach(dev);\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\terr = niu_init_hw(np);\n\tif (!err) {\n\t\tnp->timer.expires = jiffies + HZ;\n\t\tadd_timer(&np->timer);\n\t\tniu_netif_start(np);\n\t}\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\treturn err;\n}\n\nstatic SIMPLE_DEV_PM_OPS(niu_pm_ops, niu_suspend, niu_resume);\n\nstatic struct pci_driver niu_pci_driver = {\n\t.name\t\t= DRV_MODULE_NAME,\n\t.id_table\t= niu_pci_tbl,\n\t.probe\t\t= niu_pci_init_one,\n\t.remove\t\t= niu_pci_remove_one,\n\t.driver.pm\t= &niu_pm_ops,\n};\n\n#ifdef CONFIG_SPARC64\nstatic void *niu_phys_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t     u64 *dma_addr, gfp_t flag)\n{\n\tunsigned long order = get_order(size);\n\tunsigned long page = __get_free_pages(flag, order);\n\n\tif (page == 0UL)\n\t\treturn NULL;\n\tmemset((char *)page, 0, PAGE_SIZE << order);\n\t*dma_addr = __pa(page);\n\n\treturn (void *) page;\n}\n\nstatic void niu_phys_free_coherent(struct device *dev, size_t size,\n\t\t\t\t   void *cpu_addr, u64 handle)\n{\n\tunsigned long order = get_order(size);\n\n\tfree_pages((unsigned long) cpu_addr, order);\n}\n\nstatic u64 niu_phys_map_page(struct device *dev, struct page *page,\n\t\t\t     unsigned long offset, size_t size,\n\t\t\t     enum dma_data_direction direction)\n{\n\treturn page_to_phys(page) + offset;\n}\n\nstatic void niu_phys_unmap_page(struct device *dev, u64 dma_address,\n\t\t\t\tsize_t size, enum dma_data_direction direction)\n{\n\t/* Nothing to do.  */\n}\n\nstatic u64 niu_phys_map_single(struct device *dev, void *cpu_addr,\n\t\t\t       size_t size,\n\t\t\t       enum dma_data_direction direction)\n{\n\treturn __pa(cpu_addr);\n}\n\nstatic void niu_phys_unmap_single(struct device *dev, u64 dma_address,\n\t\t\t\t  size_t size,\n\t\t\t\t  enum dma_data_direction direction)\n{\n\t/* Nothing to do.  */\n}\n\nstatic const struct niu_ops niu_phys_ops = {\n\t.alloc_coherent\t= niu_phys_alloc_coherent,\n\t.free_coherent\t= niu_phys_free_coherent,\n\t.map_page\t= niu_phys_map_page,\n\t.unmap_page\t= niu_phys_unmap_page,\n\t.map_single\t= niu_phys_map_single,\n\t.unmap_single\t= niu_phys_unmap_single,\n};\n\nstatic int niu_of_probe(struct platform_device *op)\n{\n\tunion niu_parent_id parent_id;\n\tstruct net_device *dev;\n\tstruct niu *np;\n\tconst u32 *reg;\n\tint err;\n\n\tniu_driver_version();\n\n\treg = of_get_property(op->dev.of_node, \"reg\", NULL);\n\tif (!reg) {\n\t\tdev_err(&op->dev, \"%pOF: No 'reg' property, aborting\\n\",\n\t\t\top->dev.of_node);\n\t\treturn -ENODEV;\n\t}\n\n\tdev = niu_alloc_and_init(&op->dev, NULL, op,\n\t\t\t\t &niu_phys_ops, reg[0] & 0x1);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tnp = netdev_priv(dev);\n\n\tmemset(&parent_id, 0, sizeof(parent_id));\n\tparent_id.of = of_get_parent(op->dev.of_node);\n\n\tnp->parent = niu_get_parent(np, &parent_id,\n\t\t\t\t    PLAT_TYPE_NIU);\n\tif (!np->parent) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_dev;\n\t}\n\n\tniu_set_basic_features(dev);\n\n\tnp->regs = of_ioremap(&op->resource[1], 0,\n\t\t\t      resource_size(&op->resource[1]),\n\t\t\t      \"niu regs\");\n\tif (!np->regs) {\n\t\tdev_err(&op->dev, \"Cannot map device registers, aborting\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out_release_parent;\n\t}\n\n\tnp->vir_regs_1 = of_ioremap(&op->resource[2], 0,\n\t\t\t\t    resource_size(&op->resource[2]),\n\t\t\t\t    \"niu vregs-1\");\n\tif (!np->vir_regs_1) {\n\t\tdev_err(&op->dev, \"Cannot map device vir registers 1, aborting\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out_iounmap;\n\t}\n\n\tnp->vir_regs_2 = of_ioremap(&op->resource[3], 0,\n\t\t\t\t    resource_size(&op->resource[3]),\n\t\t\t\t    \"niu vregs-2\");\n\tif (!np->vir_regs_2) {\n\t\tdev_err(&op->dev, \"Cannot map device vir registers 2, aborting\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out_iounmap;\n\t}\n\n\tniu_assign_netdev_ops(dev);\n\n\terr = niu_get_invariants(np);\n\tif (err) {\n\t\tif (err != -ENODEV)\n\t\t\tdev_err(&op->dev, \"Problem fetching invariants of chip, aborting\\n\");\n\t\tgoto err_out_iounmap;\n\t}\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_err(&op->dev, \"Cannot register net device, aborting\\n\");\n\t\tgoto err_out_iounmap;\n\t}\n\n\tplatform_set_drvdata(op, dev);\n\n\tniu_device_announce(np);\n\n\treturn 0;\n\nerr_out_iounmap:\n\tif (np->vir_regs_1) {\n\t\tof_iounmap(&op->resource[2], np->vir_regs_1,\n\t\t\t   resource_size(&op->resource[2]));\n\t\tnp->vir_regs_1 = NULL;\n\t}\n\n\tif (np->vir_regs_2) {\n\t\tof_iounmap(&op->resource[3], np->vir_regs_2,\n\t\t\t   resource_size(&op->resource[3]));\n\t\tnp->vir_regs_2 = NULL;\n\t}\n\n\tif (np->regs) {\n\t\tof_iounmap(&op->resource[1], np->regs,\n\t\t\t   resource_size(&op->resource[1]));\n\t\tnp->regs = NULL;\n\t}\n\nerr_out_release_parent:\n\tniu_put_parent(np);\n\nerr_out_free_dev:\n\tfree_netdev(dev);\n\nerr_out:\n\treturn err;\n}\n\nstatic int niu_of_remove(struct platform_device *op)\n{\n\tstruct net_device *dev = platform_get_drvdata(op);\n\n\tif (dev) {\n\t\tstruct niu *np = netdev_priv(dev);\n\n\t\tunregister_netdev(dev);\n\n\t\tif (np->vir_regs_1) {\n\t\t\tof_iounmap(&op->resource[2], np->vir_regs_1,\n\t\t\t\t   resource_size(&op->resource[2]));\n\t\t\tnp->vir_regs_1 = NULL;\n\t\t}\n\n\t\tif (np->vir_regs_2) {\n\t\t\tof_iounmap(&op->resource[3], np->vir_regs_2,\n\t\t\t\t   resource_size(&op->resource[3]));\n\t\t\tnp->vir_regs_2 = NULL;\n\t\t}\n\n\t\tif (np->regs) {\n\t\t\tof_iounmap(&op->resource[1], np->regs,\n\t\t\t\t   resource_size(&op->resource[1]));\n\t\t\tnp->regs = NULL;\n\t\t}\n\n\t\tniu_ldg_free(np);\n\n\t\tniu_put_parent(np);\n\n\t\tfree_netdev(dev);\n\t}\n\treturn 0;\n}\n\nstatic const struct of_device_id niu_match[] = {\n\t{\n\t\t.name = \"network\",\n\t\t.compatible = \"SUNW,niusl\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, niu_match);\n\nstatic struct platform_driver niu_of_driver = {\n\t.driver = {\n\t\t.name = \"niu\",\n\t\t.of_match_table = niu_match,\n\t},\n\t.probe\t\t= niu_of_probe,\n\t.remove\t\t= niu_of_remove,\n};\n\n#endif /* CONFIG_SPARC64 */\n\nstatic int __init niu_init(void)\n{\n\tint err = 0;\n\n\tBUILD_BUG_ON(PAGE_SIZE < 4 * 1024);\n\n\tniu_debug = netif_msg_init(debug, NIU_MSG_DEFAULT);\n\n#ifdef CONFIG_SPARC64\n\terr = platform_driver_register(&niu_of_driver);\n#endif\n\n\tif (!err) {\n\t\terr = pci_register_driver(&niu_pci_driver);\n#ifdef CONFIG_SPARC64\n\t\tif (err)\n\t\t\tplatform_driver_unregister(&niu_of_driver);\n#endif\n\t}\n\n\treturn err;\n}\n\nstatic void __exit niu_exit(void)\n{\n\tpci_unregister_driver(&niu_pci_driver);\n#ifdef CONFIG_SPARC64\n\tplatform_driver_unregister(&niu_of_driver);\n#endif\n}\n\nmodule_init(niu_init);\nmodule_exit(niu_exit);\n"}}, "reports": [{"events": [{"location": {"col": 5, "file": 0, "line": 9555}, "message": "atomic_dec_and_test variation before object free at line 9556."}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/sun/niu.c", "reportHash": "f1eeaef048c547fdca6d3971a7edcd0d", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
