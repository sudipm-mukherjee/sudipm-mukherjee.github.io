<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/src/net/wireless/nl80211.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * This is the new netlink-based wireless configuration interface.\n *\n * Copyright 2006-2010\tJohannes Berg <johannes@sipsolutions.net>\n * Copyright 2013-2014  Intel Mobile Communications GmbH\n * Copyright 2015-2017\tIntel Deutschland GmbH\n * Copyright (C) 2018-2020 Intel Corporation\n */\n\n#include <linux/if.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/if_ether.h>\n#include <linux/ieee80211.h>\n#include <linux/nl80211.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <linux/nospec.h>\n#include <linux/etherdevice.h>\n#include <linux/if_vlan.h>\n#include <net/net_namespace.h>\n#include <net/genetlink.h>\n#include <net/cfg80211.h>\n#include <net/sock.h>\n#include <net/inet_connection_sock.h>\n#include \"core.h\"\n#include \"nl80211.h\"\n#include \"reg.h\"\n#include \"rdev-ops.h\"\n\nstatic int nl80211_crypto_settings(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct genl_info *info,\n\t\t\t\t   struct cfg80211_crypto_settings *settings,\n\t\t\t\t   int cipher_limit);\n\n/* the netlink family */\nstatic struct genl_family nl80211_fam;\n\n/* multicast groups */\nenum nl80211_multicast_groups {\n\tNL80211_MCGRP_CONFIG,\n\tNL80211_MCGRP_SCAN,\n\tNL80211_MCGRP_REGULATORY,\n\tNL80211_MCGRP_MLME,\n\tNL80211_MCGRP_VENDOR,\n\tNL80211_MCGRP_NAN,\n\tNL80211_MCGRP_TESTMODE /* keep last - ifdef! */\n};\n\nstatic const struct genl_multicast_group nl80211_mcgrps[] = {\n\t[NL80211_MCGRP_CONFIG] = { .name = NL80211_MULTICAST_GROUP_CONFIG },\n\t[NL80211_MCGRP_SCAN] = { .name = NL80211_MULTICAST_GROUP_SCAN },\n\t[NL80211_MCGRP_REGULATORY] = { .name = NL80211_MULTICAST_GROUP_REG },\n\t[NL80211_MCGRP_MLME] = { .name = NL80211_MULTICAST_GROUP_MLME },\n\t[NL80211_MCGRP_VENDOR] = { .name = NL80211_MULTICAST_GROUP_VENDOR },\n\t[NL80211_MCGRP_NAN] = { .name = NL80211_MULTICAST_GROUP_NAN },\n#ifdef CONFIG_NL80211_TESTMODE\n\t[NL80211_MCGRP_TESTMODE] = { .name = NL80211_MULTICAST_GROUP_TESTMODE }\n#endif\n};\n\n/* returns ERR_PTR values */\nstatic struct wireless_dev *\n__cfg80211_wdev_from_attrs(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net *netns, struct nlattr **attrs)\n{\n\tstruct wireless_dev *result = NULL;\n\tbool have_ifidx = attrs[NL80211_ATTR_IFINDEX];\n\tbool have_wdev_id = attrs[NL80211_ATTR_WDEV];\n\tu64 wdev_id;\n\tint wiphy_idx = -1;\n\tint ifidx = -1;\n\n\tif (!have_ifidx && !have_wdev_id)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (have_ifidx)\n\t\tifidx = nla_get_u32(attrs[NL80211_ATTR_IFINDEX]);\n\tif (have_wdev_id) {\n\t\twdev_id = nla_get_u64(attrs[NL80211_ATTR_WDEV]);\n\t\twiphy_idx = wdev_id >> 32;\n\t}\n\n\tif (rdev) {\n\t\tstruct wireless_dev *wdev;\n\n\t\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\t\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tif (have_ifidx && wdev->netdev &&\n\t\t\t    wdev->netdev->ifindex == ifidx) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (have_wdev_id && wdev->identifier == (u32)wdev_id) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result ?: ERR_PTR(-ENODEV);\n\t}\n\n\tASSERT_RTNL();\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tstruct wireless_dev *wdev;\n\n\t\tif (wiphy_net(&rdev->wiphy) != netns)\n\t\t\tcontinue;\n\n\t\tif (have_wdev_id && rdev->wiphy_idx != wiphy_idx)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tif (have_ifidx && wdev->netdev &&\n\t\t\t    wdev->netdev->ifindex == ifidx) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (have_wdev_id && wdev->identifier == (u32)wdev_id) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (result)\n\t\t\tbreak;\n\t}\n\n\tif (result)\n\t\treturn result;\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic struct cfg80211_registered_device *\n__cfg80211_rdev_from_attrs(struct net *netns, struct nlattr **attrs)\n{\n\tstruct cfg80211_registered_device *rdev = NULL, *tmp;\n\tstruct net_device *netdev;\n\n\tASSERT_RTNL();\n\n\tif (!attrs[NL80211_ATTR_WIPHY] &&\n\t    !attrs[NL80211_ATTR_IFINDEX] &&\n\t    !attrs[NL80211_ATTR_WDEV])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attrs[NL80211_ATTR_WIPHY])\n\t\trdev = cfg80211_rdev_by_wiphy_idx(\n\t\t\t\tnla_get_u32(attrs[NL80211_ATTR_WIPHY]));\n\n\tif (attrs[NL80211_ATTR_WDEV]) {\n\t\tu64 wdev_id = nla_get_u64(attrs[NL80211_ATTR_WDEV]);\n\t\tstruct wireless_dev *wdev;\n\t\tbool found = false;\n\n\t\ttmp = cfg80211_rdev_by_wiphy_idx(wdev_id >> 32);\n\t\tif (tmp) {\n\t\t\t/* make sure wdev exists */\n\t\t\tlist_for_each_entry(wdev, &tmp->wiphy.wdev_list, list) {\n\t\t\t\tif (wdev->identifier != (u32)wdev_id)\n\t\t\t\t\tcontinue;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!found)\n\t\t\t\ttmp = NULL;\n\n\t\t\tif (rdev && tmp != rdev)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\trdev = tmp;\n\t\t}\n\t}\n\n\tif (attrs[NL80211_ATTR_IFINDEX]) {\n\t\tint ifindex = nla_get_u32(attrs[NL80211_ATTR_IFINDEX]);\n\n\t\tnetdev = __dev_get_by_index(netns, ifindex);\n\t\tif (netdev) {\n\t\t\tif (netdev->ieee80211_ptr)\n\t\t\t\ttmp = wiphy_to_rdev(\n\t\t\t\t\tnetdev->ieee80211_ptr->wiphy);\n\t\t\telse\n\t\t\t\ttmp = NULL;\n\n\t\t\t/* not wireless device -- return error */\n\t\t\tif (!tmp)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\t/* mismatch -- return error */\n\t\t\tif (rdev && tmp != rdev)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\trdev = tmp;\n\t\t}\n\t}\n\n\tif (!rdev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (netns != wiphy_net(&rdev->wiphy))\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn rdev;\n}\n\n/*\n * This function returns a pointer to the driver\n * that the genl_info item that is passed refers to.\n *\n * The result of this can be a PTR_ERR and hence must\n * be checked with IS_ERR() for errors.\n */\nstatic struct cfg80211_registered_device *\ncfg80211_get_dev_from_info(struct net *netns, struct genl_info *info)\n{\n\treturn __cfg80211_rdev_from_attrs(netns, info->attrs);\n}\n\nstatic int validate_beacon_head(const struct nlattr *attr,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tconst u8 *data = nla_data(attr);\n\tunsigned int len = nla_len(attr);\n\tconst struct element *elem;\n\tconst struct ieee80211_mgmt *mgmt = (void *)data;\n\tbool s1g_bcn = ieee80211_is_s1g_beacon(mgmt->frame_control);\n\tunsigned int fixedlen, hdrlen;\n\n\tif (s1g_bcn) {\n\t\tfixedlen = offsetof(struct ieee80211_ext,\n\t\t\t\t    u.s1g_beacon.variable);\n\t\thdrlen = offsetof(struct ieee80211_ext, u.s1g_beacon);\n\t} else {\n\t\tfixedlen = offsetof(struct ieee80211_mgmt,\n\t\t\t\t    u.beacon.variable);\n\t\thdrlen = offsetof(struct ieee80211_mgmt, u.beacon);\n\t}\n\n\tif (len < fixedlen)\n\t\tgoto err;\n\n\tif (ieee80211_hdrlen(mgmt->frame_control) != hdrlen)\n\t\tgoto err;\n\n\tdata += fixedlen;\n\tlen -= fixedlen;\n\n\tfor_each_element(elem, data, len) {\n\t\t/* nothing */\n\t}\n\n\tif (for_each_element_completed(elem, data, len))\n\t\treturn 0;\n\nerr:\n\tNL_SET_ERR_MSG_ATTR(extack, attr, \"malformed beacon head\");\n\treturn -EINVAL;\n}\n\nstatic int validate_ie_attr(const struct nlattr *attr,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tconst u8 *data = nla_data(attr);\n\tunsigned int len = nla_len(attr);\n\tconst struct element *elem;\n\n\tfor_each_element(elem, data, len) {\n\t\t/* nothing */\n\t}\n\n\tif (for_each_element_completed(elem, data, len))\n\t\treturn 0;\n\n\tNL_SET_ERR_MSG_ATTR(extack, attr, \"malformed information elements\");\n\treturn -EINVAL;\n}\n\n/* policy for the attributes */\nstatic const struct nla_policy nl80211_policy[NUM_NL80211_ATTR];\n\nstatic const struct nla_policy\nnl80211_ftm_responder_policy[NL80211_FTM_RESP_ATTR_MAX + 1] = {\n\t[NL80211_FTM_RESP_ATTR_ENABLED] = { .type = NLA_FLAG, },\n\t[NL80211_FTM_RESP_ATTR_LCI] = { .type = NLA_BINARY,\n\t\t\t\t\t.len = U8_MAX },\n\t[NL80211_FTM_RESP_ATTR_CIVICLOC] = { .type = NLA_BINARY,\n\t\t\t\t\t     .len = U8_MAX },\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_ftm_req_attr_policy[NL80211_PMSR_FTM_REQ_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_FTM_REQ_ATTR_ASAP] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE] = { .type = NLA_U32 },\n\t[NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP] =\n\t\tNLA_POLICY_MAX(NLA_U8, 15),\n\t[NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD] = { .type = NLA_U16 },\n\t[NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION] =\n\t\tNLA_POLICY_MAX(NLA_U8, 15),\n\t[NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST] =\n\t\tNLA_POLICY_MAX(NLA_U8, 31),\n\t[NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES] = { .type = NLA_U8 },\n\t[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED] = { .type = NLA_FLAG },\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_req_data_policy[NL80211_PMSR_TYPE_MAX + 1] = {\n\t[NL80211_PMSR_TYPE_FTM] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_ftm_req_attr_policy),\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_req_attr_policy[NL80211_PMSR_REQ_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_REQ_ATTR_DATA] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_req_data_policy),\n\t[NL80211_PMSR_REQ_ATTR_GET_AP_TSF] = { .type = NLA_FLAG },\n};\n\nstatic const struct nla_policy\nnl80211_psmr_peer_attr_policy[NL80211_PMSR_PEER_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_PEER_ATTR_ADDR] = NLA_POLICY_ETH_ADDR,\n\t[NL80211_PMSR_PEER_ATTR_CHAN] = NLA_POLICY_NESTED(nl80211_policy),\n\t[NL80211_PMSR_PEER_ATTR_REQ] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_req_attr_policy),\n\t[NL80211_PMSR_PEER_ATTR_RESP] = { .type = NLA_REJECT },\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_attr_policy[NL80211_PMSR_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_ATTR_MAX_PEERS] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_REPORT_AP_TSF] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_TYPE_CAPA] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_PEERS] =\n\t\tNLA_POLICY_NESTED_ARRAY(nl80211_psmr_peer_attr_policy),\n};\n\nstatic const struct nla_policy\nhe_obss_pd_policy[NL80211_HE_OBSS_PD_ATTR_MAX + 1] = {\n\t[NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET] =\n\t\tNLA_POLICY_RANGE(NLA_U8, 1, 20),\n\t[NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET] =\n\t\tNLA_POLICY_RANGE(NLA_U8, 1, 20),\n\t[NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET] =\n\t\tNLA_POLICY_RANGE(NLA_U8, 1, 20),\n\t[NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP] =\n\t\tNLA_POLICY_EXACT_LEN(8),\n\t[NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP] =\n\t\tNLA_POLICY_EXACT_LEN(8),\n\t[NL80211_HE_OBSS_PD_ATTR_SR_CTRL] = { .type = NLA_U8 },\n};\n\nstatic const struct nla_policy\nhe_bss_color_policy[NL80211_HE_BSS_COLOR_ATTR_MAX + 1] = {\n\t[NL80211_HE_BSS_COLOR_ATTR_COLOR] = NLA_POLICY_RANGE(NLA_U8, 1, 63),\n\t[NL80211_HE_BSS_COLOR_ATTR_DISABLED] = { .type = NLA_FLAG },\n\t[NL80211_HE_BSS_COLOR_ATTR_PARTIAL] = { .type = NLA_FLAG },\n};\n\nstatic const struct nla_policy nl80211_txattr_policy[NL80211_TXRATE_MAX + 1] = {\n\t[NL80211_TXRATE_LEGACY] = { .type = NLA_BINARY,\n\t\t\t\t    .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_TXRATE_HT] = { .type = NLA_BINARY,\n\t\t\t\t.len = NL80211_MAX_SUPP_HT_RATES },\n\t[NL80211_TXRATE_VHT] = NLA_POLICY_EXACT_LEN_WARN(sizeof(struct nl80211_txrate_vht)),\n\t[NL80211_TXRATE_GI] = { .type = NLA_U8 },\n\t[NL80211_TXRATE_HE] = NLA_POLICY_EXACT_LEN(sizeof(struct nl80211_txrate_he)),\n\t[NL80211_TXRATE_HE_GI] =  NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\t   NL80211_RATE_INFO_HE_GI_0_8,\n\t\t\t\t\t\t   NL80211_RATE_INFO_HE_GI_3_2),\n\t[NL80211_TXRATE_HE_LTF] = NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\t   NL80211_RATE_INFO_HE_1XLTF,\n\t\t\t\t\t\t   NL80211_RATE_INFO_HE_4XLTF),\n};\n\nstatic const struct nla_policy\nnl80211_tid_config_attr_policy[NL80211_TID_CONFIG_ATTR_MAX + 1] = {\n\t[NL80211_TID_CONFIG_ATTR_VIF_SUPP] = { .type = NLA_U64 },\n\t[NL80211_TID_CONFIG_ATTR_PEER_SUPP] = { .type = NLA_U64 },\n\t[NL80211_TID_CONFIG_ATTR_OVERRIDE] = { .type = NLA_FLAG },\n\t[NL80211_TID_CONFIG_ATTR_TIDS] = NLA_POLICY_RANGE(NLA_U16, 1, 0xff),\n\t[NL80211_TID_CONFIG_ATTR_NOACK] =\n\t\t\tNLA_POLICY_MAX(NLA_U8, NL80211_TID_CONFIG_DISABLE),\n\t[NL80211_TID_CONFIG_ATTR_RETRY_SHORT] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_TID_CONFIG_ATTR_RETRY_LONG] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_TID_CONFIG_ATTR_AMPDU_CTRL] =\n\t\t\tNLA_POLICY_MAX(NLA_U8, NL80211_TID_CONFIG_DISABLE),\n\t[NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL] =\n\t\t\tNLA_POLICY_MAX(NLA_U8, NL80211_TID_CONFIG_DISABLE),\n\t[NL80211_TID_CONFIG_ATTR_AMSDU_CTRL] =\n\t\t\tNLA_POLICY_MAX(NLA_U8, NL80211_TID_CONFIG_DISABLE),\n\t[NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE] =\n\t\t\tNLA_POLICY_MAX(NLA_U8, NL80211_TX_RATE_FIXED),\n\t[NL80211_TID_CONFIG_ATTR_TX_RATE] =\n\t\t\tNLA_POLICY_NESTED(nl80211_txattr_policy),\n};\n\nstatic const struct nla_policy\nnl80211_fils_discovery_policy[NL80211_FILS_DISCOVERY_ATTR_MAX + 1] = {\n\t[NL80211_FILS_DISCOVERY_ATTR_INT_MIN] = NLA_POLICY_MAX(NLA_U32, 10000),\n\t[NL80211_FILS_DISCOVERY_ATTR_INT_MAX] = NLA_POLICY_MAX(NLA_U32, 10000),\n\tNLA_POLICY_RANGE(NLA_BINARY,\n\t\t\t NL80211_FILS_DISCOVERY_TMPL_MIN_LEN,\n\t\t\t IEEE80211_MAX_DATA_LEN),\n};\n\nstatic const struct nla_policy\nnl80211_unsol_bcast_probe_resp_policy[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX + 1] = {\n\t[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT] = NLA_POLICY_MAX(NLA_U32, 20),\n\t[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL] = { .type = NLA_BINARY,\n\t\t\t\t\t\t       .len = IEEE80211_MAX_DATA_LEN }\n};\n\nstatic const struct nla_policy\nsar_specs_policy[NL80211_SAR_ATTR_SPECS_MAX + 1] = {\n\t[NL80211_SAR_ATTR_SPECS_POWER] = { .type = NLA_S32 },\n\t[NL80211_SAR_ATTR_SPECS_RANGE_INDEX] = {.type = NLA_U32 },\n};\n\nstatic const struct nla_policy\nsar_policy[NL80211_SAR_ATTR_MAX + 1] = {\n\t[NL80211_SAR_ATTR_TYPE] = NLA_POLICY_MAX(NLA_U32, NUM_NL80211_SAR_TYPE),\n\t[NL80211_SAR_ATTR_SPECS] = NLA_POLICY_NESTED_ARRAY(sar_specs_policy),\n};\n\nstatic const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {\n\t[0] = { .strict_start_type = NL80211_ATTR_HE_OBSS_PD },\n\t[NL80211_ATTR_WIPHY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_NAME] = { .type = NLA_NUL_STRING,\n\t\t\t\t      .len = 20-1 },\n\t[NL80211_ATTR_WIPHY_TXQ_PARAMS] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_WIPHY_FREQ] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_CHANNEL_TYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_EDMG_CHANNELS] = NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\tNL80211_EDMG_CHANNELS_MIN,\n\t\t\t\t\t\tNL80211_EDMG_CHANNELS_MAX),\n\t[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG] = NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\tNL80211_EDMG_BW_CONFIG_MIN,\n\t\t\t\t\t\tNL80211_EDMG_BW_CONFIG_MAX),\n\n\t[NL80211_ATTR_CHANNEL_WIDTH] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CENTER_FREQ1] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CENTER_FREQ1_OFFSET] = NLA_POLICY_RANGE(NLA_U32, 0, 999),\n\t[NL80211_ATTR_CENTER_FREQ2] = { .type = NLA_U32 },\n\n\t[NL80211_ATTR_WIPHY_RETRY_SHORT] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_ATTR_WIPHY_RETRY_LONG] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_ATTR_WIPHY_FRAG_THRESHOLD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_RTS_THRESHOLD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_COVERAGE_CLASS] = { .type = NLA_U8 },\n\t[NL80211_ATTR_WIPHY_DYN_ACK] = { .type = NLA_FLAG },\n\n\t[NL80211_ATTR_IFTYPE] = NLA_POLICY_MAX(NLA_U32, NL80211_IFTYPE_MAX),\n\t[NL80211_ATTR_IFINDEX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_IFNAME] = { .type = NLA_NUL_STRING, .len = IFNAMSIZ-1 },\n\n\t[NL80211_ATTR_MAC] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_ATTR_PREV_BSSID] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\n\t[NL80211_ATTR_KEY] = { .type = NLA_NESTED, },\n\t[NL80211_ATTR_KEY_DATA] = { .type = NLA_BINARY,\n\t\t\t\t    .len = WLAN_MAX_KEY_LEN },\n\t[NL80211_ATTR_KEY_IDX] = NLA_POLICY_MAX(NLA_U8, 7),\n\t[NL80211_ATTR_KEY_CIPHER] = { .type = NLA_U32 },\n\t[NL80211_ATTR_KEY_DEFAULT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_KEY_SEQ] = { .type = NLA_BINARY, .len = 16 },\n\t[NL80211_ATTR_KEY_TYPE] =\n\t\tNLA_POLICY_MAX(NLA_U32, NUM_NL80211_KEYTYPES),\n\n\t[NL80211_ATTR_BEACON_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_DTIM_PERIOD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_BEACON_HEAD] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_beacon_head,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_BEACON_TAIL] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_STA_AID] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, IEEE80211_MAX_AID),\n\t[NL80211_ATTR_STA_FLAGS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_LISTEN_INTERVAL] = { .type = NLA_U16 },\n\t[NL80211_ATTR_STA_SUPPORTED_RATES] = { .type = NLA_BINARY,\n\t\t\t\t\t       .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_ATTR_STA_PLINK_ACTION] =\n\t\tNLA_POLICY_MAX(NLA_U8, NUM_NL80211_PLINK_ACTIONS - 1),\n\t[NL80211_ATTR_STA_TX_POWER_SETTING] =\n\t\tNLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t NL80211_TX_POWER_AUTOMATIC,\n\t\t\t\t NL80211_TX_POWER_FIXED),\n\t[NL80211_ATTR_STA_TX_POWER] = { .type = NLA_S16 },\n\t[NL80211_ATTR_STA_VLAN] = { .type = NLA_U32 },\n\t[NL80211_ATTR_MNTR_FLAGS] = { /* NLA_NESTED can't be empty */ },\n\t[NL80211_ATTR_MESH_ID] = { .type = NLA_BINARY,\n\t\t\t\t   .len = IEEE80211_MAX_MESH_ID_LEN },\n\t[NL80211_ATTR_MPATH_NEXT_HOP] = NLA_POLICY_ETH_ADDR_COMPAT,\n\n\t[NL80211_ATTR_REG_ALPHA2] = { .type = NLA_STRING, .len = 2 },\n\t[NL80211_ATTR_REG_RULES] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_BSS_CTS_PROT] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_SHORT_PREAMBLE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_SHORT_SLOT_TIME] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_BASIC_RATES] = { .type = NLA_BINARY,\n\t\t\t\t\t   .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_ATTR_BSS_HT_OPMODE] = { .type = NLA_U16 },\n\n\t[NL80211_ATTR_MESH_CONFIG] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SUPPORT_MESH_AUTH] = { .type = NLA_FLAG },\n\n\t[NL80211_ATTR_HT_CAPABILITY] = NLA_POLICY_EXACT_LEN_WARN(NL80211_HT_CAPABILITY_LEN),\n\n\t[NL80211_ATTR_MGMT_SUBTYPE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_IE] = NLA_POLICY_VALIDATE_FN(NLA_BINARY,\n\t\t\t\t\t\t   validate_ie_attr,\n\t\t\t\t\t\t   IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_SCAN_FREQUENCIES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SCAN_SSIDS] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_SSID] = { .type = NLA_BINARY,\n\t\t\t\t.len = IEEE80211_MAX_SSID_LEN },\n\t[NL80211_ATTR_AUTH_TYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_REASON_CODE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_FREQ_FIXED] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TIMED_OUT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_USE_MFP] = NLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t\t\t  NL80211_MFP_NO,\n\t\t\t\t\t\t  NL80211_MFP_OPTIONAL),\n\t[NL80211_ATTR_STA_FLAGS2] = {\n\t\t.len = sizeof(struct nl80211_sta_flag_update),\n\t},\n\t[NL80211_ATTR_CONTROL_PORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CONTROL_PORT_ETHERTYPE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CONTROL_PORT_OVER_NL80211] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PRIVACY] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_STATUS_CODE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_CIPHER_SUITE_GROUP] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WPA_VERSIONS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_PID] = { .type = NLA_U32 },\n\t[NL80211_ATTR_4ADDR] = { .type = NLA_U8 },\n\t[NL80211_ATTR_PMKID] = NLA_POLICY_EXACT_LEN_WARN(WLAN_PMKID_LEN),\n\t[NL80211_ATTR_DURATION] = { .type = NLA_U32 },\n\t[NL80211_ATTR_COOKIE] = { .type = NLA_U64 },\n\t[NL80211_ATTR_TX_RATES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_FRAME] = { .type = NLA_BINARY,\n\t\t\t\t .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_FRAME_MATCH] = { .type = NLA_BINARY, },\n\t[NL80211_ATTR_PS_STATE] = NLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t\t\t   NL80211_PS_DISABLED,\n\t\t\t\t\t\t   NL80211_PS_ENABLED),\n\t[NL80211_ATTR_CQM] = { .type = NLA_NESTED, },\n\t[NL80211_ATTR_LOCAL_STATE_CHANGE] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_AP_ISOLATE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_WIPHY_TX_POWER_SETTING] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_TX_POWER_LEVEL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_FRAME_TYPE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_WIPHY_ANTENNA_TX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_ANTENNA_RX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_MCAST_RATE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_OFFCHANNEL_TX_OK] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_KEY_DEFAULT_TYPES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_WOWLAN_TRIGGERS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_PLINK_STATE] =\n\t\tNLA_POLICY_MAX(NLA_U8, NUM_NL80211_PLINK_STATES - 1),\n\t[NL80211_ATTR_MEASUREMENT_DURATION] = { .type = NLA_U16 },\n\t[NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_MESH_PEER_AID] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, IEEE80211_MAX_AID),\n\t[NL80211_ATTR_SCHED_SCAN_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_REKEY_DATA] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SCAN_SUPP_RATES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_HIDDEN_SSID] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_HIDDEN_SSID_NOT_IN_USE,\n\t\t\t\t NL80211_HIDDEN_SSID_ZERO_CONTENTS),\n\t[NL80211_ATTR_IE_PROBE_RESP] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_IE_ASSOC_RESP] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_ROAM_SUPPORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_SCHED_SCAN_MATCH] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_TX_NO_CCK_RATE] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TDLS_ACTION] = { .type = NLA_U8 },\n\t[NL80211_ATTR_TDLS_DIALOG_TOKEN] = { .type = NLA_U8 },\n\t[NL80211_ATTR_TDLS_OPERATION] = { .type = NLA_U8 },\n\t[NL80211_ATTR_TDLS_SUPPORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TDLS_EXTERNAL_SETUP] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TDLS_INITIATOR] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_DONT_WAIT_FOR_ACK] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PROBE_RESP] = { .type = NLA_BINARY,\n\t\t\t\t      .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_DFS_REGION] = { .type = NLA_U8 },\n\t[NL80211_ATTR_DISABLE_HT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_HT_CAPABILITY_MASK] = {\n\t\t.len = NL80211_HT_CAPABILITY_LEN\n\t},\n\t[NL80211_ATTR_NOACK_MAP] = { .type = NLA_U16 },\n\t[NL80211_ATTR_INACTIVITY_TIMEOUT] = { .type = NLA_U16 },\n\t[NL80211_ATTR_BG_SCAN_PERIOD] = { .type = NLA_U16 },\n\t[NL80211_ATTR_WDEV] = { .type = NLA_U64 },\n\t[NL80211_ATTR_USER_REG_HINT_TYPE] = { .type = NLA_U32 },\n\n\t/* need to include at least Auth Transaction and Status Code */\n\t[NL80211_ATTR_AUTH_DATA] = NLA_POLICY_MIN_LEN(4),\n\n\t[NL80211_ATTR_VHT_CAPABILITY] = NLA_POLICY_EXACT_LEN_WARN(NL80211_VHT_CAPABILITY_LEN),\n\t[NL80211_ATTR_SCAN_FLAGS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_P2P_CTWINDOW] = NLA_POLICY_MAX(NLA_U8, 127),\n\t[NL80211_ATTR_P2P_OPPPS] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_ATTR_LOCAL_MESH_POWER_MODE] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_MESH_POWER_UNKNOWN + 1,\n\t\t\t\t NL80211_MESH_POWER_MAX),\n\t[NL80211_ATTR_ACL_POLICY] = {. type = NLA_U32 },\n\t[NL80211_ATTR_MAC_ADDRS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_CAPABILITY] = { .type = NLA_U16 },\n\t[NL80211_ATTR_STA_EXT_CAPABILITY] = { .type = NLA_BINARY, },\n\t[NL80211_ATTR_SPLIT_WIPHY_DUMP] = { .type = NLA_FLAG, },\n\t[NL80211_ATTR_DISABLE_VHT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_VHT_CAPABILITY_MASK] = {\n\t\t.len = NL80211_VHT_CAPABILITY_LEN,\n\t},\n\t[NL80211_ATTR_MDID] = { .type = NLA_U16 },\n\t[NL80211_ATTR_IE_RIC] = { .type = NLA_BINARY,\n\t\t\t\t  .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_CRIT_PROT_ID] = { .type = NLA_U16 },\n\t[NL80211_ATTR_MAX_CRIT_PROT_DURATION] =\n\t\tNLA_POLICY_MAX(NLA_U16, NL80211_CRIT_PROTO_MAX_DURATION),\n\t[NL80211_ATTR_PEER_AID] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, IEEE80211_MAX_AID),\n\t[NL80211_ATTR_CH_SWITCH_COUNT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CH_SWITCH_BLOCK_TX] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CSA_IES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_CNTDWN_OFFS_BEACON] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_CNTDWN_OFFS_PRESP] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_STA_SUPPORTED_CHANNELS] = NLA_POLICY_MIN_LEN(2),\n\t/*\n\t * The value of the Length field of the Supported Operating\n\t * Classes element is between 2 and 253.\n\t */\n\t[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES] =\n\t\tNLA_POLICY_RANGE(NLA_BINARY, 2, 253),\n\t[NL80211_ATTR_HANDLE_DFS] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_OPMODE_NOTIF] = { .type = NLA_U8 },\n\t[NL80211_ATTR_VENDOR_ID] = { .type = NLA_U32 },\n\t[NL80211_ATTR_VENDOR_SUBCMD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_VENDOR_DATA] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_QOS_MAP] = NLA_POLICY_RANGE(NLA_BINARY,\n\t\t\t\t\t\t  IEEE80211_QOS_MAP_LEN_MIN,\n\t\t\t\t\t\t  IEEE80211_QOS_MAP_LEN_MAX),\n\t[NL80211_ATTR_MAC_HINT] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_ATTR_WIPHY_FREQ_HINT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_TDLS_PEER_CAPABILITY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_SOCKET_OWNER] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CSA_C_OFFSETS_TX] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_USE_RRM] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TSID] = NLA_POLICY_MAX(NLA_U8, IEEE80211_NUM_TIDS - 1),\n\t[NL80211_ATTR_USER_PRIO] =\n\t\tNLA_POLICY_MAX(NLA_U8, IEEE80211_NUM_UPS - 1),\n\t[NL80211_ATTR_ADMITTED_TIME] = { .type = NLA_U16 },\n\t[NL80211_ATTR_SMPS_MODE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_OPER_CLASS] = { .type = NLA_U8 },\n\t[NL80211_ATTR_MAC_MASK] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_ATTR_WIPHY_SELF_MANAGED_REG] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_NETNS_FD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_SCHED_SCAN_DELAY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_REG_INDOOR] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PBSS] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_BSS_SELECT] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_SUPPORT_P2P_PS] =\n\t\tNLA_POLICY_MAX(NLA_U8, NUM_NL80211_P2P_PS_STATUS - 1),\n\t[NL80211_ATTR_MU_MIMO_GROUP_DATA] = {\n\t\t.len = VHT_MUMIMO_GROUPS_DATA_LEN\n\t},\n\t[NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_ATTR_NAN_MASTER_PREF] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_ATTR_BANDS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_NAN_FUNC] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_FILS_KEK] = { .type = NLA_BINARY,\n\t\t\t\t    .len = FILS_MAX_KEK_LEN },\n\t[NL80211_ATTR_FILS_NONCES] = NLA_POLICY_EXACT_LEN_WARN(2 * FILS_NONCE_LEN),\n\t[NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED] = { .type = NLA_FLAG, },\n\t[NL80211_ATTR_BSSID] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI] = { .type = NLA_S8 },\n\t[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST] = {\n\t\t.len = sizeof(struct nl80211_bss_select_rssi_adjust)\n\t},\n\t[NL80211_ATTR_TIMEOUT_REASON] = { .type = NLA_U32 },\n\t[NL80211_ATTR_FILS_ERP_USERNAME] = { .type = NLA_BINARY,\n\t\t\t\t\t     .len = FILS_ERP_MAX_USERNAME_LEN },\n\t[NL80211_ATTR_FILS_ERP_REALM] = { .type = NLA_BINARY,\n\t\t\t\t\t  .len = FILS_ERP_MAX_REALM_LEN },\n\t[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] = { .type = NLA_U16 },\n\t[NL80211_ATTR_FILS_ERP_RRK] = { .type = NLA_BINARY,\n\t\t\t\t\t.len = FILS_ERP_MAX_RRK_LEN },\n\t[NL80211_ATTR_FILS_CACHE_ID] = NLA_POLICY_EXACT_LEN_WARN(2),\n\t[NL80211_ATTR_PMK] = { .type = NLA_BINARY, .len = PMK_MAX_LEN },\n\t[NL80211_ATTR_PMKR0_NAME] = NLA_POLICY_EXACT_LEN(WLAN_PMK_NAME_LEN),\n\t[NL80211_ATTR_SCHED_SCAN_MULTI] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_EXTERNAL_AUTH_SUPPORT] = { .type = NLA_FLAG },\n\n\t[NL80211_ATTR_TXQ_LIMIT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_TXQ_MEMORY_LIMIT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_TXQ_QUANTUM] = { .type = NLA_U32 },\n\t[NL80211_ATTR_HE_CAPABILITY] =\n\t\tNLA_POLICY_RANGE(NLA_BINARY,\n\t\t\t\t NL80211_HE_MIN_CAPABILITY_LEN,\n\t\t\t\t NL80211_HE_MAX_CAPABILITY_LEN),\n\t[NL80211_ATTR_FTM_RESPONDER] =\n\t\tNLA_POLICY_NESTED(nl80211_ftm_responder_policy),\n\t[NL80211_ATTR_TIMEOUT] = NLA_POLICY_MIN(NLA_U32, 1),\n\t[NL80211_ATTR_PEER_MEASUREMENTS] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_attr_policy),\n\t[NL80211_ATTR_AIRTIME_WEIGHT] = NLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_ATTR_SAE_PASSWORD] = { .type = NLA_BINARY,\n\t\t\t\t\t.len = SAE_PASSWORD_MAX_LEN },\n\t[NL80211_ATTR_TWT_RESPONDER] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_HE_OBSS_PD] = NLA_POLICY_NESTED(he_obss_pd_policy),\n\t[NL80211_ATTR_VLAN_ID] = NLA_POLICY_RANGE(NLA_U16, 1, VLAN_N_VID - 2),\n\t[NL80211_ATTR_HE_BSS_COLOR] = NLA_POLICY_NESTED(he_bss_color_policy),\n\t[NL80211_ATTR_TID_CONFIG] =\n\t\tNLA_POLICY_NESTED_ARRAY(nl80211_tid_config_attr_policy),\n\t[NL80211_ATTR_CONTROL_PORT_NO_PREAUTH] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PMK_LIFETIME] = NLA_POLICY_MIN(NLA_U32, 1),\n\t[NL80211_ATTR_PMK_REAUTH_THRESHOLD] = NLA_POLICY_RANGE(NLA_U8, 1, 100),\n\t[NL80211_ATTR_RECEIVE_MULTICAST] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_WIPHY_FREQ_OFFSET] = NLA_POLICY_RANGE(NLA_U32, 0, 999),\n\t[NL80211_ATTR_SCAN_FREQ_KHZ] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_HE_6GHZ_CAPABILITY] =\n\t\tNLA_POLICY_EXACT_LEN(sizeof(struct ieee80211_he_6ghz_capa)),\n\t[NL80211_ATTR_FILS_DISCOVERY] =\n\t\tNLA_POLICY_NESTED(nl80211_fils_discovery_policy),\n\t[NL80211_ATTR_UNSOL_BCAST_PROBE_RESP] =\n\t\tNLA_POLICY_NESTED(nl80211_unsol_bcast_probe_resp_policy),\n\t[NL80211_ATTR_S1G_CAPABILITY] =\n\t\tNLA_POLICY_EXACT_LEN(IEEE80211_S1G_CAPABILITY_LEN),\n\t[NL80211_ATTR_S1G_CAPABILITY_MASK] =\n\t\tNLA_POLICY_EXACT_LEN(IEEE80211_S1G_CAPABILITY_LEN),\n\t[NL80211_ATTR_SAE_PWE] =\n\t\tNLA_POLICY_RANGE(NLA_U8, NL80211_SAE_PWE_HUNT_AND_PECK,\n\t\t\t\t NL80211_SAE_PWE_BOTH),\n\t[NL80211_ATTR_RECONNECT_REQUESTED] = { .type = NLA_REJECT },\n\t[NL80211_ATTR_SAR_SPEC] = NLA_POLICY_NESTED(sar_policy),\n};\n\n/* policy for the key attributes */\nstatic const struct nla_policy nl80211_key_policy[NL80211_KEY_MAX + 1] = {\n\t[NL80211_KEY_DATA] = { .type = NLA_BINARY, .len = WLAN_MAX_KEY_LEN },\n\t[NL80211_KEY_IDX] = { .type = NLA_U8 },\n\t[NL80211_KEY_CIPHER] = { .type = NLA_U32 },\n\t[NL80211_KEY_SEQ] = { .type = NLA_BINARY, .len = 16 },\n\t[NL80211_KEY_DEFAULT] = { .type = NLA_FLAG },\n\t[NL80211_KEY_DEFAULT_MGMT] = { .type = NLA_FLAG },\n\t[NL80211_KEY_TYPE] = NLA_POLICY_MAX(NLA_U32, NUM_NL80211_KEYTYPES - 1),\n\t[NL80211_KEY_DEFAULT_TYPES] = { .type = NLA_NESTED },\n\t[NL80211_KEY_MODE] = NLA_POLICY_RANGE(NLA_U8, 0, NL80211_KEY_SET_TX),\n};\n\n/* policy for the key default flags */\nstatic const struct nla_policy\nnl80211_key_default_policy[NUM_NL80211_KEY_DEFAULT_TYPES] = {\n\t[NL80211_KEY_DEFAULT_TYPE_UNICAST] = { .type = NLA_FLAG },\n\t[NL80211_KEY_DEFAULT_TYPE_MULTICAST] = { .type = NLA_FLAG },\n};\n\n#ifdef CONFIG_PM\n/* policy for WoWLAN attributes */\nstatic const struct nla_policy\nnl80211_wowlan_policy[NUM_NL80211_WOWLAN_TRIG] = {\n\t[NL80211_WOWLAN_TRIG_ANY] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_DISCONNECT] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_MAGIC_PKT] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_PKT_PATTERN] = { .type = NLA_NESTED },\n\t[NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_RFKILL_RELEASE] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_TCP_CONNECTION] = { .type = NLA_NESTED },\n\t[NL80211_WOWLAN_TRIG_NET_DETECT] = { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy\nnl80211_wowlan_tcp_policy[NUM_NL80211_WOWLAN_TCP] = {\n\t[NL80211_WOWLAN_TCP_SRC_IPV4] = { .type = NLA_U32 },\n\t[NL80211_WOWLAN_TCP_DST_IPV4] = { .type = NLA_U32 },\n\t[NL80211_WOWLAN_TCP_DST_MAC] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_WOWLAN_TCP_SRC_PORT] = { .type = NLA_U16 },\n\t[NL80211_WOWLAN_TCP_DST_PORT] = { .type = NLA_U16 },\n\t[NL80211_WOWLAN_TCP_DATA_PAYLOAD] = NLA_POLICY_MIN_LEN(1),\n\t[NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ] = {\n\t\t.len = sizeof(struct nl80211_wowlan_tcp_data_seq)\n\t},\n\t[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN] = {\n\t\t.len = sizeof(struct nl80211_wowlan_tcp_data_token)\n\t},\n\t[NL80211_WOWLAN_TCP_DATA_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_WOWLAN_TCP_WAKE_PAYLOAD] = NLA_POLICY_MIN_LEN(1),\n\t[NL80211_WOWLAN_TCP_WAKE_MASK] = NLA_POLICY_MIN_LEN(1),\n};\n#endif /* CONFIG_PM */\n\n/* policy for coalesce rule attributes */\nstatic const struct nla_policy\nnl80211_coalesce_policy[NUM_NL80211_ATTR_COALESCE_RULE] = {\n\t[NL80211_ATTR_COALESCE_RULE_DELAY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_COALESCE_RULE_CONDITION] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_COALESCE_CONDITION_MATCH,\n\t\t\t\t NL80211_COALESCE_CONDITION_NO_MATCH),\n\t[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN] = { .type = NLA_NESTED },\n};\n\n/* policy for GTK rekey offload attributes */\nstatic const struct nla_policy\nnl80211_rekey_policy[NUM_NL80211_REKEY_DATA] = {\n\t[NL80211_REKEY_DATA_KEK] = {\n\t\t.type = NLA_BINARY,\n\t\t.len = NL80211_KEK_EXT_LEN\n\t},\n\t[NL80211_REKEY_DATA_KCK] = {\n\t\t.type = NLA_BINARY,\n\t\t.len = NL80211_KCK_EXT_LEN\n\t},\n\t[NL80211_REKEY_DATA_REPLAY_CTR] = NLA_POLICY_EXACT_LEN(NL80211_REPLAY_CTR_LEN),\n\t[NL80211_REKEY_DATA_AKM] = { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy\nnl80211_match_band_rssi_policy[NUM_NL80211_BANDS] = {\n\t[NL80211_BAND_2GHZ] = { .type = NLA_S32 },\n\t[NL80211_BAND_5GHZ] = { .type = NLA_S32 },\n\t[NL80211_BAND_6GHZ] = { .type = NLA_S32 },\n\t[NL80211_BAND_60GHZ] = { .type = NLA_S32 },\n};\n\nstatic const struct nla_policy\nnl80211_match_policy[NL80211_SCHED_SCAN_MATCH_ATTR_MAX + 1] = {\n\t[NL80211_SCHED_SCAN_MATCH_ATTR_SSID] = { .type = NLA_BINARY,\n\t\t\t\t\t\t .len = IEEE80211_MAX_SSID_LEN },\n\t[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI] = { .type = NLA_U32 },\n\t[NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI] =\n\t\tNLA_POLICY_NESTED(nl80211_match_band_rssi_policy),\n};\n\nstatic const struct nla_policy\nnl80211_plan_policy[NL80211_SCHED_SCAN_PLAN_MAX + 1] = {\n\t[NL80211_SCHED_SCAN_PLAN_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_SCHED_SCAN_PLAN_ITERATIONS] = { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy\nnl80211_bss_select_policy[NL80211_BSS_SELECT_ATTR_MAX + 1] = {\n\t[NL80211_BSS_SELECT_ATTR_RSSI] = { .type = NLA_FLAG },\n\t[NL80211_BSS_SELECT_ATTR_BAND_PREF] = { .type = NLA_U32 },\n\t[NL80211_BSS_SELECT_ATTR_RSSI_ADJUST] = {\n\t\t.len = sizeof(struct nl80211_bss_select_rssi_adjust)\n\t},\n};\n\n/* policy for NAN function attributes */\nstatic const struct nla_policy\nnl80211_nan_func_policy[NL80211_NAN_FUNC_ATTR_MAX + 1] = {\n\t[NL80211_NAN_FUNC_TYPE] =\n\t\tNLA_POLICY_MAX(NLA_U8, NL80211_NAN_FUNC_MAX_TYPE),\n\t[NL80211_NAN_FUNC_SERVICE_ID] = {\n\t\t\t\t    .len = NL80211_NAN_FUNC_SERVICE_ID_LEN },\n\t[NL80211_NAN_FUNC_PUBLISH_TYPE] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_PUBLISH_BCAST] = { .type = NLA_FLAG },\n\t[NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE] = { .type = NLA_FLAG },\n\t[NL80211_NAN_FUNC_FOLLOW_UP_ID] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_FOLLOW_UP_DEST] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_NAN_FUNC_CLOSE_RANGE] = { .type = NLA_FLAG },\n\t[NL80211_NAN_FUNC_TTL] = { .type = NLA_U32 },\n\t[NL80211_NAN_FUNC_SERVICE_INFO] = { .type = NLA_BINARY,\n\t\t\t.len = NL80211_NAN_FUNC_SERVICE_SPEC_INFO_MAX_LEN },\n\t[NL80211_NAN_FUNC_SRF] = { .type = NLA_NESTED },\n\t[NL80211_NAN_FUNC_RX_MATCH_FILTER] = { .type = NLA_NESTED },\n\t[NL80211_NAN_FUNC_TX_MATCH_FILTER] = { .type = NLA_NESTED },\n\t[NL80211_NAN_FUNC_INSTANCE_ID] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_TERM_REASON] = { .type = NLA_U8 },\n};\n\n/* policy for Service Response Filter attributes */\nstatic const struct nla_policy\nnl80211_nan_srf_policy[NL80211_NAN_SRF_ATTR_MAX + 1] = {\n\t[NL80211_NAN_SRF_INCLUDE] = { .type = NLA_FLAG },\n\t[NL80211_NAN_SRF_BF] = { .type = NLA_BINARY,\n\t\t\t\t .len =  NL80211_NAN_FUNC_SRF_MAX_LEN },\n\t[NL80211_NAN_SRF_BF_IDX] = { .type = NLA_U8 },\n\t[NL80211_NAN_SRF_MAC_ADDRS] = { .type = NLA_NESTED },\n};\n\n/* policy for packet pattern attributes */\nstatic const struct nla_policy\nnl80211_packet_pattern_policy[MAX_NL80211_PKTPAT + 1] = {\n\t[NL80211_PKTPAT_MASK] = { .type = NLA_BINARY, },\n\t[NL80211_PKTPAT_PATTERN] = { .type = NLA_BINARY, },\n\t[NL80211_PKTPAT_OFFSET] = { .type = NLA_U32 },\n};\n\nint nl80211_prepare_wdev_dump(struct netlink_callback *cb,\n\t\t\t      struct cfg80211_registered_device **rdev,\n\t\t\t      struct wireless_dev **wdev)\n{\n\tint err;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr **attrbuf;\n\n\t\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!attrbuf)\n\t\t\treturn -ENOMEM;\n\n\t\terr = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t\t     attrbuf, nl80211_fam.maxattr,\n\t\t\t\t\t     nl80211_policy, NULL);\n\t\tif (err) {\n\t\t\tkfree(attrbuf);\n\t\t\treturn err;\n\t\t}\n\n\t\trtnl_lock();\n\t\t*wdev = __cfg80211_wdev_from_attrs(NULL, sock_net(cb->skb->sk),\n\t\t\t\t\t\t   attrbuf);\n\t\tkfree(attrbuf);\n\t\tif (IS_ERR(*wdev)) {\n\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(*wdev);\n\t\t}\n\t\t*rdev = wiphy_to_rdev((*wdev)->wiphy);\n\t\tmutex_lock(&(*rdev)->wiphy.mtx);\n\t\trtnl_unlock();\n\t\t/* 0 is the first index - add 1 to parse only once */\n\t\tcb->args[0] = (*rdev)->wiphy_idx + 1;\n\t\tcb->args[1] = (*wdev)->identifier;\n\t} else {\n\t\t/* subtract the 1 again here */\n\t\tstruct wiphy *wiphy;\n\t\tstruct wireless_dev *tmp;\n\n\t\trtnl_lock();\n\t\twiphy = wiphy_idx_to_wiphy(cb->args[0] - 1);\n\t\tif (!wiphy) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENODEV;\n\t\t}\n\t\t*rdev = wiphy_to_rdev(wiphy);\n\t\t*wdev = NULL;\n\n\t\tlist_for_each_entry(tmp, &(*rdev)->wiphy.wdev_list, list) {\n\t\t\tif (tmp->identifier == cb->args[1]) {\n\t\t\t\t*wdev = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!*wdev) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tmutex_lock(&(*rdev)->wiphy.mtx);\n\t\trtnl_unlock();\n\t}\n\n\treturn 0;\n}\n\n/* message building helper */\nvoid *nl80211hdr_put(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t     int flags, u8 cmd)\n{\n\t/* since there is no private header just add the generic one */\n\treturn genlmsg_put(skb, portid, seq, &nl80211_fam, flags, cmd);\n}\n\nstatic int nl80211_msg_put_wmm_rules(struct sk_buff *msg,\n\t\t\t\t     const struct ieee80211_reg_rule *rule)\n{\n\tint j;\n\tstruct nlattr *nl_wmm_rules =\n\t\tnla_nest_start_noflag(msg, NL80211_FREQUENCY_ATTR_WMM);\n\n\tif (!nl_wmm_rules)\n\t\tgoto nla_put_failure;\n\n\tfor (j = 0; j < IEEE80211_NUM_ACS; j++) {\n\t\tstruct nlattr *nl_wmm_rule = nla_nest_start_noflag(msg, j);\n\n\t\tif (!nl_wmm_rule)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u16(msg, NL80211_WMMR_CW_MIN,\n\t\t\t\trule->wmm_rule.client[j].cw_min) ||\n\t\t    nla_put_u16(msg, NL80211_WMMR_CW_MAX,\n\t\t\t\trule->wmm_rule.client[j].cw_max) ||\n\t\t    nla_put_u8(msg, NL80211_WMMR_AIFSN,\n\t\t\t       rule->wmm_rule.client[j].aifsn) ||\n\t\t    nla_put_u16(msg, NL80211_WMMR_TXOP,\n\t\t\t        rule->wmm_rule.client[j].cot))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_wmm_rule);\n\t}\n\tnla_nest_end(msg, nl_wmm_rules);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_msg_put_channel(struct sk_buff *msg, struct wiphy *wiphy,\n\t\t\t\t   struct ieee80211_channel *chan,\n\t\t\t\t   bool large)\n{\n\t/* Some channels must be completely excluded from the\n\t * list to protect old user-space tools from breaking\n\t */\n\tif (!large && chan->flags &\n\t    (IEEE80211_CHAN_NO_10MHZ | IEEE80211_CHAN_NO_20MHZ))\n\t\treturn 0;\n\tif (!large && chan->freq_offset)\n\t\treturn 0;\n\n\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_FREQ,\n\t\t\tchan->center_freq))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_OFFSET, chan->freq_offset))\n\t\tgoto nla_put_failure;\n\n\tif ((chan->flags & IEEE80211_CHAN_DISABLED) &&\n\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_DISABLED))\n\t\tgoto nla_put_failure;\n\tif (chan->flags & IEEE80211_CHAN_NO_IR) {\n\t\tif (nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_IR))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_flag(msg, __NL80211_FREQUENCY_ATTR_NO_IBSS))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (chan->flags & IEEE80211_CHAN_RADAR) {\n\t\tif (nla_put_flag(msg, NL80211_FREQUENCY_ATTR_RADAR))\n\t\t\tgoto nla_put_failure;\n\t\tif (large) {\n\t\t\tu32 time;\n\n\t\t\ttime = elapsed_jiffies_msecs(chan->dfs_state_entered);\n\n\t\t\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_DFS_STATE,\n\t\t\t\t\tchan->dfs_state))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_DFS_TIME,\n\t\t\t\t\ttime))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg,\n\t\t\t\t\tNL80211_FREQUENCY_ATTR_DFS_CAC_TIME,\n\t\t\t\t\tchan->dfs_cac_ms))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif (large) {\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_HT40MINUS) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_HT40_MINUS))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_HT40PLUS) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_HT40_PLUS))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_80MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_80MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_160MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_160MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_INDOOR_ONLY) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_INDOOR_ONLY))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_IR_CONCURRENT) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_IR_CONCURRENT))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_20MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_20MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_10MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_10MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_HE) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_HE))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_1MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_1MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_2MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_2MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_4MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_4MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_8MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_8MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_16MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_16MHZ))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_MAX_TX_POWER,\n\t\t\tDBM_TO_MBM(chan->max_power)))\n\t\tgoto nla_put_failure;\n\n\tif (large) {\n\t\tconst struct ieee80211_reg_rule *rule =\n\t\t\tfreq_reg_info(wiphy, MHZ_TO_KHZ(chan->center_freq));\n\n\t\tif (!IS_ERR_OR_NULL(rule) && rule->has_wmm) {\n\t\t\tif (nl80211_msg_put_wmm_rules(msg, rule))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\treturn 0;\n\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic bool nl80211_put_txq_stats(struct sk_buff *msg,\n\t\t\t\t  struct cfg80211_txq_stats *txqstats,\n\t\t\t\t  int attrtype)\n{\n\tstruct nlattr *txqattr;\n\n#define PUT_TXQVAL_U32(attr, memb) do {\t\t\t\t\t  \\\n\tif (txqstats->filled & BIT(NL80211_TXQ_STATS_ ## attr) &&\t  \\\n\t    nla_put_u32(msg, NL80211_TXQ_STATS_ ## attr, txqstats->memb)) \\\n\t\treturn false;\t\t\t\t\t\t  \\\n\t} while (0)\n\n\ttxqattr = nla_nest_start_noflag(msg, attrtype);\n\tif (!txqattr)\n\t\treturn false;\n\n\tPUT_TXQVAL_U32(BACKLOG_BYTES, backlog_bytes);\n\tPUT_TXQVAL_U32(BACKLOG_PACKETS, backlog_packets);\n\tPUT_TXQVAL_U32(FLOWS, flows);\n\tPUT_TXQVAL_U32(DROPS, drops);\n\tPUT_TXQVAL_U32(ECN_MARKS, ecn_marks);\n\tPUT_TXQVAL_U32(OVERLIMIT, overlimit);\n\tPUT_TXQVAL_U32(OVERMEMORY, overmemory);\n\tPUT_TXQVAL_U32(COLLISIONS, collisions);\n\tPUT_TXQVAL_U32(TX_BYTES, tx_bytes);\n\tPUT_TXQVAL_U32(TX_PACKETS, tx_packets);\n\tPUT_TXQVAL_U32(MAX_FLOWS, max_flows);\n\tnla_nest_end(msg, txqattr);\n\n#undef PUT_TXQVAL_U32\n\treturn true;\n}\n\n/* netlink command implementations */\n\nstruct key_parse {\n\tstruct key_params p;\n\tint idx;\n\tint type;\n\tbool def, defmgmt, defbeacon;\n\tbool def_uni, def_multi;\n};\n\nstatic int nl80211_parse_key_new(struct genl_info *info, struct nlattr *key,\n\t\t\t\t struct key_parse *k)\n{\n\tstruct nlattr *tb[NL80211_KEY_MAX + 1];\n\tint err = nla_parse_nested_deprecated(tb, NL80211_KEY_MAX, key,\n\t\t\t\t\t      nl80211_key_policy,\n\t\t\t\t\t      info->extack);\n\tif (err)\n\t\treturn err;\n\n\tk->def = !!tb[NL80211_KEY_DEFAULT];\n\tk->defmgmt = !!tb[NL80211_KEY_DEFAULT_MGMT];\n\tk->defbeacon = !!tb[NL80211_KEY_DEFAULT_BEACON];\n\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt || k->defbeacon)\n\t\tk->def_multi = true;\n\n\tif (tb[NL80211_KEY_IDX])\n\t\tk->idx = nla_get_u8(tb[NL80211_KEY_IDX]);\n\n\tif (tb[NL80211_KEY_DATA]) {\n\t\tk->p.key = nla_data(tb[NL80211_KEY_DATA]);\n\t\tk->p.key_len = nla_len(tb[NL80211_KEY_DATA]);\n\t}\n\n\tif (tb[NL80211_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(tb[NL80211_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(tb[NL80211_KEY_SEQ]);\n\t}\n\n\tif (tb[NL80211_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(tb[NL80211_KEY_CIPHER]);\n\n\tif (tb[NL80211_KEY_TYPE])\n\t\tk->type = nla_get_u32(tb[NL80211_KEY_TYPE]);\n\n\tif (tb[NL80211_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\n\t\terr = nla_parse_nested_deprecated(kdt,\n\t\t\t\t\t\t  NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\t\t\t  tb[NL80211_KEY_DEFAULT_TYPES],\n\t\t\t\t\t\t  nl80211_key_default_policy,\n\t\t\t\t\t\t  info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\n\tif (tb[NL80211_KEY_MODE])\n\t\tk->p.mode = nla_get_u8(tb[NL80211_KEY_MODE]);\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_key_old(struct genl_info *info, struct key_parse *k)\n{\n\tif (info->attrs[NL80211_ATTR_KEY_DATA]) {\n\t\tk->p.key = nla_data(info->attrs[NL80211_ATTR_KEY_DATA]);\n\t\tk->p.key_len = nla_len(info->attrs[NL80211_ATTR_KEY_DATA]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(info->attrs[NL80211_ATTR_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(info->attrs[NL80211_ATTR_KEY_SEQ]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_KEY_IDX])\n\t\tk->idx = nla_get_u8(info->attrs[NL80211_ATTR_KEY_IDX]);\n\n\tif (info->attrs[NL80211_ATTR_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(info->attrs[NL80211_ATTR_KEY_CIPHER]);\n\n\tk->def = !!info->attrs[NL80211_ATTR_KEY_DEFAULT];\n\tk->defmgmt = !!info->attrs[NL80211_ATTR_KEY_DEFAULT_MGMT];\n\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt)\n\t\tk->def_multi = true;\n\n\tif (info->attrs[NL80211_ATTR_KEY_TYPE])\n\t\tk->type = nla_get_u32(info->attrs[NL80211_ATTR_KEY_TYPE]);\n\n\tif (info->attrs[NL80211_ATTR_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\t\tint err = nla_parse_nested_deprecated(kdt,\n\t\t\t\t\t\t      NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\t\t\t      info->attrs[NL80211_ATTR_KEY_DEFAULT_TYPES],\n\t\t\t\t\t\t      nl80211_key_default_policy,\n\t\t\t\t\t\t      info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_key(struct genl_info *info, struct key_parse *k)\n{\n\tint err;\n\n\tmemset(k, 0, sizeof(*k));\n\tk->idx = -1;\n\tk->type = -1;\n\n\tif (info->attrs[NL80211_ATTR_KEY])\n\t\terr = nl80211_parse_key_new(info, info->attrs[NL80211_ATTR_KEY], k);\n\telse\n\t\terr = nl80211_parse_key_old(info, k);\n\n\tif (err)\n\t\treturn err;\n\n\tif ((k->def ? 1 : 0) + (k->defmgmt ? 1 : 0) +\n\t    (k->defbeacon ? 1 : 0) > 1) {\n\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t \"key with multiple default flags is invalid\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (k->defmgmt || k->defbeacon) {\n\t\tif (k->def_uni || !k->def_multi) {\n\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t \"defmgmt/defbeacon key must be mcast\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (k->idx != -1) {\n\t\tif (k->defmgmt) {\n\t\t\tif (k->idx < 4 || k->idx > 5) {\n\t\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t\t \"defmgmt key idx not 4 or 5\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (k->defbeacon) {\n\t\t\tif (k->idx < 6 || k->idx > 7) {\n\t\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t\t \"defbeacon key idx not 6 or 7\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (k->def) {\n\t\t\tif (k->idx < 0 || k->idx > 3) {\n\t\t\t\tGENL_SET_ERR_MSG(info, \"def key idx not 0-3\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (k->idx < 0 || k->idx > 7) {\n\t\t\t\tGENL_SET_ERR_MSG(info, \"key idx not 0-7\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct cfg80211_cached_keys *\nnl80211_parse_connkeys(struct cfg80211_registered_device *rdev,\n\t\t       struct genl_info *info, bool *no_ht)\n{\n\tstruct nlattr *keys = info->attrs[NL80211_ATTR_KEYS];\n\tstruct key_parse parse;\n\tstruct nlattr *key;\n\tstruct cfg80211_cached_keys *result;\n\tint rem, err, def = 0;\n\tbool have_key = false;\n\n\tnla_for_each_nested(key, keys, rem) {\n\t\thave_key = true;\n\t\tbreak;\n\t}\n\n\tif (!have_key)\n\t\treturn NULL;\n\n\tresult = kzalloc(sizeof(*result), GFP_KERNEL);\n\tif (!result)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tresult->def = -1;\n\n\tnla_for_each_nested(key, keys, rem) {\n\t\tmemset(&parse, 0, sizeof(parse));\n\t\tparse.idx = -1;\n\n\t\terr = nl80211_parse_key_new(info, key, &parse);\n\t\tif (err)\n\t\t\tgoto error;\n\t\terr = -EINVAL;\n\t\tif (!parse.p.key)\n\t\t\tgoto error;\n\t\tif (parse.idx < 0 || parse.idx > 3) {\n\t\t\tGENL_SET_ERR_MSG(info, \"key index out of range [0-3]\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (parse.def) {\n\t\t\tif (def) {\n\t\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t\t \"only one key can be default\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tdef = 1;\n\t\t\tresult->def = parse.idx;\n\t\t\tif (!parse.def_uni || !parse.def_multi)\n\t\t\t\tgoto error;\n\t\t} else if (parse.defmgmt)\n\t\t\tgoto error;\n\t\terr = cfg80211_validate_key_settings(rdev, &parse.p,\n\t\t\t\t\t\t     parse.idx, false, NULL);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tif (parse.p.cipher != WLAN_CIPHER_SUITE_WEP40 &&\n\t\t    parse.p.cipher != WLAN_CIPHER_SUITE_WEP104) {\n\t\t\tGENL_SET_ERR_MSG(info, \"connect key must be WEP\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tresult->params[parse.idx].cipher = parse.p.cipher;\n\t\tresult->params[parse.idx].key_len = parse.p.key_len;\n\t\tresult->params[parse.idx].key = result->data[parse.idx];\n\t\tmemcpy(result->data[parse.idx], parse.p.key, parse.p.key_len);\n\n\t\t/* must be WEP key if we got here */\n\t\tif (no_ht)\n\t\t\t*no_ht = true;\n\t}\n\n\tif (result->def < 0) {\n\t\terr = -EINVAL;\n\t\tGENL_SET_ERR_MSG(info, \"need a default/TX key\");\n\t\tgoto error;\n\t}\n\n\treturn result;\n error:\n\tkfree(result);\n\treturn ERR_PTR(err);\n}\n\nstatic int nl80211_key_allowed(struct wireless_dev *wdev)\n{\n\tASSERT_WDEV_LOCK(wdev);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (!wdev->current_bss)\n\t\t\treturn -ENOLINK;\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NL80211_IFTYPE_OCB:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_NAN:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NUM_NL80211_IFTYPES:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ieee80211_channel *nl80211_get_valid_chan(struct wiphy *wiphy,\n\t\t\t\t\t\t\tu32 freq)\n{\n\tstruct ieee80211_channel *chan;\n\n\tchan = ieee80211_get_channel_khz(wiphy, freq);\n\tif (!chan || chan->flags & IEEE80211_CHAN_DISABLED)\n\t\treturn NULL;\n\treturn chan;\n}\n\nstatic int nl80211_put_iftypes(struct sk_buff *msg, u32 attr, u16 ifmodes)\n{\n\tstruct nlattr *nl_modes = nla_nest_start_noflag(msg, attr);\n\tint i;\n\n\tif (!nl_modes)\n\t\tgoto nla_put_failure;\n\n\ti = 0;\n\twhile (ifmodes) {\n\t\tif ((ifmodes & 1) && nla_put_flag(msg, i))\n\t\t\tgoto nla_put_failure;\n\t\tifmodes >>= 1;\n\t\ti++;\n\t}\n\n\tnla_nest_end(msg, nl_modes);\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_put_iface_combinations(struct wiphy *wiphy,\n\t\t\t\t\t  struct sk_buff *msg,\n\t\t\t\t\t  bool large)\n{\n\tstruct nlattr *nl_combis;\n\tint i, j;\n\n\tnl_combis = nla_nest_start_noflag(msg,\n\t\t\t\t\t  NL80211_ATTR_INTERFACE_COMBINATIONS);\n\tif (!nl_combis)\n\t\tgoto nla_put_failure;\n\n\tfor (i = 0; i < wiphy->n_iface_combinations; i++) {\n\t\tconst struct ieee80211_iface_combination *c;\n\t\tstruct nlattr *nl_combi, *nl_limits;\n\n\t\tc = &wiphy->iface_combinations[i];\n\n\t\tnl_combi = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!nl_combi)\n\t\t\tgoto nla_put_failure;\n\n\t\tnl_limits = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t  NL80211_IFACE_COMB_LIMITS);\n\t\tif (!nl_limits)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (j = 0; j < c->n_limits; j++) {\n\t\t\tstruct nlattr *nl_limit;\n\n\t\t\tnl_limit = nla_nest_start_noflag(msg, j + 1);\n\t\t\tif (!nl_limit)\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_IFACE_LIMIT_MAX,\n\t\t\t\t\tc->limits[j].max))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nl80211_put_iftypes(msg, NL80211_IFACE_LIMIT_TYPES,\n\t\t\t\t\t\tc->limits[j].types))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tnla_nest_end(msg, nl_limit);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_limits);\n\n\t\tif (c->beacon_int_infra_match &&\n\t\t    nla_put_flag(msg, NL80211_IFACE_COMB_STA_AP_BI_MATCH))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(msg, NL80211_IFACE_COMB_NUM_CHANNELS,\n\t\t\t\tc->num_different_channels) ||\n\t\t    nla_put_u32(msg, NL80211_IFACE_COMB_MAXNUM,\n\t\t\t\tc->max_interfaces))\n\t\t\tgoto nla_put_failure;\n\t\tif (large &&\n\t\t    (nla_put_u32(msg, NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS,\n\t\t\t\tc->radar_detect_widths) ||\n\t\t     nla_put_u32(msg, NL80211_IFACE_COMB_RADAR_DETECT_REGIONS,\n\t\t\t\tc->radar_detect_regions)))\n\t\t\tgoto nla_put_failure;\n\t\tif (c->beacon_int_min_gcd &&\n\t\t    nla_put_u32(msg, NL80211_IFACE_COMB_BI_MIN_GCD,\n\t\t\t\tc->beacon_int_min_gcd))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_combi);\n\t}\n\n\tnla_nest_end(msg, nl_combis);\n\n\treturn 0;\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\n#ifdef CONFIG_PM\nstatic int nl80211_send_wowlan_tcp_caps(struct cfg80211_registered_device *rdev,\n\t\t\t\t\tstruct sk_buff *msg)\n{\n\tconst struct wiphy_wowlan_tcp_support *tcp = rdev->wiphy.wowlan->tcp;\n\tstruct nlattr *nl_tcp;\n\n\tif (!tcp)\n\t\treturn 0;\n\n\tnl_tcp = nla_nest_start_noflag(msg,\n\t\t\t\t       NL80211_WOWLAN_TRIG_TCP_CONNECTION);\n\tif (!nl_tcp)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD,\n\t\t\ttcp->data_payload_max))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD,\n\t\t\ttcp->data_payload_max))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->seq && nla_put_flag(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->tok && nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN,\n\t\t\t\tsizeof(*tcp->tok), tcp->tok))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_INTERVAL,\n\t\t\ttcp->data_interval_max))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_WAKE_PAYLOAD,\n\t\t\ttcp->wake_payload_max))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, nl_tcp);\n\treturn 0;\n}\n\nstatic int nl80211_send_wowlan(struct sk_buff *msg,\n\t\t\t       struct cfg80211_registered_device *rdev,\n\t\t\t       bool large)\n{\n\tstruct nlattr *nl_wowlan;\n\n\tif (!rdev->wiphy.wowlan)\n\t\treturn 0;\n\n\tnl_wowlan = nla_nest_start_noflag(msg,\n\t\t\t\t\t  NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED);\n\tif (!nl_wowlan)\n\t\treturn -ENOBUFS;\n\n\tif (((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_ANY) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_ANY)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_DISCONNECT) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_MAGIC_PKT) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_SUPPORTS_GTK_REKEY) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_EAP_IDENTITY_REQ) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_4WAY_HANDSHAKE) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_RFKILL_RELEASE) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE)))\n\t\treturn -ENOBUFS;\n\n\tif (rdev->wiphy.wowlan->n_patterns) {\n\t\tstruct nl80211_pattern_support pat = {\n\t\t\t.max_patterns = rdev->wiphy.wowlan->n_patterns,\n\t\t\t.min_pattern_len = rdev->wiphy.wowlan->pattern_min_len,\n\t\t\t.max_pattern_len = rdev->wiphy.wowlan->pattern_max_len,\n\t\t\t.max_pkt_offset = rdev->wiphy.wowlan->max_pkt_offset,\n\t\t};\n\n\t\tif (nla_put(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN,\n\t\t\t    sizeof(pat), &pat))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tif ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_NET_DETECT) &&\n\t    nla_put_u32(msg, NL80211_WOWLAN_TRIG_NET_DETECT,\n\t\t\trdev->wiphy.wowlan->max_nd_match_sets))\n\t\treturn -ENOBUFS;\n\n\tif (large && nl80211_send_wowlan_tcp_caps(rdev, msg))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, nl_wowlan);\n\n\treturn 0;\n}\n#endif\n\nstatic int nl80211_send_coalesce(struct sk_buff *msg,\n\t\t\t\t struct cfg80211_registered_device *rdev)\n{\n\tstruct nl80211_coalesce_rule_support rule;\n\n\tif (!rdev->wiphy.coalesce)\n\t\treturn 0;\n\n\trule.max_rules = rdev->wiphy.coalesce->n_rules;\n\trule.max_delay = rdev->wiphy.coalesce->max_delay;\n\trule.pat.max_patterns = rdev->wiphy.coalesce->n_patterns;\n\trule.pat.min_pattern_len = rdev->wiphy.coalesce->pattern_min_len;\n\trule.pat.max_pattern_len = rdev->wiphy.coalesce->pattern_max_len;\n\trule.pat.max_pkt_offset = rdev->wiphy.coalesce->max_pkt_offset;\n\n\tif (nla_put(msg, NL80211_ATTR_COALESCE_RULE, sizeof(rule), &rule))\n\t\treturn -ENOBUFS;\n\n\treturn 0;\n}\n\nstatic int\nnl80211_send_iftype_data(struct sk_buff *msg,\n\t\t\t const struct ieee80211_supported_band *sband,\n\t\t\t const struct ieee80211_sband_iftype_data *iftdata)\n{\n\tconst struct ieee80211_sta_he_cap *he_cap = &iftdata->he_cap;\n\n\tif (nl80211_put_iftypes(msg, NL80211_BAND_IFTYPE_ATTR_IFTYPES,\n\t\t\t\tiftdata->types_mask))\n\t\treturn -ENOBUFS;\n\n\tif (he_cap->has_he) {\n\t\tif (nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_MAC,\n\t\t\t    sizeof(he_cap->he_cap_elem.mac_cap_info),\n\t\t\t    he_cap->he_cap_elem.mac_cap_info) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_PHY,\n\t\t\t    sizeof(he_cap->he_cap_elem.phy_cap_info),\n\t\t\t    he_cap->he_cap_elem.phy_cap_info) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_MCS_SET,\n\t\t\t    sizeof(he_cap->he_mcs_nss_supp),\n\t\t\t    &he_cap->he_mcs_nss_supp) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_PPE,\n\t\t\t    sizeof(he_cap->ppe_thres), he_cap->ppe_thres))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tif (sband->band == NL80211_BAND_6GHZ &&\n\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_6GHZ_CAPA,\n\t\t    sizeof(iftdata->he_6ghz_capa),\n\t\t    &iftdata->he_6ghz_capa))\n\t\treturn -ENOBUFS;\n\n\treturn 0;\n}\n\nstatic int nl80211_send_band_rateinfo(struct sk_buff *msg,\n\t\t\t\t      struct ieee80211_supported_band *sband,\n\t\t\t\t      bool large)\n{\n\tstruct nlattr *nl_rates, *nl_rate;\n\tstruct ieee80211_rate *rate;\n\tint i;\n\n\t/* add HT info */\n\tif (sband->ht_cap.ht_supported &&\n\t    (nla_put(msg, NL80211_BAND_ATTR_HT_MCS_SET,\n\t\t     sizeof(sband->ht_cap.mcs),\n\t\t     &sband->ht_cap.mcs) ||\n\t     nla_put_u16(msg, NL80211_BAND_ATTR_HT_CAPA,\n\t\t\t sband->ht_cap.cap) ||\n\t     nla_put_u8(msg, NL80211_BAND_ATTR_HT_AMPDU_FACTOR,\n\t\t\tsband->ht_cap.ampdu_factor) ||\n\t     nla_put_u8(msg, NL80211_BAND_ATTR_HT_AMPDU_DENSITY,\n\t\t\tsband->ht_cap.ampdu_density)))\n\t\treturn -ENOBUFS;\n\n\t/* add VHT info */\n\tif (sband->vht_cap.vht_supported &&\n\t    (nla_put(msg, NL80211_BAND_ATTR_VHT_MCS_SET,\n\t\t     sizeof(sband->vht_cap.vht_mcs),\n\t\t     &sband->vht_cap.vht_mcs) ||\n\t     nla_put_u32(msg, NL80211_BAND_ATTR_VHT_CAPA,\n\t\t\t sband->vht_cap.cap)))\n\t\treturn -ENOBUFS;\n\n\tif (large && sband->n_iftype_data) {\n\t\tstruct nlattr *nl_iftype_data =\n\t\t\tnla_nest_start_noflag(msg,\n\t\t\t\t\t      NL80211_BAND_ATTR_IFTYPE_DATA);\n\t\tint err;\n\n\t\tif (!nl_iftype_data)\n\t\t\treturn -ENOBUFS;\n\n\t\tfor (i = 0; i < sband->n_iftype_data; i++) {\n\t\t\tstruct nlattr *iftdata;\n\n\t\t\tiftdata = nla_nest_start_noflag(msg, i + 1);\n\t\t\tif (!iftdata)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\terr = nl80211_send_iftype_data(msg, sband,\n\t\t\t\t\t\t       &sband->iftype_data[i]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tnla_nest_end(msg, iftdata);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_iftype_data);\n\t}\n\n\t/* add EDMG info */\n\tif (large && sband->edmg_cap.channels &&\n\t    (nla_put_u8(msg, NL80211_BAND_ATTR_EDMG_CHANNELS,\n\t\t       sband->edmg_cap.channels) ||\n\t    nla_put_u8(msg, NL80211_BAND_ATTR_EDMG_BW_CONFIG,\n\t\t       sband->edmg_cap.bw_config)))\n\n\t\treturn -ENOBUFS;\n\n\t/* add bitrates */\n\tnl_rates = nla_nest_start_noflag(msg, NL80211_BAND_ATTR_RATES);\n\tif (!nl_rates)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tnl_rate = nla_nest_start_noflag(msg, i);\n\t\tif (!nl_rate)\n\t\t\treturn -ENOBUFS;\n\n\t\trate = &sband->bitrates[i];\n\t\tif (nla_put_u32(msg, NL80211_BITRATE_ATTR_RATE,\n\t\t\t\trate->bitrate))\n\t\t\treturn -ENOBUFS;\n\t\tif ((rate->flags & IEEE80211_RATE_SHORT_PREAMBLE) &&\n\t\t    nla_put_flag(msg,\n\t\t\t\t NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE))\n\t\t\treturn -ENOBUFS;\n\n\t\tnla_nest_end(msg, nl_rate);\n\t}\n\n\tnla_nest_end(msg, nl_rates);\n\n\treturn 0;\n}\n\nstatic int\nnl80211_send_mgmt_stypes(struct sk_buff *msg,\n\t\t\t const struct ieee80211_txrx_stypes *mgmt_stypes)\n{\n\tu16 stypes;\n\tstruct nlattr *nl_ftypes, *nl_ifs;\n\tenum nl80211_iftype ift;\n\tint i;\n\n\tif (!mgmt_stypes)\n\t\treturn 0;\n\n\tnl_ifs = nla_nest_start_noflag(msg, NL80211_ATTR_TX_FRAME_TYPES);\n\tif (!nl_ifs)\n\t\treturn -ENOBUFS;\n\n\tfor (ift = 0; ift < NUM_NL80211_IFTYPES; ift++) {\n\t\tnl_ftypes = nla_nest_start_noflag(msg, ift);\n\t\tif (!nl_ftypes)\n\t\t\treturn -ENOBUFS;\n\t\ti = 0;\n\t\tstypes = mgmt_stypes[ift].tx;\n\t\twhile (stypes) {\n\t\t\tif ((stypes & 1) &&\n\t\t\t    nla_put_u16(msg, NL80211_ATTR_FRAME_TYPE,\n\t\t\t\t\t(i << 4) | IEEE80211_FTYPE_MGMT))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tstypes >>= 1;\n\t\t\ti++;\n\t\t}\n\t\tnla_nest_end(msg, nl_ftypes);\n\t}\n\n\tnla_nest_end(msg, nl_ifs);\n\n\tnl_ifs = nla_nest_start_noflag(msg, NL80211_ATTR_RX_FRAME_TYPES);\n\tif (!nl_ifs)\n\t\treturn -ENOBUFS;\n\n\tfor (ift = 0; ift < NUM_NL80211_IFTYPES; ift++) {\n\t\tnl_ftypes = nla_nest_start_noflag(msg, ift);\n\t\tif (!nl_ftypes)\n\t\t\treturn -ENOBUFS;\n\t\ti = 0;\n\t\tstypes = mgmt_stypes[ift].rx;\n\t\twhile (stypes) {\n\t\t\tif ((stypes & 1) &&\n\t\t\t    nla_put_u16(msg, NL80211_ATTR_FRAME_TYPE,\n\t\t\t\t\t(i << 4) | IEEE80211_FTYPE_MGMT))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tstypes >>= 1;\n\t\t\ti++;\n\t\t}\n\t\tnla_nest_end(msg, nl_ftypes);\n\t}\n\tnla_nest_end(msg, nl_ifs);\n\n\treturn 0;\n}\n\n#define CMD(op, n)\t\t\t\t\t\t\t\\\n\t do {\t\t\t\t\t\t\t\t\\\n\t\tif (rdev->ops->op) {\t\t\t\t\t\\\n\t\t\ti++;\t\t\t\t\t\t\\\n\t\t\tif (nla_put_u32(msg, i, NL80211_CMD_ ## n)) \t\\\n\t\t\t\tgoto nla_put_failure;\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic int nl80211_add_commands_unsplit(struct cfg80211_registered_device *rdev,\n\t\t\t\t\tstruct sk_buff *msg)\n{\n\tint i = 0;\n\n\t/*\n\t * do *NOT* add anything into this function, new things need to be\n\t * advertised only to new versions of userspace that can deal with\n\t * the split (and they can't possibly care about new features...\n\t */\n\tCMD(add_virtual_intf, NEW_INTERFACE);\n\tCMD(change_virtual_intf, SET_INTERFACE);\n\tCMD(add_key, NEW_KEY);\n\tCMD(start_ap, START_AP);\n\tCMD(add_station, NEW_STATION);\n\tCMD(add_mpath, NEW_MPATH);\n\tCMD(update_mesh_config, SET_MESH_CONFIG);\n\tCMD(change_bss, SET_BSS);\n\tCMD(auth, AUTHENTICATE);\n\tCMD(assoc, ASSOCIATE);\n\tCMD(deauth, DEAUTHENTICATE);\n\tCMD(disassoc, DISASSOCIATE);\n\tCMD(join_ibss, JOIN_IBSS);\n\tCMD(join_mesh, JOIN_MESH);\n\tCMD(set_pmksa, SET_PMKSA);\n\tCMD(del_pmksa, DEL_PMKSA);\n\tCMD(flush_pmksa, FLUSH_PMKSA);\n\tif (rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL)\n\t\tCMD(remain_on_channel, REMAIN_ON_CHANNEL);\n\tCMD(set_bitrate_mask, SET_TX_BITRATE_MASK);\n\tCMD(mgmt_tx, FRAME);\n\tCMD(mgmt_tx_cancel_wait, FRAME_WAIT_CANCEL);\n\tif (rdev->wiphy.flags & WIPHY_FLAG_NETNS_OK) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_SET_WIPHY_NETNS))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (rdev->ops->set_monitor_channel || rdev->ops->start_ap ||\n\t    rdev->ops->join_mesh) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_SET_CHANNEL))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) {\n\t\tCMD(tdls_mgmt, TDLS_MGMT);\n\t\tCMD(tdls_oper, TDLS_OPER);\n\t}\n\tif (rdev->wiphy.max_sched_scan_reqs)\n\t\tCMD(sched_scan_start, START_SCHED_SCAN);\n\tCMD(probe_client, PROBE_CLIENT);\n\tCMD(set_noack_map, SET_NOACK_MAP);\n\tif (rdev->wiphy.flags & WIPHY_FLAG_REPORTS_OBSS) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_REGISTER_BEACONS))\n\t\t\tgoto nla_put_failure;\n\t}\n\tCMD(start_p2p_device, START_P2P_DEVICE);\n\tCMD(set_mcast_rate, SET_MCAST_RATE);\n#ifdef CONFIG_NL80211_TESTMODE\n\tCMD(testmode_cmd, TESTMODE);\n#endif\n\n\tif (rdev->ops->connect || rdev->ops->auth) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_CONNECT))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (rdev->ops->disconnect || rdev->ops->deauth) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_DISCONNECT))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn i;\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int\nnl80211_send_pmsr_ftm_capa(const struct cfg80211_pmsr_capabilities *cap,\n\t\t\t   struct sk_buff *msg)\n{\n\tstruct nlattr *ftm;\n\n\tif (!cap->ftm.supported)\n\t\treturn 0;\n\n\tftm = nla_nest_start_noflag(msg, NL80211_PMSR_TYPE_FTM);\n\tif (!ftm)\n\t\treturn -ENOBUFS;\n\n\tif (cap->ftm.asap && nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_ASAP))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.non_asap &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.request_lci &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.request_civicloc &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES,\n\t\t\tcap->ftm.preambles))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS,\n\t\t\tcap->ftm.bandwidths))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.max_bursts_exponent >= 0 &&\n\t    nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT,\n\t\t\tcap->ftm.max_bursts_exponent))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.max_ftms_per_burst &&\n\t    nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST,\n\t\t\tcap->ftm.max_ftms_per_burst))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.trigger_based &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_TRIGGER_BASED))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.non_trigger_based &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_NON_TRIGGER_BASED))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, ftm);\n\treturn 0;\n}\n\nstatic int nl80211_send_pmsr_capa(struct cfg80211_registered_device *rdev,\n\t\t\t\t  struct sk_buff *msg)\n{\n\tconst struct cfg80211_pmsr_capabilities *cap = rdev->wiphy.pmsr_capa;\n\tstruct nlattr *pmsr, *caps;\n\n\tif (!cap)\n\t\treturn 0;\n\n\t/*\n\t * we don't need to clean up anything here since the caller\n\t * will genlmsg_cancel() if we fail\n\t */\n\n\tpmsr = nla_nest_start_noflag(msg, NL80211_ATTR_PEER_MEASUREMENTS);\n\tif (!pmsr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_PMSR_ATTR_MAX_PEERS, cap->max_peers))\n\t\treturn -ENOBUFS;\n\n\tif (cap->report_ap_tsf &&\n\t    nla_put_flag(msg, NL80211_PMSR_ATTR_REPORT_AP_TSF))\n\t\treturn -ENOBUFS;\n\n\tif (cap->randomize_mac_addr &&\n\t    nla_put_flag(msg, NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR))\n\t\treturn -ENOBUFS;\n\n\tcaps = nla_nest_start_noflag(msg, NL80211_PMSR_ATTR_TYPE_CAPA);\n\tif (!caps)\n\t\treturn -ENOBUFS;\n\n\tif (nl80211_send_pmsr_ftm_capa(cap, msg))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, caps);\n\tnla_nest_end(msg, pmsr);\n\n\treturn 0;\n}\n\nstatic int\nnl80211_put_iftype_akm_suites(struct cfg80211_registered_device *rdev,\n\t\t\t      struct sk_buff *msg)\n{\n\tint i;\n\tstruct nlattr *nested, *nested_akms;\n\tconst struct wiphy_iftype_akm_suites *iftype_akms;\n\n\tif (!rdev->wiphy.num_iftype_akm_suites ||\n\t    !rdev->wiphy.iftype_akm_suites)\n\t\treturn 0;\n\n\tnested = nla_nest_start(msg, NL80211_ATTR_IFTYPE_AKM_SUITES);\n\tif (!nested)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < rdev->wiphy.num_iftype_akm_suites; i++) {\n\t\tnested_akms = nla_nest_start(msg, i + 1);\n\t\tif (!nested_akms)\n\t\t\treturn -ENOBUFS;\n\n\t\tiftype_akms = &rdev->wiphy.iftype_akm_suites[i];\n\n\t\tif (nl80211_put_iftypes(msg, NL80211_IFTYPE_AKM_ATTR_IFTYPES,\n\t\t\t\t\tiftype_akms->iftypes_mask))\n\t\t\treturn -ENOBUFS;\n\n\t\tif (nla_put(msg, NL80211_IFTYPE_AKM_ATTR_SUITES,\n\t\t\t    sizeof(u32) * iftype_akms->n_akm_suites,\n\t\t\t    iftype_akms->akm_suites)) {\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tnla_nest_end(msg, nested_akms);\n\t}\n\n\tnla_nest_end(msg, nested);\n\n\treturn 0;\n}\n\nstatic int\nnl80211_put_tid_config_support(struct cfg80211_registered_device *rdev,\n\t\t\t       struct sk_buff *msg)\n{\n\tstruct nlattr *supp;\n\n\tif (!rdev->wiphy.tid_config_support.vif &&\n\t    !rdev->wiphy.tid_config_support.peer)\n\t\treturn 0;\n\n\tsupp = nla_nest_start(msg, NL80211_ATTR_TID_CONFIG);\n\tif (!supp)\n\t\treturn -ENOSPC;\n\n\tif (rdev->wiphy.tid_config_support.vif &&\n\t    nla_put_u64_64bit(msg, NL80211_TID_CONFIG_ATTR_VIF_SUPP,\n\t\t\t      rdev->wiphy.tid_config_support.vif,\n\t\t\t      NL80211_TID_CONFIG_ATTR_PAD))\n\t\tgoto fail;\n\n\tif (rdev->wiphy.tid_config_support.peer &&\n\t    nla_put_u64_64bit(msg, NL80211_TID_CONFIG_ATTR_PEER_SUPP,\n\t\t\t      rdev->wiphy.tid_config_support.peer,\n\t\t\t      NL80211_TID_CONFIG_ATTR_PAD))\n\t\tgoto fail;\n\n\t/* for now we just use the same value ... makes more sense */\n\tif (nla_put_u8(msg, NL80211_TID_CONFIG_ATTR_RETRY_SHORT,\n\t\t       rdev->wiphy.tid_config_support.max_retry))\n\t\tgoto fail;\n\tif (nla_put_u8(msg, NL80211_TID_CONFIG_ATTR_RETRY_LONG,\n\t\t       rdev->wiphy.tid_config_support.max_retry))\n\t\tgoto fail;\n\n\tnla_nest_end(msg, supp);\n\n\treturn 0;\nfail:\n\tnla_nest_cancel(msg, supp);\n\treturn -ENOBUFS;\n}\n\nstatic int\nnl80211_put_sar_specs(struct cfg80211_registered_device *rdev,\n\t\t      struct sk_buff *msg)\n{\n\tstruct nlattr *sar_capa, *specs, *sub_freq_range;\n\tu8 num_freq_ranges;\n\tint i;\n\n\tif (!rdev->wiphy.sar_capa)\n\t\treturn 0;\n\n\tnum_freq_ranges = rdev->wiphy.sar_capa->num_freq_ranges;\n\n\tsar_capa = nla_nest_start(msg, NL80211_ATTR_SAR_SPEC);\n\tif (!sar_capa)\n\t\treturn -ENOSPC;\n\n\tif (nla_put_u32(msg, NL80211_SAR_ATTR_TYPE, rdev->wiphy.sar_capa->type))\n\t\tgoto fail;\n\n\tspecs = nla_nest_start(msg, NL80211_SAR_ATTR_SPECS);\n\tif (!specs)\n\t\tgoto fail;\n\n\t/* report supported freq_ranges */\n\tfor (i = 0; i < num_freq_ranges; i++) {\n\t\tsub_freq_range = nla_nest_start(msg, i + 1);\n\t\tif (!sub_freq_range)\n\t\t\tgoto fail;\n\n\t\tif (nla_put_u32(msg, NL80211_SAR_ATTR_SPECS_START_FREQ,\n\t\t\t\trdev->wiphy.sar_capa->freq_ranges[i].start_freq))\n\t\t\tgoto fail;\n\n\t\tif (nla_put_u32(msg, NL80211_SAR_ATTR_SPECS_END_FREQ,\n\t\t\t\trdev->wiphy.sar_capa->freq_ranges[i].end_freq))\n\t\t\tgoto fail;\n\n\t\tnla_nest_end(msg, sub_freq_range);\n\t}\n\n\tnla_nest_end(msg, specs);\n\tnla_nest_end(msg, sar_capa);\n\n\treturn 0;\nfail:\n\tnla_nest_cancel(msg, sar_capa);\n\treturn -ENOBUFS;\n}\n\nstruct nl80211_dump_wiphy_state {\n\ts64 filter_wiphy;\n\tlong start;\n\tlong split_start, band_start, chan_start, capa_start;\n\tbool split;\n};\n\nstatic int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,\n\t\t\t      enum nl80211_commands cmd,\n\t\t\t      struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t      int flags, struct nl80211_dump_wiphy_state *state)\n{\n\tvoid *hdr;\n\tstruct nlattr *nl_bands, *nl_band;\n\tstruct nlattr *nl_freqs, *nl_freq;\n\tstruct nlattr *nl_cmds;\n\tenum nl80211_band band;\n\tstruct ieee80211_channel *chan;\n\tint i;\n\tconst struct ieee80211_txrx_stypes *mgmt_stypes =\n\t\t\t\trdev->wiphy.mgmt_stypes;\n\tu32 features;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (WARN_ON(!state))\n\t\treturn -EINVAL;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_string(msg, NL80211_ATTR_WIPHY_NAME,\n\t\t\t   wiphy_name(&rdev->wiphy)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION,\n\t\t\tcfg80211_rdev_list_generation))\n\t\tgoto nla_put_failure;\n\n\tif (cmd != NL80211_CMD_NEW_WIPHY)\n\t\tgoto finish;\n\n\tswitch (state->split_start) {\n\tcase 0:\n\t\tif (nla_put_u8(msg, NL80211_ATTR_WIPHY_RETRY_SHORT,\n\t\t\t       rdev->wiphy.retry_short) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_WIPHY_RETRY_LONG,\n\t\t\t       rdev->wiphy.retry_long) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FRAG_THRESHOLD,\n\t\t\t\trdev->wiphy.frag_threshold) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_RTS_THRESHOLD,\n\t\t\t\trdev->wiphy.rts_threshold) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_WIPHY_COVERAGE_CLASS,\n\t\t\t       rdev->wiphy.coverage_class) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_NUM_SCAN_SSIDS,\n\t\t\t       rdev->wiphy.max_scan_ssids) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS,\n\t\t\t       rdev->wiphy.max_sched_scan_ssids) ||\n\t\t    nla_put_u16(msg, NL80211_ATTR_MAX_SCAN_IE_LEN,\n\t\t\t\trdev->wiphy.max_scan_ie_len) ||\n\t\t    nla_put_u16(msg, NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN,\n\t\t\t\trdev->wiphy.max_sched_scan_ie_len) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_MATCH_SETS,\n\t\t\t       rdev->wiphy.max_match_sets))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_SUPPORT_IBSS_RSN))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_MESH_AUTH) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_SUPPORT_MESH_AUTH))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_AP_UAPSD) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_SUPPORT_AP_UAPSD))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_FW_ROAM) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_ROAM_SUPPORT))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_TDLS_SUPPORT))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_TDLS_EXTERNAL_SETUP) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_TDLS_EXTERNAL_SETUP))\n\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 1:\n\t\tif (nla_put(msg, NL80211_ATTR_CIPHER_SUITES,\n\t\t\t    sizeof(u32) * rdev->wiphy.n_cipher_suites,\n\t\t\t    rdev->wiphy.cipher_suites))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u8(msg, NL80211_ATTR_MAX_NUM_PMKIDS,\n\t\t\t       rdev->wiphy.max_num_pmkids))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_CONTROL_PORT_PROTOCOL) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_CONTROL_PORT_ETHERTYPE))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX,\n\t\t\t\trdev->wiphy.available_antennas_tx) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX,\n\t\t\t\trdev->wiphy.available_antennas_rx))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD) &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_PROBE_RESP_OFFLOAD,\n\t\t\t\trdev->wiphy.probe_resp_offload))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.available_antennas_tx ||\n\t\t     rdev->wiphy.available_antennas_rx) &&\n\t\t    rdev->ops->get_antenna) {\n\t\t\tu32 tx_ant = 0, rx_ant = 0;\n\t\t\tint res;\n\n\t\t\tres = rdev_get_antenna(rdev, &tx_ant, &rx_ant);\n\t\t\tif (!res) {\n\t\t\t\tif (nla_put_u32(msg,\n\t\t\t\t\t\tNL80211_ATTR_WIPHY_ANTENNA_TX,\n\t\t\t\t\t\ttx_ant) ||\n\t\t\t\t    nla_put_u32(msg,\n\t\t\t\t\t\tNL80211_ATTR_WIPHY_ANTENNA_RX,\n\t\t\t\t\t\trx_ant))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t}\n\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 2:\n\t\tif (nl80211_put_iftypes(msg, NL80211_ATTR_SUPPORTED_IFTYPES,\n\t\t\t\t\trdev->wiphy.interface_modes))\n\t\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 3:\n\t\tnl_bands = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t NL80211_ATTR_WIPHY_BANDS);\n\t\tif (!nl_bands)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (band = state->band_start;\n\t\t     band < NUM_NL80211_BANDS; band++) {\n\t\t\tstruct ieee80211_supported_band *sband;\n\n\t\t\t/* omit higher bands for ancient software */\n\t\t\tif (band > NL80211_BAND_5GHZ && !state->split)\n\t\t\t\tbreak;\n\n\t\t\tsband = rdev->wiphy.bands[band];\n\n\t\t\tif (!sband)\n\t\t\t\tcontinue;\n\n\t\t\tnl_band = nla_nest_start_noflag(msg, band);\n\t\t\tif (!nl_band)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tswitch (state->chan_start) {\n\t\t\tcase 0:\n\t\t\t\tif (nl80211_send_band_rateinfo(msg, sband,\n\t\t\t\t\t\t\t       state->split))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\tstate->chan_start++;\n\t\t\t\tif (state->split)\n\t\t\t\t\tbreak;\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\t/* add frequencies */\n\t\t\t\tnl_freqs = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t\t NL80211_BAND_ATTR_FREQS);\n\t\t\t\tif (!nl_freqs)\n\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\tfor (i = state->chan_start - 1;\n\t\t\t\t     i < sband->n_channels;\n\t\t\t\t     i++) {\n\t\t\t\t\tnl_freq = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t\t\ti);\n\t\t\t\t\tif (!nl_freq)\n\t\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\t\tchan = &sband->channels[i];\n\n\t\t\t\t\tif (nl80211_msg_put_channel(\n\t\t\t\t\t\t\tmsg, &rdev->wiphy, chan,\n\t\t\t\t\t\t\tstate->split))\n\t\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\t\tnla_nest_end(msg, nl_freq);\n\t\t\t\t\tif (state->split)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (i < sband->n_channels)\n\t\t\t\t\tstate->chan_start = i + 2;\n\t\t\t\telse\n\t\t\t\t\tstate->chan_start = 0;\n\t\t\t\tnla_nest_end(msg, nl_freqs);\n\t\t\t}\n\n\t\t\tnla_nest_end(msg, nl_band);\n\n\t\t\tif (state->split) {\n\t\t\t\t/* start again here */\n\t\t\t\tif (state->chan_start)\n\t\t\t\t\tband--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnla_nest_end(msg, nl_bands);\n\n\t\tif (band < NUM_NL80211_BANDS)\n\t\t\tstate->band_start = band + 1;\n\t\telse\n\t\t\tstate->band_start = 0;\n\n\t\t/* if bands & channels are done, continue outside */\n\t\tif (state->band_start == 0 && state->chan_start == 0)\n\t\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 4:\n\t\tnl_cmds = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_SUPPORTED_COMMANDS);\n\t\tif (!nl_cmds)\n\t\t\tgoto nla_put_failure;\n\n\t\ti = nl80211_add_commands_unsplit(rdev, msg);\n\t\tif (i < 0)\n\t\t\tgoto nla_put_failure;\n\t\tif (state->split) {\n\t\t\tCMD(crit_proto_start, CRIT_PROTOCOL_START);\n\t\t\tCMD(crit_proto_stop, CRIT_PROTOCOL_STOP);\n\t\t\tif (rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH)\n\t\t\t\tCMD(channel_switch, CHANNEL_SWITCH);\n\t\t\tCMD(set_qos_map, SET_QOS_MAP);\n\t\t\tif (rdev->wiphy.features &\n\t\t\t\t\tNL80211_FEATURE_SUPPORTS_WMM_ADMISSION)\n\t\t\t\tCMD(add_tx_ts, ADD_TX_TS);\n\t\t\tCMD(set_multicast_to_unicast, SET_MULTICAST_TO_UNICAST);\n\t\t\tCMD(update_connect_params, UPDATE_CONNECT_PARAMS);\n\t\t\tCMD(update_ft_ies, UPDATE_FT_IES);\n\t\t\tif (rdev->wiphy.sar_capa)\n\t\t\t\tCMD(set_sar_specs, SET_SAR_SPECS);\n\t\t}\n#undef CMD\n\n\t\tnla_nest_end(msg, nl_cmds);\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 5:\n\t\tif (rdev->ops->remain_on_channel &&\n\t\t    (rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL) &&\n\t\t    nla_put_u32(msg,\n\t\t\t\tNL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION,\n\t\t\t\trdev->wiphy.max_remain_on_channel_duration))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_OFFCHANNEL_TX_OK))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 6:\n#ifdef CONFIG_PM\n\t\tif (nl80211_send_wowlan(msg, rdev, state->split))\n\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n#else\n\t\tstate->split_start++;\n#endif\n\t\tfallthrough;\n\tcase 7:\n\t\tif (nl80211_put_iftypes(msg, NL80211_ATTR_SOFTWARE_IFTYPES,\n\t\t\t\t\trdev->wiphy.software_iftypes))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_put_iface_combinations(&rdev->wiphy, msg,\n\t\t\t\t\t\t   state->split))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 8:\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_HAVE_AP_SME) &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_DEVICE_AP_SME,\n\t\t\t\trdev->wiphy.ap_sme_capa))\n\t\t\tgoto nla_put_failure;\n\n\t\tfeatures = rdev->wiphy.features;\n\t\t/*\n\t\t * We can only add the per-channel limit information if the\n\t\t * dump is split, otherwise it makes it too big. Therefore\n\t\t * only advertise it in that case.\n\t\t */\n\t\tif (state->split)\n\t\t\tfeatures |= NL80211_FEATURE_ADVERTISE_CHAN_LIMITS;\n\t\tif (nla_put_u32(msg, NL80211_ATTR_FEATURE_FLAGS, features))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.ht_capa_mod_mask &&\n\t\t    nla_put(msg, NL80211_ATTR_HT_CAPABILITY_MASK,\n\t\t\t    sizeof(*rdev->wiphy.ht_capa_mod_mask),\n\t\t\t    rdev->wiphy.ht_capa_mod_mask))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_HAVE_AP_SME &&\n\t\t    rdev->wiphy.max_acl_mac_addrs &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAC_ACL_MAX,\n\t\t\t\trdev->wiphy.max_acl_mac_addrs))\n\t\t\tgoto nla_put_failure;\n\n\t\t/*\n\t\t * Any information below this point is only available to\n\t\t * applications that can deal with it being split. This\n\t\t * helps ensure that newly added capabilities don't break\n\t\t * older tools by overrunning their buffers.\n\t\t *\n\t\t * We still increment split_start so that in the split\n\t\t * case we'll continue with more data in the next round,\n\t\t * but break unconditionally so unsplit data stops here.\n\t\t */\n\t\tif (state->split)\n\t\t\tstate->split_start++;\n\t\telse\n\t\t\tstate->split_start = 0;\n\t\tbreak;\n\tcase 9:\n\t\tif (nl80211_send_mgmt_stypes(msg, mgmt_stypes))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_MAX_NUM_SCHED_SCAN_PLANS,\n\t\t\t\trdev->wiphy.max_sched_scan_plans) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAX_SCAN_PLAN_INTERVAL,\n\t\t\t\trdev->wiphy.max_sched_scan_plan_interval) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS,\n\t\t\t\trdev->wiphy.max_sched_scan_plan_iterations))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.extended_capabilities &&\n\t\t    (nla_put(msg, NL80211_ATTR_EXT_CAPA,\n\t\t\t     rdev->wiphy.extended_capabilities_len,\n\t\t\t     rdev->wiphy.extended_capabilities) ||\n\t\t     nla_put(msg, NL80211_ATTR_EXT_CAPA_MASK,\n\t\t\t     rdev->wiphy.extended_capabilities_len,\n\t\t\t     rdev->wiphy.extended_capabilities_mask)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.vht_capa_mod_mask &&\n\t\t    nla_put(msg, NL80211_ATTR_VHT_CAPABILITY_MASK,\n\t\t\t    sizeof(*rdev->wiphy.vht_capa_mod_mask),\n\t\t\t    rdev->wiphy.vht_capa_mod_mask))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN,\n\t\t\t    rdev->wiphy.perm_addr))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (!is_zero_ether_addr(rdev->wiphy.addr_mask) &&\n\t\t    nla_put(msg, NL80211_ATTR_MAC_MASK, ETH_ALEN,\n\t\t\t    rdev->wiphy.addr_mask))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.n_addresses > 1) {\n\t\t\tvoid *attr;\n\n\t\t\tattr = nla_nest_start(msg, NL80211_ATTR_MAC_ADDRS);\n\t\t\tif (!attr)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < rdev->wiphy.n_addresses; i++)\n\t\t\t\tif (nla_put(msg, i + 1, ETH_ALEN,\n\t\t\t\t\t    rdev->wiphy.addresses[i].addr))\n\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(msg, attr);\n\t\t}\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 10:\n\t\tif (nl80211_send_coalesce(msg, rdev))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_5_10_MHZ) &&\n\t\t    (nla_put_flag(msg, NL80211_ATTR_SUPPORT_5_MHZ) ||\n\t\t     nla_put_flag(msg, NL80211_ATTR_SUPPORT_10_MHZ)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.max_ap_assoc_sta &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAX_AP_ASSOC_STA,\n\t\t\t\trdev->wiphy.max_ap_assoc_sta))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 11:\n\t\tif (rdev->wiphy.n_vendor_commands) {\n\t\t\tconst struct nl80211_vendor_cmd_info *info;\n\t\t\tstruct nlattr *nested;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_VENDOR_DATA);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < rdev->wiphy.n_vendor_commands; i++) {\n\t\t\t\tinfo = &rdev->wiphy.vendor_commands[i].info;\n\t\t\t\tif (nla_put(msg, i + 1, sizeof(*info), info))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t}\n\n\t\tif (rdev->wiphy.n_vendor_events) {\n\t\t\tconst struct nl80211_vendor_cmd_info *info;\n\t\t\tstruct nlattr *nested;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_VENDOR_EVENTS);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < rdev->wiphy.n_vendor_events; i++) {\n\t\t\t\tinfo = &rdev->wiphy.vendor_events[i];\n\t\t\t\tif (nla_put(msg, i + 1, sizeof(*info), info))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t}\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 12:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH &&\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_CSA_COUNTERS,\n\t\t\t       rdev->wiphy.max_num_csa_counters))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.max_sched_scan_reqs &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_SCHED_SCAN_MAX_REQS,\n\t\t\t\trdev->wiphy.max_sched_scan_reqs))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put(msg, NL80211_ATTR_EXT_FEATURES,\n\t\t\t    sizeof(rdev->wiphy.ext_features),\n\t\t\t    rdev->wiphy.ext_features))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.bss_select_support) {\n\t\t\tstruct nlattr *nested;\n\t\t\tu32 bss_select_support = rdev->wiphy.bss_select_support;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_BSS_SELECT);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\ti = 0;\n\t\t\twhile (bss_select_support) {\n\t\t\t\tif ((bss_select_support & 1) &&\n\t\t\t\t    nla_put_flag(msg, i))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\ti++;\n\t\t\t\tbss_select_support >>= 1;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t}\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 13:\n\t\tif (rdev->wiphy.num_iftype_ext_capab &&\n\t\t    rdev->wiphy.iftype_ext_capab) {\n\t\t\tstruct nlattr *nested_ext_capab, *nested;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_IFTYPE_EXT_CAPA);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = state->capa_start;\n\t\t\t     i < rdev->wiphy.num_iftype_ext_capab; i++) {\n\t\t\t\tconst struct wiphy_iftype_ext_capab *capab;\n\n\t\t\t\tcapab = &rdev->wiphy.iftype_ext_capab[i];\n\n\t\t\t\tnested_ext_capab = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t\t\t i);\n\t\t\t\tif (!nested_ext_capab ||\n\t\t\t\t    nla_put_u32(msg, NL80211_ATTR_IFTYPE,\n\t\t\t\t\t\tcapab->iftype) ||\n\t\t\t\t    nla_put(msg, NL80211_ATTR_EXT_CAPA,\n\t\t\t\t\t    capab->extended_capabilities_len,\n\t\t\t\t\t    capab->extended_capabilities) ||\n\t\t\t\t    nla_put(msg, NL80211_ATTR_EXT_CAPA_MASK,\n\t\t\t\t\t    capab->extended_capabilities_len,\n\t\t\t\t\t    capab->extended_capabilities_mask))\n\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\tnla_nest_end(msg, nested_ext_capab);\n\t\t\t\tif (state->split)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t\tif (i < rdev->wiphy.num_iftype_ext_capab) {\n\t\t\t\tstate->capa_start = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_BANDS,\n\t\t\t\trdev->wiphy.nan_supported_bands))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_TXQS)) {\n\t\t\tstruct cfg80211_txq_stats txqstats = {};\n\t\t\tint res;\n\n\t\t\tres = rdev_get_txq_stats(rdev, NULL, &txqstats);\n\t\t\tif (!res &&\n\t\t\t    !nl80211_put_txq_stats(msg, &txqstats,\n\t\t\t\t\t\t   NL80211_ATTR_TXQ_STATS))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u32(msg, NL80211_ATTR_TXQ_LIMIT,\n\t\t\t\t\trdev->wiphy.txq_limit))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_ATTR_TXQ_MEMORY_LIMIT,\n\t\t\t\t\trdev->wiphy.txq_memory_limit))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_ATTR_TXQ_QUANTUM,\n\t\t\t\t\trdev->wiphy.txq_quantum))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 14:\n\t\tif (nl80211_send_pmsr_capa(rdev, msg))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 15:\n\t\tif (rdev->wiphy.akm_suites &&\n\t\t    nla_put(msg, NL80211_ATTR_AKM_SUITES,\n\t\t\t    sizeof(u32) * rdev->wiphy.n_akm_suites,\n\t\t\t    rdev->wiphy.akm_suites))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_put_iftype_akm_suites(rdev, msg))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_put_tid_config_support(rdev, msg))\n\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 16:\n\t\tif (nl80211_put_sar_specs(rdev, msg))\n\t\t\tgoto nla_put_failure;\n\n\t\t/* done */\n\t\tstate->split_start = 0;\n\t\tbreak;\n\t}\n finish:\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_wiphy_parse(struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb,\n\t\t\t\t    struct nl80211_dump_wiphy_state *state)\n{\n\tstruct nlattr **tb = kcalloc(NUM_NL80211_ATTR, sizeof(*tb), GFP_KERNEL);\n\tint ret;\n\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tret = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t     tb, nl80211_fam.maxattr,\n\t\t\t\t     nl80211_policy, NULL);\n\t/* ignore parse errors for backward compatibility */\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tstate->split = tb[NL80211_ATTR_SPLIT_WIPHY_DUMP];\n\tif (tb[NL80211_ATTR_WIPHY])\n\t\tstate->filter_wiphy = nla_get_u32(tb[NL80211_ATTR_WIPHY]);\n\tif (tb[NL80211_ATTR_WDEV])\n\t\tstate->filter_wiphy = nla_get_u64(tb[NL80211_ATTR_WDEV]) >> 32;\n\tif (tb[NL80211_ATTR_IFINDEX]) {\n\t\tstruct net_device *netdev;\n\t\tstruct cfg80211_registered_device *rdev;\n\t\tint ifidx = nla_get_u32(tb[NL80211_ATTR_IFINDEX]);\n\n\t\tnetdev = __dev_get_by_index(sock_net(skb->sk), ifidx);\n\t\tif (!netdev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (netdev->ieee80211_ptr) {\n\t\t\trdev = wiphy_to_rdev(\n\t\t\t\tnetdev->ieee80211_ptr->wiphy);\n\t\t\tstate->filter_wiphy = rdev->wiphy_idx;\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tkfree(tb);\n\treturn ret;\n}\n\nstatic int nl80211_dump_wiphy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx = 0, ret;\n\tstruct nl80211_dump_wiphy_state *state = (void *)cb->args[0];\n\tstruct cfg80211_registered_device *rdev;\n\n\trtnl_lock();\n\tif (!state) {\n\t\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\t\tif (!state) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tstate->filter_wiphy = -1;\n\t\tret = nl80211_dump_wiphy_parse(skb, cb, state);\n\t\tif (ret) {\n\t\t\tkfree(state);\n\t\t\trtnl_unlock();\n\t\t\treturn ret;\n\t\t}\n\t\tcb->args[0] = (long)state;\n\t}\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (++idx <= state->start)\n\t\t\tcontinue;\n\t\tif (state->filter_wiphy != -1 &&\n\t\t    state->filter_wiphy != rdev->wiphy_idx)\n\t\t\tcontinue;\n\t\t/* attempt to fit multiple wiphy data chunks into the skb */\n\t\tdo {\n\t\t\tret = nl80211_send_wiphy(rdev, NL80211_CMD_NEW_WIPHY,\n\t\t\t\t\t\t skb,\n\t\t\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t NLM_F_MULTI, state);\n\t\t\tif (ret < 0) {\n\t\t\t\t/*\n\t\t\t\t * If sending the wiphy data didn't fit (ENOBUFS\n\t\t\t\t * or EMSGSIZE returned), this SKB is still\n\t\t\t\t * empty (so it's not too big because another\n\t\t\t\t * wiphy dataset is already in the skb) and\n\t\t\t\t * we've not tried to adjust the dump allocation\n\t\t\t\t * yet ... then adjust the alloc size to be\n\t\t\t\t * bigger, and return 1 but with the empty skb.\n\t\t\t\t * This results in an empty message being RX'ed\n\t\t\t\t * in userspace, but that is ignored.\n\t\t\t\t *\n\t\t\t\t * We can then retry with the larger buffer.\n\t\t\t\t */\n\t\t\t\tif ((ret == -ENOBUFS || ret == -EMSGSIZE) &&\n\t\t\t\t    !skb->len && !state->split &&\n\t\t\t\t    cb->min_dump_alloc < 4096) {\n\t\t\t\t\tcb->min_dump_alloc = 4096;\n\t\t\t\t\tstate->split_start = 0;\n\t\t\t\t\trtnl_unlock();\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tidx--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (state->split_start > 0);\n\t\tbreak;\n\t}\n\trtnl_unlock();\n\n\tstate->start = idx;\n\n\treturn skb->len;\n}\n\nstatic int nl80211_dump_wiphy_done(struct netlink_callback *cb)\n{\n\tkfree((void *)cb->args[0]);\n\treturn 0;\n}\n\nstatic int nl80211_get_wiphy(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nl80211_dump_wiphy_state state = {};\n\n\tmsg = nlmsg_new(4096, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_wiphy(rdev, NL80211_CMD_NEW_WIPHY, msg,\n\t\t\t       info->snd_portid, info->snd_seq, 0,\n\t\t\t       &state) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic const struct nla_policy txq_params_policy[NL80211_TXQ_ATTR_MAX + 1] = {\n\t[NL80211_TXQ_ATTR_QUEUE]\t\t= { .type = NLA_U8 },\n\t[NL80211_TXQ_ATTR_TXOP]\t\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_CWMIN]\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_CWMAX]\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_AIFS]\t\t\t= { .type = NLA_U8 },\n};\n\nstatic int parse_txq_params(struct nlattr *tb[],\n\t\t\t    struct ieee80211_txq_params *txq_params)\n{\n\tu8 ac;\n\n\tif (!tb[NL80211_TXQ_ATTR_AC] || !tb[NL80211_TXQ_ATTR_TXOP] ||\n\t    !tb[NL80211_TXQ_ATTR_CWMIN] || !tb[NL80211_TXQ_ATTR_CWMAX] ||\n\t    !tb[NL80211_TXQ_ATTR_AIFS])\n\t\treturn -EINVAL;\n\n\tac = nla_get_u8(tb[NL80211_TXQ_ATTR_AC]);\n\ttxq_params->txop = nla_get_u16(tb[NL80211_TXQ_ATTR_TXOP]);\n\ttxq_params->cwmin = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMIN]);\n\ttxq_params->cwmax = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMAX]);\n\ttxq_params->aifs = nla_get_u8(tb[NL80211_TXQ_ATTR_AIFS]);\n\n\tif (ac >= NL80211_NUM_ACS)\n\t\treturn -EINVAL;\n\ttxq_params->ac = array_index_nospec(ac, NL80211_NUM_ACS);\n\treturn 0;\n}\n\nstatic bool nl80211_can_set_dev_channel(struct wireless_dev *wdev)\n{\n\t/*\n\t * You can only set the channel explicitly for some interfaces,\n\t * most have their channel managed via their respective\n\t * \"establish a connection\" command (connect, join, ...)\n\t *\n\t * For AP/GO and mesh mode, the channel can be set with the\n\t * channel userspace API, but is only stored and passed to the\n\t * low-level driver when the AP starts or the mesh is joined.\n\t * This is for backward compatibility, userspace can also give\n\t * the channel in the start-ap or join-mesh commands instead.\n\t *\n\t * Monitors are special as they are normally slaved to\n\t * whatever else is going on, so they have their own special\n\t * operation to set the monitor channel if possible.\n\t */\n\treturn !wdev ||\n\t\twdev->iftype == NL80211_IFTYPE_AP ||\n\t\twdev->iftype == NL80211_IFTYPE_MESH_POINT ||\n\t\twdev->iftype == NL80211_IFTYPE_MONITOR ||\n\t\twdev->iftype == NL80211_IFTYPE_P2P_GO;\n}\n\nint nl80211_parse_chandef(struct cfg80211_registered_device *rdev,\n\t\t\t  struct genl_info *info,\n\t\t\t  struct cfg80211_chan_def *chandef)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct nlattr **attrs = info->attrs;\n\tu32 control_freq;\n\n\tif (!attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\tcontrol_freq = MHZ_TO_KHZ(\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET])\n\t\tcontrol_freq +=\n\t\t    nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET]);\n\n\tmemset(chandef, 0, sizeof(*chandef));\n\tchandef->chan = ieee80211_get_channel_khz(&rdev->wiphy, control_freq);\n\tchandef->width = NL80211_CHAN_WIDTH_20_NOHT;\n\tchandef->center_freq1 = KHZ_TO_MHZ(control_freq);\n\tchandef->freq1_offset = control_freq % 1000;\n\tchandef->center_freq2 = 0;\n\n\t/* Primary channel not allowed */\n\tif (!chandef->chan || chandef->chan->flags & IEEE80211_CHAN_DISABLED) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, attrs[NL80211_ATTR_WIPHY_FREQ],\n\t\t\t\t    \"Channel is disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]) {\n\t\tenum nl80211_channel_type chantype;\n\n\t\tchantype = nla_get_u32(attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]);\n\n\t\tswitch (chantype) {\n\t\tcase NL80211_CHAN_NO_HT:\n\t\tcase NL80211_CHAN_HT20:\n\t\tcase NL80211_CHAN_HT40PLUS:\n\t\tcase NL80211_CHAN_HT40MINUS:\n\t\t\tcfg80211_chandef_create(chandef, chandef->chan,\n\t\t\t\t\t\tchantype);\n\t\t\t/* user input for center_freq is incorrect */\n\t\t\tif (attrs[NL80211_ATTR_CENTER_FREQ1] &&\n\t\t\t    chandef->center_freq1 != nla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ1])) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t\t    attrs[NL80211_ATTR_CENTER_FREQ1],\n\t\t\t\t\t\t    \"bad center frequency 1\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* center_freq2 must be zero */\n\t\t\tif (attrs[NL80211_ATTR_CENTER_FREQ2] &&\n\t\t\t    nla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ2])) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t\t    attrs[NL80211_ATTR_CENTER_FREQ2],\n\t\t\t\t\t\t    \"center frequency 2 can't be used\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t    attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE],\n\t\t\t\t\t    \"invalid channel type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (attrs[NL80211_ATTR_CHANNEL_WIDTH]) {\n\t\tchandef->width =\n\t\t\tnla_get_u32(attrs[NL80211_ATTR_CHANNEL_WIDTH]);\n\t\tif (attrs[NL80211_ATTR_CENTER_FREQ1]) {\n\t\t\tchandef->center_freq1 =\n\t\t\t\tnla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ1]);\n\t\t\tif (attrs[NL80211_ATTR_CENTER_FREQ1_OFFSET])\n\t\t\t\tchandef->freq1_offset = nla_get_u32(\n\t\t\t\t      attrs[NL80211_ATTR_CENTER_FREQ1_OFFSET]);\n\t\t\telse\n\t\t\t\tchandef->freq1_offset = 0;\n\t\t}\n\t\tif (attrs[NL80211_ATTR_CENTER_FREQ2])\n\t\t\tchandef->center_freq2 =\n\t\t\t\tnla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ2]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]) {\n\t\tchandef->edmg.channels =\n\t\t      nla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]);\n\n\t\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG])\n\t\t\tchandef->edmg.bw_config =\n\t\t     nla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG]);\n\t} else {\n\t\tchandef->edmg.bw_config = 0;\n\t\tchandef->edmg.channels = 0;\n\t}\n\n\tif (!cfg80211_chandef_valid(chandef)) {\n\t\tNL_SET_ERR_MSG(extack, \"invalid channel definition\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cfg80211_chandef_usable(&rdev->wiphy, chandef,\n\t\t\t\t     IEEE80211_CHAN_DISABLED)) {\n\t\tNL_SET_ERR_MSG(extack, \"(extension) channel is disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((chandef->width == NL80211_CHAN_WIDTH_5 ||\n\t     chandef->width == NL80211_CHAN_WIDTH_10) &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_5_10_MHZ)) {\n\t\tNL_SET_ERR_MSG(extack, \"5/10 MHz not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __nl80211_set_channel(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *dev,\n\t\t\t\t struct genl_info *info)\n{\n\tstruct cfg80211_chan_def chandef;\n\tint result;\n\tenum nl80211_iftype iftype = NL80211_IFTYPE_MONITOR;\n\tstruct wireless_dev *wdev = NULL;\n\n\tif (dev)\n\t\twdev = dev->ieee80211_ptr;\n\tif (!nl80211_can_set_dev_channel(wdev))\n\t\treturn -EOPNOTSUPP;\n\tif (wdev)\n\t\tiftype = wdev->iftype;\n\n\tresult = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (result)\n\t\treturn result;\n\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &chandef,\n\t\t\t\t\t\t   iftype)) {\n\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (wdev->beacon_interval) {\n\t\t\tif (!dev || !rdev->ops->set_ap_chanwidth ||\n\t\t\t    !(rdev->wiphy.features &\n\t\t\t      NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE)) {\n\t\t\t\tresult = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Only allow dynamic channel width changes */\n\t\t\tif (chandef.chan != wdev->preset_chandef.chan) {\n\t\t\t\tresult = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult = rdev_set_ap_chanwidth(rdev, dev, &chandef);\n\t\t\tif (result)\n\t\t\t\tbreak;\n\t\t}\n\t\twdev->preset_chandef = chandef;\n\t\tresult = 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tresult = cfg80211_set_mesh_channel(rdev, wdev, &chandef);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tresult = cfg80211_set_monitor_channel(rdev, &chandef);\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t}\n\n\treturn result;\n}\n\nstatic int nl80211_set_channel(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *netdev = info->user_ptr[1];\n\n\treturn __nl80211_set_channel(rdev, netdev, info);\n}\n\nstatic int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = NULL;\n\tstruct net_device *netdev = NULL;\n\tstruct wireless_dev *wdev;\n\tint result = 0, rem_txq_params = 0;\n\tstruct nlattr *nl_txq_params;\n\tu32 changed;\n\tu8 retry_short = 0, retry_long = 0;\n\tu32 frag_threshold = 0, rts_threshold = 0;\n\tu8 coverage_class = 0;\n\tu32 txq_limit = 0, txq_memory_limit = 0, txq_quantum = 0;\n\n\trtnl_lock();\n\t/*\n\t * Try to find the wiphy and netdev. Normally this\n\t * function shouldn't need the netdev, but this is\n\t * done for backward compatibility -- previously\n\t * setting the channel was done per wiphy, but now\n\t * it is per netdev. Previous userland like hostapd\n\t * also passed a netdev to set_wiphy, so that it is\n\t * possible to let that go to the right netdev!\n\t */\n\n\tif (info->attrs[NL80211_ATTR_IFINDEX]) {\n\t\tint ifindex = nla_get_u32(info->attrs[NL80211_ATTR_IFINDEX]);\n\n\t\tnetdev = __dev_get_by_index(genl_info_net(info), ifindex);\n\t\tif (netdev && netdev->ieee80211_ptr)\n\t\t\trdev = wiphy_to_rdev(netdev->ieee80211_ptr->wiphy);\n\t\telse\n\t\t\tnetdev = NULL;\n\t}\n\n\tif (!netdev) {\n\t\trdev = __cfg80211_rdev_from_attrs(genl_info_net(info),\n\t\t\t\t\t\t  info->attrs);\n\t\tif (IS_ERR(rdev)) {\n\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t\twdev = NULL;\n\t\tnetdev = NULL;\n\t\tresult = 0;\n\t} else\n\t\twdev = netdev->ieee80211_ptr;\n\n\tif (rdev)\n\t\tmutex_lock(&rdev->wiphy.mtx);\n\trtnl_unlock();\n\n\t/*\n\t * end workaround code, by now the rdev is available\n\t * and locked, and wdev may or may not be NULL.\n\t */\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_NAME])\n\t\tresult = cfg80211_dev_rename(\n\t\t\trdev, nla_data(info->attrs[NL80211_ATTR_WIPHY_NAME]));\n\n\tif (result)\n\t\tgoto out;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS]) {\n\t\tstruct ieee80211_txq_params txq_params;\n\t\tstruct nlattr *tb[NL80211_TXQ_ATTR_MAX + 1];\n\n\t\tif (!rdev->ops->set_txq_params) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!netdev) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t\t    netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!netif_running(netdev)) {\n\t\t\tresult = -ENETDOWN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnla_for_each_nested(nl_txq_params,\n\t\t\t\t    info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS],\n\t\t\t\t    rem_txq_params) {\n\t\t\tresult = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t\t     NL80211_TXQ_ATTR_MAX,\n\t\t\t\t\t\t\t     nl_txq_params,\n\t\t\t\t\t\t\t     txq_params_policy,\n\t\t\t\t\t\t\t     info->extack);\n\t\t\tif (result)\n\t\t\t\tgoto out;\n\t\t\tresult = parse_txq_params(tb, &txq_params);\n\t\t\tif (result)\n\t\t\t\tgoto out;\n\n\t\t\tresult = rdev_set_txq_params(rdev, netdev,\n\t\t\t\t\t\t     &txq_params);\n\t\t\tif (result)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\tresult = __nl80211_set_channel(\n\t\t\trdev,\n\t\t\tnl80211_can_set_dev_channel(wdev) ? netdev : NULL,\n\t\t\tinfo);\n\t\tif (result)\n\t\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_TX_POWER_SETTING]) {\n\t\tstruct wireless_dev *txp_wdev = wdev;\n\t\tenum nl80211_tx_power_setting type;\n\t\tint idx, mbm = 0;\n\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_VIF_TXPOWER))\n\t\t\ttxp_wdev = NULL;\n\n\t\tif (!rdev->ops->set_tx_power) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tidx = NL80211_ATTR_WIPHY_TX_POWER_SETTING;\n\t\ttype = nla_get_u32(info->attrs[idx]);\n\n\t\tif (!info->attrs[NL80211_ATTR_WIPHY_TX_POWER_LEVEL] &&\n\t\t    (type != NL80211_TX_POWER_AUTOMATIC)) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (type != NL80211_TX_POWER_AUTOMATIC) {\n\t\t\tidx = NL80211_ATTR_WIPHY_TX_POWER_LEVEL;\n\t\t\tmbm = nla_get_u32(info->attrs[idx]);\n\t\t}\n\n\t\tresult = rdev_set_tx_power(rdev, txp_wdev, type, mbm);\n\t\tif (result)\n\t\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&\n\t    info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]) {\n\t\tu32 tx_ant, rx_ant;\n\n\t\tif ((!rdev->wiphy.available_antennas_tx &&\n\t\t     !rdev->wiphy.available_antennas_rx) ||\n\t\t    !rdev->ops->set_antenna) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttx_ant = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX]);\n\t\trx_ant = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]);\n\n\t\t/* reject antenna configurations which don't match the\n\t\t * available antenna masks, except for the \"all\" mask */\n\t\tif ((~tx_ant && (tx_ant & ~rdev->wiphy.available_antennas_tx)) ||\n\t\t    (~rx_ant && (rx_ant & ~rdev->wiphy.available_antennas_rx))) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttx_ant = tx_ant & rdev->wiphy.available_antennas_tx;\n\t\trx_ant = rx_ant & rdev->wiphy.available_antennas_rx;\n\n\t\tresult = rdev_set_antenna(rdev, tx_ant, rx_ant);\n\t\tif (result)\n\t\t\tgoto out;\n\t}\n\n\tchanged = 0;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RETRY_SHORT]) {\n\t\tretry_short = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RETRY_SHORT]);\n\n\t\tchanged |= WIPHY_PARAM_RETRY_SHORT;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RETRY_LONG]) {\n\t\tretry_long = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RETRY_LONG]);\n\n\t\tchanged |= WIPHY_PARAM_RETRY_LONG;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]) {\n\t\tfrag_threshold = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]);\n\t\tif (frag_threshold < 256) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (frag_threshold != (u32) -1) {\n\t\t\t/*\n\t\t\t * Fragments (apart from the last one) are required to\n\t\t\t * have even length. Make the fragmentation code\n\t\t\t * simpler by stripping LSB should someone try to use\n\t\t\t * odd threshold value.\n\t\t\t */\n\t\t\tfrag_threshold &= ~0x1;\n\t\t}\n\t\tchanged |= WIPHY_PARAM_FRAG_THRESHOLD;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RTS_THRESHOLD]) {\n\t\trts_threshold = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RTS_THRESHOLD]);\n\t\tchanged |= WIPHY_PARAM_RTS_THRESHOLD;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_COVERAGE_CLASS]) {\n\t\tif (info->attrs[NL80211_ATTR_WIPHY_DYN_ACK]) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcoverage_class = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_COVERAGE_CLASS]);\n\t\tchanged |= WIPHY_PARAM_COVERAGE_CLASS;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_DYN_ACK]) {\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_ACKTO_ESTIMATION)) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tchanged |= WIPHY_PARAM_DYN_ACK;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TXQ_LIMIT]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_TXQS)) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\ttxq_limit = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_TXQ_LIMIT]);\n\t\tchanged |= WIPHY_PARAM_TXQ_LIMIT;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TXQ_MEMORY_LIMIT]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_TXQS)) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\ttxq_memory_limit = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_TXQ_MEMORY_LIMIT]);\n\t\tchanged |= WIPHY_PARAM_TXQ_MEMORY_LIMIT;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TXQ_QUANTUM]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_TXQS)) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\ttxq_quantum = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_TXQ_QUANTUM]);\n\t\tchanged |= WIPHY_PARAM_TXQ_QUANTUM;\n\t}\n\n\tif (changed) {\n\t\tu8 old_retry_short, old_retry_long;\n\t\tu32 old_frag_threshold, old_rts_threshold;\n\t\tu8 old_coverage_class;\n\t\tu32 old_txq_limit, old_txq_memory_limit, old_txq_quantum;\n\n\t\tif (!rdev->ops->set_wiphy_params) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\told_retry_short = rdev->wiphy.retry_short;\n\t\told_retry_long = rdev->wiphy.retry_long;\n\t\told_frag_threshold = rdev->wiphy.frag_threshold;\n\t\told_rts_threshold = rdev->wiphy.rts_threshold;\n\t\told_coverage_class = rdev->wiphy.coverage_class;\n\t\told_txq_limit = rdev->wiphy.txq_limit;\n\t\told_txq_memory_limit = rdev->wiphy.txq_memory_limit;\n\t\told_txq_quantum = rdev->wiphy.txq_quantum;\n\n\t\tif (changed & WIPHY_PARAM_RETRY_SHORT)\n\t\t\trdev->wiphy.retry_short = retry_short;\n\t\tif (changed & WIPHY_PARAM_RETRY_LONG)\n\t\t\trdev->wiphy.retry_long = retry_long;\n\t\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD)\n\t\t\trdev->wiphy.frag_threshold = frag_threshold;\n\t\tif (changed & WIPHY_PARAM_RTS_THRESHOLD)\n\t\t\trdev->wiphy.rts_threshold = rts_threshold;\n\t\tif (changed & WIPHY_PARAM_COVERAGE_CLASS)\n\t\t\trdev->wiphy.coverage_class = coverage_class;\n\t\tif (changed & WIPHY_PARAM_TXQ_LIMIT)\n\t\t\trdev->wiphy.txq_limit = txq_limit;\n\t\tif (changed & WIPHY_PARAM_TXQ_MEMORY_LIMIT)\n\t\t\trdev->wiphy.txq_memory_limit = txq_memory_limit;\n\t\tif (changed & WIPHY_PARAM_TXQ_QUANTUM)\n\t\t\trdev->wiphy.txq_quantum = txq_quantum;\n\n\t\tresult = rdev_set_wiphy_params(rdev, changed);\n\t\tif (result) {\n\t\t\trdev->wiphy.retry_short = old_retry_short;\n\t\t\trdev->wiphy.retry_long = old_retry_long;\n\t\t\trdev->wiphy.frag_threshold = old_frag_threshold;\n\t\t\trdev->wiphy.rts_threshold = old_rts_threshold;\n\t\t\trdev->wiphy.coverage_class = old_coverage_class;\n\t\t\trdev->wiphy.txq_limit = old_txq_limit;\n\t\t\trdev->wiphy.txq_memory_limit = old_txq_memory_limit;\n\t\t\trdev->wiphy.txq_quantum = old_txq_quantum;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tresult = 0;\n\nout:\n\tif (rdev)\n\t\tmutex_unlock(&rdev->wiphy.mtx);\n\treturn result;\n}\n\nstatic int nl80211_send_chandef(struct sk_buff *msg,\n\t\t\t\tconst struct cfg80211_chan_def *chandef)\n{\n\tif (WARN_ON(!cfg80211_chandef_valid(chandef)))\n\t\treturn -EINVAL;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ,\n\t\t\tchandef->chan->center_freq))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ_OFFSET,\n\t\t\tchandef->chan->freq_offset))\n\t\treturn -ENOBUFS;\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,\n\t\t\t\tcfg80211_get_chandef_type(chandef)))\n\t\t\treturn -ENOBUFS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (nla_put_u32(msg, NL80211_ATTR_CHANNEL_WIDTH, chandef->width))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_ATTR_CENTER_FREQ1, chandef->center_freq1))\n\t\treturn -ENOBUFS;\n\tif (chandef->center_freq2 &&\n\t    nla_put_u32(msg, NL80211_ATTR_CENTER_FREQ2, chandef->center_freq2))\n\t\treturn -ENOBUFS;\n\treturn 0;\n}\n\nstatic int nl80211_send_iface(struct sk_buff *msg, u32 portid, u32 seq, int flags,\n\t\t\t      struct cfg80211_registered_device *rdev,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      enum nl80211_commands cmd)\n{\n\tstruct net_device *dev = wdev->netdev;\n\tvoid *hdr;\n\n\tWARN_ON(cmd != NL80211_CMD_NEW_INTERFACE &&\n\t\tcmd != NL80211_CMD_DEL_INTERFACE &&\n\t\tcmd != NL80211_CMD_SET_INTERFACE);\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (dev &&\n\t    (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t     nla_put_string(msg, NL80211_ATTR_IFNAME, dev->name)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFTYPE, wdev->iftype) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, wdev_address(wdev)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION,\n\t\t\trdev->devlist_generation ^\n\t\t\t(cfg80211_rdev_list_generation << 2)) ||\n\t    nla_put_u8(msg, NL80211_ATTR_4ADDR, wdev->use_4addr))\n\t\tgoto nla_put_failure;\n\n\tif (rdev->ops->get_channel) {\n\t\tint ret;\n\t\tstruct cfg80211_chan_def chandef = {};\n\n\t\tret = rdev_get_channel(rdev, wdev, &chandef);\n\t\tif (ret == 0) {\n\t\t\tif (nl80211_send_chandef(msg, &chandef))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif (rdev->ops->get_tx_power) {\n\t\tint dbm, ret;\n\n\t\tret = rdev_get_tx_power(rdev, wdev, &dbm);\n\t\tif (ret == 0 &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_TX_POWER_LEVEL,\n\t\t\t\tDBM_TO_MBM(dbm)))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\twdev_lock(wdev);\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\t\tif (wdev->ssid_len &&\n\t\t    nla_put(msg, NL80211_ATTR_SSID, wdev->ssid_len, wdev->ssid))\n\t\t\tgoto nla_put_failure_locked;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_ADHOC: {\n\t\tconst u8 *ssid_ie;\n\t\tif (!wdev->current_bss)\n\t\t\tbreak;\n\t\trcu_read_lock();\n\t\tssid_ie = ieee80211_bss_get_ie(&wdev->current_bss->pub,\n\t\t\t\t\t       WLAN_EID_SSID);\n\t\tif (ssid_ie &&\n\t\t    nla_put(msg, NL80211_ATTR_SSID, ssid_ie[1], ssid_ie + 2))\n\t\t\tgoto nla_put_failure_rcu_locked;\n\t\trcu_read_unlock();\n\t\tbreak;\n\t\t}\n\tdefault:\n\t\t/* nothing */\n\t\tbreak;\n\t}\n\twdev_unlock(wdev);\n\n\tif (rdev->ops->get_txq_stats) {\n\t\tstruct cfg80211_txq_stats txqstats = {};\n\t\tint ret = rdev_get_txq_stats(rdev, wdev, &txqstats);\n\n\t\tif (ret == 0 &&\n\t\t    !nl80211_put_txq_stats(msg, &txqstats,\n\t\t\t\t\t   NL80211_ATTR_TXQ_STATS))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure_rcu_locked:\n\trcu_read_unlock();\n nla_put_failure_locked:\n\twdev_unlock(wdev);\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_interface(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint wp_idx = 0;\n\tint if_idx = 0;\n\tint wp_start = cb->args[0];\n\tint if_start = cb->args[1];\n\tint filter_wiphy = -1;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tint ret;\n\n\trtnl_lock();\n\tif (!cb->args[2]) {\n\t\tstruct nl80211_dump_wiphy_state state = {\n\t\t\t.filter_wiphy = -1,\n\t\t};\n\n\t\tret = nl80211_dump_wiphy_parse(skb, cb, &state);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tfilter_wiphy = state.filter_wiphy;\n\n\t\t/*\n\t\t * if filtering, set cb->args[2] to +1 since 0 is the default\n\t\t * value needed to determine that parsing is necessary.\n\t\t */\n\t\tif (filter_wiphy >= 0)\n\t\t\tcb->args[2] = filter_wiphy + 1;\n\t\telse\n\t\t\tcb->args[2] = -1;\n\t} else if (cb->args[2] > 0) {\n\t\tfilter_wiphy = cb->args[2] - 1;\n\t}\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (wp_idx < wp_start) {\n\t\t\twp_idx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filter_wiphy >= 0 && filter_wiphy != rdev->wiphy_idx)\n\t\t\tcontinue;\n\n\t\tif_idx = 0;\n\n\t\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tif (if_idx < if_start) {\n\t\t\t\tif_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nl80211_send_iface(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t       rdev, wdev,\n\t\t\t\t\t       NL80211_CMD_NEW_INTERFACE) < 0) {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif_idx++;\n\t\t}\n\n\t\twp_idx++;\n\t}\n out:\n\tcb->args[0] = wp_idx;\n\tcb->args[1] = if_idx;\n\n\tret = skb->len;\n out_unlock:\n\trtnl_unlock();\n\n\treturn ret;\n}\n\nstatic int nl80211_get_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_iface(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t       rdev, wdev, NL80211_CMD_NEW_INTERFACE) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic const struct nla_policy mntr_flags_policy[NL80211_MNTR_FLAG_MAX + 1] = {\n\t[NL80211_MNTR_FLAG_FCSFAIL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_PLCPFAIL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_CONTROL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_OTHER_BSS] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_COOK_FRAMES] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_ACTIVE] = { .type = NLA_FLAG },\n};\n\nstatic int parse_monitor_flags(struct nlattr *nla, u32 *mntrflags)\n{\n\tstruct nlattr *flags[NL80211_MNTR_FLAG_MAX + 1];\n\tint flag;\n\n\t*mntrflags = 0;\n\n\tif (!nla)\n\t\treturn -EINVAL;\n\n\tif (nla_parse_nested_deprecated(flags, NL80211_MNTR_FLAG_MAX, nla, mntr_flags_policy, NULL))\n\t\treturn -EINVAL;\n\n\tfor (flag = 1; flag <= NL80211_MNTR_FLAG_MAX; flag++)\n\t\tif (flags[flag])\n\t\t\t*mntrflags |= (1<<flag);\n\n\t*mntrflags |= MONITOR_FLAG_CHANGED;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_mon_options(struct cfg80211_registered_device *rdev,\n\t\t\t\t     enum nl80211_iftype type,\n\t\t\t\t     struct genl_info *info,\n\t\t\t\t     struct vif_params *params)\n{\n\tbool change = false;\n\tint err;\n\n\tif (info->attrs[NL80211_ATTR_MNTR_FLAGS]) {\n\t\tif (type != NL80211_IFTYPE_MONITOR)\n\t\t\treturn -EINVAL;\n\n\t\terr = parse_monitor_flags(info->attrs[NL80211_ATTR_MNTR_FLAGS],\n\t\t\t\t\t  &params->flags);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tchange = true;\n\t}\n\n\tif (params->flags & MONITOR_FLAG_ACTIVE &&\n\t    !(rdev->wiphy.features & NL80211_FEATURE_ACTIVE_MONITOR))\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_MU_MIMO_GROUP_DATA]) {\n\t\tconst u8 *mumimo_groups;\n\t\tu32 cap_flag = NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER;\n\n\t\tif (type != NL80211_IFTYPE_MONITOR)\n\t\t\treturn -EINVAL;\n\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy, cap_flag))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tmumimo_groups =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MU_MIMO_GROUP_DATA]);\n\n\t\t/* bits 0 and 63 are reserved and must be zero */\n\t\tif ((mumimo_groups[0] & BIT(0)) ||\n\t\t    (mumimo_groups[VHT_MUMIMO_GROUPS_DATA_LEN - 1] & BIT(7)))\n\t\t\treturn -EINVAL;\n\n\t\tparams->vht_mumimo_groups = mumimo_groups;\n\t\tchange = true;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR]) {\n\t\tu32 cap_flag = NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER;\n\n\t\tif (type != NL80211_IFTYPE_MONITOR)\n\t\t\treturn -EINVAL;\n\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy, cap_flag))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tparams->vht_mumimo_follow_addr =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR]);\n\t\tchange = true;\n\t}\n\n\treturn change ? 1 : 0;\n}\n\nstatic int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u8 use_4addr,\n\t\t\t       enum nl80211_iftype iftype)\n{\n\tif (!use_4addr) {\n\t\tif (netdev && netif_is_bridge_port(netdev))\n\t\t\treturn -EBUSY;\n\t\treturn 0;\n\t}\n\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int nl80211_set_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct vif_params params;\n\tint err;\n\tenum nl80211_iftype otype, ntype;\n\tstruct net_device *dev = info->user_ptr[1];\n\tbool change = false;\n\n\tmemset(&params, 0, sizeof(params));\n\n\totype = ntype = dev->ieee80211_ptr->iftype;\n\n\tif (info->attrs[NL80211_ATTR_IFTYPE]) {\n\t\tntype = nla_get_u32(info->attrs[NL80211_ATTR_IFTYPE]);\n\t\tif (otype != ntype)\n\t\t\tchange = true;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MESH_ID]) {\n\t\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t\tif (ntype != NL80211_IFTYPE_MESH_POINT)\n\t\t\treturn -EINVAL;\n\t\tif (netif_running(dev))\n\t\t\treturn -EBUSY;\n\n\t\twdev_lock(wdev);\n\t\tBUILD_BUG_ON(IEEE80211_MAX_SSID_LEN !=\n\t\t\t     IEEE80211_MAX_MESH_ID_LEN);\n\t\twdev->mesh_id_up_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\t\tmemcpy(wdev->ssid, nla_data(info->attrs[NL80211_ATTR_MESH_ID]),\n\t\t       wdev->mesh_id_up_len);\n\t\twdev_unlock(wdev);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_4ADDR]) {\n\t\tparams.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);\n\t\tchange = true;\n\t\terr = nl80211_valid_4addr(rdev, dev, params.use_4addr, ntype);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tparams.use_4addr = -1;\n\t}\n\n\terr = nl80211_parse_mon_options(rdev, ntype, info, &params);\n\tif (err < 0)\n\t\treturn err;\n\tif (err > 0)\n\t\tchange = true;\n\n\tif (change)\n\t\terr = cfg80211_change_iface(rdev, dev, ntype, &params);\n\telse\n\t\terr = 0;\n\n\tif (!err && params.use_4addr != -1)\n\t\tdev->ieee80211_ptr->use_4addr = params.use_4addr;\n\n\tif (change && !err) {\n\t\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t\tnl80211_notify_iface(rdev, wdev, NL80211_CMD_SET_INTERFACE);\n\t}\n\n\treturn err;\n}\n\nstatic int nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct vif_params params;\n\tstruct wireless_dev *wdev;\n\tstruct sk_buff *msg;\n\tint err;\n\tenum nl80211_iftype type = NL80211_IFTYPE_UNSPECIFIED;\n\n\t/* to avoid failing a new interface creation due to pending removal */\n\tcfg80211_destroy_ifaces(rdev);\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!info->attrs[NL80211_ATTR_IFNAME])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IFTYPE])\n\t\ttype = nla_get_u32(info->attrs[NL80211_ATTR_IFTYPE]);\n\n\tif (!rdev->ops->add_virtual_intf)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((type == NL80211_IFTYPE_P2P_DEVICE || type == NL80211_IFTYPE_NAN ||\n\t     rdev->wiphy.features & NL80211_FEATURE_MAC_ON_CREATE) &&\n\t    info->attrs[NL80211_ATTR_MAC]) {\n\t\tnla_memcpy(params.macaddr, info->attrs[NL80211_ATTR_MAC],\n\t\t\t   ETH_ALEN);\n\t\tif (!is_valid_ether_addr(params.macaddr))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_4ADDR]) {\n\t\tparams.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);\n\t\terr = nl80211_valid_4addr(rdev, NULL, params.use_4addr, type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!cfg80211_iftype_allowed(&rdev->wiphy, type, params.use_4addr, 0))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_mon_options(rdev, type, info, &params);\n\tif (err < 0)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\twdev = rdev_add_virtual_intf(rdev,\n\t\t\t\tnla_data(info->attrs[NL80211_ATTR_IFNAME]),\n\t\t\t\tNET_NAME_USER, type, &params);\n\tif (WARN_ON(!wdev)) {\n\t\tnlmsg_free(msg);\n\t\treturn -EPROTO;\n\t} else if (IS_ERR(wdev)) {\n\t\tnlmsg_free(msg);\n\t\treturn PTR_ERR(wdev);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\twdev->owner_nlportid = info->snd_portid;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!info->attrs[NL80211_ATTR_MESH_ID])\n\t\t\tbreak;\n\t\twdev_lock(wdev);\n\t\tBUILD_BUG_ON(IEEE80211_MAX_SSID_LEN !=\n\t\t\t     IEEE80211_MAX_MESH_ID_LEN);\n\t\twdev->mesh_id_up_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\t\tmemcpy(wdev->ssid, nla_data(info->attrs[NL80211_ATTR_MESH_ID]),\n\t\t       wdev->mesh_id_up_len);\n\t\twdev_unlock(wdev);\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\t/*\n\t\t * P2P Device and NAN do not have a netdev, so don't go\n\t\t * through the netdev notifier and must be added here\n\t\t */\n\t\tcfg80211_init_wdev(wdev);\n\t\tcfg80211_register_wdev(rdev, wdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (nl80211_send_iface(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t       rdev, wdev, NL80211_CMD_NEW_INTERFACE) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl80211_del_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (!rdev->ops->del_virtual_intf)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * We hold RTNL, so this is safe, without RTNL opencount cannot\n\t * reach 0, and thus the rdev cannot be deleted.\n\t *\n\t * We need to do it for the dev_close(), since that will call\n\t * the netdev notifiers, and we need to acquire the mutex there\n\t * but don't know if we get there from here or from some other\n\t * place (e.g. \"ip link set ... down\").\n\t */\n\tmutex_unlock(&rdev->wiphy.mtx);\n\n\t/*\n\t * If we remove a wireless device without a netdev then clear\n\t * user_ptr[1] so that nl80211_post_doit won't dereference it\n\t * to check if it needs to do dev_put(). Otherwise it crashes\n\t * since the wdev has been freed, unlike with a netdev where\n\t * we need the dev_put() for the netdev to really be freed.\n\t */\n\tif (!wdev->netdev)\n\t\tinfo->user_ptr[1] = NULL;\n\telse\n\t\tdev_close(wdev->netdev);\n\n\tmutex_lock(&rdev->wiphy.mtx);\n\n\treturn rdev_del_virtual_intf(rdev, wdev);\n}\n\nstatic int nl80211_set_noack_map(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu16 noack_map;\n\n\tif (!info->attrs[NL80211_ATTR_NOACK_MAP])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->set_noack_map)\n\t\treturn -EOPNOTSUPP;\n\n\tnoack_map = nla_get_u16(info->attrs[NL80211_ATTR_NOACK_MAP]);\n\n\treturn rdev_set_noack_map(rdev, dev, noack_map);\n}\n\nstruct get_key_cookie {\n\tstruct sk_buff *msg;\n\tint error;\n\tint idx;\n};\n\nstatic void get_key_callback(void *c, struct key_params *params)\n{\n\tstruct nlattr *key;\n\tstruct get_key_cookie *cookie = c;\n\n\tif ((params->key &&\n\t     nla_put(cookie->msg, NL80211_ATTR_KEY_DATA,\n\t\t     params->key_len, params->key)) ||\n\t    (params->seq &&\n\t     nla_put(cookie->msg, NL80211_ATTR_KEY_SEQ,\n\t\t     params->seq_len, params->seq)) ||\n\t    (params->cipher &&\n\t     nla_put_u32(cookie->msg, NL80211_ATTR_KEY_CIPHER,\n\t\t\t params->cipher)))\n\t\tgoto nla_put_failure;\n\n\tkey = nla_nest_start_noflag(cookie->msg, NL80211_ATTR_KEY);\n\tif (!key)\n\t\tgoto nla_put_failure;\n\n\tif ((params->key &&\n\t     nla_put(cookie->msg, NL80211_KEY_DATA,\n\t\t     params->key_len, params->key)) ||\n\t    (params->seq &&\n\t     nla_put(cookie->msg, NL80211_KEY_SEQ,\n\t\t     params->seq_len, params->seq)) ||\n\t    (params->cipher &&\n\t     nla_put_u32(cookie->msg, NL80211_KEY_CIPHER,\n\t\t\t params->cipher)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(cookie->msg, NL80211_KEY_IDX, cookie->idx))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(cookie->msg, key);\n\n\treturn;\n nla_put_failure:\n\tcookie->error = 1;\n}\n\nstatic int nl80211_get_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 key_idx = 0;\n\tconst u8 *mac_addr = NULL;\n\tbool pairwise;\n\tstruct get_key_cookie cookie = {\n\t\t.error = 0,\n\t};\n\tvoid *hdr;\n\tstruct sk_buff *msg;\n\tbool bigtk_support = false;\n\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_BEACON_PROTECTION))\n\t\tbigtk_support = true;\n\n\tif ((dev->ieee80211_ptr->iftype == NL80211_IFTYPE_STATION ||\n\t     dev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_CLIENT) &&\n\t    wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT))\n\t\tbigtk_support = true;\n\n\tif (info->attrs[NL80211_ATTR_KEY_IDX]) {\n\t\tkey_idx = nla_get_u8(info->attrs[NL80211_ATTR_KEY_IDX]);\n\n\t\tif (key_idx >= 6 && key_idx <= 7 && !bigtk_support) {\n\t\t\tGENL_SET_ERR_MSG(info, \"BIGTK not supported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tpairwise = !!mac_addr;\n\tif (info->attrs[NL80211_ATTR_KEY_TYPE]) {\n\t\tu32 kt = nla_get_u32(info->attrs[NL80211_ATTR_KEY_TYPE]);\n\n\t\tif (kt != NL80211_KEYTYPE_GROUP &&\n\t\t    kt != NL80211_KEYTYPE_PAIRWISE)\n\t\t\treturn -EINVAL;\n\t\tpairwise = kt == NL80211_KEYTYPE_PAIRWISE;\n\t}\n\n\tif (!rdev->ops->get_key)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!pairwise && mac_addr && !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))\n\t\treturn -ENOENT;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_NEW_KEY);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tcookie.msg = msg;\n\tcookie.idx = key_idx;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u8(msg, NL80211_ATTR_KEY_IDX, key_idx))\n\t\tgoto nla_put_failure;\n\tif (mac_addr &&\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr))\n\t\tgoto nla_put_failure;\n\n\terr = rdev_get_key(rdev, dev, key_idx, pairwise, mac_addr, &cookie,\n\t\t\t   get_key_callback);\n\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (cookie.error)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_set_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct key_parse key;\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (key.idx < 0)\n\t\treturn -EINVAL;\n\n\t/* Only support setting default key and\n\t * Extended Key ID action NL80211_KEY_SET_TX.\n\t */\n\tif (!key.def && !key.defmgmt && !key.defbeacon &&\n\t    !(key.p.mode == NL80211_KEY_SET_TX))\n\t\treturn -EINVAL;\n\n\twdev_lock(dev->ieee80211_ptr);\n\n\tif (key.def) {\n\t\tif (!rdev->ops->set_default_key) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev_set_default_key(rdev, dev, key.idx,\n\t\t\t\t\t\t key.def_uni, key.def_multi);\n\n\t\tif (err)\n\t\t\tgoto out;\n\n#ifdef CONFIG_CFG80211_WEXT\n\t\tdev->ieee80211_ptr->wext.default_key = key.idx;\n#endif\n\t} else if (key.defmgmt) {\n\t\tif (key.def_uni || !key.def_multi) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!rdev->ops->set_default_mgmt_key) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev_set_default_mgmt_key(rdev, dev, key.idx);\n\t\tif (err)\n\t\t\tgoto out;\n\n#ifdef CONFIG_CFG80211_WEXT\n\t\tdev->ieee80211_ptr->wext.default_mgmt_key = key.idx;\n#endif\n\t} else if (key.defbeacon) {\n\t\tif (key.def_uni || !key.def_multi) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!rdev->ops->set_default_beacon_key) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev_set_default_beacon_key(rdev, dev, key.idx);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else if (key.p.mode == NL80211_KEY_SET_TX &&\n\t\t   wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t   NL80211_EXT_FEATURE_EXT_KEY_ID)) {\n\t\tu8 *mac_addr = NULL;\n\n\t\tif (info->attrs[NL80211_ATTR_MAC])\n\t\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\t\tif (!mac_addr || key.idx < 0 || key.idx > 1) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = rdev_add_key(rdev, dev, key.idx,\n\t\t\t\t   NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t   mac_addr, &key.p);\n\t} else {\n\t\terr = -EINVAL;\n\t}\n out:\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_new_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct key_parse key;\n\tconst u8 *mac_addr = NULL;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (!key.p.key) {\n\t\tGENL_SET_ERR_MSG(info, \"no key\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (key.type == -1) {\n\t\tif (mac_addr)\n\t\t\tkey.type = NL80211_KEYTYPE_PAIRWISE;\n\t\telse\n\t\t\tkey.type = NL80211_KEYTYPE_GROUP;\n\t}\n\n\t/* for now */\n\tif (key.type != NL80211_KEYTYPE_PAIRWISE &&\n\t    key.type != NL80211_KEYTYPE_GROUP) {\n\t\tGENL_SET_ERR_MSG(info, \"key type not pairwise or group\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (key.type == NL80211_KEYTYPE_GROUP &&\n\t    info->attrs[NL80211_ATTR_VLAN_ID])\n\t\tkey.p.vlan_id = nla_get_u16(info->attrs[NL80211_ATTR_VLAN_ID]);\n\n\tif (!rdev->ops->add_key)\n\t\treturn -EOPNOTSUPP;\n\n\tif (cfg80211_validate_key_settings(rdev, &key.p, key.idx,\n\t\t\t\t\t   key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t\t   mac_addr)) {\n\t\tGENL_SET_ERR_MSG(info, \"key setting validation failed\");\n\t\treturn -EINVAL;\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\tif (err)\n\t\tGENL_SET_ERR_MSG(info, \"key not allowed\");\n\tif (!err) {\n\t\terr = rdev_add_key(rdev, dev, key.idx,\n\t\t\t\t   key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t    mac_addr, &key.p);\n\t\tif (err)\n\t\t\tGENL_SET_ERR_MSG(info, \"key addition failed\");\n\t}\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_del_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *mac_addr = NULL;\n\tstruct key_parse key;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (key.type == -1) {\n\t\tif (mac_addr)\n\t\t\tkey.type = NL80211_KEYTYPE_PAIRWISE;\n\t\telse\n\t\t\tkey.type = NL80211_KEYTYPE_GROUP;\n\t}\n\n\t/* for now */\n\tif (key.type != NL80211_KEYTYPE_PAIRWISE &&\n\t    key.type != NL80211_KEYTYPE_GROUP)\n\t\treturn -EINVAL;\n\n\tif (!cfg80211_valid_key_idx(rdev, key.idx,\n\t\t\t\t    key.type == NL80211_KEYTYPE_PAIRWISE))\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->del_key)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\n\tif (key.type == NL80211_KEYTYPE_GROUP && mac_addr &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))\n\t\terr = -ENOENT;\n\n\tif (!err)\n\t\terr = rdev_del_key(rdev, dev, key.idx,\n\t\t\t\t   key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t   mac_addr);\n\n#ifdef CONFIG_CFG80211_WEXT\n\tif (!err) {\n\t\tif (key.idx == dev->ieee80211_ptr->wext.default_key)\n\t\t\tdev->ieee80211_ptr->wext.default_key = -1;\n\t\telse if (key.idx == dev->ieee80211_ptr->wext.default_mgmt_key)\n\t\t\tdev->ieee80211_ptr->wext.default_mgmt_key = -1;\n\t}\n#endif\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\n/* This function returns an error or the number of nested attributes */\nstatic int validate_acl_mac_addrs(struct nlattr *nl_attr)\n{\n\tstruct nlattr *attr;\n\tint n_entries = 0, tmp;\n\n\tnla_for_each_nested(attr, nl_attr, tmp) {\n\t\tif (nla_len(attr) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\n\t\tn_entries++;\n\t}\n\n\treturn n_entries;\n}\n\n/*\n * This function parses ACL information and allocates memory for ACL data.\n * On successful return, the calling function is responsible to free the\n * ACL buffer returned by this function.\n */\nstatic struct cfg80211_acl_data *parse_acl_data(struct wiphy *wiphy,\n\t\t\t\t\t\tstruct genl_info *info)\n{\n\tenum nl80211_acl_policy acl_policy;\n\tstruct nlattr *attr;\n\tstruct cfg80211_acl_data *acl;\n\tint i = 0, n_entries, tmp;\n\n\tif (!wiphy->max_acl_mac_addrs)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (!info->attrs[NL80211_ATTR_ACL_POLICY])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tacl_policy = nla_get_u32(info->attrs[NL80211_ATTR_ACL_POLICY]);\n\tif (acl_policy != NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED &&\n\t    acl_policy != NL80211_ACL_POLICY_DENY_UNLESS_LISTED)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!info->attrs[NL80211_ATTR_MAC_ADDRS])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tn_entries = validate_acl_mac_addrs(info->attrs[NL80211_ATTR_MAC_ADDRS]);\n\tif (n_entries < 0)\n\t\treturn ERR_PTR(n_entries);\n\n\tif (n_entries > wiphy->max_acl_mac_addrs)\n\t\treturn ERR_PTR(-ENOTSUPP);\n\n\tacl = kzalloc(struct_size(acl, mac_addrs, n_entries), GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_MAC_ADDRS], tmp) {\n\t\tmemcpy(acl->mac_addrs[i].addr, nla_data(attr), ETH_ALEN);\n\t\ti++;\n\t}\n\n\tacl->n_acl_entries = n_entries;\n\tacl->acl_policy = acl_policy;\n\n\treturn acl;\n}\n\nstatic int nl80211_set_mac_acl(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_acl_data *acl;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!dev->ieee80211_ptr->beacon_interval)\n\t\treturn -EINVAL;\n\n\tacl = parse_acl_data(&rdev->wiphy, info);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\n\terr = rdev_set_mac_acl(rdev, dev, acl);\n\n\tkfree(acl);\n\n\treturn err;\n}\n\nstatic u32 rateset_to_mask(struct ieee80211_supported_band *sband,\n\t\t\t   u8 *rates, u8 rates_len)\n{\n\tu8 i;\n\tu32 mask = 0;\n\n\tfor (i = 0; i < rates_len; i++) {\n\t\tint rate = (rates[i] & 0x7f) * 5;\n\t\tint ridx;\n\n\t\tfor (ridx = 0; ridx < sband->n_bitrates; ridx++) {\n\t\t\tstruct ieee80211_rate *srate =\n\t\t\t\t&sband->bitrates[ridx];\n\t\t\tif (rate == srate->bitrate) {\n\t\t\t\tmask |= 1 << ridx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ridx == sband->n_bitrates)\n\t\t\treturn 0; /* rate not found */\n\t}\n\n\treturn mask;\n}\n\nstatic bool ht_rateset_to_mask(struct ieee80211_supported_band *sband,\n\t\t\t       u8 *rates, u8 rates_len,\n\t\t\t       u8 mcs[IEEE80211_HT_MCS_MASK_LEN])\n{\n\tu8 i;\n\n\tmemset(mcs, 0, IEEE80211_HT_MCS_MASK_LEN);\n\n\tfor (i = 0; i < rates_len; i++) {\n\t\tint ridx, rbit;\n\n\t\tridx = rates[i] / 8;\n\t\trbit = BIT(rates[i] % 8);\n\n\t\t/* check validity */\n\t\tif ((ridx < 0) || (ridx >= IEEE80211_HT_MCS_MASK_LEN))\n\t\t\treturn false;\n\n\t\t/* check availability */\n\t\tridx = array_index_nospec(ridx, IEEE80211_HT_MCS_MASK_LEN);\n\t\tif (sband->ht_cap.mcs.rx_mask[ridx] & rbit)\n\t\t\tmcs[ridx] |= rbit;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic u16 vht_mcs_map_to_mcs_mask(u8 vht_mcs_map)\n{\n\tu16 mcs_mask = 0;\n\n\tswitch (vht_mcs_map) {\n\tcase IEEE80211_VHT_MCS_NOT_SUPPORTED:\n\t\tbreak;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_7:\n\t\tmcs_mask = 0x00FF;\n\t\tbreak;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_8:\n\t\tmcs_mask = 0x01FF;\n\t\tbreak;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_9:\n\t\tmcs_mask = 0x03FF;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn mcs_mask;\n}\n\nstatic void vht_build_mcs_mask(u16 vht_mcs_map,\n\t\t\t       u16 vht_mcs_mask[NL80211_VHT_NSS_MAX])\n{\n\tu8 nss;\n\n\tfor (nss = 0; nss < NL80211_VHT_NSS_MAX; nss++) {\n\t\tvht_mcs_mask[nss] = vht_mcs_map_to_mcs_mask(vht_mcs_map & 0x03);\n\t\tvht_mcs_map >>= 2;\n\t}\n}\n\nstatic bool vht_set_mcs_mask(struct ieee80211_supported_band *sband,\n\t\t\t     struct nl80211_txrate_vht *txrate,\n\t\t\t     u16 mcs[NL80211_VHT_NSS_MAX])\n{\n\tu16 tx_mcs_map = le16_to_cpu(sband->vht_cap.vht_mcs.tx_mcs_map);\n\tu16 tx_mcs_mask[NL80211_VHT_NSS_MAX] = {};\n\tu8 i;\n\n\tif (!sband->vht_cap.vht_supported)\n\t\treturn false;\n\n\tmemset(mcs, 0, sizeof(u16) * NL80211_VHT_NSS_MAX);\n\n\t/* Build vht_mcs_mask from VHT capabilities */\n\tvht_build_mcs_mask(tx_mcs_map, tx_mcs_mask);\n\n\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tif ((tx_mcs_mask[i] & txrate->mcs[i]) == txrate->mcs[i])\n\t\t\tmcs[i] = txrate->mcs[i];\n\t\telse\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic u16 he_mcs_map_to_mcs_mask(u8 he_mcs_map)\n{\n\tswitch (he_mcs_map) {\n\tcase IEEE80211_HE_MCS_NOT_SUPPORTED:\n\t\treturn 0;\n\tcase IEEE80211_HE_MCS_SUPPORT_0_7:\n\t\treturn 0x00FF;\n\tcase IEEE80211_HE_MCS_SUPPORT_0_9:\n\t\treturn 0x03FF;\n\tcase IEEE80211_HE_MCS_SUPPORT_0_11:\n\t\treturn 0xFFF;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void he_build_mcs_mask(u16 he_mcs_map,\n\t\t\t      u16 he_mcs_mask[NL80211_HE_NSS_MAX])\n{\n\tu8 nss;\n\n\tfor (nss = 0; nss < NL80211_HE_NSS_MAX; nss++) {\n\t\the_mcs_mask[nss] = he_mcs_map_to_mcs_mask(he_mcs_map & 0x03);\n\t\the_mcs_map >>= 2;\n\t}\n}\n\nstatic u16 he_get_txmcsmap(struct genl_info *info,\n\t\t\t   const struct ieee80211_sta_he_cap *he_cap)\n{\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\t__le16\ttx_mcs;\n\n\tswitch (wdev->chandef.width) {\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\ttx_mcs = he_cap->he_mcs_nss_supp.tx_mcs_80p80;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\ttx_mcs = he_cap->he_mcs_nss_supp.tx_mcs_160;\n\t\tbreak;\n\tdefault:\n\t\ttx_mcs = he_cap->he_mcs_nss_supp.tx_mcs_80;\n\t\tbreak;\n\t}\n\treturn le16_to_cpu(tx_mcs);\n}\n\nstatic bool he_set_mcs_mask(struct genl_info *info,\n\t\t\t    struct wireless_dev *wdev,\n\t\t\t    struct ieee80211_supported_band *sband,\n\t\t\t    struct nl80211_txrate_he *txrate,\n\t\t\t    u16 mcs[NL80211_HE_NSS_MAX])\n{\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tu16 tx_mcs_mask[NL80211_HE_NSS_MAX] = {};\n\tu16 tx_mcs_map = 0;\n\tu8 i;\n\n\the_cap = ieee80211_get_he_iftype_cap(sband, wdev->iftype);\n\tif (!he_cap)\n\t\treturn false;\n\n\tmemset(mcs, 0, sizeof(u16) * NL80211_HE_NSS_MAX);\n\n\ttx_mcs_map = he_get_txmcsmap(info, he_cap);\n\n\t/* Build he_mcs_mask from HE capabilities */\n\the_build_mcs_mask(tx_mcs_map, tx_mcs_mask);\n\n\tfor (i = 0; i < NL80211_HE_NSS_MAX; i++) {\n\t\tif ((tx_mcs_mask[i] & txrate->mcs[i]) == txrate->mcs[i])\n\t\t\tmcs[i] = txrate->mcs[i];\n\t\telse\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int nl80211_parse_tx_bitrate_mask(struct genl_info *info,\n\t\t\t\t\t struct nlattr *attrs[],\n\t\t\t\t\t enum nl80211_attrs attr,\n\t\t\t\t\t struct cfg80211_bitrate_mask *mask,\n\t\t\t\t\t struct net_device *dev,\n\t\t\t\t\t bool default_all_enabled)\n{\n\tstruct nlattr *tb[NL80211_TXRATE_MAX + 1];\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint rem, i;\n\tstruct nlattr *tx_rates;\n\tstruct ieee80211_supported_band *sband;\n\tu16 vht_tx_mcs_map, he_tx_mcs_map;\n\n\tmemset(mask, 0, sizeof(*mask));\n\t/* Default to all rates enabled */\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {\n\t\tconst struct ieee80211_sta_he_cap *he_cap;\n\n\t\tif (!default_all_enabled)\n\t\t\tbreak;\n\n\t\tsband = rdev->wiphy.bands[i];\n\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tmask->control[i].legacy = (1 << sband->n_bitrates) - 1;\n\t\tmemcpy(mask->control[i].ht_mcs,\n\t\t       sband->ht_cap.mcs.rx_mask,\n\t\t       sizeof(mask->control[i].ht_mcs));\n\n\t\tif (!sband->vht_cap.vht_supported)\n\t\t\tcontinue;\n\n\t\tvht_tx_mcs_map = le16_to_cpu(sband->vht_cap.vht_mcs.tx_mcs_map);\n\t\tvht_build_mcs_mask(vht_tx_mcs_map, mask->control[i].vht_mcs);\n\n\t\the_cap = ieee80211_get_he_iftype_cap(sband, wdev->iftype);\n\t\tif (!he_cap)\n\t\t\tcontinue;\n\n\t\the_tx_mcs_map = he_get_txmcsmap(info, he_cap);\n\t\the_build_mcs_mask(he_tx_mcs_map, mask->control[i].he_mcs);\n\n\t\tmask->control[i].he_gi = 0xFF;\n\t\tmask->control[i].he_ltf = 0xFF;\n\t}\n\n\t/* if no rates are given set it back to the defaults */\n\tif (!attrs[attr])\n\t\tgoto out;\n\n\t/* The nested attribute uses enum nl80211_band as the index. This maps\n\t * directly to the enum nl80211_band values used in cfg80211.\n\t */\n\tBUILD_BUG_ON(NL80211_MAX_SUPP_HT_RATES > IEEE80211_HT_MCS_MASK_LEN * 8);\n\tnla_for_each_nested(tx_rates, attrs[attr], rem) {\n\t\tenum nl80211_band band = nla_type(tx_rates);\n\t\tint err;\n\n\t\tif (band < 0 || band >= NUM_NL80211_BANDS)\n\t\t\treturn -EINVAL;\n\t\tsband = rdev->wiphy.bands[band];\n\t\tif (sband == NULL)\n\t\t\treturn -EINVAL;\n\t\terr = nla_parse_nested_deprecated(tb, NL80211_TXRATE_MAX,\n\t\t\t\t\t\t  tx_rates,\n\t\t\t\t\t\t  nl80211_txattr_policy,\n\t\t\t\t\t\t  info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (tb[NL80211_TXRATE_LEGACY]) {\n\t\t\tmask->control[band].legacy = rateset_to_mask(\n\t\t\t\tsband,\n\t\t\t\tnla_data(tb[NL80211_TXRATE_LEGACY]),\n\t\t\t\tnla_len(tb[NL80211_TXRATE_LEGACY]));\n\t\t\tif ((mask->control[band].legacy == 0) &&\n\t\t\t    nla_len(tb[NL80211_TXRATE_LEGACY]))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tb[NL80211_TXRATE_HT]) {\n\t\t\tif (!ht_rateset_to_mask(\n\t\t\t\t\tsband,\n\t\t\t\t\tnla_data(tb[NL80211_TXRATE_HT]),\n\t\t\t\t\tnla_len(tb[NL80211_TXRATE_HT]),\n\t\t\t\t\tmask->control[band].ht_mcs))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (tb[NL80211_TXRATE_VHT]) {\n\t\t\tif (!vht_set_mcs_mask(\n\t\t\t\t\tsband,\n\t\t\t\t\tnla_data(tb[NL80211_TXRATE_VHT]),\n\t\t\t\t\tmask->control[band].vht_mcs))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (tb[NL80211_TXRATE_GI]) {\n\t\t\tmask->control[band].gi =\n\t\t\t\tnla_get_u8(tb[NL80211_TXRATE_GI]);\n\t\t\tif (mask->control[band].gi > NL80211_TXRATE_FORCE_LGI)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tb[NL80211_TXRATE_HE] &&\n\t\t    !he_set_mcs_mask(info, wdev, sband,\n\t\t\t\t     nla_data(tb[NL80211_TXRATE_HE]),\n\t\t\t\t     mask->control[band].he_mcs))\n\t\t\treturn -EINVAL;\n\n\t\tif (tb[NL80211_TXRATE_HE_GI])\n\t\t\tmask->control[band].he_gi =\n\t\t\t\tnla_get_u8(tb[NL80211_TXRATE_HE_GI]);\n\t\tif (tb[NL80211_TXRATE_HE_LTF])\n\t\t\tmask->control[band].he_ltf =\n\t\t\t\tnla_get_u8(tb[NL80211_TXRATE_HE_LTF]);\n\n\t\tif (mask->control[band].legacy == 0) {\n\t\t\t/* don't allow empty legacy rates if HT, VHT or HE\n\t\t\t * are not even supported.\n\t\t\t */\n\t\t\tif (!(rdev->wiphy.bands[band]->ht_cap.ht_supported ||\n\t\t\t      rdev->wiphy.bands[band]->vht_cap.vht_supported ||\n\t\t\t      ieee80211_get_he_iftype_cap(sband, wdev->iftype)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++)\n\t\t\t\tif (mask->control[band].ht_mcs[i])\n\t\t\t\t\tgoto out;\n\n\t\t\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++)\n\t\t\t\tif (mask->control[band].vht_mcs[i])\n\t\t\t\t\tgoto out;\n\n\t\t\tfor (i = 0; i < NL80211_HE_NSS_MAX; i++)\n\t\t\t\tif (mask->control[band].he_mcs[i])\n\t\t\t\t\tgoto out;\n\n\t\t\t/* legacy and mcs rates may not be both empty */\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\nout:\n\treturn 0;\n}\n\nstatic int validate_beacon_tx_rate(struct cfg80211_registered_device *rdev,\n\t\t\t\t   enum nl80211_band band,\n\t\t\t\t   struct cfg80211_bitrate_mask *beacon_rate)\n{\n\tu32 count_ht, count_vht, count_he, i;\n\tu32 rate = beacon_rate->control[band].legacy;\n\n\t/* Allow only one rate */\n\tif (hweight32(rate) > 1)\n\t\treturn -EINVAL;\n\n\tcount_ht = 0;\n\tfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++) {\n\t\tif (hweight8(beacon_rate->control[band].ht_mcs[i]) > 1) {\n\t\t\treturn -EINVAL;\n\t\t} else if (beacon_rate->control[band].ht_mcs[i]) {\n\t\t\tcount_ht++;\n\t\t\tif (count_ht > 1)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (count_ht && rate)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcount_vht = 0;\n\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tif (hweight16(beacon_rate->control[band].vht_mcs[i]) > 1) {\n\t\t\treturn -EINVAL;\n\t\t} else if (beacon_rate->control[band].vht_mcs[i]) {\n\t\t\tcount_vht++;\n\t\t\tif (count_vht > 1)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (count_vht && rate)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcount_he = 0;\n\tfor (i = 0; i < NL80211_HE_NSS_MAX; i++) {\n\t\tif (hweight16(beacon_rate->control[band].he_mcs[i]) > 1) {\n\t\t\treturn -EINVAL;\n\t\t} else if (beacon_rate->control[band].he_mcs[i]) {\n\t\t\tcount_he++;\n\t\t\tif (count_he > 1)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (count_he && rate)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif ((count_ht && count_vht && count_he) ||\n\t    (!rate && !count_ht && !count_vht && !count_he))\n\t\treturn -EINVAL;\n\n\tif (rate &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_LEGACY))\n\t\treturn -EINVAL;\n\tif (count_ht &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_HT))\n\t\treturn -EINVAL;\n\tif (count_vht &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_VHT))\n\t\treturn -EINVAL;\n\tif (count_he &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_HE))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_beacon(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct nlattr *attrs[],\n\t\t\t\tstruct cfg80211_beacon_data *bcn)\n{\n\tbool haveinfo = false;\n\tint err;\n\n\tmemset(bcn, 0, sizeof(*bcn));\n\n\tif (attrs[NL80211_ATTR_BEACON_HEAD]) {\n\t\tbcn->head = nla_data(attrs[NL80211_ATTR_BEACON_HEAD]);\n\t\tbcn->head_len = nla_len(attrs[NL80211_ATTR_BEACON_HEAD]);\n\t\tif (!bcn->head_len)\n\t\t\treturn -EINVAL;\n\t\thaveinfo = true;\n\t}\n\n\tif (attrs[NL80211_ATTR_BEACON_TAIL]) {\n\t\tbcn->tail = nla_data(attrs[NL80211_ATTR_BEACON_TAIL]);\n\t\tbcn->tail_len = nla_len(attrs[NL80211_ATTR_BEACON_TAIL]);\n\t\thaveinfo = true;\n\t}\n\n\tif (!haveinfo)\n\t\treturn -EINVAL;\n\n\tif (attrs[NL80211_ATTR_IE]) {\n\t\tbcn->beacon_ies = nla_data(attrs[NL80211_ATTR_IE]);\n\t\tbcn->beacon_ies_len = nla_len(attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (attrs[NL80211_ATTR_IE_PROBE_RESP]) {\n\t\tbcn->proberesp_ies =\n\t\t\tnla_data(attrs[NL80211_ATTR_IE_PROBE_RESP]);\n\t\tbcn->proberesp_ies_len =\n\t\t\tnla_len(attrs[NL80211_ATTR_IE_PROBE_RESP]);\n\t}\n\n\tif (attrs[NL80211_ATTR_IE_ASSOC_RESP]) {\n\t\tbcn->assocresp_ies =\n\t\t\tnla_data(attrs[NL80211_ATTR_IE_ASSOC_RESP]);\n\t\tbcn->assocresp_ies_len =\n\t\t\tnla_len(attrs[NL80211_ATTR_IE_ASSOC_RESP]);\n\t}\n\n\tif (attrs[NL80211_ATTR_PROBE_RESP]) {\n\t\tbcn->probe_resp = nla_data(attrs[NL80211_ATTR_PROBE_RESP]);\n\t\tbcn->probe_resp_len = nla_len(attrs[NL80211_ATTR_PROBE_RESP]);\n\t}\n\n\tif (attrs[NL80211_ATTR_FTM_RESPONDER]) {\n\t\tstruct nlattr *tb[NL80211_FTM_RESP_ATTR_MAX + 1];\n\n\t\terr = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t  NL80211_FTM_RESP_ATTR_MAX,\n\t\t\t\t\t\t  attrs[NL80211_ATTR_FTM_RESPONDER],\n\t\t\t\t\t\t  NULL, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (tb[NL80211_FTM_RESP_ATTR_ENABLED] &&\n\t\t    wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER))\n\t\t\tbcn->ftm_responder = 1;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (tb[NL80211_FTM_RESP_ATTR_LCI]) {\n\t\t\tbcn->lci = nla_data(tb[NL80211_FTM_RESP_ATTR_LCI]);\n\t\t\tbcn->lci_len = nla_len(tb[NL80211_FTM_RESP_ATTR_LCI]);\n\t\t}\n\n\t\tif (tb[NL80211_FTM_RESP_ATTR_CIVICLOC]) {\n\t\t\tbcn->civicloc = nla_data(tb[NL80211_FTM_RESP_ATTR_CIVICLOC]);\n\t\t\tbcn->civicloc_len = nla_len(tb[NL80211_FTM_RESP_ATTR_CIVICLOC]);\n\t\t}\n\t} else {\n\t\tbcn->ftm_responder = -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_he_obss_pd(struct nlattr *attrs,\n\t\t\t\t    struct ieee80211_he_obss_pd *he_obss_pd)\n{\n\tstruct nlattr *tb[NL80211_HE_OBSS_PD_ATTR_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested(tb, NL80211_HE_OBSS_PD_ATTR_MAX, attrs,\n\t\t\t       he_obss_pd_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_HE_OBSS_PD_ATTR_SR_CTRL])\n\t\treturn -EINVAL;\n\n\the_obss_pd->sr_ctrl = nla_get_u8(tb[NL80211_HE_OBSS_PD_ATTR_SR_CTRL]);\n\n\tif (tb[NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET])\n\t\the_obss_pd->min_offset =\n\t\t\tnla_get_u8(tb[NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET]);\n\tif (tb[NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET])\n\t\the_obss_pd->max_offset =\n\t\t\tnla_get_u8(tb[NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET]);\n\tif (tb[NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET])\n\t\the_obss_pd->non_srg_max_offset =\n\t\t\tnla_get_u8(tb[NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET]);\n\n\tif (he_obss_pd->min_offset > he_obss_pd->max_offset)\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP])\n\t\tmemcpy(he_obss_pd->bss_color_bitmap,\n\t\t       nla_data(tb[NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP]),\n\t\t       sizeof(he_obss_pd->bss_color_bitmap));\n\n\tif (tb[NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP])\n\t\tmemcpy(he_obss_pd->partial_bssid_bitmap,\n\t\t       nla_data(tb[NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP]),\n\t\t       sizeof(he_obss_pd->partial_bssid_bitmap));\n\n\the_obss_pd->enable = true;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_he_bss_color(struct nlattr *attrs,\n\t\t\t\t      struct cfg80211_he_bss_color *he_bss_color)\n{\n\tstruct nlattr *tb[NL80211_HE_BSS_COLOR_ATTR_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested(tb, NL80211_HE_BSS_COLOR_ATTR_MAX, attrs,\n\t\t\t       he_bss_color_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_HE_BSS_COLOR_ATTR_COLOR])\n\t\treturn -EINVAL;\n\n\the_bss_color->color =\n\t\tnla_get_u8(tb[NL80211_HE_BSS_COLOR_ATTR_COLOR]);\n\the_bss_color->enabled =\n\t\t!nla_get_flag(tb[NL80211_HE_BSS_COLOR_ATTR_DISABLED]);\n\the_bss_color->partial =\n\t\tnla_get_flag(tb[NL80211_HE_BSS_COLOR_ATTR_PARTIAL]);\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_fils_discovery(struct cfg80211_registered_device *rdev,\n\t\t\t\t\tstruct nlattr *attrs,\n\t\t\t\t\tstruct cfg80211_ap_settings *params)\n{\n\tstruct nlattr *tb[NL80211_FILS_DISCOVERY_ATTR_MAX + 1];\n\tint ret;\n\tstruct cfg80211_fils_discovery *fd = &params->fils_discovery;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_FILS_DISCOVERY))\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested(tb, NL80211_FILS_DISCOVERY_ATTR_MAX, attrs,\n\t\t\t       NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!tb[NL80211_FILS_DISCOVERY_ATTR_INT_MIN] ||\n\t    !tb[NL80211_FILS_DISCOVERY_ATTR_INT_MAX] ||\n\t    !tb[NL80211_FILS_DISCOVERY_ATTR_TMPL])\n\t\treturn -EINVAL;\n\n\tfd->tmpl_len = nla_len(tb[NL80211_FILS_DISCOVERY_ATTR_TMPL]);\n\tfd->tmpl = nla_data(tb[NL80211_FILS_DISCOVERY_ATTR_TMPL]);\n\tfd->min_interval = nla_get_u32(tb[NL80211_FILS_DISCOVERY_ATTR_INT_MIN]);\n\tfd->max_interval = nla_get_u32(tb[NL80211_FILS_DISCOVERY_ATTR_INT_MAX]);\n\n\treturn 0;\n}\n\nstatic int\nnl80211_parse_unsol_bcast_probe_resp(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct nlattr *attrs,\n\t\t\t\t     struct cfg80211_ap_settings *params)\n{\n\tstruct nlattr *tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX + 1];\n\tint ret;\n\tstruct cfg80211_unsol_bcast_probe_resp *presp =\n\t\t\t\t\t&params->unsol_bcast_probe_resp;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP))\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested(tb, NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX,\n\t\t\t       attrs, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT] ||\n\t    !tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL])\n\t\treturn -EINVAL;\n\n\tpresp->tmpl = nla_data(tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL]);\n\tpresp->tmpl_len = nla_len(tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL]);\n\tpresp->interval = nla_get_u32(tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT]);\n\treturn 0;\n}\n\nstatic void nl80211_check_ap_rate_selectors(struct cfg80211_ap_settings *params,\n\t\t\t\t\t    const u8 *rates)\n{\n\tint i;\n\n\tif (!rates)\n\t\treturn;\n\n\tfor (i = 0; i < rates[1]; i++) {\n\t\tif (rates[2 + i] == BSS_MEMBERSHIP_SELECTOR_HT_PHY)\n\t\t\tparams->ht_required = true;\n\t\tif (rates[2 + i] == BSS_MEMBERSHIP_SELECTOR_VHT_PHY)\n\t\t\tparams->vht_required = true;\n\t\tif (rates[2 + i] == BSS_MEMBERSHIP_SELECTOR_HE_PHY)\n\t\t\tparams->he_required = true;\n\t\tif (rates[2 + i] == BSS_MEMBERSHIP_SELECTOR_SAE_H2E)\n\t\t\tparams->sae_h2e_required = true;\n\t}\n}\n\n/*\n * Since the nl80211 API didn't include, from the beginning, attributes about\n * HT/VHT requirements/capabilities, we parse them out of the IEs for the\n * benefit of drivers that rebuild IEs in the firmware.\n */\nstatic void nl80211_calculate_ap_params(struct cfg80211_ap_settings *params)\n{\n\tconst struct cfg80211_beacon_data *bcn = &params->beacon;\n\tsize_t ies_len = bcn->tail_len;\n\tconst u8 *ies = bcn->tail;\n\tconst u8 *rates;\n\tconst u8 *cap;\n\n\trates = cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies, ies_len);\n\tnl80211_check_ap_rate_selectors(params, rates);\n\n\trates = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES, ies, ies_len);\n\tnl80211_check_ap_rate_selectors(params, rates);\n\n\tcap = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies, ies_len);\n\tif (cap && cap[1] >= sizeof(*params->ht_cap))\n\t\tparams->ht_cap = (void *)(cap + 2);\n\tcap = cfg80211_find_ie(WLAN_EID_VHT_CAPABILITY, ies, ies_len);\n\tif (cap && cap[1] >= sizeof(*params->vht_cap))\n\t\tparams->vht_cap = (void *)(cap + 2);\n\tcap = cfg80211_find_ext_ie(WLAN_EID_EXT_HE_CAPABILITY, ies, ies_len);\n\tif (cap && cap[1] >= sizeof(*params->he_cap) + 1)\n\t\tparams->he_cap = (void *)(cap + 3);\n\tcap = cfg80211_find_ext_ie(WLAN_EID_EXT_HE_OPERATION, ies, ies_len);\n\tif (cap && cap[1] >= sizeof(*params->he_oper) + 1)\n\t\tparams->he_oper = (void *)(cap + 3);\n}\n\nstatic bool nl80211_get_ap_channel(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct cfg80211_ap_settings *params)\n{\n\tstruct wireless_dev *wdev;\n\tbool ret = false;\n\n\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\tcontinue;\n\n\t\tif (!wdev->preset_chandef.chan)\n\t\t\tcontinue;\n\n\t\tparams->chandef = wdev->preset_chandef;\n\t\tret = true;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic bool nl80211_valid_auth_type(struct cfg80211_registered_device *rdev,\n\t\t\t\t    enum nl80211_auth_type auth_type,\n\t\t\t\t    enum nl80211_commands cmd)\n{\n\tif (auth_type > NL80211_AUTHTYPE_MAX)\n\t\treturn false;\n\n\tswitch (cmd) {\n\tcase NL80211_CMD_AUTHENTICATE:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_SAE) &&\n\t\t    auth_type == NL80211_AUTHTYPE_SAE)\n\t\t\treturn false;\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_FILS_STA) &&\n\t\t    (auth_type == NL80211_AUTHTYPE_FILS_SK ||\n\t\t     auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t\t     auth_type == NL80211_AUTHTYPE_FILS_PK))\n\t\t\treturn false;\n\t\treturn true;\n\tcase NL80211_CMD_CONNECT:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_SAE) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SAE_OFFLOAD) &&\n\t\t    auth_type == NL80211_AUTHTYPE_SAE)\n\t\t\treturn false;\n\n\t\t/* FILS with SK PFS or PK not supported yet */\n\t\tif (auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_PK)\n\t\t\treturn false;\n\t\tif (!wiphy_ext_feature_isset(\n\t\t\t    &rdev->wiphy,\n\t\t\t    NL80211_EXT_FEATURE_FILS_SK_OFFLOAD) &&\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_SK)\n\t\t\treturn false;\n\t\treturn true;\n\tcase NL80211_CMD_START_AP:\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SAE_OFFLOAD_AP) &&\n\t\t    auth_type == NL80211_AUTHTYPE_SAE)\n\t\t\treturn false;\n\t\t/* FILS not supported yet */\n\t\tif (auth_type == NL80211_AUTHTYPE_FILS_SK ||\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_PK)\n\t\t\treturn false;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int nl80211_start_ap(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_ap_settings params;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->start_ap)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->beacon_interval)\n\t\treturn -EALREADY;\n\n\tmemset(&params, 0, sizeof(params));\n\n\t/* these are required for START_AP */\n\tif (!info->attrs[NL80211_ATTR_BEACON_INTERVAL] ||\n\t    !info->attrs[NL80211_ATTR_DTIM_PERIOD] ||\n\t    !info->attrs[NL80211_ATTR_BEACON_HEAD])\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_beacon(rdev, info->attrs, &params.beacon);\n\tif (err)\n\t\treturn err;\n\n\tparams.beacon_interval =\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\tparams.dtim_period =\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_DTIM_PERIOD]);\n\n\terr = cfg80211_validate_beacon_int(rdev, dev->ieee80211_ptr->iftype,\n\t\t\t\t\t   params.beacon_interval);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * In theory, some of these attributes should be required here\n\t * but since they were not used when the command was originally\n\t * added, keep them optional for old user space programs to let\n\t * them continue to work with drivers that do not need the\n\t * additional information -- drivers must check!\n\t */\n\tif (info->attrs[NL80211_ATTR_SSID]) {\n\t\tparams.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\t\tparams.ssid_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_SSID]);\n\t\tif (params.ssid_len == 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HIDDEN_SSID])\n\t\tparams.hidden_ssid = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_HIDDEN_SSID]);\n\n\tparams.privacy = !!info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tparams.auth_type = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(rdev, params.auth_type,\n\t\t\t\t\t     NL80211_CMD_START_AP))\n\t\t\treturn -EINVAL;\n\t} else\n\t\tparams.auth_type = NL80211_AUTHTYPE_AUTOMATIC;\n\n\terr = nl80211_crypto_settings(rdev, info, &params.crypto,\n\t\t\t\t      NL80211_MAX_NR_CIPHER_SUITES);\n\tif (err)\n\t\treturn err;\n\n\tif (info->attrs[NL80211_ATTR_INACTIVITY_TIMEOUT]) {\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_INACTIVITY_TIMER))\n\t\t\treturn -EOPNOTSUPP;\n\t\tparams.inactivity_timeout = nla_get_u16(\n\t\t\tinfo->attrs[NL80211_ATTR_INACTIVITY_TIMEOUT]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_P2P_CTWINDOW]) {\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\tparams.p2p_ctwindow =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_P2P_CTWINDOW]);\n\t\tif (params.p2p_ctwindow != 0 &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_CTWIN))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_P2P_OPPPS]) {\n\t\tu8 tmp;\n\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\ttmp = nla_get_u8(info->attrs[NL80211_ATTR_P2P_OPPPS]);\n\t\tparams.p2p_opp_ps = tmp;\n\t\tif (params.p2p_opp_ps != 0 &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_OPPPS))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\terr = nl80211_parse_chandef(rdev, info, &params.chandef);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (wdev->preset_chandef.chan) {\n\t\tparams.chandef = wdev->preset_chandef;\n\t} else if (!nl80211_get_ap_channel(rdev, &params))\n\t\treturn -EINVAL;\n\n\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &params.chandef,\n\t\t\t\t\t   wdev->iftype))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_TX_RATES]) {\n\t\terr = nl80211_parse_tx_bitrate_mask(info, info->attrs,\n\t\t\t\t\t\t    NL80211_ATTR_TX_RATES,\n\t\t\t\t\t\t    &params.beacon_rate,\n\t\t\t\t\t\t    dev, false);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = validate_beacon_tx_rate(rdev, params.chandef.chan->band,\n\t\t\t\t\t      &params.beacon_rate);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SMPS_MODE]) {\n\t\tparams.smps_mode =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_SMPS_MODE]);\n\t\tswitch (params.smps_mode) {\n\t\tcase NL80211_SMPS_OFF:\n\t\t\tbreak;\n\t\tcase NL80211_SMPS_STATIC:\n\t\t\tif (!(rdev->wiphy.features &\n\t\t\t      NL80211_FEATURE_STATIC_SMPS))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase NL80211_SMPS_DYNAMIC:\n\t\t\tif (!(rdev->wiphy.features &\n\t\t\t      NL80211_FEATURE_DYNAMIC_SMPS))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tparams.smps_mode = NL80211_SMPS_OFF;\n\t}\n\n\tparams.pbss = nla_get_flag(info->attrs[NL80211_ATTR_PBSS]);\n\tif (params.pbss && !rdev->wiphy.bands[NL80211_BAND_60GHZ])\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_ACL_POLICY]) {\n\t\tparams.acl = parse_acl_data(&rdev->wiphy, info);\n\t\tif (IS_ERR(params.acl))\n\t\t\treturn PTR_ERR(params.acl);\n\t}\n\n\tparams.twt_responder =\n\t\t    nla_get_flag(info->attrs[NL80211_ATTR_TWT_RESPONDER]);\n\n\tif (info->attrs[NL80211_ATTR_HE_OBSS_PD]) {\n\t\terr = nl80211_parse_he_obss_pd(\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_HE_OBSS_PD],\n\t\t\t\t\t&params.he_obss_pd);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HE_BSS_COLOR]) {\n\t\terr = nl80211_parse_he_bss_color(\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_HE_BSS_COLOR],\n\t\t\t\t\t&params.he_bss_color);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_FILS_DISCOVERY]) {\n\t\terr = nl80211_parse_fils_discovery(rdev,\n\t\t\t\t\t\t   info->attrs[NL80211_ATTR_FILS_DISCOVERY],\n\t\t\t\t\t\t   &params);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_UNSOL_BCAST_PROBE_RESP]) {\n\t\terr = nl80211_parse_unsol_bcast_probe_resp(\n\t\t\trdev, info->attrs[NL80211_ATTR_UNSOL_BCAST_PROBE_RESP],\n\t\t\t&params);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnl80211_calculate_ap_params(&params);\n\n\tif (info->attrs[NL80211_ATTR_EXTERNAL_AUTH_SUPPORT])\n\t\tparams.flags |= AP_SETTINGS_EXTERNAL_AUTH_SUPPORT;\n\n\twdev_lock(wdev);\n\terr = rdev_start_ap(rdev, dev, &params);\n\tif (!err) {\n\t\twdev->preset_chandef = params.chandef;\n\t\twdev->beacon_interval = params.beacon_interval;\n\t\twdev->chandef = params.chandef;\n\t\twdev->ssid_len = params.ssid_len;\n\t\tmemcpy(wdev->ssid, params.ssid, wdev->ssid_len);\n\n\t\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\t\twdev->conn_owner_nlportid = info->snd_portid;\n\t}\n\twdev_unlock(wdev);\n\nout:\n\tkfree(params.acl);\n\n\treturn err;\n}\n\nstatic int nl80211_set_beacon(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_beacon_data params;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->change_beacon)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev->beacon_interval)\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_beacon(rdev, info->attrs, &params);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\terr = rdev_change_beacon(rdev, dev, &params);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_stop_ap(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\treturn cfg80211_stop_ap(rdev, dev, false);\n}\n\nstatic const struct nla_policy sta_flags_policy[NL80211_STA_FLAG_MAX + 1] = {\n\t[NL80211_STA_FLAG_AUTHORIZED] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_SHORT_PREAMBLE] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_WME] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_MFP] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_AUTHENTICATED] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_TDLS_PEER] = { .type = NLA_FLAG },\n};\n\nstatic int parse_station_flags(struct genl_info *info,\n\t\t\t       enum nl80211_iftype iftype,\n\t\t\t       struct station_parameters *params)\n{\n\tstruct nlattr *flags[NL80211_STA_FLAG_MAX + 1];\n\tstruct nlattr *nla;\n\tint flag;\n\n\t/*\n\t * Try parsing the new attribute first so userspace\n\t * can specify both for older kernels.\n\t */\n\tnla = info->attrs[NL80211_ATTR_STA_FLAGS2];\n\tif (nla) {\n\t\tstruct nl80211_sta_flag_update *sta_flags;\n\n\t\tsta_flags = nla_data(nla);\n\t\tparams->sta_flags_mask = sta_flags->mask;\n\t\tparams->sta_flags_set = sta_flags->set;\n\t\tparams->sta_flags_set &= params->sta_flags_mask;\n\t\tif ((params->sta_flags_mask |\n\t\t     params->sta_flags_set) & BIT(__NL80211_STA_FLAG_INVALID))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t/* if present, parse the old attribute */\n\n\tnla = info->attrs[NL80211_ATTR_STA_FLAGS];\n\tif (!nla)\n\t\treturn 0;\n\n\tif (nla_parse_nested_deprecated(flags, NL80211_STA_FLAG_MAX, nla, sta_flags_policy, info->extack))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Only allow certain flags for interface types so that\n\t * other attributes are silently ignored. Remember that\n\t * this is backward compatibility code with old userspace\n\t * and shouldn't be hit in other cases anyway.\n\t */\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tparams->sta_flags_mask = BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_SHORT_PREAMBLE) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_WME) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_MFP);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\t\tparams->sta_flags_mask = BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_TDLS_PEER);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tparams->sta_flags_mask = BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_MFP) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_AUTHORIZED);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (flag = 1; flag <= NL80211_STA_FLAG_MAX; flag++) {\n\t\tif (flags[flag]) {\n\t\t\tparams->sta_flags_set |= (1<<flag);\n\n\t\t\t/* no longer support new API additions in old API */\n\t\t\tif (flag > NL80211_STA_FLAG_MAX_OLD_API)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nbool nl80211_put_sta_rate(struct sk_buff *msg, struct rate_info *info, int attr)\n{\n\tstruct nlattr *rate;\n\tu32 bitrate;\n\tu16 bitrate_compat;\n\tenum nl80211_rate_info rate_flg;\n\n\trate = nla_nest_start_noflag(msg, attr);\n\tif (!rate)\n\t\treturn false;\n\n\t/* cfg80211_calculate_bitrate will return 0 for mcs >= 32 */\n\tbitrate = cfg80211_calculate_bitrate(info);\n\t/* report 16-bit bitrate only if we can */\n\tbitrate_compat = bitrate < (1UL << 16) ? bitrate : 0;\n\tif (bitrate > 0 &&\n\t    nla_put_u32(msg, NL80211_RATE_INFO_BITRATE32, bitrate))\n\t\treturn false;\n\tif (bitrate_compat > 0 &&\n\t    nla_put_u16(msg, NL80211_RATE_INFO_BITRATE, bitrate_compat))\n\t\treturn false;\n\n\tswitch (info->bw) {\n\tcase RATE_INFO_BW_5:\n\t\trate_flg = NL80211_RATE_INFO_5_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_10:\n\t\trate_flg = NL80211_RATE_INFO_10_MHZ_WIDTH;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tcase RATE_INFO_BW_20:\n\t\trate_flg = 0;\n\t\tbreak;\n\tcase RATE_INFO_BW_40:\n\t\trate_flg = NL80211_RATE_INFO_40_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_80:\n\t\trate_flg = NL80211_RATE_INFO_80_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_160:\n\t\trate_flg = NL80211_RATE_INFO_160_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_HE_RU:\n\t\trate_flg = 0;\n\t\tWARN_ON(!(info->flags & RATE_INFO_FLAGS_HE_MCS));\n\t}\n\n\tif (rate_flg && nla_put_flag(msg, rate_flg))\n\t\treturn false;\n\n\tif (info->flags & RATE_INFO_FLAGS_MCS) {\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_MCS, info->mcs))\n\t\t\treturn false;\n\t\tif (info->flags & RATE_INFO_FLAGS_SHORT_GI &&\n\t\t    nla_put_flag(msg, NL80211_RATE_INFO_SHORT_GI))\n\t\t\treturn false;\n\t} else if (info->flags & RATE_INFO_FLAGS_VHT_MCS) {\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_VHT_MCS, info->mcs))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_VHT_NSS, info->nss))\n\t\t\treturn false;\n\t\tif (info->flags & RATE_INFO_FLAGS_SHORT_GI &&\n\t\t    nla_put_flag(msg, NL80211_RATE_INFO_SHORT_GI))\n\t\t\treturn false;\n\t} else if (info->flags & RATE_INFO_FLAGS_HE_MCS) {\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_MCS, info->mcs))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_NSS, info->nss))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_GI, info->he_gi))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_DCM, info->he_dcm))\n\t\t\treturn false;\n\t\tif (info->bw == RATE_INFO_BW_HE_RU &&\n\t\t    nla_put_u8(msg, NL80211_RATE_INFO_HE_RU_ALLOC,\n\t\t\t       info->he_ru_alloc))\n\t\t\treturn false;\n\t}\n\n\tnla_nest_end(msg, rate);\n\treturn true;\n}\n\nstatic bool nl80211_put_signal(struct sk_buff *msg, u8 mask, s8 *signal,\n\t\t\t       int id)\n{\n\tvoid *attr;\n\tint i = 0;\n\n\tif (!mask)\n\t\treturn true;\n\n\tattr = nla_nest_start_noflag(msg, id);\n\tif (!attr)\n\t\treturn false;\n\n\tfor (i = 0; i < IEEE80211_MAX_CHAINS; i++) {\n\t\tif (!(mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\tif (nla_put_u8(msg, i, signal[i]))\n\t\t\treturn false;\n\t}\n\n\tnla_nest_end(msg, attr);\n\n\treturn true;\n}\n\nstatic int nl80211_send_station(struct sk_buff *msg, u32 cmd, u32 portid,\n\t\t\t\tu32 seq, int flags,\n\t\t\t\tstruct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tconst u8 *mac_addr, struct station_info *sinfo)\n{\n\tvoid *hdr;\n\tstruct nlattr *sinfoattr, *bss_param;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr) {\n\t\tcfg80211_sinfo_release_content(sinfo);\n\t\treturn -1;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION, sinfo->generation))\n\t\tgoto nla_put_failure;\n\n\tsinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_STA_INFO);\n\tif (!sinfoattr)\n\t\tgoto nla_put_failure;\n\n#define PUT_SINFO(attr, memb, type) do {\t\t\t\t\\\n\tBUILD_BUG_ON(sizeof(type) == sizeof(u64));\t\t\t\\\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_ ## attr) &&\t\\\n\t    nla_put_ ## type(msg, NL80211_STA_INFO_ ## attr,\t\t\\\n\t\t\t     sinfo->memb))\t\t\t\t\\\n\t\tgoto nla_put_failure;\t\t\t\t\t\\\n\t} while (0)\n#define PUT_SINFO_U64(attr, memb) do {\t\t\t\t\t\\\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_ ## attr) &&\t\\\n\t    nla_put_u64_64bit(msg, NL80211_STA_INFO_ ## attr,\t\t\\\n\t\t\t      sinfo->memb, NL80211_STA_INFO_PAD))\t\\\n\t\tgoto nla_put_failure;\t\t\t\t\t\\\n\t} while (0)\n\n\tPUT_SINFO(CONNECTED_TIME, connected_time, u32);\n\tPUT_SINFO(INACTIVE_TIME, inactive_time, u32);\n\tPUT_SINFO_U64(ASSOC_AT_BOOTTIME, assoc_at);\n\n\tif (sinfo->filled & (BIT_ULL(NL80211_STA_INFO_RX_BYTES) |\n\t\t\t     BIT_ULL(NL80211_STA_INFO_RX_BYTES64)) &&\n\t    nla_put_u32(msg, NL80211_STA_INFO_RX_BYTES,\n\t\t\t(u32)sinfo->rx_bytes))\n\t\tgoto nla_put_failure;\n\n\tif (sinfo->filled & (BIT_ULL(NL80211_STA_INFO_TX_BYTES) |\n\t\t\t     BIT_ULL(NL80211_STA_INFO_TX_BYTES64)) &&\n\t    nla_put_u32(msg, NL80211_STA_INFO_TX_BYTES,\n\t\t\t(u32)sinfo->tx_bytes))\n\t\tgoto nla_put_failure;\n\n\tPUT_SINFO_U64(RX_BYTES64, rx_bytes);\n\tPUT_SINFO_U64(TX_BYTES64, tx_bytes);\n\tPUT_SINFO(LLID, llid, u16);\n\tPUT_SINFO(PLID, plid, u16);\n\tPUT_SINFO(PLINK_STATE, plink_state, u8);\n\tPUT_SINFO_U64(RX_DURATION, rx_duration);\n\tPUT_SINFO_U64(TX_DURATION, tx_duration);\n\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\tPUT_SINFO(AIRTIME_WEIGHT, airtime_weight, u16);\n\n\tswitch (rdev->wiphy.signal_type) {\n\tcase CFG80211_SIGNAL_TYPE_MBM:\n\t\tPUT_SINFO(SIGNAL, signal, u8);\n\t\tPUT_SINFO(SIGNAL_AVG, signal_avg, u8);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL)) {\n\t\tif (!nl80211_put_signal(msg, sinfo->chains,\n\t\t\t\t\tsinfo->chain_signal,\n\t\t\t\t\tNL80211_STA_INFO_CHAIN_SIGNAL))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL_AVG)) {\n\t\tif (!nl80211_put_signal(msg, sinfo->chains,\n\t\t\t\t\tsinfo->chain_signal_avg,\n\t\t\t\t\tNL80211_STA_INFO_CHAIN_SIGNAL_AVG))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_TX_BITRATE)) {\n\t\tif (!nl80211_put_sta_rate(msg, &sinfo->txrate,\n\t\t\t\t\t  NL80211_STA_INFO_TX_BITRATE))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_RX_BITRATE)) {\n\t\tif (!nl80211_put_sta_rate(msg, &sinfo->rxrate,\n\t\t\t\t\t  NL80211_STA_INFO_RX_BITRATE))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tPUT_SINFO(RX_PACKETS, rx_packets, u32);\n\tPUT_SINFO(TX_PACKETS, tx_packets, u32);\n\tPUT_SINFO(TX_RETRIES, tx_retries, u32);\n\tPUT_SINFO(TX_FAILED, tx_failed, u32);\n\tPUT_SINFO(EXPECTED_THROUGHPUT, expected_throughput, u32);\n\tPUT_SINFO(AIRTIME_LINK_METRIC, airtime_link_metric, u32);\n\tPUT_SINFO(BEACON_LOSS, beacon_loss_count, u32);\n\tPUT_SINFO(LOCAL_PM, local_pm, u32);\n\tPUT_SINFO(PEER_PM, peer_pm, u32);\n\tPUT_SINFO(NONPEER_PM, nonpeer_pm, u32);\n\tPUT_SINFO(CONNECTED_TO_GATE, connected_to_gate, u8);\n\tPUT_SINFO(CONNECTED_TO_AS, connected_to_as, u8);\n\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_BSS_PARAM)) {\n\t\tbss_param = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t  NL80211_STA_INFO_BSS_PARAM);\n\t\tif (!bss_param)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (((sinfo->bss_param.flags & BSS_PARAM_FLAGS_CTS_PROT) &&\n\t\t     nla_put_flag(msg, NL80211_STA_BSS_PARAM_CTS_PROT)) ||\n\t\t    ((sinfo->bss_param.flags & BSS_PARAM_FLAGS_SHORT_PREAMBLE) &&\n\t\t     nla_put_flag(msg, NL80211_STA_BSS_PARAM_SHORT_PREAMBLE)) ||\n\t\t    ((sinfo->bss_param.flags & BSS_PARAM_FLAGS_SHORT_SLOT_TIME) &&\n\t\t     nla_put_flag(msg, NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME)) ||\n\t\t    nla_put_u8(msg, NL80211_STA_BSS_PARAM_DTIM_PERIOD,\n\t\t\t       sinfo->bss_param.dtim_period) ||\n\t\t    nla_put_u16(msg, NL80211_STA_BSS_PARAM_BEACON_INTERVAL,\n\t\t\t\tsinfo->bss_param.beacon_interval))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, bss_param);\n\t}\n\tif ((sinfo->filled & BIT_ULL(NL80211_STA_INFO_STA_FLAGS)) &&\n\t    nla_put(msg, NL80211_STA_INFO_STA_FLAGS,\n\t\t    sizeof(struct nl80211_sta_flag_update),\n\t\t    &sinfo->sta_flags))\n\t\tgoto nla_put_failure;\n\n\tPUT_SINFO_U64(T_OFFSET, t_offset);\n\tPUT_SINFO_U64(RX_DROP_MISC, rx_dropped_misc);\n\tPUT_SINFO_U64(BEACON_RX, rx_beacon);\n\tPUT_SINFO(BEACON_SIGNAL_AVG, rx_beacon_signal_avg, u8);\n\tPUT_SINFO(RX_MPDUS, rx_mpdu_count, u32);\n\tPUT_SINFO(FCS_ERROR_COUNT, fcs_err_count, u32);\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT)) {\n\t\tPUT_SINFO(ACK_SIGNAL, ack_signal, u8);\n\t\tPUT_SINFO(ACK_SIGNAL_AVG, avg_ack_signal, s8);\n\t}\n\n#undef PUT_SINFO\n#undef PUT_SINFO_U64\n\n\tif (sinfo->pertid) {\n\t\tstruct nlattr *tidsattr;\n\t\tint tid;\n\n\t\ttidsattr = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t NL80211_STA_INFO_TID_STATS);\n\t\tif (!tidsattr)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (tid = 0; tid < IEEE80211_NUM_TIDS + 1; tid++) {\n\t\t\tstruct cfg80211_tid_stats *tidstats;\n\t\t\tstruct nlattr *tidattr;\n\n\t\t\ttidstats = &sinfo->pertid[tid];\n\n\t\t\tif (!tidstats->filled)\n\t\t\t\tcontinue;\n\n\t\t\ttidattr = nla_nest_start_noflag(msg, tid + 1);\n\t\t\tif (!tidattr)\n\t\t\t\tgoto nla_put_failure;\n\n#define PUT_TIDVAL_U64(attr, memb) do {\t\t\t\t\t\\\n\tif (tidstats->filled & BIT(NL80211_TID_STATS_ ## attr) &&\t\\\n\t    nla_put_u64_64bit(msg, NL80211_TID_STATS_ ## attr,\t\t\\\n\t\t\t      tidstats->memb, NL80211_TID_STATS_PAD))\t\\\n\t\tgoto nla_put_failure;\t\t\t\t\t\\\n\t} while (0)\n\n\t\t\tPUT_TIDVAL_U64(RX_MSDU, rx_msdu);\n\t\t\tPUT_TIDVAL_U64(TX_MSDU, tx_msdu);\n\t\t\tPUT_TIDVAL_U64(TX_MSDU_RETRIES, tx_msdu_retries);\n\t\t\tPUT_TIDVAL_U64(TX_MSDU_FAILED, tx_msdu_failed);\n\n#undef PUT_TIDVAL_U64\n\t\t\tif ((tidstats->filled &\n\t\t\t     BIT(NL80211_TID_STATS_TXQ_STATS)) &&\n\t\t\t    !nl80211_put_txq_stats(msg, &tidstats->txq_stats,\n\t\t\t\t\t\t   NL80211_TID_STATS_TXQ_STATS))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(msg, tidattr);\n\t\t}\n\n\t\tnla_nest_end(msg, tidsattr);\n\t}\n\n\tnla_nest_end(msg, sinfoattr);\n\n\tif (sinfo->assoc_req_ies_len &&\n\t    nla_put(msg, NL80211_ATTR_IE, sinfo->assoc_req_ies_len,\n\t\t    sinfo->assoc_req_ies))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_sinfo_release_content(sinfo);\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tcfg80211_sinfo_release_content(sinfo);\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_station(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tstruct station_info sinfo;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tu8 mac_addr[ETH_ALEN];\n\tint sta_idx = cb->args[2];\n\tint err;\n\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (err)\n\t\treturn err;\n\n\tif (!wdev->netdev) {\n\t\terr = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tif (!rdev->ops->dump_station) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\tmemset(&sinfo, 0, sizeof(sinfo));\n\t\terr = rdev_dump_station(rdev, wdev->netdev, sta_idx,\n\t\t\t\t\tmac_addr, &sinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_station(skb, NL80211_CMD_NEW_STATION,\n\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\trdev, wdev->netdev, mac_addr,\n\t\t\t\t&sinfo) < 0)\n\t\t\tgoto out;\n\n\t\tsta_idx++;\n\t}\n\n out:\n\tcb->args[2] = sta_idx;\n\terr = skb->len;\n out_err:\n\tmutex_unlock(&rdev->wiphy.mtx);\n\n\treturn err;\n}\n\nstatic int nl80211_get_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_info sinfo;\n\tstruct sk_buff *msg;\n\tu8 *mac_addr = NULL;\n\tint err;\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_station)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_station(rdev, dev, mac_addr, &sinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tcfg80211_sinfo_release_content(&sinfo);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (nl80211_send_station(msg, NL80211_CMD_NEW_STATION,\n\t\t\t\t info->snd_portid, info->snd_seq, 0,\n\t\t\t\t rdev, dev, mac_addr, &sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nint cfg80211_check_station_change(struct wiphy *wiphy,\n\t\t\t\t  struct station_parameters *params,\n\t\t\t\t  enum cfg80211_station_type statype)\n{\n\tif (params->listen_interval != -1 &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC)\n\t\treturn -EINVAL;\n\n\tif (params->support_p2p_ps != -1 &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC)\n\t\treturn -EINVAL;\n\n\tif (params->aid &&\n\t    !(params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC)\n\t\treturn -EINVAL;\n\n\t/* When you run into this, adjust the code below for the new flag */\n\tBUILD_BUG_ON(NL80211_STA_FLAG_MAX != 7);\n\n\tswitch (statype) {\n\tcase CFG80211_STA_MESH_PEER_KERNEL:\n\tcase CFG80211_STA_MESH_PEER_USER:\n\t\t/*\n\t\t * No ignoring the TDLS flag here -- the userspace mesh\n\t\t * code doesn't have the bug of including TDLS in the\n\t\t * mask everywhere.\n\t\t */\n\t\tif (params->sta_flags_mask &\n\t\t\t\t~(BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_MFP) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_AUTHORIZED)))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_TDLS_PEER_SETUP:\n\tcase CFG80211_STA_TDLS_PEER_ACTIVE:\n\t\tif (!(params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)))\n\t\t\treturn -EINVAL;\n\t\t/* ignore since it can't change */\n\t\tparams->sta_flags_mask &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\t\tbreak;\n\tdefault:\n\t\t/* disallow mesh-specific things */\n\t\tif (params->plink_action != NL80211_PLINK_ACTION_NO_ACTION)\n\t\t\treturn -EINVAL;\n\t\tif (params->local_pm)\n\t\t\treturn -EINVAL;\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_PLINK_STATE)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (statype != CFG80211_STA_TDLS_PEER_SETUP &&\n\t    statype != CFG80211_STA_TDLS_PEER_ACTIVE) {\n\t\t/* TDLS can't be set, ... */\n\t\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER))\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * ... but don't bother the driver with it. This works around\n\t\t * a hostapd/wpa_supplicant issue -- it always includes the\n\t\t * TLDS_PEER flag in the mask even for AP mode.\n\t\t */\n\t\tparams->sta_flags_mask &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\t}\n\n\tif (statype != CFG80211_STA_TDLS_PEER_SETUP &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC) {\n\t\t/* reject other things that can't change */\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_UAPSD)\n\t\t\treturn -EINVAL;\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_CAPABILITY)\n\t\t\treturn -EINVAL;\n\t\tif (params->supported_rates)\n\t\t\treturn -EINVAL;\n\t\tif (params->ext_capab || params->ht_capa || params->vht_capa ||\n\t\t    params->he_capa)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (statype != CFG80211_STA_AP_CLIENT &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC) {\n\t\tif (params->vlan)\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (statype) {\n\tcase CFG80211_STA_AP_MLME_CLIENT:\n\t\t/* Use this only for authorizing/unauthorizing a station */\n\t\tif (!(params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase CFG80211_STA_AP_CLIENT:\n\tcase CFG80211_STA_AP_CLIENT_UNASSOC:\n\t\t/* accept only the listed bits */\n\t\tif (params->sta_flags_mask &\n\t\t\t\t~(BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_ASSOCIATED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_SHORT_PREAMBLE) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_WME) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_MFP)))\n\t\t\treturn -EINVAL;\n\n\t\t/* but authenticated/associated only if driver handles it */\n\t\tif (!(wiphy->features & NL80211_FEATURE_FULL_AP_CLIENT_STATE) &&\n\t\t    params->sta_flags_mask &\n\t\t\t\t(BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t BIT(NL80211_STA_FLAG_ASSOCIATED)))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_IBSS:\n\tcase CFG80211_STA_AP_STA:\n\t\t/* reject any changes other than AUTHORIZED */\n\t\tif (params->sta_flags_mask & ~BIT(NL80211_STA_FLAG_AUTHORIZED))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_TDLS_PEER_SETUP:\n\t\t/* reject any changes other than AUTHORIZED or WME */\n\t\tif (params->sta_flags_mask & ~(BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t\t       BIT(NL80211_STA_FLAG_WME)))\n\t\t\treturn -EINVAL;\n\t\t/* force (at least) rates when authorizing */\n\t\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_AUTHORIZED) &&\n\t\t    !params->supported_rates)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_TDLS_PEER_ACTIVE:\n\t\t/* reject any changes */\n\t\treturn -EINVAL;\n\tcase CFG80211_STA_MESH_PEER_KERNEL:\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_PLINK_STATE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_MESH_PEER_USER:\n\t\tif (params->plink_action != NL80211_PLINK_ACTION_NO_ACTION &&\n\t\t    params->plink_action != NL80211_PLINK_ACTION_BLOCK)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Older kernel versions ignored this attribute entirely, so don't\n\t * reject attempts to update it but mark it as unused instead so the\n\t * driver won't look at the data.\n\t */\n\tif (statype != CFG80211_STA_AP_CLIENT_UNASSOC &&\n\t    statype != CFG80211_STA_TDLS_PEER_SETUP)\n\t\tparams->opmode_notif_used = false;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cfg80211_check_station_change);\n\n/*\n * Get vlan interface making sure it is running and on the right wiphy.\n */\nstatic struct net_device *get_vlan(struct genl_info *info,\n\t\t\t\t   struct cfg80211_registered_device *rdev)\n{\n\tstruct nlattr *vlanattr = info->attrs[NL80211_ATTR_STA_VLAN];\n\tstruct net_device *v;\n\tint ret;\n\n\tif (!vlanattr)\n\t\treturn NULL;\n\n\tv = dev_get_by_index(genl_info_net(info), nla_get_u32(vlanattr));\n\tif (!v)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (!v->ieee80211_ptr || v->ieee80211_ptr->wiphy != &rdev->wiphy) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (v->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&\n\t    v->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    v->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (!netif_running(v)) {\n\t\tret = -ENETDOWN;\n\t\tgoto error;\n\t}\n\n\treturn v;\n error:\n\tdev_put(v);\n\treturn ERR_PTR(ret);\n}\n\nstatic const struct nla_policy\nnl80211_sta_wme_policy[NL80211_STA_WME_MAX + 1] = {\n\t[NL80211_STA_WME_UAPSD_QUEUES] = { .type = NLA_U8 },\n\t[NL80211_STA_WME_MAX_SP] = { .type = NLA_U8 },\n};\n\nstatic int nl80211_parse_sta_wme(struct genl_info *info,\n\t\t\t\t struct station_parameters *params)\n{\n\tstruct nlattr *tb[NL80211_STA_WME_MAX + 1];\n\tstruct nlattr *nla;\n\tint err;\n\n\t/* parse WME attributes if present */\n\tif (!info->attrs[NL80211_ATTR_STA_WME])\n\t\treturn 0;\n\n\tnla = info->attrs[NL80211_ATTR_STA_WME];\n\terr = nla_parse_nested_deprecated(tb, NL80211_STA_WME_MAX, nla,\n\t\t\t\t\t  nl80211_sta_wme_policy,\n\t\t\t\t\t  info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NL80211_STA_WME_UAPSD_QUEUES])\n\t\tparams->uapsd_queues = nla_get_u8(\n\t\t\ttb[NL80211_STA_WME_UAPSD_QUEUES]);\n\tif (params->uapsd_queues & ~IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK)\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_STA_WME_MAX_SP])\n\t\tparams->max_sp = nla_get_u8(tb[NL80211_STA_WME_MAX_SP]);\n\n\tif (params->max_sp & ~IEEE80211_WMM_IE_STA_QOSINFO_SP_MASK)\n\t\treturn -EINVAL;\n\n\tparams->sta_modify_mask |= STATION_PARAM_APPLY_UAPSD;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_sta_channel_info(struct genl_info *info,\n\t\t\t\t      struct station_parameters *params)\n{\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]) {\n\t\tparams->supported_channels =\n\t\t     nla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]);\n\t\tparams->supported_channels_len =\n\t\t     nla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]);\n\t\t/*\n\t\t * Need to include at least one (first channel, number of\n\t\t * channels) tuple for each subband (checked in policy),\n\t\t * and must have proper tuples for the rest of the data as well.\n\t\t */\n\t\tif (params->supported_channels_len % 2)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]) {\n\t\tparams->supported_oper_classes =\n\t\t nla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]);\n\t\tparams->supported_oper_classes_len =\n\t\t  nla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]);\n\t}\n\treturn 0;\n}\n\nstatic int nl80211_set_station_tdls(struct genl_info *info,\n\t\t\t\t    struct station_parameters *params)\n{\n\tint err;\n\t/* Dummy STA entry gets updated once the peer capabilities are known */\n\tif (info->attrs[NL80211_ATTR_PEER_AID])\n\t\tparams->aid = nla_get_u16(info->attrs[NL80211_ATTR_PEER_AID]);\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY])\n\t\tparams->ht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]);\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY])\n\t\tparams->vht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]);\n\tif (info->attrs[NL80211_ATTR_HE_CAPABILITY]) {\n\t\tparams->he_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\t\tparams->he_capa_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\t}\n\n\terr = nl80211_parse_sta_channel_info(info, params);\n\tif (err)\n\t\treturn err;\n\n\treturn nl80211_parse_sta_wme(info, params);\n}\n\nstatic int nl80211_parse_sta_txpower_setting(struct genl_info *info,\n\t\t\t\t\t     struct station_parameters *params)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint idx;\n\n\tif (info->attrs[NL80211_ATTR_STA_TX_POWER_SETTING]) {\n\t\tif (!rdev->ops->set_tx_power ||\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t NL80211_EXT_FEATURE_STA_TX_PWR))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tidx = NL80211_ATTR_STA_TX_POWER_SETTING;\n\t\tparams->txpwr.type = nla_get_u8(info->attrs[idx]);\n\n\t\tif (params->txpwr.type == NL80211_TX_POWER_LIMITED) {\n\t\t\tidx = NL80211_ATTR_STA_TX_POWER;\n\n\t\t\tif (info->attrs[idx])\n\t\t\t\tparams->txpwr.power =\n\t\t\t\t\tnla_get_s16(info->attrs[idx]);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tparams->sta_modify_mask |= STATION_PARAM_APPLY_STA_TXPOWER;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_set_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_parameters params;\n\tu8 *mac_addr;\n\tint err;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!rdev->ops->change_station)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * AID and listen_interval properties can be set only for unassociated\n\t * station. Include these parameters here and will check them in\n\t * cfg80211_check_station_change().\n\t */\n\tif (info->attrs[NL80211_ATTR_STA_AID])\n\t\tparams.aid = nla_get_u16(info->attrs[NL80211_ATTR_STA_AID]);\n\n\tif (info->attrs[NL80211_ATTR_VLAN_ID])\n\t\tparams.vlan_id = nla_get_u16(info->attrs[NL80211_ATTR_VLAN_ID]);\n\n\tif (info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL])\n\t\tparams.listen_interval =\n\t\t     nla_get_u16(info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL]);\n\telse\n\t\tparams.listen_interval = -1;\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS])\n\t\tparams.support_p2p_ps =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS]);\n\telse\n\t\tparams.support_p2p_ps = -1;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]) {\n\t\tparams.supported_rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\t\tparams.supported_rates_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_CAPABILITY]) {\n\t\tparams.capability =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_STA_CAPABILITY]);\n\t\tparams.sta_modify_mask |= STATION_PARAM_APPLY_CAPABILITY;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]) {\n\t\tparams.ext_capab =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t\tparams.ext_capab_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t}\n\n\tif (parse_station_flags(info, dev->ieee80211_ptr->iftype, &params))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_ACTION])\n\t\tparams.plink_action =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_ACTION]);\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_STATE]) {\n\t\tparams.plink_state =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_STATE]);\n\t\tif (info->attrs[NL80211_ATTR_MESH_PEER_AID])\n\t\t\tparams.peer_aid = nla_get_u16(\n\t\t\t\tinfo->attrs[NL80211_ATTR_MESH_PEER_AID]);\n\t\tparams.sta_modify_mask |= STATION_PARAM_APPLY_PLINK_STATE;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_LOCAL_MESH_POWER_MODE])\n\t\tparams.local_pm = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_LOCAL_MESH_POWER_MODE]);\n\n\tif (info->attrs[NL80211_ATTR_OPMODE_NOTIF]) {\n\t\tparams.opmode_notif_used = true;\n\t\tparams.opmode_notif =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_OPMODE_NOTIF]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HE_6GHZ_CAPABILITY])\n\t\tparams.he_6ghz_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_6GHZ_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_AIRTIME_WEIGHT])\n\t\tparams.airtime_weight =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_AIRTIME_WEIGHT]);\n\n\tif (params.airtime_weight &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_sta_txpower_setting(info, &params);\n\tif (err)\n\t\treturn err;\n\n\t/* Include parameters for TDLS peer (will check later) */\n\terr = nl80211_set_station_tdls(info, &params);\n\tif (err)\n\t\treturn err;\n\n\tparams.vlan = get_vlan(info, rdev);\n\tif (IS_ERR(params.vlan))\n\t\treturn PTR_ERR(params.vlan);\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_put_vlan;\n\t}\n\n\t/* driver will call cfg80211_check_station_change() */\n\terr = rdev_change_station(rdev, dev, mac_addr, &params);\n\n out_put_vlan:\n\tif (params.vlan)\n\t\tdev_put(params.vlan);\n\n\treturn err;\n}\n\nstatic int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_parameters params;\n\tu8 *mac_addr = NULL;\n\tu32 auth_assoc = BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t BIT(NL80211_STA_FLAG_ASSOCIATED);\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!rdev->ops->add_station)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_AID] &&\n\t    !info->attrs[NL80211_ATTR_PEER_AID])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tparams.supported_rates =\n\t\tnla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\tparams.supported_rates_len =\n\t\tnla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\tparams.listen_interval =\n\t\tnla_get_u16(info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL]);\n\n\tif (info->attrs[NL80211_ATTR_VLAN_ID])\n\t\tparams.vlan_id = nla_get_u16(info->attrs[NL80211_ATTR_VLAN_ID]);\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS]) {\n\t\tparams.support_p2p_ps =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS]);\n\t} else {\n\t\t/*\n\t\t * if not specified, assume it's supported for P2P GO interface,\n\t\t * and is NOT supported for AP interface\n\t\t */\n\t\tparams.support_p2p_ps =\n\t\t\tdev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_GO;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PEER_AID])\n\t\tparams.aid = nla_get_u16(info->attrs[NL80211_ATTR_PEER_AID]);\n\telse\n\t\tparams.aid = nla_get_u16(info->attrs[NL80211_ATTR_STA_AID]);\n\n\tif (info->attrs[NL80211_ATTR_STA_CAPABILITY]) {\n\t\tparams.capability =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_STA_CAPABILITY]);\n\t\tparams.sta_modify_mask |= STATION_PARAM_APPLY_CAPABILITY;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]) {\n\t\tparams.ext_capab =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t\tparams.ext_capab_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY])\n\t\tparams.ht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY])\n\t\tparams.vht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_HE_CAPABILITY]) {\n\t\tparams.he_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\t\tparams.he_capa_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HE_6GHZ_CAPABILITY])\n\t\tparams.he_6ghz_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_6GHZ_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_OPMODE_NOTIF]) {\n\t\tparams.opmode_notif_used = true;\n\t\tparams.opmode_notif =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_OPMODE_NOTIF]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_ACTION])\n\t\tparams.plink_action =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_ACTION]);\n\n\tif (info->attrs[NL80211_ATTR_AIRTIME_WEIGHT])\n\t\tparams.airtime_weight =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_AIRTIME_WEIGHT]);\n\n\tif (params.airtime_weight &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_sta_txpower_setting(info, &params);\n\tif (err)\n\t\treturn err;\n\n\terr = nl80211_parse_sta_channel_info(info, &params);\n\tif (err)\n\t\treturn err;\n\n\terr = nl80211_parse_sta_wme(info, &params);\n\tif (err)\n\t\treturn err;\n\n\tif (parse_station_flags(info, dev->ieee80211_ptr->iftype, &params))\n\t\treturn -EINVAL;\n\n\t/* HT/VHT requires QoS, but if we don't have that just ignore HT/VHT\n\t * as userspace might just pass through the capabilities from the IEs\n\t * directly, rather than enforcing this restriction and returning an\n\t * error in this case.\n\t */\n\tif (!(params.sta_flags_set & BIT(NL80211_STA_FLAG_WME))) {\n\t\tparams.ht_capa = NULL;\n\t\tparams.vht_capa = NULL;\n\n\t\t/* HE requires WME */\n\t\tif (params.he_capa_len || params.he_6ghz_capa)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure that HT/VHT capabilities are not set for 6 GHz HE STA */\n\tif (params.he_6ghz_capa && (params.ht_capa || params.vht_capa))\n\t\treturn -EINVAL;\n\n\t/* When you run into this, adjust the code below for the new flag */\n\tBUILD_BUG_ON(NL80211_STA_FLAG_MAX != 7);\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\t/* ignore WME attributes if iface/sta is not capable */\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_AP_UAPSD) ||\n\t\t    !(params.sta_flags_set & BIT(NL80211_STA_FLAG_WME)))\n\t\t\tparams.sta_modify_mask &= ~STATION_PARAM_APPLY_UAPSD;\n\n\t\t/* TDLS peers cannot be added */\n\t\tif ((params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) ||\n\t\t    info->attrs[NL80211_ATTR_PEER_AID])\n\t\t\treturn -EINVAL;\n\t\t/* but don't bother the driver with it */\n\t\tparams.sta_flags_mask &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\n\t\t/* allow authenticated/associated only if driver handles it */\n\t\tif (!(rdev->wiphy.features &\n\t\t\t\tNL80211_FEATURE_FULL_AP_CLIENT_STATE) &&\n\t\t    params.sta_flags_mask & auth_assoc)\n\t\t\treturn -EINVAL;\n\n\t\t/* Older userspace, or userspace wanting to be compatible with\n\t\t * !NL80211_FEATURE_FULL_AP_CLIENT_STATE, will not set the auth\n\t\t * and assoc flags in the mask, but assumes the station will be\n\t\t * added as associated anyway since this was the required driver\n\t\t * behaviour before NL80211_FEATURE_FULL_AP_CLIENT_STATE was\n\t\t * introduced.\n\t\t * In order to not bother drivers with this quirk in the API\n\t\t * set the flags in both the mask and set for new stations in\n\t\t * this case.\n\t\t */\n\t\tif (!(params.sta_flags_mask & auth_assoc)) {\n\t\t\tparams.sta_flags_mask |= auth_assoc;\n\t\t\tparams.sta_flags_set |= auth_assoc;\n\t\t}\n\n\t\t/* must be last in here for error handling */\n\t\tparams.vlan = get_vlan(info, rdev);\n\t\tif (IS_ERR(params.vlan))\n\t\t\treturn PTR_ERR(params.vlan);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t/* ignore uAPSD data */\n\t\tparams.sta_modify_mask &= ~STATION_PARAM_APPLY_UAPSD;\n\n\t\t/* associated is disallowed */\n\t\tif (params.sta_flags_mask & BIT(NL80211_STA_FLAG_ASSOCIATED))\n\t\t\treturn -EINVAL;\n\t\t/* TDLS peers cannot be added */\n\t\tif ((params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) ||\n\t\t    info->attrs[NL80211_ATTR_PEER_AID])\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\t/* ignore uAPSD data */\n\t\tparams.sta_modify_mask &= ~STATION_PARAM_APPLY_UAPSD;\n\n\t\t/* these are disallowed */\n\t\tif (params.sta_flags_mask &\n\t\t\t\t(BIT(NL80211_STA_FLAG_ASSOCIATED) |\n\t\t\t\t BIT(NL80211_STA_FLAG_AUTHENTICATED)))\n\t\t\treturn -EINVAL;\n\t\t/* Only TDLS peers can be added */\n\t\tif (!(params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)))\n\t\t\treturn -EINVAL;\n\t\t/* Can only add if TDLS ... */\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS))\n\t\t\treturn -EOPNOTSUPP;\n\t\t/* ... with external setup is supported */\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_TDLS_EXTERNAL_SETUP))\n\t\t\treturn -EOPNOTSUPP;\n\t\t/*\n\t\t * Older wpa_supplicant versions always mark the TDLS peer\n\t\t * as authorized, but it shouldn't yet be.\n\t\t */\n\t\tparams.sta_flags_mask &= ~BIT(NL80211_STA_FLAG_AUTHORIZED);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* be aware of params.vlan when changing code here */\n\n\terr = rdev_add_station(rdev, dev, mac_addr, &params);\n\n\tif (params.vlan)\n\t\tdev_put(params.vlan);\n\treturn err;\n}\n\nstatic int nl80211_del_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_del_parameters params;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tparams.mac = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\t/* always accept these */\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t/* conditionally accept */\n\t\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_DEL_IBSS_STA))\n\t\t\tbreak;\n\t\treturn -EINVAL;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->del_station)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_MGMT_SUBTYPE]) {\n\t\tparams.subtype =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_MGMT_SUBTYPE]);\n\t\tif (params.subtype != IEEE80211_STYPE_DISASSOC >> 4 &&\n\t\t    params.subtype != IEEE80211_STYPE_DEAUTH >> 4)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t/* Default to Deauthentication frame */\n\t\tparams.subtype = IEEE80211_STYPE_DEAUTH >> 4;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_REASON_CODE]) {\n\t\tparams.reason_code =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\t\tif (params.reason_code == 0)\n\t\t\treturn -EINVAL; /* 0 is reserved */\n\t} else {\n\t\t/* Default to reason code 2 */\n\t\tparams.reason_code = WLAN_REASON_PREV_AUTH_NOT_VALID;\n\t}\n\n\treturn rdev_del_station(rdev, dev, &params);\n}\n\nstatic int nl80211_send_mpath(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t\tint flags, struct net_device *dev,\n\t\t\t\tu8 *dst, u8 *next_hop,\n\t\t\t\tstruct mpath_info *pinfo)\n{\n\tvoid *hdr;\n\tstruct nlattr *pinfoattr;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, NL80211_CMD_NEW_MPATH);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, dst) ||\n\t    nla_put(msg, NL80211_ATTR_MPATH_NEXT_HOP, ETH_ALEN, next_hop) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION, pinfo->generation))\n\t\tgoto nla_put_failure;\n\n\tpinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_MPATH_INFO);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\tif ((pinfo->filled & MPATH_INFO_FRAME_QLEN) &&\n\t    nla_put_u32(msg, NL80211_MPATH_INFO_FRAME_QLEN,\n\t\t\tpinfo->frame_qlen))\n\t\tgoto nla_put_failure;\n\tif (((pinfo->filled & MPATH_INFO_SN) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_SN, pinfo->sn)) ||\n\t    ((pinfo->filled & MPATH_INFO_METRIC) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_METRIC,\n\t\t\t pinfo->metric)) ||\n\t    ((pinfo->filled & MPATH_INFO_EXPTIME) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_EXPTIME,\n\t\t\t pinfo->exptime)) ||\n\t    ((pinfo->filled & MPATH_INFO_FLAGS) &&\n\t     nla_put_u8(msg, NL80211_MPATH_INFO_FLAGS,\n\t\t\tpinfo->flags)) ||\n\t    ((pinfo->filled & MPATH_INFO_DISCOVERY_TIMEOUT) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_DISCOVERY_TIMEOUT,\n\t\t\t pinfo->discovery_timeout)) ||\n\t    ((pinfo->filled & MPATH_INFO_DISCOVERY_RETRIES) &&\n\t     nla_put_u8(msg, NL80211_MPATH_INFO_DISCOVERY_RETRIES,\n\t\t\tpinfo->discovery_retries)) ||\n\t    ((pinfo->filled & MPATH_INFO_HOP_COUNT) &&\n\t     nla_put_u8(msg, NL80211_MPATH_INFO_HOP_COUNT,\n\t\t\tpinfo->hop_count)) ||\n\t    ((pinfo->filled & MPATH_INFO_PATH_CHANGE) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_PATH_CHANGE,\n\t\t\t pinfo->path_change_count)))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, pinfoattr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_mpath(struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb)\n{\n\tstruct mpath_info pinfo;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tu8 dst[ETH_ALEN];\n\tu8 next_hop[ETH_ALEN];\n\tint path_idx = cb->args[2];\n\tint err;\n\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (err)\n\t\treturn err;\n\n\tif (!rdev->ops->dump_mpath) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\terr = rdev_dump_mpath(rdev, wdev->netdev, path_idx, dst,\n\t\t\t\t      next_hop, &pinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_mpath(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t       wdev->netdev, dst, next_hop,\n\t\t\t\t       &pinfo) < 0)\n\t\t\tgoto out;\n\n\t\tpath_idx++;\n\t}\n\n out:\n\tcb->args[2] = path_idx;\n\terr = skb->len;\n out_err:\n\tmutex_unlock(&rdev->wiphy.mtx);\n\treturn err;\n}\n\nstatic int nl80211_get_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mpath_info pinfo;\n\tstruct sk_buff *msg;\n\tu8 *dst = NULL;\n\tu8 next_hop[ETH_ALEN];\n\n\tmemset(&pinfo, 0, sizeof(pinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_mpath(rdev, dev, dst, next_hop, &pinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_mpath(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t\t dev, dst, next_hop, &pinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl80211_set_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\tu8 *next_hop = NULL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MPATH_NEXT_HOP])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tnext_hop = nla_data(info->attrs[NL80211_ATTR_MPATH_NEXT_HOP]);\n\n\tif (!rdev->ops->change_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_change_mpath(rdev, dev, dst, next_hop);\n}\n\nstatic int nl80211_new_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\tu8 *next_hop = NULL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MPATH_NEXT_HOP])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tnext_hop = nla_data(info->attrs[NL80211_ATTR_MPATH_NEXT_HOP]);\n\n\tif (!rdev->ops->add_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_add_mpath(rdev, dev, dst, next_hop);\n}\n\nstatic int nl80211_del_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->del_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_del_mpath(rdev, dev, dst);\n}\n\nstatic int nl80211_get_mpp(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mpath_info pinfo;\n\tstruct sk_buff *msg;\n\tu8 *dst = NULL;\n\tu8 mpp[ETH_ALEN];\n\n\tmemset(&pinfo, 0, sizeof(pinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_mpp)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_mpp(rdev, dev, dst, mpp, &pinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_mpath(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t       dev, dst, mpp, &pinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl80211_dump_mpp(struct sk_buff *skb,\n\t\t\t    struct netlink_callback *cb)\n{\n\tstruct mpath_info pinfo;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tu8 dst[ETH_ALEN];\n\tu8 mpp[ETH_ALEN];\n\tint path_idx = cb->args[2];\n\tint err;\n\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (err)\n\t\treturn err;\n\n\tif (!rdev->ops->dump_mpp) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\terr = rdev_dump_mpp(rdev, wdev->netdev, path_idx, dst,\n\t\t\t\t    mpp, &pinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_mpath(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t       wdev->netdev, dst, mpp,\n\t\t\t\t       &pinfo) < 0)\n\t\t\tgoto out;\n\n\t\tpath_idx++;\n\t}\n\n out:\n\tcb->args[2] = path_idx;\n\terr = skb->len;\n out_err:\n\tmutex_unlock(&rdev->wiphy.mtx);\n\treturn err;\n}\n\nstatic int nl80211_set_bss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct bss_parameters params;\n\tint err;\n\n\tmemset(&params, 0, sizeof(params));\n\t/* default to not changing parameters */\n\tparams.use_cts_prot = -1;\n\tparams.use_short_preamble = -1;\n\tparams.use_short_slot_time = -1;\n\tparams.ap_isolate = -1;\n\tparams.ht_opmode = -1;\n\tparams.p2p_ctwindow = -1;\n\tparams.p2p_opp_ps = -1;\n\n\tif (info->attrs[NL80211_ATTR_BSS_CTS_PROT])\n\t\tparams.use_cts_prot =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_CTS_PROT]);\n\tif (info->attrs[NL80211_ATTR_BSS_SHORT_PREAMBLE])\n\t\tparams.use_short_preamble =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_SHORT_PREAMBLE]);\n\tif (info->attrs[NL80211_ATTR_BSS_SHORT_SLOT_TIME])\n\t\tparams.use_short_slot_time =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_SHORT_SLOT_TIME]);\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tparams.basic_rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tparams.basic_rates_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t}\n\tif (info->attrs[NL80211_ATTR_AP_ISOLATE])\n\t\tparams.ap_isolate = !!nla_get_u8(info->attrs[NL80211_ATTR_AP_ISOLATE]);\n\tif (info->attrs[NL80211_ATTR_BSS_HT_OPMODE])\n\t\tparams.ht_opmode =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_BSS_HT_OPMODE]);\n\n\tif (info->attrs[NL80211_ATTR_P2P_CTWINDOW]) {\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\tparams.p2p_ctwindow =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_P2P_CTWINDOW]);\n\t\tif (params.p2p_ctwindow != 0 &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_CTWIN))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_P2P_OPPPS]) {\n\t\tu8 tmp;\n\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\ttmp = nla_get_u8(info->attrs[NL80211_ATTR_P2P_OPPPS]);\n\t\tparams.p2p_opp_ps = tmp;\n\t\tif (params.p2p_opp_ps &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_OPPPS))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->change_bss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\terr = rdev_change_bss(rdev, dev, &params);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_req_set_reg(struct sk_buff *skb, struct genl_info *info)\n{\n\tchar *data = NULL;\n\tbool is_indoor;\n\tenum nl80211_user_reg_hint_type user_reg_hint_type;\n\tu32 owner_nlportid;\n\n\t/*\n\t * You should only get this when cfg80211 hasn't yet initialized\n\t * completely when built-in to the kernel right between the time\n\t * window between nl80211_init() and regulatory_init(), if that is\n\t * even possible.\n\t */\n\tif (unlikely(!rcu_access_pointer(cfg80211_regdomain)))\n\t\treturn -EINPROGRESS;\n\n\tif (info->attrs[NL80211_ATTR_USER_REG_HINT_TYPE])\n\t\tuser_reg_hint_type =\n\t\t  nla_get_u32(info->attrs[NL80211_ATTR_USER_REG_HINT_TYPE]);\n\telse\n\t\tuser_reg_hint_type = NL80211_USER_REG_HINT_USER;\n\n\tswitch (user_reg_hint_type) {\n\tcase NL80211_USER_REG_HINT_USER:\n\tcase NL80211_USER_REG_HINT_CELL_BASE:\n\t\tif (!info->attrs[NL80211_ATTR_REG_ALPHA2])\n\t\t\treturn -EINVAL;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_REG_ALPHA2]);\n\t\treturn regulatory_hint_user(data, user_reg_hint_type);\n\tcase NL80211_USER_REG_HINT_INDOOR:\n\t\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\t\towner_nlportid = info->snd_portid;\n\t\t\tis_indoor = !!info->attrs[NL80211_ATTR_REG_INDOOR];\n\t\t} else {\n\t\t\towner_nlportid = 0;\n\t\t\tis_indoor = true;\n\t\t}\n\n\t\treturn regulatory_hint_indoor(is_indoor, owner_nlportid);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int nl80211_reload_regdb(struct sk_buff *skb, struct genl_info *info)\n{\n\treturn reg_reload_regdb();\n}\n\nstatic int nl80211_get_mesh_config(struct sk_buff *skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct mesh_config cur_params;\n\tint err = 0;\n\tvoid *hdr;\n\tstruct nlattr *pinfoattr;\n\tstruct sk_buff *msg;\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->get_mesh_config)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\t/* If not connected, get default parameters */\n\tif (!wdev->mesh_id_len)\n\t\tmemcpy(&cur_params, &default_mesh_config, sizeof(cur_params));\n\telse\n\t\terr = rdev_get_mesh_config(rdev, dev, &cur_params);\n\twdev_unlock(wdev);\n\n\tif (err)\n\t\treturn err;\n\n\t/* Draw up a netlink message to send back */\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_MESH_CONFIG);\n\tif (!hdr)\n\t\tgoto out;\n\tpinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_MESH_CONFIG);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_RETRY_TIMEOUT,\n\t\t\tcur_params.dot11MeshRetryTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_CONFIRM_TIMEOUT,\n\t\t\tcur_params.dot11MeshConfirmTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HOLDING_TIMEOUT,\n\t\t\tcur_params.dot11MeshHoldingTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_MAX_PEER_LINKS,\n\t\t\tcur_params.dot11MeshMaxPeerLinks) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_MAX_RETRIES,\n\t\t       cur_params.dot11MeshMaxRetries) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_TTL,\n\t\t       cur_params.dot11MeshTTL) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_ELEMENT_TTL,\n\t\t       cur_params.element_ttl) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_AUTO_OPEN_PLINKS,\n\t\t       cur_params.auto_open_plinks) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR,\n\t\t\tcur_params.dot11MeshNbrOffsetMaxNeighbor) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,\n\t\t       cur_params.dot11MeshHWMPmaxPREQretries) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_PATH_REFRESH_TIME,\n\t\t\tcur_params.path_refresh_time) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,\n\t\t\tcur_params.min_discovery_timeout) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,\n\t\t\tcur_params.dot11MeshHWMPactivePathTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPpreqMinInterval) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPperrMinInterval) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,\n\t\t\tcur_params.dot11MeshHWMPnetDiameterTraversalTime) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_HWMP_ROOTMODE,\n\t\t       cur_params.dot11MeshHWMPRootMode) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_RANN_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPRannInterval) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_GATE_ANNOUNCEMENTS,\n\t\t       cur_params.dot11MeshGateAnnouncementProtocol) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_FORWARDING,\n\t\t       cur_params.dot11MeshForwarding) ||\n\t    nla_put_s32(msg, NL80211_MESHCONF_RSSI_THRESHOLD,\n\t\t\tcur_params.rssi_threshold) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_HT_OPMODE,\n\t\t\tcur_params.ht_opmode) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT,\n\t\t\tcur_params.dot11MeshHWMPactivePathToRootTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_ROOT_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMProotInterval) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPconfirmationInterval) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_POWER_MODE,\n\t\t\tcur_params.power_mode) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_AWAKE_WINDOW,\n\t\t\tcur_params.dot11MeshAwakeWindowDuration) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_PLINK_TIMEOUT,\n\t\t\tcur_params.plink_timeout) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_CONNECTED_TO_GATE,\n\t\t       cur_params.dot11MeshConnectedToMeshGate) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_NOLEARN,\n\t\t       cur_params.dot11MeshNolearn) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_CONNECTED_TO_AS,\n\t\t       cur_params.dot11MeshConnectedToAuthServer))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, pinfoattr);\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n out:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic const struct nla_policy\nnl80211_meshconf_params_policy[NL80211_MESHCONF_ATTR_MAX+1] = {\n\t[NL80211_MESHCONF_RETRY_TIMEOUT] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, 255),\n\t[NL80211_MESHCONF_CONFIRM_TIMEOUT] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, 255),\n\t[NL80211_MESHCONF_HOLDING_TIMEOUT] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, 255),\n\t[NL80211_MESHCONF_MAX_PEER_LINKS] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 0, 255),\n\t[NL80211_MESHCONF_MAX_RETRIES] = NLA_POLICY_MAX(NLA_U8, 16),\n\t[NL80211_MESHCONF_TTL] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_MESHCONF_ELEMENT_TTL] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_MESHCONF_AUTO_OPEN_PLINKS] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR] =\n\t\tNLA_POLICY_RANGE(NLA_U32, 1, 255),\n\t[NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES] = { .type = NLA_U8 },\n\t[NL80211_MESHCONF_PATH_REFRESH_TIME] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT] = NLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_ROOTMODE] = NLA_POLICY_MAX(NLA_U8, 4),\n\t[NL80211_MESHCONF_HWMP_RANN_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_GATE_ANNOUNCEMENTS] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_MESHCONF_FORWARDING] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_MESHCONF_RSSI_THRESHOLD] =\n\t\tNLA_POLICY_RANGE(NLA_S32, -255, 0),\n\t[NL80211_MESHCONF_HT_OPMODE] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_HWMP_ROOT_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_POWER_MODE] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_MESH_POWER_ACTIVE,\n\t\t\t\t NL80211_MESH_POWER_MAX),\n\t[NL80211_MESHCONF_AWAKE_WINDOW] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_PLINK_TIMEOUT] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_CONNECTED_TO_GATE] = NLA_POLICY_RANGE(NLA_U8, 0, 1),\n\t[NL80211_MESHCONF_NOLEARN] = NLA_POLICY_RANGE(NLA_U8, 0, 1),\n\t[NL80211_MESHCONF_CONNECTED_TO_AS] = NLA_POLICY_RANGE(NLA_U8, 0, 1),\n};\n\nstatic const struct nla_policy\n\tnl80211_mesh_setup_params_policy[NL80211_MESH_SETUP_ATTR_MAX+1] = {\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_USERSPACE_AUTH] = { .type = NLA_FLAG },\n\t[NL80211_MESH_SETUP_AUTH_PROTOCOL] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_USERSPACE_MPM] = { .type = NLA_FLAG },\n\t[NL80211_MESH_SETUP_IE] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_MESH_SETUP_USERSPACE_AMPE] = { .type = NLA_FLAG },\n};\n\nstatic int nl80211_parse_mesh_config(struct genl_info *info,\n\t\t\t\t     struct mesh_config *cfg,\n\t\t\t\t     u32 *mask_out)\n{\n\tstruct nlattr *tb[NL80211_MESHCONF_ATTR_MAX + 1];\n\tu32 mask = 0;\n\tu16 ht_opmode;\n\n#define FILL_IN_MESH_PARAM_IF_SET(tb, cfg, param, mask, attr, fn)\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (tb[attr]) {\t\t\t\t\t\t\t\\\n\t\tcfg->param = fn(tb[attr]);\t\t\t\t\\\n\t\tmask |= BIT((attr) - 1);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n\tif (!info->attrs[NL80211_ATTR_MESH_CONFIG])\n\t\treturn -EINVAL;\n\tif (nla_parse_nested_deprecated(tb, NL80211_MESHCONF_ATTR_MAX, info->attrs[NL80211_ATTR_MESH_CONFIG], nl80211_meshconf_params_policy, info->extack))\n\t\treturn -EINVAL;\n\n\t/* This makes sure that there aren't more than 32 mesh config\n\t * parameters (otherwise our bitfield scheme would not work.) */\n\tBUILD_BUG_ON(NL80211_MESHCONF_ATTR_MAX > 32);\n\n\t/* Fill in the params struct */\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshRetryTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_RETRY_TIMEOUT, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConfirmTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_CONFIRM_TIMEOUT,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHoldingTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_HOLDING_TIMEOUT,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxPeerLinks, mask,\n\t\t\t\t  NL80211_MESHCONF_MAX_PEER_LINKS,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxRetries, mask,\n\t\t\t\t  NL80211_MESHCONF_MAX_RETRIES, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshTTL, mask,\n\t\t\t\t  NL80211_MESHCONF_TTL, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, element_ttl, mask,\n\t\t\t\t  NL80211_MESHCONF_ELEMENT_TTL, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, auto_open_plinks, mask,\n\t\t\t\t  NL80211_MESHCONF_AUTO_OPEN_PLINKS,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshNbrOffsetMaxNeighbor,\n\t\t\t\t  mask,\n\t\t\t\t  NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR,\n\t\t\t\t  nla_get_u32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPmaxPREQretries, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, path_refresh_time, mask,\n\t\t\t\t  NL80211_MESHCONF_PATH_REFRESH_TIME,\n\t\t\t\t  nla_get_u32);\n\tif (mask & BIT(NL80211_MESHCONF_PATH_REFRESH_TIME) &&\n\t    (cfg->path_refresh_time < 1 || cfg->path_refresh_time > 65535))\n\t\treturn -EINVAL;\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, min_discovery_timeout, mask,\n\t\t\t\t  NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPactivePathTimeout,\n\t\t\t\t  mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,\n\t\t\t\t  nla_get_u32);\n\tif (mask & BIT(NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT) &&\n\t    (cfg->dot11MeshHWMPactivePathTimeout < 1 ||\n\t     cfg->dot11MeshHWMPactivePathTimeout > 65535))\n\t\treturn -EINVAL;\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPpreqMinInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPperrMinInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg,\n\t\t\t\t  dot11MeshHWMPnetDiameterTraversalTime, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPRootMode, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_ROOTMODE, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPRannInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_RANN_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshGateAnnouncementProtocol,\n\t\t\t\t  mask, NL80211_MESHCONF_GATE_ANNOUNCEMENTS,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshForwarding, mask,\n\t\t\t\t  NL80211_MESHCONF_FORWARDING, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, rssi_threshold, mask,\n\t\t\t\t  NL80211_MESHCONF_RSSI_THRESHOLD,\n\t\t\t\t  nla_get_s32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConnectedToMeshGate, mask,\n\t\t\t\t  NL80211_MESHCONF_CONNECTED_TO_GATE,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConnectedToAuthServer, mask,\n\t\t\t\t  NL80211_MESHCONF_CONNECTED_TO_AS,\n\t\t\t\t  nla_get_u8);\n\t/*\n\t * Check HT operation mode based on\n\t * IEEE 802.11-2016 9.4.2.57 HT Operation element.\n\t */\n\tif (tb[NL80211_MESHCONF_HT_OPMODE]) {\n\t\tht_opmode = nla_get_u16(tb[NL80211_MESHCONF_HT_OPMODE]);\n\n\t\tif (ht_opmode & ~(IEEE80211_HT_OP_MODE_PROTECTION |\n\t\t\t\t  IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT |\n\t\t\t\t  IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT))\n\t\t\treturn -EINVAL;\n\n\t\t/* NON_HT_STA bit is reserved, but some programs set it */\n\t\tht_opmode &= ~IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT;\n\n\t\tcfg->ht_opmode = ht_opmode;\n\t\tmask |= (1 << (NL80211_MESHCONF_HT_OPMODE - 1));\n\t}\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg,\n\t\t\t\t  dot11MeshHWMPactivePathToRootTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT,\n\t\t\t\t  nla_get_u32);\n\tif (mask & BIT(NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT) &&\n\t    (cfg->dot11MeshHWMPactivePathToRootTimeout < 1 ||\n\t     cfg->dot11MeshHWMPactivePathToRootTimeout > 65535))\n\t\treturn -EINVAL;\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMProotInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_ROOT_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPconfirmationInterval,\n\t\t\t\t  mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, power_mode, mask,\n\t\t\t\t  NL80211_MESHCONF_POWER_MODE, nla_get_u32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshAwakeWindowDuration, mask,\n\t\t\t\t  NL80211_MESHCONF_AWAKE_WINDOW, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, plink_timeout, mask,\n\t\t\t\t  NL80211_MESHCONF_PLINK_TIMEOUT, nla_get_u32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshNolearn, mask,\n\t\t\t\t  NL80211_MESHCONF_NOLEARN, nla_get_u8);\n\tif (mask_out)\n\t\t*mask_out = mask;\n\n\treturn 0;\n\n#undef FILL_IN_MESH_PARAM_IF_SET\n}\n\nstatic int nl80211_parse_mesh_setup(struct genl_info *info,\n\t\t\t\t     struct mesh_setup *setup)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *tb[NL80211_MESH_SETUP_ATTR_MAX + 1];\n\n\tif (!info->attrs[NL80211_ATTR_MESH_SETUP])\n\t\treturn -EINVAL;\n\tif (nla_parse_nested_deprecated(tb, NL80211_MESH_SETUP_ATTR_MAX, info->attrs[NL80211_ATTR_MESH_SETUP], nl80211_mesh_setup_params_policy, info->extack))\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC])\n\t\tsetup->sync_method =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC])) ?\n\t\t IEEE80211_SYNC_METHOD_VENDOR :\n\t\t IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL])\n\t\tsetup->path_sel_proto =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL])) ?\n\t\t IEEE80211_PATH_PROTOCOL_VENDOR :\n\t\t IEEE80211_PATH_PROTOCOL_HWMP;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC])\n\t\tsetup->path_metric =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC])) ?\n\t\t IEEE80211_PATH_METRIC_VENDOR :\n\t\t IEEE80211_PATH_METRIC_AIRTIME;\n\n\tif (tb[NL80211_MESH_SETUP_IE]) {\n\t\tstruct nlattr *ieattr =\n\t\t\ttb[NL80211_MESH_SETUP_IE];\n\t\tsetup->ie = nla_data(ieattr);\n\t\tsetup->ie_len = nla_len(ieattr);\n\t}\n\tif (tb[NL80211_MESH_SETUP_USERSPACE_MPM] &&\n\t    !(rdev->wiphy.features & NL80211_FEATURE_USERSPACE_MPM))\n\t\treturn -EINVAL;\n\tsetup->user_mpm = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_MPM]);\n\tsetup->is_authenticated = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_AUTH]);\n\tsetup->is_secure = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_AMPE]);\n\tif (setup->is_secure)\n\t\tsetup->user_mpm = true;\n\n\tif (tb[NL80211_MESH_SETUP_AUTH_PROTOCOL]) {\n\t\tif (!setup->user_mpm)\n\t\t\treturn -EINVAL;\n\t\tsetup->auth_id =\n\t\t\tnla_get_u8(tb[NL80211_MESH_SETUP_AUTH_PROTOCOL]);\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_update_mesh_config(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct mesh_config cfg;\n\tu32 mask;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->update_mesh_config)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_mesh_config(info, &cfg, &mask);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\tif (!wdev->mesh_id_len)\n\t\terr = -ENOLINK;\n\n\tif (!err)\n\t\terr = rdev_update_mesh_config(rdev, dev, mask, &cfg);\n\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_put_regdom(const struct ieee80211_regdomain *regdom,\n\t\t\t      struct sk_buff *msg)\n{\n\tstruct nlattr *nl_reg_rules;\n\tunsigned int i;\n\n\tif (nla_put_string(msg, NL80211_ATTR_REG_ALPHA2, regdom->alpha2) ||\n\t    (regdom->dfs_region &&\n\t     nla_put_u8(msg, NL80211_ATTR_DFS_REGION, regdom->dfs_region)))\n\t\tgoto nla_put_failure;\n\n\tnl_reg_rules = nla_nest_start_noflag(msg, NL80211_ATTR_REG_RULES);\n\tif (!nl_reg_rules)\n\t\tgoto nla_put_failure;\n\n\tfor (i = 0; i < regdom->n_reg_rules; i++) {\n\t\tstruct nlattr *nl_reg_rule;\n\t\tconst struct ieee80211_reg_rule *reg_rule;\n\t\tconst struct ieee80211_freq_range *freq_range;\n\t\tconst struct ieee80211_power_rule *power_rule;\n\t\tunsigned int max_bandwidth_khz;\n\n\t\treg_rule = &regdom->reg_rules[i];\n\t\tfreq_range = &reg_rule->freq_range;\n\t\tpower_rule = &reg_rule->power_rule;\n\n\t\tnl_reg_rule = nla_nest_start_noflag(msg, i);\n\t\tif (!nl_reg_rule)\n\t\t\tgoto nla_put_failure;\n\n\t\tmax_bandwidth_khz = freq_range->max_bandwidth_khz;\n\t\tif (!max_bandwidth_khz)\n\t\t\tmax_bandwidth_khz = reg_get_max_bandwidth(regdom,\n\t\t\t\t\t\t\t\t  reg_rule);\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_REG_RULE_FLAGS,\n\t\t\t\treg_rule->flags) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_START,\n\t\t\t\tfreq_range->start_freq_khz) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_END,\n\t\t\t\tfreq_range->end_freq_khz) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_MAX_BW,\n\t\t\t\tmax_bandwidth_khz) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN,\n\t\t\t\tpower_rule->max_antenna_gain) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_POWER_RULE_MAX_EIRP,\n\t\t\t\tpower_rule->max_eirp) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_DFS_CAC_TIME,\n\t\t\t\treg_rule->dfs_cac_ms))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_reg_rule);\n\t}\n\n\tnla_nest_end(msg, nl_reg_rules);\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_get_reg_do(struct sk_buff *skb, struct genl_info *info)\n{\n\tconst struct ieee80211_regdomain *regdom = NULL;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wiphy *wiphy = NULL;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOBUFS;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_REG);\n\tif (!hdr)\n\t\tgoto put_failure;\n\n\trtnl_lock();\n\n\tif (info->attrs[NL80211_ATTR_WIPHY]) {\n\t\tbool self_managed;\n\n\t\trdev = cfg80211_get_dev_from_info(genl_info_net(info), info);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tnlmsg_free(msg);\n\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\n\t\twiphy = &rdev->wiphy;\n\t\tself_managed = wiphy->regulatory_flags &\n\t\t\t       REGULATORY_WIPHY_SELF_MANAGED;\n\t\tregdom = get_wiphy_regdom(wiphy);\n\n\t\t/* a self-managed-reg device must have a private regdom */\n\t\tif (WARN_ON(!regdom && self_managed)) {\n\t\t\tnlmsg_free(msg);\n\t\t\trtnl_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (regdom &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy)))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (!wiphy && reg_last_request_cell_base() &&\n\t    nla_put_u32(msg, NL80211_ATTR_USER_REG_HINT_TYPE,\n\t\t\tNL80211_USER_REG_HINT_CELL_BASE))\n\t\tgoto nla_put_failure;\n\n\trcu_read_lock();\n\n\tif (!regdom)\n\t\tregdom = rcu_dereference(cfg80211_regdomain);\n\n\tif (nl80211_put_regdom(regdom, msg))\n\t\tgoto nla_put_failure_rcu;\n\n\trcu_read_unlock();\n\n\tgenlmsg_end(msg, hdr);\n\trtnl_unlock();\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure_rcu:\n\trcu_read_unlock();\nnla_put_failure:\n\trtnl_unlock();\nput_failure:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_send_regdom(struct sk_buff *msg, struct netlink_callback *cb,\n\t\t\t       u32 seq, int flags, struct wiphy *wiphy,\n\t\t\t       const struct ieee80211_regdomain *regdom)\n{\n\tvoid *hdr = nl80211hdr_put(msg, NETLINK_CB(cb->skb).portid, seq, flags,\n\t\t\t\t   NL80211_CMD_GET_REG);\n\n\tif (!hdr)\n\t\treturn -1;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nl80211_put_regdom(regdom, msg))\n\t\tgoto nla_put_failure;\n\n\tif (!wiphy && reg_last_request_cell_base() &&\n\t    nla_put_u32(msg, NL80211_ATTR_USER_REG_HINT_TYPE,\n\t\t\tNL80211_USER_REG_HINT_CELL_BASE))\n\t\tgoto nla_put_failure;\n\n\tif (wiphy &&\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy)))\n\t\tgoto nla_put_failure;\n\n\tif (wiphy && wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&\n\t    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_get_reg_dump(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tconst struct ieee80211_regdomain *regdom = NULL;\n\tstruct cfg80211_registered_device *rdev;\n\tint err, reg_idx, start = cb->args[2];\n\n\trtnl_lock();\n\n\tif (cfg80211_regdomain && start == 0) {\n\t\terr = nl80211_send_regdom(skb, cb, cb->nlh->nlmsg_seq,\n\t\t\t\t\t  NLM_F_MULTI, NULL,\n\t\t\t\t\t  rtnl_dereference(cfg80211_regdomain));\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t}\n\n\t/* the global regdom is idx 0 */\n\treg_idx = 1;\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tregdom = get_wiphy_regdom(&rdev->wiphy);\n\t\tif (!regdom)\n\t\t\tcontinue;\n\n\t\tif (++reg_idx <= start)\n\t\t\tcontinue;\n\n\t\terr = nl80211_send_regdom(skb, cb, cb->nlh->nlmsg_seq,\n\t\t\t\t\t  NLM_F_MULTI, &rdev->wiphy, regdom);\n\t\tif (err < 0) {\n\t\t\treg_idx--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcb->args[2] = reg_idx;\n\terr = skb->len;\nout_err:\n\trtnl_unlock();\n\treturn err;\n}\n\n#ifdef CONFIG_CFG80211_CRDA_SUPPORT\nstatic const struct nla_policy reg_rule_policy[NL80211_REG_RULE_ATTR_MAX + 1] = {\n\t[NL80211_ATTR_REG_RULE_FLAGS]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_START]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_END]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_MAX_BW]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_POWER_RULE_MAX_EIRP]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_DFS_CAC_TIME]\t\t= { .type = NLA_U32 },\n};\n\nstatic int parse_reg_rule(struct nlattr *tb[],\n\tstruct ieee80211_reg_rule *reg_rule)\n{\n\tstruct ieee80211_freq_range *freq_range = &reg_rule->freq_range;\n\tstruct ieee80211_power_rule *power_rule = &reg_rule->power_rule;\n\n\tif (!tb[NL80211_ATTR_REG_RULE_FLAGS])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_START])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_END])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_MAX_BW])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_POWER_RULE_MAX_EIRP])\n\t\treturn -EINVAL;\n\n\treg_rule->flags = nla_get_u32(tb[NL80211_ATTR_REG_RULE_FLAGS]);\n\n\tfreq_range->start_freq_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_START]);\n\tfreq_range->end_freq_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_END]);\n\tfreq_range->max_bandwidth_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_MAX_BW]);\n\n\tpower_rule->max_eirp =\n\t\tnla_get_u32(tb[NL80211_ATTR_POWER_RULE_MAX_EIRP]);\n\n\tif (tb[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN])\n\t\tpower_rule->max_antenna_gain =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN]);\n\n\tif (tb[NL80211_ATTR_DFS_CAC_TIME])\n\t\treg_rule->dfs_cac_ms =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_DFS_CAC_TIME]);\n\n\treturn 0;\n}\n\nstatic int nl80211_set_reg(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *tb[NL80211_REG_RULE_ATTR_MAX + 1];\n\tstruct nlattr *nl_reg_rule;\n\tchar *alpha2;\n\tint rem_reg_rules, r;\n\tu32 num_rules = 0, rule_idx = 0;\n\tenum nl80211_dfs_regions dfs_region = NL80211_DFS_UNSET;\n\tstruct ieee80211_regdomain *rd;\n\n\tif (!info->attrs[NL80211_ATTR_REG_ALPHA2])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REG_RULES])\n\t\treturn -EINVAL;\n\n\talpha2 = nla_data(info->attrs[NL80211_ATTR_REG_ALPHA2]);\n\n\tif (info->attrs[NL80211_ATTR_DFS_REGION])\n\t\tdfs_region = nla_get_u8(info->attrs[NL80211_ATTR_DFS_REGION]);\n\n\tnla_for_each_nested(nl_reg_rule, info->attrs[NL80211_ATTR_REG_RULES],\n\t\t\t    rem_reg_rules) {\n\t\tnum_rules++;\n\t\tif (num_rules > NL80211_MAX_SUPP_REG_RULES)\n\t\t\treturn -EINVAL;\n\t}\n\n\trtnl_lock();\n\tif (!reg_is_valid_request(alpha2)) {\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trd = kzalloc(struct_size(rd, reg_rules, num_rules), GFP_KERNEL);\n\tif (!rd) {\n\t\tr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trd->n_reg_rules = num_rules;\n\trd->alpha2[0] = alpha2[0];\n\trd->alpha2[1] = alpha2[1];\n\n\t/*\n\t * Disable DFS master mode if the DFS region was\n\t * not supported or known on this kernel.\n\t */\n\tif (reg_supported_dfs_region(dfs_region))\n\t\trd->dfs_region = dfs_region;\n\n\tnla_for_each_nested(nl_reg_rule, info->attrs[NL80211_ATTR_REG_RULES],\n\t\t\t    rem_reg_rules) {\n\t\tr = nla_parse_nested_deprecated(tb, NL80211_REG_RULE_ATTR_MAX,\n\t\t\t\t\t\tnl_reg_rule, reg_rule_policy,\n\t\t\t\t\t\tinfo->extack);\n\t\tif (r)\n\t\t\tgoto bad_reg;\n\t\tr = parse_reg_rule(tb, &rd->reg_rules[rule_idx]);\n\t\tif (r)\n\t\t\tgoto bad_reg;\n\n\t\trule_idx++;\n\n\t\tif (rule_idx > NL80211_MAX_SUPP_REG_RULES) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto bad_reg;\n\t\t}\n\t}\n\n\tr = set_regdom(rd, REGD_SOURCE_CRDA);\n\t/* set_regdom takes ownership of rd */\n\trd = NULL;\n bad_reg:\n\tkfree(rd);\n out:\n\trtnl_unlock();\n\treturn r;\n}\n#endif /* CONFIG_CFG80211_CRDA_SUPPORT */\n\nstatic int validate_scan_freqs(struct nlattr *freqs)\n{\n\tstruct nlattr *attr1, *attr2;\n\tint n_channels = 0, tmp1, tmp2;\n\n\tnla_for_each_nested(attr1, freqs, tmp1)\n\t\tif (nla_len(attr1) != sizeof(u32))\n\t\t\treturn 0;\n\n\tnla_for_each_nested(attr1, freqs, tmp1) {\n\t\tn_channels++;\n\t\t/*\n\t\t * Some hardware has a limited channel list for\n\t\t * scanning, and it is pretty much nonsensical\n\t\t * to scan for a channel twice, so disallow that\n\t\t * and don't require drivers to check that the\n\t\t * channel list they get isn't longer than what\n\t\t * they can scan, as long as they can scan all\n\t\t * the channels they registered at once.\n\t\t */\n\t\tnla_for_each_nested(attr2, freqs, tmp2)\n\t\t\tif (attr1 != attr2 &&\n\t\t\t    nla_get_u32(attr1) == nla_get_u32(attr2))\n\t\t\t\treturn 0;\n\t}\n\n\treturn n_channels;\n}\n\nstatic bool is_band_valid(struct wiphy *wiphy, enum nl80211_band b)\n{\n\treturn b < NUM_NL80211_BANDS && wiphy->bands[b];\n}\n\nstatic int parse_bss_select(struct nlattr *nla, struct wiphy *wiphy,\n\t\t\t    struct cfg80211_bss_selection *bss_select)\n{\n\tstruct nlattr *attr[NL80211_BSS_SELECT_ATTR_MAX + 1];\n\tstruct nlattr *nest;\n\tint err;\n\tbool found = false;\n\tint i;\n\n\t/* only process one nested attribute */\n\tnest = nla_data(nla);\n\tif (!nla_ok(nest, nla_len(nest)))\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attr, NL80211_BSS_SELECT_ATTR_MAX,\n\t\t\t\t\t  nest, nl80211_bss_select_policy,\n\t\t\t\t\t  NULL);\n\tif (err)\n\t\treturn err;\n\n\t/* only one attribute may be given */\n\tfor (i = 0; i <= NL80211_BSS_SELECT_ATTR_MAX; i++) {\n\t\tif (attr[i]) {\n\t\t\tif (found)\n\t\t\t\treturn -EINVAL;\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tbss_select->behaviour = __NL80211_BSS_SELECT_ATTR_INVALID;\n\n\tif (attr[NL80211_BSS_SELECT_ATTR_RSSI])\n\t\tbss_select->behaviour = NL80211_BSS_SELECT_ATTR_RSSI;\n\n\tif (attr[NL80211_BSS_SELECT_ATTR_BAND_PREF]) {\n\t\tbss_select->behaviour = NL80211_BSS_SELECT_ATTR_BAND_PREF;\n\t\tbss_select->param.band_pref =\n\t\t\tnla_get_u32(attr[NL80211_BSS_SELECT_ATTR_BAND_PREF]);\n\t\tif (!is_band_valid(wiphy, bss_select->param.band_pref))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr[NL80211_BSS_SELECT_ATTR_RSSI_ADJUST]) {\n\t\tstruct nl80211_bss_select_rssi_adjust *adj_param;\n\n\t\tadj_param = nla_data(attr[NL80211_BSS_SELECT_ATTR_RSSI_ADJUST]);\n\t\tbss_select->behaviour = NL80211_BSS_SELECT_ATTR_RSSI_ADJUST;\n\t\tbss_select->param.adjust.band = adj_param->band;\n\t\tbss_select->param.adjust.delta = adj_param->delta;\n\t\tif (!is_band_valid(wiphy, bss_select->param.adjust.band))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* user-space did not provide behaviour attribute */\n\tif (bss_select->behaviour == __NL80211_BSS_SELECT_ATTR_INVALID)\n\t\treturn -EINVAL;\n\n\tif (!(wiphy->bss_select_support & BIT(bss_select->behaviour)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint nl80211_parse_random_mac(struct nlattr **attrs,\n\t\t\t     u8 *mac_addr, u8 *mac_addr_mask)\n{\n\tint i;\n\n\tif (!attrs[NL80211_ATTR_MAC] && !attrs[NL80211_ATTR_MAC_MASK]) {\n\t\teth_zero_addr(mac_addr);\n\t\teth_zero_addr(mac_addr_mask);\n\t\tmac_addr[0] = 0x2;\n\t\tmac_addr_mask[0] = 0x3;\n\n\t\treturn 0;\n\t}\n\n\t/* need both or none */\n\tif (!attrs[NL80211_ATTR_MAC] || !attrs[NL80211_ATTR_MAC_MASK])\n\t\treturn -EINVAL;\n\n\tmemcpy(mac_addr, nla_data(attrs[NL80211_ATTR_MAC]), ETH_ALEN);\n\tmemcpy(mac_addr_mask, nla_data(attrs[NL80211_ATTR_MAC_MASK]), ETH_ALEN);\n\n\t/* don't allow or configure an mcast address */\n\tif (!is_multicast_ether_addr(mac_addr_mask) ||\n\t    is_multicast_ether_addr(mac_addr))\n\t\treturn -EINVAL;\n\n\t/*\n\t * allow users to pass a MAC address that has bits set outside\n\t * of the mask, but don't bother drivers with having to deal\n\t * with such bits\n\t */\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tmac_addr[i] &= mac_addr_mask[i];\n\n\treturn 0;\n}\n\nstatic bool cfg80211_off_channel_oper_allowed(struct wireless_dev *wdev)\n{\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (!cfg80211_beaconing_iface_active(wdev))\n\t\treturn true;\n\n\tif (!(wdev->chandef.chan->flags & IEEE80211_CHAN_RADAR))\n\t\treturn true;\n\n\treturn regulatory_pre_cac_allowed(wdev->wiphy);\n}\n\nstatic bool nl80211_check_scan_feat(struct wiphy *wiphy, u32 flags, u32 flag,\n\t\t\t\t    enum nl80211_ext_feature_index feat)\n{\n\tif (!(flags & flag))\n\t\treturn true;\n\tif (wiphy_ext_feature_isset(wiphy, feat))\n\t\treturn true;\n\treturn false;\n}\n\nstatic int\nnl80211_check_scan_flags(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t void *request, struct nlattr **attrs,\n\t\t\t bool is_sched_scan)\n{\n\tu8 *mac_addr, *mac_addr_mask;\n\tu32 *flags;\n\tenum nl80211_feature_flags randomness_flag;\n\n\tif (!attrs[NL80211_ATTR_SCAN_FLAGS])\n\t\treturn 0;\n\n\tif (is_sched_scan) {\n\t\tstruct cfg80211_sched_scan_request *req = request;\n\n\t\trandomness_flag = wdev ?\n\t\t\t\t  NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR :\n\t\t\t\t  NL80211_FEATURE_ND_RANDOM_MAC_ADDR;\n\t\tflags = &req->flags;\n\t\tmac_addr = req->mac_addr;\n\t\tmac_addr_mask = req->mac_addr_mask;\n\t} else {\n\t\tstruct cfg80211_scan_request *req = request;\n\n\t\trandomness_flag = NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;\n\t\tflags = &req->flags;\n\t\tmac_addr = req->mac_addr;\n\t\tmac_addr_mask = req->mac_addr_mask;\n\t}\n\n\t*flags = nla_get_u32(attrs[NL80211_ATTR_SCAN_FLAGS]);\n\n\tif (((*flags & NL80211_SCAN_FLAG_LOW_PRIORITY) &&\n\t     !(wiphy->features & NL80211_FEATURE_LOW_PRIORITY_SCAN)) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_LOW_SPAN,\n\t\t\t\t     NL80211_EXT_FEATURE_LOW_SPAN_SCAN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_LOW_POWER,\n\t\t\t\t     NL80211_EXT_FEATURE_LOW_POWER_SCAN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_HIGH_ACCURACY,\n\t\t\t\t     NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME,\n\t\t\t\t     NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP,\n\t\t\t\t     NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION,\n\t\t\t\t     NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE,\n\t\t\t\t     NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_RANDOM_SN,\n\t\t\t\t     NL80211_EXT_FEATURE_SCAN_RANDOM_SN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_MIN_PREQ_CONTENT,\n\t\t\t\t     NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (*flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {\n\t\tint err;\n\n\t\tif (!(wiphy->features & randomness_flag) ||\n\t\t    (wdev && wdev->current_bss))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nl80211_parse_random_mac(attrs, mac_addr, mac_addr_mask);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_scan_request *request;\n\tstruct nlattr *scan_freqs = NULL;\n\tbool scan_freqs_khz = false;\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tsize_t ie_len;\n\n\twiphy = &rdev->wiphy;\n\n\tif (wdev->iftype == NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_req || rdev->scan_msg)\n\t\treturn -EBUSY;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQ_KHZ]) {\n\t\tif (!wiphy_ext_feature_isset(wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SCAN_FREQ_KHZ))\n\t\t\treturn -EOPNOTSUPP;\n\t\tscan_freqs = info->attrs[NL80211_ATTR_SCAN_FREQ_KHZ];\n\t\tscan_freqs_khz = true;\n\t} else if (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES])\n\t\tscan_freqs = info->attrs[NL80211_ATTR_SCAN_FREQUENCIES];\n\n\tif (scan_freqs) {\n\t\tn_channels = validate_scan_freqs(scan_freqs);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = ieee80211_get_num_supported_channels(wiphy);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (n_ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (scan_freqs) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr, scan_freqs, tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\t\t\tint freq = nla_get_u32(attr);\n\n\t\t\tif (!scan_freqs_khz)\n\t\t\t\tfreq = MHZ_TO_KHZ(freq);\n\n\t\t\tchan = ieee80211_get_channel_khz(wiphy, freq);\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\tenum nl80211_band band;\n\n\t\t/* all channels */\n\t\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\t\tint j;\n\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\twdev_lock(wdev);\n\tif (!cfg80211_off_channel_oper_allowed(wdev)) {\n\t\tstruct ieee80211_channel *chan;\n\n\t\tif (request->n_channels != 1) {\n\t\t\twdev_unlock(wdev);\n\t\t\terr = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tchan = request->channels[0];\n\t\tif (chan->center_freq != wdev->chandef.chan->center_freq) {\n\t\t\twdev_unlock(wdev);\n\t\t\terr = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\twdev_unlock(wdev);\n\n\ti = 0;\n\tif (n_ssids) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {\n\t\t\tif (nla_len(attr) > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\tif (wiphy->bands[i])\n\t\t\trequest->rates[i] =\n\t\t\t\t(1 << wiphy->bands[i]->n_bitrates) - 1;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SUPP_RATES]) {\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    info->attrs[NL80211_ATTR_SCAN_SUPP_RATES],\n\t\t\t\t    tmp) {\n\t\t\tenum nl80211_band band = nla_type(attr);\n\n\t\t\tif (band < 0 || band >= NUM_NL80211_BANDS) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\n\t\t\terr = ieee80211_get_ratemask(wiphy->bands[band],\n\t\t\t\t\t\t     nla_data(attr),\n\t\t\t\t\t\t     nla_len(attr),\n\t\t\t\t\t\t     &request->rates[band]);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MEASUREMENT_DURATION]) {\n\t\trequest->duration =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_MEASUREMENT_DURATION]);\n\t\trequest->duration_mandatory =\n\t\t\tnla_get_flag(info->attrs[NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY]);\n\t}\n\n\terr = nl80211_check_scan_flags(wiphy, wdev, request, info->attrs,\n\t\t\t\t       false);\n\tif (err)\n\t\tgoto out_free;\n\n\trequest->no_cck =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_TX_NO_CCK_RATE]);\n\n\t/* Initial implementation used NL80211_ATTR_MAC to set the specific\n\t * BSSID to scan for. This was problematic because that same attribute\n\t * was already used for another purpose (local random MAC address). The\n\t * NL80211_ATTR_BSSID attribute was added to fix this. For backwards\n\t * compatibility with older userspace components, also use the\n\t * NL80211_ATTR_MAC value here if it can be determined to be used for\n\t * the specific BSSID use case instead of the random MAC address\n\t * (NL80211_ATTR_SCAN_FLAGS is used to enable random MAC address use).\n\t */\n\tif (info->attrs[NL80211_ATTR_BSSID])\n\t\tmemcpy(request->bssid,\n\t\t       nla_data(info->attrs[NL80211_ATTR_BSSID]), ETH_ALEN);\n\telse if (!(request->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) &&\n\t\t info->attrs[NL80211_ATTR_MAC])\n\t\tmemcpy(request->bssid, nla_data(info->attrs[NL80211_ATTR_MAC]),\n\t\t       ETH_ALEN);\n\telse\n\t\teth_broadcast_addr(request->bssid);\n\n\trequest->wdev = wdev;\n\trequest->wiphy = &rdev->wiphy;\n\trequest->scan_start = jiffies;\n\n\trdev->scan_req = request;\n\terr = cfg80211_scan(rdev);\n\n\tif (err)\n\t\tgoto out_free;\n\n\tnl80211_send_scan_start(rdev, wdev);\n\tif (wdev->netdev)\n\t\tdev_hold(wdev->netdev);\n\n\treturn 0;\n\n out_free:\n\trdev->scan_req = NULL;\n\tkfree(request);\n\n\treturn err;\n}\n\nstatic int nl80211_abort_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (!rdev->ops->abort_scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_msg)\n\t\treturn 0;\n\n\tif (!rdev->scan_req)\n\t\treturn -ENOENT;\n\n\trdev_abort_scan(rdev, wdev);\n\treturn 0;\n}\n\nstatic int\nnl80211_parse_sched_scan_plans(struct wiphy *wiphy, int n_plans,\n\t\t\t       struct cfg80211_sched_scan_request *request,\n\t\t\t       struct nlattr **attrs)\n{\n\tint tmp, err, i = 0;\n\tstruct nlattr *attr;\n\n\tif (!attrs[NL80211_ATTR_SCHED_SCAN_PLANS]) {\n\t\tu32 interval;\n\n\t\t/*\n\t\t * If scan plans are not specified,\n\t\t * %NL80211_ATTR_SCHED_SCAN_INTERVAL will be specified. In this\n\t\t * case one scan plan will be set with the specified scan\n\t\t * interval and infinite number of iterations.\n\t\t */\n\t\tinterval = nla_get_u32(attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL]);\n\t\tif (!interval)\n\t\t\treturn -EINVAL;\n\n\t\trequest->scan_plans[0].interval =\n\t\t\tDIV_ROUND_UP(interval, MSEC_PER_SEC);\n\t\tif (!request->scan_plans[0].interval)\n\t\t\treturn -EINVAL;\n\n\t\tif (request->scan_plans[0].interval >\n\t\t    wiphy->max_sched_scan_plan_interval)\n\t\t\trequest->scan_plans[0].interval =\n\t\t\t\twiphy->max_sched_scan_plan_interval;\n\n\t\treturn 0;\n\t}\n\n\tnla_for_each_nested(attr, attrs[NL80211_ATTR_SCHED_SCAN_PLANS], tmp) {\n\t\tstruct nlattr *plan[NL80211_SCHED_SCAN_PLAN_MAX + 1];\n\n\t\tif (WARN_ON(i >= n_plans))\n\t\t\treturn -EINVAL;\n\n\t\terr = nla_parse_nested_deprecated(plan,\n\t\t\t\t\t\t  NL80211_SCHED_SCAN_PLAN_MAX,\n\t\t\t\t\t\t  attr, nl80211_plan_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!plan[NL80211_SCHED_SCAN_PLAN_INTERVAL])\n\t\t\treturn -EINVAL;\n\n\t\trequest->scan_plans[i].interval =\n\t\t\tnla_get_u32(plan[NL80211_SCHED_SCAN_PLAN_INTERVAL]);\n\t\tif (!request->scan_plans[i].interval ||\n\t\t    request->scan_plans[i].interval >\n\t\t    wiphy->max_sched_scan_plan_interval)\n\t\t\treturn -EINVAL;\n\n\t\tif (plan[NL80211_SCHED_SCAN_PLAN_ITERATIONS]) {\n\t\t\trequest->scan_plans[i].iterations =\n\t\t\t\tnla_get_u32(plan[NL80211_SCHED_SCAN_PLAN_ITERATIONS]);\n\t\t\tif (!request->scan_plans[i].iterations ||\n\t\t\t    (request->scan_plans[i].iterations >\n\t\t\t     wiphy->max_sched_scan_plan_iterations))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (i < n_plans - 1) {\n\t\t\t/*\n\t\t\t * All scan plans but the last one must specify\n\t\t\t * a finite number of iterations\n\t\t\t */\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ti++;\n\t}\n\n\t/*\n\t * The last scan plan must not specify the number of\n\t * iterations, it is supposed to run infinitely\n\t */\n\tif (request->scan_plans[n_plans - 1].iterations)\n\t\treturn  -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nnl80211_parse_sched_scan_per_band_rssi(struct wiphy *wiphy,\n\t\t\t\t       struct cfg80211_match_set *match_sets,\n\t\t\t\t       struct nlattr *tb_band_rssi,\n\t\t\t\t       s32 rssi_thold)\n{\n\tstruct nlattr *attr;\n\tint i, tmp, ret = 0;\n\n\tif (!wiphy_ext_feature_isset(wiphy,\n\t\t    NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD)) {\n\t\tif (tb_band_rssi)\n\t\t\tret = -EOPNOTSUPP;\n\t\telse\n\t\t\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\t\t\tmatch_sets->per_band_rssi_thold[i] =\n\t\t\t\t\tNL80211_SCAN_RSSI_THOLD_OFF;\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\tmatch_sets->per_band_rssi_thold[i] = rssi_thold;\n\n\tnla_for_each_nested(attr, tb_band_rssi, tmp) {\n\t\tenum nl80211_band band = nla_type(attr);\n\n\t\tif (band < 0 || band >= NUM_NL80211_BANDS)\n\t\t\treturn -EINVAL;\n\n\t\tmatch_sets->per_band_rssi_thold[band] =\tnla_get_s32(attr);\n\t}\n\n\treturn 0;\n}\n\nstatic struct cfg80211_sched_scan_request *\nnl80211_parse_sched_scan(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t struct nlattr **attrs, int max_match_sets)\n{\n\tstruct cfg80211_sched_scan_request *request;\n\tstruct nlattr *attr;\n\tint err, tmp, n_ssids = 0, n_match_sets = 0, n_channels, i, n_plans = 0;\n\tenum nl80211_band band;\n\tsize_t ie_len;\n\tstruct nlattr *tb[NL80211_SCHED_SCAN_MATCH_ATTR_MAX + 1];\n\ts32 default_match_rssi = NL80211_SCAN_RSSI_THOLD_OFF;\n\n\tif (attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tattrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t} else {\n\t\tn_channels = ieee80211_get_num_supported_channels(wiphy);\n\t}\n\n\tif (attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_sched_scan_ssids)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * First, count the number of 'real' matchsets. Due to an issue with\n\t * the old implementation, matchsets containing only the RSSI attribute\n\t * (NL80211_SCHED_SCAN_MATCH_ATTR_RSSI) are considered as the 'default'\n\t * RSSI for all matchsets, rather than their own matchset for reporting\n\t * all APs with a strong RSSI. This is needed to be compatible with\n\t * older userspace that treated a matchset with only the RSSI as the\n\t * global RSSI for all other matchsets - if there are other matchsets.\n\t */\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_MATCH]) {\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCHED_SCAN_MATCH],\n\t\t\t\t    tmp) {\n\t\t\tstruct nlattr *rssi;\n\n\t\t\terr = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t\t  NL80211_SCHED_SCAN_MATCH_ATTR_MAX,\n\t\t\t\t\t\t\t  attr,\n\t\t\t\t\t\t\t  nl80211_match_policy,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tif (err)\n\t\t\t\treturn ERR_PTR(err);\n\n\t\t\t/* SSID and BSSID are mutually exclusive */\n\t\t\tif (tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID] &&\n\t\t\t    tb[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID])\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\t/* add other standalone attributes here */\n\t\t\tif (tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID] ||\n\t\t\t    tb[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID]) {\n\t\t\t\tn_match_sets++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trssi = tb[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI];\n\t\t\tif (rssi)\n\t\t\t\tdefault_match_rssi = nla_get_s32(rssi);\n\t\t}\n\t}\n\n\t/* However, if there's no other matchset, add the RSSI one */\n\tif (!n_match_sets && default_match_rssi != NL80211_SCAN_RSSI_THOLD_OFF)\n\t\tn_match_sets = 1;\n\n\tif (n_match_sets > max_match_sets)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_sched_scan_ie_len)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_PLANS]) {\n\t\t/*\n\t\t * NL80211_ATTR_SCHED_SCAN_INTERVAL must not be specified since\n\t\t * each scan plan already specifies its own interval\n\t\t */\n\t\tif (attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCHED_SCAN_PLANS], tmp)\n\t\t\tn_plans++;\n\t} else {\n\t\t/*\n\t\t * The scan interval attribute is kept for backward\n\t\t * compatibility. If no scan plans are specified and sched scan\n\t\t * interval is specified, one scan plan will be set with this\n\t\t * scan interval and infinite number of iterations.\n\t\t */\n\t\tif (!attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tn_plans = 1;\n\t}\n\n\tif (!n_plans || n_plans > wiphy->max_sched_scan_plans)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!wiphy_ext_feature_isset(\n\t\t    wiphy, NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI) &&\n\t    (attrs[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI] ||\n\t     attrs[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST]))\n\t\treturn ERR_PTR(-EINVAL);\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->match_sets) * n_match_sets\n\t\t\t+ sizeof(*request->scan_plans) * n_plans\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (n_ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\tif (n_match_sets) {\n\t\tif (request->ie)\n\t\t\trequest->match_sets = (void *)(request->ie + ie_len);\n\t\telse if (n_ssids)\n\t\t\trequest->match_sets =\n\t\t\t\t(void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->match_sets =\n\t\t\t\t(void *)(request->channels + n_channels);\n\t}\n\trequest->n_match_sets = n_match_sets;\n\n\tif (n_match_sets)\n\t\trequest->scan_plans = (void *)(request->match_sets +\n\t\t\t\t\t       n_match_sets);\n\telse if (request->ie)\n\t\trequest->scan_plans = (void *)(request->ie + ie_len);\n\telse if (n_ssids)\n\t\trequest->scan_plans = (void *)(request->ssids + n_ssids);\n\telse\n\t\trequest->scan_plans = (void *)(request->channels + n_channels);\n\n\trequest->n_scan_plans = n_plans;\n\n\ti = 0;\n\tif (attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCAN_FREQUENCIES],\n\t\t\t\t    tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\t\tint j;\n\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (n_ssids) {\n\t\tnla_for_each_nested(attr, attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp) {\n\t\t\tif (nla_len(attr) > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr),\n\t\t\t       nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\ti = 0;\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_MATCH]) {\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCHED_SCAN_MATCH],\n\t\t\t\t    tmp) {\n\t\t\tstruct nlattr *ssid, *bssid, *rssi;\n\n\t\t\terr = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t\t  NL80211_SCHED_SCAN_MATCH_ATTR_MAX,\n\t\t\t\t\t\t\t  attr,\n\t\t\t\t\t\t\t  nl80211_match_policy,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\t\t\tssid = tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID];\n\t\t\tbssid = tb[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID];\n\n\t\t\tif (!ssid && !bssid) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (WARN_ON(i >= n_match_sets)) {\n\t\t\t\t/* this indicates a programming error,\n\t\t\t\t * the loop above should have verified\n\t\t\t\t * things properly\n\t\t\t\t */\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tif (ssid) {\n\t\t\t\tmemcpy(request->match_sets[i].ssid.ssid,\n\t\t\t\t       nla_data(ssid), nla_len(ssid));\n\t\t\t\trequest->match_sets[i].ssid.ssid_len =\n\t\t\t\t\tnla_len(ssid);\n\t\t\t}\n\t\t\tif (bssid)\n\t\t\t\tmemcpy(request->match_sets[i].bssid,\n\t\t\t\t       nla_data(bssid), ETH_ALEN);\n\n\t\t\t/* special attribute - old implementation w/a */\n\t\t\trequest->match_sets[i].rssi_thold = default_match_rssi;\n\t\t\trssi = tb[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI];\n\t\t\tif (rssi)\n\t\t\t\trequest->match_sets[i].rssi_thold =\n\t\t\t\t\tnla_get_s32(rssi);\n\n\t\t\t/* Parse per band RSSI attribute */\n\t\t\terr = nl80211_parse_sched_scan_per_band_rssi(wiphy,\n\t\t\t\t&request->match_sets[i],\n\t\t\t\ttb[NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI],\n\t\t\t\trequest->match_sets[i].rssi_thold);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\n\t\t\ti++;\n\t\t}\n\n\t\t/* there was no other matchset, so the RSSI one is alone */\n\t\tif (i == 0 && n_match_sets)\n\t\t\trequest->match_sets[0].rssi_thold = default_match_rssi;\n\n\t\trequest->min_rssi_thold = INT_MAX;\n\t\tfor (i = 0; i < n_match_sets; i++)\n\t\t\trequest->min_rssi_thold =\n\t\t\t\tmin(request->match_sets[i].rssi_thold,\n\t\t\t\t    request->min_rssi_thold);\n\t} else {\n\t\trequest->min_rssi_thold = NL80211_SCAN_RSSI_THOLD_OFF;\n\t}\n\n\tif (ie_len) {\n\t\trequest->ie_len = ie_len;\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\terr = nl80211_check_scan_flags(wiphy, wdev, request, attrs, true);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_DELAY])\n\t\trequest->delay =\n\t\t\tnla_get_u32(attrs[NL80211_ATTR_SCHED_SCAN_DELAY]);\n\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI]) {\n\t\trequest->relative_rssi = nla_get_s8(\n\t\t\tattrs[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI]);\n\t\trequest->relative_rssi_set = true;\n\t}\n\n\tif (request->relative_rssi_set &&\n\t    attrs[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST]) {\n\t\tstruct nl80211_bss_select_rssi_adjust *rssi_adjust;\n\n\t\trssi_adjust = nla_data(\n\t\t\tattrs[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST]);\n\t\trequest->rssi_adjust.band = rssi_adjust->band;\n\t\trequest->rssi_adjust.delta = rssi_adjust->delta;\n\t\tif (!is_band_valid(wiphy, request->rssi_adjust.band)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\terr = nl80211_parse_sched_scan_plans(wiphy, n_plans, request, attrs);\n\tif (err)\n\t\tgoto out_free;\n\n\trequest->scan_start = jiffies;\n\n\treturn request;\n\nout_free:\n\tkfree(request);\n\treturn ERR_PTR(err);\n}\n\nstatic int nl80211_start_sched_scan(struct sk_buff *skb,\n\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_sched_scan_request *sched_scan_req;\n\tbool want_multi;\n\tint err;\n\n\tif (!rdev->wiphy.max_sched_scan_reqs || !rdev->ops->sched_scan_start)\n\t\treturn -EOPNOTSUPP;\n\n\twant_multi = info->attrs[NL80211_ATTR_SCHED_SCAN_MULTI];\n\terr = cfg80211_sched_scan_req_possible(rdev, want_multi);\n\tif (err)\n\t\treturn err;\n\n\tsched_scan_req = nl80211_parse_sched_scan(&rdev->wiphy, wdev,\n\t\t\t\t\t\t  info->attrs,\n\t\t\t\t\t\t  rdev->wiphy.max_match_sets);\n\n\terr = PTR_ERR_OR_ZERO(sched_scan_req);\n\tif (err)\n\t\tgoto out_err;\n\n\t/* leave request id zero for legacy request\n\t * or if driver does not support multi-scheduled scan\n\t */\n\tif (want_multi && rdev->wiphy.max_sched_scan_reqs > 1)\n\t\tsched_scan_req->reqid = cfg80211_assign_cookie(rdev);\n\n\terr = rdev_sched_scan_start(rdev, dev, sched_scan_req);\n\tif (err)\n\t\tgoto out_free;\n\n\tsched_scan_req->dev = dev;\n\tsched_scan_req->wiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\tsched_scan_req->owner_nlportid = info->snd_portid;\n\n\tcfg80211_add_sched_scan_req(rdev, sched_scan_req);\n\n\tnl80211_send_sched_scan(sched_scan_req, NL80211_CMD_START_SCHED_SCAN);\n\treturn 0;\n\nout_free:\n\tkfree(sched_scan_req);\nout_err:\n\treturn err;\n}\n\nstatic int nl80211_stop_sched_scan(struct sk_buff *skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_sched_scan_request *req;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tu64 cookie;\n\n\tif (!rdev->wiphy.max_sched_scan_reqs || !rdev->ops->sched_scan_stop)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_COOKIE]) {\n\t\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\t\treturn __cfg80211_stop_sched_scan(rdev, cookie, false);\n\t}\n\n\treq = list_first_or_null_rcu(&rdev->sched_scan_req_list,\n\t\t\t\t     struct cfg80211_sched_scan_request,\n\t\t\t\t     list);\n\tif (!req || req->reqid ||\n\t    (req->owner_nlportid &&\n\t     req->owner_nlportid != info->snd_portid))\n\t\treturn -ENOENT;\n\n\treturn cfg80211_stop_sched_scan_req(rdev, req, false);\n}\n\nstatic int nl80211_start_radar_detection(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_chan_def chandef;\n\tenum nl80211_dfs_regions dfs_region;\n\tunsigned int cac_time_ms;\n\tint err;\n\n\tdfs_region = reg_get_dfs_region(wiphy);\n\tif (dfs_region == NL80211_DFS_UNSET)\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err)\n\t\treturn err;\n\n\tif (netif_carrier_ok(dev))\n\t\treturn -EBUSY;\n\n\tif (wdev->cac_started)\n\t\treturn -EBUSY;\n\n\terr = cfg80211_chandef_dfs_required(wiphy, &chandef, wdev->iftype);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (err == 0)\n\t\treturn -EINVAL;\n\n\tif (!cfg80211_chandef_dfs_usable(wiphy, &chandef))\n\t\treturn -EINVAL;\n\n\t/* CAC start is offloaded to HW and can't be started manually */\n\tif (wiphy_ext_feature_isset(wiphy, NL80211_EXT_FEATURE_DFS_OFFLOAD))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->start_radar_detection)\n\t\treturn -EOPNOTSUPP;\n\n\tcac_time_ms = cfg80211_chandef_dfs_cac_time(&rdev->wiphy, &chandef);\n\tif (WARN_ON(!cac_time_ms))\n\t\tcac_time_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;\n\n\terr = rdev_start_radar_detection(rdev, dev, &chandef, cac_time_ms);\n\tif (!err) {\n\t\twdev->chandef = chandef;\n\t\twdev->cac_started = true;\n\t\twdev->cac_start_time = jiffies;\n\t\twdev->cac_time_ms = cac_time_ms;\n\t}\n\treturn err;\n}\n\nstatic int nl80211_notify_radar_detection(struct sk_buff *skb,\n\t\t\t\t\t  struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_chan_def chandef;\n\tenum nl80211_dfs_regions dfs_region;\n\tint err;\n\n\tdfs_region = reg_get_dfs_region(wiphy);\n\tif (dfs_region == NL80211_DFS_UNSET) {\n\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t \"DFS Region is not set. Unexpected Radar indication\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err) {\n\t\tGENL_SET_ERR_MSG(info, \"Unable to extract chandef info\");\n\t\treturn err;\n\t}\n\n\terr = cfg80211_chandef_dfs_required(wiphy, &chandef, wdev->iftype);\n\tif (err < 0) {\n\t\tGENL_SET_ERR_MSG(info, \"chandef is invalid\");\n\t\treturn err;\n\t}\n\n\tif (err == 0) {\n\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t \"Unexpected Radar indication for chandef/iftype\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Do not process this notification if radar is already detected\n\t * by kernel on this channel, and return success.\n\t */\n\tif (chandef.chan->dfs_state == NL80211_DFS_UNAVAILABLE)\n\t\treturn 0;\n\n\tcfg80211_set_dfs_state(wiphy, &chandef, NL80211_DFS_UNAVAILABLE);\n\n\tcfg80211_sched_dfs_chan_update(rdev);\n\n\trdev->radar_chandef = chandef;\n\n\t/* Propagate this notification to other radios as well */\n\tqueue_work(cfg80211_wq, &rdev->propagate_radar_detect_wk);\n\n\treturn 0;\n}\n\nstatic int nl80211_channel_switch(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_csa_settings params;\n\tstruct nlattr **csa_attrs = NULL;\n\tint err;\n\tbool need_new_beacon = false;\n\tbool need_handle_dfs_flag = true;\n\tint len, i;\n\tu32 cs_count;\n\n\tif (!rdev->ops->channel_switch ||\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tneed_new_beacon = true;\n\t\t/* For all modes except AP the handle_dfs flag needs to be\n\t\t * supplied to tell the kernel that userspace will handle radar\n\t\t * events when they happen. Otherwise a switch to a channel\n\t\t * requiring DFS will be rejected.\n\t\t */\n\t\tneed_handle_dfs_flag = false;\n\n\t\t/* useless if AP is not running */\n\t\tif (!wdev->beacon_interval)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (!wdev->ssid_len)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!wdev->mesh_id_len)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.beacon_csa.ftm_responder = -1;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t    !info->attrs[NL80211_ATTR_CH_SWITCH_COUNT])\n\t\treturn -EINVAL;\n\n\t/* only important for AP, IBSS and mesh create IEs internally */\n\tif (need_new_beacon && !info->attrs[NL80211_ATTR_CSA_IES])\n\t\treturn -EINVAL;\n\n\t/* Even though the attribute is u32, the specification says\n\t * u8, so let's make sure we don't overflow.\n\t */\n\tcs_count = nla_get_u32(info->attrs[NL80211_ATTR_CH_SWITCH_COUNT]);\n\tif (cs_count > 255)\n\t\treturn -EINVAL;\n\n\tparams.count = cs_count;\n\n\tif (!need_new_beacon)\n\t\tgoto skip_beacons;\n\n\terr = nl80211_parse_beacon(rdev, info->attrs, &params.beacon_after);\n\tif (err)\n\t\treturn err;\n\n\tcsa_attrs = kcalloc(NL80211_ATTR_MAX + 1, sizeof(*csa_attrs),\n\t\t\t    GFP_KERNEL);\n\tif (!csa_attrs)\n\t\treturn -ENOMEM;\n\n\terr = nla_parse_nested_deprecated(csa_attrs, NL80211_ATTR_MAX,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_CSA_IES],\n\t\t\t\t\t  nl80211_policy, info->extack);\n\tif (err)\n\t\tgoto free;\n\n\terr = nl80211_parse_beacon(rdev, csa_attrs, &params.beacon_csa);\n\tif (err)\n\t\tgoto free;\n\n\tif (!csa_attrs[NL80211_ATTR_CNTDWN_OFFS_BEACON]) {\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tlen = nla_len(csa_attrs[NL80211_ATTR_CNTDWN_OFFS_BEACON]);\n\tif (!len || (len % sizeof(u16))) {\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tparams.n_counter_offsets_beacon = len / sizeof(u16);\n\tif (rdev->wiphy.max_num_csa_counters &&\n\t    (params.n_counter_offsets_beacon >\n\t     rdev->wiphy.max_num_csa_counters)) {\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tparams.counter_offsets_beacon =\n\t\tnla_data(csa_attrs[NL80211_ATTR_CNTDWN_OFFS_BEACON]);\n\n\t/* sanity checks - counters should fit and be the same */\n\tfor (i = 0; i < params.n_counter_offsets_beacon; i++) {\n\t\tu16 offset = params.counter_offsets_beacon[i];\n\n\t\tif (offset >= params.beacon_csa.tail_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tif (params.beacon_csa.tail[offset] != params.count) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (csa_attrs[NL80211_ATTR_CNTDWN_OFFS_PRESP]) {\n\t\tlen = nla_len(csa_attrs[NL80211_ATTR_CNTDWN_OFFS_PRESP]);\n\t\tif (!len || (len % sizeof(u16))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tparams.n_counter_offsets_presp = len / sizeof(u16);\n\t\tif (rdev->wiphy.max_num_csa_counters &&\n\t\t    (params.n_counter_offsets_presp >\n\t\t     rdev->wiphy.max_num_csa_counters)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tparams.counter_offsets_presp =\n\t\t\tnla_data(csa_attrs[NL80211_ATTR_CNTDWN_OFFS_PRESP]);\n\n\t\t/* sanity checks - counters should fit and be the same */\n\t\tfor (i = 0; i < params.n_counter_offsets_presp; i++) {\n\t\t\tu16 offset = params.counter_offsets_presp[i];\n\n\t\t\tif (offset >= params.beacon_csa.probe_resp_len) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tif (params.beacon_csa.probe_resp[offset] !=\n\t\t\t    params.count) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t}\n\t}\n\nskip_beacons:\n\terr = nl80211_parse_chandef(rdev, info, &params.chandef);\n\tif (err)\n\t\tgoto free;\n\n\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &params.chandef,\n\t\t\t\t\t   wdev->iftype)) {\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\n\terr = cfg80211_chandef_dfs_required(wdev->wiphy,\n\t\t\t\t\t    &params.chandef,\n\t\t\t\t\t    wdev->iftype);\n\tif (err < 0)\n\t\tgoto free;\n\n\tif (err > 0) {\n\t\tparams.radar_required = true;\n\t\tif (need_handle_dfs_flag &&\n\t\t    !nla_get_flag(info->attrs[NL80211_ATTR_HANDLE_DFS])) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_CH_SWITCH_BLOCK_TX])\n\t\tparams.block_tx = true;\n\n\twdev_lock(wdev);\n\terr = rdev_channel_switch(rdev, dev, &params);\n\twdev_unlock(wdev);\n\nfree:\n\tkfree(csa_attrs);\n\treturn err;\n}\n\nstatic int nl80211_send_bss(struct sk_buff *msg, struct netlink_callback *cb,\n\t\t\t    u32 seq, int flags,\n\t\t\t    struct cfg80211_registered_device *rdev,\n\t\t\t    struct wireless_dev *wdev,\n\t\t\t    struct cfg80211_internal_bss *intbss)\n{\n\tstruct cfg80211_bss *res = &intbss->pub;\n\tconst struct cfg80211_bss_ies *ies;\n\tvoid *hdr;\n\tstruct nlattr *bss;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\thdr = nl80211hdr_put(msg, NETLINK_CB(cb->skb).portid, seq, flags,\n\t\t\t     NL80211_CMD_NEW_SCAN_RESULTS);\n\tif (!hdr)\n\t\treturn -1;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nla_put_u32(msg, NL80211_ATTR_GENERATION, rdev->bss_generation))\n\t\tgoto nla_put_failure;\n\tif (wdev->netdev &&\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, wdev->netdev->ifindex))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tbss = nla_nest_start_noflag(msg, NL80211_ATTR_BSS);\n\tif (!bss)\n\t\tgoto nla_put_failure;\n\tif ((!is_zero_ether_addr(res->bssid) &&\n\t     nla_put(msg, NL80211_BSS_BSSID, ETH_ALEN, res->bssid)))\n\t\tgoto nla_put_failure;\n\n\trcu_read_lock();\n\t/* indicate whether we have probe response data or not */\n\tif (rcu_access_pointer(res->proberesp_ies) &&\n\t    nla_put_flag(msg, NL80211_BSS_PRESP_DATA))\n\t\tgoto fail_unlock_rcu;\n\n\t/* this pointer prefers to be pointed to probe response data\n\t * but is always valid\n\t */\n\ties = rcu_dereference(res->ies);\n\tif (ies) {\n\t\tif (nla_put_u64_64bit(msg, NL80211_BSS_TSF, ies->tsf,\n\t\t\t\t      NL80211_BSS_PAD))\n\t\t\tgoto fail_unlock_rcu;\n\t\tif (ies->len && nla_put(msg, NL80211_BSS_INFORMATION_ELEMENTS,\n\t\t\t\t\ties->len, ies->data))\n\t\t\tgoto fail_unlock_rcu;\n\t}\n\n\t/* and this pointer is always (unless driver didn't know) beacon data */\n\ties = rcu_dereference(res->beacon_ies);\n\tif (ies && ies->from_beacon) {\n\t\tif (nla_put_u64_64bit(msg, NL80211_BSS_BEACON_TSF, ies->tsf,\n\t\t\t\t      NL80211_BSS_PAD))\n\t\t\tgoto fail_unlock_rcu;\n\t\tif (ies->len && nla_put(msg, NL80211_BSS_BEACON_IES,\n\t\t\t\t\ties->len, ies->data))\n\t\t\tgoto fail_unlock_rcu;\n\t}\n\trcu_read_unlock();\n\n\tif (res->beacon_interval &&\n\t    nla_put_u16(msg, NL80211_BSS_BEACON_INTERVAL, res->beacon_interval))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(msg, NL80211_BSS_CAPABILITY, res->capability) ||\n\t    nla_put_u32(msg, NL80211_BSS_FREQUENCY, res->channel->center_freq) ||\n\t    nla_put_u32(msg, NL80211_BSS_FREQUENCY_OFFSET,\n\t\t\tres->channel->freq_offset) ||\n\t    nla_put_u32(msg, NL80211_BSS_CHAN_WIDTH, res->scan_width) ||\n\t    nla_put_u32(msg, NL80211_BSS_SEEN_MS_AGO,\n\t\t\tjiffies_to_msecs(jiffies - intbss->ts)))\n\t\tgoto nla_put_failure;\n\n\tif (intbss->parent_tsf &&\n\t    (nla_put_u64_64bit(msg, NL80211_BSS_PARENT_TSF,\n\t\t\t       intbss->parent_tsf, NL80211_BSS_PAD) ||\n\t     nla_put(msg, NL80211_BSS_PARENT_BSSID, ETH_ALEN,\n\t\t     intbss->parent_bssid)))\n\t\tgoto nla_put_failure;\n\n\tif (intbss->ts_boottime &&\n\t    nla_put_u64_64bit(msg, NL80211_BSS_LAST_SEEN_BOOTTIME,\n\t\t\t      intbss->ts_boottime, NL80211_BSS_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (!nl80211_put_signal(msg, intbss->pub.chains,\n\t\t\t\tintbss->pub.chain_signal,\n\t\t\t\tNL80211_BSS_CHAIN_SIGNAL))\n\t\tgoto nla_put_failure;\n\n\tswitch (rdev->wiphy.signal_type) {\n\tcase CFG80211_SIGNAL_TYPE_MBM:\n\t\tif (nla_put_u32(msg, NL80211_BSS_SIGNAL_MBM, res->signal))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CFG80211_SIGNAL_TYPE_UNSPEC:\n\t\tif (nla_put_u8(msg, NL80211_BSS_SIGNAL_UNSPEC, res->signal))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (intbss == wdev->current_bss &&\n\t\t    nla_put_u32(msg, NL80211_BSS_STATUS,\n\t\t\t\tNL80211_BSS_STATUS_ASSOCIATED))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (intbss == wdev->current_bss &&\n\t\t    nla_put_u32(msg, NL80211_BSS_STATUS,\n\t\t\t\tNL80211_BSS_STATUS_IBSS_JOINED))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnla_nest_end(msg, bss);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n fail_unlock_rcu:\n\trcu_read_unlock();\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_scan(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct cfg80211_internal_bss *scan;\n\tstruct wireless_dev *wdev;\n\tint start = cb->args[2], idx = 0;\n\tint err;\n\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\tspin_lock_bh(&rdev->bss_lock);\n\n\t/*\n\t * dump_scan will be called multiple times to break up the scan results\n\t * into multiple messages.  It is unlikely that any more bss-es will be\n\t * expired after the first call, so only call only call this on the\n\t * first dump_scan invocation.\n\t */\n\tif (start == 0)\n\t\tcfg80211_bss_expire(rdev);\n\n\tcb->seq = rdev->bss_generation;\n\n\tlist_for_each_entry(scan, &rdev->bss_list, list) {\n\t\tif (++idx <= start)\n\t\t\tcontinue;\n\t\tif (nl80211_send_bss(skb, cb,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\trdev, wdev, scan) < 0) {\n\t\t\tidx--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&rdev->bss_lock);\n\twdev_unlock(wdev);\n\n\tcb->args[2] = idx;\n\tmutex_unlock(&rdev->wiphy.mtx);\n\n\treturn skb->len;\n}\n\nstatic int nl80211_send_survey(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t       int flags, struct net_device *dev,\n\t\t\t       bool allow_radio_stats,\n\t\t\t       struct survey_info *survey)\n{\n\tvoid *hdr;\n\tstruct nlattr *infoattr;\n\n\t/* skip radio stats if userspace didn't request them */\n\tif (!survey->channel && !allow_radio_stats)\n\t\treturn 0;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags,\n\t\t\t     NL80211_CMD_NEW_SURVEY_RESULTS);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_SURVEY_INFO);\n\tif (!infoattr)\n\t\tgoto nla_put_failure;\n\n\tif (survey->channel &&\n\t    nla_put_u32(msg, NL80211_SURVEY_INFO_FREQUENCY,\n\t\t\tsurvey->channel->center_freq))\n\t\tgoto nla_put_failure;\n\n\tif (survey->channel && survey->channel->freq_offset &&\n\t    nla_put_u32(msg, NL80211_SURVEY_INFO_FREQUENCY_OFFSET,\n\t\t\tsurvey->channel->freq_offset))\n\t\tgoto nla_put_failure;\n\n\tif ((survey->filled & SURVEY_INFO_NOISE_DBM) &&\n\t    nla_put_u8(msg, NL80211_SURVEY_INFO_NOISE, survey->noise))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_IN_USE) &&\n\t    nla_put_flag(msg, NL80211_SURVEY_INFO_IN_USE))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME,\n\t\t\tsurvey->time, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_BUSY) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_BUSY,\n\t\t\t      survey->time_busy, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_EXT_BUSY) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_EXT_BUSY,\n\t\t\t      survey->time_ext_busy, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_RX) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_RX,\n\t\t\t      survey->time_rx, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_TX) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_TX,\n\t\t\t      survey->time_tx, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_SCAN) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_SCAN,\n\t\t\t      survey->time_scan, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_BSS_RX) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_BSS_RX,\n\t\t\t      survey->time_bss_rx, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, infoattr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_survey(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlattr **attrbuf;\n\tstruct survey_info survey;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tint survey_idx = cb->args[2];\n\tint res;\n\tbool radio_stats;\n\n\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf), GFP_KERNEL);\n\tif (!attrbuf)\n\t\treturn -ENOMEM;\n\n\tres = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (res) {\n\t\tkfree(attrbuf);\n\t\treturn res;\n\t}\n\n\t/* prepare_wdev_dump parsed the attributes */\n\tradio_stats = attrbuf[NL80211_ATTR_SURVEY_RADIO_STATS];\n\n\tif (!wdev->netdev) {\n\t\tres = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tif (!rdev->ops->dump_survey) {\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\tres = rdev_dump_survey(rdev, wdev->netdev, survey_idx, &survey);\n\t\tif (res == -ENOENT)\n\t\t\tbreak;\n\t\tif (res)\n\t\t\tgoto out_err;\n\n\t\t/* don't send disabled channels, but do send non-channel data */\n\t\tif (survey.channel &&\n\t\t    survey.channel->flags & IEEE80211_CHAN_DISABLED) {\n\t\t\tsurvey_idx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nl80211_send_survey(skb,\n\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\twdev->netdev, radio_stats, &survey) < 0)\n\t\t\tgoto out;\n\t\tsurvey_idx++;\n\t}\n\n out:\n\tcb->args[2] = survey_idx;\n\tres = skb->len;\n out_err:\n\tkfree(attrbuf);\n\tmutex_unlock(&rdev->wiphy.mtx);\n\treturn res;\n}\n\nstatic bool nl80211_valid_wpa_versions(u32 wpa_versions)\n{\n\treturn !(wpa_versions & ~(NL80211_WPA_VERSION_1 |\n\t\t\t\t  NL80211_WPA_VERSION_2 |\n\t\t\t\t  NL80211_WPA_VERSION_3));\n}\n\nstatic int nl80211_authenticate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ieee80211_channel *chan;\n\tconst u8 *bssid, *ssid, *ie = NULL, *auth_data = NULL;\n\tint err, ssid_len, ie_len = 0, auth_data_len = 0;\n\tenum nl80211_auth_type auth_type;\n\tstruct key_parse key;\n\tbool local_state_change;\n\tu32 freq;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_AUTH_TYPE])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_SSID])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (key.idx >= 0) {\n\t\tif (key.type != -1 && key.type != NL80211_KEYTYPE_GROUP)\n\t\t\treturn -EINVAL;\n\t\tif (!key.p.key || !key.p.key_len)\n\t\t\treturn -EINVAL;\n\t\tif ((key.p.cipher != WLAN_CIPHER_SUITE_WEP40 ||\n\t\t     key.p.key_len != WLAN_KEY_LEN_WEP40) &&\n\t\t    (key.p.cipher != WLAN_CIPHER_SUITE_WEP104 ||\n\t\t     key.p.key_len != WLAN_KEY_LEN_WEP104))\n\t\t\treturn -EINVAL;\n\t\tif (key.idx > 3)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tkey.p.key_len = 0;\n\t\tkey.p.key = NULL;\n\t}\n\n\tif (key.idx >= 0) {\n\t\tint i;\n\t\tbool ok = false;\n\n\t\tfor (i = 0; i < rdev->wiphy.n_cipher_suites; i++) {\n\t\t\tif (key.p.cipher == rdev->wiphy.cipher_suites[i]) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->auth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tfreq = MHZ_TO_KHZ(nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET])\n\t\tfreq +=\n\t\t    nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET]);\n\n\tchan = nl80211_get_valid_chan(&rdev->wiphy, freq);\n\tif (!chan)\n\t\treturn -EINVAL;\n\n\tssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tauth_type = nla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\tif (!nl80211_valid_auth_type(rdev, auth_type, NL80211_CMD_AUTHENTICATE))\n\t\treturn -EINVAL;\n\n\tif ((auth_type == NL80211_AUTHTYPE_SAE ||\n\t     auth_type == NL80211_AUTHTYPE_FILS_SK ||\n\t     auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t     auth_type == NL80211_AUTHTYPE_FILS_PK) &&\n\t    !info->attrs[NL80211_ATTR_AUTH_DATA])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_AUTH_DATA]) {\n\t\tif (auth_type != NL80211_AUTHTYPE_SAE &&\n\t\t    auth_type != NL80211_AUTHTYPE_FILS_SK &&\n\t\t    auth_type != NL80211_AUTHTYPE_FILS_SK_PFS &&\n\t\t    auth_type != NL80211_AUTHTYPE_FILS_PK)\n\t\t\treturn -EINVAL;\n\t\tauth_data = nla_data(info->attrs[NL80211_ATTR_AUTH_DATA]);\n\t\tauth_data_len = nla_len(info->attrs[NL80211_ATTR_AUTH_DATA]);\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\t/*\n\t * Since we no longer track auth state, ignore\n\t * requests to only change local state.\n\t */\n\tif (local_state_change)\n\t\treturn 0;\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = cfg80211_mlme_auth(rdev, dev, chan, auth_type, bssid,\n\t\t\t\t ssid, ssid_len, ie, ie_len,\n\t\t\t\t key.p.key, key.p.key_len, key.idx,\n\t\t\t\t auth_data, auth_data_len);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn err;\n}\n\nstatic int validate_pae_over_nl80211(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct genl_info *info)\n{\n\tif (!info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\tGENL_SET_ERR_MSG(info, \"SOCKET_OWNER not set\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->tx_control_port ||\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int nl80211_crypto_settings(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct genl_info *info,\n\t\t\t\t   struct cfg80211_crypto_settings *settings,\n\t\t\t\t   int cipher_limit)\n{\n\tmemset(settings, 0, sizeof(*settings));\n\n\tsettings->control_port = info->attrs[NL80211_ATTR_CONTROL_PORT];\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]) {\n\t\tu16 proto;\n\n\t\tproto = nla_get_u16(\n\t\t\tinfo->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]);\n\t\tsettings->control_port_ethertype = cpu_to_be16(proto);\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_CONTROL_PORT_PROTOCOL) &&\n\t\t    proto != ETH_P_PAE)\n\t\t\treturn -EINVAL;\n\t\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT])\n\t\t\tsettings->control_port_no_encrypt = true;\n\t} else\n\t\tsettings->control_port_ethertype = cpu_to_be16(ETH_P_PAE);\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_OVER_NL80211]) {\n\t\tint r = validate_pae_over_nl80211(rdev, info);\n\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tsettings->control_port_over_nl80211 = true;\n\n\t\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_NO_PREAUTH])\n\t\t\tsettings->control_port_no_preauth = true;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]) {\n\t\tvoid *data;\n\t\tint len, i;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]);\n\t\tsettings->n_ciphers_pairwise = len / sizeof(u32);\n\n\t\tif (len % sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tif (settings->n_ciphers_pairwise > cipher_limit)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(settings->ciphers_pairwise, data, len);\n\n\t\tfor (i = 0; i < settings->n_ciphers_pairwise; i++)\n\t\t\tif (!cfg80211_supported_cipher_suite(\n\t\t\t\t\t&rdev->wiphy,\n\t\t\t\t\tsettings->ciphers_pairwise[i]))\n\t\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_CIPHER_SUITE_GROUP]) {\n\t\tsettings->cipher_group =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_CIPHER_SUITE_GROUP]);\n\t\tif (!cfg80211_supported_cipher_suite(&rdev->wiphy,\n\t\t\t\t\t\t     settings->cipher_group))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WPA_VERSIONS]) {\n\t\tsettings->wpa_versions =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_WPA_VERSIONS]);\n\t\tif (!nl80211_valid_wpa_versions(settings->wpa_versions))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_AKM_SUITES]) {\n\t\tvoid *data;\n\t\tint len;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_AKM_SUITES]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_AKM_SUITES]);\n\t\tsettings->n_akm_suites = len / sizeof(u32);\n\n\t\tif (len % sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tif (settings->n_akm_suites > NL80211_MAX_NR_AKM_SUITES)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(settings->akm_suites, data, len);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PMK]) {\n\t\tif (nla_len(info->attrs[NL80211_ATTR_PMK]) != WLAN_PMK_LEN)\n\t\t\treturn -EINVAL;\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK))\n\t\t\treturn -EINVAL;\n\t\tsettings->psk = nla_data(info->attrs[NL80211_ATTR_PMK]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SAE_PASSWORD]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SAE_OFFLOAD) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SAE_OFFLOAD_AP))\n\t\t\treturn -EINVAL;\n\t\tsettings->sae_pwd =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_SAE_PASSWORD]);\n\t\tsettings->sae_pwd_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_SAE_PASSWORD]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SAE_PWE])\n\t\tsettings->sae_pwe =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_SAE_PWE]);\n\telse\n\t\tsettings->sae_pwe = NL80211_SAE_PWE_UNSPECIFIED;\n\n\treturn 0;\n}\n\nstatic int nl80211_associate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ieee80211_channel *chan;\n\tstruct cfg80211_assoc_request req = {};\n\tconst u8 *bssid, *ssid;\n\tint err, ssid_len = 0;\n\tu32 freq;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_SSID] ||\n\t    !info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->assoc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tfreq = MHZ_TO_KHZ(nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET])\n\t\tfreq +=\n\t\t    nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET]);\n\tchan = nl80211_get_valid_chan(&rdev->wiphy, freq);\n\tif (!chan)\n\t\treturn -EINVAL;\n\n\tssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\treq.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\treq.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_USE_MFP]) {\n\t\tenum nl80211_mfp mfp =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_USE_MFP]);\n\t\tif (mfp == NL80211_MFP_REQUIRED)\n\t\t\treq.use_mfp = true;\n\t\telse if (mfp != NL80211_MFP_NO)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PREV_BSSID])\n\t\treq.prev_bssid = nla_data(info->attrs[NL80211_ATTR_PREV_BSSID]);\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_HT]))\n\t\treq.flags |= ASSOC_REQ_DISABLE_HT;\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\tmemcpy(&req.ht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]),\n\t\t       sizeof(req.ht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&req.ht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]),\n\t\t       sizeof(req.ht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_VHT]))\n\t\treq.flags |= ASSOC_REQ_DISABLE_VHT;\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK])\n\t\tmemcpy(&req.vht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK]),\n\t\t       sizeof(req.vht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&req.vht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]),\n\t\t       sizeof(req.vht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_USE_RRM])) {\n\t\tif (!((rdev->wiphy.features &\n\t\t\tNL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES) &&\n\t\t       (rdev->wiphy.features & NL80211_FEATURE_QUIET)) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_RRM))\n\t\t\treturn -EINVAL;\n\t\treq.flags |= ASSOC_REQ_USE_RRM;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_FILS_KEK]) {\n\t\treq.fils_kek = nla_data(info->attrs[NL80211_ATTR_FILS_KEK]);\n\t\treq.fils_kek_len = nla_len(info->attrs[NL80211_ATTR_FILS_KEK]);\n\t\tif (!info->attrs[NL80211_ATTR_FILS_NONCES])\n\t\t\treturn -EINVAL;\n\t\treq.fils_nonces =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_NONCES]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_S1G_CAPABILITY_MASK]) {\n\t\tif (!info->attrs[NL80211_ATTR_S1G_CAPABILITY])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&req.s1g_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_S1G_CAPABILITY_MASK]),\n\t\t       sizeof(req.s1g_capa_mask));\n\t}\n\n\tif (info->attrs[NL80211_ATTR_S1G_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_S1G_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&req.s1g_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_S1G_CAPABILITY]),\n\t\t       sizeof(req.s1g_capa));\n\t}\n\n\terr = nl80211_crypto_settings(rdev, info, &req.crypto, 1);\n\tif (!err) {\n\t\twdev_lock(dev->ieee80211_ptr);\n\n\t\terr = cfg80211_mlme_assoc(rdev, dev, chan, bssid,\n\t\t\t\t\t  ssid, ssid_len, &req);\n\n\t\tif (!err && info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\t\tdev->ieee80211_ptr->conn_owner_nlportid =\n\t\t\t\tinfo->snd_portid;\n\t\t\tmemcpy(dev->ieee80211_ptr->disconnect_bssid,\n\t\t\t       bssid, ETH_ALEN);\n\t\t}\n\n\t\twdev_unlock(dev->ieee80211_ptr);\n\t}\n\n\treturn err;\n}\n\nstatic int nl80211_deauthenticate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tconst u8 *ie = NULL, *bssid;\n\tint ie_len = 0, err;\n\tu16 reason_code;\n\tbool local_state_change;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->deauth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treason_code = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\tif (reason_code == 0) {\n\t\t/* Reason Code 0 is reserved */\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = cfg80211_mlme_deauth(rdev, dev, bssid, ie, ie_len, reason_code,\n\t\t\t\t   local_state_change);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn err;\n}\n\nstatic int nl80211_disassociate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tconst u8 *ie = NULL, *bssid;\n\tint ie_len = 0, err;\n\tu16 reason_code;\n\tbool local_state_change;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->disassoc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treason_code = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\tif (reason_code == 0) {\n\t\t/* Reason Code 0 is reserved */\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = cfg80211_mlme_disassoc(rdev, dev, bssid, ie, ie_len, reason_code,\n\t\t\t\t     local_state_change);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn err;\n}\n\nstatic bool\nnl80211_parse_mcast_rate(struct cfg80211_registered_device *rdev,\n\t\t\t int mcast_rate[NUM_NL80211_BANDS],\n\t\t\t int rateval)\n{\n\tstruct wiphy *wiphy = &rdev->wiphy;\n\tbool found = false;\n\tint band, i;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tsband = wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\tif (sband->bitrates[i].bitrate == rateval) {\n\t\t\t\tmcast_rate[band] = i + 1;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic int nl80211_join_ibss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_ibss_params ibss;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tint err;\n\n\tmemset(&ibss, 0, sizeof(ibss));\n\n\tif (!info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tibss.beacon_interval = 100;\n\n\tif (info->attrs[NL80211_ATTR_BEACON_INTERVAL])\n\t\tibss.beacon_interval =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\n\terr = cfg80211_validate_beacon_int(rdev, NL80211_IFTYPE_ADHOC,\n\t\t\t\t\t   ibss.beacon_interval);\n\tif (err)\n\t\treturn err;\n\n\tif (!rdev->ops->join_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_MAC]) {\n\t\tibss.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\t\tif (!is_valid_ether_addr(ibss.bssid))\n\t\t\treturn -EINVAL;\n\t}\n\tibss.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tibss.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tibss.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tibss.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\terr = nl80211_parse_chandef(rdev, info, &ibss.chandef);\n\tif (err)\n\t\treturn err;\n\n\tif (!cfg80211_reg_can_beacon(&rdev->wiphy, &ibss.chandef,\n\t\t\t\t     NL80211_IFTYPE_ADHOC))\n\t\treturn -EINVAL;\n\n\tswitch (ibss.chandef.width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_HT_IBSS))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_HT_IBSS))\n\t\t\treturn -EINVAL;\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_VHT_IBSS))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tibss.channel_fixed = !!info->attrs[NL80211_ATTR_FREQ_FIXED];\n\tibss.privacy = !!info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tu8 *rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tint n_rates =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\twiphy->bands[ibss.chandef.chan->band];\n\n\t\terr = ieee80211_get_ratemask(sband, rates, n_rates,\n\t\t\t\t\t     &ibss.basic_rates);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\tmemcpy(&ibss.ht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]),\n\t\t       sizeof(ibss.ht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&ibss.ht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]),\n\t\t       sizeof(ibss.ht_capa));\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MCAST_RATE] &&\n\t    !nl80211_parse_mcast_rate(rdev, ibss.mcast_rate,\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE])))\n\t\treturn -EINVAL;\n\n\tif (ibss.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tbool no_ht = false;\n\n\t\tconnkeys = nl80211_parse_connkeys(rdev, info, &no_ht);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\n\t\tif ((ibss.chandef.width != NL80211_CHAN_WIDTH_20_NOHT) &&\n\t\t    no_ht) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tibss.control_port =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_CONTROL_PORT]);\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_OVER_NL80211]) {\n\t\tint r = validate_pae_over_nl80211(rdev, info);\n\n\t\tif (r < 0) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn r;\n\t\t}\n\n\t\tibss.control_port_over_nl80211 = true;\n\t}\n\n\tibss.userspace_handles_dfs =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_HANDLE_DFS]);\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = __cfg80211_join_ibss(rdev, dev, &ibss, connkeys);\n\tif (err)\n\t\tkfree_sensitive(connkeys);\n\telse if (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\tdev->ieee80211_ptr->conn_owner_nlportid = info->snd_portid;\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_leave_ibss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->leave_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\treturn cfg80211_leave_ibss(rdev, dev, false);\n}\n\nstatic int nl80211_set_mcast_rate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tint mcast_rate[NUM_NL80211_BANDS];\n\tu32 nla_rate;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_OCB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->set_mcast_rate)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(mcast_rate, 0, sizeof(mcast_rate));\n\n\tif (!info->attrs[NL80211_ATTR_MCAST_RATE])\n\t\treturn -EINVAL;\n\n\tnla_rate = nla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE]);\n\tif (!nl80211_parse_mcast_rate(rdev, mcast_rate, nla_rate))\n\t\treturn -EINVAL;\n\n\terr = rdev_set_mcast_rate(rdev, dev, mcast_rate);\n\n\treturn err;\n}\n\nstatic struct sk_buff *\n__cfg80211_alloc_vendor_skb(struct cfg80211_registered_device *rdev,\n\t\t\t    struct wireless_dev *wdev, int approxlen,\n\t\t\t    u32 portid, u32 seq, enum nl80211_commands cmd,\n\t\t\t    enum nl80211_attrs attr,\n\t\t\t    const struct nl80211_vendor_cmd_info *info,\n\t\t\t    gfp_t gfp)\n{\n\tstruct sk_buff *skb;\n\tvoid *hdr;\n\tstruct nlattr *data;\n\n\tskb = nlmsg_new(approxlen + 100, gfp);\n\tif (!skb)\n\t\treturn NULL;\n\n\thdr = nl80211hdr_put(skb, portid, seq, 0, cmd);\n\tif (!hdr) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tif (nla_put_u32(skb, NL80211_ATTR_WIPHY, rdev->wiphy_idx))\n\t\tgoto nla_put_failure;\n\n\tif (info) {\n\t\tif (nla_put_u32(skb, NL80211_ATTR_VENDOR_ID,\n\t\t\t\tinfo->vendor_id))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, NL80211_ATTR_VENDOR_SUBCMD,\n\t\t\t\tinfo->subcmd))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (wdev) {\n\t\tif (nla_put_u64_64bit(skb, NL80211_ATTR_WDEV,\n\t\t\t\t      wdev_id(wdev), NL80211_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\t\tif (wdev->netdev &&\n\t\t    nla_put_u32(skb, NL80211_ATTR_IFINDEX,\n\t\t\t\twdev->netdev->ifindex))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tdata = nla_nest_start_noflag(skb, attr);\n\tif (!data)\n\t\tgoto nla_put_failure;\n\n\t((void **)skb->cb)[0] = rdev;\n\t((void **)skb->cb)[1] = hdr;\n\t((void **)skb->cb)[2] = data;\n\n\treturn skb;\n\n nla_put_failure:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstruct sk_buff *__cfg80211_alloc_event_skb(struct wiphy *wiphy,\n\t\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t\t   enum nl80211_commands cmd,\n\t\t\t\t\t   enum nl80211_attrs attr,\n\t\t\t\t\t   unsigned int portid,\n\t\t\t\t\t   int vendor_event_idx,\n\t\t\t\t\t   int approxlen, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tconst struct nl80211_vendor_cmd_info *info;\n\n\tswitch (cmd) {\n\tcase NL80211_CMD_TESTMODE:\n\t\tif (WARN_ON(vendor_event_idx != -1))\n\t\t\treturn NULL;\n\t\tinfo = NULL;\n\t\tbreak;\n\tcase NL80211_CMD_VENDOR:\n\t\tif (WARN_ON(vendor_event_idx < 0 ||\n\t\t\t    vendor_event_idx >= wiphy->n_vendor_events))\n\t\t\treturn NULL;\n\t\tinfo = &wiphy->vendor_events[vendor_event_idx];\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\treturn __cfg80211_alloc_vendor_skb(rdev, wdev, approxlen, portid, 0,\n\t\t\t\t\t   cmd, attr, info, gfp);\n}\nEXPORT_SYMBOL(__cfg80211_alloc_event_skb);\n\nvoid __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];\n\tvoid *hdr = ((void **)skb->cb)[1];\n\tstruct nlmsghdr *nlhdr = nlmsg_hdr(skb);\n\tstruct nlattr *data = ((void **)skb->cb)[2];\n\tenum nl80211_multicast_groups mcgrp = NL80211_MCGRP_TESTMODE;\n\n\t/* clear CB data for netlink core to own from now on */\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\tnla_nest_end(skb, data);\n\tgenlmsg_end(skb, hdr);\n\n\tif (nlhdr->nlmsg_pid) {\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), skb,\n\t\t\t\tnlhdr->nlmsg_pid);\n\t} else {\n\t\tif (data->nla_type == NL80211_ATTR_VENDOR_DATA)\n\t\t\tmcgrp = NL80211_MCGRP_VENDOR;\n\n\t\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),\n\t\t\t\t\tskb, 0, mcgrp, gfp);\n\t}\n}\nEXPORT_SYMBOL(__cfg80211_send_event_skb);\n\n#ifdef CONFIG_NL80211_TESTMODE\nstatic int nl80211_testmode_do(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev;\n\tint err;\n\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\twdev = __cfg80211_wdev_from_attrs(rdev, genl_info_net(info),\n\t\t\t\t\t  info->attrs);\n\n\tif (!rdev->ops->testmode_cmd)\n\t\treturn -EOPNOTSUPP;\n\n\tif (IS_ERR(wdev)) {\n\t\terr = PTR_ERR(wdev);\n\t\tif (err != -EINVAL)\n\t\t\treturn err;\n\t\twdev = NULL;\n\t} else if (wdev->wiphy != &rdev->wiphy) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_TESTDATA])\n\t\treturn -EINVAL;\n\n\trdev->cur_cmd_info = info;\n\terr = rdev_testmode_cmd(rdev, wdev,\n\t\t\t\tnla_data(info->attrs[NL80211_ATTR_TESTDATA]),\n\t\t\t\tnla_len(info->attrs[NL80211_ATTR_TESTDATA]));\n\trdev->cur_cmd_info = NULL;\n\n\treturn err;\n}\n\nstatic int nl80211_testmode_dump(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct nlattr **attrbuf = NULL;\n\tint err;\n\tlong phy_idx;\n\tvoid *data = NULL;\n\tint data_len = 0;\n\n\trtnl_lock();\n\n\tif (cb->args[0]) {\n\t\t/*\n\t\t * 0 is a valid index, but not valid for args[0],\n\t\t * so we need to offset by 1.\n\t\t */\n\t\tphy_idx = cb->args[0] - 1;\n\n\t\trdev = cfg80211_rdev_by_wiphy_idx(phy_idx);\n\t\tif (!rdev) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!attrbuf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\terr = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t\t     attrbuf, nl80211_fam.maxattr,\n\t\t\t\t\t     nl80211_policy, NULL);\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\trdev = __cfg80211_rdev_from_attrs(sock_net(skb->sk), attrbuf);\n\t\tif (IS_ERR(rdev)) {\n\t\t\terr = PTR_ERR(rdev);\n\t\t\tgoto out_err;\n\t\t}\n\t\tphy_idx = rdev->wiphy_idx;\n\n\t\tif (attrbuf[NL80211_ATTR_TESTDATA])\n\t\t\tcb->args[1] = (long)attrbuf[NL80211_ATTR_TESTDATA];\n\t}\n\n\tif (cb->args[1]) {\n\t\tdata = nla_data((void *)cb->args[1]);\n\t\tdata_len = nla_len((void *)cb->args[1]);\n\t}\n\n\tif (!rdev->ops->testmode_dump) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\tvoid *hdr = nl80211hdr_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t   cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t   NL80211_CMD_TESTMODE);\n\t\tstruct nlattr *tmdata;\n\n\t\tif (!hdr)\n\t\t\tbreak;\n\n\t\tif (nla_put_u32(skb, NL80211_ATTR_WIPHY, phy_idx)) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\n\t\ttmdata = nla_nest_start_noflag(skb, NL80211_ATTR_TESTDATA);\n\t\tif (!tmdata) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\t\terr = rdev_testmode_dump(rdev, skb, cb, data, data_len);\n\t\tnla_nest_end(skb, tmdata);\n\n\t\tif (err == -ENOBUFS || err == -ENOENT) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t} else if (err) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tgenlmsg_end(skb, hdr);\n\t}\n\n\terr = skb->len;\n\t/* see above */\n\tcb->args[0] = phy_idx + 1;\n out_err:\n\tkfree(attrbuf);\n\trtnl_unlock();\n\treturn err;\n}\n#endif\n\nstatic int nl80211_connect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_connect_params connect;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tu32 freq = 0;\n\tint err;\n\n\tmemset(&connect, 0, sizeof(connect));\n\n\tif (!info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tconnect.auth_type =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(rdev, connect.auth_type,\n\t\t\t\t\t     NL80211_CMD_CONNECT))\n\t\t\treturn -EINVAL;\n\t} else\n\t\tconnect.auth_type = NL80211_AUTHTYPE_AUTOMATIC;\n\n\tconnect.privacy = info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_WANT_1X_4WAY_HS] &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X))\n\t\treturn -EINVAL;\n\tconnect.want_1x = info->attrs[NL80211_ATTR_WANT_1X_4WAY_HS];\n\n\terr = nl80211_crypto_settings(rdev, info, &connect.crypto,\n\t\t\t\t      NL80211_MAX_NR_CIPHER_SUITES);\n\tif (err)\n\t\treturn err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tconnect.bg_scan_period = -1;\n\tif (info->attrs[NL80211_ATTR_BG_SCAN_PERIOD] &&\n\t\t(wiphy->flags & WIPHY_FLAG_SUPPORTS_FW_ROAM)) {\n\t\tconnect.bg_scan_period =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_BG_SCAN_PERIOD]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tconnect.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\telse if (info->attrs[NL80211_ATTR_MAC_HINT])\n\t\tconnect.bssid_hint =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MAC_HINT]);\n\tconnect.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tconnect.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tconnect.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tconnect.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_USE_MFP]) {\n\t\tconnect.mfp = nla_get_u32(info->attrs[NL80211_ATTR_USE_MFP]);\n\t\tif (connect.mfp == NL80211_MFP_OPTIONAL &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_MFP_OPTIONAL))\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\tconnect.mfp = NL80211_MFP_NO;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PREV_BSSID])\n\t\tconnect.prev_bssid =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_PREV_BSSID]);\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\tfreq = MHZ_TO_KHZ(nla_get_u32(\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET])\n\t\tfreq +=\n\t\t    nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET]);\n\n\tif (freq) {\n\t\tconnect.channel = nl80211_get_valid_chan(wiphy, freq);\n\t\tif (!connect.channel)\n\t\t\treturn -EINVAL;\n\t} else if (info->attrs[NL80211_ATTR_WIPHY_FREQ_HINT]) {\n\t\tfreq = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ_HINT]);\n\t\tfreq = MHZ_TO_KHZ(freq);\n\t\tconnect.channel_hint = nl80211_get_valid_chan(wiphy, freq);\n\t\tif (!connect.channel_hint)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]) {\n\t\tconnect.edmg.channels =\n\t\t      nla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]);\n\n\t\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG])\n\t\t\tconnect.edmg.bw_config =\n\t\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG]);\n\t}\n\n\tif (connect.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tconnkeys = nl80211_parse_connkeys(rdev, info, NULL);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_HT]))\n\t\tconnect.flags |= ASSOC_REQ_DISABLE_HT;\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\tmemcpy(&connect.ht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]),\n\t\t       sizeof(connect.ht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(&connect.ht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]),\n\t\t       sizeof(connect.ht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_VHT]))\n\t\tconnect.flags |= ASSOC_REQ_DISABLE_VHT;\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK])\n\t\tmemcpy(&connect.vht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK]),\n\t\t       sizeof(connect.vht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK]) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(&connect.vht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]),\n\t\t       sizeof(connect.vht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_USE_RRM])) {\n\t\tif (!((rdev->wiphy.features &\n\t\t\tNL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES) &&\n\t\t       (rdev->wiphy.features & NL80211_FEATURE_QUIET)) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_RRM)) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tconnect.flags |= ASSOC_REQ_USE_RRM;\n\t}\n\n\tconnect.pbss = nla_get_flag(info->attrs[NL80211_ATTR_PBSS]);\n\tif (connect.pbss && !rdev->wiphy.bands[NL80211_BAND_60GHZ]) {\n\t\tkfree_sensitive(connkeys);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_BSS_SELECT]) {\n\t\t/* bss selection makes no sense if bssid is set */\n\t\tif (connect.bssid) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = parse_bss_select(info->attrs[NL80211_ATTR_BSS_SELECT],\n\t\t\t\t       wiphy, &connect.bss_select);\n\t\tif (err) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_FILS_SK_OFFLOAD) &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_REALM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\tconnect.fils_erp_username =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_username_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_realm =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_realm_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_next_seq_num =\n\t\t\tnla_get_u16(\n\t\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM]);\n\t\tconnect.fils_erp_rrk =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t\tconnect.fils_erp_rrk_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t} else if (info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_REALM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\tkfree_sensitive(connkeys);\n\t\treturn -EINVAL;\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_EXTERNAL_AUTH_SUPPORT])) {\n\t\tif (!info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t \"external auth requires connection ownership\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tconnect.flags |= CONNECT_REQ_EXTERNAL_AUTH_SUPPORT;\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\n\terr = cfg80211_connect(rdev, dev, &connect, connkeys,\n\t\t\t       connect.prev_bssid);\n\tif (err)\n\t\tkfree_sensitive(connkeys);\n\n\tif (!err && info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\tdev->ieee80211_ptr->conn_owner_nlportid = info->snd_portid;\n\t\tif (connect.bssid)\n\t\t\tmemcpy(dev->ieee80211_ptr->disconnect_bssid,\n\t\t\t       connect.bssid, ETH_ALEN);\n\t\telse\n\t\t\teth_zero_addr(dev->ieee80211_ptr->disconnect_bssid);\n\t}\n\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_update_connect_params(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tstruct cfg80211_connect_params connect = {};\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tbool fils_sk_offload;\n\tu32 auth_type;\n\tu32 changed = 0;\n\tint ret;\n\n\tif (!rdev->ops->update_connect_params)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tconnect.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tconnect.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tchanged |= UPDATE_ASSOC_IES;\n\t}\n\n\tfils_sk_offload = wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t\t  NL80211_EXT_FEATURE_FILS_SK_OFFLOAD);\n\n\t/*\n\t * when driver supports fils-sk offload all attributes must be\n\t * provided. So the else covers \"fils-sk-not-all\" and\n\t * \"no-fils-sk-any\".\n\t */\n\tif (fils_sk_offload &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_REALM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\tconnect.fils_erp_username =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_username_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_realm =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_realm_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_next_seq_num =\n\t\t\tnla_get_u16(\n\t\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM]);\n\t\tconnect.fils_erp_rrk =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t\tconnect.fils_erp_rrk_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t\tchanged |= UPDATE_FILS_ERP_INFO;\n\t} else if (info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_REALM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tauth_type = nla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(rdev, auth_type,\n\t\t\t\t\t     NL80211_CMD_CONNECT))\n\t\t\treturn -EINVAL;\n\n\t\tif (auth_type == NL80211_AUTHTYPE_FILS_SK &&\n\t\t    fils_sk_offload && !(changed & UPDATE_FILS_ERP_INFO))\n\t\t\treturn -EINVAL;\n\n\t\tconnect.auth_type = auth_type;\n\t\tchanged |= UPDATE_AUTH_TYPE;\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\tif (!wdev->current_bss)\n\t\tret = -ENOLINK;\n\telse\n\t\tret = rdev_update_connect_params(rdev, dev, &connect, changed);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn ret;\n}\n\nstatic int nl80211_disconnect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu16 reason;\n\tint ret;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treason = WLAN_REASON_DEAUTH_LEAVING;\n\telse\n\t\treason = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\n\tif (reason == 0)\n\t\treturn -EINVAL;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(dev->ieee80211_ptr);\n\tret = cfg80211_disconnect(rdev, dev, reason, true);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn ret;\n}\n\nstatic int nl80211_wiphy_netns(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net *net;\n\tint err;\n\n\tif (info->attrs[NL80211_ATTR_PID]) {\n\t\tu32 pid = nla_get_u32(info->attrs[NL80211_ATTR_PID]);\n\n\t\tnet = get_net_ns_by_pid(pid);\n\t} else if (info->attrs[NL80211_ATTR_NETNS_FD]) {\n\t\tu32 fd = nla_get_u32(info->attrs[NL80211_ATTR_NETNS_FD]);\n\n\t\tnet = get_net_ns_by_fd(fd);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\terr = 0;\n\n\t/* check if anything to do */\n\tif (!net_eq(wiphy_net(&rdev->wiphy), net))\n\t\terr = cfg80211_switch_netns(rdev, net);\n\n\tput_net(net);\n\treturn err;\n}\n\nstatic int nl80211_setdel_pmksa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint (*rdev_ops)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tstruct cfg80211_pmksa *pmksa) = NULL;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_pmksa pmksa;\n\n\tmemset(&pmksa, 0, sizeof(struct cfg80211_pmksa));\n\n\tif (!info->attrs[NL80211_ATTR_PMKID])\n\t\treturn -EINVAL;\n\n\tpmksa.pmkid = nla_data(info->attrs[NL80211_ATTR_PMKID]);\n\n\tif (info->attrs[NL80211_ATTR_MAC]) {\n\t\tpmksa.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\t} else if (info->attrs[NL80211_ATTR_SSID] &&\n\t\t   info->attrs[NL80211_ATTR_FILS_CACHE_ID] &&\n\t\t   (info->genlhdr->cmd == NL80211_CMD_DEL_PMKSA ||\n\t\t    info->attrs[NL80211_ATTR_PMK])) {\n\t\tpmksa.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\t\tpmksa.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\t\tpmksa.cache_id =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_CACHE_ID]);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (info->attrs[NL80211_ATTR_PMK]) {\n\t\tpmksa.pmk = nla_data(info->attrs[NL80211_ATTR_PMK]);\n\t\tpmksa.pmk_len = nla_len(info->attrs[NL80211_ATTR_PMK]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PMK_LIFETIME])\n\t\tpmksa.pmk_lifetime =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_PMK_LIFETIME]);\n\n\tif (info->attrs[NL80211_ATTR_PMK_REAUTH_THRESHOLD])\n\t\tpmksa.pmk_reauth_threshold =\n\t\t\tnla_get_u8(\n\t\t\t\tinfo->attrs[NL80211_ATTR_PMK_REAUTH_THRESHOLD]);\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT &&\n\t    !(dev->ieee80211_ptr->iftype == NL80211_IFTYPE_AP &&\n\t      wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_AP_PMKSA_CACHING)))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (info->genlhdr->cmd) {\n\tcase NL80211_CMD_SET_PMKSA:\n\t\trdev_ops = rdev->ops->set_pmksa;\n\t\tbreak;\n\tcase NL80211_CMD_DEL_PMKSA:\n\t\trdev_ops = rdev->ops->del_pmksa;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tif (!rdev_ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_ops(&rdev->wiphy, dev, &pmksa);\n}\n\nstatic int nl80211_flush_pmksa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->flush_pmksa)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_flush_pmksa(rdev, dev);\n}\n\nstatic int nl80211_tdls_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 action_code, dialog_token;\n\tu32 peer_capability = 0;\n\tu16 status_code;\n\tu8 *peer;\n\tbool initiator;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) ||\n\t    !rdev->ops->tdls_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_TDLS_ACTION] ||\n\t    !info->attrs[NL80211_ATTR_STATUS_CODE] ||\n\t    !info->attrs[NL80211_ATTR_TDLS_DIALOG_TOKEN] ||\n\t    !info->attrs[NL80211_ATTR_IE] ||\n\t    !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\taction_code = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_ACTION]);\n\tstatus_code = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);\n\tdialog_token = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_DIALOG_TOKEN]);\n\tinitiator = nla_get_flag(info->attrs[NL80211_ATTR_TDLS_INITIATOR]);\n\tif (info->attrs[NL80211_ATTR_TDLS_PEER_CAPABILITY])\n\t\tpeer_capability =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_TDLS_PEER_CAPABILITY]);\n\n\treturn rdev_tdls_mgmt(rdev, dev, peer, action_code,\n\t\t\t      dialog_token, status_code, peer_capability,\n\t\t\t      initiator,\n\t\t\t      nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t\t      nla_len(info->attrs[NL80211_ATTR_IE]));\n}\n\nstatic int nl80211_tdls_oper(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tenum nl80211_tdls_operation operation;\n\tu8 *peer;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) ||\n\t    !rdev->ops->tdls_oper)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_TDLS_OPERATION] ||\n\t    !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\toperation = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_OPERATION]);\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treturn rdev_tdls_oper(rdev, dev, peer, operation);\n}\n\nstatic int nl80211_remain_on_channel(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_chan_def chandef;\n\tconst struct cfg80211_chan_def *compat_chandef;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu64 cookie;\n\tu32 duration;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t    !info->attrs[NL80211_ATTR_DURATION])\n\t\treturn -EINVAL;\n\n\tduration = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);\n\n\tif (!rdev->ops->remain_on_channel ||\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * We should be on that channel for at least a minimum amount of\n\t * time (10ms) but no longer than the driver supports.\n\t */\n\tif (duration < NL80211_MIN_REMAIN_ON_CHANNEL_TIME ||\n\t    duration > rdev->wiphy.max_remain_on_channel_duration)\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\tif (!cfg80211_off_channel_oper_allowed(wdev) &&\n\t    !cfg80211_chandef_identical(&wdev->chandef, &chandef)) {\n\t\tcompat_chandef = cfg80211_chandef_compatible(&wdev->chandef,\n\t\t\t\t\t\t\t     &chandef);\n\t\tif (compat_chandef != &chandef) {\n\t\t\twdev_unlock(wdev);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\twdev_unlock(wdev);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_REMAIN_ON_CHANNEL);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\terr = rdev_remain_on_channel(rdev, wdev, chandef.chan,\n\t\t\t\t     duration, &cookie);\n\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_cancel_remain_on_channel(struct sk_buff *skb,\n\t\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->cancel_remain_on_channel)\n\t\treturn -EOPNOTSUPP;\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\treturn rdev_cancel_remain_on_channel(rdev, wdev, cookie);\n}\n\nstatic int nl80211_set_tx_bitrate_mask(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_bitrate_mask mask;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tint err;\n\n\tif (!rdev->ops->set_bitrate_mask)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_tx_bitrate_mask(info, info->attrs,\n\t\t\t\t\t    NL80211_ATTR_TX_RATES, &mask,\n\t\t\t\t\t    dev, true);\n\tif (err)\n\t\treturn err;\n\n\treturn rdev_set_bitrate_mask(rdev, dev, NULL, &mask);\n}\n\nstatic int nl80211_register_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu16 frame_type = IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_ACTION;\n\n\tif (!info->attrs[NL80211_ATTR_FRAME_MATCH])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_FRAME_TYPE])\n\t\tframe_type = nla_get_u16(info->attrs[NL80211_ATTR_FRAME_TYPE]);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* not much point in registering if we can't reply */\n\tif (!rdev->ops->mgmt_tx)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_RECEIVE_MULTICAST] &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS)) {\n\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t \"multicast RX registrations are not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn cfg80211_mlme_register_mgmt(wdev, info->snd_portid, frame_type,\n\t\t\t\t\t   nla_data(info->attrs[NL80211_ATTR_FRAME_MATCH]),\n\t\t\t\t\t   nla_len(info->attrs[NL80211_ATTR_FRAME_MATCH]),\n\t\t\t\t\t   info->attrs[NL80211_ATTR_RECEIVE_MULTICAST],\n\t\t\t\t\t   info->extack);\n}\n\nstatic int nl80211_tx_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_chan_def chandef;\n\tint err;\n\tvoid *hdr = NULL;\n\tu64 cookie;\n\tstruct sk_buff *msg = NULL;\n\tstruct cfg80211_mgmt_tx_params params = {\n\t\t.dont_wait_for_ack =\n\t\t\tinfo->attrs[NL80211_ATTR_DONT_WAIT_FOR_ACK],\n\t};\n\n\tif (!info->attrs[NL80211_ATTR_FRAME])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->mgmt_tx)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_DURATION]) {\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX))\n\t\t\treturn -EINVAL;\n\t\tparams.wait = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);\n\n\t\t/*\n\t\t * We should wait on the channel for at least a minimum amount\n\t\t * of time (10ms) but no longer than the driver supports.\n\t\t */\n\t\tif (params.wait < NL80211_MIN_REMAIN_ON_CHANNEL_TIME ||\n\t\t    params.wait > rdev->wiphy.max_remain_on_channel_duration)\n\t\t\treturn -EINVAL;\n\t}\n\n\tparams.offchan = info->attrs[NL80211_ATTR_OFFCHANNEL_TX_OK];\n\n\tif (params.offchan && !(rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX))\n\t\treturn -EINVAL;\n\n\tparams.no_cck = nla_get_flag(info->attrs[NL80211_ATTR_TX_NO_CCK_RATE]);\n\n\t/* get the channel if any has been specified, otherwise pass NULL to\n\t * the driver. The latter will use the current one\n\t */\n\tchandef.chan = NULL;\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!chandef.chan && params.offchan)\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\tif (params.offchan && !cfg80211_off_channel_oper_allowed(wdev)) {\n\t\twdev_unlock(wdev);\n\t\treturn -EBUSY;\n\t}\n\twdev_unlock(wdev);\n\n\tparams.buf = nla_data(info->attrs[NL80211_ATTR_FRAME]);\n\tparams.len = nla_len(info->attrs[NL80211_ATTR_FRAME]);\n\n\tif (info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]) {\n\t\tint len = nla_len(info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]);\n\t\tint i;\n\n\t\tif (len % sizeof(u16))\n\t\t\treturn -EINVAL;\n\n\t\tparams.n_csa_offsets = len / sizeof(u16);\n\t\tparams.csa_offsets =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]);\n\n\t\t/* check that all the offsets fit the frame */\n\t\tfor (i = 0; i < params.n_csa_offsets; i++) {\n\t\t\tif (params.csa_offsets[i] >= params.len)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!params.dont_wait_for_ack) {\n\t\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\t\tif (!msg)\n\t\t\treturn -ENOMEM;\n\n\t\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t\t     NL80211_CMD_FRAME);\n\t\tif (!hdr) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto free_msg;\n\t\t}\n\t}\n\n\tparams.chan = chandef.chan;\n\terr = cfg80211_mlme_mgmt_tx(rdev, wdev, &params, &cookie);\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (msg) {\n\t\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t\t      NL80211_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\n\t\tgenlmsg_end(msg, hdr);\n\t\treturn genlmsg_reply(msg, info);\n\t}\n\n\treturn 0;\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_tx_mgmt_cancel_wait(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->mgmt_tx_cancel_wait)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\treturn rdev_mgmt_tx_cancel_wait(rdev, wdev, cookie);\n}\n\nstatic int nl80211_set_power_save(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 ps_state;\n\tbool state;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_PS_STATE])\n\t\treturn -EINVAL;\n\n\tps_state = nla_get_u32(info->attrs[NL80211_ATTR_PS_STATE]);\n\n\twdev = dev->ieee80211_ptr;\n\n\tif (!rdev->ops->set_power_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tstate = (ps_state == NL80211_PS_ENABLED) ? true : false;\n\n\tif (state == wdev->ps)\n\t\treturn 0;\n\n\terr = rdev_set_power_mgmt(rdev, dev, state, wdev->ps_timeout);\n\tif (!err)\n\t\twdev->ps = state;\n\treturn err;\n}\n\nstatic int nl80211_get_power_save(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tenum nl80211_ps_state ps_state;\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint err;\n\n\twdev = dev->ieee80211_ptr;\n\n\tif (!rdev->ops->set_power_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_POWER_SAVE);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\tif (wdev->ps)\n\t\tps_state = NL80211_PS_ENABLED;\n\telse\n\t\tps_state = NL80211_PS_DISABLED;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_PS_STATE, ps_state))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic const struct nla_policy\nnl80211_attr_cqm_policy[NL80211_ATTR_CQM_MAX + 1] = {\n\t[NL80211_ATTR_CQM_RSSI_THOLD] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_CQM_RSSI_HYST] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_TXE_RATE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_TXE_PKTS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_TXE_INTVL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_RSSI_LEVEL] = { .type = NLA_S32 },\n};\n\nstatic int nl80211_set_cqm_txe(struct genl_info *info,\n\t\t\t       u32 rate, u32 pkts, u32 intvl)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tif (rate > 100 || intvl > NL80211_CQM_TXE_MAX_INTVL)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->set_cqm_txe_config)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_set_cqm_txe_config(rdev, dev, rate, pkts, intvl);\n}\n\nstatic int cfg80211_cqm_rssi_update(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct net_device *dev)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\ts32 last, low, high;\n\tu32 hyst;\n\tint i, n, low_index;\n\tint err;\n\n\t/* RSSI reporting disabled? */\n\tif (!wdev->cqm_config)\n\t\treturn rdev_set_cqm_rssi_range_config(rdev, dev, 0, 0);\n\n\t/*\n\t * Obtain current RSSI value if possible, if not and no RSSI threshold\n\t * event has been received yet, we should receive an event after a\n\t * connection is established and enough beacons received to calculate\n\t * the average.\n\t */\n\tif (!wdev->cqm_config->last_rssi_event_value && wdev->current_bss &&\n\t    rdev->ops->get_station) {\n\t\tstruct station_info sinfo = {};\n\t\tu8 *mac_addr;\n\n\t\tmac_addr = wdev->current_bss->pub.bssid;\n\n\t\terr = rdev_get_station(rdev, dev, mac_addr, &sinfo);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcfg80211_sinfo_release_content(&sinfo);\n\t\tif (sinfo.filled & BIT_ULL(NL80211_STA_INFO_BEACON_SIGNAL_AVG))\n\t\t\twdev->cqm_config->last_rssi_event_value =\n\t\t\t\t(s8) sinfo.rx_beacon_signal_avg;\n\t}\n\n\tlast = wdev->cqm_config->last_rssi_event_value;\n\thyst = wdev->cqm_config->rssi_hyst;\n\tn = wdev->cqm_config->n_rssi_thresholds;\n\n\tfor (i = 0; i < n; i++) {\n\t\ti = array_index_nospec(i, n);\n\t\tif (last < wdev->cqm_config->rssi_thresholds[i])\n\t\t\tbreak;\n\t}\n\n\tlow_index = i - 1;\n\tif (low_index >= 0) {\n\t\tlow_index = array_index_nospec(low_index, n);\n\t\tlow = wdev->cqm_config->rssi_thresholds[low_index] - hyst;\n\t} else {\n\t\tlow = S32_MIN;\n\t}\n\tif (i < n) {\n\t\ti = array_index_nospec(i, n);\n\t\thigh = wdev->cqm_config->rssi_thresholds[i] + hyst - 1;\n\t} else {\n\t\thigh = S32_MAX;\n\t}\n\n\treturn rdev_set_cqm_rssi_range_config(rdev, dev, low, high);\n}\n\nstatic int nl80211_set_cqm_rssi(struct genl_info *info,\n\t\t\t\tconst s32 *thresholds, int n_thresholds,\n\t\t\t\tu32 hysteresis)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint i, err;\n\ts32 prev = S32_MIN;\n\n\t/* Check all values negative and sorted */\n\tfor (i = 0; i < n_thresholds; i++) {\n\t\tif (thresholds[i] > 0 || thresholds[i] <= prev)\n\t\t\treturn -EINVAL;\n\n\t\tprev = thresholds[i];\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\tcfg80211_cqm_config_free(wdev);\n\twdev_unlock(wdev);\n\n\tif (n_thresholds <= 1 && rdev->ops->set_cqm_rssi_config) {\n\t\tif (n_thresholds == 0 || thresholds[0] == 0) /* Disabling */\n\t\t\treturn rdev_set_cqm_rssi_config(rdev, dev, 0, 0);\n\n\t\treturn rdev_set_cqm_rssi_config(rdev, dev,\n\t\t\t\t\t\tthresholds[0], hysteresis);\n\t}\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_CQM_RSSI_LIST))\n\t\treturn -EOPNOTSUPP;\n\n\tif (n_thresholds == 1 && thresholds[0] == 0) /* Disabling */\n\t\tn_thresholds = 0;\n\n\twdev_lock(wdev);\n\tif (n_thresholds) {\n\t\tstruct cfg80211_cqm_config *cqm_config;\n\n\t\tcqm_config = kzalloc(sizeof(struct cfg80211_cqm_config) +\n\t\t\t\t     n_thresholds * sizeof(s32), GFP_KERNEL);\n\t\tif (!cqm_config) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tcqm_config->rssi_hyst = hysteresis;\n\t\tcqm_config->n_rssi_thresholds = n_thresholds;\n\t\tmemcpy(cqm_config->rssi_thresholds, thresholds,\n\t\t       n_thresholds * sizeof(s32));\n\n\t\twdev->cqm_config = cqm_config;\n\t}\n\n\terr = cfg80211_cqm_rssi_update(rdev, dev);\n\nunlock:\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_set_cqm(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *attrs[NL80211_ATTR_CQM_MAX + 1];\n\tstruct nlattr *cqm;\n\tint err;\n\n\tcqm = info->attrs[NL80211_ATTR_CQM];\n\tif (!cqm)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, NL80211_ATTR_CQM_MAX, cqm,\n\t\t\t\t\t  nl80211_attr_cqm_policy,\n\t\t\t\t\t  info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (attrs[NL80211_ATTR_CQM_RSSI_THOLD] &&\n\t    attrs[NL80211_ATTR_CQM_RSSI_HYST]) {\n\t\tconst s32 *thresholds =\n\t\t\tnla_data(attrs[NL80211_ATTR_CQM_RSSI_THOLD]);\n\t\tint len = nla_len(attrs[NL80211_ATTR_CQM_RSSI_THOLD]);\n\t\tu32 hysteresis = nla_get_u32(attrs[NL80211_ATTR_CQM_RSSI_HYST]);\n\n\t\tif (len % 4)\n\t\t\treturn -EINVAL;\n\n\t\treturn nl80211_set_cqm_rssi(info, thresholds, len / 4,\n\t\t\t\t\t    hysteresis);\n\t}\n\n\tif (attrs[NL80211_ATTR_CQM_TXE_RATE] &&\n\t    attrs[NL80211_ATTR_CQM_TXE_PKTS] &&\n\t    attrs[NL80211_ATTR_CQM_TXE_INTVL]) {\n\t\tu32 rate = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_RATE]);\n\t\tu32 pkts = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_PKTS]);\n\t\tu32 intvl = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_INTVL]);\n\n\t\treturn nl80211_set_cqm_txe(info, rate, pkts, intvl);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int nl80211_join_ocb(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ocb_setup setup = {};\n\tint err;\n\n\terr = nl80211_parse_chandef(rdev, info, &setup.chandef);\n\tif (err)\n\t\treturn err;\n\n\treturn cfg80211_join_ocb(rdev, dev, &setup);\n}\n\nstatic int nl80211_leave_ocb(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\treturn cfg80211_leave_ocb(rdev, dev);\n}\n\nstatic int nl80211_join_mesh(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mesh_config cfg;\n\tstruct mesh_setup setup;\n\tint err;\n\n\t/* start with default */\n\tmemcpy(&cfg, &default_mesh_config, sizeof(cfg));\n\tmemcpy(&setup, &default_mesh_setup, sizeof(setup));\n\n\tif (info->attrs[NL80211_ATTR_MESH_CONFIG]) {\n\t\t/* and parse parameters if given */\n\t\terr = nl80211_parse_mesh_config(info, &cfg, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MESH_ID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_MESH_ID]))\n\t\treturn -EINVAL;\n\n\tsetup.mesh_id = nla_data(info->attrs[NL80211_ATTR_MESH_ID]);\n\tsetup.mesh_id_len = nla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\n\tif (info->attrs[NL80211_ATTR_MCAST_RATE] &&\n\t    !nl80211_parse_mcast_rate(rdev, setup.mcast_rate,\n\t\t\t    nla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE])))\n\t\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_BEACON_INTERVAL]) {\n\t\tsetup.beacon_interval =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\n\t\terr = cfg80211_validate_beacon_int(rdev,\n\t\t\t\t\t\t   NL80211_IFTYPE_MESH_POINT,\n\t\t\t\t\t\t   setup.beacon_interval);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_DTIM_PERIOD]) {\n\t\tsetup.dtim_period =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_DTIM_PERIOD]);\n\t\tif (setup.dtim_period < 1 || setup.dtim_period > 100)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MESH_SETUP]) {\n\t\t/* parse additional setup parameters if given */\n\t\terr = nl80211_parse_mesh_setup(info, &setup);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (setup.user_mpm)\n\t\tcfg.auto_open_plinks = false;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\terr = nl80211_parse_chandef(rdev, info, &setup.chandef);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\t/* __cfg80211_join_mesh() will sort it out */\n\t\tsetup.chandef.chan = NULL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tu8 *rates = nla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tint n_rates =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tif (!setup.chandef.chan)\n\t\t\treturn -EINVAL;\n\n\t\tsband = rdev->wiphy.bands[setup.chandef.chan->band];\n\n\t\terr = ieee80211_get_ratemask(sband, rates, n_rates,\n\t\t\t\t\t     &setup.basic_rates);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TX_RATES]) {\n\t\terr = nl80211_parse_tx_bitrate_mask(info, info->attrs,\n\t\t\t\t\t\t    NL80211_ATTR_TX_RATES,\n\t\t\t\t\t\t    &setup.beacon_rate,\n\t\t\t\t\t\t    dev, false);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!setup.chandef.chan)\n\t\t\treturn -EINVAL;\n\n\t\terr = validate_beacon_tx_rate(rdev, setup.chandef.chan->band,\n\t\t\t\t\t      &setup.beacon_rate);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tsetup.userspace_handles_dfs =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_HANDLE_DFS]);\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_OVER_NL80211]) {\n\t\tint r = validate_pae_over_nl80211(rdev, info);\n\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tsetup.control_port_over_nl80211 = true;\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = __cfg80211_join_mesh(rdev, dev, &setup, &cfg);\n\tif (!err && info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\tdev->ieee80211_ptr->conn_owner_nlportid = info->snd_portid;\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_leave_mesh(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\treturn cfg80211_leave_mesh(rdev, dev);\n}\n\n#ifdef CONFIG_PM\nstatic int nl80211_send_wowlan_patterns(struct sk_buff *msg,\n\t\t\t\t\tstruct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_wowlan *wowlan = rdev->wiphy.wowlan_config;\n\tstruct nlattr *nl_pats, *nl_pat;\n\tint i, pat_len;\n\n\tif (!wowlan->n_patterns)\n\t\treturn 0;\n\n\tnl_pats = nla_nest_start_noflag(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN);\n\tif (!nl_pats)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < wowlan->n_patterns; i++) {\n\t\tnl_pat = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!nl_pat)\n\t\t\treturn -ENOBUFS;\n\t\tpat_len = wowlan->patterns[i].pattern_len;\n\t\tif (nla_put(msg, NL80211_PKTPAT_MASK, DIV_ROUND_UP(pat_len, 8),\n\t\t\t    wowlan->patterns[i].mask) ||\n\t\t    nla_put(msg, NL80211_PKTPAT_PATTERN, pat_len,\n\t\t\t    wowlan->patterns[i].pattern) ||\n\t\t    nla_put_u32(msg, NL80211_PKTPAT_OFFSET,\n\t\t\t\twowlan->patterns[i].pkt_offset))\n\t\t\treturn -ENOBUFS;\n\t\tnla_nest_end(msg, nl_pat);\n\t}\n\tnla_nest_end(msg, nl_pats);\n\n\treturn 0;\n}\n\nstatic int nl80211_send_wowlan_tcp(struct sk_buff *msg,\n\t\t\t\t   struct cfg80211_wowlan_tcp *tcp)\n{\n\tstruct nlattr *nl_tcp;\n\n\tif (!tcp)\n\t\treturn 0;\n\n\tnl_tcp = nla_nest_start_noflag(msg,\n\t\t\t\t       NL80211_WOWLAN_TRIG_TCP_CONNECTION);\n\tif (!nl_tcp)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_in_addr(msg, NL80211_WOWLAN_TCP_SRC_IPV4, tcp->src) ||\n\t    nla_put_in_addr(msg, NL80211_WOWLAN_TCP_DST_IPV4, tcp->dst) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DST_MAC, ETH_ALEN, tcp->dst_mac) ||\n\t    nla_put_u16(msg, NL80211_WOWLAN_TCP_SRC_PORT, tcp->src_port) ||\n\t    nla_put_u16(msg, NL80211_WOWLAN_TCP_DST_PORT, tcp->dst_port) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD,\n\t\t    tcp->payload_len, tcp->payload) ||\n\t    nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_INTERVAL,\n\t\t\ttcp->data_interval) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_WAKE_PAYLOAD,\n\t\t    tcp->wake_len, tcp->wake_data) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_WAKE_MASK,\n\t\t    DIV_ROUND_UP(tcp->wake_len, 8), tcp->wake_mask))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->payload_seq.len &&\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ,\n\t\t    sizeof(tcp->payload_seq), &tcp->payload_seq))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->payload_tok.len &&\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN,\n\t\t    sizeof(tcp->payload_tok) + tcp->tokens_size,\n\t\t    &tcp->payload_tok))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, nl_tcp);\n\n\treturn 0;\n}\n\nstatic int nl80211_send_wowlan_nd(struct sk_buff *msg,\n\t\t\t\t  struct cfg80211_sched_scan_request *req)\n{\n\tstruct nlattr *nd, *freqs, *matches, *match, *scan_plans, *scan_plan;\n\tint i;\n\n\tif (!req)\n\t\treturn 0;\n\n\tnd = nla_nest_start_noflag(msg, NL80211_WOWLAN_TRIG_NET_DETECT);\n\tif (!nd)\n\t\treturn -ENOBUFS;\n\n\tif (req->n_scan_plans == 1 &&\n\t    nla_put_u32(msg, NL80211_ATTR_SCHED_SCAN_INTERVAL,\n\t\t\treq->scan_plans[0].interval * 1000))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_SCHED_SCAN_DELAY, req->delay))\n\t\treturn -ENOBUFS;\n\n\tif (req->relative_rssi_set) {\n\t\tstruct nl80211_bss_select_rssi_adjust rssi_adjust;\n\n\t\tif (nla_put_s8(msg, NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI,\n\t\t\t       req->relative_rssi))\n\t\t\treturn -ENOBUFS;\n\n\t\trssi_adjust.band = req->rssi_adjust.band;\n\t\trssi_adjust.delta = req->rssi_adjust.delta;\n\t\tif (nla_put(msg, NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST,\n\t\t\t    sizeof(rssi_adjust), &rssi_adjust))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tfreqs = nla_nest_start_noflag(msg, NL80211_ATTR_SCAN_FREQUENCIES);\n\tif (!freqs)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < req->n_channels; i++) {\n\t\tif (nla_put_u32(msg, i, req->channels[i]->center_freq))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tnla_nest_end(msg, freqs);\n\n\tif (req->n_match_sets) {\n\t\tmatches = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_SCHED_SCAN_MATCH);\n\t\tif (!matches)\n\t\t\treturn -ENOBUFS;\n\n\t\tfor (i = 0; i < req->n_match_sets; i++) {\n\t\t\tmatch = nla_nest_start_noflag(msg, i);\n\t\t\tif (!match)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tif (nla_put(msg, NL80211_SCHED_SCAN_MATCH_ATTR_SSID,\n\t\t\t\t    req->match_sets[i].ssid.ssid_len,\n\t\t\t\t    req->match_sets[i].ssid.ssid))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tnla_nest_end(msg, match);\n\t\t}\n\t\tnla_nest_end(msg, matches);\n\t}\n\n\tscan_plans = nla_nest_start_noflag(msg, NL80211_ATTR_SCHED_SCAN_PLANS);\n\tif (!scan_plans)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < req->n_scan_plans; i++) {\n\t\tscan_plan = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!scan_plan)\n\t\t\treturn -ENOBUFS;\n\n\t\tif (nla_put_u32(msg, NL80211_SCHED_SCAN_PLAN_INTERVAL,\n\t\t\t\treq->scan_plans[i].interval) ||\n\t\t    (req->scan_plans[i].iterations &&\n\t\t     nla_put_u32(msg, NL80211_SCHED_SCAN_PLAN_ITERATIONS,\n\t\t\t\t req->scan_plans[i].iterations)))\n\t\t\treturn -ENOBUFS;\n\t\tnla_nest_end(msg, scan_plan);\n\t}\n\tnla_nest_end(msg, scan_plans);\n\n\tnla_nest_end(msg, nd);\n\n\treturn 0;\n}\n\nstatic int nl80211_get_wowlan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu32 size = NLMSG_DEFAULT_SIZE;\n\n\tif (!rdev->wiphy.wowlan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->wiphy.wowlan_config && rdev->wiphy.wowlan_config->tcp) {\n\t\t/* adjust size to have room for all the data */\n\t\tsize += rdev->wiphy.wowlan_config->tcp->tokens_size +\n\t\t\trdev->wiphy.wowlan_config->tcp->payload_len +\n\t\t\trdev->wiphy.wowlan_config->tcp->wake_len +\n\t\t\trdev->wiphy.wowlan_config->tcp->wake_len / 8;\n\t}\n\n\tmsg = nlmsg_new(size, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_WOWLAN);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (rdev->wiphy.wowlan_config) {\n\t\tstruct nlattr *nl_wowlan;\n\n\t\tnl_wowlan = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t  NL80211_ATTR_WOWLAN_TRIGGERS);\n\t\tif (!nl_wowlan)\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.wowlan_config->any &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_ANY)) ||\n\t\t    (rdev->wiphy.wowlan_config->disconnect &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT)) ||\n\t\t    (rdev->wiphy.wowlan_config->magic_pkt &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT)) ||\n\t\t    (rdev->wiphy.wowlan_config->gtk_rekey_failure &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE)) ||\n\t\t    (rdev->wiphy.wowlan_config->eap_identity_req &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST)) ||\n\t\t    (rdev->wiphy.wowlan_config->four_way_handshake &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE)) ||\n\t\t    (rdev->wiphy.wowlan_config->rfkill_release &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_send_wowlan_patterns(msg, rdev))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_send_wowlan_tcp(msg,\n\t\t\t\t\t    rdev->wiphy.wowlan_config->tcp))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_send_wowlan_nd(\n\t\t\t    msg,\n\t\t\t    rdev->wiphy.wowlan_config->nd_config))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_wowlan);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_parse_wowlan_tcp(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct nlattr *attr,\n\t\t\t\t    struct cfg80211_wowlan *trig)\n{\n\tstruct nlattr *tb[NUM_NL80211_WOWLAN_TCP];\n\tstruct cfg80211_wowlan_tcp *cfg;\n\tstruct nl80211_wowlan_tcp_data_token *tok = NULL;\n\tstruct nl80211_wowlan_tcp_data_seq *seq = NULL;\n\tu32 size;\n\tu32 data_size, wake_size, tokens_size = 0, wake_mask_size;\n\tint err, port;\n\n\tif (!rdev->wiphy.wowlan->tcp)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, MAX_NL80211_WOWLAN_TCP, attr,\n\t\t\t\t\t  nl80211_wowlan_tcp_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_WOWLAN_TCP_SRC_IPV4] ||\n\t    !tb[NL80211_WOWLAN_TCP_DST_IPV4] ||\n\t    !tb[NL80211_WOWLAN_TCP_DST_MAC] ||\n\t    !tb[NL80211_WOWLAN_TCP_DST_PORT] ||\n\t    !tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD] ||\n\t    !tb[NL80211_WOWLAN_TCP_DATA_INTERVAL] ||\n\t    !tb[NL80211_WOWLAN_TCP_WAKE_PAYLOAD] ||\n\t    !tb[NL80211_WOWLAN_TCP_WAKE_MASK])\n\t\treturn -EINVAL;\n\n\tdata_size = nla_len(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD]);\n\tif (data_size > rdev->wiphy.wowlan->tcp->data_payload_max)\n\t\treturn -EINVAL;\n\n\tif (nla_get_u32(tb[NL80211_WOWLAN_TCP_DATA_INTERVAL]) >\n\t\t\trdev->wiphy.wowlan->tcp->data_interval_max ||\n\t    nla_get_u32(tb[NL80211_WOWLAN_TCP_DATA_INTERVAL]) == 0)\n\t\treturn -EINVAL;\n\n\twake_size = nla_len(tb[NL80211_WOWLAN_TCP_WAKE_PAYLOAD]);\n\tif (wake_size > rdev->wiphy.wowlan->tcp->wake_payload_max)\n\t\treturn -EINVAL;\n\n\twake_mask_size = nla_len(tb[NL80211_WOWLAN_TCP_WAKE_MASK]);\n\tif (wake_mask_size != DIV_ROUND_UP(wake_size, 8))\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN]) {\n\t\tu32 tokln = nla_len(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN]);\n\n\t\ttok = nla_data(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN]);\n\t\ttokens_size = tokln - sizeof(*tok);\n\n\t\tif (!tok->len || tokens_size % tok->len)\n\t\t\treturn -EINVAL;\n\t\tif (!rdev->wiphy.wowlan->tcp->tok)\n\t\t\treturn -EINVAL;\n\t\tif (tok->len > rdev->wiphy.wowlan->tcp->tok->max_len)\n\t\t\treturn -EINVAL;\n\t\tif (tok->len < rdev->wiphy.wowlan->tcp->tok->min_len)\n\t\t\treturn -EINVAL;\n\t\tif (tokens_size > rdev->wiphy.wowlan->tcp->tok->bufsize)\n\t\t\treturn -EINVAL;\n\t\tif (tok->offset + tok->len > data_size)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ]) {\n\t\tseq = nla_data(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ]);\n\t\tif (!rdev->wiphy.wowlan->tcp->seq)\n\t\t\treturn -EINVAL;\n\t\tif (seq->len == 0 || seq->len > 4)\n\t\t\treturn -EINVAL;\n\t\tif (seq->len + seq->offset > data_size)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsize = sizeof(*cfg);\n\tsize += data_size;\n\tsize += wake_size + wake_mask_size;\n\tsize += tokens_size;\n\n\tcfg = kzalloc(size, GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\tcfg->src = nla_get_in_addr(tb[NL80211_WOWLAN_TCP_SRC_IPV4]);\n\tcfg->dst = nla_get_in_addr(tb[NL80211_WOWLAN_TCP_DST_IPV4]);\n\tmemcpy(cfg->dst_mac, nla_data(tb[NL80211_WOWLAN_TCP_DST_MAC]),\n\t       ETH_ALEN);\n\tif (tb[NL80211_WOWLAN_TCP_SRC_PORT])\n\t\tport = nla_get_u16(tb[NL80211_WOWLAN_TCP_SRC_PORT]);\n\telse\n\t\tport = 0;\n#ifdef CONFIG_INET\n\t/* allocate a socket and port for it and use it */\n\terr = __sock_create(wiphy_net(&rdev->wiphy), PF_INET, SOCK_STREAM,\n\t\t\t    IPPROTO_TCP, &cfg->sock, 1);\n\tif (err) {\n\t\tkfree(cfg);\n\t\treturn err;\n\t}\n\tif (inet_csk_get_port(cfg->sock->sk, port)) {\n\t\tsock_release(cfg->sock);\n\t\tkfree(cfg);\n\t\treturn -EADDRINUSE;\n\t}\n\tcfg->src_port = inet_sk(cfg->sock->sk)->inet_num;\n#else\n\tif (!port) {\n\t\tkfree(cfg);\n\t\treturn -EINVAL;\n\t}\n\tcfg->src_port = port;\n#endif\n\n\tcfg->dst_port = nla_get_u16(tb[NL80211_WOWLAN_TCP_DST_PORT]);\n\tcfg->payload_len = data_size;\n\tcfg->payload = (u8 *)cfg + sizeof(*cfg) + tokens_size;\n\tmemcpy((void *)cfg->payload,\n\t       nla_data(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD]),\n\t       data_size);\n\tif (seq)\n\t\tcfg->payload_seq = *seq;\n\tcfg->data_interval = nla_get_u32(tb[NL80211_WOWLAN_TCP_DATA_INTERVAL]);\n\tcfg->wake_len = wake_size;\n\tcfg->wake_data = (u8 *)cfg + sizeof(*cfg) + tokens_size + data_size;\n\tmemcpy((void *)cfg->wake_data,\n\t       nla_data(tb[NL80211_WOWLAN_TCP_WAKE_PAYLOAD]),\n\t       wake_size);\n\tcfg->wake_mask = (u8 *)cfg + sizeof(*cfg) + tokens_size +\n\t\t\t data_size + wake_size;\n\tmemcpy((void *)cfg->wake_mask,\n\t       nla_data(tb[NL80211_WOWLAN_TCP_WAKE_MASK]),\n\t       wake_mask_size);\n\tif (tok) {\n\t\tcfg->tokens_size = tokens_size;\n\t\tmemcpy(&cfg->payload_tok, tok, sizeof(*tok) + tokens_size);\n\t}\n\n\ttrig->tcp = cfg;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_wowlan_nd(struct cfg80211_registered_device *rdev,\n\t\t\t\t   const struct wiphy_wowlan_support *wowlan,\n\t\t\t\t   struct nlattr *attr,\n\t\t\t\t   struct cfg80211_wowlan *trig)\n{\n\tstruct nlattr **tb;\n\tint err;\n\n\ttb = kcalloc(NUM_NL80211_ATTR, sizeof(*tb), GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tif (!(wowlan->flags & WIPHY_WOWLAN_NET_DETECT)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, NL80211_ATTR_MAX, attr,\n\t\t\t\t\t  nl80211_policy, NULL);\n\tif (err)\n\t\tgoto out;\n\n\ttrig->nd_config = nl80211_parse_sched_scan(&rdev->wiphy, NULL, tb,\n\t\t\t\t\t\t   wowlan->max_nd_match_sets);\n\terr = PTR_ERR_OR_ZERO(trig->nd_config);\n\tif (err)\n\t\ttrig->nd_config = NULL;\n\nout:\n\tkfree(tb);\n\treturn err;\n}\n\nstatic int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *tb[NUM_NL80211_WOWLAN_TRIG];\n\tstruct cfg80211_wowlan new_triggers = {};\n\tstruct cfg80211_wowlan *ntrig;\n\tconst struct wiphy_wowlan_support *wowlan = rdev->wiphy.wowlan;\n\tint err, i;\n\tbool prev_enabled = rdev->wiphy.wowlan_config;\n\tbool regular = false;\n\n\tif (!wowlan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_WOWLAN_TRIGGERS]) {\n\t\tcfg80211_rdev_free_wowlan(rdev);\n\t\trdev->wiphy.wowlan_config = NULL;\n\t\tgoto set_wakeup;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, MAX_NL80211_WOWLAN_TRIG,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_WOWLAN_TRIGGERS],\n\t\t\t\t\t  nl80211_wowlan_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NL80211_WOWLAN_TRIG_ANY]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_ANY))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.any = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_DISCONNECT]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_DISCONNECT))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.disconnect = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_MAGIC_PKT]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_MAGIC_PKT))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.magic_pkt = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED])\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.gtk_rekey_failure = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_EAP_IDENTITY_REQ))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.eap_identity_req = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_4WAY_HANDSHAKE))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.four_way_handshake = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_RFKILL_RELEASE]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_RFKILL_RELEASE))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.rfkill_release = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_PKT_PATTERN]) {\n\t\tstruct nlattr *pat;\n\t\tint n_patterns = 0;\n\t\tint rem, pat_len, mask_len, pkt_offset;\n\t\tstruct nlattr *pat_tb[NUM_NL80211_PKTPAT];\n\n\t\tregular = true;\n\n\t\tnla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],\n\t\t\t\t    rem)\n\t\t\tn_patterns++;\n\t\tif (n_patterns > wowlan->n_patterns)\n\t\t\treturn -EINVAL;\n\n\t\tnew_triggers.patterns = kcalloc(n_patterns,\n\t\t\t\t\t\tsizeof(new_triggers.patterns[0]),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!new_triggers.patterns)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_triggers.n_patterns = n_patterns;\n\t\ti = 0;\n\n\t\tnla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],\n\t\t\t\t    rem) {\n\t\t\tu8 *mask_pat;\n\n\t\t\terr = nla_parse_nested_deprecated(pat_tb,\n\t\t\t\t\t\t\t  MAX_NL80211_PKTPAT,\n\t\t\t\t\t\t\t  pat,\n\t\t\t\t\t\t\t  nl80211_packet_pattern_policy,\n\t\t\t\t\t\t\t  info->extack);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\n\t\t\terr = -EINVAL;\n\t\t\tif (!pat_tb[NL80211_PKTPAT_MASK] ||\n\t\t\t    !pat_tb[NL80211_PKTPAT_PATTERN])\n\t\t\t\tgoto error;\n\t\t\tpat_len = nla_len(pat_tb[NL80211_PKTPAT_PATTERN]);\n\t\t\tmask_len = DIV_ROUND_UP(pat_len, 8);\n\t\t\tif (nla_len(pat_tb[NL80211_PKTPAT_MASK]) != mask_len)\n\t\t\t\tgoto error;\n\t\t\tif (pat_len > wowlan->pattern_max_len ||\n\t\t\t    pat_len < wowlan->pattern_min_len)\n\t\t\t\tgoto error;\n\n\t\t\tif (!pat_tb[NL80211_PKTPAT_OFFSET])\n\t\t\t\tpkt_offset = 0;\n\t\t\telse\n\t\t\t\tpkt_offset = nla_get_u32(\n\t\t\t\t\tpat_tb[NL80211_PKTPAT_OFFSET]);\n\t\t\tif (pkt_offset > wowlan->max_pkt_offset)\n\t\t\t\tgoto error;\n\t\t\tnew_triggers.patterns[i].pkt_offset = pkt_offset;\n\n\t\t\tmask_pat = kmalloc(mask_len + pat_len, GFP_KERNEL);\n\t\t\tif (!mask_pat) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tnew_triggers.patterns[i].mask = mask_pat;\n\t\t\tmemcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_MASK]),\n\t\t\t       mask_len);\n\t\t\tmask_pat += mask_len;\n\t\t\tnew_triggers.patterns[i].pattern = mask_pat;\n\t\t\tnew_triggers.patterns[i].pattern_len = pat_len;\n\t\t\tmemcpy(mask_pat,\n\t\t\t       nla_data(pat_tb[NL80211_PKTPAT_PATTERN]),\n\t\t\t       pat_len);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_TCP_CONNECTION]) {\n\t\tregular = true;\n\t\terr = nl80211_parse_wowlan_tcp(\n\t\t\trdev, tb[NL80211_WOWLAN_TRIG_TCP_CONNECTION],\n\t\t\t&new_triggers);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_NET_DETECT]) {\n\t\tregular = true;\n\t\terr = nl80211_parse_wowlan_nd(\n\t\t\trdev, wowlan, tb[NL80211_WOWLAN_TRIG_NET_DETECT],\n\t\t\t&new_triggers);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\t/* The 'any' trigger means the device continues operating more or less\n\t * as in its normal operation mode and wakes up the host on most of the\n\t * normal interrupts (like packet RX, ...)\n\t * It therefore makes little sense to combine with the more constrained\n\t * wakeup trigger modes.\n\t */\n\tif (new_triggers.any && regular) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tntrig = kmemdup(&new_triggers, sizeof(new_triggers), GFP_KERNEL);\n\tif (!ntrig) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tcfg80211_rdev_free_wowlan(rdev);\n\trdev->wiphy.wowlan_config = ntrig;\n\n set_wakeup:\n\tif (rdev->ops->set_wakeup &&\n\t    prev_enabled != !!rdev->wiphy.wowlan_config)\n\t\trdev_set_wakeup(rdev, rdev->wiphy.wowlan_config);\n\n\treturn 0;\n error:\n\tfor (i = 0; i < new_triggers.n_patterns; i++)\n\t\tkfree(new_triggers.patterns[i].mask);\n\tkfree(new_triggers.patterns);\n\tif (new_triggers.tcp && new_triggers.tcp->sock)\n\t\tsock_release(new_triggers.tcp->sock);\n\tkfree(new_triggers.tcp);\n\tkfree(new_triggers.nd_config);\n\treturn err;\n}\n#endif\n\nstatic int nl80211_send_coalesce_rules(struct sk_buff *msg,\n\t\t\t\t       struct cfg80211_registered_device *rdev)\n{\n\tstruct nlattr *nl_pats, *nl_pat, *nl_rule, *nl_rules;\n\tint i, j, pat_len;\n\tstruct cfg80211_coalesce_rules *rule;\n\n\tif (!rdev->coalesce->n_rules)\n\t\treturn 0;\n\n\tnl_rules = nla_nest_start_noflag(msg, NL80211_ATTR_COALESCE_RULE);\n\tif (!nl_rules)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < rdev->coalesce->n_rules; i++) {\n\t\tnl_rule = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!nl_rule)\n\t\t\treturn -ENOBUFS;\n\n\t\trule = &rdev->coalesce->rules[i];\n\t\tif (nla_put_u32(msg, NL80211_ATTR_COALESCE_RULE_DELAY,\n\t\t\t\trule->delay))\n\t\t\treturn -ENOBUFS;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_COALESCE_RULE_CONDITION,\n\t\t\t\trule->condition))\n\t\t\treturn -ENOBUFS;\n\n\t\tnl_pats = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_COALESCE_RULE_PKT_PATTERN);\n\t\tif (!nl_pats)\n\t\t\treturn -ENOBUFS;\n\n\t\tfor (j = 0; j < rule->n_patterns; j++) {\n\t\t\tnl_pat = nla_nest_start_noflag(msg, j + 1);\n\t\t\tif (!nl_pat)\n\t\t\t\treturn -ENOBUFS;\n\t\t\tpat_len = rule->patterns[j].pattern_len;\n\t\t\tif (nla_put(msg, NL80211_PKTPAT_MASK,\n\t\t\t\t    DIV_ROUND_UP(pat_len, 8),\n\t\t\t\t    rule->patterns[j].mask) ||\n\t\t\t    nla_put(msg, NL80211_PKTPAT_PATTERN, pat_len,\n\t\t\t\t    rule->patterns[j].pattern) ||\n\t\t\t    nla_put_u32(msg, NL80211_PKTPAT_OFFSET,\n\t\t\t\t\trule->patterns[j].pkt_offset))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tnla_nest_end(msg, nl_pat);\n\t\t}\n\t\tnla_nest_end(msg, nl_pats);\n\t\tnla_nest_end(msg, nl_rule);\n\t}\n\tnla_nest_end(msg, nl_rules);\n\n\treturn 0;\n}\n\nstatic int nl80211_get_coalesce(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (!rdev->wiphy.coalesce)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_COALESCE);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (rdev->coalesce && nl80211_send_coalesce_rules(msg, rdev))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nvoid cfg80211_rdev_free_coalesce(struct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_coalesce *coalesce = rdev->coalesce;\n\tint i, j;\n\tstruct cfg80211_coalesce_rules *rule;\n\n\tif (!coalesce)\n\t\treturn;\n\n\tfor (i = 0; i < coalesce->n_rules; i++) {\n\t\trule = &coalesce->rules[i];\n\t\tfor (j = 0; j < rule->n_patterns; j++)\n\t\t\tkfree(rule->patterns[j].mask);\n\t\tkfree(rule->patterns);\n\t}\n\tkfree(coalesce->rules);\n\tkfree(coalesce);\n\trdev->coalesce = NULL;\n}\n\nstatic int nl80211_parse_coalesce_rule(struct cfg80211_registered_device *rdev,\n\t\t\t\t       struct nlattr *rule,\n\t\t\t\t       struct cfg80211_coalesce_rules *new_rule)\n{\n\tint err, i;\n\tconst struct wiphy_coalesce_support *coalesce = rdev->wiphy.coalesce;\n\tstruct nlattr *tb[NUM_NL80211_ATTR_COALESCE_RULE], *pat;\n\tint rem, pat_len, mask_len, pkt_offset, n_patterns = 0;\n\tstruct nlattr *pat_tb[NUM_NL80211_PKTPAT];\n\n\terr = nla_parse_nested_deprecated(tb, NL80211_ATTR_COALESCE_RULE_MAX,\n\t\t\t\t\t  rule, nl80211_coalesce_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NL80211_ATTR_COALESCE_RULE_DELAY])\n\t\tnew_rule->delay =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_COALESCE_RULE_DELAY]);\n\tif (new_rule->delay > coalesce->max_delay)\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_ATTR_COALESCE_RULE_CONDITION])\n\t\tnew_rule->condition =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_COALESCE_RULE_CONDITION]);\n\n\tif (!tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN])\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(pat, tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN],\n\t\t\t    rem)\n\t\tn_patterns++;\n\tif (n_patterns > coalesce->n_patterns)\n\t\treturn -EINVAL;\n\n\tnew_rule->patterns = kcalloc(n_patterns, sizeof(new_rule->patterns[0]),\n\t\t\t\t     GFP_KERNEL);\n\tif (!new_rule->patterns)\n\t\treturn -ENOMEM;\n\n\tnew_rule->n_patterns = n_patterns;\n\ti = 0;\n\n\tnla_for_each_nested(pat, tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN],\n\t\t\t    rem) {\n\t\tu8 *mask_pat;\n\n\t\terr = nla_parse_nested_deprecated(pat_tb, MAX_NL80211_PKTPAT,\n\t\t\t\t\t\t  pat,\n\t\t\t\t\t\t  nl80211_packet_pattern_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!pat_tb[NL80211_PKTPAT_MASK] ||\n\t\t    !pat_tb[NL80211_PKTPAT_PATTERN])\n\t\t\treturn -EINVAL;\n\t\tpat_len = nla_len(pat_tb[NL80211_PKTPAT_PATTERN]);\n\t\tmask_len = DIV_ROUND_UP(pat_len, 8);\n\t\tif (nla_len(pat_tb[NL80211_PKTPAT_MASK]) != mask_len)\n\t\t\treturn -EINVAL;\n\t\tif (pat_len > coalesce->pattern_max_len ||\n\t\t    pat_len < coalesce->pattern_min_len)\n\t\t\treturn -EINVAL;\n\n\t\tif (!pat_tb[NL80211_PKTPAT_OFFSET])\n\t\t\tpkt_offset = 0;\n\t\telse\n\t\t\tpkt_offset = nla_get_u32(pat_tb[NL80211_PKTPAT_OFFSET]);\n\t\tif (pkt_offset > coalesce->max_pkt_offset)\n\t\t\treturn -EINVAL;\n\t\tnew_rule->patterns[i].pkt_offset = pkt_offset;\n\n\t\tmask_pat = kmalloc(mask_len + pat_len, GFP_KERNEL);\n\t\tif (!mask_pat)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_rule->patterns[i].mask = mask_pat;\n\t\tmemcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_MASK]),\n\t\t       mask_len);\n\n\t\tmask_pat += mask_len;\n\t\tnew_rule->patterns[i].pattern = mask_pat;\n\t\tnew_rule->patterns[i].pattern_len = pat_len;\n\t\tmemcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_PATTERN]),\n\t\t       pat_len);\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_set_coalesce(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tconst struct wiphy_coalesce_support *coalesce = rdev->wiphy.coalesce;\n\tstruct cfg80211_coalesce new_coalesce = {};\n\tstruct cfg80211_coalesce *n_coalesce;\n\tint err, rem_rule, n_rules = 0, i, j;\n\tstruct nlattr *rule;\n\tstruct cfg80211_coalesce_rules *tmp_rule;\n\n\tif (!rdev->wiphy.coalesce || !rdev->ops->set_coalesce)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_COALESCE_RULE]) {\n\t\tcfg80211_rdev_free_coalesce(rdev);\n\t\trdev_set_coalesce(rdev, NULL);\n\t\treturn 0;\n\t}\n\n\tnla_for_each_nested(rule, info->attrs[NL80211_ATTR_COALESCE_RULE],\n\t\t\t    rem_rule)\n\t\tn_rules++;\n\tif (n_rules > coalesce->n_rules)\n\t\treturn -EINVAL;\n\n\tnew_coalesce.rules = kcalloc(n_rules, sizeof(new_coalesce.rules[0]),\n\t\t\t\t     GFP_KERNEL);\n\tif (!new_coalesce.rules)\n\t\treturn -ENOMEM;\n\n\tnew_coalesce.n_rules = n_rules;\n\ti = 0;\n\n\tnla_for_each_nested(rule, info->attrs[NL80211_ATTR_COALESCE_RULE],\n\t\t\t    rem_rule) {\n\t\terr = nl80211_parse_coalesce_rule(rdev, rule,\n\t\t\t\t\t\t  &new_coalesce.rules[i]);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\ti++;\n\t}\n\n\terr = rdev_set_coalesce(rdev, &new_coalesce);\n\tif (err)\n\t\tgoto error;\n\n\tn_coalesce = kmemdup(&new_coalesce, sizeof(new_coalesce), GFP_KERNEL);\n\tif (!n_coalesce) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tcfg80211_rdev_free_coalesce(rdev);\n\trdev->coalesce = n_coalesce;\n\n\treturn 0;\nerror:\n\tfor (i = 0; i < new_coalesce.n_rules; i++) {\n\t\ttmp_rule = &new_coalesce.rules[i];\n\t\tfor (j = 0; j < tmp_rule->n_patterns; j++)\n\t\t\tkfree(tmp_rule->patterns[j].mask);\n\t\tkfree(tmp_rule->patterns);\n\t}\n\tkfree(new_coalesce.rules);\n\n\treturn err;\n}\n\nstatic int nl80211_set_rekey_data(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct nlattr *tb[NUM_NL80211_REKEY_DATA];\n\tstruct cfg80211_gtk_rekey_data rekey_data = {};\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_REKEY_DATA])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, MAX_NL80211_REKEY_DATA,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_REKEY_DATA],\n\t\t\t\t\t  nl80211_rekey_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_REKEY_DATA_REPLAY_CTR] || !tb[NL80211_REKEY_DATA_KEK] ||\n\t    !tb[NL80211_REKEY_DATA_KCK])\n\t\treturn -EINVAL;\n\tif (nla_len(tb[NL80211_REKEY_DATA_KEK]) != NL80211_KEK_LEN &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_EXT_KEK_KCK &&\n\t      nla_len(tb[NL80211_REKEY_DATA_KEK]) == NL80211_KEK_EXT_LEN))\n\t\treturn -ERANGE;\n\tif (nla_len(tb[NL80211_REKEY_DATA_KCK]) != NL80211_KCK_LEN &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_EXT_KEK_KCK &&\n\t      nla_len(tb[NL80211_REKEY_DATA_KEK]) == NL80211_KCK_EXT_LEN))\n\t\treturn -ERANGE;\n\n\trekey_data.kek = nla_data(tb[NL80211_REKEY_DATA_KEK]);\n\trekey_data.kck = nla_data(tb[NL80211_REKEY_DATA_KCK]);\n\trekey_data.replay_ctr = nla_data(tb[NL80211_REKEY_DATA_REPLAY_CTR]);\n\trekey_data.kek_len = nla_len(tb[NL80211_REKEY_DATA_KEK]);\n\trekey_data.kck_len = nla_len(tb[NL80211_REKEY_DATA_KCK]);\n\tif (tb[NL80211_REKEY_DATA_AKM])\n\t\trekey_data.akm = nla_get_u32(tb[NL80211_REKEY_DATA_AKM]);\n\n\twdev_lock(wdev);\n\tif (!wdev->current_bss) {\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tif (!rdev->ops->set_rekey_data) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = rdev_set_rekey_data(rdev, dev, &rekey_data);\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nstatic int nl80211_register_unexpected_frame(struct sk_buff *skb,\n\t\t\t\t\t     struct genl_info *info)\n{\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EINVAL;\n\n\tif (wdev->ap_unexpected_nlportid)\n\t\treturn -EBUSY;\n\n\twdev->ap_unexpected_nlportid = info->snd_portid;\n\treturn 0;\n}\n\nstatic int nl80211_probe_client(struct sk_buff *skb,\n\t\t\t\tstruct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tconst u8 *addr;\n\tu64 cookie;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->probe_client)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_PROBE_CLIENT);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\taddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\terr = rdev_probe_client(rdev, dev, addr, &cookie);\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_register_beacons(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_beacon_registration *reg, *nreg;\n\tint rv;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_REPORTS_OBSS))\n\t\treturn -EOPNOTSUPP;\n\n\tnreg = kzalloc(sizeof(*nreg), GFP_KERNEL);\n\tif (!nreg)\n\t\treturn -ENOMEM;\n\n\t/* First, check if already registered. */\n\tspin_lock_bh(&rdev->beacon_registrations_lock);\n\tlist_for_each_entry(reg, &rdev->beacon_registrations, list) {\n\t\tif (reg->nlportid == info->snd_portid) {\n\t\t\trv = -EALREADY;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\t/* Add it to the list */\n\tnreg->nlportid = info->snd_portid;\n\tlist_add(&nreg->list, &rdev->beacon_registrations);\n\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\n\treturn 0;\nout_err:\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\tkfree(nreg);\n\treturn rv;\n}\n\nstatic int nl80211_start_p2p_device(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tint err;\n\n\tif (!rdev->ops->start_p2p_device)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_P2P_DEVICE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev_running(wdev))\n\t\treturn 0;\n\n\tif (rfkill_blocked(rdev->rfkill))\n\t\treturn -ERFKILL;\n\n\terr = rdev_start_p2p_device(rdev, wdev);\n\tif (err)\n\t\treturn err;\n\n\twdev->is_running = true;\n\trdev->opencount++;\n\n\treturn 0;\n}\n\nstatic int nl80211_stop_p2p_device(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (wdev->iftype != NL80211_IFTYPE_P2P_DEVICE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->stop_p2p_device)\n\t\treturn -EOPNOTSUPP;\n\n\tcfg80211_stop_p2p_device(rdev, wdev);\n\n\treturn 0;\n}\n\nstatic int nl80211_start_nan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_nan_conf conf = {};\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev_running(wdev))\n\t\treturn -EEXIST;\n\n\tif (rfkill_blocked(rdev->rfkill))\n\t\treturn -ERFKILL;\n\n\tif (!info->attrs[NL80211_ATTR_NAN_MASTER_PREF])\n\t\treturn -EINVAL;\n\n\tconf.master_pref =\n\t\tnla_get_u8(info->attrs[NL80211_ATTR_NAN_MASTER_PREF]);\n\n\tif (info->attrs[NL80211_ATTR_BANDS]) {\n\t\tu32 bands = nla_get_u32(info->attrs[NL80211_ATTR_BANDS]);\n\n\t\tif (bands & ~(u32)wdev->wiphy->nan_supported_bands)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (bands && !(bands & BIT(NL80211_BAND_2GHZ)))\n\t\t\treturn -EINVAL;\n\n\t\tconf.bands = bands;\n\t}\n\n\terr = rdev_start_nan(rdev, wdev, &conf);\n\tif (err)\n\t\treturn err;\n\n\twdev->is_running = true;\n\trdev->opencount++;\n\n\treturn 0;\n}\n\nstatic int nl80211_stop_nan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tcfg80211_stop_nan(rdev, wdev);\n\n\treturn 0;\n}\n\nstatic int validate_nan_filter(struct nlattr *filter_attr)\n{\n\tstruct nlattr *attr;\n\tint len = 0, n_entries = 0, rem;\n\n\tnla_for_each_nested(attr, filter_attr, rem) {\n\t\tlen += nla_len(attr);\n\t\tn_entries++;\n\t}\n\n\tif (len >= U8_MAX)\n\t\treturn -EINVAL;\n\n\treturn n_entries;\n}\n\nstatic int handle_nan_filter(struct nlattr *attr_filter,\n\t\t\t     struct cfg80211_nan_func *func,\n\t\t\t     bool tx)\n{\n\tstruct nlattr *attr;\n\tint n_entries, rem, i;\n\tstruct cfg80211_nan_func_filter *filter;\n\n\tn_entries = validate_nan_filter(attr_filter);\n\tif (n_entries < 0)\n\t\treturn n_entries;\n\n\tBUILD_BUG_ON(sizeof(*func->rx_filters) != sizeof(*func->tx_filters));\n\n\tfilter = kcalloc(n_entries, sizeof(*func->rx_filters), GFP_KERNEL);\n\tif (!filter)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tnla_for_each_nested(attr, attr_filter, rem) {\n\t\tfilter[i].filter = nla_memdup(attr, GFP_KERNEL);\n\t\tfilter[i].len = nla_len(attr);\n\t\ti++;\n\t}\n\tif (tx) {\n\t\tfunc->num_tx_filters = n_entries;\n\t\tfunc->tx_filters = filter;\n\t} else {\n\t\tfunc->num_rx_filters = n_entries;\n\t\tfunc->rx_filters = filter;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_nan_add_func(struct sk_buff *skb,\n\t\t\t\tstruct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct nlattr *tb[NUM_NL80211_NAN_FUNC_ATTR], *func_attr;\n\tstruct cfg80211_nan_func *func;\n\tstruct sk_buff *msg = NULL;\n\tvoid *hdr = NULL;\n\tint err = 0;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev_running(wdev))\n\t\treturn -ENOTCONN;\n\n\tif (!info->attrs[NL80211_ATTR_NAN_FUNC])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, NL80211_NAN_FUNC_ATTR_MAX,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_NAN_FUNC],\n\t\t\t\t\t  nl80211_nan_func_policy,\n\t\t\t\t\t  info->extack);\n\tif (err)\n\t\treturn err;\n\n\tfunc = kzalloc(sizeof(*func), GFP_KERNEL);\n\tif (!func)\n\t\treturn -ENOMEM;\n\n\tfunc->cookie = cfg80211_assign_cookie(rdev);\n\n\tif (!tb[NL80211_NAN_FUNC_TYPE]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\n\tfunc->type = nla_get_u8(tb[NL80211_NAN_FUNC_TYPE]);\n\n\tif (!tb[NL80211_NAN_FUNC_SERVICE_ID]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemcpy(func->service_id, nla_data(tb[NL80211_NAN_FUNC_SERVICE_ID]),\n\t       sizeof(func->service_id));\n\n\tfunc->close_range =\n\t\tnla_get_flag(tb[NL80211_NAN_FUNC_CLOSE_RANGE]);\n\n\tif (tb[NL80211_NAN_FUNC_SERVICE_INFO]) {\n\t\tfunc->serv_spec_info_len =\n\t\t\tnla_len(tb[NL80211_NAN_FUNC_SERVICE_INFO]);\n\t\tfunc->serv_spec_info =\n\t\t\tkmemdup(nla_data(tb[NL80211_NAN_FUNC_SERVICE_INFO]),\n\t\t\t\tfunc->serv_spec_info_len,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!func->serv_spec_info) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_TTL])\n\t\tfunc->ttl = nla_get_u32(tb[NL80211_NAN_FUNC_TTL]);\n\n\tswitch (func->type) {\n\tcase NL80211_NAN_FUNC_PUBLISH:\n\t\tif (!tb[NL80211_NAN_FUNC_PUBLISH_TYPE]) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfunc->publish_type =\n\t\t\tnla_get_u8(tb[NL80211_NAN_FUNC_PUBLISH_TYPE]);\n\t\tfunc->publish_bcast =\n\t\t\tnla_get_flag(tb[NL80211_NAN_FUNC_PUBLISH_BCAST]);\n\n\t\tif ((!(func->publish_type & NL80211_NAN_SOLICITED_PUBLISH)) &&\n\t\t\tfunc->publish_bcast) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase NL80211_NAN_FUNC_SUBSCRIBE:\n\t\tfunc->subscribe_active =\n\t\t\tnla_get_flag(tb[NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE]);\n\t\tbreak;\n\tcase NL80211_NAN_FUNC_FOLLOW_UP:\n\t\tif (!tb[NL80211_NAN_FUNC_FOLLOW_UP_ID] ||\n\t\t    !tb[NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID] ||\n\t\t    !tb[NL80211_NAN_FUNC_FOLLOW_UP_DEST]) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfunc->followup_id =\n\t\t\tnla_get_u8(tb[NL80211_NAN_FUNC_FOLLOW_UP_ID]);\n\t\tfunc->followup_reqid =\n\t\t\tnla_get_u8(tb[NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID]);\n\t\tmemcpy(func->followup_dest.addr,\n\t\t       nla_data(tb[NL80211_NAN_FUNC_FOLLOW_UP_DEST]),\n\t\t       sizeof(func->followup_dest.addr));\n\t\tif (func->ttl) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_SRF]) {\n\t\tstruct nlattr *srf_tb[NUM_NL80211_NAN_SRF_ATTR];\n\n\t\terr = nla_parse_nested_deprecated(srf_tb,\n\t\t\t\t\t\t  NL80211_NAN_SRF_ATTR_MAX,\n\t\t\t\t\t\t  tb[NL80211_NAN_FUNC_SRF],\n\t\t\t\t\t\t  nl80211_nan_srf_policy,\n\t\t\t\t\t\t  info->extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfunc->srf_include =\n\t\t\tnla_get_flag(srf_tb[NL80211_NAN_SRF_INCLUDE]);\n\n\t\tif (srf_tb[NL80211_NAN_SRF_BF]) {\n\t\t\tif (srf_tb[NL80211_NAN_SRF_MAC_ADDRS] ||\n\t\t\t    !srf_tb[NL80211_NAN_SRF_BF_IDX]) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfunc->srf_bf_len =\n\t\t\t\tnla_len(srf_tb[NL80211_NAN_SRF_BF]);\n\t\t\tfunc->srf_bf =\n\t\t\t\tkmemdup(nla_data(srf_tb[NL80211_NAN_SRF_BF]),\n\t\t\t\t\tfunc->srf_bf_len, GFP_KERNEL);\n\t\t\tif (!func->srf_bf) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfunc->srf_bf_idx =\n\t\t\t\tnla_get_u8(srf_tb[NL80211_NAN_SRF_BF_IDX]);\n\t\t} else {\n\t\t\tstruct nlattr *attr, *mac_attr =\n\t\t\t\tsrf_tb[NL80211_NAN_SRF_MAC_ADDRS];\n\t\t\tint n_entries, rem, i = 0;\n\n\t\t\tif (!mac_attr) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tn_entries = validate_acl_mac_addrs(mac_attr);\n\t\t\tif (n_entries <= 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfunc->srf_num_macs = n_entries;\n\t\t\tfunc->srf_macs =\n\t\t\t\tkcalloc(n_entries, sizeof(*func->srf_macs),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!func->srf_macs) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tnla_for_each_nested(attr, mac_attr, rem)\n\t\t\t\tmemcpy(func->srf_macs[i++].addr, nla_data(attr),\n\t\t\t\t       sizeof(*func->srf_macs));\n\t\t}\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_TX_MATCH_FILTER]) {\n\t\terr = handle_nan_filter(tb[NL80211_NAN_FUNC_TX_MATCH_FILTER],\n\t\t\t\t\tfunc, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_RX_MATCH_FILTER]) {\n\t\terr = handle_nan_filter(tb[NL80211_NAN_FUNC_RX_MATCH_FILTER],\n\t\t\t\t\tfunc, false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_ADD_NAN_FUNCTION);\n\t/* This can't really happen - we just allocated 4KB */\n\tif (WARN_ON(!hdr)) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = rdev_add_nan_func(rdev, wdev, func);\nout:\n\tif (err < 0) {\n\t\tcfg80211_free_nan_func(func);\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\t/* propagate the instance id and cookie to userspace  */\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, func->cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tfunc_attr = nla_nest_start_noflag(msg, NL80211_ATTR_NAN_FUNC);\n\tif (!func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID,\n\t\t       func->instance_id))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, func_attr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_nan_del_func(struct sk_buff *skb,\n\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev_running(wdev))\n\t\treturn -ENOTCONN;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\trdev_del_nan_func(rdev, wdev, cookie);\n\n\treturn 0;\n}\n\nstatic int nl80211_nan_change_config(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_nan_conf conf = {};\n\tu32 changed = 0;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev_running(wdev))\n\t\treturn -ENOTCONN;\n\n\tif (info->attrs[NL80211_ATTR_NAN_MASTER_PREF]) {\n\t\tconf.master_pref =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_NAN_MASTER_PREF]);\n\t\tif (conf.master_pref <= 1 || conf.master_pref == 255)\n\t\t\treturn -EINVAL;\n\n\t\tchanged |= CFG80211_NAN_CONF_CHANGED_PREF;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_BANDS]) {\n\t\tu32 bands = nla_get_u32(info->attrs[NL80211_ATTR_BANDS]);\n\n\t\tif (bands & ~(u32)wdev->wiphy->nan_supported_bands)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (bands && !(bands & BIT(NL80211_BAND_2GHZ)))\n\t\t\treturn -EINVAL;\n\n\t\tconf.bands = bands;\n\t\tchanged |= CFG80211_NAN_CONF_CHANGED_BANDS;\n\t}\n\n\tif (!changed)\n\t\treturn -EINVAL;\n\n\treturn rdev_nan_change_conf(rdev, wdev, &conf, changed);\n}\n\nvoid cfg80211_nan_match(struct wireless_dev *wdev,\n\t\t\tstruct cfg80211_nan_match_params *match, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct nlattr *match_attr, *local_func_attr, *peer_func_attr;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (WARN_ON(!match->inst_id || !match->peer_inst_id || !match->addr))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NAN_MATCH);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, match->cookie,\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, match->addr))\n\t\tgoto nla_put_failure;\n\n\tmatch_attr = nla_nest_start_noflag(msg, NL80211_ATTR_NAN_MATCH);\n\tif (!match_attr)\n\t\tgoto nla_put_failure;\n\n\tlocal_func_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_NAN_MATCH_FUNC_LOCAL);\n\tif (!local_func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, match->inst_id))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, local_func_attr);\n\n\tpeer_func_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t       NL80211_NAN_MATCH_FUNC_PEER);\n\tif (!peer_func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_TYPE, match->type) ||\n\t    nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, match->peer_inst_id))\n\t\tgoto nla_put_failure;\n\n\tif (match->info && match->info_len &&\n\t    nla_put(msg, NL80211_NAN_FUNC_SERVICE_INFO, match->info_len,\n\t\t    match->info))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, peer_func_attr);\n\tnla_nest_end(msg, match_attr);\n\tgenlmsg_end(msg, hdr);\n\n\tif (!wdev->owner_nlportid)\n\t\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),\n\t\t\t\t\tmsg, 0, NL80211_MCGRP_NAN, gfp);\n\telse\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg,\n\t\t\t\twdev->owner_nlportid);\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_nan_match);\n\nvoid cfg80211_nan_func_terminated(struct wireless_dev *wdev,\n\t\t\t\t  u8 inst_id,\n\t\t\t\t  enum nl80211_nan_func_term_reason reason,\n\t\t\t\t  u64 cookie, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tstruct nlattr *func_attr;\n\tvoid *hdr;\n\n\tif (WARN_ON(!inst_id))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DEL_NAN_FUNCTION);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tfunc_attr = nla_nest_start_noflag(msg, NL80211_ATTR_NAN_FUNC);\n\tif (!func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, inst_id) ||\n\t    nla_put_u8(msg, NL80211_NAN_FUNC_TERM_REASON, reason))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, func_attr);\n\tgenlmsg_end(msg, hdr);\n\n\tif (!wdev->owner_nlportid)\n\t\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),\n\t\t\t\t\tmsg, 0, NL80211_MCGRP_NAN, gfp);\n\telse\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg,\n\t\t\t\twdev->owner_nlportid);\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_nan_func_terminated);\n\nstatic int nl80211_get_protocol_features(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tvoid *hdr;\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_PROTOCOL_FEATURES);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_PROTOCOL_FEATURES,\n\t\t\tNL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\tkfree_skb(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_update_ft_ies_params ft_params;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->update_ft_ies)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MDID] ||\n\t    !info->attrs[NL80211_ATTR_IE])\n\t\treturn -EINVAL;\n\n\tmemset(&ft_params, 0, sizeof(ft_params));\n\tft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);\n\tft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\tft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\n\treturn rdev_update_ft_ies(rdev, dev, &ft_params);\n}\n\nstatic int nl80211_crit_protocol_start(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tenum nl80211_crit_proto_id proto = NL80211_CRIT_PROTO_UNSPEC;\n\tu16 duration;\n\tint ret;\n\n\tif (!rdev->ops->crit_proto_start)\n\t\treturn -EOPNOTSUPP;\n\n\tif (WARN_ON(!rdev->ops->crit_proto_stop))\n\t\treturn -EINVAL;\n\n\tif (rdev->crit_proto_nlportid)\n\t\treturn -EBUSY;\n\n\t/* determine protocol if provided */\n\tif (info->attrs[NL80211_ATTR_CRIT_PROT_ID])\n\t\tproto = nla_get_u16(info->attrs[NL80211_ATTR_CRIT_PROT_ID]);\n\n\tif (proto >= NUM_NL80211_CRIT_PROTO)\n\t\treturn -EINVAL;\n\n\t/* timeout must be provided */\n\tif (!info->attrs[NL80211_ATTR_MAX_CRIT_PROT_DURATION])\n\t\treturn -EINVAL;\n\n\tduration =\n\t\tnla_get_u16(info->attrs[NL80211_ATTR_MAX_CRIT_PROT_DURATION]);\n\n\tret = rdev_crit_proto_start(rdev, wdev, proto, duration);\n\tif (!ret)\n\t\trdev->crit_proto_nlportid = info->snd_portid;\n\n\treturn ret;\n}\n\nstatic int nl80211_crit_protocol_stop(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (!rdev->ops->crit_proto_stop)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->crit_proto_nlportid) {\n\t\trdev->crit_proto_nlportid = 0;\n\t\trdev_crit_proto_stop(rdev, wdev);\n\t}\n\treturn 0;\n}\n\nstatic int nl80211_vendor_check_policy(const struct wiphy_vendor_command *vcmd,\n\t\t\t\t       struct nlattr *attr,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tif (vcmd->policy == VENDOR_CMD_RAW_DATA) {\n\t\tif (attr->nla_type & NLA_F_NESTED) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr,\n\t\t\t\t\t    \"unexpected nested data\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (!(attr->nla_type & NLA_F_NESTED)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, attr, \"expected nested data\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn nla_validate_nested(attr, vcmd->maxattr, vcmd->policy, extack);\n}\n\nstatic int nl80211_vendor_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev =\n\t\t__cfg80211_wdev_from_attrs(rdev, genl_info_net(info),\n\t\t\t\t\t   info->attrs);\n\tint i, err;\n\tu32 vid, subcmd;\n\n\tif (!rdev->wiphy.vendor_commands)\n\t\treturn -EOPNOTSUPP;\n\n\tif (IS_ERR(wdev)) {\n\t\terr = PTR_ERR(wdev);\n\t\tif (err != -EINVAL)\n\t\t\treturn err;\n\t\twdev = NULL;\n\t} else if (wdev->wiphy != &rdev->wiphy) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_VENDOR_ID] ||\n\t    !info->attrs[NL80211_ATTR_VENDOR_SUBCMD])\n\t\treturn -EINVAL;\n\n\tvid = nla_get_u32(info->attrs[NL80211_ATTR_VENDOR_ID]);\n\tsubcmd = nla_get_u32(info->attrs[NL80211_ATTR_VENDOR_SUBCMD]);\n\tfor (i = 0; i < rdev->wiphy.n_vendor_commands; i++) {\n\t\tconst struct wiphy_vendor_command *vcmd;\n\t\tvoid *data = NULL;\n\t\tint len = 0;\n\n\t\tvcmd = &rdev->wiphy.vendor_commands[i];\n\n\t\tif (vcmd->info.vendor_id != vid || vcmd->info.subcmd != subcmd)\n\t\t\tcontinue;\n\n\t\tif (vcmd->flags & (WIPHY_VENDOR_CMD_NEED_WDEV |\n\t\t\t\t   WIPHY_VENDOR_CMD_NEED_NETDEV)) {\n\t\t\tif (!wdev)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_NETDEV &&\n\t\t\t    !wdev->netdev)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_RUNNING) {\n\t\t\t\tif (!wdev_running(wdev))\n\t\t\t\t\treturn -ENETDOWN;\n\t\t\t}\n\t\t} else {\n\t\t\twdev = NULL;\n\t\t}\n\n\t\tif (!vcmd->doit)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (info->attrs[NL80211_ATTR_VENDOR_DATA]) {\n\t\t\tdata = nla_data(info->attrs[NL80211_ATTR_VENDOR_DATA]);\n\t\t\tlen = nla_len(info->attrs[NL80211_ATTR_VENDOR_DATA]);\n\n\t\t\terr = nl80211_vendor_check_policy(vcmd,\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_VENDOR_DATA],\n\t\t\t\t\tinfo->extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\trdev->cur_cmd_info = info;\n\t\terr = vcmd->doit(&rdev->wiphy, wdev, data, len);\n\t\trdev->cur_cmd_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int nl80211_prepare_vendor_dump(struct sk_buff *skb,\n\t\t\t\t       struct netlink_callback *cb,\n\t\t\t\t       struct cfg80211_registered_device **rdev,\n\t\t\t\t       struct wireless_dev **wdev)\n{\n\tstruct nlattr **attrbuf;\n\tu32 vid, subcmd;\n\tunsigned int i;\n\tint vcmd_idx = -1;\n\tint err;\n\tvoid *data = NULL;\n\tunsigned int data_len = 0;\n\n\tif (cb->args[0]) {\n\t\t/* subtract the 1 again here */\n\t\tstruct wiphy *wiphy = wiphy_idx_to_wiphy(cb->args[0] - 1);\n\t\tstruct wireless_dev *tmp;\n\n\t\tif (!wiphy)\n\t\t\treturn -ENODEV;\n\t\t*rdev = wiphy_to_rdev(wiphy);\n\t\t*wdev = NULL;\n\n\t\tif (cb->args[1]) {\n\t\t\tlist_for_each_entry(tmp, &wiphy->wdev_list, list) {\n\t\t\t\tif (tmp->identifier == cb->args[1] - 1) {\n\t\t\t\t\t*wdev = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* keep rtnl locked in successful case */\n\t\treturn 0;\n\t}\n\n\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf), GFP_KERNEL);\n\tif (!attrbuf)\n\t\treturn -ENOMEM;\n\n\terr = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t     attrbuf, nl80211_fam.maxattr,\n\t\t\t\t     nl80211_policy, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tif (!attrbuf[NL80211_ATTR_VENDOR_ID] ||\n\t    !attrbuf[NL80211_ATTR_VENDOR_SUBCMD]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*wdev = __cfg80211_wdev_from_attrs(NULL, sock_net(skb->sk), attrbuf);\n\tif (IS_ERR(*wdev))\n\t\t*wdev = NULL;\n\n\t*rdev = __cfg80211_rdev_from_attrs(sock_net(skb->sk), attrbuf);\n\tif (IS_ERR(*rdev)) {\n\t\terr = PTR_ERR(*rdev);\n\t\tgoto out;\n\t}\n\n\tvid = nla_get_u32(attrbuf[NL80211_ATTR_VENDOR_ID]);\n\tsubcmd = nla_get_u32(attrbuf[NL80211_ATTR_VENDOR_SUBCMD]);\n\n\tfor (i = 0; i < (*rdev)->wiphy.n_vendor_commands; i++) {\n\t\tconst struct wiphy_vendor_command *vcmd;\n\n\t\tvcmd = &(*rdev)->wiphy.vendor_commands[i];\n\n\t\tif (vcmd->info.vendor_id != vid || vcmd->info.subcmd != subcmd)\n\t\t\tcontinue;\n\n\t\tif (!vcmd->dumpit) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tvcmd_idx = i;\n\t\tbreak;\n\t}\n\n\tif (vcmd_idx < 0) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (attrbuf[NL80211_ATTR_VENDOR_DATA]) {\n\t\tdata = nla_data(attrbuf[NL80211_ATTR_VENDOR_DATA]);\n\t\tdata_len = nla_len(attrbuf[NL80211_ATTR_VENDOR_DATA]);\n\n\t\terr = nl80211_vendor_check_policy(\n\t\t\t\t&(*rdev)->wiphy.vendor_commands[vcmd_idx],\n\t\t\t\tattrbuf[NL80211_ATTR_VENDOR_DATA],\n\t\t\t\tcb->extack);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/* 0 is the first index - add 1 to parse only once */\n\tcb->args[0] = (*rdev)->wiphy_idx + 1;\n\t/* add 1 to know if it was NULL */\n\tcb->args[1] = *wdev ? (*wdev)->identifier + 1 : 0;\n\tcb->args[2] = vcmd_idx;\n\tcb->args[3] = (unsigned long)data;\n\tcb->args[4] = data_len;\n\n\t/* keep rtnl locked in successful case */\n\terr = 0;\nout:\n\tkfree(attrbuf);\n\treturn err;\n}\n\nstatic int nl80211_vendor_cmd_dump(struct sk_buff *skb,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tunsigned int vcmd_idx;\n\tconst struct wiphy_vendor_command *vcmd;\n\tvoid *data;\n\tint data_len;\n\tint err;\n\tstruct nlattr *vendor_data;\n\n\trtnl_lock();\n\terr = nl80211_prepare_vendor_dump(skb, cb, &rdev, &wdev);\n\tif (err)\n\t\tgoto out;\n\n\tvcmd_idx = cb->args[2];\n\tdata = (void *)cb->args[3];\n\tdata_len = cb->args[4];\n\tvcmd = &rdev->wiphy.vendor_commands[vcmd_idx];\n\n\tif (vcmd->flags & (WIPHY_VENDOR_CMD_NEED_WDEV |\n\t\t\t   WIPHY_VENDOR_CMD_NEED_NETDEV)) {\n\t\tif (!wdev) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_NETDEV &&\n\t\t    !wdev->netdev) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_RUNNING) {\n\t\t\tif (!wdev_running(wdev)) {\n\t\t\t\terr = -ENETDOWN;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tvoid *hdr = nl80211hdr_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t   cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t   NL80211_CMD_VENDOR);\n\t\tif (!hdr)\n\t\t\tbreak;\n\n\t\tif (nla_put_u32(skb, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t\t    (wdev && nla_put_u64_64bit(skb, NL80211_ATTR_WDEV,\n\t\t\t\t\t       wdev_id(wdev),\n\t\t\t\t\t       NL80211_ATTR_PAD))) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\n\t\tvendor_data = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t    NL80211_ATTR_VENDOR_DATA);\n\t\tif (!vendor_data) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = vcmd->dumpit(&rdev->wiphy, wdev, skb, data, data_len,\n\t\t\t\t   (unsigned long *)&cb->args[5]);\n\t\tnla_nest_end(skb, vendor_data);\n\n\t\tif (err == -ENOBUFS || err == -ENOENT) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t} else if (err <= 0) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tgoto out;\n\t\t}\n\n\t\tgenlmsg_end(skb, hdr);\n\t}\n\n\terr = skb->len;\n out:\n\trtnl_unlock();\n\treturn err;\n}\n\nstruct sk_buff *__cfg80211_alloc_reply_skb(struct wiphy *wiphy,\n\t\t\t\t\t   enum nl80211_commands cmd,\n\t\t\t\t\t   enum nl80211_attrs attr,\n\t\t\t\t\t   int approxlen)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tif (WARN_ON(!rdev->cur_cmd_info))\n\t\treturn NULL;\n\n\treturn __cfg80211_alloc_vendor_skb(rdev, NULL, approxlen,\n\t\t\t\t\t   rdev->cur_cmd_info->snd_portid,\n\t\t\t\t\t   rdev->cur_cmd_info->snd_seq,\n\t\t\t\t\t   cmd, attr, NULL, GFP_KERNEL);\n}\nEXPORT_SYMBOL(__cfg80211_alloc_reply_skb);\n\nint cfg80211_vendor_cmd_reply(struct sk_buff *skb)\n{\n\tstruct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];\n\tvoid *hdr = ((void **)skb->cb)[1];\n\tstruct nlattr *data = ((void **)skb->cb)[2];\n\n\t/* clear CB data for netlink core to own from now on */\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\tif (WARN_ON(!rdev->cur_cmd_info)) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tnla_nest_end(skb, data);\n\tgenlmsg_end(skb, hdr);\n\treturn genlmsg_reply(skb, rdev->cur_cmd_info);\n}\nEXPORT_SYMBOL_GPL(cfg80211_vendor_cmd_reply);\n\nunsigned int cfg80211_vendor_cmd_get_sender(struct wiphy *wiphy)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tif (WARN_ON(!rdev->cur_cmd_info))\n\t\treturn 0;\n\n\treturn rdev->cur_cmd_info->snd_portid;\n}\nEXPORT_SYMBOL_GPL(cfg80211_vendor_cmd_get_sender);\n\nstatic int nl80211_set_qos_map(struct sk_buff *skb,\n\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_qos_map *qos_map = NULL;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *pos, len, num_des, des_len, des;\n\tint ret;\n\n\tif (!rdev->ops->set_qos_map)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_QOS_MAP]) {\n\t\tpos = nla_data(info->attrs[NL80211_ATTR_QOS_MAP]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_QOS_MAP]);\n\n\t\tif (len % 2)\n\t\t\treturn -EINVAL;\n\n\t\tqos_map = kzalloc(sizeof(struct cfg80211_qos_map), GFP_KERNEL);\n\t\tif (!qos_map)\n\t\t\treturn -ENOMEM;\n\n\t\tnum_des = (len - IEEE80211_QOS_MAP_LEN_MIN) >> 1;\n\t\tif (num_des) {\n\t\t\tdes_len = num_des *\n\t\t\t\tsizeof(struct cfg80211_dscp_exception);\n\t\t\tmemcpy(qos_map->dscp_exception, pos, des_len);\n\t\t\tqos_map->num_des = num_des;\n\t\t\tfor (des = 0; des < num_des; des++) {\n\t\t\t\tif (qos_map->dscp_exception[des].up > 7) {\n\t\t\t\t\tkfree(qos_map);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos += des_len;\n\t\t}\n\t\tmemcpy(qos_map->up, pos, IEEE80211_QOS_MAP_LEN_MIN);\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\tret = nl80211_key_allowed(dev->ieee80211_ptr);\n\tif (!ret)\n\t\tret = rdev_set_qos_map(rdev, dev, qos_map);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\tkfree(qos_map);\n\treturn ret;\n}\n\nstatic int nl80211_add_tx_ts(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *peer;\n\tu8 tsid, up;\n\tu16 admitted_time = 0;\n\tint err;\n\n\tif (!(rdev->wiphy.features & NL80211_FEATURE_SUPPORTS_WMM_ADMISSION))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_TSID] || !info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_USER_PRIO])\n\t\treturn -EINVAL;\n\n\ttsid = nla_get_u8(info->attrs[NL80211_ATTR_TSID]);\n\tup = nla_get_u8(info->attrs[NL80211_ATTR_USER_PRIO]);\n\n\t/* WMM uses TIDs 0-7 even for TSPEC */\n\tif (tsid >= IEEE80211_FIRST_TSPEC_TSID) {\n\t\t/* TODO: handle 802.11 TSPEC/admission control\n\t\t * need more attributes for that (e.g. BA session requirement);\n\t\t * change the WMM adminssion test above to allow both then\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (info->attrs[NL80211_ATTR_ADMITTED_TIME]) {\n\t\tadmitted_time =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_ADMITTED_TIME]);\n\t\tif (!admitted_time)\n\t\t\treturn -EINVAL;\n\t}\n\n\twdev_lock(wdev);\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (wdev->current_bss)\n\t\t\tbreak;\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = rdev_add_tx_ts(rdev, dev, tsid, peer, up, admitted_time);\n\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nstatic int nl80211_del_tx_ts(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *peer;\n\tu8 tsid;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_TSID] || !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\ttsid = nla_get_u8(info->attrs[NL80211_ATTR_TSID]);\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\twdev_lock(wdev);\n\terr = rdev_del_tx_ts(rdev, dev, tsid, peer);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_tdls_channel_switch(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_chan_def chandef = {};\n\tconst u8 *addr;\n\tu8 oper_class;\n\tint err;\n\n\tif (!rdev->ops->tdls_channel_switch ||\n\t    !(rdev->wiphy.features & NL80211_FEATURE_TDLS_CHANNEL_SWITCH))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_OPER_CLASS])\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * Don't allow wide channels on the 2.4Ghz band, as per IEEE802.11-2012\n\t * section 10.22.6.2.1. Disallow 5/10Mhz channels as well for now, the\n\t * specification is not defined for them.\n\t */\n\tif (chandef.chan->band == NL80211_BAND_2GHZ &&\n\t    chandef.width != NL80211_CHAN_WIDTH_20_NOHT &&\n\t    chandef.width != NL80211_CHAN_WIDTH_20)\n\t\treturn -EINVAL;\n\n\t/* we will be active on the TDLS link */\n\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &chandef,\n\t\t\t\t\t   wdev->iftype))\n\t\treturn -EINVAL;\n\n\t/* don't allow switching to DFS channels */\n\tif (cfg80211_chandef_dfs_required(wdev->wiphy, &chandef, wdev->iftype))\n\t\treturn -EINVAL;\n\n\taddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\toper_class = nla_get_u8(info->attrs[NL80211_ATTR_OPER_CLASS]);\n\n\twdev_lock(wdev);\n\terr = rdev_tdls_channel_switch(rdev, dev, addr, oper_class, &chandef);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_tdls_cancel_channel_switch(struct sk_buff *skb,\n\t\t\t\t\t      struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *addr;\n\n\tif (!rdev->ops->tdls_channel_switch ||\n\t    !rdev->ops->tdls_cancel_channel_switch ||\n\t    !(rdev->wiphy.features & NL80211_FEATURE_TDLS_CHANNEL_SWITCH))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\taddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\twdev_lock(wdev);\n\trdev_tdls_cancel_channel_switch(rdev, dev, addr);\n\twdev_unlock(wdev);\n\n\treturn 0;\n}\n\nstatic int nl80211_set_multicast_to_unicast(struct sk_buff *skb,\n\t\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst struct nlattr *nla;\n\tbool enabled;\n\n\tif (!rdev->ops->set_multicast_to_unicast)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tnla = info->attrs[NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED];\n\tenabled = nla_get_flag(nla);\n\n\treturn rdev_set_multicast_to_unicast(rdev, dev, enabled);\n}\n\nstatic int nl80211_set_pmk(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_pmk_conf pmk_conf = {};\n\tint ret;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] || !info->attrs[NL80211_ATTR_PMK])\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\tif (!wdev->current_bss) {\n\t\tret = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tpmk_conf.aa = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tif (memcmp(pmk_conf.aa, wdev->current_bss->pub.bssid, ETH_ALEN)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpmk_conf.pmk = nla_data(info->attrs[NL80211_ATTR_PMK]);\n\tpmk_conf.pmk_len = nla_len(info->attrs[NL80211_ATTR_PMK]);\n\tif (pmk_conf.pmk_len != WLAN_PMK_LEN &&\n\t    pmk_conf.pmk_len != WLAN_PMK_LEN_SUITE_B_192) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PMKR0_NAME])\n\t\tpmk_conf.pmk_r0_name =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_PMKR0_NAME]);\n\n\tret = rdev_set_pmk(rdev, dev, &pmk_conf);\nout:\n\twdev_unlock(wdev);\n\treturn ret;\n}\n\nstatic int nl80211_del_pmk(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *aa;\n\tint ret;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\taa = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tret = rdev_del_pmk(rdev, dev, aa);\n\twdev_unlock(wdev);\n\n\treturn ret;\n}\n\nstatic int nl80211_external_auth(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_external_auth_params params;\n\n\tif (!rdev->ops->external_auth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_SSID] &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_BSSID])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STATUS_CODE])\n\t\treturn -EINVAL;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (info->attrs[NL80211_ATTR_SSID]) {\n\t\tparams.ssid.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\t\tif (params.ssid.ssid_len == 0)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(params.ssid.ssid,\n\t\t       nla_data(info->attrs[NL80211_ATTR_SSID]),\n\t\t       params.ssid.ssid_len);\n\t}\n\n\tmemcpy(params.bssid, nla_data(info->attrs[NL80211_ATTR_BSSID]),\n\t       ETH_ALEN);\n\n\tparams.status = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);\n\n\tif (info->attrs[NL80211_ATTR_PMKID])\n\t\tparams.pmkid = nla_data(info->attrs[NL80211_ATTR_PMKID]);\n\n\treturn rdev_external_auth(rdev, dev, &params);\n}\n\nstatic int nl80211_tx_control_port(struct sk_buff *skb, struct genl_info *info)\n{\n\tbool dont_wait_for_ack = info->attrs[NL80211_ATTR_DONT_WAIT_FOR_ACK];\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *buf;\n\tsize_t len;\n\tu8 *dest;\n\tu16 proto;\n\tbool noencrypt;\n\tu64 cookie = 0;\n\tint err;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->tx_control_port)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_FRAME] ||\n\t    !info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]) {\n\t\tGENL_SET_ERR_MSG(info, \"Frame, MAC or ethertype missing\");\n\t\treturn -EINVAL;\n\t}\n\n\twdev_lock(wdev);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (wdev->current_bss)\n\t\t\tbreak;\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\twdev_unlock(wdev);\n\n\tbuf = nla_data(info->attrs[NL80211_ATTR_FRAME]);\n\tlen = nla_len(info->attrs[NL80211_ATTR_FRAME]);\n\tdest = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tproto = nla_get_u16(info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]);\n\tnoencrypt =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT]);\n\n\terr = rdev_tx_control_port(rdev, dev, buf, len,\n\t\t\t\t   dest, cpu_to_be16(proto), noencrypt,\n\t\t\t\t   dont_wait_for_ack ? NULL : &cookie);\n\tif (!err && !dont_wait_for_ack)\n\t\tnl_set_extack_cookie_u64(info->extack, cookie);\n\treturn err;\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nstatic int nl80211_get_ftm_responder_stats(struct sk_buff *skb,\n\t\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_ftm_responder_stats ftm_stats = {};\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *ftm_stats_attr;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP || !wdev->beacon_interval)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_ftm_responder_stats(rdev, dev, &ftm_stats);\n\tif (err)\n\t\treturn err;\n\n\tif (!ftm_stats.filled)\n\t\treturn -ENODATA;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_FTM_RESPONDER_STATS);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tftm_stats_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t       NL80211_ATTR_FTM_RESPONDER_STATS);\n\tif (!ftm_stats_attr)\n\t\tgoto nla_put_failure;\n\n#define SET_FTM(field, name, type)\t\t\t\t\t \\\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_ ## type(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t     ftm_stats.field))\t\t\t\t \\\n\t\tgoto nla_put_failure; } while (0)\n#define SET_FTM_U64(field, name)\t\t\t\t\t \\\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_u64_64bit(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t      ftm_stats.field, NL80211_FTM_STATS_PAD))\t \\\n\t\tgoto nla_put_failure; } while (0)\n\n\tSET_FTM(success_num, SUCCESS_NUM, u32);\n\tSET_FTM(partial_num, PARTIAL_NUM, u32);\n\tSET_FTM(failed_num, FAILED_NUM, u32);\n\tSET_FTM(asap_num, ASAP_NUM, u32);\n\tSET_FTM(non_asap_num, NON_ASAP_NUM, u32);\n\tSET_FTM_U64(total_duration_ms, TOTAL_DURATION_MSEC);\n\tSET_FTM(unknown_triggers_num, UNKNOWN_TRIGGERS_NUM, u32);\n\tSET_FTM(reschedule_requests_num, RESCHEDULE_REQUESTS_NUM, u32);\n\tSET_FTM(out_of_window_triggers_num, OUT_OF_WINDOW_TRIGGERS_NUM, u32);\n#undef SET_FTM\n\n\tnla_nest_end(msg, ftm_stats_attr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_update_owe_info(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_update_owe_info owe_info;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->update_owe_info)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_STATUS_CODE] ||\n\t    !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmemset(&owe_info, 0, sizeof(owe_info));\n\towe_info.status = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);\n\tnla_memcpy(owe_info.peer, info->attrs[NL80211_ATTR_MAC], ETH_ALEN);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\towe_info.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\towe_info.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\treturn rdev_update_owe_info(rdev, dev, &owe_info);\n}\n\nstatic int nl80211_probe_mesh_link(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct station_info sinfo = {};\n\tconst u8 *buf;\n\tsize_t len;\n\tu8 *dest;\n\tint err;\n\n\tif (!rdev->ops->probe_mesh_link || !rdev->ops->get_station)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_FRAME]) {\n\t\tGENL_SET_ERR_MSG(info, \"Frame or MAC missing\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tdest = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tbuf = nla_data(info->attrs[NL80211_ATTR_FRAME]);\n\tlen = nla_len(info->attrs[NL80211_ATTR_FRAME]);\n\n\tif (len < sizeof(struct ethhdr))\n\t\treturn -EINVAL;\n\n\tif (!ether_addr_equal(buf, dest) || is_multicast_ether_addr(buf) ||\n\t    !ether_addr_equal(buf + ETH_ALEN, dev->dev_addr))\n\t\treturn -EINVAL;\n\n\terr = rdev_get_station(rdev, dev, dest, &sinfo);\n\tif (err)\n\t\treturn err;\n\n\tcfg80211_sinfo_release_content(&sinfo);\n\n\treturn rdev_probe_mesh_link(rdev, dev, dest, buf, len);\n}\n\nstatic int parse_tid_conf(struct cfg80211_registered_device *rdev,\n\t\t\t  struct nlattr *attrs[], struct net_device *dev,\n\t\t\t  struct cfg80211_tid_cfg *tid_conf,\n\t\t\t  struct genl_info *info, const u8 *peer)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu64 mask;\n\tint err;\n\n\tif (!attrs[NL80211_TID_CONFIG_ATTR_TIDS])\n\t\treturn -EINVAL;\n\n\ttid_conf->config_override =\n\t\t\tnla_get_flag(attrs[NL80211_TID_CONFIG_ATTR_OVERRIDE]);\n\ttid_conf->tids = nla_get_u16(attrs[NL80211_TID_CONFIG_ATTR_TIDS]);\n\n\tif (tid_conf->config_override) {\n\t\tif (rdev->ops->reset_tid_config) {\n\t\t\terr = rdev_reset_tid_config(rdev, dev, peer,\n\t\t\t\t\t\t    tid_conf->tids);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_NOACK]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_NOACK);\n\t\ttid_conf->noack =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_NOACK]);\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_RETRY_SHORT]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_RETRY_SHORT);\n\t\ttid_conf->retry_short =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_RETRY_SHORT]);\n\n\t\tif (tid_conf->retry_short > rdev->wiphy.max_data_retry_count)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_RETRY_LONG]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_RETRY_LONG);\n\t\ttid_conf->retry_long =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_RETRY_LONG]);\n\n\t\tif (tid_conf->retry_long > rdev->wiphy.max_data_retry_count)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_AMPDU_CTRL]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL);\n\t\ttid_conf->ampdu =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_AMPDU_CTRL]);\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL);\n\t\ttid_conf->rtscts =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL]);\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_AMSDU_CTRL]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_AMSDU_CTRL);\n\t\ttid_conf->amsdu =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_AMSDU_CTRL]);\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE]) {\n\t\tu32 idx = NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE, attr;\n\n\t\ttid_conf->txrate_type = nla_get_u8(attrs[idx]);\n\n\t\tif (tid_conf->txrate_type != NL80211_TX_RATE_AUTOMATIC) {\n\t\t\tattr = NL80211_TID_CONFIG_ATTR_TX_RATE;\n\t\t\terr = nl80211_parse_tx_bitrate_mask(info, attrs, attr,\n\t\t\t\t\t\t    &tid_conf->txrate_mask, dev,\n\t\t\t\t\t\t    true);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_TX_RATE);\n\t\t}\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE);\n\t}\n\n\tif (peer)\n\t\tmask = rdev->wiphy.tid_config_support.peer;\n\telse\n\t\tmask = rdev->wiphy.tid_config_support.vif;\n\n\tif (tid_conf->mask & ~mask) {\n\t\tNL_SET_ERR_MSG(extack, \"unsupported TID configuration\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_set_tid_config(struct sk_buff *skb,\n\t\t\t\t  struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *attrs[NL80211_TID_CONFIG_ATTR_MAX + 1];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_tid_config *tid_config;\n\tstruct nlattr *tid;\n\tint conf_idx = 0, rem_conf;\n\tint ret = -EINVAL;\n\tu32 num_conf = 0;\n\n\tif (!info->attrs[NL80211_ATTR_TID_CONFIG])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->set_tid_config)\n\t\treturn -EOPNOTSUPP;\n\n\tnla_for_each_nested(tid, info->attrs[NL80211_ATTR_TID_CONFIG],\n\t\t\t    rem_conf)\n\t\tnum_conf++;\n\n\ttid_config = kzalloc(struct_size(tid_config, tid_conf, num_conf),\n\t\t\t     GFP_KERNEL);\n\tif (!tid_config)\n\t\treturn -ENOMEM;\n\n\ttid_config->n_tid_conf = num_conf;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\ttid_config->peer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tnla_for_each_nested(tid, info->attrs[NL80211_ATTR_TID_CONFIG],\n\t\t\t    rem_conf) {\n\t\tret = nla_parse_nested(attrs, NL80211_TID_CONFIG_ATTR_MAX,\n\t\t\t\t       tid, NULL, NULL);\n\n\t\tif (ret)\n\t\t\tgoto bad_tid_conf;\n\n\t\tret = parse_tid_conf(rdev, attrs, dev,\n\t\t\t\t     &tid_config->tid_conf[conf_idx],\n\t\t\t\t     info, tid_config->peer);\n\t\tif (ret)\n\t\t\tgoto bad_tid_conf;\n\n\t\tconf_idx++;\n\t}\n\n\tret = rdev_set_tid_config(rdev, dev, tid_config);\n\nbad_tid_conf:\n\tkfree(tid_config);\n\treturn ret;\n}\n\n#define NL80211_FLAG_NEED_WIPHY\t\t0x01\n#define NL80211_FLAG_NEED_NETDEV\t0x02\n#define NL80211_FLAG_NEED_RTNL\t\t0x04\n#define NL80211_FLAG_CHECK_NETDEV_UP\t0x08\n#define NL80211_FLAG_NEED_NETDEV_UP\t(NL80211_FLAG_NEED_NETDEV |\\\n\t\t\t\t\t NL80211_FLAG_CHECK_NETDEV_UP)\n#define NL80211_FLAG_NEED_WDEV\t\t0x10\n/* If a netdev is associated, it must be UP, P2P must be started */\n#define NL80211_FLAG_NEED_WDEV_UP\t(NL80211_FLAG_NEED_WDEV |\\\n\t\t\t\t\t NL80211_FLAG_CHECK_NETDEV_UP)\n#define NL80211_FLAG_CLEAR_SKB\t\t0x20\n\nstatic int nl80211_pre_doit(const struct genl_ops *ops, struct sk_buff *skb,\n\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = NULL;\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev;\n\n\trtnl_lock();\n\tif (ops->internal_flags & NL80211_FLAG_NEED_WIPHY) {\n\t\trdev = cfg80211_get_dev_from_info(genl_info_net(info), info);\n\t\tif (IS_ERR(rdev)) {\n\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t\tinfo->user_ptr[0] = rdev;\n\t} else if (ops->internal_flags & NL80211_FLAG_NEED_NETDEV ||\n\t\t   ops->internal_flags & NL80211_FLAG_NEED_WDEV) {\n\t\twdev = __cfg80211_wdev_from_attrs(NULL, genl_info_net(info),\n\t\t\t\t\t\t  info->attrs);\n\t\tif (IS_ERR(wdev)) {\n\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(wdev);\n\t\t}\n\n\t\tdev = wdev->netdev;\n\t\trdev = wiphy_to_rdev(wdev->wiphy);\n\n\t\tif (ops->internal_flags & NL80211_FLAG_NEED_NETDEV) {\n\t\t\tif (!dev) {\n\t\t\t\trtnl_unlock();\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tinfo->user_ptr[1] = dev;\n\t\t} else {\n\t\t\tinfo->user_ptr[1] = wdev;\n\t\t}\n\n\t\tif (ops->internal_flags & NL80211_FLAG_CHECK_NETDEV_UP &&\n\t\t    !wdev_running(wdev)) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENETDOWN;\n\t\t}\n\n\t\tif (dev)\n\t\t\tdev_hold(dev);\n\n\t\tinfo->user_ptr[0] = rdev;\n\t}\n\n\tif (rdev)\n\t\tmutex_lock(&rdev->wiphy.mtx);\n\tif (!(ops->internal_flags & NL80211_FLAG_NEED_RTNL))\n\t\trtnl_unlock();\n\n\treturn 0;\n}\n\nstatic void nl80211_post_doit(const struct genl_ops *ops, struct sk_buff *skb,\n\t\t\t      struct genl_info *info)\n{\n\tif (info->user_ptr[1]) {\n\t\tif (ops->internal_flags & NL80211_FLAG_NEED_WDEV) {\n\t\t\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\t\t\tif (wdev->netdev)\n\t\t\t\tdev_put(wdev->netdev);\n\t\t} else {\n\t\t\tdev_put(info->user_ptr[1]);\n\t\t}\n\t}\n\n\tif (info->user_ptr[0]) {\n\t\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\n\t\tmutex_unlock(&rdev->wiphy.mtx);\n\t}\n\n\tif (ops->internal_flags & NL80211_FLAG_NEED_RTNL)\n\t\trtnl_unlock();\n\n\t/* If needed, clear the netlink message payload from the SKB\n\t * as it might contain key data that shouldn't stick around on\n\t * the heap after the SKB is freed. The netlink message header\n\t * is still needed for further processing, so leave it intact.\n\t */\n\tif (ops->internal_flags & NL80211_FLAG_CLEAR_SKB) {\n\t\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\n\t\tmemset(nlmsg_data(nlh), 0, nlmsg_len(nlh));\n\t}\n}\n\nstatic int nl80211_set_sar_sub_specs(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct cfg80211_sar_specs *sar_specs,\n\t\t\t\t     struct nlattr *spec[], int index)\n{\n\tu32 range_index, i;\n\n\tif (!sar_specs || !spec)\n\t\treturn -EINVAL;\n\n\tif (!spec[NL80211_SAR_ATTR_SPECS_POWER] ||\n\t    !spec[NL80211_SAR_ATTR_SPECS_RANGE_INDEX])\n\t\treturn -EINVAL;\n\n\trange_index = nla_get_u32(spec[NL80211_SAR_ATTR_SPECS_RANGE_INDEX]);\n\n\t/* check if range_index exceeds num_freq_ranges */\n\tif (range_index >= rdev->wiphy.sar_capa->num_freq_ranges)\n\t\treturn -EINVAL;\n\n\t/* check if range_index duplicates */\n\tfor (i = 0; i < index; i++) {\n\t\tif (sar_specs->sub_specs[i].freq_range_index == range_index)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsar_specs->sub_specs[index].power =\n\t\tnla_get_s32(spec[NL80211_SAR_ATTR_SPECS_POWER]);\n\n\tsar_specs->sub_specs[index].freq_range_index = range_index;\n\n\treturn 0;\n}\n\nstatic int nl80211_set_sar_specs(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *spec[NL80211_SAR_ATTR_SPECS_MAX + 1];\n\tstruct nlattr *tb[NL80211_SAR_ATTR_MAX + 1];\n\tstruct cfg80211_sar_specs *sar_spec;\n\tenum nl80211_sar_type type;\n\tstruct nlattr *spec_list;\n\tu32 specs;\n\tint rem, err;\n\n\tif (!rdev->wiphy.sar_capa || !rdev->ops->set_sar_specs)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_SAR_SPEC])\n\t\treturn -EINVAL;\n\n\tnla_parse_nested(tb, NL80211_SAR_ATTR_MAX,\n\t\t\t info->attrs[NL80211_ATTR_SAR_SPEC],\n\t\t\t NULL, NULL);\n\n\tif (!tb[NL80211_SAR_ATTR_TYPE] || !tb[NL80211_SAR_ATTR_SPECS])\n\t\treturn -EINVAL;\n\n\ttype = nla_get_u32(tb[NL80211_SAR_ATTR_TYPE]);\n\tif (type != rdev->wiphy.sar_capa->type)\n\t\treturn -EINVAL;\n\n\tspecs = 0;\n\tnla_for_each_nested(spec_list, tb[NL80211_SAR_ATTR_SPECS], rem)\n\t\tspecs++;\n\n\tif (specs > rdev->wiphy.sar_capa->num_freq_ranges)\n\t\treturn -EINVAL;\n\n\tsar_spec = kzalloc(sizeof(*sar_spec) +\n\t\t\t   specs * sizeof(struct cfg80211_sar_sub_specs),\n\t\t\t   GFP_KERNEL);\n\tif (!sar_spec)\n\t\treturn -ENOMEM;\n\n\tsar_spec->type = type;\n\tspecs = 0;\n\tnla_for_each_nested(spec_list, tb[NL80211_SAR_ATTR_SPECS], rem) {\n\t\tnla_parse_nested(spec, NL80211_SAR_ATTR_SPECS_MAX,\n\t\t\t\t spec_list, NULL, NULL);\n\n\t\tswitch (type) {\n\t\tcase NL80211_SAR_TYPE_POWER:\n\t\t\tif (nl80211_set_sar_sub_specs(rdev, sar_spec,\n\t\t\t\t\t\t      spec, specs)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tspecs++;\n\t}\n\n\tsar_spec->num_sub_specs = specs;\n\n\trdev->cur_cmd_info = info;\n\terr = rdev_set_sar_specs(rdev, sar_spec);\n\trdev->cur_cmd_info = NULL;\nerror:\n\tkfree(sar_spec);\n\treturn err;\n}\n\nstatic const struct genl_ops nl80211_ops[] = {\n\t{\n\t\t.cmd = NL80211_CMD_GET_WIPHY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_wiphy,\n\t\t.dumpit = nl80211_dump_wiphy,\n\t\t.done = nl80211_dump_wiphy_done,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY,\n\t},\n};\n\nstatic const struct genl_small_ops nl80211_small_ops[] = {\n\t{\n\t\t.cmd = NL80211_CMD_SET_WIPHY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_wiphy,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_interface,\n\t\t.dumpit = nl80211_dump_interface,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_interface,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_interface,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_interface,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_BEACON,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = nl80211_set_beacon,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_AP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = nl80211_start_ap,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_AP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = nl80211_stop_ap,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_station,\n\t\t.dumpit = nl80211_dump_station,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_mpath,\n\t\t.dumpit = nl80211_dump_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MPP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_mpp,\n\t\t.dumpit = nl80211_dump_mpp,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_BSS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_bss,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_REG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_reg_do,\n\t\t.dumpit = nl80211_get_reg_dump,\n\t\t.internal_flags = 0,\n\t\t/* can be retrieved by unprivileged users */\n\t},\n#ifdef CONFIG_CFG80211_CRDA_SUPPORT\n\t{\n\t\t.cmd = NL80211_CMD_SET_REG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_reg,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = 0,\n\t},\n#endif\n\t{\n\t\t.cmd = NL80211_CMD_REQ_SET_REG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_req_set_reg,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_RELOAD_REGDB,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_reload_regdb,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MESH_CONFIG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_mesh_config,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MESH_CONFIG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_update_mesh_config,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TRIGGER_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_trigger_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ABORT_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_abort_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.dumpit = nl80211_dump_scan,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_SCHED_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_sched_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_SCHED_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_stop_sched_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_AUTHENTICATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_authenticate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  0 |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ASSOCIATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_associate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  0 |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEAUTHENTICATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_deauthenticate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DISASSOCIATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_disassociate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_IBSS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_join_ibss,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_IBSS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_leave_ibss,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n#ifdef CONFIG_NL80211_TESTMODE\n\t{\n\t\t.cmd = NL80211_CMD_TESTMODE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_testmode_do,\n\t\t.dumpit = nl80211_testmode_dump,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY,\n\t},\n#endif\n\t{\n\t\t.cmd = NL80211_CMD_CONNECT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_connect,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  0 |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UPDATE_CONNECT_PARAMS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_update_connect_params,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  0 |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DISCONNECT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_disconnect,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WIPHY_NETNS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_wiphy_netns,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_SURVEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.dumpit = nl80211_dump_survey,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_PMKSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_setdel_pmksa,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  0 |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_PMKSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_setdel_pmksa,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FLUSH_PMKSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_flush_pmksa,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REMAIN_ON_CHANNEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_remain_on_channel,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_cancel_remain_on_channel,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_TX_BITRATE_MASK,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_tx_bitrate_mask,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REGISTER_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_register_mgmt,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tx_mgmt,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FRAME_WAIT_CANCEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tx_mgmt_cancel_wait,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_POWER_SAVE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_power_save,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_POWER_SAVE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_power_save,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_CQM,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_cqm,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_CHANNEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_channel,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_MESH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_join_mesh,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_MESH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_leave_mesh,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_OCB,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_join_ocb,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_OCB,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_leave_ocb,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n#ifdef CONFIG_PM\n\t{\n\t\t.cmd = NL80211_CMD_GET_WOWLAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_wowlan,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WOWLAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_wowlan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY,\n\t},\n#endif\n\t{\n\t\t.cmd = NL80211_CMD_SET_REKEY_OFFLOAD,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_rekey_data,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  0 |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_MGMT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_mgmt,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_OPER,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_oper,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UNEXPECTED_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_register_unexpected_frame,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_PROBE_CLIENT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_probe_client,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REGISTER_BEACONS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_register_beacons,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_NOACK_MAP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_noack_map,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_P2P_DEVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_p2p_device,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_P2P_DEVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_stop_p2p_device,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_NAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_nan,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_NAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_stop_nan,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ADD_NAN_FUNCTION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_nan_add_func,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_NAN_FUNCTION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_nan_del_func,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CHANGE_NAN_CONFIG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_nan_change_config,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MCAST_RATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_mcast_rate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MAC_ACL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_mac_acl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_RADAR_DETECT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_radar_detection,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_PROTOCOL_FEATURES,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_protocol_features,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UPDATE_FT_IES,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_update_ft_ies,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CRIT_PROTOCOL_START,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_crit_protocol_start,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CRIT_PROTOCOL_STOP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_crit_protocol_stop,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_COALESCE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_coalesce,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_COALESCE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_coalesce,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CHANNEL_SWITCH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_channel_switch,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_VENDOR,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_vendor_cmd,\n\t\t.dumpit = nl80211_vendor_cmd_dump,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  0 |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_QOS_MAP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_qos_map,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ADD_TX_TS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_add_tx_ts,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_TX_TS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_tx_ts,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_CHANNEL_SWITCH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_channel_switch,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_cancel_channel_switch,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MULTICAST_TO_UNICAST,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_multicast_to_unicast,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_PMK,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_pmk,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  0 |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_PMK,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_pmk,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_EXTERNAL_AUTH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_external_auth,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CONTROL_PORT_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tx_control_port,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_FTM_RESPONDER_STATS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_ftm_responder_stats,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_PEER_MEASUREMENT_START,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_pmsr_start,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NOTIFY_RADAR,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_notify_radar_detection,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UPDATE_OWE_INFO,\n\t\t.doit = nl80211_update_owe_info,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_PROBE_MESH_LINK,\n\t\t.doit = nl80211_probe_mesh_link,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_TID_CONFIG,\n\t\t.doit = nl80211_set_tid_config,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_SAR_SPECS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_sar_specs,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n};\n\nstatic struct genl_family nl80211_fam __ro_after_init = {\n\t.name = NL80211_GENL_NAME,\t/* have users key off the name instead */\n\t.hdrsize = 0,\t\t\t/* no private header */\n\t.version = 1,\t\t\t/* no particular meaning now */\n\t.maxattr = NL80211_ATTR_MAX,\n\t.policy = nl80211_policy,\n\t.netnsok = true,\n\t.pre_doit = nl80211_pre_doit,\n\t.post_doit = nl80211_post_doit,\n\t.module = THIS_MODULE,\n\t.ops = nl80211_ops,\n\t.n_ops = ARRAY_SIZE(nl80211_ops),\n\t.small_ops = nl80211_small_ops,\n\t.n_small_ops = ARRAY_SIZE(nl80211_small_ops),\n\t.mcgrps = nl80211_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(nl80211_mcgrps),\n\t.parallel_ops = true,\n};\n\n/* notification functions */\n\nvoid nl80211_notify_wiphy(struct cfg80211_registered_device *rdev,\n\t\t\t  enum nl80211_commands cmd)\n{\n\tstruct sk_buff *msg;\n\tstruct nl80211_dump_wiphy_state state = {};\n\n\tWARN_ON(cmd != NL80211_CMD_NEW_WIPHY &&\n\t\tcmd != NL80211_CMD_DEL_WIPHY);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_wiphy(rdev, cmd, msg, 0, 0, 0, &state) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nvoid nl80211_notify_iface(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct wireless_dev *wdev,\n\t\t\t\tenum nl80211_commands cmd)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_iface(msg, 0, 0, 0, rdev, wdev, cmd) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nstatic int nl80211_add_scan_req(struct sk_buff *msg,\n\t\t\t\tstruct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_scan_request *req = rdev->scan_req;\n\tstruct nlattr *nest;\n\tint i;\n\tstruct cfg80211_scan_info *info;\n\n\tif (WARN_ON(!req))\n\t\treturn 0;\n\n\tnest = nla_nest_start_noflag(msg, NL80211_ATTR_SCAN_SSIDS);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tfor (i = 0; i < req->n_ssids; i++) {\n\t\tif (nla_put(msg, i, req->ssids[i].ssid_len, req->ssids[i].ssid))\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(msg, nest);\n\n\tif (req->flags & NL80211_SCAN_FLAG_FREQ_KHZ) {\n\t\tnest = nla_nest_start(msg, NL80211_ATTR_SCAN_FREQ_KHZ);\n\t\tif (!nest)\n\t\t\tgoto nla_put_failure;\n\t\tfor (i = 0; i < req->n_channels; i++) {\n\t\t\tif (nla_put_u32(msg, i,\n\t\t\t\t   ieee80211_channel_to_khz(req->channels[i])))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(msg, nest);\n\t} else {\n\t\tnest = nla_nest_start_noflag(msg,\n\t\t\t\t\t     NL80211_ATTR_SCAN_FREQUENCIES);\n\t\tif (!nest)\n\t\t\tgoto nla_put_failure;\n\t\tfor (i = 0; i < req->n_channels; i++) {\n\t\t\tif (nla_put_u32(msg, i, req->channels[i]->center_freq))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(msg, nest);\n\t}\n\n\tif (req->ie &&\n\t    nla_put(msg, NL80211_ATTR_IE, req->ie_len, req->ie))\n\t\tgoto nla_put_failure;\n\n\tif (req->flags &&\n\t    nla_put_u32(msg, NL80211_ATTR_SCAN_FLAGS, req->flags))\n\t\tgoto nla_put_failure;\n\n\tinfo = rdev->int_scan_req ? &rdev->int_scan_req->info :\n\t\t&rdev->scan_req->info;\n\tif (info->scan_start_tsf &&\n\t    (nla_put_u64_64bit(msg, NL80211_ATTR_SCAN_START_TIME_TSF,\n\t\t\t       info->scan_start_tsf, NL80211_BSS_PAD) ||\n\t     nla_put(msg, NL80211_ATTR_SCAN_START_TIME_TSF_BSSID, ETH_ALEN,\n\t\t     info->tsf_bssid)))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_prep_scan_msg(struct sk_buff *msg,\n\t\t\t\t struct cfg80211_registered_device *rdev,\n\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t u32 portid, u32 seq, int flags,\n\t\t\t\t u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\t/* ignore errors and send incomplete event anyway */\n\tnl80211_add_scan_req(msg, rdev);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int\nnl80211_prep_sched_scan_msg(struct sk_buff *msg,\n\t\t\t    struct cfg80211_sched_scan_request *req, u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY,\n\t\t\twiphy_to_rdev(req->wiphy)->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, req->dev->ifindex) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, req->reqid,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nvoid nl80211_send_scan_start(struct cfg80211_registered_device *rdev,\n\t\t\t     struct wireless_dev *wdev)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_prep_scan_msg(msg, rdev, wdev, 0, 0, 0,\n\t\t\t\t  NL80211_CMD_TRIGGER_SCAN) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_SCAN, GFP_KERNEL);\n}\n\nstruct sk_buff *nl80211_build_scan_msg(struct cfg80211_registered_device *rdev,\n\t\t\t\t       struct wireless_dev *wdev, bool aborted)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn NULL;\n\n\tif (nl80211_prep_scan_msg(msg, rdev, wdev, 0, 0, 0,\n\t\t\t\t  aborted ? NL80211_CMD_SCAN_ABORTED :\n\t\t\t\t\t    NL80211_CMD_NEW_SCAN_RESULTS) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn NULL;\n\t}\n\n\treturn msg;\n}\n\n/* send message created by nl80211_build_scan_msg() */\nvoid nl80211_send_scan_msg(struct cfg80211_registered_device *rdev,\n\t\t\t   struct sk_buff *msg)\n{\n\tif (!msg)\n\t\treturn;\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_SCAN, GFP_KERNEL);\n}\n\nvoid nl80211_send_sched_scan(struct cfg80211_sched_scan_request *req, u32 cmd)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_prep_sched_scan_msg(msg, req, cmd) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(req->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_SCAN, GFP_KERNEL);\n}\n\nstatic bool nl80211_reg_change_event_fill(struct sk_buff *msg,\n\t\t\t\t\t  struct regulatory_request *request)\n{\n\t/* Userspace can always count this one always being set */\n\tif (nla_put_u8(msg, NL80211_ATTR_REG_INITIATOR, request->initiator))\n\t\tgoto nla_put_failure;\n\n\tif (request->alpha2[0] == '0' && request->alpha2[1] == '0') {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_WORLD))\n\t\t\tgoto nla_put_failure;\n\t} else if (request->alpha2[0] == '9' && request->alpha2[1] == '9') {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_CUSTOM_WORLD))\n\t\t\tgoto nla_put_failure;\n\t} else if ((request->alpha2[0] == '9' && request->alpha2[1] == '8') ||\n\t\t   request->intersect) {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_INTERSECTION))\n\t\t\tgoto nla_put_failure;\n\t} else {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_COUNTRY) ||\n\t\t    nla_put_string(msg, NL80211_ATTR_REG_ALPHA2,\n\t\t\t\t   request->alpha2))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (request->wiphy_idx != WIPHY_IDX_INVALID) {\n\t\tstruct wiphy *wiphy = wiphy_idx_to_wiphy(request->wiphy_idx);\n\n\t\tif (wiphy &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY, request->wiphy_idx))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (wiphy &&\n\t\t    wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn true;\n\nnla_put_failure:\n\treturn false;\n}\n\n/*\n * This can happen on global regulatory changes or device specific settings\n * based on custom regulatory domains.\n */\nvoid nl80211_common_reg_change_event(enum nl80211_commands cmd_id,\n\t\t\t\t     struct regulatory_request *request)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd_id);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (!nl80211_reg_change_event_fill(msg, request))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\trcu_read_lock();\n\tgenlmsg_multicast_allns(&nl80211_fam, msg, 0,\n\t\t\t\tNL80211_MCGRP_REGULATORY, GFP_ATOMIC);\n\trcu_read_unlock();\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\n\nstatic void nl80211_send_mlme_event(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct net_device *netdev,\n\t\t\t\t    const u8 *buf, size_t len,\n\t\t\t\t    enum nl80211_commands cmd, gfp_t gfp,\n\t\t\t\t    int uapsd_queues, const u8 *req_ies,\n\t\t\t\t    size_t req_ies_len, bool reconnect)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + len + req_ies_len, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_FRAME, len, buf) ||\n\t    (req_ies &&\n\t     nla_put(msg, NL80211_ATTR_REQ_IE, req_ies_len, req_ies)))\n\t\tgoto nla_put_failure;\n\n\tif (reconnect && nla_put_flag(msg, NL80211_ATTR_RECONNECT_REQUESTED))\n\t\tgoto nla_put_failure;\n\n\tif (uapsd_queues >= 0) {\n\t\tstruct nlattr *nla_wmm =\n\t\t\tnla_nest_start_noflag(msg, NL80211_ATTR_STA_WME);\n\t\tif (!nla_wmm)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u8(msg, NL80211_STA_WME_UAPSD_QUEUES,\n\t\t\t       uapsd_queues))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nla_wmm);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_rx_auth(struct cfg80211_registered_device *rdev,\n\t\t\t  struct net_device *netdev, const u8 *buf,\n\t\t\t  size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_AUTHENTICATE, gfp, -1, NULL, 0,\n\t\t\t\tfalse);\n}\n\nvoid nl80211_send_rx_assoc(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net_device *netdev, const u8 *buf,\n\t\t\t   size_t len, gfp_t gfp, int uapsd_queues,\n\t\t\t   const u8 *req_ies, size_t req_ies_len)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_ASSOCIATE, gfp, uapsd_queues,\n\t\t\t\treq_ies, req_ies_len, false);\n}\n\nvoid nl80211_send_deauth(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *netdev, const u8 *buf,\n\t\t\t size_t len, bool reconnect, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_DEAUTHENTICATE, gfp, -1, NULL, 0,\n\t\t\t\treconnect);\n}\n\nvoid nl80211_send_disassoc(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net_device *netdev, const u8 *buf,\n\t\t\t   size_t len, bool reconnect, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_DISASSOCIATE, gfp, -1, NULL, 0,\n\t\t\t\treconnect);\n}\n\nvoid cfg80211_rx_unprot_mlme_mgmt(struct net_device *dev, const u8 *buf,\n\t\t\t\t  size_t len)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tconst struct ieee80211_mgmt *mgmt = (void *)buf;\n\tu32 cmd;\n\n\tif (WARN_ON(len < 2))\n\t\treturn;\n\n\tif (ieee80211_is_deauth(mgmt->frame_control)) {\n\t\tcmd = NL80211_CMD_UNPROT_DEAUTHENTICATE;\n\t} else if (ieee80211_is_disassoc(mgmt->frame_control)) {\n\t\tcmd = NL80211_CMD_UNPROT_DISASSOCIATE;\n\t} else if (ieee80211_is_beacon(mgmt->frame_control)) {\n\t\tif (wdev->unprot_beacon_reported &&\n\t\t    elapsed_jiffies_msecs(wdev->unprot_beacon_reported) < 10000)\n\t\t\treturn;\n\t\tcmd = NL80211_CMD_UNPROT_BEACON;\n\t\twdev->unprot_beacon_reported = jiffies;\n\t} else {\n\t\treturn;\n\t}\n\n\ttrace_cfg80211_rx_unprot_mlme_mgmt(dev, buf, len);\n\tnl80211_send_mlme_event(rdev, dev, buf, len, cmd, GFP_ATOMIC, -1,\n\t\t\t\tNULL, 0, false);\n}\nEXPORT_SYMBOL(cfg80211_rx_unprot_mlme_mgmt);\n\nstatic void nl80211_send_mlme_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t\t      struct net_device *netdev, int cmd,\n\t\t\t\t      const u8 *addr, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put_flag(msg, NL80211_ATTR_TIMED_OUT) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_auth_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, const u8 *addr,\n\t\t\t       gfp_t gfp)\n{\n\tnl80211_send_mlme_timeout(rdev, netdev, NL80211_CMD_AUTHENTICATE,\n\t\t\t\t  addr, gfp);\n}\n\nvoid nl80211_send_assoc_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *netdev, const u8 *addr,\n\t\t\t\tgfp_t gfp)\n{\n\tnl80211_send_mlme_timeout(rdev, netdev, NL80211_CMD_ASSOCIATE,\n\t\t\t\t  addr, gfp);\n}\n\nvoid nl80211_send_connect_result(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev,\n\t\t\t\t struct cfg80211_connect_resp_params *cr,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + cr->req_ie_len + cr->resp_ie_len +\n\t\t\tcr->fils.kek_len + cr->fils.pmk_len +\n\t\t\t(cr->fils.pmkid ? WLAN_PMKID_LEN : 0), gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CONNECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    (cr->bssid &&\n\t     nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, cr->bssid)) ||\n\t    nla_put_u16(msg, NL80211_ATTR_STATUS_CODE,\n\t\t\tcr->status < 0 ? WLAN_STATUS_UNSPECIFIED_FAILURE :\n\t\t\tcr->status) ||\n\t    (cr->status < 0 &&\n\t     (nla_put_flag(msg, NL80211_ATTR_TIMED_OUT) ||\n\t      nla_put_u32(msg, NL80211_ATTR_TIMEOUT_REASON,\n\t\t\t  cr->timeout_reason))) ||\n\t    (cr->req_ie &&\n\t     nla_put(msg, NL80211_ATTR_REQ_IE, cr->req_ie_len, cr->req_ie)) ||\n\t    (cr->resp_ie &&\n\t     nla_put(msg, NL80211_ATTR_RESP_IE, cr->resp_ie_len,\n\t\t     cr->resp_ie)) ||\n\t    (cr->fils.update_erp_next_seq_num &&\n\t     nla_put_u16(msg, NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM,\n\t\t\t cr->fils.erp_next_seq_num)) ||\n\t    (cr->status == WLAN_STATUS_SUCCESS &&\n\t     ((cr->fils.kek &&\n\t       nla_put(msg, NL80211_ATTR_FILS_KEK, cr->fils.kek_len,\n\t\t       cr->fils.kek)) ||\n\t      (cr->fils.pmk &&\n\t       nla_put(msg, NL80211_ATTR_PMK, cr->fils.pmk_len, cr->fils.pmk)) ||\n\t      (cr->fils.pmkid &&\n\t       nla_put(msg, NL80211_ATTR_PMKID, WLAN_PMKID_LEN, cr->fils.pmkid)))))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_roamed(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *netdev,\n\t\t\t struct cfg80211_roam_info *info, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tconst u8 *bssid = info->bss ? info->bss->bssid : info->bssid;\n\n\tmsg = nlmsg_new(100 + info->req_ie_len + info->resp_ie_len +\n\t\t\tinfo->fils.kek_len + info->fils.pmk_len +\n\t\t\t(info->fils.pmkid ? WLAN_PMKID_LEN : 0), gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_ROAM);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid) ||\n\t    (info->req_ie &&\n\t     nla_put(msg, NL80211_ATTR_REQ_IE, info->req_ie_len,\n\t\t     info->req_ie)) ||\n\t    (info->resp_ie &&\n\t     nla_put(msg, NL80211_ATTR_RESP_IE, info->resp_ie_len,\n\t\t     info->resp_ie)) ||\n\t    (info->fils.update_erp_next_seq_num &&\n\t     nla_put_u16(msg, NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM,\n\t\t\t info->fils.erp_next_seq_num)) ||\n\t    (info->fils.kek &&\n\t     nla_put(msg, NL80211_ATTR_FILS_KEK, info->fils.kek_len,\n\t\t     info->fils.kek)) ||\n\t    (info->fils.pmk &&\n\t     nla_put(msg, NL80211_ATTR_PMK, info->fils.pmk_len, info->fils.pmk)) ||\n\t    (info->fils.pmkid &&\n\t     nla_put(msg, NL80211_ATTR_PMKID, WLAN_PMKID_LEN, info->fils.pmkid)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_port_authorized(struct cfg80211_registered_device *rdev,\n\t\t\t\t  struct net_device *netdev, const u8 *bssid)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PORT_AUTHORIZED);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_disconnected(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u16 reason,\n\t\t\t       const u8 *ie, size_t ie_len, bool from_ap)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + ie_len, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    (reason &&\n\t     nla_put_u16(msg, NL80211_ATTR_REASON_CODE, reason)) ||\n\t    (from_ap &&\n\t     nla_put_flag(msg, NL80211_ATTR_DISCONNECTED_BY_AP)) ||\n\t    (ie && nla_put(msg, NL80211_ATTR_IE, ie_len, ie)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_ibss_bssid(struct cfg80211_registered_device *rdev,\n\t\t\t     struct net_device *netdev, const u8 *bssid,\n\t\t\t     gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_JOIN_IBSS);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_notify_new_peer_candidate(struct net_device *dev, const u8 *addr,\n\t\t\t\t\tconst u8 *ie, u8 ie_len,\n\t\t\t\t\tint sig_dbm, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_MESH_POINT))\n\t\treturn;\n\n\ttrace_cfg80211_notify_new_peer_candidate(dev, addr);\n\n\tmsg = nlmsg_new(100 + ie_len, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NEW_PEER_CANDIDATE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr) ||\n\t    (ie_len && ie &&\n\t     nla_put(msg, NL80211_ATTR_IE, ie_len, ie)) ||\n\t    (sig_dbm &&\n\t     nla_put_u32(msg, NL80211_ATTR_RX_SIGNAL_DBM, sig_dbm)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_notify_new_peer_candidate);\n\nvoid nl80211_michael_mic_failure(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev, const u8 *addr,\n\t\t\t\t enum nl80211_key_type key_type, int key_id,\n\t\t\t\t const u8 *tsc, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_MICHAEL_MIC_FAILURE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    (addr && nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_KEY_TYPE, key_type) ||\n\t    (key_id != -1 &&\n\t     nla_put_u8(msg, NL80211_ATTR_KEY_IDX, key_id)) ||\n\t    (tsc && nla_put(msg, NL80211_ATTR_KEY_SEQ, 6, tsc)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_beacon_hint_event(struct wiphy *wiphy,\n\t\t\t\t    struct ieee80211_channel *channel_before,\n\t\t\t\t    struct ieee80211_channel *channel_after)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *nl_freq;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_REG_BEACON_HINT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\t/*\n\t * Since we are applying the beacon hint to a wiphy we know its\n\t * wiphy_idx is valid\n\t */\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy)))\n\t\tgoto nla_put_failure;\n\n\t/* Before */\n\tnl_freq = nla_nest_start_noflag(msg, NL80211_ATTR_FREQ_BEFORE);\n\tif (!nl_freq)\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_msg_put_channel(msg, wiphy, channel_before, false))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, nl_freq);\n\n\t/* After */\n\tnl_freq = nla_nest_start_noflag(msg, NL80211_ATTR_FREQ_AFTER);\n\tif (!nl_freq)\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_msg_put_channel(msg, wiphy, channel_after, false))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, nl_freq);\n\n\tgenlmsg_end(msg, hdr);\n\n\trcu_read_lock();\n\tgenlmsg_multicast_allns(&nl80211_fam, msg, 0,\n\t\t\t\tNL80211_MCGRP_REGULATORY, GFP_ATOMIC);\n\trcu_read_unlock();\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\n\nstatic void nl80211_send_remain_on_chan_event(\n\tint cmd, struct cfg80211_registered_device *rdev,\n\tstruct wireless_dev *wdev, u64 cookie,\n\tstruct ieee80211_channel *chan,\n\tunsigned int duration, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ, chan->center_freq) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,\n\t\t\tNL80211_CHAN_NO_HT) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (cmd == NL80211_CMD_REMAIN_ON_CHANNEL &&\n\t    nla_put_u32(msg, NL80211_ATTR_DURATION, duration))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_ready_on_channel(struct wireless_dev *wdev, u64 cookie,\n\t\t\t       struct ieee80211_channel *chan,\n\t\t\t       unsigned int duration, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_ready_on_channel(wdev, cookie, chan, duration);\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan,\n\t\t\t\t\t  duration, gfp);\n}\nEXPORT_SYMBOL(cfg80211_ready_on_channel);\n\nvoid cfg80211_remain_on_channel_expired(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\t\tgfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_ready_on_channel_expired(wdev, cookie, chan);\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan, 0, gfp);\n}\nEXPORT_SYMBOL(cfg80211_remain_on_channel_expired);\n\nvoid cfg80211_tx_mgmt_expired(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\t\tgfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_tx_mgmt_expired(wdev, cookie, chan);\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_FRAME_WAIT_CANCEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan, 0, gfp);\n}\nEXPORT_SYMBOL(cfg80211_tx_mgmt_expired);\n\nvoid cfg80211_new_sta(struct net_device *dev, const u8 *mac_addr,\n\t\t      struct station_info *sinfo, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\n\ttrace_cfg80211_new_sta(dev, mac_addr, sinfo);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_station(msg, NL80211_CMD_NEW_STATION, 0, 0, 0,\n\t\t\t\t rdev, dev, mac_addr, sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n}\nEXPORT_SYMBOL(cfg80211_new_sta);\n\nvoid cfg80211_del_sta_sinfo(struct net_device *dev, const u8 *mac_addr,\n\t\t\t    struct station_info *sinfo, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tstruct station_info empty_sinfo = {};\n\n\tif (!sinfo)\n\t\tsinfo = &empty_sinfo;\n\n\ttrace_cfg80211_del_sta(dev, mac_addr);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg) {\n\t\tcfg80211_sinfo_release_content(sinfo);\n\t\treturn;\n\t}\n\n\tif (nl80211_send_station(msg, NL80211_CMD_DEL_STATION, 0, 0, 0,\n\t\t\t\t rdev, dev, mac_addr, sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n}\nEXPORT_SYMBOL(cfg80211_del_sta_sinfo);\n\nvoid cfg80211_conn_failed(struct net_device *dev, const u8 *mac_addr,\n\t\t\t  enum nl80211_connect_failed_reason reason,\n\t\t\t  gfp_t gfp)\n{\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CONN_FAILED);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr) ||\n\t    nla_put_u32(msg, NL80211_ATTR_CONN_FAILED_REASON, reason))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_conn_failed);\n\nstatic bool __nl80211_unexpected_frame(struct net_device *dev, u8 cmd,\n\t\t\t\t       const u8 *addr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu32 nlportid = READ_ONCE(wdev->ap_unexpected_nlportid);\n\n\tif (!nlportid)\n\t\treturn false;\n\n\tmsg = nlmsg_new(100, gfp);\n\tif (!msg)\n\t\treturn true;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn true;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\treturn true;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn true;\n}\n\nbool cfg80211_rx_spurious_frame(struct net_device *dev,\n\t\t\t\tconst u8 *addr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tbool ret;\n\n\ttrace_cfg80211_rx_spurious_frame(dev, addr);\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_AP &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)) {\n\t\ttrace_cfg80211_return_bool(false);\n\t\treturn false;\n\t}\n\tret = __nl80211_unexpected_frame(dev, NL80211_CMD_UNEXPECTED_FRAME,\n\t\t\t\t\t addr, gfp);\n\ttrace_cfg80211_return_bool(ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(cfg80211_rx_spurious_frame);\n\nbool cfg80211_rx_unexpected_4addr_frame(struct net_device *dev,\n\t\t\t\t\tconst u8 *addr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tbool ret;\n\n\ttrace_cfg80211_rx_unexpected_4addr_frame(dev, addr);\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_AP &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_GO &&\n\t\t    wdev->iftype != NL80211_IFTYPE_AP_VLAN)) {\n\t\ttrace_cfg80211_return_bool(false);\n\t\treturn false;\n\t}\n\tret = __nl80211_unexpected_frame(dev,\n\t\t\t\t\t NL80211_CMD_UNEXPECTED_4ADDR_FRAME,\n\t\t\t\t\t addr, gfp);\n\ttrace_cfg80211_return_bool(ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(cfg80211_rx_unexpected_4addr_frame);\n\nint nl80211_send_mgmt(struct cfg80211_registered_device *rdev,\n\t\t      struct wireless_dev *wdev, u32 nlportid,\n\t\t      int freq, int sig_dbm,\n\t\t      const u8 *buf, size_t len, u32 flags, gfp_t gfp)\n{\n\tstruct net_device *netdev = wdev->netdev;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + len, gfp);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\tnetdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ, KHZ_TO_MHZ(freq)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ_OFFSET, freq % 1000) ||\n\t    (sig_dbm &&\n\t     nla_put_u32(msg, NL80211_ATTR_RX_SIGNAL_DBM, sig_dbm)) ||\n\t    nla_put(msg, NL80211_ATTR_FRAME, len, buf) ||\n\t    (flags &&\n\t     nla_put_u32(msg, NL80211_ATTR_RXMGMT_FLAGS, flags)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic void nl80211_frame_tx_status(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t    const u8 *buf, size_t len, bool ack,\n\t\t\t\t    gfp_t gfp, enum nl80211_commands command)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct net_device *netdev = wdev->netdev;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (command == NL80211_CMD_FRAME_TX_STATUS)\n\t\ttrace_cfg80211_mgmt_tx_status(wdev, cookie, ack);\n\telse\n\t\ttrace_cfg80211_control_port_tx_status(wdev, cookie, ack);\n\n\tmsg = nlmsg_new(100 + len, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, command);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t   netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_FRAME, len, buf) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    (ack && nla_put_flag(msg, NL80211_ATTR_ACK)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_control_port_tx_status(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t     const u8 *buf, size_t len, bool ack,\n\t\t\t\t     gfp_t gfp)\n{\n\tnl80211_frame_tx_status(wdev, cookie, buf, len, ack, gfp,\n\t\t\t\tNL80211_CMD_CONTROL_PORT_FRAME_TX_STATUS);\n}\nEXPORT_SYMBOL(cfg80211_control_port_tx_status);\n\nvoid cfg80211_mgmt_tx_status(struct wireless_dev *wdev, u64 cookie,\n\t\t\t     const u8 *buf, size_t len, bool ack, gfp_t gfp)\n{\n\tnl80211_frame_tx_status(wdev, cookie, buf, len, ack, gfp,\n\t\t\t\tNL80211_CMD_FRAME_TX_STATUS);\n}\nEXPORT_SYMBOL(cfg80211_mgmt_tx_status);\n\nstatic int __nl80211_rx_control_port(struct net_device *dev,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     bool unencrypted, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct ethhdr *ehdr = eth_hdr(skb);\n\tconst u8 *addr = ehdr->h_source;\n\tu16 proto = be16_to_cpu(skb->protocol);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *frame;\n\n\tu32 nlportid = READ_ONCE(wdev->conn_owner_nlportid);\n\n\tif (!nlportid)\n\t\treturn -ENOENT;\n\n\tmsg = nlmsg_new(100 + skb->len, gfp);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CONTROL_PORT_FRAME);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr) ||\n\t    nla_put_u16(msg, NL80211_ATTR_CONTROL_PORT_ETHERTYPE, proto) ||\n\t    (unencrypted && nla_put_flag(msg,\n\t\t\t\t\t NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT)))\n\t\tgoto nla_put_failure;\n\n\tframe = nla_reserve(msg, NL80211_ATTR_FRAME, skb->len);\n\tif (!frame)\n\t\tgoto nla_put_failure;\n\n\tskb_copy_bits(skb, 0, nla_data(frame), skb->len);\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nbool cfg80211_rx_control_port(struct net_device *dev,\n\t\t\t      struct sk_buff *skb, bool unencrypted)\n{\n\tint ret;\n\n\ttrace_cfg80211_rx_control_port(dev, skb, unencrypted);\n\tret = __nl80211_rx_control_port(dev, skb, unencrypted, GFP_ATOMIC);\n\ttrace_cfg80211_return_bool(ret == 0);\n\treturn ret == 0;\n}\nEXPORT_SYMBOL(cfg80211_rx_control_port);\n\nstatic struct sk_buff *cfg80211_prepare_cqm(struct net_device *dev,\n\t\t\t\t\t    const char *mac, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tvoid **cb;\n\n\tif (!msg)\n\t\treturn NULL;\n\n\tcb = (void **)msg->cb;\n\n\tcb[0] = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NOTIFY_CQM);\n\tif (!cb[0]) {\n\t\tnlmsg_free(msg);\n\t\treturn NULL;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (mac && nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac))\n\t\tgoto nla_put_failure;\n\n\tcb[1] = nla_nest_start_noflag(msg, NL80211_ATTR_CQM);\n\tif (!cb[1])\n\t\tgoto nla_put_failure;\n\n\tcb[2] = rdev;\n\n\treturn msg;\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn NULL;\n}\n\nstatic void cfg80211_send_cqm(struct sk_buff *msg, gfp_t gfp)\n{\n\tvoid **cb = (void **)msg->cb;\n\tstruct cfg80211_registered_device *rdev = cb[2];\n\n\tnla_nest_end(msg, cb[1]);\n\tgenlmsg_end(msg, cb[0]);\n\n\tmemset(msg->cb, 0, sizeof(msg->cb));\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n}\n\nvoid cfg80211_cqm_rssi_notify(struct net_device *dev,\n\t\t\t      enum nl80211_cqm_rssi_threshold_event rssi_event,\n\t\t\t      s32 rssi_level, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\n\ttrace_cfg80211_cqm_rssi_notify(dev, rssi_event, rssi_level);\n\n\tif (WARN_ON(rssi_event != NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW &&\n\t\t    rssi_event != NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH))\n\t\treturn;\n\n\tif (wdev->cqm_config) {\n\t\twdev->cqm_config->last_rssi_event_value = rssi_level;\n\n\t\tcfg80211_cqm_rssi_update(rdev, dev);\n\n\t\tif (rssi_level == 0)\n\t\t\trssi_level = wdev->cqm_config->last_rssi_event_value;\n\t}\n\n\tmsg = cfg80211_prepare_cqm(dev, NULL, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT,\n\t\t\trssi_event))\n\t\tgoto nla_put_failure;\n\n\tif (rssi_level && nla_put_s32(msg, NL80211_ATTR_CQM_RSSI_LEVEL,\n\t\t\t\t      rssi_level))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_rssi_notify);\n\nvoid cfg80211_cqm_txe_notify(struct net_device *dev,\n\t\t\t     const u8 *peer, u32 num_packets,\n\t\t\t     u32 rate, u32 intvl, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = cfg80211_prepare_cqm(dev, peer, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_PKTS, num_packets))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_RATE, rate))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_INTVL, intvl))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_txe_notify);\n\nvoid cfg80211_cqm_pktloss_notify(struct net_device *dev,\n\t\t\t\t const u8 *peer, u32 num_packets, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\n\ttrace_cfg80211_cqm_pktloss_notify(dev, peer, num_packets);\n\n\tmsg = cfg80211_prepare_cqm(dev, peer, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_PKT_LOSS_EVENT, num_packets))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_pktloss_notify);\n\nvoid cfg80211_cqm_beacon_loss_notify(struct net_device *dev, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = cfg80211_prepare_cqm(dev, NULL, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_flag(msg, NL80211_ATTR_CQM_BEACON_LOSS_EVENT))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_beacon_loss_notify);\n\nstatic void nl80211_gtk_rekey_notify(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct net_device *netdev, const u8 *bssid,\n\t\t\t\t     const u8 *replay_ctr, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *rekey_attr;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_SET_REKEY_OFFLOAD);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))\n\t\tgoto nla_put_failure;\n\n\trekey_attr = nla_nest_start_noflag(msg, NL80211_ATTR_REKEY_DATA);\n\tif (!rekey_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(msg, NL80211_REKEY_DATA_REPLAY_CTR,\n\t\t    NL80211_REPLAY_CTR_LEN, replay_ctr))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, rekey_attr);\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_gtk_rekey_notify(struct net_device *dev, const u8 *bssid,\n\t\t\t       const u8 *replay_ctr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_gtk_rekey_notify(dev, bssid);\n\tnl80211_gtk_rekey_notify(rdev, dev, bssid, replay_ctr, gfp);\n}\nEXPORT_SYMBOL(cfg80211_gtk_rekey_notify);\n\nstatic void\nnl80211_pmksa_candidate_notify(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, int index,\n\t\t\t       const u8 *bssid, bool preauth, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *attr;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PMKSA_CANDIDATE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tattr = nla_nest_start_noflag(msg, NL80211_ATTR_PMKSA_CANDIDATE);\n\tif (!attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_PMKSA_CANDIDATE_INDEX, index) ||\n\t    nla_put(msg, NL80211_PMKSA_CANDIDATE_BSSID, ETH_ALEN, bssid) ||\n\t    (preauth &&\n\t     nla_put_flag(msg, NL80211_PMKSA_CANDIDATE_PREAUTH)))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, attr);\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_pmksa_candidate_notify(struct net_device *dev, int index,\n\t\t\t\t     const u8 *bssid, bool preauth, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_pmksa_candidate_notify(dev, index, bssid, preauth);\n\tnl80211_pmksa_candidate_notify(rdev, dev, index, bssid, preauth, gfp);\n}\nEXPORT_SYMBOL(cfg80211_pmksa_candidate_notify);\n\nstatic void nl80211_ch_switch_notify(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct net_device *netdev,\n\t\t\t\t     struct cfg80211_chan_def *chandef,\n\t\t\t\t     gfp_t gfp,\n\t\t\t\t     enum nl80211_commands notif,\n\t\t\t\t     u8 count, bool quiet)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, notif);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_send_chandef(msg, chandef))\n\t\tgoto nla_put_failure;\n\n\tif (notif == NL80211_CMD_CH_SWITCH_STARTED_NOTIFY) {\n\t\tif (nla_put_u32(msg, NL80211_ATTR_CH_SWITCH_COUNT, count))\n\t\t\tgoto nla_put_failure;\n\t\tif (quiet &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_CH_SWITCH_BLOCK_TX))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_ch_switch_notify(struct net_device *dev,\n\t\t\t       struct cfg80211_chan_def *chandef)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\ttrace_cfg80211_ch_switch_notify(dev, chandef);\n\n\twdev->chandef = *chandef;\n\twdev->preset_chandef = *chandef;\n\n\tif (wdev->iftype == NL80211_IFTYPE_STATION &&\n\t    !WARN_ON(!wdev->current_bss))\n\t\tcfg80211_update_assoc_bss_entry(wdev, chandef->chan);\n\n\tcfg80211_sched_dfs_chan_update(rdev);\n\n\tnl80211_ch_switch_notify(rdev, dev, chandef, GFP_KERNEL,\n\t\t\t\t NL80211_CMD_CH_SWITCH_NOTIFY, 0, false);\n}\nEXPORT_SYMBOL(cfg80211_ch_switch_notify);\n\nvoid cfg80211_ch_switch_started_notify(struct net_device *dev,\n\t\t\t\t       struct cfg80211_chan_def *chandef,\n\t\t\t\t       u8 count, bool quiet)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_ch_switch_started_notify(dev, chandef);\n\n\tnl80211_ch_switch_notify(rdev, dev, chandef, GFP_KERNEL,\n\t\t\t\t NL80211_CMD_CH_SWITCH_STARTED_NOTIFY,\n\t\t\t\t count, quiet);\n}\nEXPORT_SYMBOL(cfg80211_ch_switch_started_notify);\n\nvoid\nnl80211_radar_notify(struct cfg80211_registered_device *rdev,\n\t\t     const struct cfg80211_chan_def *chandef,\n\t\t     enum nl80211_radar_event event,\n\t\t     struct net_device *netdev, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_RADAR_DETECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx))\n\t\tgoto nla_put_failure;\n\n\t/* NOP and radar events don't need a netdev parameter */\n\tif (netdev) {\n\t\tstruct wireless_dev *wdev = netdev->ieee80211_ptr;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t\t      NL80211_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_RADAR_EVENT, event))\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_send_chandef(msg, chandef))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_sta_opmode_change_notify(struct net_device *dev, const u8 *mac,\n\t\t\t\t       struct sta_opmode_info *sta_opmode,\n\t\t\t\t       gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tvoid *hdr;\n\n\tif (WARN_ON(!mac))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_STA_OPMODE_CHANGED);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac))\n\t\tgoto nla_put_failure;\n\n\tif ((sta_opmode->changed & STA_OPMODE_SMPS_MODE_CHANGED) &&\n\t    nla_put_u8(msg, NL80211_ATTR_SMPS_MODE, sta_opmode->smps_mode))\n\t\tgoto nla_put_failure;\n\n\tif ((sta_opmode->changed & STA_OPMODE_MAX_BW_CHANGED) &&\n\t    nla_put_u32(msg, NL80211_ATTR_CHANNEL_WIDTH, sta_opmode->bw))\n\t\tgoto nla_put_failure;\n\n\tif ((sta_opmode->changed & STA_OPMODE_N_SS_CHANGED) &&\n\t    nla_put_u8(msg, NL80211_ATTR_NSS, sta_opmode->rx_nss))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_sta_opmode_change_notify);\n\nvoid cfg80211_probe_status(struct net_device *dev, const u8 *addr,\n\t\t\t   u64 cookie, bool acked, s32 ack_signal,\n\t\t\t   bool is_valid_ack_signal, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_probe_status(dev, addr, cookie, acked);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PROBE_CLIENT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    (acked && nla_put_flag(msg, NL80211_ATTR_ACK)) ||\n\t    (is_valid_ack_signal && nla_put_s32(msg, NL80211_ATTR_ACK_SIGNAL,\n\t\t\t\t\t\tack_signal)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_probe_status);\n\nvoid cfg80211_report_obss_beacon_khz(struct wiphy *wiphy, const u8 *frame,\n\t\t\t\t     size_t len, int freq, int sig_dbm)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct cfg80211_beacon_registration *reg;\n\n\ttrace_cfg80211_report_obss_beacon(wiphy, frame, len, freq, sig_dbm);\n\n\tspin_lock_bh(&rdev->beacon_registrations_lock);\n\tlist_for_each_entry(reg, &rdev->beacon_registrations, list) {\n\t\tmsg = nlmsg_new(len + 100, GFP_ATOMIC);\n\t\tif (!msg) {\n\t\t\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\t\t\treturn;\n\t\t}\n\n\t\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME);\n\t\tif (!hdr)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t\t    (freq &&\n\t\t     (nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ,\n\t\t\t\t  KHZ_TO_MHZ(freq)) ||\n\t\t      nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ_OFFSET,\n\t\t\t\t  freq % 1000))) ||\n\t\t    (sig_dbm &&\n\t\t     nla_put_u32(msg, NL80211_ATTR_RX_SIGNAL_DBM, sig_dbm)) ||\n\t\t    nla_put(msg, NL80211_ATTR_FRAME, len, frame))\n\t\t\tgoto nla_put_failure;\n\n\t\tgenlmsg_end(msg, hdr);\n\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg, reg->nlportid);\n\t}\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\treturn;\n\n nla_put_failure:\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_report_obss_beacon_khz);\n\n#ifdef CONFIG_PM\nstatic int cfg80211_net_detect_results(struct sk_buff *msg,\n\t\t\t\t       struct cfg80211_wowlan_wakeup *wakeup)\n{\n\tstruct cfg80211_wowlan_nd_info *nd = wakeup->net_detect;\n\tstruct nlattr *nl_results, *nl_match, *nl_freqs;\n\tint i, j;\n\n\tnl_results = nla_nest_start_noflag(msg,\n\t\t\t\t\t   NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS);\n\tif (!nl_results)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < nd->n_matches; i++) {\n\t\tstruct cfg80211_wowlan_nd_match *match = nd->matches[i];\n\n\t\tnl_match = nla_nest_start_noflag(msg, i);\n\t\tif (!nl_match)\n\t\t\tbreak;\n\n\t\t/* The SSID attribute is optional in nl80211, but for\n\t\t * simplicity reasons it's always present in the\n\t\t * cfg80211 structure.  If a driver can't pass the\n\t\t * SSID, that needs to be changed.  A zero length SSID\n\t\t * is still a valid SSID (wildcard), so it cannot be\n\t\t * used for this purpose.\n\t\t */\n\t\tif (nla_put(msg, NL80211_ATTR_SSID, match->ssid.ssid_len,\n\t\t\t    match->ssid.ssid)) {\n\t\t\tnla_nest_cancel(msg, nl_match);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (match->n_channels) {\n\t\t\tnl_freqs = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t NL80211_ATTR_SCAN_FREQUENCIES);\n\t\t\tif (!nl_freqs) {\n\t\t\t\tnla_nest_cancel(msg, nl_match);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < match->n_channels; j++) {\n\t\t\t\tif (nla_put_u32(msg, j, match->channels[j])) {\n\t\t\t\t\tnla_nest_cancel(msg, nl_freqs);\n\t\t\t\t\tnla_nest_cancel(msg, nl_match);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnla_nest_end(msg, nl_freqs);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_match);\n\t}\n\nout:\n\tnla_nest_end(msg, nl_results);\n\treturn 0;\n}\n\nvoid cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,\n\t\t\t\t   struct cfg80211_wowlan_wakeup *wakeup,\n\t\t\t\t   gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint size = 200;\n\n\ttrace_cfg80211_report_wowlan_wakeup(wdev->wiphy, wdev, wakeup);\n\n\tif (wakeup)\n\t\tsize += wakeup->packet_present_len;\n\n\tmsg = nlmsg_new(size, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_SET_WOWLAN);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto free_msg;\n\n\tif (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\twdev->netdev->ifindex))\n\t\tgoto free_msg;\n\n\tif (wakeup) {\n\t\tstruct nlattr *reasons;\n\n\t\treasons = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_WOWLAN_TRIGGERS);\n\t\tif (!reasons)\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->disconnect &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->magic_pkt &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->gtk_rekey_failure &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->eap_identity_req &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->four_way_handshake &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->rfkill_release &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->pattern_idx >= 0 &&\n\t\t    nla_put_u32(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN,\n\t\t\t\twakeup->pattern_idx))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->tcp_match &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_WAKEUP_TCP_MATCH))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->tcp_connlost &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->tcp_nomoretokens &&\n\t\t    nla_put_flag(msg,\n\t\t\t\t NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->packet) {\n\t\t\tu32 pkt_attr = NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211;\n\t\t\tu32 len_attr = NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN;\n\n\t\t\tif (!wakeup->packet_80211) {\n\t\t\t\tpkt_attr =\n\t\t\t\t\tNL80211_WOWLAN_TRIG_WAKEUP_PKT_8023;\n\t\t\t\tlen_attr =\n\t\t\t\t\tNL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN;\n\t\t\t}\n\n\t\t\tif (wakeup->packet_len &&\n\t\t\t    nla_put_u32(msg, len_attr, wakeup->packet_len))\n\t\t\t\tgoto free_msg;\n\n\t\t\tif (nla_put(msg, pkt_attr, wakeup->packet_present_len,\n\t\t\t\t    wakeup->packet))\n\t\t\t\tgoto free_msg;\n\t\t}\n\n\t\tif (wakeup->net_detect &&\n\t\t    cfg80211_net_detect_results(msg, wakeup))\n\t\t\t\tgoto free_msg;\n\n\t\tnla_nest_end(msg, reasons);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n free_msg:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_report_wowlan_wakeup);\n#endif\n\nvoid cfg80211_tdls_oper_request(struct net_device *dev, const u8 *peer,\n\t\t\t\tenum nl80211_tdls_operation oper,\n\t\t\t\tu16 reason_code, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_tdls_oper_request(wdev->wiphy, dev, peer, oper,\n\t\t\t\t\t reason_code);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_TDLS_OPER);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u8(msg, NL80211_ATTR_TDLS_OPERATION, oper) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, peer) ||\n\t    (reason_code > 0 &&\n\t     nla_put_u16(msg, NL80211_ATTR_REASON_CODE, reason_code)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_tdls_oper_request);\n\nstatic int nl80211_netlink_notify(struct notifier_block * nb,\n\t\t\t\t  unsigned long state,\n\t\t\t\t  void *_notify)\n{\n\tstruct netlink_notify *notify = _notify;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tstruct cfg80211_beacon_registration *reg, *tmp;\n\n\tif (state != NETLINK_URELEASE || notify->protocol != NETLINK_GENERIC)\n\t\treturn NOTIFY_DONE;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(rdev, &cfg80211_rdev_list, list) {\n\t\tstruct cfg80211_sched_scan_request *sched_scan_req;\n\n\t\tlist_for_each_entry_rcu(sched_scan_req,\n\t\t\t\t\t&rdev->sched_scan_req_list,\n\t\t\t\t\tlist) {\n\t\t\tif (sched_scan_req->owner_nlportid == notify->portid) {\n\t\t\t\tsched_scan_req->nl_owner_dead = true;\n\t\t\t\tschedule_work(&rdev->sched_scan_stop_wk);\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry_rcu(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tcfg80211_mlme_unregister_socket(wdev, notify->portid);\n\n\t\t\tif (wdev->owner_nlportid == notify->portid) {\n\t\t\t\twdev->nl_owner_dead = true;\n\t\t\t\tschedule_work(&rdev->destroy_work);\n\t\t\t} else if (wdev->conn_owner_nlportid == notify->portid) {\n\t\t\t\tschedule_work(&wdev->disconnect_wk);\n\t\t\t}\n\n\t\t\tcfg80211_release_pmsr(wdev, notify->portid);\n\t\t}\n\n\t\tspin_lock_bh(&rdev->beacon_registrations_lock);\n\t\tlist_for_each_entry_safe(reg, tmp, &rdev->beacon_registrations,\n\t\t\t\t\t list) {\n\t\t\tif (reg->nlportid == notify->portid) {\n\t\t\t\tlist_del(&reg->list);\n\t\t\t\tkfree(reg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\t}\n\n\trcu_read_unlock();\n\n\t/*\n\t * It is possible that the user space process that is controlling the\n\t * indoor setting disappeared, so notify the regulatory core.\n\t */\n\tregulatory_netlink_notify(notify->portid);\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block nl80211_netlink_notifier = {\n\t.notifier_call = nl80211_netlink_notify,\n};\n\nvoid cfg80211_ft_event(struct net_device *netdev,\n\t\t       struct cfg80211_ft_event_params *ft_event)\n{\n\tstruct wiphy *wiphy = netdev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_ft_event(wiphy, netdev, ft_event);\n\n\tif (!ft_event->target_ap)\n\t\treturn;\n\n\tmsg = nlmsg_new(100 + ft_event->ies_len + ft_event->ric_ies_len,\n\t\t\tGFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FT_EVENT);\n\tif (!hdr)\n\t\tgoto out;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, ft_event->target_ap))\n\t\tgoto out;\n\n\tif (ft_event->ies &&\n\t    nla_put(msg, NL80211_ATTR_IE, ft_event->ies_len, ft_event->ies))\n\t\tgoto out;\n\tif (ft_event->ric_ies &&\n\t    nla_put(msg, NL80211_ATTR_IE_RIC, ft_event->ric_ies_len,\n\t\t    ft_event->ric_ies))\n\t\tgoto out;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n out:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_ft_event);\n\nvoid cfg80211_crit_proto_stopped(struct wireless_dev *wdev, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu32 nlportid;\n\n\trdev = wiphy_to_rdev(wdev->wiphy);\n\tif (!rdev->crit_proto_nlportid)\n\t\treturn;\n\n\tnlportid = rdev->crit_proto_nlportid;\n\trdev->crit_proto_nlportid = 0;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CRIT_PROTOCOL_STOP);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_crit_proto_stopped);\n\nvoid nl80211_send_ap_stopped(struct wireless_dev *wdev)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_STOP_AP);\n\tif (!hdr)\n\t\tgoto out;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, wdev->netdev->ifindex) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto out;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n out:\n\tnlmsg_free(msg);\n}\n\nint cfg80211_external_auth_request(struct net_device *dev,\n\t\t\t\t   struct cfg80211_external_auth_params *params,\n\t\t\t\t   gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (!wdev->conn_owner_nlportid)\n\t\treturn -EINVAL;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_EXTERNAL_AUTH);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u32(msg, NL80211_ATTR_AKM_SUITES, params->key_mgmt_suite) ||\n\t    nla_put_u32(msg, NL80211_ATTR_EXTERNAL_AUTH_ACTION,\n\t\t\tparams->action) ||\n\t    nla_put(msg, NL80211_ATTR_BSSID, ETH_ALEN, params->bssid) ||\n\t    nla_put(msg, NL80211_ATTR_SSID, params->ssid.ssid_len,\n\t\t    params->ssid.ssid))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg,\n\t\t\twdev->conn_owner_nlportid);\n\treturn 0;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\nEXPORT_SYMBOL(cfg80211_external_auth_request);\n\nvoid cfg80211_update_owe_info_event(struct net_device *netdev,\n\t\t\t\t    struct cfg80211_update_owe_info *owe_info,\n\t\t\t\t    gfp_t gfp)\n{\n\tstruct wiphy *wiphy = netdev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_update_owe_info_event(wiphy, netdev, owe_info);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_UPDATE_OWE_INFO);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, owe_info->peer))\n\t\tgoto nla_put_failure;\n\n\tif (!owe_info->ie_len ||\n\t    nla_put(msg, NL80211_ATTR_IE, owe_info->ie_len, owe_info->ie))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_update_owe_info_event);\n\n/* initialisation/exit functions */\n\nint __init nl80211_init(void)\n{\n\tint err;\n\n\terr = genl_register_family(&nl80211_fam);\n\tif (err)\n\t\treturn err;\n\n\terr = netlink_register_notifier(&nl80211_netlink_notifier);\n\tif (err)\n\t\tgoto err_out;\n\n\treturn 0;\n err_out:\n\tgenl_unregister_family(&nl80211_fam);\n\treturn err;\n}\n\nvoid nl80211_exit(void)\n{\n\tnetlink_unregister_notifier(&nl80211_netlink_notifier);\n\tgenl_unregister_family(&nl80211_fam);\n}\n"}, "2": {"id": 2, "path": "/src/include/linux/err.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_ERR_H\n#define _LINUX_ERR_H\n\n#include <linux/compiler.h>\n#include <linux/types.h>\n\n#include <asm/errno.h>\n\n/*\n * Kernel pointers have redundant information, so we can use a\n * scheme where we can return either an error code or a normal\n * pointer with the same return value.\n *\n * This should be a per-architecture thing, to allow different\n * error and pointer decisions.\n */\n#define MAX_ERRNO\t4095\n\n#ifndef __ASSEMBLY__\n\n#define IS_ERR_VALUE(x) unlikely((unsigned long)(void *)(x) >= (unsigned long)-MAX_ERRNO)\n\nstatic inline void * __must_check ERR_PTR(long error)\n{\n\treturn (void *) error;\n}\n\nstatic inline long __must_check PTR_ERR(__force const void *ptr)\n{\n\treturn (long) ptr;\n}\n\nstatic inline bool __must_check IS_ERR(__force const void *ptr)\n{\n\treturn IS_ERR_VALUE((unsigned long)ptr);\n}\n\nstatic inline bool __must_check IS_ERR_OR_NULL(__force const void *ptr)\n{\n\treturn unlikely(!ptr) || IS_ERR_VALUE((unsigned long)ptr);\n}\n\n/**\n * ERR_CAST - Explicitly cast an error-valued pointer to another pointer type\n * @ptr: The pointer to cast.\n *\n * Explicitly cast an error-valued pointer to another pointer type in such a\n * way as to make it clear that's what's going on.\n */\nstatic inline void * __must_check ERR_CAST(__force const void *ptr)\n{\n\t/* cast away the const */\n\treturn (void *) ptr;\n}\n\nstatic inline int __must_check PTR_ERR_OR_ZERO(__force const void *ptr)\n{\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\telse\n\t\treturn 0;\n}\n\n#endif\n\n#endif /* _LINUX_ERR_H */\n"}, "3": {"id": 3, "path": "/src/include/linux/compiler.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_H\n#define __LINUX_COMPILER_H\n\n#include <linux/compiler_types.h>\n\n#ifndef __ASSEMBLY__\n\n#ifdef __KERNEL__\n\n/*\n * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code\n * to disable branch tracing on a per file basis.\n */\n#if defined(CONFIG_TRACE_BRANCH_PROFILING) \\\n    && !defined(DISABLE_BRANCH_PROFILING) && !defined(__CHECKER__)\nvoid ftrace_likely_update(struct ftrace_likely_data *f, int val,\n\t\t\t  int expect, int is_constant);\n\n#define likely_notrace(x)\t__builtin_expect(!!(x), 1)\n#define unlikely_notrace(x)\t__builtin_expect(!!(x), 0)\n\n#define __branch_check__(x, expect, is_constant) ({\t\t\t\\\n\t\t\tlong ______r;\t\t\t\t\t\\\n\t\t\tstatic struct ftrace_likely_data\t\t\\\n\t\t\t\t__aligned(4)\t\t\t\t\\\n\t\t\t\t__section(\"_ftrace_annotated_branch\")\t\\\n\t\t\t\t______f = {\t\t\t\t\\\n\t\t\t\t.data.func = __func__,\t\t\t\\\n\t\t\t\t.data.file = __FILE__,\t\t\t\\\n\t\t\t\t.data.line = __LINE__,\t\t\t\\\n\t\t\t};\t\t\t\t\t\t\\\n\t\t\t______r = __builtin_expect(!!(x), expect);\t\\\n\t\t\tftrace_likely_update(&______f, ______r,\t\t\\\n\t\t\t\t\t     expect, is_constant);\t\\\n\t\t\t______r;\t\t\t\t\t\\\n\t\t})\n\n/*\n * Using __builtin_constant_p(x) to ignore cases where the return\n * value is always the same.  This idea is taken from a similar patch\n * written by Daniel Walker.\n */\n# ifndef likely\n#  define likely(x)\t(__branch_check__(x, 1, __builtin_constant_p(x)))\n# endif\n# ifndef unlikely\n#  define unlikely(x)\t(__branch_check__(x, 0, __builtin_constant_p(x)))\n# endif\n\n#ifdef CONFIG_PROFILE_ALL_BRANCHES\n/*\n * \"Define 'is'\", Bill Clinton\n * \"Define 'if'\", Steven Rostedt\n */\n#define if(cond, ...) if ( __trace_if_var( !!(cond , ## __VA_ARGS__) ) )\n\n#define __trace_if_var(cond) (__builtin_constant_p(cond) ? (cond) : __trace_if_value(cond))\n\n#define __trace_if_value(cond) ({\t\t\t\\\n\tstatic struct ftrace_branch_data\t\t\\\n\t\t__aligned(4)\t\t\t\t\\\n\t\t__section(\"_ftrace_branch\")\t\t\\\n\t\t__if_trace = {\t\t\t\t\\\n\t\t\t.func = __func__,\t\t\\\n\t\t\t.file = __FILE__,\t\t\\\n\t\t\t.line = __LINE__,\t\t\\\n\t\t};\t\t\t\t\t\\\n\t(cond) ?\t\t\t\t\t\\\n\t\t(__if_trace.miss_hit[1]++,1) :\t\t\\\n\t\t(__if_trace.miss_hit[0]++,0);\t\t\\\n})\n\n#endif /* CONFIG_PROFILE_ALL_BRANCHES */\n\n#else\n# define likely(x)\t__builtin_expect(!!(x), 1)\n# define unlikely(x)\t__builtin_expect(!!(x), 0)\n#endif\n\n/* Optimization barrier */\n#ifndef barrier\n/* The \"volatile\" is due to gcc bugs */\n# define barrier() __asm__ __volatile__(\"\": : :\"memory\")\n#endif\n\n#ifndef barrier_data\n/*\n * This version is i.e. to prevent dead stores elimination on @ptr\n * where gcc and llvm may behave differently when otherwise using\n * normal barrier(): while gcc behavior gets along with a normal\n * barrier(), llvm needs an explicit input variable to be assumed\n * clobbered. The issue is as follows: while the inline asm might\n * access any memory it wants, the compiler could have fit all of\n * @ptr into memory registers instead, and since @ptr never escaped\n * from that, it proved that the inline asm wasn't touching any of\n * it. This version works well with both compilers, i.e. we're telling\n * the compiler that the inline asm absolutely may see the contents\n * of @ptr. See also: https://llvm.org/bugs/show_bug.cgi?id=15495\n */\n# define barrier_data(ptr) __asm__ __volatile__(\"\": :\"r\"(ptr) :\"memory\")\n#endif\n\n/* workaround for GCC PR82365 if needed */\n#ifndef barrier_before_unreachable\n# define barrier_before_unreachable() do { } while (0)\n#endif\n\n/* Unreachable code */\n#ifdef CONFIG_STACK_VALIDATION\n/*\n * These macros help objtool understand GCC code flow for unreachable code.\n * The __COUNTER__ based labels are a hack to make each instance of the macros\n * unique, to convince GCC not to merge duplicate inline asm statements.\n */\n#define annotate_reachable() ({\t\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.reachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define annotate_unreachable() ({\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.unreachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define ASM_UNREACHABLE\t\t\t\t\t\t\t\\\n\t\"999:\\n\\t\"\t\t\t\t\t\t\t\\\n\t\".pushsection .discard.unreachable\\n\\t\"\t\t\t\t\\\n\t\".long 999b - .\\n\\t\"\t\t\t\t\t\t\\\n\t\".popsection\\n\\t\"\n\n/* Annotate a C jump table to allow objtool to follow the code flow */\n#define __annotate_jump_table __section(\".rodata..c_jump_table\")\n\n#else\n#define annotate_reachable()\n#define annotate_unreachable()\n#define __annotate_jump_table\n#endif\n\n#ifndef ASM_UNREACHABLE\n# define ASM_UNREACHABLE\n#endif\n#ifndef unreachable\n# define unreachable() do {\t\t\\\n\tannotate_unreachable();\t\t\\\n\t__builtin_unreachable();\t\\\n} while (0)\n#endif\n\n/*\n * KENTRY - kernel entry point\n * This can be used to annotate symbols (functions or data) that are used\n * without their linker symbol being referenced explicitly. For example,\n * interrupt vector handlers, or functions in the kernel image that are found\n * programatically.\n *\n * Not required for symbols exported with EXPORT_SYMBOL, or initcalls. Those\n * are handled in their own way (with KEEP() in linker scripts).\n *\n * KENTRY can be avoided if the symbols in question are marked as KEEP() in the\n * linker script. For example an architecture could KEEP() its entire\n * boot/exception vector code rather than annotate each function and data.\n */\n#ifndef KENTRY\n# define KENTRY(sym)\t\t\t\t\t\t\\\n\textern typeof(sym) sym;\t\t\t\t\t\\\n\tstatic const unsigned long __kentry_##sym\t\t\\\n\t__used\t\t\t\t\t\t\t\\\n\t__attribute__((__section__(\"___kentry+\" #sym)))\t\t\\\n\t= (unsigned long)&sym;\n#endif\n\n#ifndef RELOC_HIDE\n# define RELOC_HIDE(ptr, off)\t\t\t\t\t\\\n  ({ unsigned long __ptr;\t\t\t\t\t\\\n     __ptr = (unsigned long) (ptr);\t\t\t\t\\\n    (typeof(ptr)) (__ptr + (off)); })\n#endif\n\n#ifndef OPTIMIZER_HIDE_VAR\n/* Make the optimizer believe the variable can be manipulated arbitrarily. */\n#define OPTIMIZER_HIDE_VAR(var)\t\t\t\t\t\t\\\n\t__asm__ (\"\" : \"=r\" (var) : \"0\" (var))\n#endif\n\n/* Not-quite-unique ID. */\n#ifndef __UNIQUE_ID\n# define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)\n#endif\n\n/**\n * data_race - mark an expression as containing intentional data races\n *\n * This data_race() macro is useful for situations in which data races\n * should be forgiven.  One example is diagnostic code that accesses\n * shared variables but is not a part of the core synchronization design.\n *\n * This macro *does not* affect normal code generation, but is a hint\n * to tooling that data races here are to be ignored.\n */\n#define data_race(expr)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__unqual_scalar_typeof(({ expr; })) __v = ({\t\t\t\\\n\t\t__kcsan_disable_current();\t\t\t\t\\\n\t\texpr;\t\t\t\t\t\t\t\\\n\t});\t\t\t\t\t\t\t\t\\\n\t__kcsan_enable_current();\t\t\t\t\t\\\n\t__v;\t\t\t\t\t\t\t\t\\\n})\n\n#endif /* __KERNEL__ */\n\n/*\n * Force the compiler to emit 'sym' as a symbol, so that we can reference\n * it from inline assembler. Necessary in case 'sym' could be inlined\n * otherwise, or eliminated entirely due to lack of references that are\n * visible to the compiler.\n */\n#define __ADDRESSABLE(sym) \\\n\tstatic void * __section(\".discard.addressable\") __used \\\n\t\t__UNIQUE_ID(__PASTE(__addressable_,sym)) = (void *)&sym;\n\n/**\n * offset_to_ptr - convert a relative memory offset to an absolute pointer\n * @off:\tthe address of the 32-bit offset value\n */\nstatic inline void *offset_to_ptr(const int *off)\n{\n\treturn (void *)((unsigned long)off + *off);\n}\n\n#endif /* __ASSEMBLY__ */\n\n/* &a[0] degrades to a pointer: a different type from an array */\n#define __must_be_array(a)\tBUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))\n\n/*\n * This is needed in functions which generate the stack canary, see\n * arch/x86/kernel/smpboot.c::start_secondary() for an example.\n */\n#define prevent_tail_call_optimization()\tmb()\n\n#include <asm/rwonce.h>\n\n#endif /* __LINUX_COMPILER_H */\n"}, "0": {"id": 0, "path": "/src/include/net/cfg80211.h", "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n#ifndef __NET_CFG80211_H\n#define __NET_CFG80211_H\n/*\n * 802.11 device and configuration interface\n *\n * Copyright 2006-2010\tJohannes Berg <johannes@sipsolutions.net>\n * Copyright 2013-2014 Intel Mobile Communications GmbH\n * Copyright 2015-2017\tIntel Deutschland GmbH\n * Copyright (C) 2018-2020 Intel Corporation\n */\n\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/debugfs.h>\n#include <linux/list.h>\n#include <linux/bug.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/nl80211.h>\n#include <linux/if_ether.h>\n#include <linux/ieee80211.h>\n#include <linux/net.h>\n#include <net/regulatory.h>\n\n/**\n * DOC: Introduction\n *\n * cfg80211 is the configuration API for 802.11 devices in Linux. It bridges\n * userspace and drivers, and offers some utility functionality associated\n * with 802.11. cfg80211 must, directly or indirectly via mac80211, be used\n * by all modern wireless drivers in Linux, so that they offer a consistent\n * API through nl80211. For backward compatibility, cfg80211 also offers\n * wireless extensions to userspace, but hides them from drivers completely.\n *\n * Additionally, cfg80211 contains code to help enforce regulatory spectrum\n * use restrictions.\n */\n\n\n/**\n * DOC: Device registration\n *\n * In order for a driver to use cfg80211, it must register the hardware device\n * with cfg80211. This happens through a number of hardware capability structs\n * described below.\n *\n * The fundamental structure for each device is the 'wiphy', of which each\n * instance describes a physical wireless device connected to the system. Each\n * such wiphy can have zero, one, or many virtual interfaces associated with\n * it, which need to be identified as such by pointing the network interface's\n * @ieee80211_ptr pointer to a &struct wireless_dev which further describes\n * the wireless part of the interface, normally this struct is embedded in the\n * network interface's private data area. Drivers can optionally allow creating\n * or destroying virtual interfaces on the fly, but without at least one or the\n * ability to create some the wireless device isn't useful.\n *\n * Each wiphy structure contains device capability information, and also has\n * a pointer to the various operations the driver offers. The definitions and\n * structures here describe these capabilities in detail.\n */\n\nstruct wiphy;\n\n/*\n * wireless hardware capability structures\n */\n\n/**\n * enum ieee80211_channel_flags - channel flags\n *\n * Channel flags set by the regulatory control code.\n *\n * @IEEE80211_CHAN_DISABLED: This channel is disabled.\n * @IEEE80211_CHAN_NO_IR: do not initiate radiation, this includes\n *\tsending probe requests or beaconing.\n * @IEEE80211_CHAN_RADAR: Radar detection is required on this channel.\n * @IEEE80211_CHAN_NO_HT40PLUS: extension channel above this channel\n *\tis not permitted.\n * @IEEE80211_CHAN_NO_HT40MINUS: extension channel below this channel\n *\tis not permitted.\n * @IEEE80211_CHAN_NO_OFDM: OFDM is not allowed on this channel.\n * @IEEE80211_CHAN_NO_80MHZ: If the driver supports 80 MHz on the band,\n *\tthis flag indicates that an 80 MHz channel cannot use this\n *\tchannel as the control or any of the secondary channels.\n *\tThis may be due to the driver or due to regulatory bandwidth\n *\trestrictions.\n * @IEEE80211_CHAN_NO_160MHZ: If the driver supports 160 MHz on the band,\n *\tthis flag indicates that an 160 MHz channel cannot use this\n *\tchannel as the control or any of the secondary channels.\n *\tThis may be due to the driver or due to regulatory bandwidth\n *\trestrictions.\n * @IEEE80211_CHAN_INDOOR_ONLY: see %NL80211_FREQUENCY_ATTR_INDOOR_ONLY\n * @IEEE80211_CHAN_IR_CONCURRENT: see %NL80211_FREQUENCY_ATTR_IR_CONCURRENT\n * @IEEE80211_CHAN_NO_20MHZ: 20 MHz bandwidth is not permitted\n *\ton this channel.\n * @IEEE80211_CHAN_NO_10MHZ: 10 MHz bandwidth is not permitted\n *\ton this channel.\n * @IEEE80211_CHAN_NO_HE: HE operation is not permitted on this channel.\n * @IEEE80211_CHAN_1MHZ: 1 MHz bandwidth is permitted\n *\ton this channel.\n * @IEEE80211_CHAN_2MHZ: 2 MHz bandwidth is permitted\n *\ton this channel.\n * @IEEE80211_CHAN_4MHZ: 4 MHz bandwidth is permitted\n *\ton this channel.\n * @IEEE80211_CHAN_8MHZ: 8 MHz bandwidth is permitted\n *\ton this channel.\n * @IEEE80211_CHAN_16MHZ: 16 MHz bandwidth is permitted\n *\ton this channel.\n *\n */\nenum ieee80211_channel_flags {\n\tIEEE80211_CHAN_DISABLED\t\t= 1<<0,\n\tIEEE80211_CHAN_NO_IR\t\t= 1<<1,\n\t/* hole at 1<<2 */\n\tIEEE80211_CHAN_RADAR\t\t= 1<<3,\n\tIEEE80211_CHAN_NO_HT40PLUS\t= 1<<4,\n\tIEEE80211_CHAN_NO_HT40MINUS\t= 1<<5,\n\tIEEE80211_CHAN_NO_OFDM\t\t= 1<<6,\n\tIEEE80211_CHAN_NO_80MHZ\t\t= 1<<7,\n\tIEEE80211_CHAN_NO_160MHZ\t= 1<<8,\n\tIEEE80211_CHAN_INDOOR_ONLY\t= 1<<9,\n\tIEEE80211_CHAN_IR_CONCURRENT\t= 1<<10,\n\tIEEE80211_CHAN_NO_20MHZ\t\t= 1<<11,\n\tIEEE80211_CHAN_NO_10MHZ\t\t= 1<<12,\n\tIEEE80211_CHAN_NO_HE\t\t= 1<<13,\n\tIEEE80211_CHAN_1MHZ\t\t= 1<<14,\n\tIEEE80211_CHAN_2MHZ\t\t= 1<<15,\n\tIEEE80211_CHAN_4MHZ\t\t= 1<<16,\n\tIEEE80211_CHAN_8MHZ\t\t= 1<<17,\n\tIEEE80211_CHAN_16MHZ\t\t= 1<<18,\n};\n\n#define IEEE80211_CHAN_NO_HT40 \\\n\t(IEEE80211_CHAN_NO_HT40PLUS | IEEE80211_CHAN_NO_HT40MINUS)\n\n#define IEEE80211_DFS_MIN_CAC_TIME_MS\t\t60000\n#define IEEE80211_DFS_MIN_NOP_TIME_MS\t\t(30 * 60 * 1000)\n\n/**\n * struct ieee80211_channel - channel definition\n *\n * This structure describes a single channel for use\n * with cfg80211.\n *\n * @center_freq: center frequency in MHz\n * @freq_offset: offset from @center_freq, in KHz\n * @hw_value: hardware-specific value for the channel\n * @flags: channel flags from &enum ieee80211_channel_flags.\n * @orig_flags: channel flags at registration time, used by regulatory\n *\tcode to support devices with additional restrictions\n * @band: band this channel belongs to.\n * @max_antenna_gain: maximum antenna gain in dBi\n * @max_power: maximum transmission power (in dBm)\n * @max_reg_power: maximum regulatory transmission power (in dBm)\n * @beacon_found: helper to regulatory code to indicate when a beacon\n *\thas been found on this channel. Use regulatory_hint_found_beacon()\n *\tto enable this, this is useful only on 5 GHz band.\n * @orig_mag: internal use\n * @orig_mpwr: internal use\n * @dfs_state: current state of this channel. Only relevant if radar is required\n *\ton this channel.\n * @dfs_state_entered: timestamp (jiffies) when the dfs state was entered.\n * @dfs_cac_ms: DFS CAC time in milliseconds, this is valid for DFS channels.\n */\nstruct ieee80211_channel {\n\tenum nl80211_band band;\n\tu32 center_freq;\n\tu16 freq_offset;\n\tu16 hw_value;\n\tu32 flags;\n\tint max_antenna_gain;\n\tint max_power;\n\tint max_reg_power;\n\tbool beacon_found;\n\tu32 orig_flags;\n\tint orig_mag, orig_mpwr;\n\tenum nl80211_dfs_state dfs_state;\n\tunsigned long dfs_state_entered;\n\tunsigned int dfs_cac_ms;\n};\n\n/**\n * enum ieee80211_rate_flags - rate flags\n *\n * Hardware/specification flags for rates. These are structured\n * in a way that allows using the same bitrate structure for\n * different bands/PHY modes.\n *\n * @IEEE80211_RATE_SHORT_PREAMBLE: Hardware can send with short\n *\tpreamble on this bitrate; only relevant in 2.4GHz band and\n *\twith CCK rates.\n * @IEEE80211_RATE_MANDATORY_A: This bitrate is a mandatory rate\n *\twhen used with 802.11a (on the 5 GHz band); filled by the\n *\tcore code when registering the wiphy.\n * @IEEE80211_RATE_MANDATORY_B: This bitrate is a mandatory rate\n *\twhen used with 802.11b (on the 2.4 GHz band); filled by the\n *\tcore code when registering the wiphy.\n * @IEEE80211_RATE_MANDATORY_G: This bitrate is a mandatory rate\n *\twhen used with 802.11g (on the 2.4 GHz band); filled by the\n *\tcore code when registering the wiphy.\n * @IEEE80211_RATE_ERP_G: This is an ERP rate in 802.11g mode.\n * @IEEE80211_RATE_SUPPORTS_5MHZ: Rate can be used in 5 MHz mode\n * @IEEE80211_RATE_SUPPORTS_10MHZ: Rate can be used in 10 MHz mode\n */\nenum ieee80211_rate_flags {\n\tIEEE80211_RATE_SHORT_PREAMBLE\t= 1<<0,\n\tIEEE80211_RATE_MANDATORY_A\t= 1<<1,\n\tIEEE80211_RATE_MANDATORY_B\t= 1<<2,\n\tIEEE80211_RATE_MANDATORY_G\t= 1<<3,\n\tIEEE80211_RATE_ERP_G\t\t= 1<<4,\n\tIEEE80211_RATE_SUPPORTS_5MHZ\t= 1<<5,\n\tIEEE80211_RATE_SUPPORTS_10MHZ\t= 1<<6,\n};\n\n/**\n * enum ieee80211_bss_type - BSS type filter\n *\n * @IEEE80211_BSS_TYPE_ESS: Infrastructure BSS\n * @IEEE80211_BSS_TYPE_PBSS: Personal BSS\n * @IEEE80211_BSS_TYPE_IBSS: Independent BSS\n * @IEEE80211_BSS_TYPE_MBSS: Mesh BSS\n * @IEEE80211_BSS_TYPE_ANY: Wildcard value for matching any BSS type\n */\nenum ieee80211_bss_type {\n\tIEEE80211_BSS_TYPE_ESS,\n\tIEEE80211_BSS_TYPE_PBSS,\n\tIEEE80211_BSS_TYPE_IBSS,\n\tIEEE80211_BSS_TYPE_MBSS,\n\tIEEE80211_BSS_TYPE_ANY\n};\n\n/**\n * enum ieee80211_privacy - BSS privacy filter\n *\n * @IEEE80211_PRIVACY_ON: privacy bit set\n * @IEEE80211_PRIVACY_OFF: privacy bit clear\n * @IEEE80211_PRIVACY_ANY: Wildcard value for matching any privacy setting\n */\nenum ieee80211_privacy {\n\tIEEE80211_PRIVACY_ON,\n\tIEEE80211_PRIVACY_OFF,\n\tIEEE80211_PRIVACY_ANY\n};\n\n#define IEEE80211_PRIVACY(x)\t\\\n\t((x) ? IEEE80211_PRIVACY_ON : IEEE80211_PRIVACY_OFF)\n\n/**\n * struct ieee80211_rate - bitrate definition\n *\n * This structure describes a bitrate that an 802.11 PHY can\n * operate with. The two values @hw_value and @hw_value_short\n * are only for driver use when pointers to this structure are\n * passed around.\n *\n * @flags: rate-specific flags\n * @bitrate: bitrate in units of 100 Kbps\n * @hw_value: driver/hardware value for this rate\n * @hw_value_short: driver/hardware value for this rate when\n *\tshort preamble is used\n */\nstruct ieee80211_rate {\n\tu32 flags;\n\tu16 bitrate;\n\tu16 hw_value, hw_value_short;\n};\n\n/**\n * struct ieee80211_he_obss_pd - AP settings for spatial reuse\n *\n * @enable: is the feature enabled.\n * @sr_ctrl: The SR Control field of SRP element.\n * @non_srg_max_offset: non-SRG maximum tx power offset\n * @min_offset: minimal tx power offset an associated station shall use\n * @max_offset: maximum tx power offset an associated station shall use\n * @bss_color_bitmap: bitmap that indicates the BSS color values used by\n *\tmembers of the SRG\n * @partial_bssid_bitmap: bitmap that indicates the partial BSSID values\n *\tused by members of the SRG\n */\nstruct ieee80211_he_obss_pd {\n\tbool enable;\n\tu8 sr_ctrl;\n\tu8 non_srg_max_offset;\n\tu8 min_offset;\n\tu8 max_offset;\n\tu8 bss_color_bitmap[8];\n\tu8 partial_bssid_bitmap[8];\n};\n\n/**\n * struct cfg80211_he_bss_color - AP settings for BSS coloring\n *\n * @color: the current color.\n * @enabled: HE BSS color is used\n * @partial: define the AID equation.\n */\nstruct cfg80211_he_bss_color {\n\tu8 color;\n\tbool enabled;\n\tbool partial;\n};\n\n/**\n * struct ieee80211_sta_ht_cap - STA's HT capabilities\n *\n * This structure describes most essential parameters needed\n * to describe 802.11n HT capabilities for an STA.\n *\n * @ht_supported: is HT supported by the STA\n * @cap: HT capabilities map as described in 802.11n spec\n * @ampdu_factor: Maximum A-MPDU length factor\n * @ampdu_density: Minimum A-MPDU spacing\n * @mcs: Supported MCS rates\n */\nstruct ieee80211_sta_ht_cap {\n\tu16 cap; /* use IEEE80211_HT_CAP_ */\n\tbool ht_supported;\n\tu8 ampdu_factor;\n\tu8 ampdu_density;\n\tstruct ieee80211_mcs_info mcs;\n};\n\n/**\n * struct ieee80211_sta_vht_cap - STA's VHT capabilities\n *\n * This structure describes most essential parameters needed\n * to describe 802.11ac VHT capabilities for an STA.\n *\n * @vht_supported: is VHT supported by the STA\n * @cap: VHT capabilities map as described in 802.11ac spec\n * @vht_mcs: Supported VHT MCS rates\n */\nstruct ieee80211_sta_vht_cap {\n\tbool vht_supported;\n\tu32 cap; /* use IEEE80211_VHT_CAP_ */\n\tstruct ieee80211_vht_mcs_info vht_mcs;\n};\n\n#define IEEE80211_HE_PPE_THRES_MAX_LEN\t\t25\n\n/**\n * struct ieee80211_sta_he_cap - STA's HE capabilities\n *\n * This structure describes most essential parameters needed\n * to describe 802.11ax HE capabilities for a STA.\n *\n * @has_he: true iff HE data is valid.\n * @he_cap_elem: Fixed portion of the HE capabilities element.\n * @he_mcs_nss_supp: The supported NSS/MCS combinations.\n * @ppe_thres: Holds the PPE Thresholds data.\n */\nstruct ieee80211_sta_he_cap {\n\tbool has_he;\n\tstruct ieee80211_he_cap_elem he_cap_elem;\n\tstruct ieee80211_he_mcs_nss_supp he_mcs_nss_supp;\n\tu8 ppe_thres[IEEE80211_HE_PPE_THRES_MAX_LEN];\n};\n\n/**\n * struct ieee80211_sband_iftype_data\n *\n * This structure encapsulates sband data that is relevant for the\n * interface types defined in @types_mask.  Each type in the\n * @types_mask must be unique across all instances of iftype_data.\n *\n * @types_mask: interface types mask\n * @he_cap: holds the HE capabilities\n * @he_6ghz_capa: HE 6 GHz capabilities, must be filled in for a\n *\t6 GHz band channel (and 0 may be valid value).\n */\nstruct ieee80211_sband_iftype_data {\n\tu16 types_mask;\n\tstruct ieee80211_sta_he_cap he_cap;\n\tstruct ieee80211_he_6ghz_capa he_6ghz_capa;\n};\n\n/**\n * enum ieee80211_edmg_bw_config - allowed channel bandwidth configurations\n *\n * @IEEE80211_EDMG_BW_CONFIG_4: 2.16GHz\n * @IEEE80211_EDMG_BW_CONFIG_5: 2.16GHz and 4.32GHz\n * @IEEE80211_EDMG_BW_CONFIG_6: 2.16GHz, 4.32GHz and 6.48GHz\n * @IEEE80211_EDMG_BW_CONFIG_7: 2.16GHz, 4.32GHz, 6.48GHz and 8.64GHz\n * @IEEE80211_EDMG_BW_CONFIG_8: 2.16GHz and 2.16GHz + 2.16GHz\n * @IEEE80211_EDMG_BW_CONFIG_9: 2.16GHz, 4.32GHz and 2.16GHz + 2.16GHz\n * @IEEE80211_EDMG_BW_CONFIG_10: 2.16GHz, 4.32GHz, 6.48GHz and 2.16GHz+2.16GHz\n * @IEEE80211_EDMG_BW_CONFIG_11: 2.16GHz, 4.32GHz, 6.48GHz, 8.64GHz and\n *\t2.16GHz+2.16GHz\n * @IEEE80211_EDMG_BW_CONFIG_12: 2.16GHz, 2.16GHz + 2.16GHz and\n *\t4.32GHz + 4.32GHz\n * @IEEE80211_EDMG_BW_CONFIG_13: 2.16GHz, 4.32GHz, 2.16GHz + 2.16GHz and\n *\t4.32GHz + 4.32GHz\n * @IEEE80211_EDMG_BW_CONFIG_14: 2.16GHz, 4.32GHz, 6.48GHz, 2.16GHz + 2.16GHz\n *\tand 4.32GHz + 4.32GHz\n * @IEEE80211_EDMG_BW_CONFIG_15: 2.16GHz, 4.32GHz, 6.48GHz, 8.64GHz,\n *\t2.16GHz + 2.16GHz and 4.32GHz + 4.32GHz\n */\nenum ieee80211_edmg_bw_config {\n\tIEEE80211_EDMG_BW_CONFIG_4\t= 4,\n\tIEEE80211_EDMG_BW_CONFIG_5\t= 5,\n\tIEEE80211_EDMG_BW_CONFIG_6\t= 6,\n\tIEEE80211_EDMG_BW_CONFIG_7\t= 7,\n\tIEEE80211_EDMG_BW_CONFIG_8\t= 8,\n\tIEEE80211_EDMG_BW_CONFIG_9\t= 9,\n\tIEEE80211_EDMG_BW_CONFIG_10\t= 10,\n\tIEEE80211_EDMG_BW_CONFIG_11\t= 11,\n\tIEEE80211_EDMG_BW_CONFIG_12\t= 12,\n\tIEEE80211_EDMG_BW_CONFIG_13\t= 13,\n\tIEEE80211_EDMG_BW_CONFIG_14\t= 14,\n\tIEEE80211_EDMG_BW_CONFIG_15\t= 15,\n};\n\n/**\n * struct ieee80211_edmg - EDMG configuration\n *\n * This structure describes most essential parameters needed\n * to describe 802.11ay EDMG configuration\n *\n * @channels: bitmap that indicates the 2.16 GHz channel(s)\n *\tthat are allowed to be used for transmissions.\n *\tBit 0 indicates channel 1, bit 1 indicates channel 2, etc.\n *\tSet to 0 indicate EDMG not supported.\n * @bw_config: Channel BW Configuration subfield encodes\n *\tthe allowed channel bandwidth configurations\n */\nstruct ieee80211_edmg {\n\tu8 channels;\n\tenum ieee80211_edmg_bw_config bw_config;\n};\n\n/**\n * struct ieee80211_sta_s1g_cap - STA's S1G capabilities\n *\n * This structure describes most essential parameters needed\n * to describe 802.11ah S1G capabilities for a STA.\n *\n * @s1g_supported: is STA an S1G STA\n * @cap: S1G capabilities information\n * @nss_mcs: Supported NSS MCS set\n */\nstruct ieee80211_sta_s1g_cap {\n\tbool s1g;\n\tu8 cap[10]; /* use S1G_CAPAB_ */\n\tu8 nss_mcs[5];\n};\n\n/**\n * struct ieee80211_supported_band - frequency band definition\n *\n * This structure describes a frequency band a wiphy\n * is able to operate in.\n *\n * @channels: Array of channels the hardware can operate with\n *\tin this band.\n * @band: the band this structure represents\n * @n_channels: Number of channels in @channels\n * @bitrates: Array of bitrates the hardware can operate with\n *\tin this band. Must be sorted to give a valid \"supported\n *\trates\" IE, i.e. CCK rates first, then OFDM.\n * @n_bitrates: Number of bitrates in @bitrates\n * @ht_cap: HT capabilities in this band\n * @vht_cap: VHT capabilities in this band\n * @s1g_cap: S1G capabilities in this band\n * @edmg_cap: EDMG capabilities in this band\n * @s1g_cap: S1G capabilities in this band (S1B band only, of course)\n * @n_iftype_data: number of iftype data entries\n * @iftype_data: interface type data entries.  Note that the bits in\n *\t@types_mask inside this structure cannot overlap (i.e. only\n *\tone occurrence of each type is allowed across all instances of\n *\tiftype_data).\n */\nstruct ieee80211_supported_band {\n\tstruct ieee80211_channel *channels;\n\tstruct ieee80211_rate *bitrates;\n\tenum nl80211_band band;\n\tint n_channels;\n\tint n_bitrates;\n\tstruct ieee80211_sta_ht_cap ht_cap;\n\tstruct ieee80211_sta_vht_cap vht_cap;\n\tstruct ieee80211_sta_s1g_cap s1g_cap;\n\tstruct ieee80211_edmg edmg_cap;\n\tu16 n_iftype_data;\n\tconst struct ieee80211_sband_iftype_data *iftype_data;\n};\n\n/**\n * ieee80211_get_sband_iftype_data - return sband data for a given iftype\n * @sband: the sband to search for the STA on\n * @iftype: enum nl80211_iftype\n *\n * Return: pointer to struct ieee80211_sband_iftype_data, or NULL is none found\n */\nstatic inline const struct ieee80211_sband_iftype_data *\nieee80211_get_sband_iftype_data(const struct ieee80211_supported_band *sband,\n\t\t\t\tu8 iftype)\n{\n\tint i;\n\n\tif (WARN_ON(iftype >= NL80211_IFTYPE_MAX))\n\t\treturn NULL;\n\n\tfor (i = 0; i < sband->n_iftype_data; i++)  {\n\t\tconst struct ieee80211_sband_iftype_data *data =\n\t\t\t&sband->iftype_data[i];\n\n\t\tif (data->types_mask & BIT(iftype))\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * ieee80211_get_he_iftype_cap - return HE capabilities for an sband's iftype\n * @sband: the sband to search for the iftype on\n * @iftype: enum nl80211_iftype\n *\n * Return: pointer to the struct ieee80211_sta_he_cap, or NULL is none found\n */\nstatic inline const struct ieee80211_sta_he_cap *\nieee80211_get_he_iftype_cap(const struct ieee80211_supported_band *sband,\n\t\t\t    u8 iftype)\n{\n\tconst struct ieee80211_sband_iftype_data *data =\n\t\tieee80211_get_sband_iftype_data(sband, iftype);\n\n\tif (data && data->he_cap.has_he)\n\t\treturn &data->he_cap;\n\n\treturn NULL;\n}\n\n/**\n * ieee80211_get_he_sta_cap - return HE capabilities for an sband's STA\n * @sband: the sband to search for the STA on\n *\n * Return: pointer to the struct ieee80211_sta_he_cap, or NULL is none found\n */\nstatic inline const struct ieee80211_sta_he_cap *\nieee80211_get_he_sta_cap(const struct ieee80211_supported_band *sband)\n{\n\treturn ieee80211_get_he_iftype_cap(sband, NL80211_IFTYPE_STATION);\n}\n\n/**\n * ieee80211_get_he_6ghz_capa - return HE 6 GHz capabilities\n * @sband: the sband to search for the STA on\n * @iftype: the iftype to search for\n *\n * Return: the 6GHz capabilities\n */\nstatic inline __le16\nieee80211_get_he_6ghz_capa(const struct ieee80211_supported_band *sband,\n\t\t\t   enum nl80211_iftype iftype)\n{\n\tconst struct ieee80211_sband_iftype_data *data =\n\t\tieee80211_get_sband_iftype_data(sband, iftype);\n\n\tif (WARN_ON(!data || !data->he_cap.has_he))\n\t\treturn 0;\n\n\treturn data->he_6ghz_capa.capa;\n}\n\n/**\n * wiphy_read_of_freq_limits - read frequency limits from device tree\n *\n * @wiphy: the wireless device to get extra limits for\n *\n * Some devices may have extra limitations specified in DT. This may be useful\n * for chipsets that normally support more bands but are limited due to board\n * design (e.g. by antennas or external power amplifier).\n *\n * This function reads info from DT and uses it to *modify* channels (disable\n * unavailable ones). It's usually a *bad* idea to use it in drivers with\n * shared channel data as DT limitations are device specific. You should make\n * sure to call it only if channels in wiphy are copied and can be modified\n * without affecting other devices.\n *\n * As this function access device node it has to be called after set_wiphy_dev.\n * It also modifies channels so they have to be set first.\n * If using this helper, call it before wiphy_register().\n */\n#ifdef CONFIG_OF\nvoid wiphy_read_of_freq_limits(struct wiphy *wiphy);\n#else /* CONFIG_OF */\nstatic inline void wiphy_read_of_freq_limits(struct wiphy *wiphy)\n{\n}\n#endif /* !CONFIG_OF */\n\n\n/*\n * Wireless hardware/device configuration structures and methods\n */\n\n/**\n * DOC: Actions and configuration\n *\n * Each wireless device and each virtual interface offer a set of configuration\n * operations and other actions that are invoked by userspace. Each of these\n * actions is described in the operations structure, and the parameters these\n * operations use are described separately.\n *\n * Additionally, some operations are asynchronous and expect to get status\n * information via some functions that drivers need to call.\n *\n * Scanning and BSS list handling with its associated functionality is described\n * in a separate chapter.\n */\n\n#define VHT_MUMIMO_GROUPS_DATA_LEN (WLAN_MEMBERSHIP_LEN +\\\n\t\t\t\t    WLAN_USER_POSITION_LEN)\n\n/**\n * struct vif_params - describes virtual interface parameters\n * @flags: monitor interface flags, unchanged if 0, otherwise\n *\t%MONITOR_FLAG_CHANGED will be set\n * @use_4addr: use 4-address frames\n * @macaddr: address to use for this virtual interface.\n *\tIf this parameter is set to zero address the driver may\n *\tdetermine the address as needed.\n *\tThis feature is only fully supported by drivers that enable the\n *\t%NL80211_FEATURE_MAC_ON_CREATE flag.  Others may support creating\n **\tonly p2p devices with specified MAC.\n * @vht_mumimo_groups: MU-MIMO groupID, used for monitoring MU-MIMO packets\n *\tbelonging to that MU-MIMO groupID; %NULL if not changed\n * @vht_mumimo_follow_addr: MU-MIMO follow address, used for monitoring\n *\tMU-MIMO packets going to the specified station; %NULL if not changed\n */\nstruct vif_params {\n\tu32 flags;\n\tint use_4addr;\n\tu8 macaddr[ETH_ALEN];\n\tconst u8 *vht_mumimo_groups;\n\tconst u8 *vht_mumimo_follow_addr;\n};\n\n/**\n * struct key_params - key information\n *\n * Information about a key\n *\n * @key: key material\n * @key_len: length of key material\n * @cipher: cipher suite selector\n * @seq: sequence counter (IV/PN) for TKIP and CCMP keys, only used\n *\twith the get_key() callback, must be in little endian,\n *\tlength given by @seq_len.\n * @seq_len: length of @seq.\n * @vlan_id: vlan_id for VLAN group key (if nonzero)\n * @mode: key install mode (RX_TX, NO_TX or SET_TX)\n */\nstruct key_params {\n\tconst u8 *key;\n\tconst u8 *seq;\n\tint key_len;\n\tint seq_len;\n\tu16 vlan_id;\n\tu32 cipher;\n\tenum nl80211_key_mode mode;\n};\n\n/**\n * struct cfg80211_chan_def - channel definition\n * @chan: the (control) channel\n * @width: channel width\n * @center_freq1: center frequency of first segment\n * @center_freq2: center frequency of second segment\n *\t(only with 80+80 MHz)\n * @edmg: define the EDMG channels configuration.\n *\tIf edmg is requested (i.e. the .channels member is non-zero),\n *\tchan will define the primary channel and all other\n *\tparameters are ignored.\n * @freq1_offset: offset from @center_freq1, in KHz\n */\nstruct cfg80211_chan_def {\n\tstruct ieee80211_channel *chan;\n\tenum nl80211_chan_width width;\n\tu32 center_freq1;\n\tu32 center_freq2;\n\tstruct ieee80211_edmg edmg;\n\tu16 freq1_offset;\n};\n\n/*\n * cfg80211_bitrate_mask - masks for bitrate control\n */\nstruct cfg80211_bitrate_mask {\n\tstruct {\n\t\tu32 legacy;\n\t\tu8 ht_mcs[IEEE80211_HT_MCS_MASK_LEN];\n\t\tu16 vht_mcs[NL80211_VHT_NSS_MAX];\n\t\tu16 he_mcs[NL80211_HE_NSS_MAX];\n\t\tenum nl80211_txrate_gi gi;\n\t\tenum nl80211_he_gi he_gi;\n\t\tenum nl80211_he_ltf he_ltf;\n\t} control[NUM_NL80211_BANDS];\n};\n\n\n/**\n * struct cfg80211_tid_cfg - TID specific configuration\n * @config_override: Flag to notify driver to reset TID configuration\n *\tof the peer.\n * @tids: bitmap of TIDs to modify\n * @mask: bitmap of attributes indicating which parameter changed,\n *\tsimilar to &nl80211_tid_config_supp.\n * @noack: noack configuration value for the TID\n * @retry_long: retry count value\n * @retry_short: retry count value\n * @ampdu: Enable/Disable MPDU aggregation\n * @rtscts: Enable/Disable RTS/CTS\n * @amsdu: Enable/Disable MSDU aggregation\n * @txrate_type: Tx bitrate mask type\n * @txrate_mask: Tx bitrate to be applied for the TID\n */\nstruct cfg80211_tid_cfg {\n\tbool config_override;\n\tu8 tids;\n\tu64 mask;\n\tenum nl80211_tid_config noack;\n\tu8 retry_long, retry_short;\n\tenum nl80211_tid_config ampdu;\n\tenum nl80211_tid_config rtscts;\n\tenum nl80211_tid_config amsdu;\n\tenum nl80211_tx_rate_setting txrate_type;\n\tstruct cfg80211_bitrate_mask txrate_mask;\n};\n\n/**\n * struct cfg80211_tid_config - TID configuration\n * @peer: Station's MAC address\n * @n_tid_conf: Number of TID specific configurations to be applied\n * @tid_conf: Configuration change info\n */\nstruct cfg80211_tid_config {\n\tconst u8 *peer;\n\tu32 n_tid_conf;\n\tstruct cfg80211_tid_cfg tid_conf[];\n};\n\n/**\n * cfg80211_get_chandef_type - return old channel type from chandef\n * @chandef: the channel definition\n *\n * Return: The old channel type (NOHT, HT20, HT40+/-) from a given\n * chandef, which must have a bandwidth allowing this conversion.\n */\nstatic inline enum nl80211_channel_type\ncfg80211_get_chandef_type(const struct cfg80211_chan_def *chandef)\n{\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\treturn NL80211_CHAN_NO_HT;\n\tcase NL80211_CHAN_WIDTH_20:\n\t\treturn NL80211_CHAN_HT20;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (chandef->center_freq1 > chandef->chan->center_freq)\n\t\t\treturn NL80211_CHAN_HT40PLUS;\n\t\treturn NL80211_CHAN_HT40MINUS;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn NL80211_CHAN_NO_HT;\n\t}\n}\n\n/**\n * cfg80211_chandef_create - create channel definition using channel type\n * @chandef: the channel definition struct to fill\n * @channel: the control channel\n * @chantype: the channel type\n *\n * Given a channel type, create a channel definition.\n */\nvoid cfg80211_chandef_create(struct cfg80211_chan_def *chandef,\n\t\t\t     struct ieee80211_channel *channel,\n\t\t\t     enum nl80211_channel_type chantype);\n\n/**\n * cfg80211_chandef_identical - check if two channel definitions are identical\n * @chandef1: first channel definition\n * @chandef2: second channel definition\n *\n * Return: %true if the channels defined by the channel definitions are\n * identical, %false otherwise.\n */\nstatic inline bool\ncfg80211_chandef_identical(const struct cfg80211_chan_def *chandef1,\n\t\t\t   const struct cfg80211_chan_def *chandef2)\n{\n\treturn (chandef1->chan == chandef2->chan &&\n\t\tchandef1->width == chandef2->width &&\n\t\tchandef1->center_freq1 == chandef2->center_freq1 &&\n\t\tchandef1->freq1_offset == chandef2->freq1_offset &&\n\t\tchandef1->center_freq2 == chandef2->center_freq2);\n}\n\n/**\n * cfg80211_chandef_is_edmg - check if chandef represents an EDMG channel\n *\n * @chandef: the channel definition\n *\n * Return: %true if EDMG defined, %false otherwise.\n */\nstatic inline bool\ncfg80211_chandef_is_edmg(const struct cfg80211_chan_def *chandef)\n{\n\treturn chandef->edmg.channels || chandef->edmg.bw_config;\n}\n\n/**\n * cfg80211_chandef_compatible - check if two channel definitions are compatible\n * @chandef1: first channel definition\n * @chandef2: second channel definition\n *\n * Return: %NULL if the given channel definitions are incompatible,\n * chandef1 or chandef2 otherwise.\n */\nconst struct cfg80211_chan_def *\ncfg80211_chandef_compatible(const struct cfg80211_chan_def *chandef1,\n\t\t\t    const struct cfg80211_chan_def *chandef2);\n\n/**\n * cfg80211_chandef_valid - check if a channel definition is valid\n * @chandef: the channel definition to check\n * Return: %true if the channel definition is valid. %false otherwise.\n */\nbool cfg80211_chandef_valid(const struct cfg80211_chan_def *chandef);\n\n/**\n * cfg80211_chandef_usable - check if secondary channels can be used\n * @wiphy: the wiphy to validate against\n * @chandef: the channel definition to check\n * @prohibited_flags: the regulatory channel flags that must not be set\n * Return: %true if secondary channels are usable. %false otherwise.\n */\nbool cfg80211_chandef_usable(struct wiphy *wiphy,\n\t\t\t     const struct cfg80211_chan_def *chandef,\n\t\t\t     u32 prohibited_flags);\n\n/**\n * cfg80211_chandef_dfs_required - checks if radar detection is required\n * @wiphy: the wiphy to validate against\n * @chandef: the channel definition to check\n * @iftype: the interface type as specified in &enum nl80211_iftype\n * Returns:\n *\t1 if radar detection is required, 0 if it is not, < 0 on error\n */\nint cfg80211_chandef_dfs_required(struct wiphy *wiphy,\n\t\t\t\t  const struct cfg80211_chan_def *chandef,\n\t\t\t\t  enum nl80211_iftype iftype);\n\n/**\n * ieee80211_chandef_rate_flags - returns rate flags for a channel\n *\n * In some channel types, not all rates may be used - for example CCK\n * rates may not be used in 5/10 MHz channels.\n *\n * @chandef: channel definition for the channel\n *\n * Returns: rate flags which apply for this channel\n */\nstatic inline enum ieee80211_rate_flags\nieee80211_chandef_rate_flags(struct cfg80211_chan_def *chandef)\n{\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\t\treturn IEEE80211_RATE_SUPPORTS_5MHZ;\n\tcase NL80211_CHAN_WIDTH_10:\n\t\treturn IEEE80211_RATE_SUPPORTS_10MHZ;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/**\n * ieee80211_chandef_max_power - maximum transmission power for the chandef\n *\n * In some regulations, the transmit power may depend on the configured channel\n * bandwidth which may be defined as dBm/MHz. This function returns the actual\n * max_power for non-standard (20 MHz) channels.\n *\n * @chandef: channel definition for the channel\n *\n * Returns: maximum allowed transmission power in dBm for the chandef\n */\nstatic inline int\nieee80211_chandef_max_power(struct cfg80211_chan_def *chandef)\n{\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\t\treturn min(chandef->chan->max_reg_power - 6,\n\t\t\t   chandef->chan->max_power);\n\tcase NL80211_CHAN_WIDTH_10:\n\t\treturn min(chandef->chan->max_reg_power - 3,\n\t\t\t   chandef->chan->max_power);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn chandef->chan->max_power;\n}\n\n/**\n * enum survey_info_flags - survey information flags\n *\n * @SURVEY_INFO_NOISE_DBM: noise (in dBm) was filled in\n * @SURVEY_INFO_IN_USE: channel is currently being used\n * @SURVEY_INFO_TIME: active time (in ms) was filled in\n * @SURVEY_INFO_TIME_BUSY: busy time was filled in\n * @SURVEY_INFO_TIME_EXT_BUSY: extension channel busy time was filled in\n * @SURVEY_INFO_TIME_RX: receive time was filled in\n * @SURVEY_INFO_TIME_TX: transmit time was filled in\n * @SURVEY_INFO_TIME_SCAN: scan time was filled in\n * @SURVEY_INFO_TIME_BSS_RX: local BSS receive time was filled in\n *\n * Used by the driver to indicate which info in &struct survey_info\n * it has filled in during the get_survey().\n */\nenum survey_info_flags {\n\tSURVEY_INFO_NOISE_DBM\t\t= BIT(0),\n\tSURVEY_INFO_IN_USE\t\t= BIT(1),\n\tSURVEY_INFO_TIME\t\t= BIT(2),\n\tSURVEY_INFO_TIME_BUSY\t\t= BIT(3),\n\tSURVEY_INFO_TIME_EXT_BUSY\t= BIT(4),\n\tSURVEY_INFO_TIME_RX\t\t= BIT(5),\n\tSURVEY_INFO_TIME_TX\t\t= BIT(6),\n\tSURVEY_INFO_TIME_SCAN\t\t= BIT(7),\n\tSURVEY_INFO_TIME_BSS_RX\t\t= BIT(8),\n};\n\n/**\n * struct survey_info - channel survey response\n *\n * @channel: the channel this survey record reports, may be %NULL for a single\n *\trecord to report global statistics\n * @filled: bitflag of flags from &enum survey_info_flags\n * @noise: channel noise in dBm. This and all following fields are\n *\toptional\n * @time: amount of time in ms the radio was turn on (on the channel)\n * @time_busy: amount of time the primary channel was sensed busy\n * @time_ext_busy: amount of time the extension channel was sensed busy\n * @time_rx: amount of time the radio spent receiving data\n * @time_tx: amount of time the radio spent transmitting data\n * @time_scan: amount of time the radio spent for scanning\n * @time_bss_rx: amount of time the radio spent receiving data on a local BSS\n *\n * Used by dump_survey() to report back per-channel survey information.\n *\n * This structure can later be expanded with things like\n * channel duty cycle etc.\n */\nstruct survey_info {\n\tstruct ieee80211_channel *channel;\n\tu64 time;\n\tu64 time_busy;\n\tu64 time_ext_busy;\n\tu64 time_rx;\n\tu64 time_tx;\n\tu64 time_scan;\n\tu64 time_bss_rx;\n\tu32 filled;\n\ts8 noise;\n};\n\n#define CFG80211_MAX_WEP_KEYS\t4\n\n/**\n * struct cfg80211_crypto_settings - Crypto settings\n * @wpa_versions: indicates which, if any, WPA versions are enabled\n *\t(from enum nl80211_wpa_versions)\n * @cipher_group: group key cipher suite (or 0 if unset)\n * @n_ciphers_pairwise: number of AP supported unicast ciphers\n * @ciphers_pairwise: unicast key cipher suites\n * @n_akm_suites: number of AKM suites\n * @akm_suites: AKM suites\n * @control_port: Whether user space controls IEEE 802.1X port, i.e.,\n *\tsets/clears %NL80211_STA_FLAG_AUTHORIZED. If true, the driver is\n *\trequired to assume that the port is unauthorized until authorized by\n *\tuser space. Otherwise, port is marked authorized by default.\n * @control_port_ethertype: the control port protocol that should be\n *\tallowed through even on unauthorized ports\n * @control_port_no_encrypt: TRUE to prevent encryption of control port\n *\tprotocol frames.\n * @control_port_over_nl80211: TRUE if userspace expects to exchange control\n *\tport frames over NL80211 instead of the network interface.\n * @control_port_no_preauth: disables pre-auth rx over the nl80211 control\n *\tport for mac80211\n * @wep_keys: static WEP keys, if not NULL points to an array of\n *\tCFG80211_MAX_WEP_KEYS WEP keys\n * @wep_tx_key: key index (0..3) of the default TX static WEP key\n * @psk: PSK (for devices supporting 4-way-handshake offload)\n * @sae_pwd: password for SAE authentication (for devices supporting SAE\n *\toffload)\n * @sae_pwd_len: length of SAE password (for devices supporting SAE offload)\n * @sae_pwe: The mechanisms allowed for SAE PWE derivation:\n *\n *\tNL80211_SAE_PWE_UNSPECIFIED\n *\t  Not-specified, used to indicate userspace did not specify any\n *\t  preference. The driver should follow its internal policy in\n *\t  such a scenario.\n *\n *\tNL80211_SAE_PWE_HUNT_AND_PECK\n *\t  Allow hunting-and-pecking loop only\n *\n *\tNL80211_SAE_PWE_HASH_TO_ELEMENT\n *\t  Allow hash-to-element only\n *\n *\tNL80211_SAE_PWE_BOTH\n *\t  Allow either hunting-and-pecking loop or hash-to-element\n */\nstruct cfg80211_crypto_settings {\n\tu32 wpa_versions;\n\tu32 cipher_group;\n\tint n_ciphers_pairwise;\n\tu32 ciphers_pairwise[NL80211_MAX_NR_CIPHER_SUITES];\n\tint n_akm_suites;\n\tu32 akm_suites[NL80211_MAX_NR_AKM_SUITES];\n\tbool control_port;\n\t__be16 control_port_ethertype;\n\tbool control_port_no_encrypt;\n\tbool control_port_over_nl80211;\n\tbool control_port_no_preauth;\n\tstruct key_params *wep_keys;\n\tint wep_tx_key;\n\tconst u8 *psk;\n\tconst u8 *sae_pwd;\n\tu8 sae_pwd_len;\n\tenum nl80211_sae_pwe_mechanism sae_pwe;\n};\n\n/**\n * struct cfg80211_beacon_data - beacon data\n * @head: head portion of beacon (before TIM IE)\n *\tor %NULL if not changed\n * @tail: tail portion of beacon (after TIM IE)\n *\tor %NULL if not changed\n * @head_len: length of @head\n * @tail_len: length of @tail\n * @beacon_ies: extra information element(s) to add into Beacon frames or %NULL\n * @beacon_ies_len: length of beacon_ies in octets\n * @proberesp_ies: extra information element(s) to add into Probe Response\n *\tframes or %NULL\n * @proberesp_ies_len: length of proberesp_ies in octets\n * @assocresp_ies: extra information element(s) to add into (Re)Association\n *\tResponse frames or %NULL\n * @assocresp_ies_len: length of assocresp_ies in octets\n * @probe_resp_len: length of probe response template (@probe_resp)\n * @probe_resp: probe response template (AP mode only)\n * @ftm_responder: enable FTM responder functionality; -1 for no change\n *\t(which also implies no change in LCI/civic location data)\n * @lci: Measurement Report element content, starting with Measurement Token\n *\t(measurement type 8)\n * @civicloc: Measurement Report element content, starting with Measurement\n *\tToken (measurement type 11)\n * @lci_len: LCI data length\n * @civicloc_len: Civic location data length\n */\nstruct cfg80211_beacon_data {\n\tconst u8 *head, *tail;\n\tconst u8 *beacon_ies;\n\tconst u8 *proberesp_ies;\n\tconst u8 *assocresp_ies;\n\tconst u8 *probe_resp;\n\tconst u8 *lci;\n\tconst u8 *civicloc;\n\ts8 ftm_responder;\n\n\tsize_t head_len, tail_len;\n\tsize_t beacon_ies_len;\n\tsize_t proberesp_ies_len;\n\tsize_t assocresp_ies_len;\n\tsize_t probe_resp_len;\n\tsize_t lci_len;\n\tsize_t civicloc_len;\n};\n\nstruct mac_address {\n\tu8 addr[ETH_ALEN];\n};\n\n/**\n * struct cfg80211_acl_data - Access control list data\n *\n * @acl_policy: ACL policy to be applied on the station's\n *\tentry specified by mac_addr\n * @n_acl_entries: Number of MAC address entries passed\n * @mac_addrs: List of MAC addresses of stations to be used for ACL\n */\nstruct cfg80211_acl_data {\n\tenum nl80211_acl_policy acl_policy;\n\tint n_acl_entries;\n\n\t/* Keep it last */\n\tstruct mac_address mac_addrs[];\n};\n\n/**\n * struct cfg80211_fils_discovery - FILS discovery parameters from\n * IEEE Std 802.11ai-2016, Annex C.3 MIB detail.\n *\n * @min_interval: Minimum packet interval in TUs (0 - 10000)\n * @max_interval: Maximum packet interval in TUs (0 - 10000)\n * @tmpl_len: Template length\n * @tmpl: Template data for FILS discovery frame including the action\n *\tframe headers.\n */\nstruct cfg80211_fils_discovery {\n\tu32 min_interval;\n\tu32 max_interval;\n\tsize_t tmpl_len;\n\tconst u8 *tmpl;\n};\n\n/**\n * struct cfg80211_unsol_bcast_probe_resp - Unsolicited broadcast probe\n *\tresponse parameters in 6GHz.\n *\n * @interval: Packet interval in TUs. Maximum allowed is 20 TU, as mentioned\n *\tin IEEE P802.11ax/D6.0 26.17.2.3.2 - AP behavior for fast passive\n *\tscanning\n * @tmpl_len: Template length\n * @tmpl: Template data for probe response\n */\nstruct cfg80211_unsol_bcast_probe_resp {\n\tu32 interval;\n\tsize_t tmpl_len;\n\tconst u8 *tmpl;\n};\n\n/**\n * enum cfg80211_ap_settings_flags - AP settings flags\n *\n * Used by cfg80211_ap_settings\n *\n * @AP_SETTINGS_EXTERNAL_AUTH_SUPPORT: AP supports external authentication\n */\nenum cfg80211_ap_settings_flags {\n\tAP_SETTINGS_EXTERNAL_AUTH_SUPPORT = BIT(0),\n};\n\n/**\n * struct cfg80211_ap_settings - AP configuration\n *\n * Used to configure an AP interface.\n *\n * @chandef: defines the channel to use\n * @beacon: beacon data\n * @beacon_interval: beacon interval\n * @dtim_period: DTIM period\n * @ssid: SSID to be used in the BSS (note: may be %NULL if not provided from\n *\tuser space)\n * @ssid_len: length of @ssid\n * @hidden_ssid: whether to hide the SSID in Beacon/Probe Response frames\n * @crypto: crypto settings\n * @privacy: the BSS uses privacy\n * @auth_type: Authentication type (algorithm)\n * @smps_mode: SMPS mode\n * @inactivity_timeout: time in seconds to determine station's inactivity.\n * @p2p_ctwindow: P2P CT Window\n * @p2p_opp_ps: P2P opportunistic PS\n * @acl: ACL configuration used by the drivers which has support for\n *\tMAC address based access control\n * @pbss: If set, start as a PCP instead of AP. Relevant for DMG\n *\tnetworks.\n * @beacon_rate: bitrate to be used for beacons\n * @ht_cap: HT capabilities (or %NULL if HT isn't enabled)\n * @vht_cap: VHT capabilities (or %NULL if VHT isn't enabled)\n * @he_cap: HE capabilities (or %NULL if HE isn't enabled)\n * @ht_required: stations must support HT\n * @vht_required: stations must support VHT\n * @twt_responder: Enable Target Wait Time\n * @he_required: stations must support HE\n * @sae_h2e_required: stations must support direct H2E technique in SAE\n * @flags: flags, as defined in enum cfg80211_ap_settings_flags\n * @he_obss_pd: OBSS Packet Detection settings\n * @he_bss_color: BSS Color settings\n * @he_oper: HE operation IE (or %NULL if HE isn't enabled)\n * @fils_discovery: FILS discovery transmission parameters\n * @unsol_bcast_probe_resp: Unsolicited broadcast probe response parameters\n */\nstruct cfg80211_ap_settings {\n\tstruct cfg80211_chan_def chandef;\n\n\tstruct cfg80211_beacon_data beacon;\n\n\tint beacon_interval, dtim_period;\n\tconst u8 *ssid;\n\tsize_t ssid_len;\n\tenum nl80211_hidden_ssid hidden_ssid;\n\tstruct cfg80211_crypto_settings crypto;\n\tbool privacy;\n\tenum nl80211_auth_type auth_type;\n\tenum nl80211_smps_mode smps_mode;\n\tint inactivity_timeout;\n\tu8 p2p_ctwindow;\n\tbool p2p_opp_ps;\n\tconst struct cfg80211_acl_data *acl;\n\tbool pbss;\n\tstruct cfg80211_bitrate_mask beacon_rate;\n\n\tconst struct ieee80211_ht_cap *ht_cap;\n\tconst struct ieee80211_vht_cap *vht_cap;\n\tconst struct ieee80211_he_cap_elem *he_cap;\n\tconst struct ieee80211_he_operation *he_oper;\n\tbool ht_required, vht_required, he_required, sae_h2e_required;\n\tbool twt_responder;\n\tu32 flags;\n\tstruct ieee80211_he_obss_pd he_obss_pd;\n\tstruct cfg80211_he_bss_color he_bss_color;\n\tstruct cfg80211_fils_discovery fils_discovery;\n\tstruct cfg80211_unsol_bcast_probe_resp unsol_bcast_probe_resp;\n};\n\n/**\n * struct cfg80211_csa_settings - channel switch settings\n *\n * Used for channel switch\n *\n * @chandef: defines the channel to use after the switch\n * @beacon_csa: beacon data while performing the switch\n * @counter_offsets_beacon: offsets of the counters within the beacon (tail)\n * @counter_offsets_presp: offsets of the counters within the probe response\n * @n_counter_offsets_beacon: number of csa counters the beacon (tail)\n * @n_counter_offsets_presp: number of csa counters in the probe response\n * @beacon_after: beacon data to be used on the new channel\n * @radar_required: whether radar detection is required on the new channel\n * @block_tx: whether transmissions should be blocked while changing\n * @count: number of beacons until switch\n */\nstruct cfg80211_csa_settings {\n\tstruct cfg80211_chan_def chandef;\n\tstruct cfg80211_beacon_data beacon_csa;\n\tconst u16 *counter_offsets_beacon;\n\tconst u16 *counter_offsets_presp;\n\tunsigned int n_counter_offsets_beacon;\n\tunsigned int n_counter_offsets_presp;\n\tstruct cfg80211_beacon_data beacon_after;\n\tbool radar_required;\n\tbool block_tx;\n\tu8 count;\n};\n\n#define CFG80211_MAX_NUM_DIFFERENT_CHANNELS 10\n\n/**\n * struct iface_combination_params - input parameters for interface combinations\n *\n * Used to pass interface combination parameters\n *\n * @num_different_channels: the number of different channels we want\n *\tto use for verification\n * @radar_detect: a bitmap where each bit corresponds to a channel\n *\twidth where radar detection is needed, as in the definition of\n *\t&struct ieee80211_iface_combination.@radar_detect_widths\n * @iftype_num: array with the number of interfaces of each interface\n *\ttype.  The index is the interface type as specified in &enum\n *\tnl80211_iftype.\n * @new_beacon_int: set this to the beacon interval of a new interface\n *\tthat's not operating yet, if such is to be checked as part of\n *\tthe verification\n */\nstruct iface_combination_params {\n\tint num_different_channels;\n\tu8 radar_detect;\n\tint iftype_num[NUM_NL80211_IFTYPES];\n\tu32 new_beacon_int;\n};\n\n/**\n * enum station_parameters_apply_mask - station parameter values to apply\n * @STATION_PARAM_APPLY_UAPSD: apply new uAPSD parameters (uapsd_queues, max_sp)\n * @STATION_PARAM_APPLY_CAPABILITY: apply new capability\n * @STATION_PARAM_APPLY_PLINK_STATE: apply new plink state\n *\n * Not all station parameters have in-band \"no change\" signalling,\n * for those that don't these flags will are used.\n */\nenum station_parameters_apply_mask {\n\tSTATION_PARAM_APPLY_UAPSD = BIT(0),\n\tSTATION_PARAM_APPLY_CAPABILITY = BIT(1),\n\tSTATION_PARAM_APPLY_PLINK_STATE = BIT(2),\n\tSTATION_PARAM_APPLY_STA_TXPOWER = BIT(3),\n};\n\n/**\n * struct sta_txpwr - station txpower configuration\n *\n * Used to configure txpower for station.\n *\n * @power: tx power (in dBm) to be used for sending data traffic. If tx power\n *\tis not provided, the default per-interface tx power setting will be\n *\toverriding. Driver should be picking up the lowest tx power, either tx\n *\tpower per-interface or per-station.\n * @type: In particular if TPC %type is NL80211_TX_POWER_LIMITED then tx power\n *\twill be less than or equal to specified from userspace, whereas if TPC\n *\t%type is NL80211_TX_POWER_AUTOMATIC then it indicates default tx power.\n *\tNL80211_TX_POWER_FIXED is not a valid configuration option for\n *\tper peer TPC.\n */\nstruct sta_txpwr {\n\ts16 power;\n\tenum nl80211_tx_power_setting type;\n};\n\n/**\n * struct station_parameters - station parameters\n *\n * Used to change and create a new station.\n *\n * @vlan: vlan interface station should belong to\n * @supported_rates: supported rates in IEEE 802.11 format\n *\t(or NULL for no change)\n * @supported_rates_len: number of supported rates\n * @sta_flags_mask: station flags that changed\n *\t(bitmask of BIT(%NL80211_STA_FLAG_...))\n * @sta_flags_set: station flags values\n *\t(bitmask of BIT(%NL80211_STA_FLAG_...))\n * @listen_interval: listen interval or -1 for no change\n * @aid: AID or zero for no change\n * @vlan_id: VLAN ID for station (if nonzero)\n * @peer_aid: mesh peer AID or zero for no change\n * @plink_action: plink action to take\n * @plink_state: set the peer link state for a station\n * @ht_capa: HT capabilities of station\n * @vht_capa: VHT capabilities of station\n * @uapsd_queues: bitmap of queues configured for uapsd. same format\n *\tas the AC bitmap in the QoS info field\n * @max_sp: max Service Period. same format as the MAX_SP in the\n *\tQoS info field (but already shifted down)\n * @sta_modify_mask: bitmap indicating which parameters changed\n *\t(for those that don't have a natural \"no change\" value),\n *\tsee &enum station_parameters_apply_mask\n * @local_pm: local link-specific mesh power save mode (no change when set\n *\tto unknown)\n * @capability: station capability\n * @ext_capab: extended capabilities of the station\n * @ext_capab_len: number of extended capabilities\n * @supported_channels: supported channels in IEEE 802.11 format\n * @supported_channels_len: number of supported channels\n * @supported_oper_classes: supported oper classes in IEEE 802.11 format\n * @supported_oper_classes_len: number of supported operating classes\n * @opmode_notif: operating mode field from Operating Mode Notification\n * @opmode_notif_used: information if operating mode field is used\n * @support_p2p_ps: information if station supports P2P PS mechanism\n * @he_capa: HE capabilities of station\n * @he_capa_len: the length of the HE capabilities\n * @airtime_weight: airtime scheduler weight for this station\n * @txpwr: transmit power for an associated station\n * @he_6ghz_capa: HE 6 GHz Band capabilities of station\n */\nstruct station_parameters {\n\tconst u8 *supported_rates;\n\tstruct net_device *vlan;\n\tu32 sta_flags_mask, sta_flags_set;\n\tu32 sta_modify_mask;\n\tint listen_interval;\n\tu16 aid;\n\tu16 vlan_id;\n\tu16 peer_aid;\n\tu8 supported_rates_len;\n\tu8 plink_action;\n\tu8 plink_state;\n\tconst struct ieee80211_ht_cap *ht_capa;\n\tconst struct ieee80211_vht_cap *vht_capa;\n\tu8 uapsd_queues;\n\tu8 max_sp;\n\tenum nl80211_mesh_power_mode local_pm;\n\tu16 capability;\n\tconst u8 *ext_capab;\n\tu8 ext_capab_len;\n\tconst u8 *supported_channels;\n\tu8 supported_channels_len;\n\tconst u8 *supported_oper_classes;\n\tu8 supported_oper_classes_len;\n\tu8 opmode_notif;\n\tbool opmode_notif_used;\n\tint support_p2p_ps;\n\tconst struct ieee80211_he_cap_elem *he_capa;\n\tu8 he_capa_len;\n\tu16 airtime_weight;\n\tstruct sta_txpwr txpwr;\n\tconst struct ieee80211_he_6ghz_capa *he_6ghz_capa;\n};\n\n/**\n * struct station_del_parameters - station deletion parameters\n *\n * Used to delete a station entry (or all stations).\n *\n * @mac: MAC address of the station to remove or NULL to remove all stations\n * @subtype: Management frame subtype to use for indicating removal\n *\t(10 = Disassociation, 12 = Deauthentication)\n * @reason_code: Reason code for the Disassociation/Deauthentication frame\n */\nstruct station_del_parameters {\n\tconst u8 *mac;\n\tu8 subtype;\n\tu16 reason_code;\n};\n\n/**\n * enum cfg80211_station_type - the type of station being modified\n * @CFG80211_STA_AP_CLIENT: client of an AP interface\n * @CFG80211_STA_AP_CLIENT_UNASSOC: client of an AP interface that is still\n *\tunassociated (update properties for this type of client is permitted)\n * @CFG80211_STA_AP_MLME_CLIENT: client of an AP interface that has\n *\tthe AP MLME in the device\n * @CFG80211_STA_AP_STA: AP station on managed interface\n * @CFG80211_STA_IBSS: IBSS station\n * @CFG80211_STA_TDLS_PEER_SETUP: TDLS peer on managed interface (dummy entry\n *\twhile TDLS setup is in progress, it moves out of this state when\n *\tbeing marked authorized; use this only if TDLS with external setup is\n *\tsupported/used)\n * @CFG80211_STA_TDLS_PEER_ACTIVE: TDLS peer on managed interface (active\n *\tentry that is operating, has been marked authorized by userspace)\n * @CFG80211_STA_MESH_PEER_KERNEL: peer on mesh interface (kernel managed)\n * @CFG80211_STA_MESH_PEER_USER: peer on mesh interface (user managed)\n */\nenum cfg80211_station_type {\n\tCFG80211_STA_AP_CLIENT,\n\tCFG80211_STA_AP_CLIENT_UNASSOC,\n\tCFG80211_STA_AP_MLME_CLIENT,\n\tCFG80211_STA_AP_STA,\n\tCFG80211_STA_IBSS,\n\tCFG80211_STA_TDLS_PEER_SETUP,\n\tCFG80211_STA_TDLS_PEER_ACTIVE,\n\tCFG80211_STA_MESH_PEER_KERNEL,\n\tCFG80211_STA_MESH_PEER_USER,\n};\n\n/**\n * cfg80211_check_station_change - validate parameter changes\n * @wiphy: the wiphy this operates on\n * @params: the new parameters for a station\n * @statype: the type of station being modified\n *\n * Utility function for the @change_station driver method. Call this function\n * with the appropriate station type looking up the station (and checking that\n * it exists). It will verify whether the station change is acceptable, and if\n * not will return an error code. Note that it may modify the parameters for\n * backward compatibility reasons, so don't use them before calling this.\n */\nint cfg80211_check_station_change(struct wiphy *wiphy,\n\t\t\t\t  struct station_parameters *params,\n\t\t\t\t  enum cfg80211_station_type statype);\n\n/**\n * enum rate_info_flags - bitrate info flags\n *\n * Used by the driver to indicate the specific rate transmission\n * type for 802.11n transmissions.\n *\n * @RATE_INFO_FLAGS_MCS: mcs field filled with HT MCS\n * @RATE_INFO_FLAGS_VHT_MCS: mcs field filled with VHT MCS\n * @RATE_INFO_FLAGS_SHORT_GI: 400ns guard interval\n * @RATE_INFO_FLAGS_DMG: 60GHz MCS\n * @RATE_INFO_FLAGS_HE_MCS: HE MCS information\n * @RATE_INFO_FLAGS_EDMG: 60GHz MCS in EDMG mode\n * @RATE_INFO_FLAGS_EXTENDED_SC_DMG: 60GHz extended SC MCS\n */\nenum rate_info_flags {\n\tRATE_INFO_FLAGS_MCS\t\t\t= BIT(0),\n\tRATE_INFO_FLAGS_VHT_MCS\t\t\t= BIT(1),\n\tRATE_INFO_FLAGS_SHORT_GI\t\t= BIT(2),\n\tRATE_INFO_FLAGS_DMG\t\t\t= BIT(3),\n\tRATE_INFO_FLAGS_HE_MCS\t\t\t= BIT(4),\n\tRATE_INFO_FLAGS_EDMG\t\t\t= BIT(5),\n\tRATE_INFO_FLAGS_EXTENDED_SC_DMG\t\t= BIT(6),\n};\n\n/**\n * enum rate_info_bw - rate bandwidth information\n *\n * Used by the driver to indicate the rate bandwidth.\n *\n * @RATE_INFO_BW_5: 5 MHz bandwidth\n * @RATE_INFO_BW_10: 10 MHz bandwidth\n * @RATE_INFO_BW_20: 20 MHz bandwidth\n * @RATE_INFO_BW_40: 40 MHz bandwidth\n * @RATE_INFO_BW_80: 80 MHz bandwidth\n * @RATE_INFO_BW_160: 160 MHz bandwidth\n * @RATE_INFO_BW_HE_RU: bandwidth determined by HE RU allocation\n */\nenum rate_info_bw {\n\tRATE_INFO_BW_20 = 0,\n\tRATE_INFO_BW_5,\n\tRATE_INFO_BW_10,\n\tRATE_INFO_BW_40,\n\tRATE_INFO_BW_80,\n\tRATE_INFO_BW_160,\n\tRATE_INFO_BW_HE_RU,\n};\n\n/**\n * struct rate_info - bitrate information\n *\n * Information about a receiving or transmitting bitrate\n *\n * @flags: bitflag of flags from &enum rate_info_flags\n * @mcs: mcs index if struct describes an HT/VHT/HE rate\n * @legacy: bitrate in 100kbit/s for 802.11abg\n * @nss: number of streams (VHT & HE only)\n * @bw: bandwidth (from &enum rate_info_bw)\n * @he_gi: HE guard interval (from &enum nl80211_he_gi)\n * @he_dcm: HE DCM value\n * @he_ru_alloc: HE RU allocation (from &enum nl80211_he_ru_alloc,\n *\tonly valid if bw is %RATE_INFO_BW_HE_RU)\n * @n_bonded_ch: In case of EDMG the number of bonded channels (1-4)\n */\nstruct rate_info {\n\tu8 flags;\n\tu8 mcs;\n\tu16 legacy;\n\tu8 nss;\n\tu8 bw;\n\tu8 he_gi;\n\tu8 he_dcm;\n\tu8 he_ru_alloc;\n\tu8 n_bonded_ch;\n};\n\n/**\n * enum bss_param_flags - bitrate info flags\n *\n * Used by the driver to indicate the specific rate transmission\n * type for 802.11n transmissions.\n *\n * @BSS_PARAM_FLAGS_CTS_PROT: whether CTS protection is enabled\n * @BSS_PARAM_FLAGS_SHORT_PREAMBLE: whether short preamble is enabled\n * @BSS_PARAM_FLAGS_SHORT_SLOT_TIME: whether short slot time is enabled\n */\nenum bss_param_flags {\n\tBSS_PARAM_FLAGS_CTS_PROT\t= 1<<0,\n\tBSS_PARAM_FLAGS_SHORT_PREAMBLE\t= 1<<1,\n\tBSS_PARAM_FLAGS_SHORT_SLOT_TIME\t= 1<<2,\n};\n\n/**\n * struct sta_bss_parameters - BSS parameters for the attached station\n *\n * Information about the currently associated BSS\n *\n * @flags: bitflag of flags from &enum bss_param_flags\n * @dtim_period: DTIM period for the BSS\n * @beacon_interval: beacon interval\n */\nstruct sta_bss_parameters {\n\tu8 flags;\n\tu8 dtim_period;\n\tu16 beacon_interval;\n};\n\n/**\n * struct cfg80211_txq_stats - TXQ statistics for this TID\n * @filled: bitmap of flags using the bits of &enum nl80211_txq_stats to\n *\tindicate the relevant values in this struct are filled\n * @backlog_bytes: total number of bytes currently backlogged\n * @backlog_packets: total number of packets currently backlogged\n * @flows: number of new flows seen\n * @drops: total number of packets dropped\n * @ecn_marks: total number of packets marked with ECN CE\n * @overlimit: number of drops due to queue space overflow\n * @overmemory: number of drops due to memory limit overflow\n * @collisions: number of hash collisions\n * @tx_bytes: total number of bytes dequeued\n * @tx_packets: total number of packets dequeued\n * @max_flows: maximum number of flows supported\n */\nstruct cfg80211_txq_stats {\n\tu32 filled;\n\tu32 backlog_bytes;\n\tu32 backlog_packets;\n\tu32 flows;\n\tu32 drops;\n\tu32 ecn_marks;\n\tu32 overlimit;\n\tu32 overmemory;\n\tu32 collisions;\n\tu32 tx_bytes;\n\tu32 tx_packets;\n\tu32 max_flows;\n};\n\n/**\n * struct cfg80211_tid_stats - per-TID statistics\n * @filled: bitmap of flags using the bits of &enum nl80211_tid_stats to\n *\tindicate the relevant values in this struct are filled\n * @rx_msdu: number of received MSDUs\n * @tx_msdu: number of (attempted) transmitted MSDUs\n * @tx_msdu_retries: number of retries (not counting the first) for\n *\ttransmitted MSDUs\n * @tx_msdu_failed: number of failed transmitted MSDUs\n * @txq_stats: TXQ statistics\n */\nstruct cfg80211_tid_stats {\n\tu32 filled;\n\tu64 rx_msdu;\n\tu64 tx_msdu;\n\tu64 tx_msdu_retries;\n\tu64 tx_msdu_failed;\n\tstruct cfg80211_txq_stats txq_stats;\n};\n\n#define IEEE80211_MAX_CHAINS\t4\n\n/**\n * struct station_info - station information\n *\n * Station information filled by driver for get_station() and dump_station.\n *\n * @filled: bitflag of flags using the bits of &enum nl80211_sta_info to\n *\tindicate the relevant values in this struct for them\n * @connected_time: time(in secs) since a station is last connected\n * @inactive_time: time since last station activity (tx/rx) in milliseconds\n * @assoc_at: bootime (ns) of the last association\n * @rx_bytes: bytes (size of MPDUs) received from this station\n * @tx_bytes: bytes (size of MPDUs) transmitted to this station\n * @llid: mesh local link id\n * @plid: mesh peer link id\n * @plink_state: mesh peer link state\n * @signal: The signal strength, type depends on the wiphy's signal_type.\n *\tFor CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.\n * @signal_avg: Average signal strength, type depends on the wiphy's signal_type.\n *\tFor CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.\n * @chains: bitmask for filled values in @chain_signal, @chain_signal_avg\n * @chain_signal: per-chain signal strength of last received packet in dBm\n * @chain_signal_avg: per-chain signal strength average in dBm\n * @txrate: current unicast bitrate from this station\n * @rxrate: current unicast bitrate to this station\n * @rx_packets: packets (MSDUs & MMPDUs) received from this station\n * @tx_packets: packets (MSDUs & MMPDUs) transmitted to this station\n * @tx_retries: cumulative retry counts (MPDUs)\n * @tx_failed: number of failed transmissions (MPDUs) (retries exceeded, no ACK)\n * @rx_dropped_misc:  Dropped for un-specified reason.\n * @bss_param: current BSS parameters\n * @generation: generation number for nl80211 dumps.\n *\tThis number should increase every time the list of stations\n *\tchanges, i.e. when a station is added or removed, so that\n *\tuserspace can tell whether it got a consistent snapshot.\n * @assoc_req_ies: IEs from (Re)Association Request.\n *\tThis is used only when in AP mode with drivers that do not use\n *\tuser space MLME/SME implementation. The information is provided for\n *\tthe cfg80211_new_sta() calls to notify user space of the IEs.\n * @assoc_req_ies_len: Length of assoc_req_ies buffer in octets.\n * @sta_flags: station flags mask & values\n * @beacon_loss_count: Number of times beacon loss event has triggered.\n * @t_offset: Time offset of the station relative to this host.\n * @local_pm: local mesh STA power save mode\n * @peer_pm: peer mesh STA power save mode\n * @nonpeer_pm: non-peer mesh STA power save mode\n * @expected_throughput: expected throughput in kbps (including 802.11 headers)\n *\ttowards this station.\n * @rx_beacon: number of beacons received from this peer\n * @rx_beacon_signal_avg: signal strength average (in dBm) for beacons received\n *\tfrom this peer\n * @connected_to_gate: true if mesh STA has a path to mesh gate\n * @rx_duration: aggregate PPDU duration(usecs) for all the frames from a peer\n * @tx_duration: aggregate PPDU duration(usecs) for all the frames to a peer\n * @airtime_weight: current airtime scheduling weight\n * @pertid: per-TID statistics, see &struct cfg80211_tid_stats, using the last\n *\t(IEEE80211_NUM_TIDS) index for MSDUs not encapsulated in QoS-MPDUs.\n *\tNote that this doesn't use the @filled bit, but is used if non-NULL.\n * @ack_signal: signal strength (in dBm) of the last ACK frame.\n * @avg_ack_signal: average rssi value of ack packet for the no of msdu's has\n *\tbeen sent.\n * @rx_mpdu_count: number of MPDUs received from this station\n * @fcs_err_count: number of packets (MPDUs) received from this station with\n *\tan FCS error. This counter should be incremented only when TA of the\n *\treceived packet with an FCS error matches the peer MAC address.\n * @airtime_link_metric: mesh airtime link metric.\n * @connected_to_as: true if mesh STA has a path to authentication server\n */\nstruct station_info {\n\tu64 filled;\n\tu32 connected_time;\n\tu32 inactive_time;\n\tu64 assoc_at;\n\tu64 rx_bytes;\n\tu64 tx_bytes;\n\tu16 llid;\n\tu16 plid;\n\tu8 plink_state;\n\ts8 signal;\n\ts8 signal_avg;\n\n\tu8 chains;\n\ts8 chain_signal[IEEE80211_MAX_CHAINS];\n\ts8 chain_signal_avg[IEEE80211_MAX_CHAINS];\n\n\tstruct rate_info txrate;\n\tstruct rate_info rxrate;\n\tu32 rx_packets;\n\tu32 tx_packets;\n\tu32 tx_retries;\n\tu32 tx_failed;\n\tu32 rx_dropped_misc;\n\tstruct sta_bss_parameters bss_param;\n\tstruct nl80211_sta_flag_update sta_flags;\n\n\tint generation;\n\n\tconst u8 *assoc_req_ies;\n\tsize_t assoc_req_ies_len;\n\n\tu32 beacon_loss_count;\n\ts64 t_offset;\n\tenum nl80211_mesh_power_mode local_pm;\n\tenum nl80211_mesh_power_mode peer_pm;\n\tenum nl80211_mesh_power_mode nonpeer_pm;\n\n\tu32 expected_throughput;\n\n\tu64 tx_duration;\n\tu64 rx_duration;\n\tu64 rx_beacon;\n\tu8 rx_beacon_signal_avg;\n\tu8 connected_to_gate;\n\n\tstruct cfg80211_tid_stats *pertid;\n\ts8 ack_signal;\n\ts8 avg_ack_signal;\n\n\tu16 airtime_weight;\n\n\tu32 rx_mpdu_count;\n\tu32 fcs_err_count;\n\n\tu32 airtime_link_metric;\n\n\tu8 connected_to_as;\n};\n\n/**\n * struct cfg80211_sar_sub_specs - sub specs limit\n * @power: power limitation in 0.25dbm\n * @freq_range_index: index the power limitation applies to\n */\nstruct cfg80211_sar_sub_specs {\n\ts32 power;\n\tu32 freq_range_index;\n};\n\n/**\n * struct cfg80211_sar_specs - sar limit specs\n * @type: it's set with power in 0.25dbm or other types\n * @num_sub_specs: number of sar sub specs\n * @sub_specs: memory to hold the sar sub specs\n */\nstruct cfg80211_sar_specs {\n\tenum nl80211_sar_type type;\n\tu32 num_sub_specs;\n\tstruct cfg80211_sar_sub_specs sub_specs[];\n};\n\n\n/**\n * struct cfg80211_sar_freq_ranges - sar frequency ranges\n * @start_freq:  start range edge frequency\n * @end_freq:    end range edge frequency\n */\nstruct cfg80211_sar_freq_ranges {\n\tu32 start_freq;\n\tu32 end_freq;\n};\n\n/**\n * struct cfg80211_sar_capa - sar limit capability\n * @type: it's set via power in 0.25dbm or other types\n * @num_freq_ranges: number of frequency ranges\n * @freq_ranges: memory to hold the freq ranges.\n *\n * Note: WLAN driver may append new ranges or split an existing\n * range to small ones and then append them.\n */\nstruct cfg80211_sar_capa {\n\tenum nl80211_sar_type type;\n\tu32 num_freq_ranges;\n\tconst struct cfg80211_sar_freq_ranges *freq_ranges;\n};\n\n#if IS_ENABLED(CONFIG_CFG80211)\n/**\n * cfg80211_get_station - retrieve information about a given station\n * @dev: the device where the station is supposed to be connected to\n * @mac_addr: the mac address of the station of interest\n * @sinfo: pointer to the structure to fill with the information\n *\n * Returns 0 on success and sinfo is filled with the available information\n * otherwise returns a negative error code and the content of sinfo has to be\n * considered undefined.\n */\nint cfg80211_get_station(struct net_device *dev, const u8 *mac_addr,\n\t\t\t struct station_info *sinfo);\n#else\nstatic inline int cfg80211_get_station(struct net_device *dev,\n\t\t\t\t       const u8 *mac_addr,\n\t\t\t\t       struct station_info *sinfo)\n{\n\treturn -ENOENT;\n}\n#endif\n\n/**\n * enum monitor_flags - monitor flags\n *\n * Monitor interface configuration flags. Note that these must be the bits\n * according to the nl80211 flags.\n *\n * @MONITOR_FLAG_CHANGED: set if the flags were changed\n * @MONITOR_FLAG_FCSFAIL: pass frames with bad FCS\n * @MONITOR_FLAG_PLCPFAIL: pass frames with bad PLCP\n * @MONITOR_FLAG_CONTROL: pass control frames\n * @MONITOR_FLAG_OTHER_BSS: disable BSSID filtering\n * @MONITOR_FLAG_COOK_FRAMES: report frames after processing\n * @MONITOR_FLAG_ACTIVE: active monitor, ACKs frames on its MAC address\n */\nenum monitor_flags {\n\tMONITOR_FLAG_CHANGED\t\t= 1<<__NL80211_MNTR_FLAG_INVALID,\n\tMONITOR_FLAG_FCSFAIL\t\t= 1<<NL80211_MNTR_FLAG_FCSFAIL,\n\tMONITOR_FLAG_PLCPFAIL\t\t= 1<<NL80211_MNTR_FLAG_PLCPFAIL,\n\tMONITOR_FLAG_CONTROL\t\t= 1<<NL80211_MNTR_FLAG_CONTROL,\n\tMONITOR_FLAG_OTHER_BSS\t\t= 1<<NL80211_MNTR_FLAG_OTHER_BSS,\n\tMONITOR_FLAG_COOK_FRAMES\t= 1<<NL80211_MNTR_FLAG_COOK_FRAMES,\n\tMONITOR_FLAG_ACTIVE\t\t= 1<<NL80211_MNTR_FLAG_ACTIVE,\n};\n\n/**\n * enum mpath_info_flags -  mesh path information flags\n *\n * Used by the driver to indicate which info in &struct mpath_info it has filled\n * in during get_station() or dump_station().\n *\n * @MPATH_INFO_FRAME_QLEN: @frame_qlen filled\n * @MPATH_INFO_SN: @sn filled\n * @MPATH_INFO_METRIC: @metric filled\n * @MPATH_INFO_EXPTIME: @exptime filled\n * @MPATH_INFO_DISCOVERY_TIMEOUT: @discovery_timeout filled\n * @MPATH_INFO_DISCOVERY_RETRIES: @discovery_retries filled\n * @MPATH_INFO_FLAGS: @flags filled\n * @MPATH_INFO_HOP_COUNT: @hop_count filled\n * @MPATH_INFO_PATH_CHANGE: @path_change_count filled\n */\nenum mpath_info_flags {\n\tMPATH_INFO_FRAME_QLEN\t\t= BIT(0),\n\tMPATH_INFO_SN\t\t\t= BIT(1),\n\tMPATH_INFO_METRIC\t\t= BIT(2),\n\tMPATH_INFO_EXPTIME\t\t= BIT(3),\n\tMPATH_INFO_DISCOVERY_TIMEOUT\t= BIT(4),\n\tMPATH_INFO_DISCOVERY_RETRIES\t= BIT(5),\n\tMPATH_INFO_FLAGS\t\t= BIT(6),\n\tMPATH_INFO_HOP_COUNT\t\t= BIT(7),\n\tMPATH_INFO_PATH_CHANGE\t\t= BIT(8),\n};\n\n/**\n * struct mpath_info - mesh path information\n *\n * Mesh path information filled by driver for get_mpath() and dump_mpath().\n *\n * @filled: bitfield of flags from &enum mpath_info_flags\n * @frame_qlen: number of queued frames for this destination\n * @sn: target sequence number\n * @metric: metric (cost) of this mesh path\n * @exptime: expiration time for the mesh path from now, in msecs\n * @flags: mesh path flags\n * @discovery_timeout: total mesh path discovery timeout, in msecs\n * @discovery_retries: mesh path discovery retries\n * @generation: generation number for nl80211 dumps.\n *\tThis number should increase every time the list of mesh paths\n *\tchanges, i.e. when a station is added or removed, so that\n *\tuserspace can tell whether it got a consistent snapshot.\n * @hop_count: hops to destination\n * @path_change_count: total number of path changes to destination\n */\nstruct mpath_info {\n\tu32 filled;\n\tu32 frame_qlen;\n\tu32 sn;\n\tu32 metric;\n\tu32 exptime;\n\tu32 discovery_timeout;\n\tu8 discovery_retries;\n\tu8 flags;\n\tu8 hop_count;\n\tu32 path_change_count;\n\n\tint generation;\n};\n\n/**\n * struct bss_parameters - BSS parameters\n *\n * Used to change BSS parameters (mainly for AP mode).\n *\n * @use_cts_prot: Whether to use CTS protection\n *\t(0 = no, 1 = yes, -1 = do not change)\n * @use_short_preamble: Whether the use of short preambles is allowed\n *\t(0 = no, 1 = yes, -1 = do not change)\n * @use_short_slot_time: Whether the use of short slot time is allowed\n *\t(0 = no, 1 = yes, -1 = do not change)\n * @basic_rates: basic rates in IEEE 802.11 format\n *\t(or NULL for no change)\n * @basic_rates_len: number of basic rates\n * @ap_isolate: do not forward packets between connected stations\n *\t(0 = no, 1 = yes, -1 = do not change)\n * @ht_opmode: HT Operation mode\n *\t(u16 = opmode, -1 = do not change)\n * @p2p_ctwindow: P2P CT Window (-1 = no change)\n * @p2p_opp_ps: P2P opportunistic PS (-1 = no change)\n */\nstruct bss_parameters {\n\tint use_cts_prot;\n\tint use_short_preamble;\n\tint use_short_slot_time;\n\tconst u8 *basic_rates;\n\tu8 basic_rates_len;\n\tint ap_isolate;\n\tint ht_opmode;\n\ts8 p2p_ctwindow, p2p_opp_ps;\n};\n\n/**\n * struct mesh_config - 802.11s mesh configuration\n *\n * These parameters can be changed while the mesh is active.\n *\n * @dot11MeshRetryTimeout: the initial retry timeout in millisecond units used\n *\tby the Mesh Peering Open message\n * @dot11MeshConfirmTimeout: the initial retry timeout in millisecond units\n *\tused by the Mesh Peering Open message\n * @dot11MeshHoldingTimeout: the confirm timeout in millisecond units used by\n *\tthe mesh peering management to close a mesh peering\n * @dot11MeshMaxPeerLinks: the maximum number of peer links allowed on this\n *\tmesh interface\n * @dot11MeshMaxRetries: the maximum number of peer link open retries that can\n *\tbe sent to establish a new peer link instance in a mesh\n * @dot11MeshTTL: the value of TTL field set at a source mesh STA\n * @element_ttl: the value of TTL field set at a mesh STA for path selection\n *\telements\n * @auto_open_plinks: whether we should automatically open peer links when we\n *\tdetect compatible mesh peers\n * @dot11MeshNbrOffsetMaxNeighbor: the maximum number of neighbors to\n *\tsynchronize to for 11s default synchronization method\n * @dot11MeshHWMPmaxPREQretries: the number of action frames containing a PREQ\n *\tthat an originator mesh STA can send to a particular path target\n * @path_refresh_time: how frequently to refresh mesh paths in milliseconds\n * @min_discovery_timeout: the minimum length of time to wait until giving up on\n *\ta path discovery in milliseconds\n * @dot11MeshHWMPactivePathTimeout: the time (in TUs) for which mesh STAs\n *\treceiving a PREQ shall consider the forwarding information from the\n *\troot to be valid. (TU = time unit)\n * @dot11MeshHWMPpreqMinInterval: the minimum interval of time (in TUs) during\n *\twhich a mesh STA can send only one action frame containing a PREQ\n *\telement\n * @dot11MeshHWMPperrMinInterval: the minimum interval of time (in TUs) during\n *\twhich a mesh STA can send only one Action frame containing a PERR\n *\telement\n * @dot11MeshHWMPnetDiameterTraversalTime: the interval of time (in TUs) that\n *\tit takes for an HWMP information element to propagate across the mesh\n * @dot11MeshHWMPRootMode: the configuration of a mesh STA as root mesh STA\n * @dot11MeshHWMPRannInterval: the interval of time (in TUs) between root\n *\tannouncements are transmitted\n * @dot11MeshGateAnnouncementProtocol: whether to advertise that this mesh\n *\tstation has access to a broader network beyond the MBSS. (This is\n *\tmissnamed in draft 12.0: dot11MeshGateAnnouncementProtocol set to true\n *\tonly means that the station will announce others it's a mesh gate, but\n *\tnot necessarily using the gate announcement protocol. Still keeping the\n *\tsame nomenclature to be in sync with the spec)\n * @dot11MeshForwarding: whether the Mesh STA is forwarding or non-forwarding\n *\tentity (default is TRUE - forwarding entity)\n * @rssi_threshold: the threshold for average signal strength of candidate\n *\tstation to establish a peer link\n * @ht_opmode: mesh HT protection mode\n *\n * @dot11MeshHWMPactivePathToRootTimeout: The time (in TUs) for which mesh STAs\n *\treceiving a proactive PREQ shall consider the forwarding information to\n *\tthe root mesh STA to be valid.\n *\n * @dot11MeshHWMProotInterval: The interval of time (in TUs) between proactive\n *\tPREQs are transmitted.\n * @dot11MeshHWMPconfirmationInterval: The minimum interval of time (in TUs)\n *\tduring which a mesh STA can send only one Action frame containing\n *\ta PREQ element for root path confirmation.\n * @power_mode: The default mesh power save mode which will be the initial\n *\tsetting for new peer links.\n * @dot11MeshAwakeWindowDuration: The duration in TUs the STA will remain awake\n *\tafter transmitting its beacon.\n * @plink_timeout: If no tx activity is seen from a STA we've established\n *\tpeering with for longer than this time (in seconds), then remove it\n *\tfrom the STA's list of peers.  Default is 30 minutes.\n * @dot11MeshConnectedToMeshGate: if set to true, advertise that this STA is\n *      connected to a mesh gate in mesh formation info.  If false, the\n *      value in mesh formation is determined by the presence of root paths\n *      in the mesh path table\n * @dot11MeshNolearn: Try to avoid multi-hop path discovery (e.g. PREQ/PREP\n *      for HWMP) if the destination is a direct neighbor. Note that this might\n *      not be the optimal decision as a multi-hop route might be better. So\n *      if using this setting you will likely also want to disable\n *      dot11MeshForwarding and use another mesh routing protocol on top.\n */\nstruct mesh_config {\n\tu16 dot11MeshRetryTimeout;\n\tu16 dot11MeshConfirmTimeout;\n\tu16 dot11MeshHoldingTimeout;\n\tu16 dot11MeshMaxPeerLinks;\n\tu8 dot11MeshMaxRetries;\n\tu8 dot11MeshTTL;\n\tu8 element_ttl;\n\tbool auto_open_plinks;\n\tu32 dot11MeshNbrOffsetMaxNeighbor;\n\tu8 dot11MeshHWMPmaxPREQretries;\n\tu32 path_refresh_time;\n\tu16 min_discovery_timeout;\n\tu32 dot11MeshHWMPactivePathTimeout;\n\tu16 dot11MeshHWMPpreqMinInterval;\n\tu16 dot11MeshHWMPperrMinInterval;\n\tu16 dot11MeshHWMPnetDiameterTraversalTime;\n\tu8 dot11MeshHWMPRootMode;\n\tbool dot11MeshConnectedToMeshGate;\n\tbool dot11MeshConnectedToAuthServer;\n\tu16 dot11MeshHWMPRannInterval;\n\tbool dot11MeshGateAnnouncementProtocol;\n\tbool dot11MeshForwarding;\n\ts32 rssi_threshold;\n\tu16 ht_opmode;\n\tu32 dot11MeshHWMPactivePathToRootTimeout;\n\tu16 dot11MeshHWMProotInterval;\n\tu16 dot11MeshHWMPconfirmationInterval;\n\tenum nl80211_mesh_power_mode power_mode;\n\tu16 dot11MeshAwakeWindowDuration;\n\tu32 plink_timeout;\n\tbool dot11MeshNolearn;\n};\n\n/**\n * struct mesh_setup - 802.11s mesh setup configuration\n * @chandef: defines the channel to use\n * @mesh_id: the mesh ID\n * @mesh_id_len: length of the mesh ID, at least 1 and at most 32 bytes\n * @sync_method: which synchronization method to use\n * @path_sel_proto: which path selection protocol to use\n * @path_metric: which metric to use\n * @auth_id: which authentication method this mesh is using\n * @ie: vendor information elements (optional)\n * @ie_len: length of vendor information elements\n * @is_authenticated: this mesh requires authentication\n * @is_secure: this mesh uses security\n * @user_mpm: userspace handles all MPM functions\n * @dtim_period: DTIM period to use\n * @beacon_interval: beacon interval to use\n * @mcast_rate: multicat rate for Mesh Node [6Mbps is the default for 802.11a]\n * @basic_rates: basic rates to use when creating the mesh\n * @beacon_rate: bitrate to be used for beacons\n * @userspace_handles_dfs: whether user space controls DFS operation, i.e.\n *\tchanges the channel when a radar is detected. This is required\n *\tto operate on DFS channels.\n * @control_port_over_nl80211: TRUE if userspace expects to exchange control\n *\tport frames over NL80211 instead of the network interface.\n *\n * These parameters are fixed when the mesh is created.\n */\nstruct mesh_setup {\n\tstruct cfg80211_chan_def chandef;\n\tconst u8 *mesh_id;\n\tu8 mesh_id_len;\n\tu8 sync_method;\n\tu8 path_sel_proto;\n\tu8 path_metric;\n\tu8 auth_id;\n\tconst u8 *ie;\n\tu8 ie_len;\n\tbool is_authenticated;\n\tbool is_secure;\n\tbool user_mpm;\n\tu8 dtim_period;\n\tu16 beacon_interval;\n\tint mcast_rate[NUM_NL80211_BANDS];\n\tu32 basic_rates;\n\tstruct cfg80211_bitrate_mask beacon_rate;\n\tbool userspace_handles_dfs;\n\tbool control_port_over_nl80211;\n};\n\n/**\n * struct ocb_setup - 802.11p OCB mode setup configuration\n * @chandef: defines the channel to use\n *\n * These parameters are fixed when connecting to the network\n */\nstruct ocb_setup {\n\tstruct cfg80211_chan_def chandef;\n};\n\n/**\n * struct ieee80211_txq_params - TX queue parameters\n * @ac: AC identifier\n * @txop: Maximum burst time in units of 32 usecs, 0 meaning disabled\n * @cwmin: Minimum contention window [a value of the form 2^n-1 in the range\n *\t1..32767]\n * @cwmax: Maximum contention window [a value of the form 2^n-1 in the range\n *\t1..32767]\n * @aifs: Arbitration interframe space [0..255]\n */\nstruct ieee80211_txq_params {\n\tenum nl80211_ac ac;\n\tu16 txop;\n\tu16 cwmin;\n\tu16 cwmax;\n\tu8 aifs;\n};\n\n/**\n * DOC: Scanning and BSS list handling\n *\n * The scanning process itself is fairly simple, but cfg80211 offers quite\n * a bit of helper functionality. To start a scan, the scan operation will\n * be invoked with a scan definition. This scan definition contains the\n * channels to scan, and the SSIDs to send probe requests for (including the\n * wildcard, if desired). A passive scan is indicated by having no SSIDs to\n * probe. Additionally, a scan request may contain extra information elements\n * that should be added to the probe request. The IEs are guaranteed to be\n * well-formed, and will not exceed the maximum length the driver advertised\n * in the wiphy structure.\n *\n * When scanning finds a BSS, cfg80211 needs to be notified of that, because\n * it is responsible for maintaining the BSS list; the driver should not\n * maintain a list itself. For this notification, various functions exist.\n *\n * Since drivers do not maintain a BSS list, there are also a number of\n * functions to search for a BSS and obtain information about it from the\n * BSS structure cfg80211 maintains. The BSS list is also made available\n * to userspace.\n */\n\n/**\n * struct cfg80211_ssid - SSID description\n * @ssid: the SSID\n * @ssid_len: length of the ssid\n */\nstruct cfg80211_ssid {\n\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\tu8 ssid_len;\n};\n\n/**\n * struct cfg80211_scan_info - information about completed scan\n * @scan_start_tsf: scan start time in terms of the TSF of the BSS that the\n *\twireless device that requested the scan is connected to. If this\n *\tinformation is not available, this field is left zero.\n * @tsf_bssid: the BSSID according to which %scan_start_tsf is set.\n * @aborted: set to true if the scan was aborted for any reason,\n *\tuserspace will be notified of that\n */\nstruct cfg80211_scan_info {\n\tu64 scan_start_tsf;\n\tu8 tsf_bssid[ETH_ALEN] __aligned(2);\n\tbool aborted;\n};\n\n/**\n * struct cfg80211_scan_6ghz_params - relevant for 6 GHz only\n *\n * @short_bssid: short ssid to scan for\n * @bssid: bssid to scan for\n * @channel_idx: idx of the channel in the channel array in the scan request\n *\t which the above info relvant to\n * @unsolicited_probe: the AP transmits unsolicited probe response every 20 TU\n * @short_ssid_valid: short_ssid is valid and can be used\n * @psc_no_listen: when set, and the channel is a PSC channel, no need to wait\n *       20 TUs before starting to send probe requests.\n */\nstruct cfg80211_scan_6ghz_params {\n\tu32 short_ssid;\n\tu32 channel_idx;\n\tu8 bssid[ETH_ALEN];\n\tbool unsolicited_probe;\n\tbool short_ssid_valid;\n\tbool psc_no_listen;\n};\n\n/**\n * struct cfg80211_scan_request - scan request description\n *\n * @ssids: SSIDs to scan for (active scan only)\n * @n_ssids: number of SSIDs\n * @channels: channels to scan on.\n * @n_channels: total number of channels to scan\n * @scan_width: channel width for scanning\n * @ie: optional information element(s) to add into Probe Request or %NULL\n * @ie_len: length of ie in octets\n * @duration: how long to listen on each channel, in TUs. If\n *\t%duration_mandatory is not set, this is the maximum dwell time and\n *\tthe actual dwell time may be shorter.\n * @duration_mandatory: if set, the scan duration must be as specified by the\n *\t%duration field.\n * @flags: bit field of flags controlling operation\n * @rates: bitmap of rates to advertise for each band\n * @wiphy: the wiphy this was for\n * @scan_start: time (in jiffies) when the scan started\n * @wdev: the wireless device to scan for\n * @info: (internal) information about completed scan\n * @notified: (internal) scan request was notified as done or aborted\n * @no_cck: used to send probe requests at non CCK rate in 2GHz band\n * @mac_addr: MAC address used with randomisation\n * @mac_addr_mask: MAC address mask used with randomisation, bits that\n *\tare 0 in the mask should be randomised, bits that are 1 should\n *\tbe taken from the @mac_addr\n * @scan_6ghz: relevant for split scan request only,\n *\ttrue if this is the second scan request\n * @n_6ghz_params: number of 6 GHz params\n * @scan_6ghz_params: 6 GHz params\n * @bssid: BSSID to scan for (most commonly, the wildcard BSSID)\n */\nstruct cfg80211_scan_request {\n\tstruct cfg80211_ssid *ssids;\n\tint n_ssids;\n\tu32 n_channels;\n\tenum nl80211_bss_scan_width scan_width;\n\tconst u8 *ie;\n\tsize_t ie_len;\n\tu16 duration;\n\tbool duration_mandatory;\n\tu32 flags;\n\n\tu32 rates[NUM_NL80211_BANDS];\n\n\tstruct wireless_dev *wdev;\n\n\tu8 mac_addr[ETH_ALEN] __aligned(2);\n\tu8 mac_addr_mask[ETH_ALEN] __aligned(2);\n\tu8 bssid[ETH_ALEN] __aligned(2);\n\n\t/* internal */\n\tstruct wiphy *wiphy;\n\tunsigned long scan_start;\n\tstruct cfg80211_scan_info info;\n\tbool notified;\n\tbool no_cck;\n\tbool scan_6ghz;\n\tu32 n_6ghz_params;\n\tstruct cfg80211_scan_6ghz_params *scan_6ghz_params;\n\n\t/* keep last */\n\tstruct ieee80211_channel *channels[];\n};\n\nstatic inline void get_random_mask_addr(u8 *buf, const u8 *addr, const u8 *mask)\n{\n\tint i;\n\n\tget_random_bytes(buf, ETH_ALEN);\n\tfor (i = 0; i < ETH_ALEN; i++) {\n\t\tbuf[i] &= ~mask[i];\n\t\tbuf[i] |= addr[i] & mask[i];\n\t}\n}\n\n/**\n * struct cfg80211_match_set - sets of attributes to match\n *\n * @ssid: SSID to be matched; may be zero-length in case of BSSID match\n *\tor no match (RSSI only)\n * @bssid: BSSID to be matched; may be all-zero BSSID in case of SSID match\n *\tor no match (RSSI only)\n * @rssi_thold: don't report scan results below this threshold (in s32 dBm)\n * @per_band_rssi_thold: Minimum rssi threshold for each band to be applied\n *\tfor filtering out scan results received. Drivers advertize this support\n *\tof band specific rssi based filtering through the feature capability\n *\t%NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD. These band\n *\tspecific rssi thresholds take precedence over rssi_thold, if specified.\n *\tIf not specified for any band, it will be assigned with rssi_thold of\n *\tcorresponding matchset.\n */\nstruct cfg80211_match_set {\n\tstruct cfg80211_ssid ssid;\n\tu8 bssid[ETH_ALEN];\n\ts32 rssi_thold;\n\ts32 per_band_rssi_thold[NUM_NL80211_BANDS];\n};\n\n/**\n * struct cfg80211_sched_scan_plan - scan plan for scheduled scan\n *\n * @interval: interval between scheduled scan iterations. In seconds.\n * @iterations: number of scan iterations in this scan plan. Zero means\n *\tinfinite loop.\n *\tThe last scan plan will always have this parameter set to zero,\n *\tall other scan plans will have a finite number of iterations.\n */\nstruct cfg80211_sched_scan_plan {\n\tu32 interval;\n\tu32 iterations;\n};\n\n/**\n * struct cfg80211_bss_select_adjust - BSS selection with RSSI adjustment.\n *\n * @band: band of BSS which should match for RSSI level adjustment.\n * @delta: value of RSSI level adjustment.\n */\nstruct cfg80211_bss_select_adjust {\n\tenum nl80211_band band;\n\ts8 delta;\n};\n\n/**\n * struct cfg80211_sched_scan_request - scheduled scan request description\n *\n * @reqid: identifies this request.\n * @ssids: SSIDs to scan for (passed in the probe_reqs in active scans)\n * @n_ssids: number of SSIDs\n * @n_channels: total number of channels to scan\n * @scan_width: channel width for scanning\n * @ie: optional information element(s) to add into Probe Request or %NULL\n * @ie_len: length of ie in octets\n * @flags: bit field of flags controlling operation\n * @match_sets: sets of parameters to be matched for a scan result\n *\tentry to be considered valid and to be passed to the host\n *\t(others are filtered out).\n *\tIf ommited, all results are passed.\n * @n_match_sets: number of match sets\n * @report_results: indicates that results were reported for this request\n * @wiphy: the wiphy this was for\n * @dev: the interface\n * @scan_start: start time of the scheduled scan\n * @channels: channels to scan\n * @min_rssi_thold: for drivers only supporting a single threshold, this\n *\tcontains the minimum over all matchsets\n * @mac_addr: MAC address used with randomisation\n * @mac_addr_mask: MAC address mask used with randomisation, bits that\n *\tare 0 in the mask should be randomised, bits that are 1 should\n *\tbe taken from the @mac_addr\n * @scan_plans: scan plans to be executed in this scheduled scan. Lowest\n *\tindex must be executed first.\n * @n_scan_plans: number of scan plans, at least 1.\n * @rcu_head: RCU callback used to free the struct\n * @owner_nlportid: netlink portid of owner (if this should is a request\n *\towned by a particular socket)\n * @nl_owner_dead: netlink owner socket was closed - this request be freed\n * @list: for keeping list of requests.\n * @delay: delay in seconds to use before starting the first scan\n *\tcycle.  The driver may ignore this parameter and start\n *\timmediately (or at any other time), if this feature is not\n *\tsupported.\n * @relative_rssi_set: Indicates whether @relative_rssi is set or not.\n * @relative_rssi: Relative RSSI threshold in dB to restrict scan result\n *\treporting in connected state to cases where a matching BSS is determined\n *\tto have better or slightly worse RSSI than the current connected BSS.\n *\tThe relative RSSI threshold values are ignored in disconnected state.\n * @rssi_adjust: delta dB of RSSI preference to be given to the BSSs that belong\n *\tto the specified band while deciding whether a better BSS is reported\n *\tusing @relative_rssi. If delta is a negative number, the BSSs that\n *\tbelong to the specified band will be penalized by delta dB in relative\n *\tcomparisions.\n */\nstruct cfg80211_sched_scan_request {\n\tu64 reqid;\n\tstruct cfg80211_ssid *ssids;\n\tint n_ssids;\n\tu32 n_channels;\n\tenum nl80211_bss_scan_width scan_width;\n\tconst u8 *ie;\n\tsize_t ie_len;\n\tu32 flags;\n\tstruct cfg80211_match_set *match_sets;\n\tint n_match_sets;\n\ts32 min_rssi_thold;\n\tu32 delay;\n\tstruct cfg80211_sched_scan_plan *scan_plans;\n\tint n_scan_plans;\n\n\tu8 mac_addr[ETH_ALEN] __aligned(2);\n\tu8 mac_addr_mask[ETH_ALEN] __aligned(2);\n\n\tbool relative_rssi_set;\n\ts8 relative_rssi;\n\tstruct cfg80211_bss_select_adjust rssi_adjust;\n\n\t/* internal */\n\tstruct wiphy *wiphy;\n\tstruct net_device *dev;\n\tunsigned long scan_start;\n\tbool report_results;\n\tstruct rcu_head rcu_head;\n\tu32 owner_nlportid;\n\tbool nl_owner_dead;\n\tstruct list_head list;\n\n\t/* keep last */\n\tstruct ieee80211_channel *channels[];\n};\n\n/**\n * enum cfg80211_signal_type - signal type\n *\n * @CFG80211_SIGNAL_TYPE_NONE: no signal strength information available\n * @CFG80211_SIGNAL_TYPE_MBM: signal strength in mBm (100*dBm)\n * @CFG80211_SIGNAL_TYPE_UNSPEC: signal strength, increasing from 0 through 100\n */\nenum cfg80211_signal_type {\n\tCFG80211_SIGNAL_TYPE_NONE,\n\tCFG80211_SIGNAL_TYPE_MBM,\n\tCFG80211_SIGNAL_TYPE_UNSPEC,\n};\n\n/**\n * struct cfg80211_inform_bss - BSS inform data\n * @chan: channel the frame was received on\n * @scan_width: scan width that was used\n * @signal: signal strength value, according to the wiphy's\n *\tsignal type\n * @boottime_ns: timestamp (CLOCK_BOOTTIME) when the information was\n *\treceived; should match the time when the frame was actually\n *\treceived by the device (not just by the host, in case it was\n *\tbuffered on the device) and be accurate to about 10ms.\n *\tIf the frame isn't buffered, just passing the return value of\n *\tktime_get_boottime_ns() is likely appropriate.\n * @parent_tsf: the time at the start of reception of the first octet of the\n *\ttimestamp field of the frame. The time is the TSF of the BSS specified\n *\tby %parent_bssid.\n * @parent_bssid: the BSS according to which %parent_tsf is set. This is set to\n *\tthe BSS that requested the scan in which the beacon/probe was received.\n * @chains: bitmask for filled values in @chain_signal.\n * @chain_signal: per-chain signal strength of last received BSS in dBm.\n */\nstruct cfg80211_inform_bss {\n\tstruct ieee80211_channel *chan;\n\tenum nl80211_bss_scan_width scan_width;\n\ts32 signal;\n\tu64 boottime_ns;\n\tu64 parent_tsf;\n\tu8 parent_bssid[ETH_ALEN] __aligned(2);\n\tu8 chains;\n\ts8 chain_signal[IEEE80211_MAX_CHAINS];\n};\n\n/**\n * struct cfg80211_bss_ies - BSS entry IE data\n * @tsf: TSF contained in the frame that carried these IEs\n * @rcu_head: internal use, for freeing\n * @len: length of the IEs\n * @from_beacon: these IEs are known to come from a beacon\n * @data: IE data\n */\nstruct cfg80211_bss_ies {\n\tu64 tsf;\n\tstruct rcu_head rcu_head;\n\tint len;\n\tbool from_beacon;\n\tu8 data[];\n};\n\n/**\n * struct cfg80211_bss - BSS description\n *\n * This structure describes a BSS (which may also be a mesh network)\n * for use in scan results and similar.\n *\n * @channel: channel this BSS is on\n * @scan_width: width of the control channel\n * @bssid: BSSID of the BSS\n * @beacon_interval: the beacon interval as from the frame\n * @capability: the capability field in host byte order\n * @ies: the information elements (Note that there is no guarantee that these\n *\tare well-formed!); this is a pointer to either the beacon_ies or\n *\tproberesp_ies depending on whether Probe Response frame has been\n *\treceived. It is always non-%NULL.\n * @beacon_ies: the information elements from the last Beacon frame\n *\t(implementation note: if @hidden_beacon_bss is set this struct doesn't\n *\town the beacon_ies, but they're just pointers to the ones from the\n *\t@hidden_beacon_bss struct)\n * @proberesp_ies: the information elements from the last Probe Response frame\n * @hidden_beacon_bss: in case this BSS struct represents a probe response from\n *\ta BSS that hides the SSID in its beacon, this points to the BSS struct\n *\tthat holds the beacon data. @beacon_ies is still valid, of course, and\n *\tpoints to the same data as hidden_beacon_bss->beacon_ies in that case.\n * @transmitted_bss: pointer to the transmitted BSS, if this is a\n *\tnon-transmitted one (multi-BSSID support)\n * @nontrans_list: list of non-transmitted BSS, if this is a transmitted one\n *\t(multi-BSSID support)\n * @signal: signal strength value (type depends on the wiphy's signal_type)\n * @chains: bitmask for filled values in @chain_signal.\n * @chain_signal: per-chain signal strength of last received BSS in dBm.\n * @bssid_index: index in the multiple BSS set\n * @max_bssid_indicator: max number of members in the BSS set\n * @priv: private area for driver use, has at least wiphy->bss_priv_size bytes\n */\nstruct cfg80211_bss {\n\tstruct ieee80211_channel *channel;\n\tenum nl80211_bss_scan_width scan_width;\n\n\tconst struct cfg80211_bss_ies __rcu *ies;\n\tconst struct cfg80211_bss_ies __rcu *beacon_ies;\n\tconst struct cfg80211_bss_ies __rcu *proberesp_ies;\n\n\tstruct cfg80211_bss *hidden_beacon_bss;\n\tstruct cfg80211_bss *transmitted_bss;\n\tstruct list_head nontrans_list;\n\n\ts32 signal;\n\n\tu16 beacon_interval;\n\tu16 capability;\n\n\tu8 bssid[ETH_ALEN];\n\tu8 chains;\n\ts8 chain_signal[IEEE80211_MAX_CHAINS];\n\n\tu8 bssid_index;\n\tu8 max_bssid_indicator;\n\n\tu8 priv[] __aligned(sizeof(void *));\n};\n\n/**\n * ieee80211_bss_get_elem - find element with given ID\n * @bss: the bss to search\n * @id: the element ID\n *\n * Note that the return value is an RCU-protected pointer, so\n * rcu_read_lock() must be held when calling this function.\n * Return: %NULL if not found.\n */\nconst struct element *ieee80211_bss_get_elem(struct cfg80211_bss *bss, u8 id);\n\n/**\n * ieee80211_bss_get_ie - find IE with given ID\n * @bss: the bss to search\n * @id: the element ID\n *\n * Note that the return value is an RCU-protected pointer, so\n * rcu_read_lock() must be held when calling this function.\n * Return: %NULL if not found.\n */\nstatic inline const u8 *ieee80211_bss_get_ie(struct cfg80211_bss *bss, u8 id)\n{\n\treturn (void *)ieee80211_bss_get_elem(bss, id);\n}\n\n\n/**\n * struct cfg80211_auth_request - Authentication request data\n *\n * This structure provides information needed to complete IEEE 802.11\n * authentication.\n *\n * @bss: The BSS to authenticate with, the callee must obtain a reference\n *\tto it if it needs to keep it.\n * @auth_type: Authentication type (algorithm)\n * @ie: Extra IEs to add to Authentication frame or %NULL\n * @ie_len: Length of ie buffer in octets\n * @key_len: length of WEP key for shared key authentication\n * @key_idx: index of WEP key for shared key authentication\n * @key: WEP key for shared key authentication\n * @auth_data: Fields and elements in Authentication frames. This contains\n *\tthe authentication frame body (non-IE and IE data), excluding the\n *\tAuthentication algorithm number, i.e., starting at the Authentication\n *\ttransaction sequence number field.\n * @auth_data_len: Length of auth_data buffer in octets\n */\nstruct cfg80211_auth_request {\n\tstruct cfg80211_bss *bss;\n\tconst u8 *ie;\n\tsize_t ie_len;\n\tenum nl80211_auth_type auth_type;\n\tconst u8 *key;\n\tu8 key_len, key_idx;\n\tconst u8 *auth_data;\n\tsize_t auth_data_len;\n};\n\n/**\n * enum cfg80211_assoc_req_flags - Over-ride default behaviour in association.\n *\n * @ASSOC_REQ_DISABLE_HT:  Disable HT (802.11n)\n * @ASSOC_REQ_DISABLE_VHT:  Disable VHT\n * @ASSOC_REQ_USE_RRM: Declare RRM capability in this association\n * @CONNECT_REQ_EXTERNAL_AUTH_SUPPORT: User space indicates external\n *\tauthentication capability. Drivers can offload authentication to\n *\tuserspace if this flag is set. Only applicable for cfg80211_connect()\n *\trequest (connect callback).\n */\nenum cfg80211_assoc_req_flags {\n\tASSOC_REQ_DISABLE_HT\t\t\t= BIT(0),\n\tASSOC_REQ_DISABLE_VHT\t\t\t= BIT(1),\n\tASSOC_REQ_USE_RRM\t\t\t= BIT(2),\n\tCONNECT_REQ_EXTERNAL_AUTH_SUPPORT\t= BIT(3),\n};\n\n/**\n * struct cfg80211_assoc_request - (Re)Association request data\n *\n * This structure provides information needed to complete IEEE 802.11\n * (re)association.\n * @bss: The BSS to associate with. If the call is successful the driver is\n *\tgiven a reference that it must give back to cfg80211_send_rx_assoc()\n *\tor to cfg80211_assoc_timeout(). To ensure proper refcounting, new\n *\tassociation requests while already associating must be rejected.\n * @ie: Extra IEs to add to (Re)Association Request frame or %NULL\n * @ie_len: Length of ie buffer in octets\n * @use_mfp: Use management frame protection (IEEE 802.11w) in this association\n * @crypto: crypto settings\n * @prev_bssid: previous BSSID, if not %NULL use reassociate frame. This is used\n *\tto indicate a request to reassociate within the ESS instead of a request\n *\tdo the initial association with the ESS. When included, this is set to\n *\tthe BSSID of the current association, i.e., to the value that is\n *\tincluded in the Current AP address field of the Reassociation Request\n *\tframe.\n * @flags:  See &enum cfg80211_assoc_req_flags\n * @ht_capa:  HT Capabilities over-rides.  Values set in ht_capa_mask\n *\twill be used in ht_capa.  Un-supported values will be ignored.\n * @ht_capa_mask:  The bits of ht_capa which are to be used.\n * @vht_capa: VHT capability override\n * @vht_capa_mask: VHT capability mask indicating which fields to use\n * @fils_kek: FILS KEK for protecting (Re)Association Request/Response frame or\n *\t%NULL if FILS is not used.\n * @fils_kek_len: Length of fils_kek in octets\n * @fils_nonces: FILS nonces (part of AAD) for protecting (Re)Association\n *\tRequest/Response frame or %NULL if FILS is not used. This field starts\n *\twith 16 octets of STA Nonce followed by 16 octets of AP Nonce.\n * @s1g_capa: S1G capability override\n * @s1g_capa_mask: S1G capability override mask\n */\nstruct cfg80211_assoc_request {\n\tstruct cfg80211_bss *bss;\n\tconst u8 *ie, *prev_bssid;\n\tsize_t ie_len;\n\tstruct cfg80211_crypto_settings crypto;\n\tbool use_mfp;\n\tu32 flags;\n\tstruct ieee80211_ht_cap ht_capa;\n\tstruct ieee80211_ht_cap ht_capa_mask;\n\tstruct ieee80211_vht_cap vht_capa, vht_capa_mask;\n\tconst u8 *fils_kek;\n\tsize_t fils_kek_len;\n\tconst u8 *fils_nonces;\n\tstruct ieee80211_s1g_cap s1g_capa, s1g_capa_mask;\n};\n\n/**\n * struct cfg80211_deauth_request - Deauthentication request data\n *\n * This structure provides information needed to complete IEEE 802.11\n * deauthentication.\n *\n * @bssid: the BSSID of the BSS to deauthenticate from\n * @ie: Extra IEs to add to Deauthentication frame or %NULL\n * @ie_len: Length of ie buffer in octets\n * @reason_code: The reason code for the deauthentication\n * @local_state_change: if set, change local state only and\n *\tdo not set a deauth frame\n */\nstruct cfg80211_deauth_request {\n\tconst u8 *bssid;\n\tconst u8 *ie;\n\tsize_t ie_len;\n\tu16 reason_code;\n\tbool local_state_change;\n};\n\n/**\n * struct cfg80211_disassoc_request - Disassociation request data\n *\n * This structure provides information needed to complete IEEE 802.11\n * disassociation.\n *\n * @bss: the BSS to disassociate from\n * @ie: Extra IEs to add to Disassociation frame or %NULL\n * @ie_len: Length of ie buffer in octets\n * @reason_code: The reason code for the disassociation\n * @local_state_change: This is a request for a local state only, i.e., no\n *\tDisassociation frame is to be transmitted.\n */\nstruct cfg80211_disassoc_request {\n\tstruct cfg80211_bss *bss;\n\tconst u8 *ie;\n\tsize_t ie_len;\n\tu16 reason_code;\n\tbool local_state_change;\n};\n\n/**\n * struct cfg80211_ibss_params - IBSS parameters\n *\n * This structure defines the IBSS parameters for the join_ibss()\n * method.\n *\n * @ssid: The SSID, will always be non-null.\n * @ssid_len: The length of the SSID, will always be non-zero.\n * @bssid: Fixed BSSID requested, maybe be %NULL, if set do not\n *\tsearch for IBSSs with a different BSSID.\n * @chandef: defines the channel to use if no other IBSS to join can be found\n * @channel_fixed: The channel should be fixed -- do not search for\n *\tIBSSs to join on other channels.\n * @ie: information element(s) to include in the beacon\n * @ie_len: length of that\n * @beacon_interval: beacon interval to use\n * @privacy: this is a protected network, keys will be configured\n *\tafter joining\n * @control_port: whether user space controls IEEE 802.1X port, i.e.,\n *\tsets/clears %NL80211_STA_FLAG_AUTHORIZED. If true, the driver is\n *\trequired to assume that the port is unauthorized until authorized by\n *\tuser space. Otherwise, port is marked authorized by default.\n * @control_port_over_nl80211: TRUE if userspace expects to exchange control\n *\tport frames over NL80211 instead of the network interface.\n * @userspace_handles_dfs: whether user space controls DFS operation, i.e.\n *\tchanges the channel when a radar is detected. This is required\n *\tto operate on DFS channels.\n * @basic_rates: bitmap of basic rates to use when creating the IBSS\n * @mcast_rate: per-band multicast rate index + 1 (0: disabled)\n * @ht_capa:  HT Capabilities over-rides.  Values set in ht_capa_mask\n *\twill be used in ht_capa.  Un-supported values will be ignored.\n * @ht_capa_mask:  The bits of ht_capa which are to be used.\n * @wep_keys: static WEP keys, if not NULL points to an array of\n *\tCFG80211_MAX_WEP_KEYS WEP keys\n * @wep_tx_key: key index (0..3) of the default TX static WEP key\n */\nstruct cfg80211_ibss_params {\n\tconst u8 *ssid;\n\tconst u8 *bssid;\n\tstruct cfg80211_chan_def chandef;\n\tconst u8 *ie;\n\tu8 ssid_len, ie_len;\n\tu16 beacon_interval;\n\tu32 basic_rates;\n\tbool channel_fixed;\n\tbool privacy;\n\tbool control_port;\n\tbool control_port_over_nl80211;\n\tbool userspace_handles_dfs;\n\tint mcast_rate[NUM_NL80211_BANDS];\n\tstruct ieee80211_ht_cap ht_capa;\n\tstruct ieee80211_ht_cap ht_capa_mask;\n\tstruct key_params *wep_keys;\n\tint wep_tx_key;\n};\n\n/**\n * struct cfg80211_bss_selection - connection parameters for BSS selection.\n *\n * @behaviour: requested BSS selection behaviour.\n * @param: parameters for requestion behaviour.\n * @band_pref: preferred band for %NL80211_BSS_SELECT_ATTR_BAND_PREF.\n * @adjust: parameters for %NL80211_BSS_SELECT_ATTR_RSSI_ADJUST.\n */\nstruct cfg80211_bss_selection {\n\tenum nl80211_bss_select_attr behaviour;\n\tunion {\n\t\tenum nl80211_band band_pref;\n\t\tstruct cfg80211_bss_select_adjust adjust;\n\t} param;\n};\n\n/**\n * struct cfg80211_connect_params - Connection parameters\n *\n * This structure provides information needed to complete IEEE 802.11\n * authentication and association.\n *\n * @channel: The channel to use or %NULL if not specified (auto-select based\n *\ton scan results)\n * @channel_hint: The channel of the recommended BSS for initial connection or\n *\t%NULL if not specified\n * @bssid: The AP BSSID or %NULL if not specified (auto-select based on scan\n *\tresults)\n * @bssid_hint: The recommended AP BSSID for initial connection to the BSS or\n *\t%NULL if not specified. Unlike the @bssid parameter, the driver is\n *\tallowed to ignore this @bssid_hint if it has knowledge of a better BSS\n *\tto use.\n * @ssid: SSID\n * @ssid_len: Length of ssid in octets\n * @auth_type: Authentication type (algorithm)\n * @ie: IEs for association request\n * @ie_len: Length of assoc_ie in octets\n * @privacy: indicates whether privacy-enabled APs should be used\n * @mfp: indicate whether management frame protection is used\n * @crypto: crypto settings\n * @key_len: length of WEP key for shared key authentication\n * @key_idx: index of WEP key for shared key authentication\n * @key: WEP key for shared key authentication\n * @flags:  See &enum cfg80211_assoc_req_flags\n * @bg_scan_period:  Background scan period in seconds\n *\tor -1 to indicate that default value is to be used.\n * @ht_capa:  HT Capabilities over-rides.  Values set in ht_capa_mask\n *\twill be used in ht_capa.  Un-supported values will be ignored.\n * @ht_capa_mask:  The bits of ht_capa which are to be used.\n * @vht_capa:  VHT Capability overrides\n * @vht_capa_mask: The bits of vht_capa which are to be used.\n * @pbss: if set, connect to a PCP instead of AP. Valid for DMG\n *\tnetworks.\n * @bss_select: criteria to be used for BSS selection.\n * @prev_bssid: previous BSSID, if not %NULL use reassociate frame. This is used\n *\tto indicate a request to reassociate within the ESS instead of a request\n *\tdo the initial association with the ESS. When included, this is set to\n *\tthe BSSID of the current association, i.e., to the value that is\n *\tincluded in the Current AP address field of the Reassociation Request\n *\tframe.\n * @fils_erp_username: EAP re-authentication protocol (ERP) username part of the\n *\tNAI or %NULL if not specified. This is used to construct FILS wrapped\n *\tdata IE.\n * @fils_erp_username_len: Length of @fils_erp_username in octets.\n * @fils_erp_realm: EAP re-authentication protocol (ERP) realm part of NAI or\n *\t%NULL if not specified. This specifies the domain name of ER server and\n *\tis used to construct FILS wrapped data IE.\n * @fils_erp_realm_len: Length of @fils_erp_realm in octets.\n * @fils_erp_next_seq_num: The next sequence number to use in the FILS ERP\n *\tmessages. This is also used to construct FILS wrapped data IE.\n * @fils_erp_rrk: ERP re-authentication Root Key (rRK) used to derive additional\n *\tkeys in FILS or %NULL if not specified.\n * @fils_erp_rrk_len: Length of @fils_erp_rrk in octets.\n * @want_1x: indicates user-space supports and wants to use 802.1X driver\n *\toffload of 4-way handshake.\n * @edmg: define the EDMG channels.\n *\tThis may specify multiple channels and bonding options for the driver\n *\tto choose from, based on BSS configuration.\n */\nstruct cfg80211_connect_params {\n\tstruct ieee80211_channel *channel;\n\tstruct ieee80211_channel *channel_hint;\n\tconst u8 *bssid;\n\tconst u8 *bssid_hint;\n\tconst u8 *ssid;\n\tsize_t ssid_len;\n\tenum nl80211_auth_type auth_type;\n\tconst u8 *ie;\n\tsize_t ie_len;\n\tbool privacy;\n\tenum nl80211_mfp mfp;\n\tstruct cfg80211_crypto_settings crypto;\n\tconst u8 *key;\n\tu8 key_len, key_idx;\n\tu32 flags;\n\tint bg_scan_period;\n\tstruct ieee80211_ht_cap ht_capa;\n\tstruct ieee80211_ht_cap ht_capa_mask;\n\tstruct ieee80211_vht_cap vht_capa;\n\tstruct ieee80211_vht_cap vht_capa_mask;\n\tbool pbss;\n\tstruct cfg80211_bss_selection bss_select;\n\tconst u8 *prev_bssid;\n\tconst u8 *fils_erp_username;\n\tsize_t fils_erp_username_len;\n\tconst u8 *fils_erp_realm;\n\tsize_t fils_erp_realm_len;\n\tu16 fils_erp_next_seq_num;\n\tconst u8 *fils_erp_rrk;\n\tsize_t fils_erp_rrk_len;\n\tbool want_1x;\n\tstruct ieee80211_edmg edmg;\n};\n\n/**\n * enum cfg80211_connect_params_changed - Connection parameters being updated\n *\n * This enum provides information of all connect parameters that\n * have to be updated as part of update_connect_params() call.\n *\n * @UPDATE_ASSOC_IES: Indicates whether association request IEs are updated\n * @UPDATE_FILS_ERP_INFO: Indicates that FILS connection parameters (realm,\n *\tusername, erp sequence number and rrk) are updated\n * @UPDATE_AUTH_TYPE: Indicates that authentication type is updated\n */\nenum cfg80211_connect_params_changed {\n\tUPDATE_ASSOC_IES\t\t= BIT(0),\n\tUPDATE_FILS_ERP_INFO\t\t= BIT(1),\n\tUPDATE_AUTH_TYPE\t\t= BIT(2),\n};\n\n/**\n * enum wiphy_params_flags - set_wiphy_params bitfield values\n * @WIPHY_PARAM_RETRY_SHORT: wiphy->retry_short has changed\n * @WIPHY_PARAM_RETRY_LONG: wiphy->retry_long has changed\n * @WIPHY_PARAM_FRAG_THRESHOLD: wiphy->frag_threshold has changed\n * @WIPHY_PARAM_RTS_THRESHOLD: wiphy->rts_threshold has changed\n * @WIPHY_PARAM_COVERAGE_CLASS: coverage class changed\n * @WIPHY_PARAM_DYN_ACK: dynack has been enabled\n * @WIPHY_PARAM_TXQ_LIMIT: TXQ packet limit has been changed\n * @WIPHY_PARAM_TXQ_MEMORY_LIMIT: TXQ memory limit has been changed\n * @WIPHY_PARAM_TXQ_QUANTUM: TXQ scheduler quantum\n */\nenum wiphy_params_flags {\n\tWIPHY_PARAM_RETRY_SHORT\t\t= 1 << 0,\n\tWIPHY_PARAM_RETRY_LONG\t\t= 1 << 1,\n\tWIPHY_PARAM_FRAG_THRESHOLD\t= 1 << 2,\n\tWIPHY_PARAM_RTS_THRESHOLD\t= 1 << 3,\n\tWIPHY_PARAM_COVERAGE_CLASS\t= 1 << 4,\n\tWIPHY_PARAM_DYN_ACK\t\t= 1 << 5,\n\tWIPHY_PARAM_TXQ_LIMIT\t\t= 1 << 6,\n\tWIPHY_PARAM_TXQ_MEMORY_LIMIT\t= 1 << 7,\n\tWIPHY_PARAM_TXQ_QUANTUM\t\t= 1 << 8,\n};\n\n#define IEEE80211_DEFAULT_AIRTIME_WEIGHT\t256\n\n/* The per TXQ device queue limit in airtime */\n#define IEEE80211_DEFAULT_AQL_TXQ_LIMIT_L\t5000\n#define IEEE80211_DEFAULT_AQL_TXQ_LIMIT_H\t12000\n\n/* The per interface airtime threshold to switch to lower queue limit */\n#define IEEE80211_AQL_THRESHOLD\t\t\t24000\n\n/**\n * struct cfg80211_pmksa - PMK Security Association\n *\n * This structure is passed to the set/del_pmksa() method for PMKSA\n * caching.\n *\n * @bssid: The AP's BSSID (may be %NULL).\n * @pmkid: The identifier to refer a PMKSA.\n * @pmk: The PMK for the PMKSA identified by @pmkid. This is used for key\n *\tderivation by a FILS STA. Otherwise, %NULL.\n * @pmk_len: Length of the @pmk. The length of @pmk can differ depending on\n *\tthe hash algorithm used to generate this.\n * @ssid: SSID to specify the ESS within which a PMKSA is valid when using FILS\n *\tcache identifier (may be %NULL).\n * @ssid_len: Length of the @ssid in octets.\n * @cache_id: 2-octet cache identifier advertized by a FILS AP identifying the\n *\tscope of PMKSA. This is valid only if @ssid_len is non-zero (may be\n *\t%NULL).\n * @pmk_lifetime: Maximum lifetime for PMKSA in seconds\n *\t(dot11RSNAConfigPMKLifetime) or 0 if not specified.\n *\tThe configured PMKSA must not be used for PMKSA caching after\n *\texpiration and any keys derived from this PMK become invalid on\n *\texpiration, i.e., the current association must be dropped if the PMK\n *\tused for it expires.\n * @pmk_reauth_threshold: Threshold time for reauthentication (percentage of\n *\tPMK lifetime, dot11RSNAConfigPMKReauthThreshold) or 0 if not specified.\n *\tDrivers are expected to trigger a full authentication instead of using\n *\tthis PMKSA for caching when reassociating to a new BSS after this\n *\tthreshold to generate a new PMK before the current one expires.\n */\nstruct cfg80211_pmksa {\n\tconst u8 *bssid;\n\tconst u8 *pmkid;\n\tconst u8 *pmk;\n\tsize_t pmk_len;\n\tconst u8 *ssid;\n\tsize_t ssid_len;\n\tconst u8 *cache_id;\n\tu32 pmk_lifetime;\n\tu8 pmk_reauth_threshold;\n};\n\n/**\n * struct cfg80211_pkt_pattern - packet pattern\n * @mask: bitmask where to match pattern and where to ignore bytes,\n *\tone bit per byte, in same format as nl80211\n * @pattern: bytes to match where bitmask is 1\n * @pattern_len: length of pattern (in bytes)\n * @pkt_offset: packet offset (in bytes)\n *\n * Internal note: @mask and @pattern are allocated in one chunk of\n * memory, free @mask only!\n */\nstruct cfg80211_pkt_pattern {\n\tconst u8 *mask, *pattern;\n\tint pattern_len;\n\tint pkt_offset;\n};\n\n/**\n * struct cfg80211_wowlan_tcp - TCP connection parameters\n *\n * @sock: (internal) socket for source port allocation\n * @src: source IP address\n * @dst: destination IP address\n * @dst_mac: destination MAC address\n * @src_port: source port\n * @dst_port: destination port\n * @payload_len: data payload length\n * @payload: data payload buffer\n * @payload_seq: payload sequence stamping configuration\n * @data_interval: interval at which to send data packets\n * @wake_len: wakeup payload match length\n * @wake_data: wakeup payload match data\n * @wake_mask: wakeup payload match mask\n * @tokens_size: length of the tokens buffer\n * @payload_tok: payload token usage configuration\n */\nstruct cfg80211_wowlan_tcp {\n\tstruct socket *sock;\n\t__be32 src, dst;\n\tu16 src_port, dst_port;\n\tu8 dst_mac[ETH_ALEN];\n\tint payload_len;\n\tconst u8 *payload;\n\tstruct nl80211_wowlan_tcp_data_seq payload_seq;\n\tu32 data_interval;\n\tu32 wake_len;\n\tconst u8 *wake_data, *wake_mask;\n\tu32 tokens_size;\n\t/* must be last, variable member */\n\tstruct nl80211_wowlan_tcp_data_token payload_tok;\n};\n\n/**\n * struct cfg80211_wowlan - Wake on Wireless-LAN support info\n *\n * This structure defines the enabled WoWLAN triggers for the device.\n * @any: wake up on any activity -- special trigger if device continues\n *\toperating as normal during suspend\n * @disconnect: wake up if getting disconnected\n * @magic_pkt: wake up on receiving magic packet\n * @patterns: wake up on receiving packet matching a pattern\n * @n_patterns: number of patterns\n * @gtk_rekey_failure: wake up on GTK rekey failure\n * @eap_identity_req: wake up on EAP identity request packet\n * @four_way_handshake: wake up on 4-way handshake\n * @rfkill_release: wake up when rfkill is released\n * @tcp: TCP connection establishment/wakeup parameters, see nl80211.h.\n *\tNULL if not configured.\n * @nd_config: configuration for the scan to be used for net detect wake.\n */\nstruct cfg80211_wowlan {\n\tbool any, disconnect, magic_pkt, gtk_rekey_failure,\n\t     eap_identity_req, four_way_handshake,\n\t     rfkill_release;\n\tstruct cfg80211_pkt_pattern *patterns;\n\tstruct cfg80211_wowlan_tcp *tcp;\n\tint n_patterns;\n\tstruct cfg80211_sched_scan_request *nd_config;\n};\n\n/**\n * struct cfg80211_coalesce_rules - Coalesce rule parameters\n *\n * This structure defines coalesce rule for the device.\n * @delay: maximum coalescing delay in msecs.\n * @condition: condition for packet coalescence.\n *\tsee &enum nl80211_coalesce_condition.\n * @patterns: array of packet patterns\n * @n_patterns: number of patterns\n */\nstruct cfg80211_coalesce_rules {\n\tint delay;\n\tenum nl80211_coalesce_condition condition;\n\tstruct cfg80211_pkt_pattern *patterns;\n\tint n_patterns;\n};\n\n/**\n * struct cfg80211_coalesce - Packet coalescing settings\n *\n * This structure defines coalescing settings.\n * @rules: array of coalesce rules\n * @n_rules: number of rules\n */\nstruct cfg80211_coalesce {\n\tstruct cfg80211_coalesce_rules *rules;\n\tint n_rules;\n};\n\n/**\n * struct cfg80211_wowlan_nd_match - information about the match\n *\n * @ssid: SSID of the match that triggered the wake up\n * @n_channels: Number of channels where the match occurred.  This\n *\tvalue may be zero if the driver can't report the channels.\n * @channels: center frequencies of the channels where a match\n *\toccurred (in MHz)\n */\nstruct cfg80211_wowlan_nd_match {\n\tstruct cfg80211_ssid ssid;\n\tint n_channels;\n\tu32 channels[];\n};\n\n/**\n * struct cfg80211_wowlan_nd_info - net detect wake up information\n *\n * @n_matches: Number of match information instances provided in\n *\t@matches.  This value may be zero if the driver can't provide\n *\tmatch information.\n * @matches: Array of pointers to matches containing information about\n *\tthe matches that triggered the wake up.\n */\nstruct cfg80211_wowlan_nd_info {\n\tint n_matches;\n\tstruct cfg80211_wowlan_nd_match *matches[];\n};\n\n/**\n * struct cfg80211_wowlan_wakeup - wakeup report\n * @disconnect: woke up by getting disconnected\n * @magic_pkt: woke up by receiving magic packet\n * @gtk_rekey_failure: woke up by GTK rekey failure\n * @eap_identity_req: woke up by EAP identity request packet\n * @four_way_handshake: woke up by 4-way handshake\n * @rfkill_release: woke up by rfkill being released\n * @pattern_idx: pattern that caused wakeup, -1 if not due to pattern\n * @packet_present_len: copied wakeup packet data\n * @packet_len: original wakeup packet length\n * @packet: The packet causing the wakeup, if any.\n * @packet_80211:  For pattern match, magic packet and other data\n *\tframe triggers an 802.3 frame should be reported, for\n *\tdisconnect due to deauth 802.11 frame. This indicates which\n *\tit is.\n * @tcp_match: TCP wakeup packet received\n * @tcp_connlost: TCP connection lost or failed to establish\n * @tcp_nomoretokens: TCP data ran out of tokens\n * @net_detect: if not %NULL, woke up because of net detect\n */\nstruct cfg80211_wowlan_wakeup {\n\tbool disconnect, magic_pkt, gtk_rekey_failure,\n\t     eap_identity_req, four_way_handshake,\n\t     rfkill_release, packet_80211,\n\t     tcp_match, tcp_connlost, tcp_nomoretokens;\n\ts32 pattern_idx;\n\tu32 packet_present_len, packet_len;\n\tconst void *packet;\n\tstruct cfg80211_wowlan_nd_info *net_detect;\n};\n\n/**\n * struct cfg80211_gtk_rekey_data - rekey data\n * @kek: key encryption key (@kek_len bytes)\n * @kck: key confirmation key (@kck_len bytes)\n * @replay_ctr: replay counter (NL80211_REPLAY_CTR_LEN bytes)\n * @kek_len: length of kek\n * @kck_len length of kck\n * @akm: akm (oui, id)\n */\nstruct cfg80211_gtk_rekey_data {\n\tconst u8 *kek, *kck, *replay_ctr;\n\tu32 akm;\n\tu8 kek_len, kck_len;\n};\n\n/**\n * struct cfg80211_update_ft_ies_params - FT IE Information\n *\n * This structure provides information needed to update the fast transition IE\n *\n * @md: The Mobility Domain ID, 2 Octet value\n * @ie: Fast Transition IEs\n * @ie_len: Length of ft_ie in octets\n */\nstruct cfg80211_update_ft_ies_params {\n\tu16 md;\n\tconst u8 *ie;\n\tsize_t ie_len;\n};\n\n/**\n * struct cfg80211_mgmt_tx_params - mgmt tx parameters\n *\n * This structure provides information needed to transmit a mgmt frame\n *\n * @chan: channel to use\n * @offchan: indicates wether off channel operation is required\n * @wait: duration for ROC\n * @buf: buffer to transmit\n * @len: buffer length\n * @no_cck: don't use cck rates for this frame\n * @dont_wait_for_ack: tells the low level not to wait for an ack\n * @n_csa_offsets: length of csa_offsets array\n * @csa_offsets: array of all the csa offsets in the frame\n */\nstruct cfg80211_mgmt_tx_params {\n\tstruct ieee80211_channel *chan;\n\tbool offchan;\n\tunsigned int wait;\n\tconst u8 *buf;\n\tsize_t len;\n\tbool no_cck;\n\tbool dont_wait_for_ack;\n\tint n_csa_offsets;\n\tconst u16 *csa_offsets;\n};\n\n/**\n * struct cfg80211_dscp_exception - DSCP exception\n *\n * @dscp: DSCP value that does not adhere to the user priority range definition\n * @up: user priority value to which the corresponding DSCP value belongs\n */\nstruct cfg80211_dscp_exception {\n\tu8 dscp;\n\tu8 up;\n};\n\n/**\n * struct cfg80211_dscp_range - DSCP range definition for user priority\n *\n * @low: lowest DSCP value of this user priority range, inclusive\n * @high: highest DSCP value of this user priority range, inclusive\n */\nstruct cfg80211_dscp_range {\n\tu8 low;\n\tu8 high;\n};\n\n/* QoS Map Set element length defined in IEEE Std 802.11-2012, 8.4.2.97 */\n#define IEEE80211_QOS_MAP_MAX_EX\t21\n#define IEEE80211_QOS_MAP_LEN_MIN\t16\n#define IEEE80211_QOS_MAP_LEN_MAX \\\n\t(IEEE80211_QOS_MAP_LEN_MIN + 2 * IEEE80211_QOS_MAP_MAX_EX)\n\n/**\n * struct cfg80211_qos_map - QoS Map Information\n *\n * This struct defines the Interworking QoS map setting for DSCP values\n *\n * @num_des: number of DSCP exceptions (0..21)\n * @dscp_exception: optionally up to maximum of 21 DSCP exceptions from\n *\tthe user priority DSCP range definition\n * @up: DSCP range definition for a particular user priority\n */\nstruct cfg80211_qos_map {\n\tu8 num_des;\n\tstruct cfg80211_dscp_exception dscp_exception[IEEE80211_QOS_MAP_MAX_EX];\n\tstruct cfg80211_dscp_range up[8];\n};\n\n/**\n * struct cfg80211_nan_conf - NAN configuration\n *\n * This struct defines NAN configuration parameters\n *\n * @master_pref: master preference (1 - 255)\n * @bands: operating bands, a bitmap of &enum nl80211_band values.\n *\tFor instance, for NL80211_BAND_2GHZ, bit 0 would be set\n *\t(i.e. BIT(NL80211_BAND_2GHZ)).\n */\nstruct cfg80211_nan_conf {\n\tu8 master_pref;\n\tu8 bands;\n};\n\n/**\n * enum cfg80211_nan_conf_changes - indicates changed fields in NAN\n * configuration\n *\n * @CFG80211_NAN_CONF_CHANGED_PREF: master preference\n * @CFG80211_NAN_CONF_CHANGED_BANDS: operating bands\n */\nenum cfg80211_nan_conf_changes {\n\tCFG80211_NAN_CONF_CHANGED_PREF = BIT(0),\n\tCFG80211_NAN_CONF_CHANGED_BANDS = BIT(1),\n};\n\n/**\n * struct cfg80211_nan_func_filter - a NAN function Rx / Tx filter\n *\n * @filter: the content of the filter\n * @len: the length of the filter\n */\nstruct cfg80211_nan_func_filter {\n\tconst u8 *filter;\n\tu8 len;\n};\n\n/**\n * struct cfg80211_nan_func - a NAN function\n *\n * @type: &enum nl80211_nan_function_type\n * @service_id: the service ID of the function\n * @publish_type: &nl80211_nan_publish_type\n * @close_range: if true, the range should be limited. Threshold is\n *\timplementation specific.\n * @publish_bcast: if true, the solicited publish should be broadcasted\n * @subscribe_active: if true, the subscribe is active\n * @followup_id: the instance ID for follow up\n * @followup_reqid: the requestor instance ID for follow up\n * @followup_dest: MAC address of the recipient of the follow up\n * @ttl: time to live counter in DW.\n * @serv_spec_info: Service Specific Info\n * @serv_spec_info_len: Service Specific Info length\n * @srf_include: if true, SRF is inclusive\n * @srf_bf: Bloom Filter\n * @srf_bf_len: Bloom Filter length\n * @srf_bf_idx: Bloom Filter index\n * @srf_macs: SRF MAC addresses\n * @srf_num_macs: number of MAC addresses in SRF\n * @rx_filters: rx filters that are matched with corresponding peer's tx_filter\n * @tx_filters: filters that should be transmitted in the SDF.\n * @num_rx_filters: length of &rx_filters.\n * @num_tx_filters: length of &tx_filters.\n * @instance_id: driver allocated id of the function.\n * @cookie: unique NAN function identifier.\n */\nstruct cfg80211_nan_func {\n\tenum nl80211_nan_function_type type;\n\tu8 service_id[NL80211_NAN_FUNC_SERVICE_ID_LEN];\n\tu8 publish_type;\n\tbool close_range;\n\tbool publish_bcast;\n\tbool subscribe_active;\n\tu8 followup_id;\n\tu8 followup_reqid;\n\tstruct mac_address followup_dest;\n\tu32 ttl;\n\tconst u8 *serv_spec_info;\n\tu8 serv_spec_info_len;\n\tbool srf_include;\n\tconst u8 *srf_bf;\n\tu8 srf_bf_len;\n\tu8 srf_bf_idx;\n\tstruct mac_address *srf_macs;\n\tint srf_num_macs;\n\tstruct cfg80211_nan_func_filter *rx_filters;\n\tstruct cfg80211_nan_func_filter *tx_filters;\n\tu8 num_tx_filters;\n\tu8 num_rx_filters;\n\tu8 instance_id;\n\tu64 cookie;\n};\n\n/**\n * struct cfg80211_pmk_conf - PMK configuration\n *\n * @aa: authenticator address\n * @pmk_len: PMK length in bytes.\n * @pmk: the PMK material\n * @pmk_r0_name: PMK-R0 Name. NULL if not applicable (i.e., the PMK\n *\tis not PMK-R0). When pmk_r0_name is not NULL, the pmk field\n *\tholds PMK-R0.\n */\nstruct cfg80211_pmk_conf {\n\tconst u8 *aa;\n\tu8 pmk_len;\n\tconst u8 *pmk;\n\tconst u8 *pmk_r0_name;\n};\n\n/**\n * struct cfg80211_external_auth_params - Trigger External authentication.\n *\n * Commonly used across the external auth request and event interfaces.\n *\n * @action: action type / trigger for external authentication. Only significant\n *\tfor the authentication request event interface (driver to user space).\n * @bssid: BSSID of the peer with which the authentication has\n *\tto happen. Used by both the authentication request event and\n *\tauthentication response command interface.\n * @ssid: SSID of the AP.  Used by both the authentication request event and\n *\tauthentication response command interface.\n * @key_mgmt_suite: AKM suite of the respective authentication. Used by the\n *\tauthentication request event interface.\n * @status: status code, %WLAN_STATUS_SUCCESS for successful authentication,\n *\tuse %WLAN_STATUS_UNSPECIFIED_FAILURE if user space cannot give you\n *\tthe real status code for failures. Used only for the authentication\n *\tresponse command interface (user space to driver).\n * @pmkid: The identifier to refer a PMKSA.\n */\nstruct cfg80211_external_auth_params {\n\tenum nl80211_external_auth_action action;\n\tu8 bssid[ETH_ALEN] __aligned(2);\n\tstruct cfg80211_ssid ssid;\n\tunsigned int key_mgmt_suite;\n\tu16 status;\n\tconst u8 *pmkid;\n};\n\n/**\n * struct cfg80211_ftm_responder_stats - FTM responder statistics\n *\n * @filled: bitflag of flags using the bits of &enum nl80211_ftm_stats to\n *\tindicate the relevant values in this struct for them\n * @success_num: number of FTM sessions in which all frames were successfully\n *\tanswered\n * @partial_num: number of FTM sessions in which part of frames were\n *\tsuccessfully answered\n * @failed_num: number of failed FTM sessions\n * @asap_num: number of ASAP FTM sessions\n * @non_asap_num: number of  non-ASAP FTM sessions\n * @total_duration_ms: total sessions durations - gives an indication\n *\tof how much time the responder was busy\n * @unknown_triggers_num: number of unknown FTM triggers - triggers from\n *\tinitiators that didn't finish successfully the negotiation phase with\n *\tthe responder\n * @reschedule_requests_num: number of FTM reschedule requests - initiator asks\n *\tfor a new scheduling although it already has scheduled FTM slot\n * @out_of_window_triggers_num: total FTM triggers out of scheduled window\n */\nstruct cfg80211_ftm_responder_stats {\n\tu32 filled;\n\tu32 success_num;\n\tu32 partial_num;\n\tu32 failed_num;\n\tu32 asap_num;\n\tu32 non_asap_num;\n\tu64 total_duration_ms;\n\tu32 unknown_triggers_num;\n\tu32 reschedule_requests_num;\n\tu32 out_of_window_triggers_num;\n};\n\n/**\n * struct cfg80211_pmsr_ftm_result - FTM result\n * @failure_reason: if this measurement failed (PMSR status is\n *\t%NL80211_PMSR_STATUS_FAILURE), this gives a more precise\n *\treason than just \"failure\"\n * @burst_index: if reporting partial results, this is the index\n *\tin [0 .. num_bursts-1] of the burst that's being reported\n * @num_ftmr_attempts: number of FTM request frames transmitted\n * @num_ftmr_successes: number of FTM request frames acked\n * @busy_retry_time: if failure_reason is %NL80211_PMSR_FTM_FAILURE_PEER_BUSY,\n *\tfill this to indicate in how many seconds a retry is deemed possible\n *\tby the responder\n * @num_bursts_exp: actual number of bursts exponent negotiated\n * @burst_duration: actual burst duration negotiated\n * @ftms_per_burst: actual FTMs per burst negotiated\n * @lci_len: length of LCI information (if present)\n * @civicloc_len: length of civic location information (if present)\n * @lci: LCI data (may be %NULL)\n * @civicloc: civic location data (may be %NULL)\n * @rssi_avg: average RSSI over FTM action frames reported\n * @rssi_spread: spread of the RSSI over FTM action frames reported\n * @tx_rate: bitrate for transmitted FTM action frame response\n * @rx_rate: bitrate of received FTM action frame\n * @rtt_avg: average of RTTs measured (must have either this or @dist_avg)\n * @rtt_variance: variance of RTTs measured (note that standard deviation is\n *\tthe square root of the variance)\n * @rtt_spread: spread of the RTTs measured\n * @dist_avg: average of distances (mm) measured\n *\t(must have either this or @rtt_avg)\n * @dist_variance: variance of distances measured (see also @rtt_variance)\n * @dist_spread: spread of distances measured (see also @rtt_spread)\n * @num_ftmr_attempts_valid: @num_ftmr_attempts is valid\n * @num_ftmr_successes_valid: @num_ftmr_successes is valid\n * @rssi_avg_valid: @rssi_avg is valid\n * @rssi_spread_valid: @rssi_spread is valid\n * @tx_rate_valid: @tx_rate is valid\n * @rx_rate_valid: @rx_rate is valid\n * @rtt_avg_valid: @rtt_avg is valid\n * @rtt_variance_valid: @rtt_variance is valid\n * @rtt_spread_valid: @rtt_spread is valid\n * @dist_avg_valid: @dist_avg is valid\n * @dist_variance_valid: @dist_variance is valid\n * @dist_spread_valid: @dist_spread is valid\n */\nstruct cfg80211_pmsr_ftm_result {\n\tconst u8 *lci;\n\tconst u8 *civicloc;\n\tunsigned int lci_len;\n\tunsigned int civicloc_len;\n\tenum nl80211_peer_measurement_ftm_failure_reasons failure_reason;\n\tu32 num_ftmr_attempts, num_ftmr_successes;\n\ts16 burst_index;\n\tu8 busy_retry_time;\n\tu8 num_bursts_exp;\n\tu8 burst_duration;\n\tu8 ftms_per_burst;\n\ts32 rssi_avg;\n\ts32 rssi_spread;\n\tstruct rate_info tx_rate, rx_rate;\n\ts64 rtt_avg;\n\ts64 rtt_variance;\n\ts64 rtt_spread;\n\ts64 dist_avg;\n\ts64 dist_variance;\n\ts64 dist_spread;\n\n\tu16 num_ftmr_attempts_valid:1,\n\t    num_ftmr_successes_valid:1,\n\t    rssi_avg_valid:1,\n\t    rssi_spread_valid:1,\n\t    tx_rate_valid:1,\n\t    rx_rate_valid:1,\n\t    rtt_avg_valid:1,\n\t    rtt_variance_valid:1,\n\t    rtt_spread_valid:1,\n\t    dist_avg_valid:1,\n\t    dist_variance_valid:1,\n\t    dist_spread_valid:1;\n};\n\n/**\n * struct cfg80211_pmsr_result - peer measurement result\n * @addr: address of the peer\n * @host_time: host time (use ktime_get_boottime() adjust to the time when the\n *\tmeasurement was made)\n * @ap_tsf: AP's TSF at measurement time\n * @status: status of the measurement\n * @final: if reporting partial results, mark this as the last one; if not\n *\treporting partial results always set this flag\n * @ap_tsf_valid: indicates the @ap_tsf value is valid\n * @type: type of the measurement reported, note that we only support reporting\n *\tone type at a time, but you can report multiple results separately and\n *\tthey're all aggregated for userspace.\n */\nstruct cfg80211_pmsr_result {\n\tu64 host_time, ap_tsf;\n\tenum nl80211_peer_measurement_status status;\n\n\tu8 addr[ETH_ALEN];\n\n\tu8 final:1,\n\t   ap_tsf_valid:1;\n\n\tenum nl80211_peer_measurement_type type;\n\n\tunion {\n\t\tstruct cfg80211_pmsr_ftm_result ftm;\n\t};\n};\n\n/**\n * struct cfg80211_pmsr_ftm_request_peer - FTM request data\n * @requested: indicates FTM is requested\n * @preamble: frame preamble to use\n * @burst_period: burst period to use\n * @asap: indicates to use ASAP mode\n * @num_bursts_exp: number of bursts exponent\n * @burst_duration: burst duration\n * @ftms_per_burst: number of FTMs per burst\n * @ftmr_retries: number of retries for FTM request\n * @request_lci: request LCI information\n * @request_civicloc: request civic location information\n * @trigger_based: use trigger based ranging for the measurement\n *\t\t If neither @trigger_based nor @non_trigger_based is set,\n *\t\t EDCA based ranging will be used.\n * @non_trigger_based: use non trigger based ranging for the measurement\n *\t\t If neither @trigger_based nor @non_trigger_based is set,\n *\t\t EDCA based ranging will be used.\n *\n * See also nl80211 for the respective attribute documentation.\n */\nstruct cfg80211_pmsr_ftm_request_peer {\n\tenum nl80211_preamble preamble;\n\tu16 burst_period;\n\tu8 requested:1,\n\t   asap:1,\n\t   request_lci:1,\n\t   request_civicloc:1,\n\t   trigger_based:1,\n\t   non_trigger_based:1;\n\tu8 num_bursts_exp;\n\tu8 burst_duration;\n\tu8 ftms_per_burst;\n\tu8 ftmr_retries;\n};\n\n/**\n * struct cfg80211_pmsr_request_peer - peer data for a peer measurement request\n * @addr: MAC address\n * @chandef: channel to use\n * @report_ap_tsf: report the associated AP's TSF\n * @ftm: FTM data, see &struct cfg80211_pmsr_ftm_request_peer\n */\nstruct cfg80211_pmsr_request_peer {\n\tu8 addr[ETH_ALEN];\n\tstruct cfg80211_chan_def chandef;\n\tu8 report_ap_tsf:1;\n\tstruct cfg80211_pmsr_ftm_request_peer ftm;\n};\n\n/**\n * struct cfg80211_pmsr_request - peer measurement request\n * @cookie: cookie, set by cfg80211\n * @nl_portid: netlink portid - used by cfg80211\n * @drv_data: driver data for this request, if required for aborting,\n *\tnot otherwise freed or anything by cfg80211\n * @mac_addr: MAC address used for (randomised) request\n * @mac_addr_mask: MAC address mask used for randomisation, bits that\n *\tare 0 in the mask should be randomised, bits that are 1 should\n *\tbe taken from the @mac_addr\n * @list: used by cfg80211 to hold on to the request\n * @timeout: timeout (in milliseconds) for the whole operation, if\n *\tzero it means there's no timeout\n * @n_peers: number of peers to do measurements with\n * @peers: per-peer measurement request data\n */\nstruct cfg80211_pmsr_request {\n\tu64 cookie;\n\tvoid *drv_data;\n\tu32 n_peers;\n\tu32 nl_portid;\n\n\tu32 timeout;\n\n\tu8 mac_addr[ETH_ALEN] __aligned(2);\n\tu8 mac_addr_mask[ETH_ALEN] __aligned(2);\n\n\tstruct list_head list;\n\n\tstruct cfg80211_pmsr_request_peer peers[];\n};\n\n/**\n * struct cfg80211_update_owe_info - OWE Information\n *\n * This structure provides information needed for the drivers to offload OWE\n * (Opportunistic Wireless Encryption) processing to the user space.\n *\n * Commonly used across update_owe_info request and event interfaces.\n *\n * @peer: MAC address of the peer device for which the OWE processing\n *\thas to be done.\n * @status: status code, %WLAN_STATUS_SUCCESS for successful OWE info\n *\tprocessing, use %WLAN_STATUS_UNSPECIFIED_FAILURE if user space\n *\tcannot give you the real status code for failures. Used only for\n *\tOWE update request command interface (user space to driver).\n * @ie: IEs obtained from the peer or constructed by the user space. These are\n *\tthe IEs of the remote peer in the event from the host driver and\n *\tthe constructed IEs by the user space in the request interface.\n * @ie_len: Length of IEs in octets.\n */\nstruct cfg80211_update_owe_info {\n\tu8 peer[ETH_ALEN] __aligned(2);\n\tu16 status;\n\tconst u8 *ie;\n\tsize_t ie_len;\n};\n\n/**\n * struct mgmt_frame_regs - management frame registrations data\n * @global_stypes: bitmap of management frame subtypes registered\n *\tfor the entire device\n * @interface_stypes: bitmap of management frame subtypes registered\n *\tfor the given interface\n * @global_mcast_rx: mcast RX is needed globally for these subtypes\n * @interface_mcast_stypes: mcast RX is needed on this interface\n *\tfor these subtypes\n */\nstruct mgmt_frame_regs {\n\tu32 global_stypes, interface_stypes;\n\tu32 global_mcast_stypes, interface_mcast_stypes;\n};\n\n/**\n * struct cfg80211_ops - backend description for wireless configuration\n *\n * This struct is registered by fullmac card drivers and/or wireless stacks\n * in order to handle configuration requests on their interfaces.\n *\n * All callbacks except where otherwise noted should return 0\n * on success or a negative error code.\n *\n * All operations are invoked with the wiphy mutex held. The RTNL may be\n * held in addition (due to wireless extensions) but this cannot be relied\n * upon except in cases where documented below. Note that due to ordering,\n * the RTNL also cannot be acquired in any handlers.\n *\n * @suspend: wiphy device needs to be suspended. The variable @wow will\n *\tbe %NULL or contain the enabled Wake-on-Wireless triggers that are\n *\tconfigured for the device.\n * @resume: wiphy device needs to be resumed\n * @set_wakeup: Called when WoWLAN is enabled/disabled, use this callback\n *\tto call device_set_wakeup_enable() to enable/disable wakeup from\n *\tthe device.\n *\n * @add_virtual_intf: create a new virtual interface with the given name,\n *\tmust set the struct wireless_dev's iftype. Beware: You must create\n *\tthe new netdev in the wiphy's network namespace! Returns the struct\n *\twireless_dev, or an ERR_PTR. For P2P device wdevs, the driver must\n *\talso set the address member in the wdev.\n *\tThis additionally holds the RTNL to be able to do netdev changes.\n *\n * @del_virtual_intf: remove the virtual interface\n *\tThis additionally holds the RTNL to be able to do netdev changes.\n *\n * @change_virtual_intf: change type/configuration of virtual interface,\n *\tkeep the struct wireless_dev's iftype updated.\n *\tThis additionally holds the RTNL to be able to do netdev changes.\n *\n * @add_key: add a key with the given parameters. @mac_addr will be %NULL\n *\twhen adding a group key.\n *\n * @get_key: get information about the key with the given parameters.\n *\t@mac_addr will be %NULL when requesting information for a group\n *\tkey. All pointers given to the @callback function need not be valid\n *\tafter it returns. This function should return an error if it is\n *\tnot possible to retrieve the key, -ENOENT if it doesn't exist.\n *\n * @del_key: remove a key given the @mac_addr (%NULL for a group key)\n *\tand @key_index, return -ENOENT if the key doesn't exist.\n *\n * @set_default_key: set the default key on an interface\n *\n * @set_default_mgmt_key: set the default management frame key on an interface\n *\n * @set_default_beacon_key: set the default Beacon frame key on an interface\n *\n * @set_rekey_data: give the data necessary for GTK rekeying to the driver\n *\n * @start_ap: Start acting in AP mode defined by the parameters.\n * @change_beacon: Change the beacon parameters for an access point mode\n *\tinterface. This should reject the call when AP mode wasn't started.\n * @stop_ap: Stop being an AP, including stopping beaconing.\n *\n * @add_station: Add a new station.\n * @del_station: Remove a station\n * @change_station: Modify a given station. Note that flags changes are not much\n *\tvalidated in cfg80211, in particular the auth/assoc/authorized flags\n *\tmight come to the driver in invalid combinations -- make sure to check\n *\tthem, also against the existing state! Drivers must call\n *\tcfg80211_check_station_change() to validate the information.\n * @get_station: get station information for the station identified by @mac\n * @dump_station: dump station callback -- resume dump at index @idx\n *\n * @add_mpath: add a fixed mesh path\n * @del_mpath: delete a given mesh path\n * @change_mpath: change a given mesh path\n * @get_mpath: get a mesh path for the given parameters\n * @dump_mpath: dump mesh path callback -- resume dump at index @idx\n * @get_mpp: get a mesh proxy path for the given parameters\n * @dump_mpp: dump mesh proxy path callback -- resume dump at index @idx\n * @join_mesh: join the mesh network with the specified parameters\n *\t(invoked with the wireless_dev mutex held)\n * @leave_mesh: leave the current mesh network\n *\t(invoked with the wireless_dev mutex held)\n *\n * @get_mesh_config: Get the current mesh configuration\n *\n * @update_mesh_config: Update mesh parameters on a running mesh.\n *\tThe mask is a bitfield which tells us which parameters to\n *\tset, and which to leave alone.\n *\n * @change_bss: Modify parameters for a given BSS.\n *\n * @set_txq_params: Set TX queue parameters\n *\n * @libertas_set_mesh_channel: Only for backward compatibility for libertas,\n *\tas it doesn't implement join_mesh and needs to set the channel to\n *\tjoin the mesh instead.\n *\n * @set_monitor_channel: Set the monitor mode channel for the device. If other\n *\tinterfaces are active this callback should reject the configuration.\n *\tIf no interfaces are active or the device is down, the channel should\n *\tbe stored for when a monitor interface becomes active.\n *\n * @scan: Request to do a scan. If returning zero, the scan request is given\n *\tthe driver, and will be valid until passed to cfg80211_scan_done().\n *\tFor scan results, call cfg80211_inform_bss(); you can call this outside\n *\tthe scan/scan_done bracket too.\n * @abort_scan: Tell the driver to abort an ongoing scan. The driver shall\n *\tindicate the status of the scan through cfg80211_scan_done().\n *\n * @auth: Request to authenticate with the specified peer\n *\t(invoked with the wireless_dev mutex held)\n * @assoc: Request to (re)associate with the specified peer\n *\t(invoked with the wireless_dev mutex held)\n * @deauth: Request to deauthenticate from the specified peer\n *\t(invoked with the wireless_dev mutex held)\n * @disassoc: Request to disassociate from the specified peer\n *\t(invoked with the wireless_dev mutex held)\n *\n * @connect: Connect to the ESS with the specified parameters. When connected,\n *\tcall cfg80211_connect_result()/cfg80211_connect_bss() with status code\n *\t%WLAN_STATUS_SUCCESS. If the connection fails for some reason, call\n *\tcfg80211_connect_result()/cfg80211_connect_bss() with the status code\n *\tfrom the AP or cfg80211_connect_timeout() if no frame with status code\n *\twas received.\n *\tThe driver is allowed to roam to other BSSes within the ESS when the\n *\tother BSS matches the connect parameters. When such roaming is initiated\n *\tby the driver, the driver is expected to verify that the target matches\n *\tthe configured security parameters and to use Reassociation Request\n *\tframe instead of Association Request frame.\n *\tThe connect function can also be used to request the driver to perform a\n *\tspecific roam when connected to an ESS. In that case, the prev_bssid\n *\tparameter is set to the BSSID of the currently associated BSS as an\n *\tindication of requesting reassociation.\n *\tIn both the driver-initiated and new connect() call initiated roaming\n *\tcases, the result of roaming is indicated with a call to\n *\tcfg80211_roamed(). (invoked with the wireless_dev mutex held)\n * @update_connect_params: Update the connect parameters while connected to a\n *\tBSS. The updated parameters can be used by driver/firmware for\n *\tsubsequent BSS selection (roaming) decisions and to form the\n *\tAuthentication/(Re)Association Request frames. This call does not\n *\trequest an immediate disassociation or reassociation with the current\n *\tBSS, i.e., this impacts only subsequent (re)associations. The bits in\n *\tchanged are defined in &enum cfg80211_connect_params_changed.\n *\t(invoked with the wireless_dev mutex held)\n * @disconnect: Disconnect from the BSS/ESS or stop connection attempts if\n *      connection is in progress. Once done, call cfg80211_disconnected() in\n *      case connection was already established (invoked with the\n *      wireless_dev mutex held), otherwise call cfg80211_connect_timeout().\n *\n * @join_ibss: Join the specified IBSS (or create if necessary). Once done, call\n *\tcfg80211_ibss_joined(), also call that function when changing BSSID due\n *\tto a merge.\n *\t(invoked with the wireless_dev mutex held)\n * @leave_ibss: Leave the IBSS.\n *\t(invoked with the wireless_dev mutex held)\n *\n * @set_mcast_rate: Set the specified multicast rate (only if vif is in ADHOC or\n *\tMESH mode)\n *\n * @set_wiphy_params: Notify that wiphy parameters have changed;\n *\t@changed bitfield (see &enum wiphy_params_flags) describes which values\n *\thave changed. The actual parameter values are available in\n *\tstruct wiphy. If returning an error, no value should be changed.\n *\n * @set_tx_power: set the transmit power according to the parameters,\n *\tthe power passed is in mBm, to get dBm use MBM_TO_DBM(). The\n *\twdev may be %NULL if power was set for the wiphy, and will\n *\talways be %NULL unless the driver supports per-vif TX power\n *\t(as advertised by the nl80211 feature flag.)\n * @get_tx_power: store the current TX power into the dbm variable;\n *\treturn 0 if successful\n *\n * @rfkill_poll: polls the hw rfkill line, use cfg80211 reporting\n *\tfunctions to adjust rfkill hw state\n *\n * @dump_survey: get site survey information.\n *\n * @remain_on_channel: Request the driver to remain awake on the specified\n *\tchannel for the specified duration to complete an off-channel\n *\toperation (e.g., public action frame exchange). When the driver is\n *\tready on the requested channel, it must indicate this with an event\n *\tnotification by calling cfg80211_ready_on_channel().\n * @cancel_remain_on_channel: Cancel an on-going remain-on-channel operation.\n *\tThis allows the operation to be terminated prior to timeout based on\n *\tthe duration value.\n * @mgmt_tx: Transmit a management frame.\n * @mgmt_tx_cancel_wait: Cancel the wait time from transmitting a management\n *\tframe on another channel\n *\n * @testmode_cmd: run a test mode command; @wdev may be %NULL\n * @testmode_dump: Implement a test mode dump. The cb->args[2] and up may be\n *\tused by the function, but 0 and 1 must not be touched. Additionally,\n *\treturn error codes other than -ENOBUFS and -ENOENT will terminate the\n *\tdump and return to userspace with an error, so be careful. If any data\n *\twas passed in from userspace then the data/len arguments will be present\n *\tand point to the data contained in %NL80211_ATTR_TESTDATA.\n *\n * @set_bitrate_mask: set the bitrate mask configuration\n *\n * @set_pmksa: Cache a PMKID for a BSSID. This is mostly useful for fullmac\n *\tdevices running firmwares capable of generating the (re) association\n *\tRSN IE. It allows for faster roaming between WPA2 BSSIDs.\n * @del_pmksa: Delete a cached PMKID.\n * @flush_pmksa: Flush all cached PMKIDs.\n * @set_power_mgmt: Configure WLAN power management. A timeout value of -1\n *\tallows the driver to adjust the dynamic ps timeout value.\n * @set_cqm_rssi_config: Configure connection quality monitor RSSI threshold.\n *\tAfter configuration, the driver should (soon) send an event indicating\n *\tthe current level is above/below the configured threshold; this may\n *\tneed some care when the configuration is changed (without first being\n *\tdisabled.)\n * @set_cqm_rssi_range_config: Configure two RSSI thresholds in the\n *\tconnection quality monitor.  An event is to be sent only when the\n *\tsignal level is found to be outside the two values.  The driver should\n *\tset %NL80211_EXT_FEATURE_CQM_RSSI_LIST if this method is implemented.\n *\tIf it is provided then there's no point providing @set_cqm_rssi_config.\n * @set_cqm_txe_config: Configure connection quality monitor TX error\n *\tthresholds.\n * @sched_scan_start: Tell the driver to start a scheduled scan.\n * @sched_scan_stop: Tell the driver to stop an ongoing scheduled scan with\n *\tgiven request id. This call must stop the scheduled scan and be ready\n *\tfor starting a new one before it returns, i.e. @sched_scan_start may be\n *\tcalled immediately after that again and should not fail in that case.\n *\tThe driver should not call cfg80211_sched_scan_stopped() for a requested\n *\tstop (when this method returns 0).\n *\n * @update_mgmt_frame_registrations: Notify the driver that management frame\n *\tregistrations were updated. The callback is allowed to sleep.\n *\n * @set_antenna: Set antenna configuration (tx_ant, rx_ant) on the device.\n *\tParameters are bitmaps of allowed antennas to use for TX/RX. Drivers may\n *\treject TX/RX mask combinations they cannot support by returning -EINVAL\n *\t(also see nl80211.h @NL80211_ATTR_WIPHY_ANTENNA_TX).\n *\n * @get_antenna: Get current antenna configuration from device (tx_ant, rx_ant).\n *\n * @tdls_mgmt: Transmit a TDLS management frame.\n * @tdls_oper: Perform a high-level TDLS operation (e.g. TDLS link setup).\n *\n * @probe_client: probe an associated client, must return a cookie that it\n *\tlater passes to cfg80211_probe_status().\n *\n * @set_noack_map: Set the NoAck Map for the TIDs.\n *\n * @get_channel: Get the current operating channel for the virtual interface.\n *\tFor monitor interfaces, it should return %NULL unless there's a single\n *\tcurrent monitoring channel.\n *\n * @start_p2p_device: Start the given P2P device.\n * @stop_p2p_device: Stop the given P2P device.\n *\n * @set_mac_acl: Sets MAC address control list in AP and P2P GO mode.\n *\tParameters include ACL policy, an array of MAC address of stations\n *\tand the number of MAC addresses. If there is already a list in driver\n *\tthis new list replaces the existing one. Driver has to clear its ACL\n *\twhen number of MAC addresses entries is passed as 0. Drivers which\n *\tadvertise the support for MAC based ACL have to implement this callback.\n *\n * @start_radar_detection: Start radar detection in the driver.\n *\n * @end_cac: End running CAC, probably because a related CAC\n *\twas finished on another phy.\n *\n * @update_ft_ies: Provide updated Fast BSS Transition information to the\n *\tdriver. If the SME is in the driver/firmware, this information can be\n *\tused in building Authentication and Reassociation Request frames.\n *\n * @crit_proto_start: Indicates a critical protocol needs more link reliability\n *\tfor a given duration (milliseconds). The protocol is provided so the\n *\tdriver can take the most appropriate actions.\n * @crit_proto_stop: Indicates critical protocol no longer needs increased link\n *\treliability. This operation can not fail.\n * @set_coalesce: Set coalesce parameters.\n *\n * @channel_switch: initiate channel-switch procedure (with CSA). Driver is\n *\tresponsible for veryfing if the switch is possible. Since this is\n *\tinherently tricky driver may decide to disconnect an interface later\n *\twith cfg80211_stop_iface(). This doesn't mean driver can accept\n *\teverything. It should do it's best to verify requests and reject them\n *\tas soon as possible.\n *\n * @set_qos_map: Set QoS mapping information to the driver\n *\n * @set_ap_chanwidth: Set the AP (including P2P GO) mode channel width for the\n *\tgiven interface This is used e.g. for dynamic HT 20/40 MHz channel width\n *\tchanges during the lifetime of the BSS.\n *\n * @add_tx_ts: validate (if admitted_time is 0) or add a TX TS to the device\n *\twith the given parameters; action frame exchange has been handled by\n *\tuserspace so this just has to modify the TX path to take the TS into\n *\taccount.\n *\tIf the admitted time is 0 just validate the parameters to make sure\n *\tthe session can be created at all; it is valid to just always return\n *\tsuccess for that but that may result in inefficient behaviour (handshake\n *\twith the peer followed by immediate teardown when the addition is later\n *\trejected)\n * @del_tx_ts: remove an existing TX TS\n *\n * @join_ocb: join the OCB network with the specified parameters\n *\t(invoked with the wireless_dev mutex held)\n * @leave_ocb: leave the current OCB network\n *\t(invoked with the wireless_dev mutex held)\n *\n * @tdls_channel_switch: Start channel-switching with a TDLS peer. The driver\n *\tis responsible for continually initiating channel-switching operations\n *\tand returning to the base channel for communication with the AP.\n * @tdls_cancel_channel_switch: Stop channel-switching with a TDLS peer. Both\n *\tpeers must be on the base channel when the call completes.\n * @start_nan: Start the NAN interface.\n * @stop_nan: Stop the NAN interface.\n * @add_nan_func: Add a NAN function. Returns negative value on failure.\n *\tOn success @nan_func ownership is transferred to the driver and\n *\tit may access it outside of the scope of this function. The driver\n *\tshould free the @nan_func when no longer needed by calling\n *\tcfg80211_free_nan_func().\n *\tOn success the driver should assign an instance_id in the\n *\tprovided @nan_func.\n * @del_nan_func: Delete a NAN function.\n * @nan_change_conf: changes NAN configuration. The changed parameters must\n *\tbe specified in @changes (using &enum cfg80211_nan_conf_changes);\n *\tAll other parameters must be ignored.\n *\n * @set_multicast_to_unicast: configure multicast to unicast conversion for BSS\n *\n * @get_txq_stats: Get TXQ stats for interface or phy. If wdev is %NULL, this\n *      function should return phy stats, and interface stats otherwise.\n *\n * @set_pmk: configure the PMK to be used for offloaded 802.1X 4-Way handshake.\n *\tIf not deleted through @del_pmk the PMK remains valid until disconnect\n *\tupon which the driver should clear it.\n *\t(invoked with the wireless_dev mutex held)\n * @del_pmk: delete the previously configured PMK for the given authenticator.\n *\t(invoked with the wireless_dev mutex held)\n *\n * @external_auth: indicates result of offloaded authentication processing from\n *     user space\n *\n * @tx_control_port: TX a control port frame (EAPoL).  The noencrypt parameter\n *\ttells the driver that the frame should not be encrypted.\n *\n * @get_ftm_responder_stats: Retrieve FTM responder statistics, if available.\n *\tStatistics should be cumulative, currently no way to reset is provided.\n * @start_pmsr: start peer measurement (e.g. FTM)\n * @abort_pmsr: abort peer measurement\n *\n * @update_owe_info: Provide updated OWE info to driver. Driver implementing SME\n *\tbut offloading OWE processing to the user space will get the updated\n *\tDH IE through this interface.\n *\n * @probe_mesh_link: Probe direct Mesh peer's link quality by sending data frame\n *\tand overrule HWMP path selection algorithm.\n * @set_tid_config: TID specific configuration, this can be peer or BSS specific\n *\tThis callback may sleep.\n * @reset_tid_config: Reset TID specific configuration for the peer, for the\n *\tgiven TIDs. This callback may sleep.\n *\n * @set_sar_specs: Update the SAR (TX power) settings.\n */\nstruct cfg80211_ops {\n\tint\t(*suspend)(struct wiphy *wiphy, struct cfg80211_wowlan *wow);\n\tint\t(*resume)(struct wiphy *wiphy);\n\tvoid\t(*set_wakeup)(struct wiphy *wiphy, bool enabled);\n\n\tstruct wireless_dev * (*add_virtual_intf)(struct wiphy *wiphy,\n\t\t\t\t\t\t  const char *name,\n\t\t\t\t\t\t  unsigned char name_assign_type,\n\t\t\t\t\t\t  enum nl80211_iftype type,\n\t\t\t\t\t\t  struct vif_params *params);\n\tint\t(*del_virtual_intf)(struct wiphy *wiphy,\n\t\t\t\t    struct wireless_dev *wdev);\n\tint\t(*change_virtual_intf)(struct wiphy *wiphy,\n\t\t\t\t       struct net_device *dev,\n\t\t\t\t       enum nl80211_iftype type,\n\t\t\t\t       struct vif_params *params);\n\n\tint\t(*add_key)(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t   u8 key_index, bool pairwise, const u8 *mac_addr,\n\t\t\t   struct key_params *params);\n\tint\t(*get_key)(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t   u8 key_index, bool pairwise, const u8 *mac_addr,\n\t\t\t   void *cookie,\n\t\t\t   void (*callback)(void *cookie, struct key_params*));\n\tint\t(*del_key)(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t   u8 key_index, bool pairwise, const u8 *mac_addr);\n\tint\t(*set_default_key)(struct wiphy *wiphy,\n\t\t\t\t   struct net_device *netdev,\n\t\t\t\t   u8 key_index, bool unicast, bool multicast);\n\tint\t(*set_default_mgmt_key)(struct wiphy *wiphy,\n\t\t\t\t\tstruct net_device *netdev,\n\t\t\t\t\tu8 key_index);\n\tint\t(*set_default_beacon_key)(struct wiphy *wiphy,\n\t\t\t\t\t  struct net_device *netdev,\n\t\t\t\t\t  u8 key_index);\n\n\tint\t(*start_ap)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t    struct cfg80211_ap_settings *settings);\n\tint\t(*change_beacon)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t struct cfg80211_beacon_data *info);\n\tint\t(*stop_ap)(struct wiphy *wiphy, struct net_device *dev);\n\n\n\tint\t(*add_station)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       const u8 *mac,\n\t\t\t       struct station_parameters *params);\n\tint\t(*del_station)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       struct station_del_parameters *params);\n\tint\t(*change_station)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  const u8 *mac,\n\t\t\t\t  struct station_parameters *params);\n\tint\t(*get_station)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       const u8 *mac, struct station_info *sinfo);\n\tint\t(*dump_station)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\tint idx, u8 *mac, struct station_info *sinfo);\n\n\tint\t(*add_mpath)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       const u8 *dst, const u8 *next_hop);\n\tint\t(*del_mpath)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       const u8 *dst);\n\tint\t(*change_mpath)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  const u8 *dst, const u8 *next_hop);\n\tint\t(*get_mpath)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     u8 *dst, u8 *next_hop, struct mpath_info *pinfo);\n\tint\t(*dump_mpath)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      int idx, u8 *dst, u8 *next_hop,\n\t\t\t      struct mpath_info *pinfo);\n\tint\t(*get_mpp)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   u8 *dst, u8 *mpp, struct mpath_info *pinfo);\n\tint\t(*dump_mpp)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t    int idx, u8 *dst, u8 *mpp,\n\t\t\t    struct mpath_info *pinfo);\n\tint\t(*get_mesh_config)(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tstruct mesh_config *conf);\n\tint\t(*update_mesh_config)(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *dev, u32 mask,\n\t\t\t\t      const struct mesh_config *nconf);\n\tint\t(*join_mesh)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     const struct mesh_config *conf,\n\t\t\t     const struct mesh_setup *setup);\n\tint\t(*leave_mesh)(struct wiphy *wiphy, struct net_device *dev);\n\n\tint\t(*join_ocb)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t    struct ocb_setup *setup);\n\tint\t(*leave_ocb)(struct wiphy *wiphy, struct net_device *dev);\n\n\tint\t(*change_bss)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      struct bss_parameters *params);\n\n\tint\t(*set_txq_params)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  struct ieee80211_txq_params *params);\n\n\tint\t(*libertas_set_mesh_channel)(struct wiphy *wiphy,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     struct ieee80211_channel *chan);\n\n\tint\t(*set_monitor_channel)(struct wiphy *wiphy,\n\t\t\t\t       struct cfg80211_chan_def *chandef);\n\n\tint\t(*scan)(struct wiphy *wiphy,\n\t\t\tstruct cfg80211_scan_request *request);\n\tvoid\t(*abort_scan)(struct wiphy *wiphy, struct wireless_dev *wdev);\n\n\tint\t(*auth)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tstruct cfg80211_auth_request *req);\n\tint\t(*assoc)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t struct cfg80211_assoc_request *req);\n\tint\t(*deauth)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t  struct cfg80211_deauth_request *req);\n\tint\t(*disassoc)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t    struct cfg80211_disassoc_request *req);\n\n\tint\t(*connect)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   struct cfg80211_connect_params *sme);\n\tint\t(*update_connect_params)(struct wiphy *wiphy,\n\t\t\t\t\t struct net_device *dev,\n\t\t\t\t\t struct cfg80211_connect_params *sme,\n\t\t\t\t\t u32 changed);\n\tint\t(*disconnect)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      u16 reason_code);\n\n\tint\t(*join_ibss)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     struct cfg80211_ibss_params *params);\n\tint\t(*leave_ibss)(struct wiphy *wiphy, struct net_device *dev);\n\n\tint\t(*set_mcast_rate)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  int rate[NUM_NL80211_BANDS]);\n\n\tint\t(*set_wiphy_params)(struct wiphy *wiphy, u32 changed);\n\n\tint\t(*set_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t\tenum nl80211_tx_power_setting type, int mbm);\n\tint\t(*get_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t\tint *dbm);\n\n\tvoid\t(*rfkill_poll)(struct wiphy *wiphy);\n\n#ifdef CONFIG_NL80211_TESTMODE\n\tint\t(*testmode_cmd)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t\tvoid *data, int len);\n\tint\t(*testmode_dump)(struct wiphy *wiphy, struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb,\n\t\t\t\t void *data, int len);\n#endif\n\n\tint\t(*set_bitrate_mask)(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *dev,\n\t\t\t\t    const u8 *peer,\n\t\t\t\t    const struct cfg80211_bitrate_mask *mask);\n\n\tint\t(*dump_survey)(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\tint idx, struct survey_info *info);\n\n\tint\t(*set_pmksa)(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t     struct cfg80211_pmksa *pmksa);\n\tint\t(*del_pmksa)(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t     struct cfg80211_pmksa *pmksa);\n\tint\t(*flush_pmksa)(struct wiphy *wiphy, struct net_device *netdev);\n\n\tint\t(*remain_on_channel)(struct wiphy *wiphy,\n\t\t\t\t     struct wireless_dev *wdev,\n\t\t\t\t     struct ieee80211_channel *chan,\n\t\t\t\t     unsigned int duration,\n\t\t\t\t     u64 *cookie);\n\tint\t(*cancel_remain_on_channel)(struct wiphy *wiphy,\n\t\t\t\t\t    struct wireless_dev *wdev,\n\t\t\t\t\t    u64 cookie);\n\n\tint\t(*mgmt_tx)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t   struct cfg80211_mgmt_tx_params *params,\n\t\t\t   u64 *cookie);\n\tint\t(*mgmt_tx_cancel_wait)(struct wiphy *wiphy,\n\t\t\t\t       struct wireless_dev *wdev,\n\t\t\t\t       u64 cookie);\n\n\tint\t(*set_power_mgmt)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  bool enabled, int timeout);\n\n\tint\t(*set_cqm_rssi_config)(struct wiphy *wiphy,\n\t\t\t\t       struct net_device *dev,\n\t\t\t\t       s32 rssi_thold, u32 rssi_hyst);\n\n\tint\t(*set_cqm_rssi_range_config)(struct wiphy *wiphy,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     s32 rssi_low, s32 rssi_high);\n\n\tint\t(*set_cqm_txe_config)(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      u32 rate, u32 pkts, u32 intvl);\n\n\tvoid\t(*update_mgmt_frame_registrations)(struct wiphy *wiphy,\n\t\t\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t\t\t   struct mgmt_frame_regs *upd);\n\n\tint\t(*set_antenna)(struct wiphy *wiphy, u32 tx_ant, u32 rx_ant);\n\tint\t(*get_antenna)(struct wiphy *wiphy, u32 *tx_ant, u32 *rx_ant);\n\n\tint\t(*sched_scan_start)(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tstruct cfg80211_sched_scan_request *request);\n\tint\t(*sched_scan_stop)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t   u64 reqid);\n\n\tint\t(*set_rekey_data)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  struct cfg80211_gtk_rekey_data *data);\n\n\tint\t(*tdls_mgmt)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     const u8 *peer, u8 action_code,  u8 dialog_token,\n\t\t\t     u16 status_code, u32 peer_capability,\n\t\t\t     bool initiator, const u8 *buf, size_t len);\n\tint\t(*tdls_oper)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     const u8 *peer, enum nl80211_tdls_operation oper);\n\n\tint\t(*probe_client)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\tconst u8 *peer, u64 *cookie);\n\n\tint\t(*set_noack_map)(struct wiphy *wiphy,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  u16 noack_map);\n\n\tint\t(*get_channel)(struct wiphy *wiphy,\n\t\t\t       struct wireless_dev *wdev,\n\t\t\t       struct cfg80211_chan_def *chandef);\n\n\tint\t(*start_p2p_device)(struct wiphy *wiphy,\n\t\t\t\t    struct wireless_dev *wdev);\n\tvoid\t(*stop_p2p_device)(struct wiphy *wiphy,\n\t\t\t\t   struct wireless_dev *wdev);\n\n\tint\t(*set_mac_acl)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       const struct cfg80211_acl_data *params);\n\n\tint\t(*start_radar_detection)(struct wiphy *wiphy,\n\t\t\t\t\t struct net_device *dev,\n\t\t\t\t\t struct cfg80211_chan_def *chandef,\n\t\t\t\t\t u32 cac_time_ms);\n\tvoid\t(*end_cac)(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *dev);\n\tint\t(*update_ft_ies)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t struct cfg80211_update_ft_ies_params *ftie);\n\tint\t(*crit_proto_start)(struct wiphy *wiphy,\n\t\t\t\t    struct wireless_dev *wdev,\n\t\t\t\t    enum nl80211_crit_proto_id protocol,\n\t\t\t\t    u16 duration);\n\tvoid\t(*crit_proto_stop)(struct wiphy *wiphy,\n\t\t\t\t   struct wireless_dev *wdev);\n\tint\t(*set_coalesce)(struct wiphy *wiphy,\n\t\t\t\tstruct cfg80211_coalesce *coalesce);\n\n\tint\t(*channel_switch)(struct wiphy *wiphy,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  struct cfg80211_csa_settings *params);\n\n\tint     (*set_qos_map)(struct wiphy *wiphy,\n\t\t\t       struct net_device *dev,\n\t\t\t       struct cfg80211_qos_map *qos_map);\n\n\tint\t(*set_ap_chanwidth)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t    struct cfg80211_chan_def *chandef);\n\n\tint\t(*add_tx_ts)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     u8 tsid, const u8 *peer, u8 user_prio,\n\t\t\t     u16 admitted_time);\n\tint\t(*del_tx_ts)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     u8 tsid, const u8 *peer);\n\n\tint\t(*tdls_channel_switch)(struct wiphy *wiphy,\n\t\t\t\t       struct net_device *dev,\n\t\t\t\t       const u8 *addr, u8 oper_class,\n\t\t\t\t       struct cfg80211_chan_def *chandef);\n\tvoid\t(*tdls_cancel_channel_switch)(struct wiphy *wiphy,\n\t\t\t\t\t      struct net_device *dev,\n\t\t\t\t\t      const u8 *addr);\n\tint\t(*start_nan)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t     struct cfg80211_nan_conf *conf);\n\tvoid\t(*stop_nan)(struct wiphy *wiphy, struct wireless_dev *wdev);\n\tint\t(*add_nan_func)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t\tstruct cfg80211_nan_func *nan_func);\n\tvoid\t(*del_nan_func)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t       u64 cookie);\n\tint\t(*nan_change_conf)(struct wiphy *wiphy,\n\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t   struct cfg80211_nan_conf *conf,\n\t\t\t\t   u32 changes);\n\n\tint\t(*set_multicast_to_unicast)(struct wiphy *wiphy,\n\t\t\t\t\t    struct net_device *dev,\n\t\t\t\t\t    const bool enabled);\n\n\tint\t(*get_txq_stats)(struct wiphy *wiphy,\n\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t struct cfg80211_txq_stats *txqstats);\n\n\tint\t(*set_pmk)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   const struct cfg80211_pmk_conf *conf);\n\tint\t(*del_pmk)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   const u8 *aa);\n\tint     (*external_auth)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t struct cfg80211_external_auth_params *params);\n\n\tint\t(*tx_control_port)(struct wiphy *wiphy,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   const u8 *buf, size_t len,\n\t\t\t\t   const u8 *dest, const __be16 proto,\n\t\t\t\t   const bool noencrypt,\n\t\t\t\t   u64 *cookie);\n\n\tint\t(*get_ftm_responder_stats)(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tstruct cfg80211_ftm_responder_stats *ftm_stats);\n\n\tint\t(*start_pmsr)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t      struct cfg80211_pmsr_request *request);\n\tvoid\t(*abort_pmsr)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t      struct cfg80211_pmsr_request *request);\n\tint\t(*update_owe_info)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t   struct cfg80211_update_owe_info *owe_info);\n\tint\t(*probe_mesh_link)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t   const u8 *buf, size_t len);\n\tint     (*set_tid_config)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  struct cfg80211_tid_config *tid_conf);\n\tint\t(*reset_tid_config)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t    const u8 *peer, u8 tids);\n\tint\t(*set_sar_specs)(struct wiphy *wiphy,\n\t\t\t\t struct cfg80211_sar_specs *sar);\n};\n\n/*\n * wireless hardware and networking interfaces structures\n * and registration/helper functions\n */\n\n/**\n * enum wiphy_flags - wiphy capability flags\n *\n * @WIPHY_FLAG_SPLIT_SCAN_6GHZ: if set to true, the scan request will be split\n *\t into two, first for legacy bands and second for UHB.\n * @WIPHY_FLAG_NETNS_OK: if not set, do not allow changing the netns of this\n *\twiphy at all\n * @WIPHY_FLAG_PS_ON_BY_DEFAULT: if set to true, powersave will be enabled\n *\tby default -- this flag will be set depending on the kernel's default\n *\ton wiphy_new(), but can be changed by the driver if it has a good\n *\treason to override the default\n * @WIPHY_FLAG_4ADDR_AP: supports 4addr mode even on AP (with a single station\n *\ton a VLAN interface). This flag also serves an extra purpose of\n *\tsupporting 4ADDR AP mode on devices which do not support AP/VLAN iftype.\n * @WIPHY_FLAG_4ADDR_STATION: supports 4addr mode even as a station\n * @WIPHY_FLAG_CONTROL_PORT_PROTOCOL: This device supports setting the\n *\tcontrol port protocol ethertype. The device also honours the\n *\tcontrol_port_no_encrypt flag.\n * @WIPHY_FLAG_IBSS_RSN: The device supports IBSS RSN.\n * @WIPHY_FLAG_MESH_AUTH: The device supports mesh authentication by routing\n *\tauth frames to userspace. See @NL80211_MESH_SETUP_USERSPACE_AUTH.\n * @WIPHY_FLAG_SUPPORTS_FW_ROAM: The device supports roaming feature in the\n *\tfirmware.\n * @WIPHY_FLAG_AP_UAPSD: The device supports uapsd on AP.\n * @WIPHY_FLAG_SUPPORTS_TDLS: The device supports TDLS (802.11z) operation.\n * @WIPHY_FLAG_TDLS_EXTERNAL_SETUP: The device does not handle TDLS (802.11z)\n *\tlink setup/discovery operations internally. Setup, discovery and\n *\tteardown packets should be sent through the @NL80211_CMD_TDLS_MGMT\n *\tcommand. When this flag is not set, @NL80211_CMD_TDLS_OPER should be\n *\tused for asking the driver/firmware to perform a TDLS operation.\n * @WIPHY_FLAG_HAVE_AP_SME: device integrates AP SME\n * @WIPHY_FLAG_REPORTS_OBSS: the device will report beacons from other BSSes\n *\twhen there are virtual interfaces in AP mode by calling\n *\tcfg80211_report_obss_beacon().\n * @WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD: When operating as an AP, the device\n *\tresponds to probe-requests in hardware.\n * @WIPHY_FLAG_OFFCHAN_TX: Device supports direct off-channel TX.\n * @WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL: Device supports remain-on-channel call.\n * @WIPHY_FLAG_SUPPORTS_5_10_MHZ: Device supports 5 MHz and 10 MHz channels.\n * @WIPHY_FLAG_HAS_CHANNEL_SWITCH: Device supports channel switch in\n *\tbeaconing mode (AP, IBSS, Mesh, ...).\n * @WIPHY_FLAG_HAS_STATIC_WEP: The device supports static WEP key installation\n *\tbefore connection.\n * @WIPHY_FLAG_SUPPORTS_EXT_KEK_KCK: The device supports bigger kek and kck keys\n */\nenum wiphy_flags {\n\tWIPHY_FLAG_SUPPORTS_EXT_KEK_KCK\t\t= BIT(0),\n\t/* use hole at 1 */\n\tWIPHY_FLAG_SPLIT_SCAN_6GHZ\t\t= BIT(2),\n\tWIPHY_FLAG_NETNS_OK\t\t\t= BIT(3),\n\tWIPHY_FLAG_PS_ON_BY_DEFAULT\t\t= BIT(4),\n\tWIPHY_FLAG_4ADDR_AP\t\t\t= BIT(5),\n\tWIPHY_FLAG_4ADDR_STATION\t\t= BIT(6),\n\tWIPHY_FLAG_CONTROL_PORT_PROTOCOL\t= BIT(7),\n\tWIPHY_FLAG_IBSS_RSN\t\t\t= BIT(8),\n\tWIPHY_FLAG_MESH_AUTH\t\t\t= BIT(10),\n\t/* use hole at 11 */\n\t/* use hole at 12 */\n\tWIPHY_FLAG_SUPPORTS_FW_ROAM\t\t= BIT(13),\n\tWIPHY_FLAG_AP_UAPSD\t\t\t= BIT(14),\n\tWIPHY_FLAG_SUPPORTS_TDLS\t\t= BIT(15),\n\tWIPHY_FLAG_TDLS_EXTERNAL_SETUP\t\t= BIT(16),\n\tWIPHY_FLAG_HAVE_AP_SME\t\t\t= BIT(17),\n\tWIPHY_FLAG_REPORTS_OBSS\t\t\t= BIT(18),\n\tWIPHY_FLAG_AP_PROBE_RESP_OFFLOAD\t= BIT(19),\n\tWIPHY_FLAG_OFFCHAN_TX\t\t\t= BIT(20),\n\tWIPHY_FLAG_HAS_REMAIN_ON_CHANNEL\t= BIT(21),\n\tWIPHY_FLAG_SUPPORTS_5_10_MHZ\t\t= BIT(22),\n\tWIPHY_FLAG_HAS_CHANNEL_SWITCH\t\t= BIT(23),\n\tWIPHY_FLAG_HAS_STATIC_WEP\t\t= BIT(24),\n};\n\n/**\n * struct ieee80211_iface_limit - limit on certain interface types\n * @max: maximum number of interfaces of these types\n * @types: interface types (bits)\n */\nstruct ieee80211_iface_limit {\n\tu16 max;\n\tu16 types;\n};\n\n/**\n * struct ieee80211_iface_combination - possible interface combination\n *\n * With this structure the driver can describe which interface\n * combinations it supports concurrently.\n *\n * Examples:\n *\n * 1. Allow #STA <= 1, #AP <= 1, matching BI, channels = 1, 2 total:\n *\n *    .. code-block:: c\n *\n *\tstruct ieee80211_iface_limit limits1[] = {\n *\t\t{ .max = 1, .types = BIT(NL80211_IFTYPE_STATION), },\n *\t\t{ .max = 1, .types = BIT(NL80211_IFTYPE_AP}, },\n *\t};\n *\tstruct ieee80211_iface_combination combination1 = {\n *\t\t.limits = limits1,\n *\t\t.n_limits = ARRAY_SIZE(limits1),\n *\t\t.max_interfaces = 2,\n *\t\t.beacon_int_infra_match = true,\n *\t};\n *\n *\n * 2. Allow #{AP, P2P-GO} <= 8, channels = 1, 8 total:\n *\n *    .. code-block:: c\n *\n *\tstruct ieee80211_iface_limit limits2[] = {\n *\t\t{ .max = 8, .types = BIT(NL80211_IFTYPE_AP) |\n *\t\t\t\t     BIT(NL80211_IFTYPE_P2P_GO), },\n *\t};\n *\tstruct ieee80211_iface_combination combination2 = {\n *\t\t.limits = limits2,\n *\t\t.n_limits = ARRAY_SIZE(limits2),\n *\t\t.max_interfaces = 8,\n *\t\t.num_different_channels = 1,\n *\t};\n *\n *\n * 3. Allow #STA <= 1, #{P2P-client,P2P-GO} <= 3 on two channels, 4 total.\n *\n *    This allows for an infrastructure connection and three P2P connections.\n *\n *    .. code-block:: c\n *\n *\tstruct ieee80211_iface_limit limits3[] = {\n *\t\t{ .max = 1, .types = BIT(NL80211_IFTYPE_STATION), },\n *\t\t{ .max = 3, .types = BIT(NL80211_IFTYPE_P2P_GO) |\n *\t\t\t\t     BIT(NL80211_IFTYPE_P2P_CLIENT), },\n *\t};\n *\tstruct ieee80211_iface_combination combination3 = {\n *\t\t.limits = limits3,\n *\t\t.n_limits = ARRAY_SIZE(limits3),\n *\t\t.max_interfaces = 4,\n *\t\t.num_different_channels = 2,\n *\t};\n *\n */\nstruct ieee80211_iface_combination {\n\t/**\n\t * @limits:\n\t * limits for the given interface types\n\t */\n\tconst struct ieee80211_iface_limit *limits;\n\n\t/**\n\t * @num_different_channels:\n\t * can use up to this many different channels\n\t */\n\tu32 num_different_channels;\n\n\t/**\n\t * @max_interfaces:\n\t * maximum number of interfaces in total allowed in this group\n\t */\n\tu16 max_interfaces;\n\n\t/**\n\t * @n_limits:\n\t * number of limitations\n\t */\n\tu8 n_limits;\n\n\t/**\n\t * @beacon_int_infra_match:\n\t * In this combination, the beacon intervals between infrastructure\n\t * and AP types must match. This is required only in special cases.\n\t */\n\tbool beacon_int_infra_match;\n\n\t/**\n\t * @radar_detect_widths:\n\t * bitmap of channel widths supported for radar detection\n\t */\n\tu8 radar_detect_widths;\n\n\t/**\n\t * @radar_detect_regions:\n\t * bitmap of regions supported for radar detection\n\t */\n\tu8 radar_detect_regions;\n\n\t/**\n\t * @beacon_int_min_gcd:\n\t * This interface combination supports different beacon intervals.\n\t *\n\t * = 0\n\t *   all beacon intervals for different interface must be same.\n\t * > 0\n\t *   any beacon interval for the interface part of this combination AND\n\t *   GCD of all beacon intervals from beaconing interfaces of this\n\t *   combination must be greater or equal to this value.\n\t */\n\tu32 beacon_int_min_gcd;\n};\n\nstruct ieee80211_txrx_stypes {\n\tu16 tx, rx;\n};\n\n/**\n * enum wiphy_wowlan_support_flags - WoWLAN support flags\n * @WIPHY_WOWLAN_ANY: supports wakeup for the special \"any\"\n *\ttrigger that keeps the device operating as-is and\n *\twakes up the host on any activity, for example a\n *\treceived packet that passed filtering; note that the\n *\tpacket should be preserved in that case\n * @WIPHY_WOWLAN_MAGIC_PKT: supports wakeup on magic packet\n *\t(see nl80211.h)\n * @WIPHY_WOWLAN_DISCONNECT: supports wakeup on disconnect\n * @WIPHY_WOWLAN_SUPPORTS_GTK_REKEY: supports GTK rekeying while asleep\n * @WIPHY_WOWLAN_GTK_REKEY_FAILURE: supports wakeup on GTK rekey failure\n * @WIPHY_WOWLAN_EAP_IDENTITY_REQ: supports wakeup on EAP identity request\n * @WIPHY_WOWLAN_4WAY_HANDSHAKE: supports wakeup on 4-way handshake failure\n * @WIPHY_WOWLAN_RFKILL_RELEASE: supports wakeup on RF-kill release\n * @WIPHY_WOWLAN_NET_DETECT: supports wakeup on network detection\n */\nenum wiphy_wowlan_support_flags {\n\tWIPHY_WOWLAN_ANY\t\t= BIT(0),\n\tWIPHY_WOWLAN_MAGIC_PKT\t\t= BIT(1),\n\tWIPHY_WOWLAN_DISCONNECT\t\t= BIT(2),\n\tWIPHY_WOWLAN_SUPPORTS_GTK_REKEY\t= BIT(3),\n\tWIPHY_WOWLAN_GTK_REKEY_FAILURE\t= BIT(4),\n\tWIPHY_WOWLAN_EAP_IDENTITY_REQ\t= BIT(5),\n\tWIPHY_WOWLAN_4WAY_HANDSHAKE\t= BIT(6),\n\tWIPHY_WOWLAN_RFKILL_RELEASE\t= BIT(7),\n\tWIPHY_WOWLAN_NET_DETECT\t\t= BIT(8),\n};\n\nstruct wiphy_wowlan_tcp_support {\n\tconst struct nl80211_wowlan_tcp_data_token_feature *tok;\n\tu32 data_payload_max;\n\tu32 data_interval_max;\n\tu32 wake_payload_max;\n\tbool seq;\n};\n\n/**\n * struct wiphy_wowlan_support - WoWLAN support data\n * @flags: see &enum wiphy_wowlan_support_flags\n * @n_patterns: number of supported wakeup patterns\n *\t(see nl80211.h for the pattern definition)\n * @pattern_max_len: maximum length of each pattern\n * @pattern_min_len: minimum length of each pattern\n * @max_pkt_offset: maximum Rx packet offset\n * @max_nd_match_sets: maximum number of matchsets for net-detect,\n *\tsimilar, but not necessarily identical, to max_match_sets for\n *\tscheduled scans.\n *\tSee &struct cfg80211_sched_scan_request.@match_sets for more\n *\tdetails.\n * @tcp: TCP wakeup support information\n */\nstruct wiphy_wowlan_support {\n\tu32 flags;\n\tint n_patterns;\n\tint pattern_max_len;\n\tint pattern_min_len;\n\tint max_pkt_offset;\n\tint max_nd_match_sets;\n\tconst struct wiphy_wowlan_tcp_support *tcp;\n};\n\n/**\n * struct wiphy_coalesce_support - coalesce support data\n * @n_rules: maximum number of coalesce rules\n * @max_delay: maximum supported coalescing delay in msecs\n * @n_patterns: number of supported patterns in a rule\n *\t(see nl80211.h for the pattern definition)\n * @pattern_max_len: maximum length of each pattern\n * @pattern_min_len: minimum length of each pattern\n * @max_pkt_offset: maximum Rx packet offset\n */\nstruct wiphy_coalesce_support {\n\tint n_rules;\n\tint max_delay;\n\tint n_patterns;\n\tint pattern_max_len;\n\tint pattern_min_len;\n\tint max_pkt_offset;\n};\n\n/**\n * enum wiphy_vendor_command_flags - validation flags for vendor commands\n * @WIPHY_VENDOR_CMD_NEED_WDEV: vendor command requires wdev\n * @WIPHY_VENDOR_CMD_NEED_NETDEV: vendor command requires netdev\n * @WIPHY_VENDOR_CMD_NEED_RUNNING: interface/wdev must be up & running\n *\t(must be combined with %_WDEV or %_NETDEV)\n */\nenum wiphy_vendor_command_flags {\n\tWIPHY_VENDOR_CMD_NEED_WDEV = BIT(0),\n\tWIPHY_VENDOR_CMD_NEED_NETDEV = BIT(1),\n\tWIPHY_VENDOR_CMD_NEED_RUNNING = BIT(2),\n};\n\n/**\n * enum wiphy_opmode_flag - Station's ht/vht operation mode information flags\n *\n * @STA_OPMODE_MAX_BW_CHANGED: Max Bandwidth changed\n * @STA_OPMODE_SMPS_MODE_CHANGED: SMPS mode changed\n * @STA_OPMODE_N_SS_CHANGED: max N_SS (number of spatial streams) changed\n *\n */\nenum wiphy_opmode_flag {\n\tSTA_OPMODE_MAX_BW_CHANGED\t= BIT(0),\n\tSTA_OPMODE_SMPS_MODE_CHANGED\t= BIT(1),\n\tSTA_OPMODE_N_SS_CHANGED\t\t= BIT(2),\n};\n\n/**\n * struct sta_opmode_info - Station's ht/vht operation mode information\n * @changed: contains value from &enum wiphy_opmode_flag\n * @smps_mode: New SMPS mode value from &enum nl80211_smps_mode of a station\n * @bw: new max bandwidth value from &enum nl80211_chan_width of a station\n * @rx_nss: new rx_nss value of a station\n */\n\nstruct sta_opmode_info {\n\tu32 changed;\n\tenum nl80211_smps_mode smps_mode;\n\tenum nl80211_chan_width bw;\n\tu8 rx_nss;\n};\n\n#define VENDOR_CMD_RAW_DATA ((const struct nla_policy *)(long)(-ENODATA))\n\n/**\n * struct wiphy_vendor_command - vendor command definition\n * @info: vendor command identifying information, as used in nl80211\n * @flags: flags, see &enum wiphy_vendor_command_flags\n * @doit: callback for the operation, note that wdev is %NULL if the\n *\tflags didn't ask for a wdev and non-%NULL otherwise; the data\n *\tpointer may be %NULL if userspace provided no data at all\n * @dumpit: dump callback, for transferring bigger/multiple items. The\n *\t@storage points to cb->args[5], ie. is preserved over the multiple\n *\tdumpit calls.\n * @policy: policy pointer for attributes within %NL80211_ATTR_VENDOR_DATA.\n *\tSet this to %VENDOR_CMD_RAW_DATA if no policy can be given and the\n *\tattribute is just raw data (e.g. a firmware command).\n * @maxattr: highest attribute number in policy\n * It's recommended to not have the same sub command with both @doit and\n * @dumpit, so that userspace can assume certain ones are get and others\n * are used with dump requests.\n */\nstruct wiphy_vendor_command {\n\tstruct nl80211_vendor_cmd_info info;\n\tu32 flags;\n\tint (*doit)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t    const void *data, int data_len);\n\tint (*dumpit)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t      struct sk_buff *skb, const void *data, int data_len,\n\t\t      unsigned long *storage);\n\tconst struct nla_policy *policy;\n\tunsigned int maxattr;\n};\n\n/**\n * struct wiphy_iftype_ext_capab - extended capabilities per interface type\n * @iftype: interface type\n * @extended_capabilities: extended capabilities supported by the driver,\n *\tadditional capabilities might be supported by userspace; these are the\n *\t802.11 extended capabilities (\"Extended Capabilities element\") and are\n *\tin the same format as in the information element. See IEEE Std\n *\t802.11-2012 8.4.2.29 for the defined fields.\n * @extended_capabilities_mask: mask of the valid values\n * @extended_capabilities_len: length of the extended capabilities\n */\nstruct wiphy_iftype_ext_capab {\n\tenum nl80211_iftype iftype;\n\tconst u8 *extended_capabilities;\n\tconst u8 *extended_capabilities_mask;\n\tu8 extended_capabilities_len;\n};\n\n/**\n * struct cfg80211_pmsr_capabilities - cfg80211 peer measurement capabilities\n * @max_peers: maximum number of peers in a single measurement\n * @report_ap_tsf: can report assoc AP's TSF for radio resource measurement\n * @randomize_mac_addr: can randomize MAC address for measurement\n * @ftm.supported: FTM measurement is supported\n * @ftm.asap: ASAP-mode is supported\n * @ftm.non_asap: non-ASAP-mode is supported\n * @ftm.request_lci: can request LCI data\n * @ftm.request_civicloc: can request civic location data\n * @ftm.preambles: bitmap of preambles supported (&enum nl80211_preamble)\n * @ftm.bandwidths: bitmap of bandwidths supported (&enum nl80211_chan_width)\n * @ftm.max_bursts_exponent: maximum burst exponent supported\n *\t(set to -1 if not limited; note that setting this will necessarily\n *\tforbid using the value 15 to let the responder pick)\n * @ftm.max_ftms_per_burst: maximum FTMs per burst supported (set to 0 if\n *\tnot limited)\n * @ftm.trigger_based: trigger based ranging measurement is supported\n * @ftm.non_trigger_based: non trigger based ranging measurement is supported\n */\nstruct cfg80211_pmsr_capabilities {\n\tunsigned int max_peers;\n\tu8 report_ap_tsf:1,\n\t   randomize_mac_addr:1;\n\n\tstruct {\n\t\tu32 preambles;\n\t\tu32 bandwidths;\n\t\ts8 max_bursts_exponent;\n\t\tu8 max_ftms_per_burst;\n\t\tu8 supported:1,\n\t\t   asap:1,\n\t\t   non_asap:1,\n\t\t   request_lci:1,\n\t\t   request_civicloc:1,\n\t\t   trigger_based:1,\n\t\t   non_trigger_based:1;\n\t} ftm;\n};\n\n/**\n * struct wiphy_iftype_akm_suites - This structure encapsulates supported akm\n * suites for interface types defined in @iftypes_mask. Each type in the\n * @iftypes_mask must be unique across all instances of iftype_akm_suites.\n *\n * @iftypes_mask: bitmask of interfaces types\n * @akm_suites: points to an array of supported akm suites\n * @n_akm_suites: number of supported AKM suites\n */\nstruct wiphy_iftype_akm_suites {\n\tu16 iftypes_mask;\n\tconst u32 *akm_suites;\n\tint n_akm_suites;\n};\n\n/**\n * struct wiphy - wireless hardware description\n * @mtx: mutex for the data (structures) of this device\n * @reg_notifier: the driver's regulatory notification callback,\n *\tnote that if your driver uses wiphy_apply_custom_regulatory()\n *\tthe reg_notifier's request can be passed as NULL\n * @regd: the driver's regulatory domain, if one was requested via\n *\tthe regulatory_hint() API. This can be used by the driver\n *\ton the reg_notifier() if it chooses to ignore future\n *\tregulatory domain changes caused by other drivers.\n * @signal_type: signal type reported in &struct cfg80211_bss.\n * @cipher_suites: supported cipher suites\n * @n_cipher_suites: number of supported cipher suites\n * @akm_suites: supported AKM suites. These are the default AKMs supported if\n *\tthe supported AKMs not advertized for a specific interface type in\n *\tiftype_akm_suites.\n * @n_akm_suites: number of supported AKM suites\n * @iftype_akm_suites: array of supported akm suites info per interface type.\n *\tNote that the bits in @iftypes_mask inside this structure cannot\n *\toverlap (i.e. only one occurrence of each type is allowed across all\n *\tinstances of iftype_akm_suites).\n * @num_iftype_akm_suites: number of interface types for which supported akm\n *\tsuites are specified separately.\n * @retry_short: Retry limit for short frames (dot11ShortRetryLimit)\n * @retry_long: Retry limit for long frames (dot11LongRetryLimit)\n * @frag_threshold: Fragmentation threshold (dot11FragmentationThreshold);\n *\t-1 = fragmentation disabled, only odd values >= 256 used\n * @rts_threshold: RTS threshold (dot11RTSThreshold); -1 = RTS/CTS disabled\n * @_net: the network namespace this wiphy currently lives in\n * @perm_addr: permanent MAC address of this device\n * @addr_mask: If the device supports multiple MAC addresses by masking,\n *\tset this to a mask with variable bits set to 1, e.g. if the last\n *\tfour bits are variable then set it to 00-00-00-00-00-0f. The actual\n *\tvariable bits shall be determined by the interfaces added, with\n *\tinterfaces not matching the mask being rejected to be brought up.\n * @n_addresses: number of addresses in @addresses.\n * @addresses: If the device has more than one address, set this pointer\n *\tto a list of addresses (6 bytes each). The first one will be used\n *\tby default for perm_addr. In this case, the mask should be set to\n *\tall-zeroes. In this case it is assumed that the device can handle\n *\tthe same number of arbitrary MAC addresses.\n * @registered: protects ->resume and ->suspend sysfs callbacks against\n *\tunregister hardware\n * @debugfsdir: debugfs directory used for this wiphy (ieee80211/<wiphyname>).\n *\tIt will be renamed automatically on wiphy renames\n * @dev: (virtual) struct device for this wiphy. The item in\n *\t/sys/class/ieee80211/ points to this. You need use set_wiphy_dev()\n *\t(see below).\n * @wext: wireless extension handlers\n * @priv: driver private data (sized according to wiphy_new() parameter)\n * @interface_modes: bitmask of interfaces types valid for this wiphy,\n *\tmust be set by driver\n * @iface_combinations: Valid interface combinations array, should not\n *\tlist single interface types.\n * @n_iface_combinations: number of entries in @iface_combinations array.\n * @software_iftypes: bitmask of software interface types, these are not\n *\tsubject to any restrictions since they are purely managed in SW.\n * @flags: wiphy flags, see &enum wiphy_flags\n * @regulatory_flags: wiphy regulatory flags, see\n *\t&enum ieee80211_regulatory_flags\n * @features: features advertised to nl80211, see &enum nl80211_feature_flags.\n * @ext_features: extended features advertised to nl80211, see\n *\t&enum nl80211_ext_feature_index.\n * @bss_priv_size: each BSS struct has private data allocated with it,\n *\tthis variable determines its size\n * @max_scan_ssids: maximum number of SSIDs the device can scan for in\n *\tany given scan\n * @max_sched_scan_reqs: maximum number of scheduled scan requests that\n *\tthe device can run concurrently.\n * @max_sched_scan_ssids: maximum number of SSIDs the device can scan\n *\tfor in any given scheduled scan\n * @max_match_sets: maximum number of match sets the device can handle\n *\twhen performing a scheduled scan, 0 if filtering is not\n *\tsupported.\n * @max_scan_ie_len: maximum length of user-controlled IEs device can\n *\tadd to probe request frames transmitted during a scan, must not\n *\tinclude fixed IEs like supported rates\n * @max_sched_scan_ie_len: same as max_scan_ie_len, but for scheduled\n *\tscans\n * @max_sched_scan_plans: maximum number of scan plans (scan interval and number\n *\tof iterations) for scheduled scan supported by the device.\n * @max_sched_scan_plan_interval: maximum interval (in seconds) for a\n *\tsingle scan plan supported by the device.\n * @max_sched_scan_plan_iterations: maximum number of iterations for a single\n *\tscan plan supported by the device.\n * @coverage_class: current coverage class\n * @fw_version: firmware version for ethtool reporting\n * @hw_version: hardware version for ethtool reporting\n * @max_num_pmkids: maximum number of PMKIDs supported by device\n * @privid: a pointer that drivers can use to identify if an arbitrary\n *\twiphy is theirs, e.g. in global notifiers\n * @bands: information about bands/channels supported by this device\n *\n * @mgmt_stypes: bitmasks of frame subtypes that can be subscribed to or\n *\ttransmitted through nl80211, points to an array indexed by interface\n *\ttype\n *\n * @available_antennas_tx: bitmap of antennas which are available to be\n *\tconfigured as TX antennas. Antenna configuration commands will be\n *\trejected unless this or @available_antennas_rx is set.\n *\n * @available_antennas_rx: bitmap of antennas which are available to be\n *\tconfigured as RX antennas. Antenna configuration commands will be\n *\trejected unless this or @available_antennas_tx is set.\n *\n * @probe_resp_offload:\n *\t Bitmap of supported protocols for probe response offloading.\n *\t See &enum nl80211_probe_resp_offload_support_attr. Only valid\n *\t when the wiphy flag @WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD is set.\n *\n * @max_remain_on_channel_duration: Maximum time a remain-on-channel operation\n *\tmay request, if implemented.\n *\n * @wowlan: WoWLAN support information\n * @wowlan_config: current WoWLAN configuration; this should usually not be\n *\tused since access to it is necessarily racy, use the parameter passed\n *\tto the suspend() operation instead.\n *\n * @ap_sme_capa: AP SME capabilities, flags from &enum nl80211_ap_sme_features.\n * @ht_capa_mod_mask:  Specify what ht_cap values can be over-ridden.\n *\tIf null, then none can be over-ridden.\n * @vht_capa_mod_mask:  Specify what VHT capabilities can be over-ridden.\n *\tIf null, then none can be over-ridden.\n *\n * @wdev_list: the list of associated (virtual) interfaces; this list must\n *\tnot be modified by the driver, but can be read with RTNL/RCU protection.\n *\n * @max_acl_mac_addrs: Maximum number of MAC addresses that the device\n *\tsupports for ACL.\n *\n * @extended_capabilities: extended capabilities supported by the driver,\n *\tadditional capabilities might be supported by userspace; these are\n *\tthe 802.11 extended capabilities (\"Extended Capabilities element\")\n *\tand are in the same format as in the information element. See\n *\t802.11-2012 8.4.2.29 for the defined fields. These are the default\n *\textended capabilities to be used if the capabilities are not specified\n *\tfor a specific interface type in iftype_ext_capab.\n * @extended_capabilities_mask: mask of the valid values\n * @extended_capabilities_len: length of the extended capabilities\n * @iftype_ext_capab: array of extended capabilities per interface type\n * @num_iftype_ext_capab: number of interface types for which extended\n *\tcapabilities are specified separately.\n * @coalesce: packet coalescing support information\n *\n * @vendor_commands: array of vendor commands supported by the hardware\n * @n_vendor_commands: number of vendor commands\n * @vendor_events: array of vendor events supported by the hardware\n * @n_vendor_events: number of vendor events\n *\n * @max_ap_assoc_sta: maximum number of associated stations supported in AP mode\n *\t(including P2P GO) or 0 to indicate no such limit is advertised. The\n *\tdriver is allowed to advertise a theoretical limit that it can reach in\n *\tsome cases, but may not always reach.\n *\n * @max_num_csa_counters: Number of supported csa_counters in beacons\n *\tand probe responses.  This value should be set if the driver\n *\twishes to limit the number of csa counters. Default (0) means\n *\tinfinite.\n * @bss_select_support: bitmask indicating the BSS selection criteria supported\n *\tby the driver in the .connect() callback. The bit position maps to the\n *\tattribute indices defined in &enum nl80211_bss_select_attr.\n *\n * @nan_supported_bands: bands supported by the device in NAN mode, a\n *\tbitmap of &enum nl80211_band values.  For instance, for\n *\tNL80211_BAND_2GHZ, bit 0 would be set\n *\t(i.e. BIT(NL80211_BAND_2GHZ)).\n *\n * @txq_limit: configuration of internal TX queue frame limit\n * @txq_memory_limit: configuration internal TX queue memory limit\n * @txq_quantum: configuration of internal TX queue scheduler quantum\n *\n * @tx_queue_len: allow setting transmit queue len for drivers not using\n *\twake_tx_queue\n *\n * @support_mbssid: can HW support association with nontransmitted AP\n * @support_only_he_mbssid: don't parse MBSSID elements if it is not\n *\tHE AP, in order to avoid compatibility issues.\n *\t@support_mbssid must be set for this to have any effect.\n *\n * @pmsr_capa: peer measurement capabilities\n *\n * @tid_config_support: describes the per-TID config support that the\n *\tdevice has\n * @tid_config_support.vif: bitmap of attributes (configurations)\n *\tsupported by the driver for each vif\n * @tid_config_support.peer: bitmap of attributes (configurations)\n *\tsupported by the driver for each peer\n * @tid_config_support.max_retry: maximum supported retry count for\n *\tlong/short retry configuration\n *\n * @max_data_retry_count: maximum supported per TID retry count for\n *\tconfiguration through the %NL80211_TID_CONFIG_ATTR_RETRY_SHORT and\n *\t%NL80211_TID_CONFIG_ATTR_RETRY_LONG attributes\n * @sar_capa: SAR control capabilities\n */\nstruct wiphy {\n\tstruct mutex mtx;\n\n\t/* assign these fields before you register the wiphy */\n\n\tu8 perm_addr[ETH_ALEN];\n\tu8 addr_mask[ETH_ALEN];\n\n\tstruct mac_address *addresses;\n\n\tconst struct ieee80211_txrx_stypes *mgmt_stypes;\n\n\tconst struct ieee80211_iface_combination *iface_combinations;\n\tint n_iface_combinations;\n\tu16 software_iftypes;\n\n\tu16 n_addresses;\n\n\t/* Supported interface modes, OR together BIT(NL80211_IFTYPE_...) */\n\tu16 interface_modes;\n\n\tu16 max_acl_mac_addrs;\n\n\tu32 flags, regulatory_flags, features;\n\tu8 ext_features[DIV_ROUND_UP(NUM_NL80211_EXT_FEATURES, 8)];\n\n\tu32 ap_sme_capa;\n\n\tenum cfg80211_signal_type signal_type;\n\n\tint bss_priv_size;\n\tu8 max_scan_ssids;\n\tu8 max_sched_scan_reqs;\n\tu8 max_sched_scan_ssids;\n\tu8 max_match_sets;\n\tu16 max_scan_ie_len;\n\tu16 max_sched_scan_ie_len;\n\tu32 max_sched_scan_plans;\n\tu32 max_sched_scan_plan_interval;\n\tu32 max_sched_scan_plan_iterations;\n\n\tint n_cipher_suites;\n\tconst u32 *cipher_suites;\n\n\tint n_akm_suites;\n\tconst u32 *akm_suites;\n\n\tconst struct wiphy_iftype_akm_suites *iftype_akm_suites;\n\tunsigned int num_iftype_akm_suites;\n\n\tu8 retry_short;\n\tu8 retry_long;\n\tu32 frag_threshold;\n\tu32 rts_threshold;\n\tu8 coverage_class;\n\n\tchar fw_version[ETHTOOL_FWVERS_LEN];\n\tu32 hw_version;\n\n#ifdef CONFIG_PM\n\tconst struct wiphy_wowlan_support *wowlan;\n\tstruct cfg80211_wowlan *wowlan_config;\n#endif\n\n\tu16 max_remain_on_channel_duration;\n\n\tu8 max_num_pmkids;\n\n\tu32 available_antennas_tx;\n\tu32 available_antennas_rx;\n\n\tu32 probe_resp_offload;\n\n\tconst u8 *extended_capabilities, *extended_capabilities_mask;\n\tu8 extended_capabilities_len;\n\n\tconst struct wiphy_iftype_ext_capab *iftype_ext_capab;\n\tunsigned int num_iftype_ext_capab;\n\n\tconst void *privid;\n\n\tstruct ieee80211_supported_band *bands[NUM_NL80211_BANDS];\n\n\tvoid (*reg_notifier)(struct wiphy *wiphy,\n\t\t\t     struct regulatory_request *request);\n\n\t/* fields below are read-only, assigned by cfg80211 */\n\n\tconst struct ieee80211_regdomain __rcu *regd;\n\n\tstruct device dev;\n\n\tbool registered;\n\n\tstruct dentry *debugfsdir;\n\n\tconst struct ieee80211_ht_cap *ht_capa_mod_mask;\n\tconst struct ieee80211_vht_cap *vht_capa_mod_mask;\n\n\tstruct list_head wdev_list;\n\n\tpossible_net_t _net;\n\n#ifdef CONFIG_CFG80211_WEXT\n\tconst struct iw_handler_def *wext;\n#endif\n\n\tconst struct wiphy_coalesce_support *coalesce;\n\n\tconst struct wiphy_vendor_command *vendor_commands;\n\tconst struct nl80211_vendor_cmd_info *vendor_events;\n\tint n_vendor_commands, n_vendor_events;\n\n\tu16 max_ap_assoc_sta;\n\n\tu8 max_num_csa_counters;\n\n\tu32 bss_select_support;\n\n\tu8 nan_supported_bands;\n\n\tu32 txq_limit;\n\tu32 txq_memory_limit;\n\tu32 txq_quantum;\n\n\tunsigned long tx_queue_len;\n\n\tu8 support_mbssid:1,\n\t   support_only_he_mbssid:1;\n\n\tconst struct cfg80211_pmsr_capabilities *pmsr_capa;\n\n\tstruct {\n\t\tu64 peer, vif;\n\t\tu8 max_retry;\n\t} tid_config_support;\n\n\tu8 max_data_retry_count;\n\n\tconst struct cfg80211_sar_capa *sar_capa;\n\n\tchar priv[] __aligned(NETDEV_ALIGN);\n};\n\nstatic inline struct net *wiphy_net(struct wiphy *wiphy)\n{\n\treturn read_pnet(&wiphy->_net);\n}\n\nstatic inline void wiphy_net_set(struct wiphy *wiphy, struct net *net)\n{\n\twrite_pnet(&wiphy->_net, net);\n}\n\n/**\n * wiphy_priv - return priv from wiphy\n *\n * @wiphy: the wiphy whose priv pointer to return\n * Return: The priv of @wiphy.\n */\nstatic inline void *wiphy_priv(struct wiphy *wiphy)\n{\n\tBUG_ON(!wiphy);\n\treturn &wiphy->priv;\n}\n\n/**\n * priv_to_wiphy - return the wiphy containing the priv\n *\n * @priv: a pointer previously returned by wiphy_priv\n * Return: The wiphy of @priv.\n */\nstatic inline struct wiphy *priv_to_wiphy(void *priv)\n{\n\tBUG_ON(!priv);\n\treturn container_of(priv, struct wiphy, priv);\n}\n\n/**\n * set_wiphy_dev - set device pointer for wiphy\n *\n * @wiphy: The wiphy whose device to bind\n * @dev: The device to parent it to\n */\nstatic inline void set_wiphy_dev(struct wiphy *wiphy, struct device *dev)\n{\n\twiphy->dev.parent = dev;\n}\n\n/**\n * wiphy_dev - get wiphy dev pointer\n *\n * @wiphy: The wiphy whose device struct to look up\n * Return: The dev of @wiphy.\n */\nstatic inline struct device *wiphy_dev(struct wiphy *wiphy)\n{\n\treturn wiphy->dev.parent;\n}\n\n/**\n * wiphy_name - get wiphy name\n *\n * @wiphy: The wiphy whose name to return\n * Return: The name of @wiphy.\n */\nstatic inline const char *wiphy_name(const struct wiphy *wiphy)\n{\n\treturn dev_name(&wiphy->dev);\n}\n\n/**\n * wiphy_new_nm - create a new wiphy for use with cfg80211\n *\n * @ops: The configuration operations for this device\n * @sizeof_priv: The size of the private area to allocate\n * @requested_name: Request a particular name.\n *\tNULL is valid value, and means use the default phy%d naming.\n *\n * Create a new wiphy and associate the given operations with it.\n * @sizeof_priv bytes are allocated for private use.\n *\n * Return: A pointer to the new wiphy. This pointer must be\n * assigned to each netdev's ieee80211_ptr for proper operation.\n */\nstruct wiphy *wiphy_new_nm(const struct cfg80211_ops *ops, int sizeof_priv,\n\t\t\t   const char *requested_name);\n\n/**\n * wiphy_new - create a new wiphy for use with cfg80211\n *\n * @ops: The configuration operations for this device\n * @sizeof_priv: The size of the private area to allocate\n *\n * Create a new wiphy and associate the given operations with it.\n * @sizeof_priv bytes are allocated for private use.\n *\n * Return: A pointer to the new wiphy. This pointer must be\n * assigned to each netdev's ieee80211_ptr for proper operation.\n */\nstatic inline struct wiphy *wiphy_new(const struct cfg80211_ops *ops,\n\t\t\t\t      int sizeof_priv)\n{\n\treturn wiphy_new_nm(ops, sizeof_priv, NULL);\n}\n\n/**\n * wiphy_register - register a wiphy with cfg80211\n *\n * @wiphy: The wiphy to register.\n *\n * Return: A non-negative wiphy index or a negative error code.\n */\nint wiphy_register(struct wiphy *wiphy);\n\n/* this is a define for better error reporting (file/line) */\n#define lockdep_assert_wiphy(wiphy) lockdep_assert_held(&(wiphy)->mtx)\n\n/**\n * rcu_dereference_wiphy - rcu_dereference with debug checking\n * @wiphy: the wiphy to check the locking on\n * @p: The pointer to read, prior to dereferencing\n *\n * Do an rcu_dereference(p), but check caller either holds rcu_read_lock()\n * or RTNL. Note: Please prefer wiphy_dereference() or rcu_dereference().\n */\n#define rcu_dereference_wiphy(wiphy, p)\t\t\t\t\\\n        rcu_dereference_check(p, lockdep_is_held(&wiphy->mtx))\n\n/**\n * wiphy_dereference - fetch RCU pointer when updates are prevented by wiphy mtx\n * @wiphy: the wiphy to check the locking on\n * @p: The pointer to read, prior to dereferencing\n *\n * Return the value of the specified RCU-protected pointer, but omit the\n * READ_ONCE(), because caller holds the wiphy mutex used for updates.\n */\n#define wiphy_dereference(wiphy, p)\t\t\t\t\\\n        rcu_dereference_protected(p, lockdep_is_held(&wiphy->mtx))\n\n/**\n * get_wiphy_regdom - get custom regdomain for the given wiphy\n * @wiphy: the wiphy to get the regdomain from\n */\nconst struct ieee80211_regdomain *get_wiphy_regdom(struct wiphy *wiphy);\n\n/**\n * wiphy_unregister - deregister a wiphy from cfg80211\n *\n * @wiphy: The wiphy to unregister.\n *\n * After this call, no more requests can be made with this priv\n * pointer, but the call may sleep to wait for an outstanding\n * request that is being handled.\n */\nvoid wiphy_unregister(struct wiphy *wiphy);\n\n/**\n * wiphy_free - free wiphy\n *\n * @wiphy: The wiphy to free\n */\nvoid wiphy_free(struct wiphy *wiphy);\n\n/* internal structs */\nstruct cfg80211_conn;\nstruct cfg80211_internal_bss;\nstruct cfg80211_cached_keys;\nstruct cfg80211_cqm_config;\n\n/**\n * wiphy_lock - lock the wiphy\n * @wiphy: the wiphy to lock\n *\n * This is mostly exposed so it can be done around registering and\n * unregistering netdevs that aren't created through cfg80211 calls,\n * since that requires locking in cfg80211 when the notifiers is\n * called, but that cannot differentiate which way it's called.\n *\n * When cfg80211 ops are called, the wiphy is already locked.\n */\nstatic inline void wiphy_lock(struct wiphy *wiphy)\n{\n\tmutex_lock(&wiphy->mtx);\n}\n\n/**\n * wiphy_unlock - unlock the wiphy again\n * @wiphy: the wiphy to unlock\n */\nstatic inline void wiphy_unlock(struct wiphy *wiphy)\n{\n\tmutex_unlock(&wiphy->mtx);\n}\n\n/**\n * cfg80211_register_netdev - register netdev\n * @dev: the netdev to register\n *\n * This is just a helper function similar to register_netdev() that takes\n * care of the required locking - obviously dev->ieee80211_ptr must have\n * been set correctly.\n */\nint cfg80211_register_netdev(struct net_device *dev);\n\n/**\n * cfg80211_unregister_netdev - register netdev\n * @dev: the netdev to unregister\n *\n * This is just a helper function similar to unregister_netdev() that takes\n * care of the required locking - obviously dev->ieee80211_ptr must have\n * been set correctly.\n */\nvoid cfg80211_unregister_netdev(struct net_device *dev);\n\n/**\n * struct wireless_dev - wireless device state\n *\n * For netdevs, this structure must be allocated by the driver\n * that uses the ieee80211_ptr field in struct net_device (this\n * is intentional so it can be allocated along with the netdev.)\n * It need not be registered then as netdev registration will\n * be intercepted by cfg80211 to see the new wireless device,\n * however, drivers must lock the wiphy before registering or\n * unregistering netdevs if they pre-create any netdevs (in ops\n * called from cfg80211, the wiphy is already locked.)\n *\n * For non-netdev uses, it must also be allocated by the driver\n * in response to the cfg80211 callbacks that require it, as\n * there's no netdev registration in that case it may not be\n * allocated outside of callback operations that return it.\n *\n * @wiphy: pointer to hardware description\n * @iftype: interface type\n * @list: (private) Used to collect the interfaces\n * @netdev: (private) Used to reference back to the netdev, may be %NULL\n * @identifier: (private) Identifier used in nl80211 to identify this\n *\twireless device if it has no netdev\n * @current_bss: (private) Used by the internal configuration code\n * @chandef: (private) Used by the internal configuration code to track\n *\tthe user-set channel definition.\n * @preset_chandef: (private) Used by the internal configuration code to\n *\ttrack the channel to be used for AP later\n * @bssid: (private) Used by the internal configuration code\n * @ssid: (private) Used by the internal configuration code\n * @ssid_len: (private) Used by the internal configuration code\n * @mesh_id_len: (private) Used by the internal configuration code\n * @mesh_id_up_len: (private) Used by the internal configuration code\n * @wext: (private) Used by the internal wireless extensions compat code\n * @wext.ibss: (private) IBSS data part of wext handling\n * @wext.connect: (private) connection handling data\n * @wext.keys: (private) (WEP) key data\n * @wext.ie: (private) extra elements for association\n * @wext.ie_len: (private) length of extra elements\n * @wext.bssid: (private) selected network BSSID\n * @wext.ssid: (private) selected network SSID\n * @wext.default_key: (private) selected default key index\n * @wext.default_mgmt_key: (private) selected default management key index\n * @wext.prev_bssid: (private) previous BSSID for reassociation\n * @wext.prev_bssid_valid: (private) previous BSSID validity\n * @use_4addr: indicates 4addr mode is used on this interface, must be\n *\tset by driver (if supported) on add_interface BEFORE registering the\n *\tnetdev and may otherwise be used by driver read-only, will be update\n *\tby cfg80211 on change_interface\n * @mgmt_registrations: list of registrations for management frames\n * @mgmt_registrations_lock: lock for the list\n * @mgmt_registrations_need_update: mgmt registrations were updated,\n *\tneed to propagate the update to the driver\n * @mtx: mutex used to lock data in this struct, may be used by drivers\n *\tand some API functions require it held\n * @beacon_interval: beacon interval used on this device for transmitting\n *\tbeacons, 0 when not valid\n * @address: The address for this device, valid only if @netdev is %NULL\n * @is_running: true if this is a non-netdev device that has been started, e.g.\n *\tthe P2P Device.\n * @cac_started: true if DFS channel availability check has been started\n * @cac_start_time: timestamp (jiffies) when the dfs state was entered.\n * @cac_time_ms: CAC time in ms\n * @ps: powersave mode is enabled\n * @ps_timeout: dynamic powersave timeout\n * @ap_unexpected_nlportid: (private) netlink port ID of application\n *\tregistered for unexpected class 3 frames (AP mode)\n * @conn: (private) cfg80211 software SME connection state machine data\n * @connect_keys: (private) keys to set after connection is established\n * @conn_bss_type: connecting/connected BSS type\n * @conn_owner_nlportid: (private) connection owner socket port ID\n * @disconnect_wk: (private) auto-disconnect work\n * @disconnect_bssid: (private) the BSSID to use for auto-disconnect\n * @ibss_fixed: (private) IBSS is using fixed BSSID\n * @ibss_dfs_possible: (private) IBSS may change to a DFS channel\n * @event_list: (private) list for internal event processing\n * @event_lock: (private) lock for event list\n * @owner_nlportid: (private) owner socket port ID\n * @nl_owner_dead: (private) owner socket went away\n * @cqm_config: (private) nl80211 RSSI monitor state\n * @pmsr_list: (private) peer measurement requests\n * @pmsr_lock: (private) peer measurements requests/results lock\n * @pmsr_free_wk: (private) peer measurements cleanup work\n * @unprot_beacon_reported: (private) timestamp of last\n *\tunprotected beacon report\n */\nstruct wireless_dev {\n\tstruct wiphy *wiphy;\n\tenum nl80211_iftype iftype;\n\n\t/* the remainder of this struct should be private to cfg80211 */\n\tstruct list_head list;\n\tstruct net_device *netdev;\n\n\tu32 identifier;\n\n\tstruct list_head mgmt_registrations;\n\tspinlock_t mgmt_registrations_lock;\n\tu8 mgmt_registrations_need_update:1;\n\n\tstruct mutex mtx;\n\n\tbool use_4addr, is_running;\n\n\tu8 address[ETH_ALEN] __aligned(sizeof(u16));\n\n\t/* currently used for IBSS and SME - might be rearranged later */\n\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\tu8 ssid_len, mesh_id_len, mesh_id_up_len;\n\tstruct cfg80211_conn *conn;\n\tstruct cfg80211_cached_keys *connect_keys;\n\tenum ieee80211_bss_type conn_bss_type;\n\tu32 conn_owner_nlportid;\n\n\tstruct work_struct disconnect_wk;\n\tu8 disconnect_bssid[ETH_ALEN];\n\n\tstruct list_head event_list;\n\tspinlock_t event_lock;\n\n\tstruct cfg80211_internal_bss *current_bss; /* associated / joined */\n\tstruct cfg80211_chan_def preset_chandef;\n\tstruct cfg80211_chan_def chandef;\n\n\tbool ibss_fixed;\n\tbool ibss_dfs_possible;\n\n\tbool ps;\n\tint ps_timeout;\n\n\tint beacon_interval;\n\n\tu32 ap_unexpected_nlportid;\n\n\tu32 owner_nlportid;\n\tbool nl_owner_dead;\n\n\tbool cac_started;\n\tunsigned long cac_start_time;\n\tunsigned int cac_time_ms;\n\n#ifdef CONFIG_CFG80211_WEXT\n\t/* wext data */\n\tstruct {\n\t\tstruct cfg80211_ibss_params ibss;\n\t\tstruct cfg80211_connect_params connect;\n\t\tstruct cfg80211_cached_keys *keys;\n\t\tconst u8 *ie;\n\t\tsize_t ie_len;\n\t\tu8 bssid[ETH_ALEN];\n\t\tu8 prev_bssid[ETH_ALEN];\n\t\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\t\ts8 default_key, default_mgmt_key;\n\t\tbool prev_bssid_valid;\n\t} wext;\n#endif\n\n\tstruct cfg80211_cqm_config *cqm_config;\n\n\tstruct list_head pmsr_list;\n\tspinlock_t pmsr_lock;\n\tstruct work_struct pmsr_free_wk;\n\n\tunsigned long unprot_beacon_reported;\n};\n\nstatic inline u8 *wdev_address(struct wireless_dev *wdev)\n{\n\tif (wdev->netdev)\n\t\treturn wdev->netdev->dev_addr;\n\treturn wdev->address;\n}\n\nstatic inline bool wdev_running(struct wireless_dev *wdev)\n{\n\tif (wdev->netdev)\n\t\treturn netif_running(wdev->netdev);\n\treturn wdev->is_running;\n}\n\n/**\n * wdev_priv - return wiphy priv from wireless_dev\n *\n * @wdev: The wireless device whose wiphy's priv pointer to return\n * Return: The wiphy priv of @wdev.\n */\nstatic inline void *wdev_priv(struct wireless_dev *wdev)\n{\n\tBUG_ON(!wdev);\n\treturn wiphy_priv(wdev->wiphy);\n}\n\n/**\n * DOC: Utility functions\n *\n * cfg80211 offers a number of utility functions that can be useful.\n */\n\n/**\n * ieee80211_channel_equal - compare two struct ieee80211_channel\n *\n * @a: 1st struct ieee80211_channel\n * @b: 2nd struct ieee80211_channel\n * Return: true if center frequency of @a == @b\n */\nstatic inline bool\nieee80211_channel_equal(struct ieee80211_channel *a,\n\t\t\tstruct ieee80211_channel *b)\n{\n\treturn (a->center_freq == b->center_freq &&\n\t\ta->freq_offset == b->freq_offset);\n}\n\n/**\n * ieee80211_channel_to_khz - convert ieee80211_channel to frequency in KHz\n * @chan: struct ieee80211_channel to convert\n * Return: The corresponding frequency (in KHz)\n */\nstatic inline u32\nieee80211_channel_to_khz(const struct ieee80211_channel *chan)\n{\n\treturn MHZ_TO_KHZ(chan->center_freq) + chan->freq_offset;\n}\n\n/**\n * ieee80211_s1g_channel_width - get allowed channel width from @chan\n *\n * Only allowed for band NL80211_BAND_S1GHZ\n * @chan: channel\n * Return: The allowed channel width for this center_freq\n */\nenum nl80211_chan_width\nieee80211_s1g_channel_width(const struct ieee80211_channel *chan);\n\n/**\n * ieee80211_channel_to_freq_khz - convert channel number to frequency\n * @chan: channel number\n * @band: band, necessary due to channel number overlap\n * Return: The corresponding frequency (in KHz), or 0 if the conversion failed.\n */\nu32 ieee80211_channel_to_freq_khz(int chan, enum nl80211_band band);\n\n/**\n * ieee80211_channel_to_frequency - convert channel number to frequency\n * @chan: channel number\n * @band: band, necessary due to channel number overlap\n * Return: The corresponding frequency (in MHz), or 0 if the conversion failed.\n */\nstatic inline int\nieee80211_channel_to_frequency(int chan, enum nl80211_band band)\n{\n\treturn KHZ_TO_MHZ(ieee80211_channel_to_freq_khz(chan, band));\n}\n\n/**\n * ieee80211_freq_khz_to_channel - convert frequency to channel number\n * @freq: center frequency in KHz\n * Return: The corresponding channel, or 0 if the conversion failed.\n */\nint ieee80211_freq_khz_to_channel(u32 freq);\n\n/**\n * ieee80211_frequency_to_channel - convert frequency to channel number\n * @freq: center frequency in MHz\n * Return: The corresponding channel, or 0 if the conversion failed.\n */\nstatic inline int\nieee80211_frequency_to_channel(int freq)\n{\n\treturn ieee80211_freq_khz_to_channel(MHZ_TO_KHZ(freq));\n}\n\n/**\n * ieee80211_get_channel_khz - get channel struct from wiphy for specified\n * frequency\n * @wiphy: the struct wiphy to get the channel for\n * @freq: the center frequency (in KHz) of the channel\n * Return: The channel struct from @wiphy at @freq.\n */\nstruct ieee80211_channel *\nieee80211_get_channel_khz(struct wiphy *wiphy, u32 freq);\n\n/**\n * ieee80211_get_channel - get channel struct from wiphy for specified frequency\n *\n * @wiphy: the struct wiphy to get the channel for\n * @freq: the center frequency (in MHz) of the channel\n * Return: The channel struct from @wiphy at @freq.\n */\nstatic inline struct ieee80211_channel *\nieee80211_get_channel(struct wiphy *wiphy, int freq)\n{\n\treturn ieee80211_get_channel_khz(wiphy, MHZ_TO_KHZ(freq));\n}\n\n/**\n * cfg80211_channel_is_psc - Check if the channel is a 6 GHz PSC\n * @chan: control channel to check\n *\n * The Preferred Scanning Channels (PSC) are defined in\n * Draft IEEE P802.11ax/D5.0, 26.17.2.3.3\n */\nstatic inline bool cfg80211_channel_is_psc(struct ieee80211_channel *chan)\n{\n\tif (chan->band != NL80211_BAND_6GHZ)\n\t\treturn false;\n\n\treturn ieee80211_frequency_to_channel(chan->center_freq) % 16 == 5;\n}\n\n/**\n * ieee80211_get_response_rate - get basic rate for a given rate\n *\n * @sband: the band to look for rates in\n * @basic_rates: bitmap of basic rates\n * @bitrate: the bitrate for which to find the basic rate\n *\n * Return: The basic rate corresponding to a given bitrate, that\n * is the next lower bitrate contained in the basic rate map,\n * which is, for this function, given as a bitmap of indices of\n * rates in the band's bitrate table.\n */\nstruct ieee80211_rate *\nieee80211_get_response_rate(struct ieee80211_supported_band *sband,\n\t\t\t    u32 basic_rates, int bitrate);\n\n/**\n * ieee80211_mandatory_rates - get mandatory rates for a given band\n * @sband: the band to look for rates in\n * @scan_width: width of the control channel\n *\n * This function returns a bitmap of the mandatory rates for the given\n * band, bits are set according to the rate position in the bitrates array.\n */\nu32 ieee80211_mandatory_rates(struct ieee80211_supported_band *sband,\n\t\t\t      enum nl80211_bss_scan_width scan_width);\n\n/*\n * Radiotap parsing functions -- for controlled injection support\n *\n * Implemented in net/wireless/radiotap.c\n * Documentation in Documentation/networking/radiotap-headers.rst\n */\n\nstruct radiotap_align_size {\n\tuint8_t align:4, size:4;\n};\n\nstruct ieee80211_radiotap_namespace {\n\tconst struct radiotap_align_size *align_size;\n\tint n_bits;\n\tuint32_t oui;\n\tuint8_t subns;\n};\n\nstruct ieee80211_radiotap_vendor_namespaces {\n\tconst struct ieee80211_radiotap_namespace *ns;\n\tint n_ns;\n};\n\n/**\n * struct ieee80211_radiotap_iterator - tracks walk thru present radiotap args\n * @this_arg_index: index of current arg, valid after each successful call\n *\tto ieee80211_radiotap_iterator_next()\n * @this_arg: pointer to current radiotap arg; it is valid after each\n *\tcall to ieee80211_radiotap_iterator_next() but also after\n *\tieee80211_radiotap_iterator_init() where it will point to\n *\tthe beginning of the actual data portion\n * @this_arg_size: length of the current arg, for convenience\n * @current_namespace: pointer to the current namespace definition\n *\t(or internally %NULL if the current namespace is unknown)\n * @is_radiotap_ns: indicates whether the current namespace is the default\n *\tradiotap namespace or not\n *\n * @_rtheader: pointer to the radiotap header we are walking through\n * @_max_length: length of radiotap header in cpu byte ordering\n * @_arg_index: next argument index\n * @_arg: next argument pointer\n * @_next_bitmap: internal pointer to next present u32\n * @_bitmap_shifter: internal shifter for curr u32 bitmap, b0 set == arg present\n * @_vns: vendor namespace definitions\n * @_next_ns_data: beginning of the next namespace's data\n * @_reset_on_ext: internal; reset the arg index to 0 when going to the\n *\tnext bitmap word\n *\n * Describes the radiotap parser state. Fields prefixed with an underscore\n * must not be used by users of the parser, only by the parser internally.\n */\n\nstruct ieee80211_radiotap_iterator {\n\tstruct ieee80211_radiotap_header *_rtheader;\n\tconst struct ieee80211_radiotap_vendor_namespaces *_vns;\n\tconst struct ieee80211_radiotap_namespace *current_namespace;\n\n\tunsigned char *_arg, *_next_ns_data;\n\t__le32 *_next_bitmap;\n\n\tunsigned char *this_arg;\n\tint this_arg_index;\n\tint this_arg_size;\n\n\tint is_radiotap_ns;\n\n\tint _max_length;\n\tint _arg_index;\n\tuint32_t _bitmap_shifter;\n\tint _reset_on_ext;\n};\n\nint\nieee80211_radiotap_iterator_init(struct ieee80211_radiotap_iterator *iterator,\n\t\t\t\t struct ieee80211_radiotap_header *radiotap_header,\n\t\t\t\t int max_length,\n\t\t\t\t const struct ieee80211_radiotap_vendor_namespaces *vns);\n\nint\nieee80211_radiotap_iterator_next(struct ieee80211_radiotap_iterator *iterator);\n\n\nextern const unsigned char rfc1042_header[6];\nextern const unsigned char bridge_tunnel_header[6];\n\n/**\n * ieee80211_get_hdrlen_from_skb - get header length from data\n *\n * @skb: the frame\n *\n * Given an skb with a raw 802.11 header at the data pointer this function\n * returns the 802.11 header length.\n *\n * Return: The 802.11 header length in bytes (not including encryption\n * headers). Or 0 if the data in the sk_buff is too short to contain a valid\n * 802.11 header.\n */\nunsigned int ieee80211_get_hdrlen_from_skb(const struct sk_buff *skb);\n\n/**\n * ieee80211_hdrlen - get header length in bytes from frame control\n * @fc: frame control field in little-endian format\n * Return: The header length in bytes.\n */\nunsigned int __attribute_const__ ieee80211_hdrlen(__le16 fc);\n\n/**\n * ieee80211_get_mesh_hdrlen - get mesh extension header length\n * @meshhdr: the mesh extension header, only the flags field\n *\t(first byte) will be accessed\n * Return: The length of the extension header, which is always at\n * least 6 bytes and at most 18 if address 5 and 6 are present.\n */\nunsigned int ieee80211_get_mesh_hdrlen(struct ieee80211s_hdr *meshhdr);\n\n/**\n * DOC: Data path helpers\n *\n * In addition to generic utilities, cfg80211 also offers\n * functions that help implement the data path for devices\n * that do not do the 802.11/802.3 conversion on the device.\n */\n\n/**\n * ieee80211_data_to_8023_exthdr - convert an 802.11 data frame to 802.3\n * @skb: the 802.11 data frame\n * @ehdr: pointer to a &struct ethhdr that will get the header, instead\n *\tof it being pushed into the SKB\n * @addr: the device MAC address\n * @iftype: the virtual interface type\n * @data_offset: offset of payload after the 802.11 header\n * Return: 0 on success. Non-zero on error.\n */\nint ieee80211_data_to_8023_exthdr(struct sk_buff *skb, struct ethhdr *ehdr,\n\t\t\t\t  const u8 *addr, enum nl80211_iftype iftype,\n\t\t\t\t  u8 data_offset);\n\n/**\n * ieee80211_data_to_8023 - convert an 802.11 data frame to 802.3\n * @skb: the 802.11 data frame\n * @addr: the device MAC address\n * @iftype: the virtual interface type\n * Return: 0 on success. Non-zero on error.\n */\nstatic inline int ieee80211_data_to_8023(struct sk_buff *skb, const u8 *addr,\n\t\t\t\t\t enum nl80211_iftype iftype)\n{\n\treturn ieee80211_data_to_8023_exthdr(skb, NULL, addr, iftype, 0);\n}\n\n/**\n * ieee80211_amsdu_to_8023s - decode an IEEE 802.11n A-MSDU frame\n *\n * Decode an IEEE 802.11 A-MSDU and convert it to a list of 802.3 frames.\n * The @list will be empty if the decode fails. The @skb must be fully\n * header-less before being passed in here; it is freed in this function.\n *\n * @skb: The input A-MSDU frame without any headers.\n * @list: The output list of 802.3 frames. It must be allocated and\n *\tinitialized by the caller.\n * @addr: The device MAC address.\n * @iftype: The device interface type.\n * @extra_headroom: The hardware extra headroom for SKBs in the @list.\n * @check_da: DA to check in the inner ethernet header, or NULL\n * @check_sa: SA to check in the inner ethernet header, or NULL\n */\nvoid ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,\n\t\t\t      const u8 *addr, enum nl80211_iftype iftype,\n\t\t\t      const unsigned int extra_headroom,\n\t\t\t      const u8 *check_da, const u8 *check_sa);\n\n/**\n * cfg80211_classify8021d - determine the 802.1p/1d tag for a data frame\n * @skb: the data frame\n * @qos_map: Interworking QoS mapping or %NULL if not in use\n * Return: The 802.1p/1d tag.\n */\nunsigned int cfg80211_classify8021d(struct sk_buff *skb,\n\t\t\t\t    struct cfg80211_qos_map *qos_map);\n\n/**\n * cfg80211_find_elem_match - match information element and byte array in data\n *\n * @eid: element ID\n * @ies: data consisting of IEs\n * @len: length of data\n * @match: byte array to match\n * @match_len: number of bytes in the match array\n * @match_offset: offset in the IE data where the byte array should match.\n *\tNote the difference to cfg80211_find_ie_match() which considers\n *\tthe offset to start from the element ID byte, but here we take\n *\tthe data portion instead.\n *\n * Return: %NULL if the element ID could not be found or if\n * the element is invalid (claims to be longer than the given\n * data) or if the byte array doesn't match; otherwise return the\n * requested element struct.\n *\n * Note: There are no checks on the element length other than\n * having to fit into the given data and being large enough for the\n * byte array to match.\n */\nconst struct element *\ncfg80211_find_elem_match(u8 eid, const u8 *ies, unsigned int len,\n\t\t\t const u8 *match, unsigned int match_len,\n\t\t\t unsigned int match_offset);\n\n/**\n * cfg80211_find_ie_match - match information element and byte array in data\n *\n * @eid: element ID\n * @ies: data consisting of IEs\n * @len: length of data\n * @match: byte array to match\n * @match_len: number of bytes in the match array\n * @match_offset: offset in the IE where the byte array should match.\n *\tIf match_len is zero, this must also be set to zero.\n *\tOtherwise this must be set to 2 or more, because the first\n *\tbyte is the element id, which is already compared to eid, and\n *\tthe second byte is the IE length.\n *\n * Return: %NULL if the element ID could not be found or if\n * the element is invalid (claims to be longer than the given\n * data) or if the byte array doesn't match, or a pointer to the first\n * byte of the requested element, that is the byte containing the\n * element ID.\n *\n * Note: There are no checks on the element length other than\n * having to fit into the given data and being large enough for the\n * byte array to match.\n */\nstatic inline const u8 *\ncfg80211_find_ie_match(u8 eid, const u8 *ies, unsigned int len,\n\t\t       const u8 *match, unsigned int match_len,\n\t\t       unsigned int match_offset)\n{\n\t/* match_offset can't be smaller than 2, unless match_len is\n\t * zero, in which case match_offset must be zero as well.\n\t */\n\tif (WARN_ON((match_len && match_offset < 2) ||\n\t\t    (!match_len && match_offset)))\n\t\treturn NULL;\n\n\treturn (void *)cfg80211_find_elem_match(eid, ies, len,\n\t\t\t\t\t\tmatch, match_len,\n\t\t\t\t\t\tmatch_offset ?\n\t\t\t\t\t\t\tmatch_offset - 2 : 0);\n}\n\n/**\n * cfg80211_find_elem - find information element in data\n *\n * @eid: element ID\n * @ies: data consisting of IEs\n * @len: length of data\n *\n * Return: %NULL if the element ID could not be found or if\n * the element is invalid (claims to be longer than the given\n * data) or if the byte array doesn't match; otherwise return the\n * requested element struct.\n *\n * Note: There are no checks on the element length other than\n * having to fit into the given data.\n */\nstatic inline const struct element *\ncfg80211_find_elem(u8 eid, const u8 *ies, int len)\n{\n\treturn cfg80211_find_elem_match(eid, ies, len, NULL, 0, 0);\n}\n\n/**\n * cfg80211_find_ie - find information element in data\n *\n * @eid: element ID\n * @ies: data consisting of IEs\n * @len: length of data\n *\n * Return: %NULL if the element ID could not be found or if\n * the element is invalid (claims to be longer than the given\n * data), or a pointer to the first byte of the requested\n * element, that is the byte containing the element ID.\n *\n * Note: There are no checks on the element length other than\n * having to fit into the given data.\n */\nstatic inline const u8 *cfg80211_find_ie(u8 eid, const u8 *ies, int len)\n{\n\treturn cfg80211_find_ie_match(eid, ies, len, NULL, 0, 0);\n}\n\n/**\n * cfg80211_find_ext_elem - find information element with EID Extension in data\n *\n * @ext_eid: element ID Extension\n * @ies: data consisting of IEs\n * @len: length of data\n *\n * Return: %NULL if the etended element could not be found or if\n * the element is invalid (claims to be longer than the given\n * data) or if the byte array doesn't match; otherwise return the\n * requested element struct.\n *\n * Note: There are no checks on the element length other than\n * having to fit into the given data.\n */\nstatic inline const struct element *\ncfg80211_find_ext_elem(u8 ext_eid, const u8 *ies, int len)\n{\n\treturn cfg80211_find_elem_match(WLAN_EID_EXTENSION, ies, len,\n\t\t\t\t\t&ext_eid, 1, 0);\n}\n\n/**\n * cfg80211_find_ext_ie - find information element with EID Extension in data\n *\n * @ext_eid: element ID Extension\n * @ies: data consisting of IEs\n * @len: length of data\n *\n * Return: %NULL if the extended element ID could not be found or if\n * the element is invalid (claims to be longer than the given\n * data), or a pointer to the first byte of the requested\n * element, that is the byte containing the element ID.\n *\n * Note: There are no checks on the element length other than\n * having to fit into the given data.\n */\nstatic inline const u8 *cfg80211_find_ext_ie(u8 ext_eid, const u8 *ies, int len)\n{\n\treturn cfg80211_find_ie_match(WLAN_EID_EXTENSION, ies, len,\n\t\t\t\t      &ext_eid, 1, 2);\n}\n\n/**\n * cfg80211_find_vendor_elem - find vendor specific information element in data\n *\n * @oui: vendor OUI\n * @oui_type: vendor-specific OUI type (must be < 0xff), negative means any\n * @ies: data consisting of IEs\n * @len: length of data\n *\n * Return: %NULL if the vendor specific element ID could not be found or if the\n * element is invalid (claims to be longer than the given data); otherwise\n * return the element structure for the requested element.\n *\n * Note: There are no checks on the element length other than having to fit into\n * the given data.\n */\nconst struct element *cfg80211_find_vendor_elem(unsigned int oui, int oui_type,\n\t\t\t\t\t\tconst u8 *ies,\n\t\t\t\t\t\tunsigned int len);\n\n/**\n * cfg80211_find_vendor_ie - find vendor specific information element in data\n *\n * @oui: vendor OUI\n * @oui_type: vendor-specific OUI type (must be < 0xff), negative means any\n * @ies: data consisting of IEs\n * @len: length of data\n *\n * Return: %NULL if the vendor specific element ID could not be found or if the\n * element is invalid (claims to be longer than the given data), or a pointer to\n * the first byte of the requested element, that is the byte containing the\n * element ID.\n *\n * Note: There are no checks on the element length other than having to fit into\n * the given data.\n */\nstatic inline const u8 *\ncfg80211_find_vendor_ie(unsigned int oui, int oui_type,\n\t\t\tconst u8 *ies, unsigned int len)\n{\n\treturn (void *)cfg80211_find_vendor_elem(oui, oui_type, ies, len);\n}\n\n/**\n * cfg80211_send_layer2_update - send layer 2 update frame\n *\n * @dev: network device\n * @addr: STA MAC address\n *\n * Wireless drivers can use this function to update forwarding tables in bridge\n * devices upon STA association.\n */\nvoid cfg80211_send_layer2_update(struct net_device *dev, const u8 *addr);\n\n/**\n * DOC: Regulatory enforcement infrastructure\n *\n * TODO\n */\n\n/**\n * regulatory_hint - driver hint to the wireless core a regulatory domain\n * @wiphy: the wireless device giving the hint (used only for reporting\n *\tconflicts)\n * @alpha2: the ISO/IEC 3166 alpha2 the driver claims its regulatory domain\n *\tshould be in. If @rd is set this should be NULL. Note that if you\n *\tset this to NULL you should still set rd->alpha2 to some accepted\n *\talpha2.\n *\n * Wireless drivers can use this function to hint to the wireless core\n * what it believes should be the current regulatory domain by\n * giving it an ISO/IEC 3166 alpha2 country code it knows its regulatory\n * domain should be in or by providing a completely build regulatory domain.\n * If the driver provides an ISO/IEC 3166 alpha2 userspace will be queried\n * for a regulatory domain structure for the respective country.\n *\n * The wiphy must have been registered to cfg80211 prior to this call.\n * For cfg80211 drivers this means you must first use wiphy_register(),\n * for mac80211 drivers you must first use ieee80211_register_hw().\n *\n * Drivers should check the return value, its possible you can get\n * an -ENOMEM.\n *\n * Return: 0 on success. -ENOMEM.\n */\nint regulatory_hint(struct wiphy *wiphy, const char *alpha2);\n\n/**\n * regulatory_set_wiphy_regd - set regdom info for self managed drivers\n * @wiphy: the wireless device we want to process the regulatory domain on\n * @rd: the regulatory domain informatoin to use for this wiphy\n *\n * Set the regulatory domain information for self-managed wiphys, only they\n * may use this function. See %REGULATORY_WIPHY_SELF_MANAGED for more\n * information.\n *\n * Return: 0 on success. -EINVAL, -EPERM\n */\nint regulatory_set_wiphy_regd(struct wiphy *wiphy,\n\t\t\t      struct ieee80211_regdomain *rd);\n\n/**\n * regulatory_set_wiphy_regd_sync - set regdom for self-managed drivers\n * @wiphy: the wireless device we want to process the regulatory domain on\n * @rd: the regulatory domain information to use for this wiphy\n *\n * This functions requires the RTNL and the wiphy mutex to be held and\n * applies the new regdomain synchronously to this wiphy. For more details\n * see regulatory_set_wiphy_regd().\n *\n * Return: 0 on success. -EINVAL, -EPERM\n */\nint regulatory_set_wiphy_regd_sync(struct wiphy *wiphy,\n\t\t\t\t   struct ieee80211_regdomain *rd);\n\n/**\n * wiphy_apply_custom_regulatory - apply a custom driver regulatory domain\n * @wiphy: the wireless device we want to process the regulatory domain on\n * @regd: the custom regulatory domain to use for this wiphy\n *\n * Drivers can sometimes have custom regulatory domains which do not apply\n * to a specific country. Drivers can use this to apply such custom regulatory\n * domains. This routine must be called prior to wiphy registration. The\n * custom regulatory domain will be trusted completely and as such previous\n * default channel settings will be disregarded. If no rule is found for a\n * channel on the regulatory domain the channel will be disabled.\n * Drivers using this for a wiphy should also set the wiphy flag\n * REGULATORY_CUSTOM_REG or cfg80211 will set it for the wiphy\n * that called this helper.\n */\nvoid wiphy_apply_custom_regulatory(struct wiphy *wiphy,\n\t\t\t\t   const struct ieee80211_regdomain *regd);\n\n/**\n * freq_reg_info - get regulatory information for the given frequency\n * @wiphy: the wiphy for which we want to process this rule for\n * @center_freq: Frequency in KHz for which we want regulatory information for\n *\n * Use this function to get the regulatory rule for a specific frequency on\n * a given wireless device. If the device has a specific regulatory domain\n * it wants to follow we respect that unless a country IE has been received\n * and processed already.\n *\n * Return: A valid pointer, or, when an error occurs, for example if no rule\n * can be found, the return value is encoded using ERR_PTR(). Use IS_ERR() to\n * check and PTR_ERR() to obtain the numeric return value. The numeric return\n * value will be -ERANGE if we determine the given center_freq does not even\n * have a regulatory rule for a frequency range in the center_freq's band.\n * See freq_in_rule_band() for our current definition of a band -- this is\n * purely subjective and right now it's 802.11 specific.\n */\nconst struct ieee80211_reg_rule *freq_reg_info(struct wiphy *wiphy,\n\t\t\t\t\t       u32 center_freq);\n\n/**\n * reg_initiator_name - map regulatory request initiator enum to name\n * @initiator: the regulatory request initiator\n *\n * You can use this to map the regulatory request initiator enum to a\n * proper string representation.\n */\nconst char *reg_initiator_name(enum nl80211_reg_initiator initiator);\n\n/**\n * regulatory_pre_cac_allowed - check if pre-CAC allowed in the current regdom\n * @wiphy: wiphy for which pre-CAC capability is checked.\n *\n * Pre-CAC is allowed only in some regdomains (notable ETSI).\n */\nbool regulatory_pre_cac_allowed(struct wiphy *wiphy);\n\n/**\n * DOC: Internal regulatory db functions\n *\n */\n\n/**\n * reg_query_regdb_wmm -  Query internal regulatory db for wmm rule\n * Regulatory self-managed driver can use it to proactively\n *\n * @alpha2: the ISO/IEC 3166 alpha2 wmm rule to be queried.\n * @freq: the freqency(in MHz) to be queried.\n * @rule: pointer to store the wmm rule from the regulatory db.\n *\n * Self-managed wireless drivers can use this function to  query\n * the internal regulatory database to check whether the given\n * ISO/IEC 3166 alpha2 country and freq have wmm rule limitations.\n *\n * Drivers should check the return value, its possible you can get\n * an -ENODATA.\n *\n * Return: 0 on success. -ENODATA.\n */\nint reg_query_regdb_wmm(char *alpha2, int freq,\n\t\t\tstruct ieee80211_reg_rule *rule);\n\n/*\n * callbacks for asynchronous cfg80211 methods, notification\n * functions and BSS handling helpers\n */\n\n/**\n * cfg80211_scan_done - notify that scan finished\n *\n * @request: the corresponding scan request\n * @info: information about the completed scan\n */\nvoid cfg80211_scan_done(struct cfg80211_scan_request *request,\n\t\t\tstruct cfg80211_scan_info *info);\n\n/**\n * cfg80211_sched_scan_results - notify that new scan results are available\n *\n * @wiphy: the wiphy which got scheduled scan results\n * @reqid: identifier for the related scheduled scan request\n */\nvoid cfg80211_sched_scan_results(struct wiphy *wiphy, u64 reqid);\n\n/**\n * cfg80211_sched_scan_stopped - notify that the scheduled scan has stopped\n *\n * @wiphy: the wiphy on which the scheduled scan stopped\n * @reqid: identifier for the related scheduled scan request\n *\n * The driver can call this function to inform cfg80211 that the\n * scheduled scan had to be stopped, for whatever reason.  The driver\n * is then called back via the sched_scan_stop operation when done.\n */\nvoid cfg80211_sched_scan_stopped(struct wiphy *wiphy, u64 reqid);\n\n/**\n * cfg80211_sched_scan_stopped_locked - notify that the scheduled scan has stopped\n *\n * @wiphy: the wiphy on which the scheduled scan stopped\n * @reqid: identifier for the related scheduled scan request\n *\n * The driver can call this function to inform cfg80211 that the\n * scheduled scan had to be stopped, for whatever reason.  The driver\n * is then called back via the sched_scan_stop operation when done.\n * This function should be called with the wiphy mutex held.\n */\nvoid cfg80211_sched_scan_stopped_locked(struct wiphy *wiphy, u64 reqid);\n\n/**\n * cfg80211_inform_bss_frame_data - inform cfg80211 of a received BSS frame\n * @wiphy: the wiphy reporting the BSS\n * @data: the BSS metadata\n * @mgmt: the management frame (probe response or beacon)\n * @len: length of the management frame\n * @gfp: context flags\n *\n * This informs cfg80211 that BSS information was found and\n * the BSS should be updated/added.\n *\n * Return: A referenced struct, must be released with cfg80211_put_bss()!\n * Or %NULL on error.\n */\nstruct cfg80211_bss * __must_check\ncfg80211_inform_bss_frame_data(struct wiphy *wiphy,\n\t\t\t       struct cfg80211_inform_bss *data,\n\t\t\t       struct ieee80211_mgmt *mgmt, size_t len,\n\t\t\t       gfp_t gfp);\n\nstatic inline struct cfg80211_bss * __must_check\ncfg80211_inform_bss_width_frame(struct wiphy *wiphy,\n\t\t\t\tstruct ieee80211_channel *rx_channel,\n\t\t\t\tenum nl80211_bss_scan_width scan_width,\n\t\t\t\tstruct ieee80211_mgmt *mgmt, size_t len,\n\t\t\t\ts32 signal, gfp_t gfp)\n{\n\tstruct cfg80211_inform_bss data = {\n\t\t.chan = rx_channel,\n\t\t.scan_width = scan_width,\n\t\t.signal = signal,\n\t};\n\n\treturn cfg80211_inform_bss_frame_data(wiphy, &data, mgmt, len, gfp);\n}\n\nstatic inline struct cfg80211_bss * __must_check\ncfg80211_inform_bss_frame(struct wiphy *wiphy,\n\t\t\t  struct ieee80211_channel *rx_channel,\n\t\t\t  struct ieee80211_mgmt *mgmt, size_t len,\n\t\t\t  s32 signal, gfp_t gfp)\n{\n\tstruct cfg80211_inform_bss data = {\n\t\t.chan = rx_channel,\n\t\t.scan_width = NL80211_BSS_CHAN_WIDTH_20,\n\t\t.signal = signal,\n\t};\n\n\treturn cfg80211_inform_bss_frame_data(wiphy, &data, mgmt, len, gfp);\n}\n\n/**\n * cfg80211_gen_new_bssid - generate a nontransmitted BSSID for multi-BSSID\n * @bssid: transmitter BSSID\n * @max_bssid: max BSSID indicator, taken from Multiple BSSID element\n * @mbssid_index: BSSID index, taken from Multiple BSSID index element\n * @new_bssid: calculated nontransmitted BSSID\n */\nstatic inline void cfg80211_gen_new_bssid(const u8 *bssid, u8 max_bssid,\n\t\t\t\t\t  u8 mbssid_index, u8 *new_bssid)\n{\n\tu64 bssid_u64 = ether_addr_to_u64(bssid);\n\tu64 mask = GENMASK_ULL(max_bssid - 1, 0);\n\tu64 new_bssid_u64;\n\n\tnew_bssid_u64 = bssid_u64 & ~mask;\n\n\tnew_bssid_u64 |= ((bssid_u64 & mask) + mbssid_index) & mask;\n\n\tu64_to_ether_addr(new_bssid_u64, new_bssid);\n}\n\n/**\n * cfg80211_is_element_inherited - returns if element ID should be inherited\n * @element: element to check\n * @non_inherit_element: non inheritance element\n */\nbool cfg80211_is_element_inherited(const struct element *element,\n\t\t\t\t   const struct element *non_inherit_element);\n\n/**\n * cfg80211_merge_profile - merges a MBSSID profile if it is split between IEs\n * @ie: ies\n * @ielen: length of IEs\n * @mbssid_elem: current MBSSID element\n * @sub_elem: current MBSSID subelement (profile)\n * @merged_ie: location of the merged profile\n * @max_copy_len: max merged profile length\n */\nsize_t cfg80211_merge_profile(const u8 *ie, size_t ielen,\n\t\t\t      const struct element *mbssid_elem,\n\t\t\t      const struct element *sub_elem,\n\t\t\t      u8 *merged_ie, size_t max_copy_len);\n\n/**\n * enum cfg80211_bss_frame_type - frame type that the BSS data came from\n * @CFG80211_BSS_FTYPE_UNKNOWN: driver doesn't know whether the data is\n *\tfrom a beacon or probe response\n * @CFG80211_BSS_FTYPE_BEACON: data comes from a beacon\n * @CFG80211_BSS_FTYPE_PRESP: data comes from a probe response\n */\nenum cfg80211_bss_frame_type {\n\tCFG80211_BSS_FTYPE_UNKNOWN,\n\tCFG80211_BSS_FTYPE_BEACON,\n\tCFG80211_BSS_FTYPE_PRESP,\n};\n\n/**\n * cfg80211_inform_bss_data - inform cfg80211 of a new BSS\n *\n * @wiphy: the wiphy reporting the BSS\n * @data: the BSS metadata\n * @ftype: frame type (if known)\n * @bssid: the BSSID of the BSS\n * @tsf: the TSF sent by the peer in the beacon/probe response (or 0)\n * @capability: the capability field sent by the peer\n * @beacon_interval: the beacon interval announced by the peer\n * @ie: additional IEs sent by the peer\n * @ielen: length of the additional IEs\n * @gfp: context flags\n *\n * This informs cfg80211 that BSS information was found and\n * the BSS should be updated/added.\n *\n * Return: A referenced struct, must be released with cfg80211_put_bss()!\n * Or %NULL on error.\n */\nstruct cfg80211_bss * __must_check\ncfg80211_inform_bss_data(struct wiphy *wiphy,\n\t\t\t struct cfg80211_inform_bss *data,\n\t\t\t enum cfg80211_bss_frame_type ftype,\n\t\t\t const u8 *bssid, u64 tsf, u16 capability,\n\t\t\t u16 beacon_interval, const u8 *ie, size_t ielen,\n\t\t\t gfp_t gfp);\n\nstatic inline struct cfg80211_bss * __must_check\ncfg80211_inform_bss_width(struct wiphy *wiphy,\n\t\t\t  struct ieee80211_channel *rx_channel,\n\t\t\t  enum nl80211_bss_scan_width scan_width,\n\t\t\t  enum cfg80211_bss_frame_type ftype,\n\t\t\t  const u8 *bssid, u64 tsf, u16 capability,\n\t\t\t  u16 beacon_interval, const u8 *ie, size_t ielen,\n\t\t\t  s32 signal, gfp_t gfp)\n{\n\tstruct cfg80211_inform_bss data = {\n\t\t.chan = rx_channel,\n\t\t.scan_width = scan_width,\n\t\t.signal = signal,\n\t};\n\n\treturn cfg80211_inform_bss_data(wiphy, &data, ftype, bssid, tsf,\n\t\t\t\t\tcapability, beacon_interval, ie, ielen,\n\t\t\t\t\tgfp);\n}\n\nstatic inline struct cfg80211_bss * __must_check\ncfg80211_inform_bss(struct wiphy *wiphy,\n\t\t    struct ieee80211_channel *rx_channel,\n\t\t    enum cfg80211_bss_frame_type ftype,\n\t\t    const u8 *bssid, u64 tsf, u16 capability,\n\t\t    u16 beacon_interval, const u8 *ie, size_t ielen,\n\t\t    s32 signal, gfp_t gfp)\n{\n\tstruct cfg80211_inform_bss data = {\n\t\t.chan = rx_channel,\n\t\t.scan_width = NL80211_BSS_CHAN_WIDTH_20,\n\t\t.signal = signal,\n\t};\n\n\treturn cfg80211_inform_bss_data(wiphy, &data, ftype, bssid, tsf,\n\t\t\t\t\tcapability, beacon_interval, ie, ielen,\n\t\t\t\t\tgfp);\n}\n\n/**\n * cfg80211_get_bss - get a BSS reference\n * @wiphy: the wiphy this BSS struct belongs to\n * @channel: the channel to search on (or %NULL)\n * @bssid: the desired BSSID (or %NULL)\n * @ssid: the desired SSID (or %NULL)\n * @ssid_len: length of the SSID (or 0)\n * @bss_type: type of BSS, see &enum ieee80211_bss_type\n * @privacy: privacy filter, see &enum ieee80211_privacy\n */\nstruct cfg80211_bss *cfg80211_get_bss(struct wiphy *wiphy,\n\t\t\t\t      struct ieee80211_channel *channel,\n\t\t\t\t      const u8 *bssid,\n\t\t\t\t      const u8 *ssid, size_t ssid_len,\n\t\t\t\t      enum ieee80211_bss_type bss_type,\n\t\t\t\t      enum ieee80211_privacy privacy);\nstatic inline struct cfg80211_bss *\ncfg80211_get_ibss(struct wiphy *wiphy,\n\t\t  struct ieee80211_channel *channel,\n\t\t  const u8 *ssid, size_t ssid_len)\n{\n\treturn cfg80211_get_bss(wiphy, channel, NULL, ssid, ssid_len,\n\t\t\t\tIEEE80211_BSS_TYPE_IBSS,\n\t\t\t\tIEEE80211_PRIVACY_ANY);\n}\n\n/**\n * cfg80211_ref_bss - reference BSS struct\n * @wiphy: the wiphy this BSS struct belongs to\n * @bss: the BSS struct to reference\n *\n * Increments the refcount of the given BSS struct.\n */\nvoid cfg80211_ref_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);\n\n/**\n * cfg80211_put_bss - unref BSS struct\n * @wiphy: the wiphy this BSS struct belongs to\n * @bss: the BSS struct\n *\n * Decrements the refcount of the given BSS struct.\n */\nvoid cfg80211_put_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);\n\n/**\n * cfg80211_unlink_bss - unlink BSS from internal data structures\n * @wiphy: the wiphy\n * @bss: the bss to remove\n *\n * This function removes the given BSS from the internal data structures\n * thereby making it no longer show up in scan results etc. Use this\n * function when you detect a BSS is gone. Normally BSSes will also time\n * out, so it is not necessary to use this function at all.\n */\nvoid cfg80211_unlink_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);\n\n/**\n * cfg80211_bss_iter - iterate all BSS entries\n *\n * This function iterates over the BSS entries associated with the given wiphy\n * and calls the callback for the iterated BSS. The iterator function is not\n * allowed to call functions that might modify the internal state of the BSS DB.\n *\n * @wiphy: the wiphy\n * @chandef: if given, the iterator function will be called only if the channel\n *     of the currently iterated BSS is a subset of the given channel.\n * @iter: the iterator function to call\n * @iter_data: an argument to the iterator function\n */\nvoid cfg80211_bss_iter(struct wiphy *wiphy,\n\t\t       struct cfg80211_chan_def *chandef,\n\t\t       void (*iter)(struct wiphy *wiphy,\n\t\t\t\t    struct cfg80211_bss *bss,\n\t\t\t\t    void *data),\n\t\t       void *iter_data);\n\nstatic inline enum nl80211_bss_scan_width\ncfg80211_chandef_to_scan_width(const struct cfg80211_chan_def *chandef)\n{\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\t\treturn NL80211_BSS_CHAN_WIDTH_5;\n\tcase NL80211_CHAN_WIDTH_10:\n\t\treturn NL80211_BSS_CHAN_WIDTH_10;\n\tdefault:\n\t\treturn NL80211_BSS_CHAN_WIDTH_20;\n\t}\n}\n\n/**\n * cfg80211_rx_mlme_mgmt - notification of processed MLME management frame\n * @dev: network device\n * @buf: authentication frame (header + body)\n * @len: length of the frame data\n *\n * This function is called whenever an authentication, disassociation or\n * deauthentication frame has been received and processed in station mode.\n * After being asked to authenticate via cfg80211_ops::auth() the driver must\n * call either this function or cfg80211_auth_timeout().\n * After being asked to associate via cfg80211_ops::assoc() the driver must\n * call either this function or cfg80211_auth_timeout().\n * While connected, the driver must calls this for received and processed\n * disassociation and deauthentication frames. If the frame couldn't be used\n * because it was unprotected, the driver must call the function\n * cfg80211_rx_unprot_mlme_mgmt() instead.\n *\n * This function may sleep. The caller must hold the corresponding wdev's mutex.\n */\nvoid cfg80211_rx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len);\n\n/**\n * cfg80211_auth_timeout - notification of timed out authentication\n * @dev: network device\n * @addr: The MAC address of the device with which the authentication timed out\n *\n * This function may sleep. The caller must hold the corresponding wdev's\n * mutex.\n */\nvoid cfg80211_auth_timeout(struct net_device *dev, const u8 *addr);\n\n/**\n * cfg80211_rx_assoc_resp - notification of processed association response\n * @dev: network device\n * @bss: the BSS that association was requested with, ownership of the pointer\n *\tmoves to cfg80211 in this call\n * @buf: (Re)Association Response frame (header + body)\n * @len: length of the frame data\n * @uapsd_queues: bitmap of queues configured for uapsd. Same format\n *\tas the AC bitmap in the QoS info field\n * @req_ies: information elements from the (Re)Association Request frame\n * @req_ies_len: length of req_ies data\n *\n * After being asked to associate via cfg80211_ops::assoc() the driver must\n * call either this function or cfg80211_auth_timeout().\n *\n * This function may sleep. The caller must hold the corresponding wdev's mutex.\n */\nvoid cfg80211_rx_assoc_resp(struct net_device *dev,\n\t\t\t    struct cfg80211_bss *bss,\n\t\t\t    const u8 *buf, size_t len,\n\t\t\t    int uapsd_queues,\n\t\t\t    const u8 *req_ies, size_t req_ies_len);\n\n/**\n * cfg80211_assoc_timeout - notification of timed out association\n * @dev: network device\n * @bss: The BSS entry with which association timed out.\n *\n * This function may sleep. The caller must hold the corresponding wdev's mutex.\n */\nvoid cfg80211_assoc_timeout(struct net_device *dev, struct cfg80211_bss *bss);\n\n/**\n * cfg80211_abandon_assoc - notify cfg80211 of abandoned association attempt\n * @dev: network device\n * @bss: The BSS entry with which association was abandoned.\n *\n * Call this whenever - for reasons reported through other API, like deauth RX,\n * an association attempt was abandoned.\n * This function may sleep. The caller must hold the corresponding wdev's mutex.\n */\nvoid cfg80211_abandon_assoc(struct net_device *dev, struct cfg80211_bss *bss);\n\n/**\n * cfg80211_tx_mlme_mgmt - notification of transmitted deauth/disassoc frame\n * @dev: network device\n * @buf: 802.11 frame (header + body)\n * @len: length of the frame data\n * @reconnect: immediate reconnect is desired (include the nl80211 attribute)\n *\n * This function is called whenever deauthentication has been processed in\n * station mode. This includes both received deauthentication frames and\n * locally generated ones. This function may sleep. The caller must hold the\n * corresponding wdev's mutex.\n */\nvoid cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len,\n\t\t\t   bool reconnect);\n\n/**\n * cfg80211_rx_unprot_mlme_mgmt - notification of unprotected mlme mgmt frame\n * @dev: network device\n * @buf: received management frame (header + body)\n * @len: length of the frame data\n *\n * This function is called whenever a received deauthentication or dissassoc\n * frame has been dropped in station mode because of MFP being used but the\n * frame was not protected. This is also used to notify reception of a Beacon\n * frame that was dropped because it did not include a valid MME MIC while\n * beacon protection was enabled (BIGTK configured in station mode).\n *\n * This function may sleep.\n */\nvoid cfg80211_rx_unprot_mlme_mgmt(struct net_device *dev,\n\t\t\t\t  const u8 *buf, size_t len);\n\n/**\n * cfg80211_michael_mic_failure - notification of Michael MIC failure (TKIP)\n * @dev: network device\n * @addr: The source MAC address of the frame\n * @key_type: The key type that the received frame used\n * @key_id: Key identifier (0..3). Can be -1 if missing.\n * @tsc: The TSC value of the frame that generated the MIC failure (6 octets)\n * @gfp: allocation flags\n *\n * This function is called whenever the local MAC detects a MIC failure in a\n * received frame. This matches with MLME-MICHAELMICFAILURE.indication()\n * primitive.\n */\nvoid cfg80211_michael_mic_failure(struct net_device *dev, const u8 *addr,\n\t\t\t\t  enum nl80211_key_type key_type, int key_id,\n\t\t\t\t  const u8 *tsc, gfp_t gfp);\n\n/**\n * cfg80211_ibss_joined - notify cfg80211 that device joined an IBSS\n *\n * @dev: network device\n * @bssid: the BSSID of the IBSS joined\n * @channel: the channel of the IBSS joined\n * @gfp: allocation flags\n *\n * This function notifies cfg80211 that the device joined an IBSS or\n * switched to a different BSSID. Before this function can be called,\n * either a beacon has to have been received from the IBSS, or one of\n * the cfg80211_inform_bss{,_frame} functions must have been called\n * with the locally generated beacon -- this guarantees that there is\n * always a scan result for this IBSS. cfg80211 will handle the rest.\n */\nvoid cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,\n\t\t\t  struct ieee80211_channel *channel, gfp_t gfp);\n\n/**\n * cfg80211_notify_new_peer_candidate - notify cfg80211 of a new mesh peer\n * \t\t\t\t\tcandidate\n *\n * @dev: network device\n * @macaddr: the MAC address of the new candidate\n * @ie: information elements advertised by the peer candidate\n * @ie_len: length of the information elements buffer\n * @gfp: allocation flags\n *\n * This function notifies cfg80211 that the mesh peer candidate has been\n * detected, most likely via a beacon or, less likely, via a probe response.\n * cfg80211 then sends a notification to userspace.\n */\nvoid cfg80211_notify_new_peer_candidate(struct net_device *dev,\n\t\tconst u8 *macaddr, const u8 *ie, u8 ie_len,\n\t\tint sig_dbm, gfp_t gfp);\n\n/**\n * DOC: RFkill integration\n *\n * RFkill integration in cfg80211 is almost invisible to drivers,\n * as cfg80211 automatically registers an rfkill instance for each\n * wireless device it knows about. Soft kill is also translated\n * into disconnecting and turning all interfaces off, drivers are\n * expected to turn off the device when all interfaces are down.\n *\n * However, devices may have a hard RFkill line, in which case they\n * also need to interact with the rfkill subsystem, via cfg80211.\n * They can do this with a few helper functions documented here.\n */\n\n/**\n * wiphy_rfkill_set_hw_state - notify cfg80211 about hw block state\n * @wiphy: the wiphy\n * @blocked: block status\n */\nvoid wiphy_rfkill_set_hw_state(struct wiphy *wiphy, bool blocked);\n\n/**\n * wiphy_rfkill_start_polling - start polling rfkill\n * @wiphy: the wiphy\n */\nvoid wiphy_rfkill_start_polling(struct wiphy *wiphy);\n\n/**\n * wiphy_rfkill_stop_polling - stop polling rfkill\n * @wiphy: the wiphy\n */\nvoid wiphy_rfkill_stop_polling(struct wiphy *wiphy);\n\n/**\n * DOC: Vendor commands\n *\n * Occasionally, there are special protocol or firmware features that\n * can't be implemented very openly. For this and similar cases, the\n * vendor command functionality allows implementing the features with\n * (typically closed-source) userspace and firmware, using nl80211 as\n * the configuration mechanism.\n *\n * A driver supporting vendor commands must register them as an array\n * in struct wiphy, with handlers for each one, each command has an\n * OUI and sub command ID to identify it.\n *\n * Note that this feature should not be (ab)used to implement protocol\n * features that could openly be shared across drivers. In particular,\n * it must never be required to use vendor commands to implement any\n * \"normal\" functionality that higher-level userspace like connection\n * managers etc. need.\n */\n\nstruct sk_buff *__cfg80211_alloc_reply_skb(struct wiphy *wiphy,\n\t\t\t\t\t   enum nl80211_commands cmd,\n\t\t\t\t\t   enum nl80211_attrs attr,\n\t\t\t\t\t   int approxlen);\n\nstruct sk_buff *__cfg80211_alloc_event_skb(struct wiphy *wiphy,\n\t\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t\t   enum nl80211_commands cmd,\n\t\t\t\t\t   enum nl80211_attrs attr,\n\t\t\t\t\t   unsigned int portid,\n\t\t\t\t\t   int vendor_event_idx,\n\t\t\t\t\t   int approxlen, gfp_t gfp);\n\nvoid __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp);\n\n/**\n * cfg80211_vendor_cmd_alloc_reply_skb - allocate vendor command reply\n * @wiphy: the wiphy\n * @approxlen: an upper bound of the length of the data that will\n *\tbe put into the skb\n *\n * This function allocates and pre-fills an skb for a reply to\n * a vendor command. Since it is intended for a reply, calling\n * it outside of a vendor command's doit() operation is invalid.\n *\n * The returned skb is pre-filled with some identifying data in\n * a way that any data that is put into the skb (with skb_put(),\n * nla_put() or similar) will end up being within the\n * %NL80211_ATTR_VENDOR_DATA attribute, so all that needs to be done\n * with the skb is adding data for the corresponding userspace tool\n * which can then read that data out of the vendor data attribute.\n * You must not modify the skb in any other way.\n *\n * When done, call cfg80211_vendor_cmd_reply() with the skb and return\n * its error code as the result of the doit() operation.\n *\n * Return: An allocated and pre-filled skb. %NULL if any errors happen.\n */\nstatic inline struct sk_buff *\ncfg80211_vendor_cmd_alloc_reply_skb(struct wiphy *wiphy, int approxlen)\n{\n\treturn __cfg80211_alloc_reply_skb(wiphy, NL80211_CMD_VENDOR,\n\t\t\t\t\t  NL80211_ATTR_VENDOR_DATA, approxlen);\n}\n\n/**\n * cfg80211_vendor_cmd_reply - send the reply skb\n * @skb: The skb, must have been allocated with\n *\tcfg80211_vendor_cmd_alloc_reply_skb()\n *\n * Since calling this function will usually be the last thing\n * before returning from the vendor command doit() you should\n * return the error code.  Note that this function consumes the\n * skb regardless of the return value.\n *\n * Return: An error code or 0 on success.\n */\nint cfg80211_vendor_cmd_reply(struct sk_buff *skb);\n\n/**\n * cfg80211_vendor_cmd_get_sender\n * @wiphy: the wiphy\n *\n * Return the current netlink port ID in a vendor command handler.\n * Valid to call only there.\n */\nunsigned int cfg80211_vendor_cmd_get_sender(struct wiphy *wiphy);\n\n/**\n * cfg80211_vendor_event_alloc - allocate vendor-specific event skb\n * @wiphy: the wiphy\n * @wdev: the wireless device\n * @event_idx: index of the vendor event in the wiphy's vendor_events\n * @approxlen: an upper bound of the length of the data that will\n *\tbe put into the skb\n * @gfp: allocation flags\n *\n * This function allocates and pre-fills an skb for an event on the\n * vendor-specific multicast group.\n *\n * If wdev != NULL, both the ifindex and identifier of the specified\n * wireless device are added to the event message before the vendor data\n * attribute.\n *\n * When done filling the skb, call cfg80211_vendor_event() with the\n * skb to send the event.\n *\n * Return: An allocated and pre-filled skb. %NULL if any errors happen.\n */\nstatic inline struct sk_buff *\ncfg80211_vendor_event_alloc(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t     int approxlen, int event_idx, gfp_t gfp)\n{\n\treturn __cfg80211_alloc_event_skb(wiphy, wdev, NL80211_CMD_VENDOR,\n\t\t\t\t\t  NL80211_ATTR_VENDOR_DATA,\n\t\t\t\t\t  0, event_idx, approxlen, gfp);\n}\n\n/**\n * cfg80211_vendor_event_alloc_ucast - alloc unicast vendor-specific event skb\n * @wiphy: the wiphy\n * @wdev: the wireless device\n * @event_idx: index of the vendor event in the wiphy's vendor_events\n * @portid: port ID of the receiver\n * @approxlen: an upper bound of the length of the data that will\n *\tbe put into the skb\n * @gfp: allocation flags\n *\n * This function allocates and pre-fills an skb for an event to send to\n * a specific (userland) socket. This socket would previously have been\n * obtained by cfg80211_vendor_cmd_get_sender(), and the caller MUST take\n * care to register a netlink notifier to see when the socket closes.\n *\n * If wdev != NULL, both the ifindex and identifier of the specified\n * wireless device are added to the event message before the vendor data\n * attribute.\n *\n * When done filling the skb, call cfg80211_vendor_event() with the\n * skb to send the event.\n *\n * Return: An allocated and pre-filled skb. %NULL if any errors happen.\n */\nstatic inline struct sk_buff *\ncfg80211_vendor_event_alloc_ucast(struct wiphy *wiphy,\n\t\t\t\t  struct wireless_dev *wdev,\n\t\t\t\t  unsigned int portid, int approxlen,\n\t\t\t\t  int event_idx, gfp_t gfp)\n{\n\treturn __cfg80211_alloc_event_skb(wiphy, wdev, NL80211_CMD_VENDOR,\n\t\t\t\t\t  NL80211_ATTR_VENDOR_DATA,\n\t\t\t\t\t  portid, event_idx, approxlen, gfp);\n}\n\n/**\n * cfg80211_vendor_event - send the event\n * @skb: The skb, must have been allocated with cfg80211_vendor_event_alloc()\n * @gfp: allocation flags\n *\n * This function sends the given @skb, which must have been allocated\n * by cfg80211_vendor_event_alloc(), as an event. It always consumes it.\n */\nstatic inline void cfg80211_vendor_event(struct sk_buff *skb, gfp_t gfp)\n{\n\t__cfg80211_send_event_skb(skb, gfp);\n}\n\n#ifdef CONFIG_NL80211_TESTMODE\n/**\n * DOC: Test mode\n *\n * Test mode is a set of utility functions to allow drivers to\n * interact with driver-specific tools to aid, for instance,\n * factory programming.\n *\n * This chapter describes how drivers interact with it, for more\n * information see the nl80211 book's chapter on it.\n */\n\n/**\n * cfg80211_testmode_alloc_reply_skb - allocate testmode reply\n * @wiphy: the wiphy\n * @approxlen: an upper bound of the length of the data that will\n *\tbe put into the skb\n *\n * This function allocates and pre-fills an skb for a reply to\n * the testmode command. Since it is intended for a reply, calling\n * it outside of the @testmode_cmd operation is invalid.\n *\n * The returned skb is pre-filled with the wiphy index and set up in\n * a way that any data that is put into the skb (with skb_put(),\n * nla_put() or similar) will end up being within the\n * %NL80211_ATTR_TESTDATA attribute, so all that needs to be done\n * with the skb is adding data for the corresponding userspace tool\n * which can then read that data out of the testdata attribute. You\n * must not modify the skb in any other way.\n *\n * When done, call cfg80211_testmode_reply() with the skb and return\n * its error code as the result of the @testmode_cmd operation.\n *\n * Return: An allocated and pre-filled skb. %NULL if any errors happen.\n */\nstatic inline struct sk_buff *\ncfg80211_testmode_alloc_reply_skb(struct wiphy *wiphy, int approxlen)\n{\n\treturn __cfg80211_alloc_reply_skb(wiphy, NL80211_CMD_TESTMODE,\n\t\t\t\t\t  NL80211_ATTR_TESTDATA, approxlen);\n}\n\n/**\n * cfg80211_testmode_reply - send the reply skb\n * @skb: The skb, must have been allocated with\n *\tcfg80211_testmode_alloc_reply_skb()\n *\n * Since calling this function will usually be the last thing\n * before returning from the @testmode_cmd you should return\n * the error code.  Note that this function consumes the skb\n * regardless of the return value.\n *\n * Return: An error code or 0 on success.\n */\nstatic inline int cfg80211_testmode_reply(struct sk_buff *skb)\n{\n\treturn cfg80211_vendor_cmd_reply(skb);\n}\n\n/**\n * cfg80211_testmode_alloc_event_skb - allocate testmode event\n * @wiphy: the wiphy\n * @approxlen: an upper bound of the length of the data that will\n *\tbe put into the skb\n * @gfp: allocation flags\n *\n * This function allocates and pre-fills an skb for an event on the\n * testmode multicast group.\n *\n * The returned skb is set up in the same way as with\n * cfg80211_testmode_alloc_reply_skb() but prepared for an event. As\n * there, you should simply add data to it that will then end up in the\n * %NL80211_ATTR_TESTDATA attribute. Again, you must not modify the skb\n * in any other way.\n *\n * When done filling the skb, call cfg80211_testmode_event() with the\n * skb to send the event.\n *\n * Return: An allocated and pre-filled skb. %NULL if any errors happen.\n */\nstatic inline struct sk_buff *\ncfg80211_testmode_alloc_event_skb(struct wiphy *wiphy, int approxlen, gfp_t gfp)\n{\n\treturn __cfg80211_alloc_event_skb(wiphy, NULL, NL80211_CMD_TESTMODE,\n\t\t\t\t\t  NL80211_ATTR_TESTDATA, 0, -1,\n\t\t\t\t\t  approxlen, gfp);\n}\n\n/**\n * cfg80211_testmode_event - send the event\n * @skb: The skb, must have been allocated with\n *\tcfg80211_testmode_alloc_event_skb()\n * @gfp: allocation flags\n *\n * This function sends the given @skb, which must have been allocated\n * by cfg80211_testmode_alloc_event_skb(), as an event. It always\n * consumes it.\n */\nstatic inline void cfg80211_testmode_event(struct sk_buff *skb, gfp_t gfp)\n{\n\t__cfg80211_send_event_skb(skb, gfp);\n}\n\n#define CFG80211_TESTMODE_CMD(cmd)\t.testmode_cmd = (cmd),\n#define CFG80211_TESTMODE_DUMP(cmd)\t.testmode_dump = (cmd),\n#else\n#define CFG80211_TESTMODE_CMD(cmd)\n#define CFG80211_TESTMODE_DUMP(cmd)\n#endif\n\n/**\n * struct cfg80211_fils_resp_params - FILS connection response params\n * @kek: KEK derived from a successful FILS connection (may be %NULL)\n * @kek_len: Length of @fils_kek in octets\n * @update_erp_next_seq_num: Boolean value to specify whether the value in\n *\t@erp_next_seq_num is valid.\n * @erp_next_seq_num: The next sequence number to use in ERP message in\n *\tFILS Authentication. This value should be specified irrespective of the\n *\tstatus for a FILS connection.\n * @pmk: A new PMK if derived from a successful FILS connection (may be %NULL).\n * @pmk_len: Length of @pmk in octets\n * @pmkid: A new PMKID if derived from a successful FILS connection or the PMKID\n *\tused for this FILS connection (may be %NULL).\n */\nstruct cfg80211_fils_resp_params {\n\tconst u8 *kek;\n\tsize_t kek_len;\n\tbool update_erp_next_seq_num;\n\tu16 erp_next_seq_num;\n\tconst u8 *pmk;\n\tsize_t pmk_len;\n\tconst u8 *pmkid;\n};\n\n/**\n * struct cfg80211_connect_resp_params - Connection response params\n * @status: Status code, %WLAN_STATUS_SUCCESS for successful connection, use\n *\t%WLAN_STATUS_UNSPECIFIED_FAILURE if your device cannot give you\n *\tthe real status code for failures. If this call is used to report a\n *\tfailure due to a timeout (e.g., not receiving an Authentication frame\n *\tfrom the AP) instead of an explicit rejection by the AP, -1 is used to\n *\tindicate that this is a failure, but without a status code.\n *\t@timeout_reason is used to report the reason for the timeout in that\n *\tcase.\n * @bssid: The BSSID of the AP (may be %NULL)\n * @bss: Entry of bss to which STA got connected to, can be obtained through\n *\tcfg80211_get_bss() (may be %NULL). But it is recommended to store the\n *\tbss from the connect_request and hold a reference to it and return\n *\tthrough this param to avoid a warning if the bss is expired during the\n *\tconnection, esp. for those drivers implementing connect op.\n *\tOnly one parameter among @bssid and @bss needs to be specified.\n * @req_ie: Association request IEs (may be %NULL)\n * @req_ie_len: Association request IEs length\n * @resp_ie: Association response IEs (may be %NULL)\n * @resp_ie_len: Association response IEs length\n * @fils: FILS connection response parameters.\n * @timeout_reason: Reason for connection timeout. This is used when the\n *\tconnection fails due to a timeout instead of an explicit rejection from\n *\tthe AP. %NL80211_TIMEOUT_UNSPECIFIED is used when the timeout reason is\n *\tnot known. This value is used only if @status < 0 to indicate that the\n *\tfailure is due to a timeout and not due to explicit rejection by the AP.\n *\tThis value is ignored in other cases (@status >= 0).\n */\nstruct cfg80211_connect_resp_params {\n\tint status;\n\tconst u8 *bssid;\n\tstruct cfg80211_bss *bss;\n\tconst u8 *req_ie;\n\tsize_t req_ie_len;\n\tconst u8 *resp_ie;\n\tsize_t resp_ie_len;\n\tstruct cfg80211_fils_resp_params fils;\n\tenum nl80211_timeout_reason timeout_reason;\n};\n\n/**\n * cfg80211_connect_done - notify cfg80211 of connection result\n *\n * @dev: network device\n * @params: connection response parameters\n * @gfp: allocation flags\n *\n * It should be called by the underlying driver once execution of the connection\n * request from connect() has been completed. This is similar to\n * cfg80211_connect_bss(), but takes a structure pointer for connection response\n * parameters. Only one of the functions among cfg80211_connect_bss(),\n * cfg80211_connect_result(), cfg80211_connect_timeout(),\n * and cfg80211_connect_done() should be called.\n */\nvoid cfg80211_connect_done(struct net_device *dev,\n\t\t\t   struct cfg80211_connect_resp_params *params,\n\t\t\t   gfp_t gfp);\n\n/**\n * cfg80211_connect_bss - notify cfg80211 of connection result\n *\n * @dev: network device\n * @bssid: the BSSID of the AP\n * @bss: Entry of bss to which STA got connected to, can be obtained through\n *\tcfg80211_get_bss() (may be %NULL). But it is recommended to store the\n *\tbss from the connect_request and hold a reference to it and return\n *\tthrough this param to avoid a warning if the bss is expired during the\n *\tconnection, esp. for those drivers implementing connect op.\n *\tOnly one parameter among @bssid and @bss needs to be specified.\n * @req_ie: association request IEs (maybe be %NULL)\n * @req_ie_len: association request IEs length\n * @resp_ie: association response IEs (may be %NULL)\n * @resp_ie_len: assoc response IEs length\n * @status: status code, %WLAN_STATUS_SUCCESS for successful connection, use\n *\t%WLAN_STATUS_UNSPECIFIED_FAILURE if your device cannot give you\n *\tthe real status code for failures. If this call is used to report a\n *\tfailure due to a timeout (e.g., not receiving an Authentication frame\n *\tfrom the AP) instead of an explicit rejection by the AP, -1 is used to\n *\tindicate that this is a failure, but without a status code.\n *\t@timeout_reason is used to report the reason for the timeout in that\n *\tcase.\n * @gfp: allocation flags\n * @timeout_reason: reason for connection timeout. This is used when the\n *\tconnection fails due to a timeout instead of an explicit rejection from\n *\tthe AP. %NL80211_TIMEOUT_UNSPECIFIED is used when the timeout reason is\n *\tnot known. This value is used only if @status < 0 to indicate that the\n *\tfailure is due to a timeout and not due to explicit rejection by the AP.\n *\tThis value is ignored in other cases (@status >= 0).\n *\n * It should be called by the underlying driver once execution of the connection\n * request from connect() has been completed. This is similar to\n * cfg80211_connect_result(), but with the option of identifying the exact bss\n * entry for the connection. Only one of the functions among\n * cfg80211_connect_bss(), cfg80211_connect_result(),\n * cfg80211_connect_timeout(), and cfg80211_connect_done() should be called.\n */\nstatic inline void\ncfg80211_connect_bss(struct net_device *dev, const u8 *bssid,\n\t\t     struct cfg80211_bss *bss, const u8 *req_ie,\n\t\t     size_t req_ie_len, const u8 *resp_ie,\n\t\t     size_t resp_ie_len, int status, gfp_t gfp,\n\t\t     enum nl80211_timeout_reason timeout_reason)\n{\n\tstruct cfg80211_connect_resp_params params;\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.status = status;\n\tparams.bssid = bssid;\n\tparams.bss = bss;\n\tparams.req_ie = req_ie;\n\tparams.req_ie_len = req_ie_len;\n\tparams.resp_ie = resp_ie;\n\tparams.resp_ie_len = resp_ie_len;\n\tparams.timeout_reason = timeout_reason;\n\n\tcfg80211_connect_done(dev, &params, gfp);\n}\n\n/**\n * cfg80211_connect_result - notify cfg80211 of connection result\n *\n * @dev: network device\n * @bssid: the BSSID of the AP\n * @req_ie: association request IEs (maybe be %NULL)\n * @req_ie_len: association request IEs length\n * @resp_ie: association response IEs (may be %NULL)\n * @resp_ie_len: assoc response IEs length\n * @status: status code, %WLAN_STATUS_SUCCESS for successful connection, use\n *\t%WLAN_STATUS_UNSPECIFIED_FAILURE if your device cannot give you\n *\tthe real status code for failures.\n * @gfp: allocation flags\n *\n * It should be called by the underlying driver once execution of the connection\n * request from connect() has been completed. This is similar to\n * cfg80211_connect_bss() which allows the exact bss entry to be specified. Only\n * one of the functions among cfg80211_connect_bss(), cfg80211_connect_result(),\n * cfg80211_connect_timeout(), and cfg80211_connect_done() should be called.\n */\nstatic inline void\ncfg80211_connect_result(struct net_device *dev, const u8 *bssid,\n\t\t\tconst u8 *req_ie, size_t req_ie_len,\n\t\t\tconst u8 *resp_ie, size_t resp_ie_len,\n\t\t\tu16 status, gfp_t gfp)\n{\n\tcfg80211_connect_bss(dev, bssid, NULL, req_ie, req_ie_len, resp_ie,\n\t\t\t     resp_ie_len, status, gfp,\n\t\t\t     NL80211_TIMEOUT_UNSPECIFIED);\n}\n\n/**\n * cfg80211_connect_timeout - notify cfg80211 of connection timeout\n *\n * @dev: network device\n * @bssid: the BSSID of the AP\n * @req_ie: association request IEs (maybe be %NULL)\n * @req_ie_len: association request IEs length\n * @gfp: allocation flags\n * @timeout_reason: reason for connection timeout.\n *\n * It should be called by the underlying driver whenever connect() has failed\n * in a sequence where no explicit authentication/association rejection was\n * received from the AP. This could happen, e.g., due to not being able to send\n * out the Authentication or Association Request frame or timing out while\n * waiting for the response. Only one of the functions among\n * cfg80211_connect_bss(), cfg80211_connect_result(),\n * cfg80211_connect_timeout(), and cfg80211_connect_done() should be called.\n */\nstatic inline void\ncfg80211_connect_timeout(struct net_device *dev, const u8 *bssid,\n\t\t\t const u8 *req_ie, size_t req_ie_len, gfp_t gfp,\n\t\t\t enum nl80211_timeout_reason timeout_reason)\n{\n\tcfg80211_connect_bss(dev, bssid, NULL, req_ie, req_ie_len, NULL, 0, -1,\n\t\t\t     gfp, timeout_reason);\n}\n\n/**\n * struct cfg80211_roam_info - driver initiated roaming information\n *\n * @channel: the channel of the new AP\n * @bss: entry of bss to which STA got roamed (may be %NULL if %bssid is set)\n * @bssid: the BSSID of the new AP (may be %NULL if %bss is set)\n * @req_ie: association request IEs (maybe be %NULL)\n * @req_ie_len: association request IEs length\n * @resp_ie: association response IEs (may be %NULL)\n * @resp_ie_len: assoc response IEs length\n * @fils: FILS related roaming information.\n */\nstruct cfg80211_roam_info {\n\tstruct ieee80211_channel *channel;\n\tstruct cfg80211_bss *bss;\n\tconst u8 *bssid;\n\tconst u8 *req_ie;\n\tsize_t req_ie_len;\n\tconst u8 *resp_ie;\n\tsize_t resp_ie_len;\n\tstruct cfg80211_fils_resp_params fils;\n};\n\n/**\n * cfg80211_roamed - notify cfg80211 of roaming\n *\n * @dev: network device\n * @info: information about the new BSS. struct &cfg80211_roam_info.\n * @gfp: allocation flags\n *\n * This function may be called with the driver passing either the BSSID of the\n * new AP or passing the bss entry to avoid a race in timeout of the bss entry.\n * It should be called by the underlying driver whenever it roamed from one AP\n * to another while connected. Drivers which have roaming implemented in\n * firmware should pass the bss entry to avoid a race in bss entry timeout where\n * the bss entry of the new AP is seen in the driver, but gets timed out by the\n * time it is accessed in __cfg80211_roamed() due to delay in scheduling\n * rdev->event_work. In case of any failures, the reference is released\n * either in cfg80211_roamed() or in __cfg80211_romed(), Otherwise, it will be\n * released while disconnecting from the current bss.\n */\nvoid cfg80211_roamed(struct net_device *dev, struct cfg80211_roam_info *info,\n\t\t     gfp_t gfp);\n\n/**\n * cfg80211_port_authorized - notify cfg80211 of successful security association\n *\n * @dev: network device\n * @bssid: the BSSID of the AP\n * @gfp: allocation flags\n *\n * This function should be called by a driver that supports 4 way handshake\n * offload after a security association was successfully established (i.e.,\n * the 4 way handshake was completed successfully). The call to this function\n * should be preceded with a call to cfg80211_connect_result(),\n * cfg80211_connect_done(), cfg80211_connect_bss() or cfg80211_roamed() to\n * indicate the 802.11 association.\n */\nvoid cfg80211_port_authorized(struct net_device *dev, const u8 *bssid,\n\t\t\t      gfp_t gfp);\n\n/**\n * cfg80211_disconnected - notify cfg80211 that connection was dropped\n *\n * @dev: network device\n * @ie: information elements of the deauth/disassoc frame (may be %NULL)\n * @ie_len: length of IEs\n * @reason: reason code for the disconnection, set it to 0 if unknown\n * @locally_generated: disconnection was requested locally\n * @gfp: allocation flags\n *\n * After it calls this function, the driver should enter an idle state\n * and not try to connect to any AP any more.\n */\nvoid cfg80211_disconnected(struct net_device *dev, u16 reason,\n\t\t\t   const u8 *ie, size_t ie_len,\n\t\t\t   bool locally_generated, gfp_t gfp);\n\n/**\n * cfg80211_ready_on_channel - notification of remain_on_channel start\n * @wdev: wireless device\n * @cookie: the request cookie\n * @chan: The current channel (from remain_on_channel request)\n * @duration: Duration in milliseconds that the driver intents to remain on the\n *\tchannel\n * @gfp: allocation flags\n */\nvoid cfg80211_ready_on_channel(struct wireless_dev *wdev, u64 cookie,\n\t\t\t       struct ieee80211_channel *chan,\n\t\t\t       unsigned int duration, gfp_t gfp);\n\n/**\n * cfg80211_remain_on_channel_expired - remain_on_channel duration expired\n * @wdev: wireless device\n * @cookie: the request cookie\n * @chan: The current channel (from remain_on_channel request)\n * @gfp: allocation flags\n */\nvoid cfg80211_remain_on_channel_expired(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\t\tgfp_t gfp);\n\n/**\n * cfg80211_tx_mgmt_expired - tx_mgmt duration expired\n * @wdev: wireless device\n * @cookie: the requested cookie\n * @chan: The current channel (from tx_mgmt request)\n * @gfp: allocation flags\n */\nvoid cfg80211_tx_mgmt_expired(struct wireless_dev *wdev, u64 cookie,\n\t\t\t      struct ieee80211_channel *chan, gfp_t gfp);\n\n/**\n * cfg80211_sinfo_alloc_tid_stats - allocate per-tid statistics.\n *\n * @sinfo: the station information\n * @gfp: allocation flags\n */\nint cfg80211_sinfo_alloc_tid_stats(struct station_info *sinfo, gfp_t gfp);\n\n/**\n * cfg80211_sinfo_release_content - release contents of station info\n * @sinfo: the station information\n *\n * Releases any potentially allocated sub-information of the station\n * information, but not the struct itself (since it's typically on\n * the stack.)\n */\nstatic inline void cfg80211_sinfo_release_content(struct station_info *sinfo)\n{\n\tkfree(sinfo->pertid);\n}\n\n/**\n * cfg80211_new_sta - notify userspace about station\n *\n * @dev: the netdev\n * @mac_addr: the station's address\n * @sinfo: the station information\n * @gfp: allocation flags\n */\nvoid cfg80211_new_sta(struct net_device *dev, const u8 *mac_addr,\n\t\t      struct station_info *sinfo, gfp_t gfp);\n\n/**\n * cfg80211_del_sta_sinfo - notify userspace about deletion of a station\n * @dev: the netdev\n * @mac_addr: the station's address\n * @sinfo: the station information/statistics\n * @gfp: allocation flags\n */\nvoid cfg80211_del_sta_sinfo(struct net_device *dev, const u8 *mac_addr,\n\t\t\t    struct station_info *sinfo, gfp_t gfp);\n\n/**\n * cfg80211_del_sta - notify userspace about deletion of a station\n *\n * @dev: the netdev\n * @mac_addr: the station's address\n * @gfp: allocation flags\n */\nstatic inline void cfg80211_del_sta(struct net_device *dev,\n\t\t\t\t    const u8 *mac_addr, gfp_t gfp)\n{\n\tcfg80211_del_sta_sinfo(dev, mac_addr, NULL, gfp);\n}\n\n/**\n * cfg80211_conn_failed - connection request failed notification\n *\n * @dev: the netdev\n * @mac_addr: the station's address\n * @reason: the reason for connection failure\n * @gfp: allocation flags\n *\n * Whenever a station tries to connect to an AP and if the station\n * could not connect to the AP as the AP has rejected the connection\n * for some reasons, this function is called.\n *\n * The reason for connection failure can be any of the value from\n * nl80211_connect_failed_reason enum\n */\nvoid cfg80211_conn_failed(struct net_device *dev, const u8 *mac_addr,\n\t\t\t  enum nl80211_connect_failed_reason reason,\n\t\t\t  gfp_t gfp);\n\n/**\n * cfg80211_rx_mgmt_khz - notification of received, unprocessed management frame\n * @wdev: wireless device receiving the frame\n * @freq: Frequency on which the frame was received in KHz\n * @sig_dbm: signal strength in dBm, or 0 if unknown\n * @buf: Management frame (header + body)\n * @len: length of the frame data\n * @flags: flags, as defined in enum nl80211_rxmgmt_flags\n *\n * This function is called whenever an Action frame is received for a station\n * mode interface, but is not processed in kernel.\n *\n * Return: %true if a user space application has registered for this frame.\n * For action frames, that makes it responsible for rejecting unrecognized\n * action frames; %false otherwise, in which case for action frames the\n * driver is responsible for rejecting the frame.\n */\nbool cfg80211_rx_mgmt_khz(struct wireless_dev *wdev, int freq, int sig_dbm,\n\t\t\t  const u8 *buf, size_t len, u32 flags);\n\n/**\n * cfg80211_rx_mgmt - notification of received, unprocessed management frame\n * @wdev: wireless device receiving the frame\n * @freq: Frequency on which the frame was received in MHz\n * @sig_dbm: signal strength in dBm, or 0 if unknown\n * @buf: Management frame (header + body)\n * @len: length of the frame data\n * @flags: flags, as defined in enum nl80211_rxmgmt_flags\n *\n * This function is called whenever an Action frame is received for a station\n * mode interface, but is not processed in kernel.\n *\n * Return: %true if a user space application has registered for this frame.\n * For action frames, that makes it responsible for rejecting unrecognized\n * action frames; %false otherwise, in which case for action frames the\n * driver is responsible for rejecting the frame.\n */\nstatic inline bool cfg80211_rx_mgmt(struct wireless_dev *wdev, int freq,\n\t\t\t\t    int sig_dbm, const u8 *buf, size_t len,\n\t\t\t\t    u32 flags)\n{\n\treturn cfg80211_rx_mgmt_khz(wdev, MHZ_TO_KHZ(freq), sig_dbm, buf, len,\n\t\t\t\t    flags);\n}\n\n/**\n * cfg80211_mgmt_tx_status - notification of TX status for management frame\n * @wdev: wireless device receiving the frame\n * @cookie: Cookie returned by cfg80211_ops::mgmt_tx()\n * @buf: Management frame (header + body)\n * @len: length of the frame data\n * @ack: Whether frame was acknowledged\n * @gfp: context flags\n *\n * This function is called whenever a management frame was requested to be\n * transmitted with cfg80211_ops::mgmt_tx() to report the TX status of the\n * transmission attempt.\n */\nvoid cfg80211_mgmt_tx_status(struct wireless_dev *wdev, u64 cookie,\n\t\t\t     const u8 *buf, size_t len, bool ack, gfp_t gfp);\n\n/**\n * cfg80211_control_port_tx_status - notification of TX status for control\n *                                   port frames\n * @wdev: wireless device receiving the frame\n * @cookie: Cookie returned by cfg80211_ops::tx_control_port()\n * @buf: Data frame (header + body)\n * @len: length of the frame data\n * @ack: Whether frame was acknowledged\n * @gfp: context flags\n *\n * This function is called whenever a control port frame was requested to be\n * transmitted with cfg80211_ops::tx_control_port() to report the TX status of\n * the transmission attempt.\n */\nvoid cfg80211_control_port_tx_status(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t     const u8 *buf, size_t len, bool ack,\n\t\t\t\t     gfp_t gfp);\n\n/**\n * cfg80211_rx_control_port - notification about a received control port frame\n * @dev: The device the frame matched to\n * @skb: The skbuf with the control port frame.  It is assumed that the skbuf\n *\tis 802.3 formatted (with 802.3 header).  The skb can be non-linear.\n *\tThis function does not take ownership of the skb, so the caller is\n *\tresponsible for any cleanup.  The caller must also ensure that\n *\tskb->protocol is set appropriately.\n * @unencrypted: Whether the frame was received unencrypted\n *\n * This function is used to inform userspace about a received control port\n * frame.  It should only be used if userspace indicated it wants to receive\n * control port frames over nl80211.\n *\n * The frame is the data portion of the 802.3 or 802.11 data frame with all\n * network layer headers removed (e.g. the raw EAPoL frame).\n *\n * Return: %true if the frame was passed to userspace\n */\nbool cfg80211_rx_control_port(struct net_device *dev,\n\t\t\t      struct sk_buff *skb, bool unencrypted);\n\n/**\n * cfg80211_cqm_rssi_notify - connection quality monitoring rssi event\n * @dev: network device\n * @rssi_event: the triggered RSSI event\n * @rssi_level: new RSSI level value or 0 if not available\n * @gfp: context flags\n *\n * This function is called when a configured connection quality monitoring\n * rssi threshold reached event occurs.\n */\nvoid cfg80211_cqm_rssi_notify(struct net_device *dev,\n\t\t\t      enum nl80211_cqm_rssi_threshold_event rssi_event,\n\t\t\t      s32 rssi_level, gfp_t gfp);\n\n/**\n * cfg80211_cqm_pktloss_notify - notify userspace about packetloss to peer\n * @dev: network device\n * @peer: peer's MAC address\n * @num_packets: how many packets were lost -- should be a fixed threshold\n *\tbut probably no less than maybe 50, or maybe a throughput dependent\n *\tthreshold (to account for temporary interference)\n * @gfp: context flags\n */\nvoid cfg80211_cqm_pktloss_notify(struct net_device *dev,\n\t\t\t\t const u8 *peer, u32 num_packets, gfp_t gfp);\n\n/**\n * cfg80211_cqm_txe_notify - TX error rate event\n * @dev: network device\n * @peer: peer's MAC address\n * @num_packets: how many packets were lost\n * @rate: % of packets which failed transmission\n * @intvl: interval (in s) over which the TX failure threshold was breached.\n * @gfp: context flags\n *\n * Notify userspace when configured % TX failures over number of packets in a\n * given interval is exceeded.\n */\nvoid cfg80211_cqm_txe_notify(struct net_device *dev, const u8 *peer,\n\t\t\t     u32 num_packets, u32 rate, u32 intvl, gfp_t gfp);\n\n/**\n * cfg80211_cqm_beacon_loss_notify - beacon loss event\n * @dev: network device\n * @gfp: context flags\n *\n * Notify userspace about beacon loss from the connected AP.\n */\nvoid cfg80211_cqm_beacon_loss_notify(struct net_device *dev, gfp_t gfp);\n\n/**\n * cfg80211_radar_event - radar detection event\n * @wiphy: the wiphy\n * @chandef: chandef for the current channel\n * @gfp: context flags\n *\n * This function is called when a radar is detected on the current chanenl.\n */\nvoid cfg80211_radar_event(struct wiphy *wiphy,\n\t\t\t  struct cfg80211_chan_def *chandef, gfp_t gfp);\n\n/**\n * cfg80211_sta_opmode_change_notify - STA's ht/vht operation mode change event\n * @dev: network device\n * @mac: MAC address of a station which opmode got modified\n * @sta_opmode: station's current opmode value\n * @gfp: context flags\n *\n * Driver should call this function when station's opmode modified via action\n * frame.\n */\nvoid cfg80211_sta_opmode_change_notify(struct net_device *dev, const u8 *mac,\n\t\t\t\t       struct sta_opmode_info *sta_opmode,\n\t\t\t\t       gfp_t gfp);\n\n/**\n * cfg80211_cac_event - Channel availability check (CAC) event\n * @netdev: network device\n * @chandef: chandef for the current channel\n * @event: type of event\n * @gfp: context flags\n *\n * This function is called when a Channel availability check (CAC) is finished\n * or aborted. This must be called to notify the completion of a CAC process,\n * also by full-MAC drivers.\n */\nvoid cfg80211_cac_event(struct net_device *netdev,\n\t\t\tconst struct cfg80211_chan_def *chandef,\n\t\t\tenum nl80211_radar_event event, gfp_t gfp);\n\n\n/**\n * cfg80211_gtk_rekey_notify - notify userspace about driver rekeying\n * @dev: network device\n * @bssid: BSSID of AP (to avoid races)\n * @replay_ctr: new replay counter\n * @gfp: allocation flags\n */\nvoid cfg80211_gtk_rekey_notify(struct net_device *dev, const u8 *bssid,\n\t\t\t       const u8 *replay_ctr, gfp_t gfp);\n\n/**\n * cfg80211_pmksa_candidate_notify - notify about PMKSA caching candidate\n * @dev: network device\n * @index: candidate index (the smaller the index, the higher the priority)\n * @bssid: BSSID of AP\n * @preauth: Whether AP advertises support for RSN pre-authentication\n * @gfp: allocation flags\n */\nvoid cfg80211_pmksa_candidate_notify(struct net_device *dev, int index,\n\t\t\t\t     const u8 *bssid, bool preauth, gfp_t gfp);\n\n/**\n * cfg80211_rx_spurious_frame - inform userspace about a spurious frame\n * @dev: The device the frame matched to\n * @addr: the transmitter address\n * @gfp: context flags\n *\n * This function is used in AP mode (only!) to inform userspace that\n * a spurious class 3 frame was received, to be able to deauth the\n * sender.\n * Return: %true if the frame was passed to userspace (or this failed\n * for a reason other than not having a subscription.)\n */\nbool cfg80211_rx_spurious_frame(struct net_device *dev,\n\t\t\t\tconst u8 *addr, gfp_t gfp);\n\n/**\n * cfg80211_rx_unexpected_4addr_frame - inform about unexpected WDS frame\n * @dev: The device the frame matched to\n * @addr: the transmitter address\n * @gfp: context flags\n *\n * This function is used in AP mode (only!) to inform userspace that\n * an associated station sent a 4addr frame but that wasn't expected.\n * It is allowed and desirable to send this event only once for each\n * station to avoid event flooding.\n * Return: %true if the frame was passed to userspace (or this failed\n * for a reason other than not having a subscription.)\n */\nbool cfg80211_rx_unexpected_4addr_frame(struct net_device *dev,\n\t\t\t\t\tconst u8 *addr, gfp_t gfp);\n\n/**\n * cfg80211_probe_status - notify userspace about probe status\n * @dev: the device the probe was sent on\n * @addr: the address of the peer\n * @cookie: the cookie filled in @probe_client previously\n * @acked: indicates whether probe was acked or not\n * @ack_signal: signal strength (in dBm) of the ACK frame.\n * @is_valid_ack_signal: indicates the ack_signal is valid or not.\n * @gfp: allocation flags\n */\nvoid cfg80211_probe_status(struct net_device *dev, const u8 *addr,\n\t\t\t   u64 cookie, bool acked, s32 ack_signal,\n\t\t\t   bool is_valid_ack_signal, gfp_t gfp);\n\n/**\n * cfg80211_report_obss_beacon_khz - report beacon from other APs\n * @wiphy: The wiphy that received the beacon\n * @frame: the frame\n * @len: length of the frame\n * @freq: frequency the frame was received on in KHz\n * @sig_dbm: signal strength in dBm, or 0 if unknown\n *\n * Use this function to report to userspace when a beacon was\n * received. It is not useful to call this when there is no\n * netdev that is in AP/GO mode.\n */\nvoid cfg80211_report_obss_beacon_khz(struct wiphy *wiphy, const u8 *frame,\n\t\t\t\t     size_t len, int freq, int sig_dbm);\n\n/**\n * cfg80211_report_obss_beacon - report beacon from other APs\n * @wiphy: The wiphy that received the beacon\n * @frame: the frame\n * @len: length of the frame\n * @freq: frequency the frame was received on\n * @sig_dbm: signal strength in dBm, or 0 if unknown\n *\n * Use this function to report to userspace when a beacon was\n * received. It is not useful to call this when there is no\n * netdev that is in AP/GO mode.\n */\nstatic inline void cfg80211_report_obss_beacon(struct wiphy *wiphy,\n\t\t\t\t\t       const u8 *frame, size_t len,\n\t\t\t\t\t       int freq, int sig_dbm)\n{\n\tcfg80211_report_obss_beacon_khz(wiphy, frame, len, MHZ_TO_KHZ(freq),\n\t\t\t\t\tsig_dbm);\n}\n\n/**\n * cfg80211_reg_can_beacon - check if beaconing is allowed\n * @wiphy: the wiphy\n * @chandef: the channel definition\n * @iftype: interface type\n *\n * Return: %true if there is no secondary channel or the secondary channel(s)\n * can be used for beaconing (i.e. is not a radar channel etc.)\n */\nbool cfg80211_reg_can_beacon(struct wiphy *wiphy,\n\t\t\t     struct cfg80211_chan_def *chandef,\n\t\t\t     enum nl80211_iftype iftype);\n\n/**\n * cfg80211_reg_can_beacon_relax - check if beaconing is allowed with relaxation\n * @wiphy: the wiphy\n * @chandef: the channel definition\n * @iftype: interface type\n *\n * Return: %true if there is no secondary channel or the secondary channel(s)\n * can be used for beaconing (i.e. is not a radar channel etc.). This version\n * also checks if IR-relaxation conditions apply, to allow beaconing under\n * more permissive conditions.\n *\n * Requires the RTNL to be held.\n */\nbool cfg80211_reg_can_beacon_relax(struct wiphy *wiphy,\n\t\t\t\t   struct cfg80211_chan_def *chandef,\n\t\t\t\t   enum nl80211_iftype iftype);\n\n/*\n * cfg80211_ch_switch_notify - update wdev channel and notify userspace\n * @dev: the device which switched channels\n * @chandef: the new channel definition\n *\n * Caller must acquire wdev_lock, therefore must only be called from sleepable\n * driver context!\n */\nvoid cfg80211_ch_switch_notify(struct net_device *dev,\n\t\t\t       struct cfg80211_chan_def *chandef);\n\n/*\n * cfg80211_ch_switch_started_notify - notify channel switch start\n * @dev: the device on which the channel switch started\n * @chandef: the future channel definition\n * @count: the number of TBTTs until the channel switch happens\n * @quiet: whether or not immediate quiet was requested by the AP\n *\n * Inform the userspace about the channel switch that has just\n * started, so that it can take appropriate actions (eg. starting\n * channel switch on other vifs), if necessary.\n */\nvoid cfg80211_ch_switch_started_notify(struct net_device *dev,\n\t\t\t\t       struct cfg80211_chan_def *chandef,\n\t\t\t\t       u8 count, bool quiet);\n\n/**\n * ieee80211_operating_class_to_band - convert operating class to band\n *\n * @operating_class: the operating class to convert\n * @band: band pointer to fill\n *\n * Returns %true if the conversion was successful, %false otherwise.\n */\nbool ieee80211_operating_class_to_band(u8 operating_class,\n\t\t\t\t       enum nl80211_band *band);\n\n/**\n * ieee80211_chandef_to_operating_class - convert chandef to operation class\n *\n * @chandef: the chandef to convert\n * @op_class: a pointer to the resulting operating class\n *\n * Returns %true if the conversion was successful, %false otherwise.\n */\nbool ieee80211_chandef_to_operating_class(struct cfg80211_chan_def *chandef,\n\t\t\t\t\t  u8 *op_class);\n\n/**\n * ieee80211_chandef_to_khz - convert chandef to frequency in KHz\n *\n * @chandef: the chandef to convert\n *\n * Returns the center frequency of chandef (1st segment) in KHz.\n */\nstatic inline u32\nieee80211_chandef_to_khz(const struct cfg80211_chan_def *chandef)\n{\n\treturn MHZ_TO_KHZ(chandef->center_freq1) + chandef->freq1_offset;\n}\n\n/*\n * cfg80211_tdls_oper_request - request userspace to perform TDLS operation\n * @dev: the device on which the operation is requested\n * @peer: the MAC address of the peer device\n * @oper: the requested TDLS operation (NL80211_TDLS_SETUP or\n *\tNL80211_TDLS_TEARDOWN)\n * @reason_code: the reason code for teardown request\n * @gfp: allocation flags\n *\n * This function is used to request userspace to perform TDLS operation that\n * requires knowledge of keys, i.e., link setup or teardown when the AP\n * connection uses encryption. This is optional mechanism for the driver to use\n * if it can automatically determine when a TDLS link could be useful (e.g.,\n * based on traffic and signal strength for a peer).\n */\nvoid cfg80211_tdls_oper_request(struct net_device *dev, const u8 *peer,\n\t\t\t\tenum nl80211_tdls_operation oper,\n\t\t\t\tu16 reason_code, gfp_t gfp);\n\n/*\n * cfg80211_calculate_bitrate - calculate actual bitrate (in 100Kbps units)\n * @rate: given rate_info to calculate bitrate from\n *\n * return 0 if MCS index >= 32\n */\nu32 cfg80211_calculate_bitrate(struct rate_info *rate);\n\n/**\n * cfg80211_unregister_wdev - remove the given wdev\n * @wdev: struct wireless_dev to remove\n *\n * Call this function only for wdevs that have no netdev assigned,\n * e.g. P2P Devices. It removes the device from the list so that\n * it can no longer be used. It is necessary to call this function\n * even when cfg80211 requests the removal of the interface by\n * calling the del_virtual_intf() callback. The function must also\n * be called when the driver wishes to unregister the wdev, e.g.\n * when the device is unbound from the driver.\n *\n * Requires the RTNL to be held.\n */\nvoid cfg80211_unregister_wdev(struct wireless_dev *wdev);\n\n/**\n * struct cfg80211_ft_event_params - FT Information Elements\n * @ies: FT IEs\n * @ies_len: length of the FT IE in bytes\n * @target_ap: target AP's MAC address\n * @ric_ies: RIC IE\n * @ric_ies_len: length of the RIC IE in bytes\n */\nstruct cfg80211_ft_event_params {\n\tconst u8 *ies;\n\tsize_t ies_len;\n\tconst u8 *target_ap;\n\tconst u8 *ric_ies;\n\tsize_t ric_ies_len;\n};\n\n/**\n * cfg80211_ft_event - notify userspace about FT IE and RIC IE\n * @netdev: network device\n * @ft_event: IE information\n */\nvoid cfg80211_ft_event(struct net_device *netdev,\n\t\t       struct cfg80211_ft_event_params *ft_event);\n\n/**\n * cfg80211_get_p2p_attr - find and copy a P2P attribute from IE buffer\n * @ies: the input IE buffer\n * @len: the input length\n * @attr: the attribute ID to find\n * @buf: output buffer, can be %NULL if the data isn't needed, e.g.\n *\tif the function is only called to get the needed buffer size\n * @bufsize: size of the output buffer\n *\n * The function finds a given P2P attribute in the (vendor) IEs and\n * copies its contents to the given buffer.\n *\n * Return: A negative error code (-%EILSEQ or -%ENOENT) if the data is\n * malformed or the attribute can't be found (respectively), or the\n * length of the found attribute (which can be zero).\n */\nint cfg80211_get_p2p_attr(const u8 *ies, unsigned int len,\n\t\t\t  enum ieee80211_p2p_attr_id attr,\n\t\t\t  u8 *buf, unsigned int bufsize);\n\n/**\n * ieee80211_ie_split_ric - split an IE buffer according to ordering (with RIC)\n * @ies: the IE buffer\n * @ielen: the length of the IE buffer\n * @ids: an array with element IDs that are allowed before\n *\tthe split. A WLAN_EID_EXTENSION value means that the next\n *\tEID in the list is a sub-element of the EXTENSION IE.\n * @n_ids: the size of the element ID array\n * @after_ric: array IE types that come after the RIC element\n * @n_after_ric: size of the @after_ric array\n * @offset: offset where to start splitting in the buffer\n *\n * This function splits an IE buffer by updating the @offset\n * variable to point to the location where the buffer should be\n * split.\n *\n * It assumes that the given IE buffer is well-formed, this\n * has to be guaranteed by the caller!\n *\n * It also assumes that the IEs in the buffer are ordered\n * correctly, if not the result of using this function will not\n * be ordered correctly either, i.e. it does no reordering.\n *\n * The function returns the offset where the next part of the\n * buffer starts, which may be @ielen if the entire (remainder)\n * of the buffer should be used.\n */\nsize_t ieee80211_ie_split_ric(const u8 *ies, size_t ielen,\n\t\t\t      const u8 *ids, int n_ids,\n\t\t\t      const u8 *after_ric, int n_after_ric,\n\t\t\t      size_t offset);\n\n/**\n * ieee80211_ie_split - split an IE buffer according to ordering\n * @ies: the IE buffer\n * @ielen: the length of the IE buffer\n * @ids: an array with element IDs that are allowed before\n *\tthe split. A WLAN_EID_EXTENSION value means that the next\n *\tEID in the list is a sub-element of the EXTENSION IE.\n * @n_ids: the size of the element ID array\n * @offset: offset where to start splitting in the buffer\n *\n * This function splits an IE buffer by updating the @offset\n * variable to point to the location where the buffer should be\n * split.\n *\n * It assumes that the given IE buffer is well-formed, this\n * has to be guaranteed by the caller!\n *\n * It also assumes that the IEs in the buffer are ordered\n * correctly, if not the result of using this function will not\n * be ordered correctly either, i.e. it does no reordering.\n *\n * The function returns the offset where the next part of the\n * buffer starts, which may be @ielen if the entire (remainder)\n * of the buffer should be used.\n */\nstatic inline size_t ieee80211_ie_split(const u8 *ies, size_t ielen,\n\t\t\t\t\tconst u8 *ids, int n_ids, size_t offset)\n{\n\treturn ieee80211_ie_split_ric(ies, ielen, ids, n_ids, NULL, 0, offset);\n}\n\n/**\n * cfg80211_report_wowlan_wakeup - report wakeup from WoWLAN\n * @wdev: the wireless device reporting the wakeup\n * @wakeup: the wakeup report\n * @gfp: allocation flags\n *\n * This function reports that the given device woke up. If it\n * caused the wakeup, report the reason(s), otherwise you may\n * pass %NULL as the @wakeup parameter to advertise that something\n * else caused the wakeup.\n */\nvoid cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,\n\t\t\t\t   struct cfg80211_wowlan_wakeup *wakeup,\n\t\t\t\t   gfp_t gfp);\n\n/**\n * cfg80211_crit_proto_stopped() - indicate critical protocol stopped by driver.\n *\n * @wdev: the wireless device for which critical protocol is stopped.\n * @gfp: allocation flags\n *\n * This function can be called by the driver to indicate it has reverted\n * operation back to normal. One reason could be that the duration given\n * by .crit_proto_start() has expired.\n */\nvoid cfg80211_crit_proto_stopped(struct wireless_dev *wdev, gfp_t gfp);\n\n/**\n * ieee80211_get_num_supported_channels - get number of channels device has\n * @wiphy: the wiphy\n *\n * Return: the number of channels supported by the device.\n */\nunsigned int ieee80211_get_num_supported_channels(struct wiphy *wiphy);\n\n/**\n * cfg80211_check_combinations - check interface combinations\n *\n * @wiphy: the wiphy\n * @params: the interface combinations parameter\n *\n * This function can be called by the driver to check whether a\n * combination of interfaces and their types are allowed according to\n * the interface combinations.\n */\nint cfg80211_check_combinations(struct wiphy *wiphy,\n\t\t\t\tstruct iface_combination_params *params);\n\n/**\n * cfg80211_iter_combinations - iterate over matching combinations\n *\n * @wiphy: the wiphy\n * @params: the interface combinations parameter\n * @iter: function to call for each matching combination\n * @data: pointer to pass to iter function\n *\n * This function can be called by the driver to check what possible\n * combinations it fits in at a given moment, e.g. for channel switching\n * purposes.\n */\nint cfg80211_iter_combinations(struct wiphy *wiphy,\n\t\t\t       struct iface_combination_params *params,\n\t\t\t       void (*iter)(const struct ieee80211_iface_combination *c,\n\t\t\t\t\t    void *data),\n\t\t\t       void *data);\n\n/*\n * cfg80211_stop_iface - trigger interface disconnection\n *\n * @wiphy: the wiphy\n * @wdev: wireless device\n * @gfp: context flags\n *\n * Trigger interface to be stopped as if AP was stopped, IBSS/mesh left, STA\n * disconnected.\n *\n * Note: This doesn't need any locks and is asynchronous.\n */\nvoid cfg80211_stop_iface(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t gfp_t gfp);\n\n/**\n * cfg80211_shutdown_all_interfaces - shut down all interfaces for a wiphy\n * @wiphy: the wiphy to shut down\n *\n * This function shuts down all interfaces belonging to this wiphy by\n * calling dev_close() (and treating non-netdev interfaces as needed).\n * It shouldn't really be used unless there are some fatal device errors\n * that really can't be recovered in any other way.\n *\n * Callers must hold the RTNL and be able to deal with callbacks into\n * the driver while the function is running.\n */\nvoid cfg80211_shutdown_all_interfaces(struct wiphy *wiphy);\n\n/**\n * wiphy_ext_feature_set - set the extended feature flag\n *\n * @wiphy: the wiphy to modify.\n * @ftidx: extended feature bit index.\n *\n * The extended features are flagged in multiple bytes (see\n * &struct wiphy.@ext_features)\n */\nstatic inline void wiphy_ext_feature_set(struct wiphy *wiphy,\n\t\t\t\t\t enum nl80211_ext_feature_index ftidx)\n{\n\tu8 *ft_byte;\n\n\tft_byte = &wiphy->ext_features[ftidx / 8];\n\t*ft_byte |= BIT(ftidx % 8);\n}\n\n/**\n * wiphy_ext_feature_isset - check the extended feature flag\n *\n * @wiphy: the wiphy to modify.\n * @ftidx: extended feature bit index.\n *\n * The extended features are flagged in multiple bytes (see\n * &struct wiphy.@ext_features)\n */\nstatic inline bool\nwiphy_ext_feature_isset(struct wiphy *wiphy,\n\t\t\tenum nl80211_ext_feature_index ftidx)\n{\n\tu8 ft_byte;\n\n\tft_byte = wiphy->ext_features[ftidx / 8];\n\treturn (ft_byte & BIT(ftidx % 8)) != 0;\n}\n\n/**\n * cfg80211_free_nan_func - free NAN function\n * @f: NAN function that should be freed\n *\n * Frees all the NAN function and all it's allocated members.\n */\nvoid cfg80211_free_nan_func(struct cfg80211_nan_func *f);\n\n/**\n * struct cfg80211_nan_match_params - NAN match parameters\n * @type: the type of the function that triggered a match. If it is\n *\t %NL80211_NAN_FUNC_SUBSCRIBE it means that we replied to a subscriber.\n *\t If it is %NL80211_NAN_FUNC_PUBLISH, it means that we got a discovery\n *\t result.\n *\t If it is %NL80211_NAN_FUNC_FOLLOW_UP, we received a follow up.\n * @inst_id: the local instance id\n * @peer_inst_id: the instance id of the peer's function\n * @addr: the MAC address of the peer\n * @info_len: the length of the &info\n * @info: the Service Specific Info from the peer (if any)\n * @cookie: unique identifier of the corresponding function\n */\nstruct cfg80211_nan_match_params {\n\tenum nl80211_nan_function_type type;\n\tu8 inst_id;\n\tu8 peer_inst_id;\n\tconst u8 *addr;\n\tu8 info_len;\n\tconst u8 *info;\n\tu64 cookie;\n};\n\n/**\n * cfg80211_nan_match - report a match for a NAN function.\n * @wdev: the wireless device reporting the match\n * @match: match notification parameters\n * @gfp: allocation flags\n *\n * This function reports that the a NAN function had a match. This\n * can be a subscribe that had a match or a solicited publish that\n * was sent. It can also be a follow up that was received.\n */\nvoid cfg80211_nan_match(struct wireless_dev *wdev,\n\t\t\tstruct cfg80211_nan_match_params *match, gfp_t gfp);\n\n/**\n * cfg80211_nan_func_terminated - notify about NAN function termination.\n *\n * @wdev: the wireless device reporting the match\n * @inst_id: the local instance id\n * @reason: termination reason (one of the NL80211_NAN_FUNC_TERM_REASON_*)\n * @cookie: unique NAN function identifier\n * @gfp: allocation flags\n *\n * This function reports that the a NAN function is terminated.\n */\nvoid cfg80211_nan_func_terminated(struct wireless_dev *wdev,\n\t\t\t\t  u8 inst_id,\n\t\t\t\t  enum nl80211_nan_func_term_reason reason,\n\t\t\t\t  u64 cookie, gfp_t gfp);\n\n/* ethtool helper */\nvoid cfg80211_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info);\n\n/**\n * cfg80211_external_auth_request - userspace request for authentication\n * @netdev: network device\n * @params: External authentication parameters\n * @gfp: allocation flags\n * Returns: 0 on success, < 0 on error\n */\nint cfg80211_external_auth_request(struct net_device *netdev,\n\t\t\t\t   struct cfg80211_external_auth_params *params,\n\t\t\t\t   gfp_t gfp);\n\n/**\n * cfg80211_pmsr_report - report peer measurement result data\n * @wdev: the wireless device reporting the measurement\n * @req: the original measurement request\n * @result: the result data\n * @gfp: allocation flags\n */\nvoid cfg80211_pmsr_report(struct wireless_dev *wdev,\n\t\t\t  struct cfg80211_pmsr_request *req,\n\t\t\t  struct cfg80211_pmsr_result *result,\n\t\t\t  gfp_t gfp);\n\n/**\n * cfg80211_pmsr_complete - report peer measurement completed\n * @wdev: the wireless device reporting the measurement\n * @req: the original measurement request\n * @gfp: allocation flags\n *\n * Report that the entire measurement completed, after this\n * the request pointer will no longer be valid.\n */\nvoid cfg80211_pmsr_complete(struct wireless_dev *wdev,\n\t\t\t    struct cfg80211_pmsr_request *req,\n\t\t\t    gfp_t gfp);\n\n/**\n * cfg80211_iftype_allowed - check whether the interface can be allowed\n * @wiphy: the wiphy\n * @iftype: interface type\n * @is_4addr: use_4addr flag, must be '0' when check_swif is '1'\n * @check_swif: check iftype against software interfaces\n *\n * Check whether the interface is allowed to operate; additionally, this API\n * can be used to check iftype against the software interfaces when\n * check_swif is '1'.\n */\nbool cfg80211_iftype_allowed(struct wiphy *wiphy, enum nl80211_iftype iftype,\n\t\t\t     bool is_4addr, u8 check_swif);\n\n\n/* Logging, debugging and troubleshooting/diagnostic helpers. */\n\n/* wiphy_printk helpers, similar to dev_printk */\n\n#define wiphy_printk(level, wiphy, format, args...)\t\t\\\n\tdev_printk(level, &(wiphy)->dev, format, ##args)\n#define wiphy_emerg(wiphy, format, args...)\t\t\t\\\n\tdev_emerg(&(wiphy)->dev, format, ##args)\n#define wiphy_alert(wiphy, format, args...)\t\t\t\\\n\tdev_alert(&(wiphy)->dev, format, ##args)\n#define wiphy_crit(wiphy, format, args...)\t\t\t\\\n\tdev_crit(&(wiphy)->dev, format, ##args)\n#define wiphy_err(wiphy, format, args...)\t\t\t\\\n\tdev_err(&(wiphy)->dev, format, ##args)\n#define wiphy_warn(wiphy, format, args...)\t\t\t\\\n\tdev_warn(&(wiphy)->dev, format, ##args)\n#define wiphy_notice(wiphy, format, args...)\t\t\t\\\n\tdev_notice(&(wiphy)->dev, format, ##args)\n#define wiphy_info(wiphy, format, args...)\t\t\t\\\n\tdev_info(&(wiphy)->dev, format, ##args)\n\n#define wiphy_err_ratelimited(wiphy, format, args...)\t\t\\\n\tdev_err_ratelimited(&(wiphy)->dev, format, ##args)\n#define wiphy_warn_ratelimited(wiphy, format, args...)\t\t\\\n\tdev_warn_ratelimited(&(wiphy)->dev, format, ##args)\n\n#define wiphy_debug(wiphy, format, args...)\t\t\t\\\n\twiphy_printk(KERN_DEBUG, wiphy, format, ##args)\n\n#define wiphy_dbg(wiphy, format, args...)\t\t\t\\\n\tdev_dbg(&(wiphy)->dev, format, ##args)\n\n#if defined(VERBOSE_DEBUG)\n#define wiphy_vdbg\twiphy_dbg\n#else\n#define wiphy_vdbg(wiphy, format, args...)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\t\\\n\t\twiphy_printk(KERN_DEBUG, wiphy, format, ##args);\t\\\n\t0;\t\t\t\t\t\t\t\t\\\n})\n#endif\n\n/*\n * wiphy_WARN() acts like wiphy_printk(), but with the key difference\n * of using a WARN/WARN_ON to get the message out, including the\n * file/line information and a backtrace.\n */\n#define wiphy_WARN(wiphy, format, args...)\t\t\t\\\n\tWARN(1, \"wiphy: %s\\n\" format, wiphy_name(wiphy), ##args);\n\n/**\n * cfg80211_update_owe_info_event - Notify the peer's OWE info to user space\n * @netdev: network device\n * @owe_info: peer's owe info\n * @gfp: allocation flags\n */\nvoid cfg80211_update_owe_info_event(struct net_device *netdev,\n\t\t\t\t    struct cfg80211_update_owe_info *owe_info,\n\t\t\t\t    gfp_t gfp);\n\n/**\n * cfg80211_bss_flush - resets all the scan entries\n * @wiphy: the wiphy\n */\nvoid cfg80211_bss_flush(struct wiphy *wiphy);\n\n#endif /* __NET_CFG80211_H */\n"}}, "reports": [{"events": [{"location": {"col": 6, "file": 1, "line": 3199}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 1, "line": 3199}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 1, "line": 3209}, "message": "'netdev' is null"}, {"location": {"col": 2, "file": 1, "line": 3209}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 1, "line": 3210}, "message": "Value assigned to 'rdev'"}, {"location": {"col": 7, "file": 1, "line": 3212}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 2, "line": 36}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 2, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 3, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 2, "line": 36}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 7, "file": 1, "line": 3212}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 3, "file": 1, "line": 3212}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 1, "line": 3222}, "message": "Assuming 'rdev' is null"}, {"location": {"col": 2, "file": 1, "line": 3222}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 1, "line": 3231}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 1, "line": 3231}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 1, "line": 3235}, "message": "'result' is 0"}, {"location": {"col": 2, "file": 1, "line": 3235}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 1, "line": 3238}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 1, "line": 3238}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 1, "line": 3284}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 1, "line": 3284}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 1, "line": 3293}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 1, "line": 3293}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 1, "line": 3325}, "message": "Assuming the condition is false"}, {"location": {"col": 49, "file": 1, "line": 3325}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 1, "line": 3357}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 1, "line": 3357}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 1, "line": 3364}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 1, "line": 3364}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 1, "line": 3371}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 1, "line": 3371}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 1, "line": 3391}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 1, "line": 3391}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 1, "line": 3397}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 1, "line": 3397}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 1, "line": 3408}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 1, "line": 3408}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 1, "line": 3417}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 1, "line": 3417}, "message": "Taking true branch"}, {"location": {"col": 32, "file": 1, "line": 3418}, "message": "Passing null pointer value via 1st parameter 'wiphy'"}, {"location": {"col": 8, "file": 1, "line": 3418}, "message": "Calling 'wiphy_ext_feature_isset'"}, {"location": {"col": 12, "file": 0, "line": 7990}, "message": "Array access (via field 'ext_features') results in a null pointer dereference"}, {"location": {"col": 12, "file": 0, "line": 7990}, "message": "Array access (via field 'ext_features') results in a null pointer dereference"}], "macros": [], "notes": [], "path": "/src/include/net/cfg80211.h", "reportHash": "5170af2ed6d834068003740a478762d2", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
