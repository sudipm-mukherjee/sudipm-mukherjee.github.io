<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/fs/ext4/resize.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n *  linux/fs/ext4/resize.c\n *\n * Support for resizing an ext4 filesystem while it is mounted.\n *\n * Copyright (C) 2001, 2002 Andreas Dilger <adilger@clusterfs.com>\n *\n * This could probably be made into a module, because it is not often in use.\n */\n\n\n#define EXT4FS_DEBUG\n\n#include <linux/errno.h>\n#include <linux/slab.h>\n\n#include \"ext4_jbd2.h\"\n\nstruct ext4_rcu_ptr {\n\tstruct rcu_head rcu;\n\tvoid *ptr;\n};\n\nstatic void ext4_rcu_ptr_callback(struct rcu_head *head)\n{\n\tstruct ext4_rcu_ptr *ptr;\n\n\tptr = container_of(head, struct ext4_rcu_ptr, rcu);\n\tkvfree(ptr->ptr);\n\tkfree(ptr);\n}\n\nvoid ext4_kvfree_array_rcu(void *to_free)\n{\n\tstruct ext4_rcu_ptr *ptr = kzalloc(sizeof(*ptr), GFP_KERNEL);\n\n\tif (ptr) {\n\t\tptr->ptr = to_free;\n\t\tcall_rcu(&ptr->rcu, ext4_rcu_ptr_callback);\n\t\treturn;\n\t}\n\tsynchronize_rcu();\n\tkvfree(to_free);\n}\n\nint ext4_resize_begin(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint ret = 0;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\t/*\n\t * If we are not using the primary superblock/GDT copy don't resize,\n         * because the user tools have no way of handling this.  Probably a\n         * bad time to do it anyways.\n         */\n\tif (EXT4_B2C(sbi, sbi->s_sbh->b_blocknr) !=\n\t    le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) {\n\t\text4_warning(sb, \"won't resize using backup superblock at %llu\",\n\t\t\t(unsigned long long)EXT4_SB(sb)->s_sbh->b_blocknr);\n\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * We are not allowed to do online-resizing on a filesystem mounted\n\t * with error, because it can destroy the filesystem easily.\n\t */\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_ERROR_FS) {\n\t\text4_warning(sb, \"There are errors in the filesystem, \"\n\t\t\t     \"so online resizing is not allowed\");\n\t\treturn -EPERM;\n\t}\n\n\tif (test_and_set_bit_lock(EXT4_FLAGS_RESIZING,\n\t\t\t\t  &EXT4_SB(sb)->s_ext4_flags))\n\t\tret = -EBUSY;\n\n\treturn ret;\n}\n\nvoid ext4_resize_end(struct super_block *sb)\n{\n\tclear_bit_unlock(EXT4_FLAGS_RESIZING, &EXT4_SB(sb)->s_ext4_flags);\n\tsmp_mb__after_atomic();\n}\n\nstatic ext4_group_t ext4_meta_bg_first_group(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t group) {\n\treturn (group >> EXT4_DESC_PER_BLOCK_BITS(sb)) <<\n\t       EXT4_DESC_PER_BLOCK_BITS(sb);\n}\n\nstatic ext4_fsblk_t ext4_meta_bg_first_block_no(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t group) {\n\tgroup = ext4_meta_bg_first_group(sb, group);\n\treturn ext4_group_first_block_no(sb, group);\n}\n\nstatic ext4_grpblk_t ext4_group_overhead_blocks(struct super_block *sb,\n\t\t\t\t\t\text4_group_t group) {\n\text4_grpblk_t overhead;\n\toverhead = ext4_bg_num_gdb(sb, group);\n\tif (ext4_bg_has_super(sb, group))\n\t\toverhead += 1 +\n\t\t\t  le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\treturn overhead;\n}\n\n#define outside(b, first, last)\t((b) < (first) || (b) >= (last))\n#define inside(b, first, last)\t((b) >= (first) && (b) < (last))\n\nstatic int verify_group_input(struct super_block *sb,\n\t\t\t      struct ext4_new_group_data *input)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_fsblk_t start = ext4_blocks_count(es);\n\text4_fsblk_t end = start + input->blocks_count;\n\text4_group_t group = input->group;\n\text4_fsblk_t itend = input->inode_table + sbi->s_itb_per_group;\n\tunsigned overhead;\n\text4_fsblk_t metaend;\n\tstruct buffer_head *bh = NULL;\n\text4_grpblk_t free_blocks_count, offset;\n\tint err = -EINVAL;\n\n\tif (group != sbi->s_groups_count) {\n\t\text4_warning(sb, \"Cannot add at group %u (only %u groups)\",\n\t\t\t     input->group, sbi->s_groups_count);\n\t\treturn -EINVAL;\n\t}\n\n\toverhead = ext4_group_overhead_blocks(sb, group);\n\tmetaend = start + overhead;\n\tinput->free_clusters_count = free_blocks_count =\n\t\tinput->blocks_count - 2 - overhead - sbi->s_itb_per_group;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT4-fs: adding %s group %u: %u blocks \"\n\t\t       \"(%d free, %u reserved)\\n\",\n\t\t       ext4_bg_has_super(sb, input->group) ? \"normal\" :\n\t\t       \"no-super\", input->group, input->blocks_count,\n\t\t       free_blocks_count, input->reserved_blocks);\n\n\text4_get_group_no_and_offset(sb, start, NULL, &offset);\n\tif (offset != 0)\n\t\t\text4_warning(sb, \"Last group not full\");\n\telse if (input->reserved_blocks > input->blocks_count / 5)\n\t\text4_warning(sb, \"Reserved blocks too high (%u)\",\n\t\t\t     input->reserved_blocks);\n\telse if (free_blocks_count < 0)\n\t\text4_warning(sb, \"Bad blocks count %u\",\n\t\t\t     input->blocks_count);\n\telse if (IS_ERR(bh = ext4_sb_bread(sb, end - 1, 0))) {\n\t\terr = PTR_ERR(bh);\n\t\tbh = NULL;\n\t\text4_warning(sb, \"Cannot read last block (%llu)\",\n\t\t\t     end - 1);\n\t} else if (outside(input->block_bitmap, start, end))\n\t\text4_warning(sb, \"Block bitmap not in group (block %llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap);\n\telse if (outside(input->inode_bitmap, start, end))\n\t\text4_warning(sb, \"Inode bitmap not in group (block %llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap);\n\telse if (outside(input->inode_table, start, end) ||\n\t\t outside(itend - 1, start, end))\n\t\text4_warning(sb, \"Inode table not in group (blocks %llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (input->inode_bitmap == input->block_bitmap)\n\t\text4_warning(sb, \"Block bitmap same as inode bitmap (%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap);\n\telse if (inside(input->block_bitmap, input->inode_table, itend))\n\t\text4_warning(sb, \"Block bitmap (%llu) in inode table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap,\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (inside(input->inode_bitmap, input->inode_table, itend))\n\t\text4_warning(sb, \"Inode bitmap (%llu) in inode table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap,\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (inside(input->block_bitmap, start, metaend))\n\t\text4_warning(sb, \"Block bitmap (%llu) in GDT table (%llu-%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap,\n\t\t\t     start, metaend - 1);\n\telse if (inside(input->inode_bitmap, start, metaend))\n\t\text4_warning(sb, \"Inode bitmap (%llu) in GDT table (%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap,\n\t\t\t     start, metaend - 1);\n\telse if (inside(input->inode_table, start, metaend) ||\n\t\t inside(itend - 1, start, metaend))\n\t\text4_warning(sb, \"Inode table (%llu-%llu) overlaps GDT table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_table,\n\t\t\t     itend - 1, start, metaend - 1);\n\telse\n\t\terr = 0;\n\tbrelse(bh);\n\n\treturn err;\n}\n\n/*\n * ext4_new_flex_group_data is used by 64bit-resize interface to add a flex\n * group each time.\n */\nstruct ext4_new_flex_group_data {\n\tstruct ext4_new_group_data *groups;\t/* new_group_data for groups\n\t\t\t\t\t\t   in the flex group */\n\t__u16 *bg_flags;\t\t\t/* block group flags of groups\n\t\t\t\t\t\t   in @groups */\n\text4_group_t count;\t\t\t/* number of groups in @groups\n\t\t\t\t\t\t */\n};\n\n/*\n * alloc_flex_gd() allocates a ext4_new_flex_group_data with size of\n * @flexbg_size.\n *\n * Returns NULL on failure otherwise address of the allocated structure.\n */\nstatic struct ext4_new_flex_group_data *alloc_flex_gd(unsigned long flexbg_size)\n{\n\tstruct ext4_new_flex_group_data *flex_gd;\n\n\tflex_gd = kmalloc(sizeof(*flex_gd), GFP_NOFS);\n\tif (flex_gd == NULL)\n\t\tgoto out3;\n\n\tif (flexbg_size >= UINT_MAX / sizeof(struct ext4_new_group_data))\n\t\tgoto out2;\n\tflex_gd->count = flexbg_size;\n\n\tflex_gd->groups = kmalloc_array(flexbg_size,\n\t\t\t\t\tsizeof(struct ext4_new_group_data),\n\t\t\t\t\tGFP_NOFS);\n\tif (flex_gd->groups == NULL)\n\t\tgoto out2;\n\n\tflex_gd->bg_flags = kmalloc_array(flexbg_size, sizeof(__u16),\n\t\t\t\t\t  GFP_NOFS);\n\tif (flex_gd->bg_flags == NULL)\n\t\tgoto out1;\n\n\treturn flex_gd;\n\nout1:\n\tkfree(flex_gd->groups);\nout2:\n\tkfree(flex_gd);\nout3:\n\treturn NULL;\n}\n\nstatic void free_flex_gd(struct ext4_new_flex_group_data *flex_gd)\n{\n\tkfree(flex_gd->bg_flags);\n\tkfree(flex_gd->groups);\n\tkfree(flex_gd);\n}\n\n/*\n * ext4_alloc_group_tables() allocates block bitmaps, inode bitmaps\n * and inode tables for a flex group.\n *\n * This function is used by 64bit-resize.  Note that this function allocates\n * group tables from the 1st group of groups contained by @flexgd, which may\n * be a partial of a flex group.\n *\n * @sb: super block of fs to which the groups belongs\n *\n * Returns 0 on a successful allocation of the metadata blocks in the\n * block group.\n */\nstatic int ext4_alloc_group_tables(struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd,\n\t\t\t\tint flexbg_size)\n{\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\text4_fsblk_t start_blk;\n\text4_fsblk_t last_blk;\n\text4_group_t src_group;\n\text4_group_t bb_index = 0;\n\text4_group_t ib_index = 0;\n\text4_group_t it_index = 0;\n\text4_group_t group;\n\text4_group_t last_group;\n\tunsigned overhead;\n\t__u16 uninit_mask = (flexbg_size > 1) ? ~EXT4_BG_BLOCK_UNINIT : ~0;\n\tint i;\n\n\tBUG_ON(flex_gd->count == 0 || group_data == NULL);\n\n\tsrc_group = group_data[0].group;\n\tlast_group  = src_group + flex_gd->count - 1;\n\n\tBUG_ON((flexbg_size > 1) && ((src_group & ~(flexbg_size - 1)) !=\n\t       (last_group & ~(flexbg_size - 1))));\nnext_group:\n\tgroup = group_data[0].group;\n\tif (src_group >= group_data[0].group + flex_gd->count)\n\t\treturn -ENOSPC;\n\tstart_blk = ext4_group_first_block_no(sb, src_group);\n\tlast_blk = start_blk + group_data[src_group - group].blocks_count;\n\n\toverhead = ext4_group_overhead_blocks(sb, src_group);\n\n\tstart_blk += overhead;\n\n\t/* We collect contiguous blocks as much as possible. */\n\tsrc_group++;\n\tfor (; src_group <= last_group; src_group++) {\n\t\toverhead = ext4_group_overhead_blocks(sb, src_group);\n\t\tif (overhead == 0)\n\t\t\tlast_blk += group_data[src_group - group].blocks_count;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\t/* Allocate block bitmaps */\n\tfor (; bb_index < flex_gd->count; bb_index++) {\n\t\tif (start_blk >= last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[bb_index].block_bitmap = start_blk++;\n\t\tgroup = ext4_get_group_number(sb, start_blk - 1);\n\t\tgroup -= group_data[0].group;\n\t\tgroup_data[group].mdata_blocks++;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t}\n\n\t/* Allocate inode bitmaps */\n\tfor (; ib_index < flex_gd->count; ib_index++) {\n\t\tif (start_blk >= last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[ib_index].inode_bitmap = start_blk++;\n\t\tgroup = ext4_get_group_number(sb, start_blk - 1);\n\t\tgroup -= group_data[0].group;\n\t\tgroup_data[group].mdata_blocks++;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t}\n\n\t/* Allocate inode tables */\n\tfor (; it_index < flex_gd->count; it_index++) {\n\t\tunsigned int itb = EXT4_SB(sb)->s_itb_per_group;\n\t\text4_fsblk_t next_group_start;\n\n\t\tif (start_blk + itb > last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[it_index].inode_table = start_blk;\n\t\tgroup = ext4_get_group_number(sb, start_blk);\n\t\tnext_group_start = ext4_group_first_block_no(sb, group + 1);\n\t\tgroup -= group_data[0].group;\n\n\t\tif (start_blk + itb > next_group_start) {\n\t\t\tflex_gd->bg_flags[group + 1] &= uninit_mask;\n\t\t\toverhead = start_blk + itb - next_group_start;\n\t\t\tgroup_data[group + 1].mdata_blocks += overhead;\n\t\t\titb -= overhead;\n\t\t}\n\n\t\tgroup_data[group].mdata_blocks += itb;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t\tstart_blk += EXT4_SB(sb)->s_itb_per_group;\n\t}\n\n\t/* Update free clusters count to exclude metadata blocks */\n\tfor (i = 0; i < flex_gd->count; i++) {\n\t\tgroup_data[i].free_clusters_count -=\n\t\t\t\tEXT4_NUM_B2C(EXT4_SB(sb),\n\t\t\t\t\t     group_data[i].mdata_blocks);\n\t}\n\n\tif (test_opt(sb, DEBUG)) {\n\t\tint i;\n\t\tgroup = group_data[0].group;\n\n\t\tprintk(KERN_DEBUG \"EXT4-fs: adding a flex group with \"\n\t\t       \"%d groups, flexbg size is %d:\\n\", flex_gd->count,\n\t\t       flexbg_size);\n\n\t\tfor (i = 0; i < flex_gd->count; i++) {\n\t\t\text4_debug(\n\t\t\t       \"adding %s group %u: %u blocks (%d free, %d mdata blocks)\\n\",\n\t\t\t       ext4_bg_has_super(sb, group + i) ? \"normal\" :\n\t\t\t       \"no-super\", group + i,\n\t\t\t       group_data[i].blocks_count,\n\t\t\t       group_data[i].free_clusters_count,\n\t\t\t       group_data[i].mdata_blocks);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic struct buffer_head *bclean(handle_t *handle, struct super_block *sb,\n\t\t\t\t  ext4_fsblk_t blk)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tbh = sb_getblk(sb, blk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\tif ((err = ext4_journal_get_write_access(handle, bh))) {\n\t\tbrelse(bh);\n\t\tbh = ERR_PTR(err);\n\t} else {\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t}\n\n\treturn bh;\n}\n\nstatic int ext4_resize_ensure_credits_batch(handle_t *handle, int credits)\n{\n\treturn ext4_journal_ensure_credits_fn(handle, credits,\n\t\tEXT4_MAX_TRANS_DATA, 0, 0);\n}\n\n/*\n * set_flexbg_block_bitmap() mark clusters [@first_cluster, @last_cluster] used.\n *\n * Helper function for ext4_setup_new_group_blocks() which set .\n *\n * @sb: super block\n * @handle: journal handle\n * @flex_gd: flex group data\n */\nstatic int set_flexbg_block_bitmap(struct super_block *sb, handle_t *handle,\n\t\t\tstruct ext4_new_flex_group_data *flex_gd,\n\t\t\text4_fsblk_t first_cluster, ext4_fsblk_t last_cluster)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t count = last_cluster - first_cluster + 1;\n\text4_group_t count2;\n\n\text4_debug(\"mark clusters [%llu-%llu] used\\n\", first_cluster,\n\t\t   last_cluster);\n\tfor (count2 = count; count > 0;\n\t     count -= count2, first_cluster += count2) {\n\t\text4_fsblk_t start;\n\t\tstruct buffer_head *bh;\n\t\text4_group_t group;\n\t\tint err;\n\n\t\tgroup = ext4_get_group_number(sb, EXT4_C2B(sbi, first_cluster));\n\t\tstart = EXT4_B2C(sbi, ext4_group_first_block_no(sb, group));\n\t\tgroup -= flex_gd->groups[0].group;\n\n\t\tcount2 = EXT4_CLUSTERS_PER_GROUP(sb) - (first_cluster - start);\n\t\tif (count2 > count)\n\t\t\tcount2 = count;\n\n\t\tif (flex_gd->bg_flags[group] & EXT4_BG_BLOCK_UNINIT) {\n\t\t\tBUG_ON(flex_gd->count > 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = ext4_resize_ensure_credits_batch(handle, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tbh = sb_getblk(sb, flex_gd->groups[group].block_bitmap);\n\t\tif (unlikely(!bh))\n\t\t\treturn -ENOMEM;\n\n\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, bh);\n\t\tif (err) {\n\t\t\tbrelse(bh);\n\t\t\treturn err;\n\t\t}\n\t\text4_debug(\"mark block bitmap %#04llx (+%llu/%u)\\n\",\n\t\t\t   first_cluster, first_cluster - start, count2);\n\t\text4_set_bits(bh->b_data, first_cluster - start, count2);\n\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tbrelse(bh);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Set up the block and inode bitmaps, and the inode table for the new groups.\n * This doesn't need to be part of the main transaction, since we are only\n * changing blocks outside the actual filesystem.  We still do journaling to\n * ensure the recovery is correct in case of a failure just after resize.\n * If any part of this fails, we simply abort the resize.\n *\n * setup_new_flex_group_blocks handles a flex group as follow:\n *  1. copy super block and GDT, and initialize group tables if necessary.\n *     In this step, we only set bits in blocks bitmaps for blocks taken by\n *     super block and GDT.\n *  2. allocate group tables in block bitmaps, that is, set bits in block\n *     bitmap for blocks taken by group tables.\n */\nstatic int setup_new_flex_group_blocks(struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd)\n{\n\tint group_table_count[] = {1, 1, EXT4_SB(sb)->s_itb_per_group};\n\text4_fsblk_t start;\n\text4_fsblk_t block;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\t__u16 *bg_flags = flex_gd->bg_flags;\n\thandle_t *handle;\n\text4_group_t group, count;\n\tstruct buffer_head *bh = NULL;\n\tint reserved_gdb, i, j, err = 0, err2;\n\tint meta_bg;\n\n\tBUG_ON(!flex_gd->count || !group_data ||\n\t       group_data[0].group != sbi->s_groups_count);\n\n\treserved_gdb = le16_to_cpu(es->s_reserved_gdt_blocks);\n\tmeta_bg = ext4_has_feature_meta_bg(sb);\n\n\t/* This transaction may be extended/restarted along the way */\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, EXT4_MAX_TRANS_DATA);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tgroup = group_data[0].group;\n\tfor (i = 0; i < flex_gd->count; i++, group++) {\n\t\tunsigned long gdblocks;\n\t\text4_grpblk_t overhead;\n\n\t\tgdblocks = ext4_bg_num_gdb(sb, group);\n\t\tstart = ext4_group_first_block_no(sb, group);\n\n\t\tif (meta_bg == 0 && !ext4_bg_has_super(sb, group))\n\t\t\tgoto handle_itb;\n\n\t\tif (meta_bg == 1) {\n\t\t\text4_group_t first_group;\n\t\t\tfirst_group = ext4_meta_bg_first_group(sb, group);\n\t\t\tif (first_group != group + 1 &&\n\t\t\t    first_group != group + EXT4_DESC_PER_BLOCK(sb) - 1)\n\t\t\t\tgoto handle_itb;\n\t\t}\n\n\t\tblock = start + ext4_bg_has_super(sb, group);\n\t\t/* Copy all of the GDT blocks into the backup in this group */\n\t\tfor (j = 0; j < gdblocks; j++, block++) {\n\t\t\tstruct buffer_head *gdb;\n\n\t\t\text4_debug(\"update backup group %#04llx\\n\", block);\n\t\t\terr = ext4_resize_ensure_credits_batch(handle, 1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t\tgdb = sb_getblk(sb, block);\n\t\t\tif (unlikely(!gdb)) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUFFER_TRACE(gdb, \"get_write_access\");\n\t\t\terr = ext4_journal_get_write_access(handle, gdb);\n\t\t\tif (err) {\n\t\t\t\tbrelse(gdb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(gdb->b_data, sbi_array_rcu_deref(sbi,\n\t\t\t\ts_group_desc, j)->b_data, gdb->b_size);\n\t\t\tset_buffer_uptodate(gdb);\n\n\t\t\terr = ext4_handle_dirty_metadata(handle, NULL, gdb);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tbrelse(gdb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbrelse(gdb);\n\t\t}\n\n\t\t/* Zero out all of the reserved backup group descriptor\n\t\t * table blocks\n\t\t */\n\t\tif (ext4_bg_has_super(sb, group)) {\n\t\t\terr = sb_issue_zeroout(sb, gdblocks + start + 1,\n\t\t\t\t\treserved_gdb, GFP_NOFS);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\nhandle_itb:\n\t\t/* Initialize group tables of the grop @group */\n\t\tif (!(bg_flags[i] & EXT4_BG_INODE_ZEROED))\n\t\t\tgoto handle_bb;\n\n\t\t/* Zero out all of the inode table blocks */\n\t\tblock = group_data[i].inode_table;\n\t\text4_debug(\"clear inode table blocks %#04llx -> %#04lx\\n\",\n\t\t\t   block, sbi->s_itb_per_group);\n\t\terr = sb_issue_zeroout(sb, block, sbi->s_itb_per_group,\n\t\t\t\t       GFP_NOFS);\n\t\tif (err)\n\t\t\tgoto out;\n\nhandle_bb:\n\t\tif (bg_flags[i] & EXT4_BG_BLOCK_UNINIT)\n\t\t\tgoto handle_ib;\n\n\t\t/* Initialize block bitmap of the @group */\n\t\tblock = group_data[i].block_bitmap;\n\t\terr = ext4_resize_ensure_credits_batch(handle, 1);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\tbh = bclean(handle, sb, block);\n\t\tif (IS_ERR(bh)) {\n\t\t\terr = PTR_ERR(bh);\n\t\t\tgoto out;\n\t\t}\n\t\toverhead = ext4_group_overhead_blocks(sb, group);\n\t\tif (overhead != 0) {\n\t\t\text4_debug(\"mark backup superblock %#04llx (+0)\\n\",\n\t\t\t\t   start);\n\t\t\text4_set_bits(bh->b_data, 0,\n\t\t\t\t      EXT4_NUM_B2C(sbi, overhead));\n\t\t}\n\t\text4_mark_bitmap_end(EXT4_B2C(sbi, group_data[i].blocks_count),\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tbrelse(bh);\n\t\tif (err)\n\t\t\tgoto out;\n\nhandle_ib:\n\t\tif (bg_flags[i] & EXT4_BG_INODE_UNINIT)\n\t\t\tcontinue;\n\n\t\t/* Initialize inode bitmap of the @group */\n\t\tblock = group_data[i].inode_bitmap;\n\t\terr = ext4_resize_ensure_credits_batch(handle, 1);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\t/* Mark unused entries in inode bitmap used */\n\t\tbh = bclean(handle, sb, block);\n\t\tif (IS_ERR(bh)) {\n\t\t\terr = PTR_ERR(bh);\n\t\t\tgoto out;\n\t\t}\n\n\t\text4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tbrelse(bh);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/* Mark group tables in block bitmap */\n\tfor (j = 0; j < GROUP_TABLE_COUNT; j++) {\n\t\tcount = group_table_count[j];\n\t\tstart = (&group_data[0].block_bitmap)[j];\n\t\tblock = start;\n\t\tfor (i = 1; i < flex_gd->count; i++) {\n\t\t\tblock += group_table_count[j];\n\t\t\tif (block == (&group_data[i].block_bitmap)[j]) {\n\t\t\t\tcount += group_table_count[j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = set_flexbg_block_bitmap(sb, handle,\n\t\t\t\t\t\t      flex_gd,\n\t\t\t\t\t\t      EXT4_B2C(sbi, start),\n\t\t\t\t\t\t      EXT4_B2C(sbi,\n\t\t\t\t\t\t\t       start + count\n\t\t\t\t\t\t\t       - 1));\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tcount = group_table_count[j];\n\t\t\tstart = (&group_data[i].block_bitmap)[j];\n\t\t\tblock = start;\n\t\t}\n\n\t\tif (count) {\n\t\t\terr = set_flexbg_block_bitmap(sb, handle,\n\t\t\t\t\t\t      flex_gd,\n\t\t\t\t\t\t      EXT4_B2C(sbi, start),\n\t\t\t\t\t\t      EXT4_B2C(sbi,\n\t\t\t\t\t\t\t       start + count\n\t\t\t\t\t\t\t       - 1));\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\terr2 = ext4_journal_stop(handle);\n\tif (err2 && !err)\n\t\terr = err2;\n\n\treturn err;\n}\n\n/*\n * Iterate through the groups which hold BACKUP superblock/GDT copies in an\n * ext4 filesystem.  The counters should be initialized to 1, 5, and 7 before\n * calling this for the first time.  In a sparse filesystem it will be the\n * sequence of powers of 3, 5, and 7: 1, 3, 5, 7, 9, 25, 27, 49, 81, ...\n * For a non-sparse filesystem it will be every group: 1, 2, 3, 4, ...\n */\nstatic unsigned ext4_list_backups(struct super_block *sb, unsigned *three,\n\t\t\t\t  unsigned *five, unsigned *seven)\n{\n\tunsigned *min = three;\n\tint mult = 3;\n\tunsigned ret;\n\n\tif (!ext4_has_feature_sparse_super(sb)) {\n\t\tret = *min;\n\t\t*min += 1;\n\t\treturn ret;\n\t}\n\n\tif (*five < *min) {\n\t\tmin = five;\n\t\tmult = 5;\n\t}\n\tif (*seven < *min) {\n\t\tmin = seven;\n\t\tmult = 7;\n\t}\n\n\tret = *min;\n\t*min *= mult;\n\n\treturn ret;\n}\n\n/*\n * Check that all of the backup GDT blocks are held in the primary GDT block.\n * It is assumed that they are stored in group order.  Returns the number of\n * groups in current filesystem that have BACKUPS, or -ve error code.\n */\nstatic int verify_reserved_gdb(struct super_block *sb,\n\t\t\t       ext4_group_t end,\n\t\t\t       struct buffer_head *primary)\n{\n\tconst ext4_fsblk_t blk = primary->b_blocknr;\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned grp;\n\t__le32 *p = (__le32 *)primary->b_data;\n\tint gdbackups = 0;\n\n\twhile ((grp = ext4_list_backups(sb, &three, &five, &seven)) < end) {\n\t\tif (le32_to_cpu(*p++) !=\n\t\t    grp * EXT4_BLOCKS_PER_GROUP(sb) + blk){\n\t\t\text4_warning(sb, \"reserved GDT %llu\"\n\t\t\t\t     \" missing grp %d (%llu)\",\n\t\t\t\t     blk, grp,\n\t\t\t\t     grp *\n\t\t\t\t     (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\t\t\t     blk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (++gdbackups > EXT4_ADDR_PER_BLOCK(sb))\n\t\t\treturn -EFBIG;\n\t}\n\n\treturn gdbackups;\n}\n\n/*\n * Called when we need to bring a reserved group descriptor table block into\n * use from the resize inode.  The primary copy of the new GDT block currently\n * is an indirect block (under the double indirect block in the resize inode).\n * The new backup GDT blocks will be stored as leaf blocks in this indirect\n * block, in group order.  Even though we know all the block numbers we need,\n * we check to ensure that the resize inode has actually reserved these blocks.\n *\n * Don't need to update the block bitmaps because the blocks are still in use.\n *\n * We get all of the error cases out of the way, so that we are sure to not\n * fail once we start modifying the data on disk, because JBD has no rollback.\n */\nstatic int add_new_gdb(handle_t *handle, struct inode *inode,\n\t\t       ext4_group_t group)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tunsigned long gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\text4_fsblk_t gdblock = EXT4_SB(sb)->s_sbh->b_blocknr + 1 + gdb_num;\n\tstruct buffer_head **o_group_desc, **n_group_desc = NULL;\n\tstruct buffer_head *dind = NULL;\n\tstruct buffer_head *gdb_bh = NULL;\n\tint gdbackups;\n\tstruct ext4_iloc iloc = { .bh = NULL };\n\t__le32 *data;\n\tint err;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG\n\t\t       \"EXT4-fs: ext4_add_new_gdb: adding group block %lu\\n\",\n\t\t       gdb_num);\n\n\tgdb_bh = ext4_sb_bread(sb, gdblock, 0);\n\tif (IS_ERR(gdb_bh))\n\t\treturn PTR_ERR(gdb_bh);\n\n\tgdbackups = verify_reserved_gdb(sb, group, gdb_bh);\n\tif (gdbackups < 0) {\n\t\terr = gdbackups;\n\t\tgoto errout;\n\t}\n\n\tdata = EXT4_I(inode)->i_data + EXT4_DIND_BLOCK;\n\tdind = ext4_sb_bread(sb, le32_to_cpu(*data), 0);\n\tif (IS_ERR(dind)) {\n\t\terr = PTR_ERR(dind);\n\t\tdind = NULL;\n\t\tgoto errout;\n\t}\n\n\tdata = (__le32 *)dind->b_data;\n\tif (le32_to_cpu(data[gdb_num % EXT4_ADDR_PER_BLOCK(sb)]) != gdblock) {\n\t\text4_warning(sb, \"new group %u GDT block %llu not reserved\",\n\t\t\t     group, gdblock);\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);\n\tif (unlikely(err))\n\t\tgoto errout;\n\n\tBUFFER_TRACE(gdb_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gdb_bh);\n\tif (unlikely(err))\n\t\tgoto errout;\n\n\tBUFFER_TRACE(dind, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, dind);\n\tif (unlikely(err)) {\n\t\text4_std_error(sb, err);\n\t\tgoto errout;\n\t}\n\n\t/* ext4_reserve_inode_write() gets a reference on the iloc */\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (unlikely(err))\n\t\tgoto errout;\n\n\tn_group_desc = kvmalloc((gdb_num + 1) * sizeof(struct buffer_head *),\n\t\t\t\tGFP_KERNEL);\n\tif (!n_group_desc) {\n\t\terr = -ENOMEM;\n\t\text4_warning(sb, \"not enough memory for %lu groups\",\n\t\t\t     gdb_num + 1);\n\t\tgoto errout;\n\t}\n\n\t/*\n\t * Finally, we have all of the possible failures behind us...\n\t *\n\t * Remove new GDT block from inode double-indirect block and clear out\n\t * the new GDT block for use (which also \"frees\" the backup GDT blocks\n\t * from the reserved inode).  We don't need to change the bitmaps for\n\t * these blocks, because they are marked as in-use from being in the\n\t * reserved inode, and will become GDT blocks (primary and backup).\n\t */\n\tdata[gdb_num % EXT4_ADDR_PER_BLOCK(sb)] = 0;\n\terr = ext4_handle_dirty_metadata(handle, NULL, dind);\n\tif (unlikely(err)) {\n\t\text4_std_error(sb, err);\n\t\tgoto errout;\n\t}\n\tinode->i_blocks -= (gdbackups + 1) * sb->s_blocksize >>\n\t\t\t   (9 - EXT4_SB(sb)->s_cluster_bits);\n\text4_mark_iloc_dirty(handle, inode, &iloc);\n\tmemset(gdb_bh->b_data, 0, sb->s_blocksize);\n\terr = ext4_handle_dirty_metadata(handle, NULL, gdb_bh);\n\tif (unlikely(err)) {\n\t\text4_std_error(sb, err);\n\t\tiloc.bh = NULL;\n\t\tgoto errout;\n\t}\n\tbrelse(dind);\n\n\trcu_read_lock();\n\to_group_desc = rcu_dereference(EXT4_SB(sb)->s_group_desc);\n\tmemcpy(n_group_desc, o_group_desc,\n\t       EXT4_SB(sb)->s_gdb_count * sizeof(struct buffer_head *));\n\trcu_read_unlock();\n\tn_group_desc[gdb_num] = gdb_bh;\n\trcu_assign_pointer(EXT4_SB(sb)->s_group_desc, n_group_desc);\n\tEXT4_SB(sb)->s_gdb_count++;\n\text4_kvfree_array_rcu(o_group_desc);\n\n\tlock_buffer(EXT4_SB(sb)->s_sbh);\n\tle16_add_cpu(&es->s_reserved_gdt_blocks, -1);\n\text4_superblock_csum_set(sb);\n\tunlock_buffer(EXT4_SB(sb)->s_sbh);\n\terr = ext4_handle_dirty_metadata(handle, NULL, EXT4_SB(sb)->s_sbh);\n\tif (err)\n\t\text4_std_error(sb, err);\n\treturn err;\nerrout:\n\tkvfree(n_group_desc);\n\tbrelse(iloc.bh);\n\tbrelse(dind);\n\tbrelse(gdb_bh);\n\n\text4_debug(\"leaving with error %d\\n\", err);\n\treturn err;\n}\n\n/*\n * add_new_gdb_meta_bg is the sister of add_new_gdb.\n */\nstatic int add_new_gdb_meta_bg(struct super_block *sb,\n\t\t\t       handle_t *handle, ext4_group_t group) {\n\text4_fsblk_t gdblock;\n\tstruct buffer_head *gdb_bh;\n\tstruct buffer_head **o_group_desc, **n_group_desc;\n\tunsigned long gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\tint err;\n\n\tgdblock = ext4_meta_bg_first_block_no(sb, group) +\n\t\t   ext4_bg_has_super(sb, group);\n\tgdb_bh = ext4_sb_bread(sb, gdblock, 0);\n\tif (IS_ERR(gdb_bh))\n\t\treturn PTR_ERR(gdb_bh);\n\tn_group_desc = kvmalloc((gdb_num + 1) * sizeof(struct buffer_head *),\n\t\t\t\tGFP_KERNEL);\n\tif (!n_group_desc) {\n\t\tbrelse(gdb_bh);\n\t\terr = -ENOMEM;\n\t\text4_warning(sb, \"not enough memory for %lu groups\",\n\t\t\t     gdb_num + 1);\n\t\treturn err;\n\t}\n\n\trcu_read_lock();\n\to_group_desc = rcu_dereference(EXT4_SB(sb)->s_group_desc);\n\tmemcpy(n_group_desc, o_group_desc,\n\t       EXT4_SB(sb)->s_gdb_count * sizeof(struct buffer_head *));\n\trcu_read_unlock();\n\tn_group_desc[gdb_num] = gdb_bh;\n\n\tBUFFER_TRACE(gdb_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gdb_bh);\n\tif (err) {\n\t\tkvfree(n_group_desc);\n\t\tbrelse(gdb_bh);\n\t\treturn err;\n\t}\n\n\trcu_assign_pointer(EXT4_SB(sb)->s_group_desc, n_group_desc);\n\tEXT4_SB(sb)->s_gdb_count++;\n\text4_kvfree_array_rcu(o_group_desc);\n\treturn err;\n}\n\n/*\n * Called when we are adding a new group which has a backup copy of each of\n * the GDT blocks (i.e. sparse group) and there are reserved GDT blocks.\n * We need to add these reserved backup GDT blocks to the resize inode, so\n * that they are kept for future resizing and not allocated to files.\n *\n * Each reserved backup GDT block will go into a different indirect block.\n * The indirect blocks are actually the primary reserved GDT blocks,\n * so we know in advance what their block numbers are.  We only get the\n * double-indirect block to verify it is pointing to the primary reserved\n * GDT blocks so we don't overwrite a data block by accident.  The reserved\n * backup GDT blocks are stored in their reserved primary GDT block.\n */\nstatic int reserve_backup_gdb(handle_t *handle, struct inode *inode,\n\t\t\t      ext4_group_t group)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint reserved_gdb =le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\tint cluster_bits = EXT4_SB(sb)->s_cluster_bits;\n\tstruct buffer_head **primary;\n\tstruct buffer_head *dind;\n\tstruct ext4_iloc iloc;\n\text4_fsblk_t blk;\n\t__le32 *data, *end;\n\tint gdbackups = 0;\n\tint res, i;\n\tint err;\n\n\tprimary = kmalloc_array(reserved_gdb, sizeof(*primary), GFP_NOFS);\n\tif (!primary)\n\t\treturn -ENOMEM;\n\n\tdata = EXT4_I(inode)->i_data + EXT4_DIND_BLOCK;\n\tdind = ext4_sb_bread(sb, le32_to_cpu(*data), 0);\n\tif (IS_ERR(dind)) {\n\t\terr = PTR_ERR(dind);\n\t\tdind = NULL;\n\t\tgoto exit_free;\n\t}\n\n\tblk = EXT4_SB(sb)->s_sbh->b_blocknr + 1 + EXT4_SB(sb)->s_gdb_count;\n\tdata = (__le32 *)dind->b_data + (EXT4_SB(sb)->s_gdb_count %\n\t\t\t\t\t EXT4_ADDR_PER_BLOCK(sb));\n\tend = (__le32 *)dind->b_data + EXT4_ADDR_PER_BLOCK(sb);\n\n\t/* Get each reserved primary GDT block and verify it holds backups */\n\tfor (res = 0; res < reserved_gdb; res++, blk++) {\n\t\tif (le32_to_cpu(*data) != blk) {\n\t\t\text4_warning(sb, \"reserved block %llu\"\n\t\t\t\t     \" not at offset %ld\",\n\t\t\t\t     blk,\n\t\t\t\t     (long)(data - (__le32 *)dind->b_data));\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tprimary[res] = ext4_sb_bread(sb, blk, 0);\n\t\tif (IS_ERR(primary[res])) {\n\t\t\terr = PTR_ERR(primary[res]);\n\t\t\tprimary[res] = NULL;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tgdbackups = verify_reserved_gdb(sb, group, primary[res]);\n\t\tif (gdbackups < 0) {\n\t\t\tbrelse(primary[res]);\n\t\t\terr = gdbackups;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif (++data >= end)\n\t\t\tdata = (__le32 *)dind->b_data;\n\t}\n\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tBUFFER_TRACE(primary[i], \"get_write_access\");\n\t\tif ((err = ext4_journal_get_write_access(handle, primary[i])))\n\t\t\tgoto exit_bh;\n\t}\n\n\tif ((err = ext4_reserve_inode_write(handle, inode, &iloc)))\n\t\tgoto exit_bh;\n\n\t/*\n\t * Finally we can add each of the reserved backup GDT blocks from\n\t * the new group to its reserved primary GDT block.\n\t */\n\tblk = group * EXT4_BLOCKS_PER_GROUP(sb);\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tint err2;\n\t\tdata = (__le32 *)primary[i]->b_data;\n\t\t/* printk(\"reserving backup %lu[%u] = %lu\\n\",\n\t\t       primary[i]->b_blocknr, gdbackups,\n\t\t       blk + primary[i]->b_blocknr); */\n\t\tdata[gdbackups] = cpu_to_le32(blk + primary[i]->b_blocknr);\n\t\terr2 = ext4_handle_dirty_metadata(handle, NULL, primary[i]);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\n\tinode->i_blocks += reserved_gdb * sb->s_blocksize >> (9 - cluster_bits);\n\text4_mark_iloc_dirty(handle, inode, &iloc);\n\nexit_bh:\n\twhile (--res >= 0)\n\t\tbrelse(primary[res]);\n\tbrelse(dind);\n\nexit_free:\n\tkfree(primary);\n\n\treturn err;\n}\n\n/*\n * Update the backup copies of the ext4 metadata.  These don't need to be part\n * of the main resize transaction, because e2fsck will re-write them if there\n * is a problem (basically only OOM will cause a problem).  However, we\n * _should_ update the backups if possible, in case the primary gets trashed\n * for some reason and we need to run e2fsck from a backup superblock.  The\n * important part is that the new block and inode counts are in the backup\n * superblocks, and the location of the new group metadata in the GDT backups.\n *\n * We do not need take the s_resize_lock for this, because these\n * blocks are not otherwise touched by the filesystem code when it is\n * mounted.  We don't need to worry about last changing from\n * sbi->s_groups_count, because the worst that can happen is that we\n * do not copy the full number of backups at this time.  The resize\n * which changed s_groups_count will backup again.\n */\nstatic void update_backups(struct super_block *sb, sector_t blk_off, char *data,\n\t\t\t   int size, int meta_bg)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t last;\n\tconst int bpg = EXT4_BLOCKS_PER_GROUP(sb);\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\text4_group_t group = 0;\n\tint rest = sb->s_blocksize - size;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, EXT4_MAX_TRANS_DATA);\n\tif (IS_ERR(handle)) {\n\t\tgroup = 1;\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_err;\n\t}\n\n\tif (meta_bg == 0) {\n\t\tgroup = ext4_list_backups(sb, &three, &five, &seven);\n\t\tlast = sbi->s_groups_count;\n\t} else {\n\t\tgroup = ext4_get_group_number(sb, blk_off) + 1;\n\t\tlast = (ext4_group_t)(group + EXT4_DESC_PER_BLOCK(sb) - 2);\n\t}\n\n\twhile (group < sbi->s_groups_count) {\n\t\tstruct buffer_head *bh;\n\t\text4_fsblk_t backup_block;\n\n\t\t/* Out of journal space, and can't get more - abort - so sad */\n\t\terr = ext4_resize_ensure_credits_batch(handle, 1);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tif (meta_bg == 0)\n\t\t\tbackup_block = ((ext4_fsblk_t)group) * bpg + blk_off;\n\t\telse\n\t\t\tbackup_block = (ext4_group_first_block_no(sb, group) +\n\t\t\t\t\text4_bg_has_super(sb, group));\n\n\t\tbh = sb_getblk(sb, backup_block);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\text4_debug(\"update metadata backup %llu(+%llu)\\n\",\n\t\t\t   backup_block, backup_block -\n\t\t\t   ext4_group_first_block_no(sb, group));\n\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\tif ((err = ext4_journal_get_write_access(handle, bh))) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data, data, size);\n\t\tif (rest)\n\t\t\tmemset(bh->b_data + size, 0, rest);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (unlikely(err))\n\t\t\text4_std_error(sb, err);\n\t\tbrelse(bh);\n\n\t\tif (meta_bg == 0)\n\t\t\tgroup = ext4_list_backups(sb, &three, &five, &seven);\n\t\telse if (group == last)\n\t\t\tbreak;\n\t\telse\n\t\t\tgroup = last;\n\t}\n\tif ((err2 = ext4_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\t/*\n\t * Ugh! Need to have e2fsck write the backup copies.  It is too\n\t * late to revert the resize, we shouldn't fail just because of\n\t * the backup copies (they are only needed in case of corruption).\n\t *\n\t * However, if we got here we have a journal problem too, so we\n\t * can't really start a transaction to mark the superblock.\n\t * Chicken out and just set the flag on the hope it will be written\n\t * to disk, and if not - we will simply wait until next fsck.\n\t */\nexit_err:\n\tif (err) {\n\t\text4_warning(sb, \"can't update backup for group %u (err %d), \"\n\t\t\t     \"forcing fsck on next reboot\", group, err);\n\t\tsbi->s_mount_state &= ~EXT4_VALID_FS;\n\t\tsbi->s_es->s_state &= cpu_to_le16(~EXT4_VALID_FS);\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t}\n}\n\n/*\n * ext4_add_new_descs() adds @count group descriptor of groups\n * starting at @group\n *\n * @handle: journal handle\n * @sb: super block\n * @group: the group no. of the first group desc to be added\n * @resize_inode: the resize inode\n * @count: number of group descriptors to be added\n */\nstatic int ext4_add_new_descs(handle_t *handle, struct super_block *sb,\n\t\t\t      ext4_group_t group, struct inode *resize_inode,\n\t\t\t      ext4_group_t count)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct buffer_head *gdb_bh;\n\tint i, gdb_off, gdb_num, err = 0;\n\tint meta_bg;\n\n\tmeta_bg = ext4_has_feature_meta_bg(sb);\n\tfor (i = 0; i < count; i++, group++) {\n\t\tint reserved_gdb = ext4_bg_has_super(sb, group) ?\n\t\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\n\t\tgdb_off = group % EXT4_DESC_PER_BLOCK(sb);\n\t\tgdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\n\t\t/*\n\t\t * We will only either add reserved group blocks to a backup group\n\t\t * or remove reserved blocks for the first group in a new group block.\n\t\t * Doing both would be mean more complex code, and sane people don't\n\t\t * use non-sparse filesystems anymore.  This is already checked above.\n\t\t */\n\t\tif (gdb_off) {\n\t\t\tgdb_bh = sbi_array_rcu_deref(sbi, s_group_desc,\n\t\t\t\t\t\t     gdb_num);\n\t\t\tBUFFER_TRACE(gdb_bh, \"get_write_access\");\n\t\t\terr = ext4_journal_get_write_access(handle, gdb_bh);\n\n\t\t\tif (!err && reserved_gdb && ext4_bg_num_gdb(sb, group))\n\t\t\t\terr = reserve_backup_gdb(handle, resize_inode, group);\n\t\t} else if (meta_bg != 0) {\n\t\t\terr = add_new_gdb_meta_bg(sb, handle, group);\n\t\t} else {\n\t\t\terr = add_new_gdb(handle, resize_inode, group);\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic struct buffer_head *ext4_get_bitmap(struct super_block *sb, __u64 block)\n{\n\tstruct buffer_head *bh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn NULL;\n\tif (!bh_uptodate_or_lock(bh)) {\n\t\tif (ext4_read_bh(bh, 0, NULL) < 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn bh;\n}\n\nstatic int ext4_set_bitmap_checksums(struct super_block *sb,\n\t\t\t\t     ext4_group_t group,\n\t\t\t\t     struct ext4_group_desc *gdp,\n\t\t\t\t     struct ext4_new_group_data *group_data)\n{\n\tstruct buffer_head *bh;\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 0;\n\n\tbh = ext4_get_bitmap(sb, group_data->inode_bitmap);\n\tif (!bh)\n\t\treturn -EIO;\n\text4_inode_bitmap_csum_set(sb, group, gdp, bh,\n\t\t\t\t   EXT4_INODES_PER_GROUP(sb) / 8);\n\tbrelse(bh);\n\n\tbh = ext4_get_bitmap(sb, group_data->block_bitmap);\n\tif (!bh)\n\t\treturn -EIO;\n\text4_block_bitmap_csum_set(sb, group, gdp, bh);\n\tbrelse(bh);\n\n\treturn 0;\n}\n\n/*\n * ext4_setup_new_descs() will set up the group descriptor descriptors of a flex bg\n */\nstatic int ext4_setup_new_descs(handle_t *handle, struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd)\n{\n\tstruct ext4_new_group_data\t*group_data = flex_gd->groups;\n\tstruct ext4_group_desc\t\t*gdp;\n\tstruct ext4_sb_info\t\t*sbi = EXT4_SB(sb);\n\tstruct buffer_head\t\t*gdb_bh;\n\text4_group_t\t\t\tgroup;\n\t__u16\t\t\t\t*bg_flags = flex_gd->bg_flags;\n\tint\t\t\t\ti, gdb_off, gdb_num, err = 0;\n\n\n\tfor (i = 0; i < flex_gd->count; i++, group_data++, bg_flags++) {\n\t\tgroup = group_data->group;\n\n\t\tgdb_off = group % EXT4_DESC_PER_BLOCK(sb);\n\t\tgdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\n\t\t/*\n\t\t * get_write_access() has been called on gdb_bh by ext4_add_new_desc().\n\t\t */\n\t\tgdb_bh = sbi_array_rcu_deref(sbi, s_group_desc, gdb_num);\n\t\t/* Update group descriptor block for new group */\n\t\tgdp = (struct ext4_group_desc *)(gdb_bh->b_data +\n\t\t\t\t\t\t gdb_off * EXT4_DESC_SIZE(sb));\n\n\t\tmemset(gdp, 0, EXT4_DESC_SIZE(sb));\n\t\text4_block_bitmap_set(sb, gdp, group_data->block_bitmap);\n\t\text4_inode_bitmap_set(sb, gdp, group_data->inode_bitmap);\n\t\terr = ext4_set_bitmap_checksums(sb, group, gdp, group_data);\n\t\tif (err) {\n\t\t\text4_std_error(sb, err);\n\t\t\tbreak;\n\t\t}\n\n\t\text4_inode_table_set(sb, gdp, group_data->inode_table);\n\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\t\t\t     group_data->free_clusters_count);\n\t\text4_free_inodes_set(sb, gdp, EXT4_INODES_PER_GROUP(sb));\n\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\text4_itable_unused_set(sb, gdp,\n\t\t\t\t\t       EXT4_INODES_PER_GROUP(sb));\n\t\tgdp->bg_flags = cpu_to_le16(*bg_flags);\n\t\text4_group_desc_csum_set(sb, group, gdp);\n\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, gdb_bh);\n\t\tif (unlikely(err)) {\n\t\t\text4_std_error(sb, err);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We can allocate memory for mb_alloc based on the new group\n\t\t * descriptor\n\t\t */\n\t\terr = ext4_mb_add_groupinfo(sb, group, gdp);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\n/*\n * ext4_update_super() updates the super block so that the newly added\n * groups can be seen by the filesystem.\n *\n * @sb: super block\n * @flex_gd: new added groups\n */\nstatic void ext4_update_super(struct super_block *sb,\n\t\t\t     struct ext4_new_flex_group_data *flex_gd)\n{\n\text4_fsblk_t blocks_count = 0;\n\text4_fsblk_t free_blocks = 0;\n\text4_fsblk_t reserved_blocks = 0;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint i;\n\n\tBUG_ON(flex_gd->count == 0 || group_data == NULL);\n\t/*\n\t * Make the new blocks and inodes valid next.  We do this before\n\t * increasing the group count so that once the group is enabled,\n\t * all of its blocks and inodes are already valid.\n\t *\n\t * We always allocate group-by-group, then block-by-block or\n\t * inode-by-inode within a group, so enabling these\n\t * blocks/inodes before the group is live won't actually let us\n\t * allocate the new space yet.\n\t */\n\tfor (i = 0; i < flex_gd->count; i++) {\n\t\tblocks_count += group_data[i].blocks_count;\n\t\tfree_blocks += EXT4_C2B(sbi, group_data[i].free_clusters_count);\n\t}\n\n\treserved_blocks = ext4_r_blocks_count(es) * 100;\n\treserved_blocks = div64_u64(reserved_blocks, ext4_blocks_count(es));\n\treserved_blocks *= blocks_count;\n\tdo_div(reserved_blocks, 100);\n\n\tlock_buffer(sbi->s_sbh);\n\text4_blocks_count_set(es, ext4_blocks_count(es) + blocks_count);\n\text4_free_blocks_count_set(es, ext4_free_blocks_count(es) + free_blocks);\n\tle32_add_cpu(&es->s_inodes_count, EXT4_INODES_PER_GROUP(sb) *\n\t\t     flex_gd->count);\n\tle32_add_cpu(&es->s_free_inodes_count, EXT4_INODES_PER_GROUP(sb) *\n\t\t     flex_gd->count);\n\n\text4_debug(\"free blocks count %llu\", ext4_free_blocks_count(es));\n\t/*\n\t * We need to protect s_groups_count against other CPUs seeing\n\t * inconsistent state in the superblock.\n\t *\n\t * The precise rules we use are:\n\t *\n\t * * Writers must perform a smp_wmb() after updating all\n\t *   dependent data and before modifying the groups count\n\t *\n\t * * Readers must perform an smp_rmb() after reading the groups\n\t *   count and before reading any dependent data.\n\t *\n\t * NB. These rules can be relaxed when checking the group count\n\t * while freeing data, as we can only allocate from a block\n\t * group after serialising against the group count, and we can\n\t * only then free after serialising in turn against that\n\t * allocation.\n\t */\n\tsmp_wmb();\n\n\t/* Update the global fs size fields */\n\tsbi->s_groups_count += flex_gd->count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\n\t/* Update the reserved block counts only once the new group is\n\t * active. */\n\text4_r_blocks_count_set(es, ext4_r_blocks_count(es) +\n\t\t\t\treserved_blocks);\n\text4_superblock_csum_set(sb);\n\tunlock_buffer(sbi->s_sbh);\n\n\t/* Update the free space counts */\n\tpercpu_counter_add(&sbi->s_freeclusters_counter,\n\t\t\t   EXT4_NUM_B2C(sbi, free_blocks));\n\tpercpu_counter_add(&sbi->s_freeinodes_counter,\n\t\t\t   EXT4_INODES_PER_GROUP(sb) * flex_gd->count);\n\n\text4_debug(\"free blocks count %llu\",\n\t\t   percpu_counter_read(&sbi->s_freeclusters_counter));\n\tif (ext4_has_feature_flex_bg(sb) && sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group;\n\t\tstruct flex_groups *fg;\n\n\t\tflex_group = ext4_flex_group(sbi, group_data[0].group);\n\t\tfg = sbi_array_rcu_deref(sbi, s_flex_groups, flex_group);\n\t\tatomic64_add(EXT4_NUM_B2C(sbi, free_blocks),\n\t\t\t     &fg->free_clusters);\n\t\tatomic_add(EXT4_INODES_PER_GROUP(sb) * flex_gd->count,\n\t\t\t   &fg->free_inodes);\n\t}\n\n\t/*\n\t * Update the fs overhead information\n\t */\n\text4_calculate_overhead(sb);\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT4-fs: added group %u:\"\n\t\t       \"%llu blocks(%llu free %llu reserved)\\n\", flex_gd->count,\n\t\t       blocks_count, free_blocks, reserved_blocks);\n}\n\n/* Add a flex group to an fs. Ensure we handle all possible error conditions\n * _before_ we start modifying the filesystem, because we cannot abort the\n * transaction and not have it write the data to disk.\n */\nstatic int ext4_flex_group_add(struct super_block *sb,\n\t\t\t       struct inode *resize_inode,\n\t\t\t       struct ext4_new_flex_group_data *flex_gd)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_fsblk_t o_blocks_count;\n\text4_grpblk_t last;\n\text4_group_t group;\n\thandle_t *handle;\n\tunsigned reserved_gdb;\n\tint err = 0, err2 = 0, credit;\n\n\tBUG_ON(!flex_gd->count || !flex_gd->groups || !flex_gd->bg_flags);\n\n\treserved_gdb = le16_to_cpu(es->s_reserved_gdt_blocks);\n\to_blocks_count = ext4_blocks_count(es);\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\tBUG_ON(last);\n\n\terr = setup_new_flex_group_blocks(sb, flex_gd);\n\tif (err)\n\t\tgoto exit;\n\t/*\n\t * We will always be modifying at least the superblock and  GDT\n\t * blocks.  If we are adding a group past the last current GDT block,\n\t * we will also modify the inode and the dindirect block.  If we\n\t * are adding a group with superblock/GDT backups  we will also\n\t * modify each of the reserved GDT dindirect blocks.\n\t */\n\tcredit = 3;\t/* sb, resize inode, resize inode dindirect */\n\t/* GDT blocks */\n\tcredit += 1 + DIV_ROUND_UP(flex_gd->count, EXT4_DESC_PER_BLOCK(sb));\n\tcredit += reserved_gdb;\t/* Reserved GDT dindirect blocks */\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, credit);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit;\n\t}\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto exit_journal;\n\n\tgroup = flex_gd->groups[0].group;\n\tBUG_ON(group != sbi->s_groups_count);\n\terr = ext4_add_new_descs(handle, sb, group,\n\t\t\t\tresize_inode, flex_gd->count);\n\tif (err)\n\t\tgoto exit_journal;\n\n\terr = ext4_setup_new_descs(handle, sb, flex_gd);\n\tif (err)\n\t\tgoto exit_journal;\n\n\text4_update_super(sb, flex_gd);\n\n\terr = ext4_handle_dirty_metadata(handle, NULL, sbi->s_sbh);\n\nexit_journal:\n\terr2 = ext4_journal_stop(handle);\n\tif (!err)\n\t\terr = err2;\n\n\tif (!err) {\n\t\tint gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\t\tint gdb_num_end = ((group + flex_gd->count - 1) /\n\t\t\t\t   EXT4_DESC_PER_BLOCK(sb));\n\t\tint meta_bg = ext4_has_feature_meta_bg(sb);\n\t\tsector_t old_gdb = 0;\n\n\t\tupdate_backups(sb, sbi->s_sbh->b_blocknr, (char *)es,\n\t\t\t       sizeof(struct ext4_super_block), 0);\n\t\tfor (; gdb_num <= gdb_num_end; gdb_num++) {\n\t\t\tstruct buffer_head *gdb_bh;\n\n\t\t\tgdb_bh = sbi_array_rcu_deref(sbi, s_group_desc,\n\t\t\t\t\t\t     gdb_num);\n\t\t\tif (old_gdb == gdb_bh->b_blocknr)\n\t\t\t\tcontinue;\n\t\t\tupdate_backups(sb, gdb_bh->b_blocknr, gdb_bh->b_data,\n\t\t\t\t       gdb_bh->b_size, meta_bg);\n\t\t\told_gdb = gdb_bh->b_blocknr;\n\t\t}\n\t}\nexit:\n\treturn err;\n}\n\nstatic int ext4_setup_next_flex_gd(struct super_block *sb,\n\t\t\t\t    struct ext4_new_flex_group_data *flex_gd,\n\t\t\t\t    ext4_fsblk_t n_blocks_count,\n\t\t\t\t    unsigned long flexbg_size)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\text4_fsblk_t o_blocks_count;\n\text4_group_t n_group;\n\text4_group_t group;\n\text4_group_t last_group;\n\text4_grpblk_t last;\n\text4_grpblk_t clusters_per_group;\n\tunsigned long i;\n\n\tclusters_per_group = EXT4_CLUSTERS_PER_GROUP(sb);\n\n\to_blocks_count = ext4_blocks_count(es);\n\n\tif (o_blocks_count == n_blocks_count)\n\t\treturn 0;\n\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\tBUG_ON(last);\n\text4_get_group_no_and_offset(sb, n_blocks_count - 1, &n_group, &last);\n\n\tlast_group = group | (flexbg_size - 1);\n\tif (last_group > n_group)\n\t\tlast_group = n_group;\n\n\tflex_gd->count = last_group - group + 1;\n\n\tfor (i = 0; i < flex_gd->count; i++) {\n\t\tint overhead;\n\n\t\tgroup_data[i].group = group + i;\n\t\tgroup_data[i].blocks_count = EXT4_BLOCKS_PER_GROUP(sb);\n\t\toverhead = ext4_group_overhead_blocks(sb, group + i);\n\t\tgroup_data[i].mdata_blocks = overhead;\n\t\tgroup_data[i].free_clusters_count = EXT4_CLUSTERS_PER_GROUP(sb);\n\t\tif (ext4_has_group_desc_csum(sb)) {\n\t\t\tflex_gd->bg_flags[i] = EXT4_BG_BLOCK_UNINIT |\n\t\t\t\t\t       EXT4_BG_INODE_UNINIT;\n\t\t\tif (!test_opt(sb, INIT_INODE_TABLE))\n\t\t\t\tflex_gd->bg_flags[i] |= EXT4_BG_INODE_ZEROED;\n\t\t} else\n\t\t\tflex_gd->bg_flags[i] = EXT4_BG_INODE_ZEROED;\n\t}\n\n\tif (last_group == n_group && ext4_has_group_desc_csum(sb))\n\t\t/* We need to initialize block bitmap of last group. */\n\t\tflex_gd->bg_flags[i - 1] &= ~EXT4_BG_BLOCK_UNINIT;\n\n\tif ((last_group == n_group) && (last != clusters_per_group - 1)) {\n\t\tgroup_data[i - 1].blocks_count = EXT4_C2B(sbi, last + 1);\n\t\tgroup_data[i - 1].free_clusters_count -= clusters_per_group -\n\t\t\t\t\t\t       last - 1;\n\t}\n\n\treturn 1;\n}\n\n/* Add group descriptor data to an existing or new group descriptor block.\n * Ensure we handle all possible error conditions _before_ we start modifying\n * the filesystem, because we cannot abort the transaction and not have it\n * write the data to disk.\n *\n * If we are on a GDT block boundary, we need to get the reserved GDT block.\n * Otherwise, we may need to add backup GDT blocks for a sparse group.\n *\n * We only need to hold the superblock lock while we are actually adding\n * in the new group's counts to the superblock.  Prior to that we have\n * not really \"added\" the group at all.  We re-check that we are still\n * adding in the last group in case things have changed since verifying.\n */\nint ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_new_flex_group_data flex_gd;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct inode *inode = NULL;\n\tint gdb_off;\n\tint err;\n\t__u16 bg_flags = 0;\n\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\n\tif (gdb_off == 0 && !ext4_has_feature_sparse_super(sb)) {\n\t\text4_warning(sb, \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!ext4_has_feature_resize_inode(sb) ||\n\t\t    !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO, EXT4_IGET_SPECIAL);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\n\n\terr = verify_group_input(sb, input);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_alloc_flex_bg_array(sb, input->group + 1);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_mb_alloc_groupinfo(sb, input->group + 1);\n\tif (err)\n\t\tgoto out;\n\n\tflex_gd.count = 1;\n\tflex_gd.groups = input;\n\tflex_gd.bg_flags = &bg_flags;\n\terr = ext4_flex_group_add(sb, inode, &flex_gd);\nout:\n\tiput(inode);\n\treturn err;\n} /* ext4_group_add */\n\n/*\n * extend a group without checking assuming that checking has been done.\n */\nstatic int ext4_group_extend_no_check(struct super_block *sb,\n\t\t\t\t      ext4_fsblk_t o_blocks_count, ext4_grpblk_t add)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\t/* We will update the superblock, one block bitmap, and\n\t * one group descriptor via ext4_group_add_blocks().\n\t */\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, 3);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\text4_warning(sb, \"error %d on journal start\", err);\n\t\treturn err;\n\t}\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);\n\tif (err) {\n\t\text4_warning(sb, \"error %d on journal write access\", err);\n\t\tgoto errout;\n\t}\n\n\tlock_buffer(EXT4_SB(sb)->s_sbh);\n\text4_blocks_count_set(es, o_blocks_count + add);\n\text4_free_blocks_count_set(es, ext4_free_blocks_count(es) + add);\n\text4_superblock_csum_set(sb);\n\tunlock_buffer(EXT4_SB(sb)->s_sbh);\n\text4_debug(\"freeing blocks %llu through %llu\\n\", o_blocks_count,\n\t\t   o_blocks_count + add);\n\t/* We add the blocks to the bitmap and set the group need init bit */\n\terr = ext4_group_add_blocks(handle, sb, o_blocks_count, add);\n\tif (err)\n\t\tgoto errout;\n\text4_handle_dirty_metadata(handle, NULL, EXT4_SB(sb)->s_sbh);\n\text4_debug(\"freed blocks %llu through %llu\\n\", o_blocks_count,\n\t\t   o_blocks_count + add);\nerrout:\n\terr2 = ext4_journal_stop(handle);\n\tif (err2 && !err)\n\t\terr = err2;\n\n\tif (!err) {\n\t\tif (test_opt(sb, DEBUG))\n\t\t\tprintk(KERN_DEBUG \"EXT4-fs: extended group to %llu \"\n\t\t\t       \"blocks\\n\", ext4_blocks_count(es));\n\t\tupdate_backups(sb, EXT4_SB(sb)->s_sbh->b_blocknr,\n\t\t\t       (char *)es, sizeof(struct ext4_super_block), 0);\n\t}\n\treturn err;\n}\n\n/*\n * Extend the filesystem to the new number of blocks specified.  This entry\n * point is only used to extend the current filesystem to the end of the last\n * existing group.  It can be accessed via ioctl, or by \"remount,resize=<size>\"\n * for emergencies (because it has no dependencies on reserved blocks).\n *\n * If we _really_ wanted, we could use default values to call ext4_group_add()\n * allow the \"remount\" trick to work for arbitrary resizing, assuming enough\n * GDT blocks are reserved to grow to the desired size.\n */\nint ext4_group_extend(struct super_block *sb, struct ext4_super_block *es,\n\t\t      ext4_fsblk_t n_blocks_count)\n{\n\text4_fsblk_t o_blocks_count;\n\text4_grpblk_t last;\n\text4_grpblk_t add;\n\tstruct buffer_head *bh;\n\tint err;\n\text4_group_t group;\n\n\to_blocks_count = ext4_blocks_count(es);\n\n\tif (test_opt(sb, DEBUG))\n\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t \"extending last group from %llu to %llu blocks\",\n\t\t\t o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count == 0 || n_blocks_count == o_blocks_count)\n\t\treturn 0;\n\n\tif (n_blocks_count > (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"filesystem too large to resize to %llu blocks safely\",\n\t\t\t n_blocks_count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\text4_warning(sb, \"can't shrink FS - resize aborted\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Handle the remaining blocks in the last group only. */\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\n\tif (last == 0) {\n\t\text4_warning(sb, \"need to use ext2online to resize further\");\n\t\treturn -EPERM;\n\t}\n\n\tadd = EXT4_BLOCKS_PER_GROUP(sb) - last;\n\n\tif (o_blocks_count + add < o_blocks_count) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (o_blocks_count + add > n_blocks_count)\n\t\tadd = n_blocks_count - o_blocks_count;\n\n\tif (o_blocks_count + add < n_blocks_count)\n\t\text4_warning(sb, \"will only finish group (%llu blocks, %u new)\",\n\t\t\t     o_blocks_count + add, add);\n\n\t/* See if the device is actually as big as what was requested */\n\tbh = ext4_sb_bread(sb, o_blocks_count + add - 1, 0);\n\tif (IS_ERR(bh)) {\n\t\text4_warning(sb, \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\n\terr = ext4_group_extend_no_check(sb, o_blocks_count, add);\n\treturn err;\n} /* ext4_group_extend */\n\n\nstatic int num_desc_blocks(struct super_block *sb, ext4_group_t groups)\n{\n\treturn (groups + EXT4_DESC_PER_BLOCK(sb) - 1) / EXT4_DESC_PER_BLOCK(sb);\n}\n\n/*\n * Release the resize inode and drop the resize_inode feature if there\n * are no more reserved gdt blocks, and then convert the file system\n * to enable meta_bg\n */\nstatic int ext4_convert_meta_bg(struct super_block *sb, struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\text4_fsblk_t nr;\n\tint i, ret, err = 0;\n\tint credits = 1;\n\n\text4_msg(sb, KERN_INFO, \"Converting file system to meta_bg\");\n\tif (inode) {\n\t\tif (es->s_reserved_gdt_blocks) {\n\t\t\text4_error(sb, \"Unexpected non-zero \"\n\t\t\t\t   \"s_reserved_gdt_blocks\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/* Do a quick sanity check of the resize inode */\n\t\tif (inode->i_blocks != 1 << (inode->i_blkbits -\n\t\t\t\t\t     (9 - sbi->s_cluster_bits)))\n\t\t\tgoto invalid_resize_inode;\n\t\tfor (i = 0; i < EXT4_N_BLOCKS; i++) {\n\t\t\tif (i == EXT4_DIND_BLOCK) {\n\t\t\t\tif (ei->i_data[i])\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tgoto invalid_resize_inode;\n\t\t\t}\n\t\t\tif (ei->i_data[i])\n\t\t\t\tgoto invalid_resize_inode;\n\t\t}\n\t\tcredits += 3;\t/* block bitmap, bg descriptor, resize inode */\n\t}\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, credits);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto errout;\n\n\tlock_buffer(sbi->s_sbh);\n\text4_clear_feature_resize_inode(sb);\n\text4_set_feature_meta_bg(sb);\n\tsbi->s_es->s_first_meta_bg =\n\t\tcpu_to_le32(num_desc_blocks(sb, sbi->s_groups_count));\n\text4_superblock_csum_set(sb);\n\tunlock_buffer(sbi->s_sbh);\n\n\terr = ext4_handle_dirty_metadata(handle, NULL, sbi->s_sbh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto errout;\n\t}\n\n\tif (inode) {\n\t\tnr = le32_to_cpu(ei->i_data[EXT4_DIND_BLOCK]);\n\t\text4_free_blocks(handle, inode, NULL, nr, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t\tei->i_data[EXT4_DIND_BLOCK] = 0;\n\t\tinode->i_blocks = 0;\n\n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t\tif (err)\n\t\t\text4_std_error(sb, err);\n\t}\n\nerrout:\n\tret = ext4_journal_stop(handle);\n\tif (!err)\n\t\terr = ret;\n\treturn ret;\n\ninvalid_resize_inode:\n\text4_error(sb, \"corrupted/inconsistent resize inode\");\n\treturn -EINVAL;\n}\n\n/*\n * ext4_resize_fs() resizes a fs to new size specified by @n_blocks_count\n *\n * @sb: super block of the fs to be resized\n * @n_blocks_count: the number of blocks resides in the resized fs\n */\nint ext4_resize_fs(struct super_block *sb, ext4_fsblk_t n_blocks_count)\n{\n\tstruct ext4_new_flex_group_data *flex_gd = NULL;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct buffer_head *bh;\n\tstruct inode *resize_inode = NULL;\n\text4_grpblk_t add, offset;\n\tunsigned long n_desc_blocks;\n\tunsigned long o_desc_blocks;\n\text4_group_t o_group;\n\text4_group_t n_group;\n\text4_fsblk_t o_blocks_count;\n\text4_fsblk_t n_blocks_count_retry = 0;\n\tunsigned long last_update_time = 0;\n\tint err = 0, flexbg_size = 1 << sbi->s_log_groups_per_flex;\n\tint meta_bg;\n\n\t/* See if the device is actually as big as what was requested */\n\tbh = ext4_sb_bread(sb, n_blocks_count - 1, 0);\n\tif (IS_ERR(bh)) {\n\t\text4_warning(sb, \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\nretry:\n\to_blocks_count = ext4_blocks_count(es);\n\n\text4_msg(sb, KERN_INFO, \"resizing filesystem from %llu \"\n\t\t \"to %llu blocks\", o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\t/* On-line shrinking not supported */\n\t\text4_warning(sb, \"can't shrink FS - resize aborted\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count == o_blocks_count)\n\t\t/* Nothing need to do */\n\t\treturn 0;\n\n\tn_group = ext4_get_group_number(sb, n_blocks_count - 1);\n\tif (n_group >= (0xFFFFFFFFUL / EXT4_INODES_PER_GROUP(sb))) {\n\t\text4_warning(sb, \"resize would cause inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\text4_get_group_no_and_offset(sb, o_blocks_count - 1, &o_group, &offset);\n\n\tn_desc_blocks = num_desc_blocks(sb, n_group + 1);\n\to_desc_blocks = num_desc_blocks(sb, sbi->s_groups_count);\n\n\tmeta_bg = ext4_has_feature_meta_bg(sb);\n\n\tif (ext4_has_feature_resize_inode(sb)) {\n\t\tif (meta_bg) {\n\t\t\text4_error(sb, \"resize_inode and meta_bg enabled \"\n\t\t\t\t   \"simultaneously\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (n_desc_blocks > o_desc_blocks +\n\t\t    le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\tn_blocks_count_retry = n_blocks_count;\n\t\t\tn_desc_blocks = o_desc_blocks +\n\t\t\t\tle16_to_cpu(es->s_reserved_gdt_blocks);\n\t\t\tn_group = n_desc_blocks * EXT4_DESC_PER_BLOCK(sb);\n\t\t\tn_blocks_count = (ext4_fsblk_t)n_group *\n\t\t\t\tEXT4_BLOCKS_PER_GROUP(sb) +\n\t\t\t\tle32_to_cpu(es->s_first_data_block);\n\t\t\tn_group--; /* set to last group number */\n\t\t}\n\n\t\tif (!resize_inode)\n\t\t\tresize_inode = ext4_iget(sb, EXT4_RESIZE_INO,\n\t\t\t\t\t\t EXT4_IGET_SPECIAL);\n\t\tif (IS_ERR(resize_inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(resize_inode);\n\t\t}\n\t}\n\n\tif ((!resize_inode && !meta_bg) || n_blocks_count == o_blocks_count) {\n\t\terr = ext4_convert_meta_bg(sb, resize_inode);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (resize_inode) {\n\t\t\tiput(resize_inode);\n\t\t\tresize_inode = NULL;\n\t\t}\n\t\tif (n_blocks_count_retry) {\n\t\t\tn_blocks_count = n_blocks_count_retry;\n\t\t\tn_blocks_count_retry = 0;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure the last group has enough space so that it's\n\t * guaranteed to have enough space for all metadata blocks\n\t * that it might need to hold.  (We might not need to store\n\t * the inode table blocks in the last block group, but there\n\t * will be cases where this might be needed.)\n\t */\n\tif ((ext4_group_first_block_no(sb, n_group) +\n\t     ext4_group_overhead_blocks(sb, n_group) + 2 +\n\t     sbi->s_itb_per_group + sbi->s_cluster_ratio) >= n_blocks_count) {\n\t\tn_blocks_count = ext4_group_first_block_no(sb, n_group);\n\t\tn_group--;\n\t\tn_blocks_count_retry = 0;\n\t\tif (resize_inode) {\n\t\t\tiput(resize_inode);\n\t\t\tresize_inode = NULL;\n\t\t}\n\t\tgoto retry;\n\t}\n\n\t/* extend the last group */\n\tif (n_group == o_group)\n\t\tadd = n_blocks_count - o_blocks_count;\n\telse\n\t\tadd = EXT4_C2B(sbi, EXT4_CLUSTERS_PER_GROUP(sb) - (offset + 1));\n\tif (add > 0) {\n\t\terr = ext4_group_extend_no_check(sb, o_blocks_count, add);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (ext4_blocks_count(es) == n_blocks_count)\n\t\tgoto out;\n\n\terr = ext4_alloc_flex_bg_array(sb, n_group + 1);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_mb_alloc_groupinfo(sb, n_group + 1);\n\tif (err)\n\t\tgoto out;\n\n\tflex_gd = alloc_flex_gd(flexbg_size);\n\tif (flex_gd == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Add flex groups. Note that a regular group is a\n\t * flex group with 1 group.\n\t */\n\twhile (ext4_setup_next_flex_gd(sb, flex_gd, n_blocks_count,\n\t\t\t\t\t      flexbg_size)) {\n\t\tif (jiffies - last_update_time > HZ * 10) {\n\t\t\tif (last_update_time)\n\t\t\t\text4_msg(sb, KERN_INFO,\n\t\t\t\t\t \"resized to %llu blocks\",\n\t\t\t\t\t ext4_blocks_count(es));\n\t\t\tlast_update_time = jiffies;\n\t\t}\n\t\tif (ext4_alloc_group_tables(sb, flex_gd, flexbg_size) != 0)\n\t\t\tbreak;\n\t\terr = ext4_flex_group_add(sb, resize_inode, flex_gd);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t}\n\n\tif (!err && n_blocks_count_retry) {\n\t\tn_blocks_count = n_blocks_count_retry;\n\t\tn_blocks_count_retry = 0;\n\t\tfree_flex_gd(flex_gd);\n\t\tflex_gd = NULL;\n\t\tif (resize_inode) {\n\t\t\tiput(resize_inode);\n\t\t\tresize_inode = NULL;\n\t\t}\n\t\tgoto retry;\n\t}\n\nout:\n\tif (flex_gd)\n\t\tfree_flex_gd(flex_gd);\n\tif (resize_inode != NULL)\n\t\tiput(resize_inode);\n\tif (err)\n\t\text4_warning(sb, \"error (%d) occurred during \"\n\t\t\t     \"file system resize\", err);\n\text4_msg(sb, KERN_INFO, \"resized filesystem to %llu\",\n\t\t ext4_blocks_count(es));\n\treturn err;\n}\n"}, "1": {"id": 1, "path": "/src/include/linux/byteorder/generic.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_BYTEORDER_GENERIC_H\n#define _LINUX_BYTEORDER_GENERIC_H\n\n/*\n * linux/byteorder/generic.h\n * Generic Byte-reordering support\n *\n * The \"... p\" macros, like le64_to_cpup, can be used with pointers\n * to unaligned data, but there will be a performance penalty on \n * some architectures.  Use get_unaligned for unaligned data.\n *\n * Francois-Rene Rideau <fare@tunes.org> 19970707\n *    gathered all the good ideas from all asm-foo/byteorder.h into one file,\n *    cleaned them up.\n *    I hope it is compliant with non-GCC compilers.\n *    I decided to put __BYTEORDER_HAS_U64__ in byteorder.h,\n *    because I wasn't sure it would be ok to put it in types.h\n *    Upgraded it to 2.1.43\n * Francois-Rene Rideau <fare@tunes.org> 19971012\n *    Upgraded it to 2.1.57\n *    to please Linus T., replaced huge #ifdef's between little/big endian\n *    by nestedly #include'd files.\n * Francois-Rene Rideau <fare@tunes.org> 19971205\n *    Made it to 2.1.71; now a facelift:\n *    Put files under include/linux/byteorder/\n *    Split swab from generic support.\n *\n * TODO:\n *   = Regular kernel maintainers could also replace all these manual\n *    byteswap macros that remain, disseminated among drivers,\n *    after some grep or the sources...\n *   = Linus might want to rename all these macros and files to fit his taste,\n *    to fit his personal naming scheme.\n *   = it seems that a few drivers would also appreciate\n *    nybble swapping support...\n *   = every architecture could add their byteswap macro in asm/byteorder.h\n *    see how some architectures already do (i386, alpha, ppc, etc)\n *   = cpu_to_beXX and beXX_to_cpu might some day need to be well\n *    distinguished throughout the kernel. This is not the case currently,\n *    since little endian, big endian, and pdp endian machines needn't it.\n *    But this might be the case for, say, a port of Linux to 20/21 bit\n *    architectures (and F21 Linux addict around?).\n */\n\n/*\n * The following macros are to be defined by <asm/byteorder.h>:\n *\n * Conversion of long and short int between network and host format\n *\tntohl(__u32 x)\n *\tntohs(__u16 x)\n *\thtonl(__u32 x)\n *\thtons(__u16 x)\n * It seems that some programs (which? where? or perhaps a standard? POSIX?)\n * might like the above to be functions, not macros (why?).\n * if that's true, then detect them, and take measures.\n * Anyway, the measure is: define only ___ntohl as a macro instead,\n * and in a separate file, have\n * unsigned long inline ntohl(x){return ___ntohl(x);}\n *\n * The same for constant arguments\n *\t__constant_ntohl(__u32 x)\n *\t__constant_ntohs(__u16 x)\n *\t__constant_htonl(__u32 x)\n *\t__constant_htons(__u16 x)\n *\n * Conversion of XX-bit integers (16- 32- or 64-)\n * between native CPU format and little/big endian format\n * 64-bit stuff only defined for proper architectures\n *\tcpu_to_[bl]eXX(__uXX x)\n *\t[bl]eXX_to_cpu(__uXX x)\n *\n * The same, but takes a pointer to the value to convert\n *\tcpu_to_[bl]eXXp(__uXX x)\n *\t[bl]eXX_to_cpup(__uXX x)\n *\n * The same, but change in situ\n *\tcpu_to_[bl]eXXs(__uXX x)\n *\t[bl]eXX_to_cpus(__uXX x)\n *\n * See asm-foo/byteorder.h for examples of how to provide\n * architecture-optimized versions\n *\n */\n\n#define cpu_to_le64 __cpu_to_le64\n#define le64_to_cpu __le64_to_cpu\n#define cpu_to_le32 __cpu_to_le32\n#define le32_to_cpu __le32_to_cpu\n#define cpu_to_le16 __cpu_to_le16\n#define le16_to_cpu __le16_to_cpu\n#define cpu_to_be64 __cpu_to_be64\n#define be64_to_cpu __be64_to_cpu\n#define cpu_to_be32 __cpu_to_be32\n#define be32_to_cpu __be32_to_cpu\n#define cpu_to_be16 __cpu_to_be16\n#define be16_to_cpu __be16_to_cpu\n#define cpu_to_le64p __cpu_to_le64p\n#define le64_to_cpup __le64_to_cpup\n#define cpu_to_le32p __cpu_to_le32p\n#define le32_to_cpup __le32_to_cpup\n#define cpu_to_le16p __cpu_to_le16p\n#define le16_to_cpup __le16_to_cpup\n#define cpu_to_be64p __cpu_to_be64p\n#define be64_to_cpup __be64_to_cpup\n#define cpu_to_be32p __cpu_to_be32p\n#define be32_to_cpup __be32_to_cpup\n#define cpu_to_be16p __cpu_to_be16p\n#define be16_to_cpup __be16_to_cpup\n#define cpu_to_le64s __cpu_to_le64s\n#define le64_to_cpus __le64_to_cpus\n#define cpu_to_le32s __cpu_to_le32s\n#define le32_to_cpus __le32_to_cpus\n#define cpu_to_le16s __cpu_to_le16s\n#define le16_to_cpus __le16_to_cpus\n#define cpu_to_be64s __cpu_to_be64s\n#define be64_to_cpus __be64_to_cpus\n#define cpu_to_be32s __cpu_to_be32s\n#define be32_to_cpus __be32_to_cpus\n#define cpu_to_be16s __cpu_to_be16s\n#define be16_to_cpus __be16_to_cpus\n\n/*\n * They have to be macros in order to do the constant folding\n * correctly - if the argument passed into a inline function\n * it is no longer constant according to gcc..\n */\n\n#undef ntohl\n#undef ntohs\n#undef htonl\n#undef htons\n\n#define ___htonl(x) __cpu_to_be32(x)\n#define ___htons(x) __cpu_to_be16(x)\n#define ___ntohl(x) __be32_to_cpu(x)\n#define ___ntohs(x) __be16_to_cpu(x)\n\n#define htonl(x) ___htonl(x)\n#define ntohl(x) ___ntohl(x)\n#define htons(x) ___htons(x)\n#define ntohs(x) ___ntohs(x)\n\nstatic inline void le16_add_cpu(__le16 *var, u16 val)\n{\n\t*var = cpu_to_le16(le16_to_cpu(*var) + val);\n}\n\nstatic inline void le32_add_cpu(__le32 *var, u32 val)\n{\n\t*var = cpu_to_le32(le32_to_cpu(*var) + val);\n}\n\nstatic inline void le64_add_cpu(__le64 *var, u64 val)\n{\n\t*var = cpu_to_le64(le64_to_cpu(*var) + val);\n}\n\n/* XXX: this stuff can be optimized */\nstatic inline void le32_to_cpu_array(u32 *buf, unsigned int words)\n{\n\twhile (words--) {\n\t\t__le32_to_cpus(buf);\n\t\tbuf++;\n\t}\n}\n\nstatic inline void cpu_to_le32_array(u32 *buf, unsigned int words)\n{\n\twhile (words--) {\n\t\t__cpu_to_le32s(buf);\n\t\tbuf++;\n\t}\n}\n\nstatic inline void be16_add_cpu(__be16 *var, u16 val)\n{\n\t*var = cpu_to_be16(be16_to_cpu(*var) + val);\n}\n\nstatic inline void be32_add_cpu(__be32 *var, u32 val)\n{\n\t*var = cpu_to_be32(be32_to_cpu(*var) + val);\n}\n\nstatic inline void be64_add_cpu(__be64 *var, u64 val)\n{\n\t*var = cpu_to_be64(be64_to_cpu(*var) + val);\n}\n\nstatic inline void cpu_to_be32_array(__be32 *dst, const u32 *src, size_t len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[i] = cpu_to_be32(src[i]);\n}\n\nstatic inline void be32_to_cpu_array(u32 *dst, const __be32 *src, size_t len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[i] = be32_to_cpu(src[i]);\n}\n\n#endif /* _LINUX_BYTEORDER_GENERIC_H */\n"}, "2": {"id": 2, "path": "/src/include/uapi/linux/byteorder/little_endian.h", "content": "/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef _UAPI_LINUX_BYTEORDER_LITTLE_ENDIAN_H\n#define _UAPI_LINUX_BYTEORDER_LITTLE_ENDIAN_H\n\n#ifndef __LITTLE_ENDIAN\n#define __LITTLE_ENDIAN 1234\n#endif\n#ifndef __LITTLE_ENDIAN_BITFIELD\n#define __LITTLE_ENDIAN_BITFIELD\n#endif\n\n#include <linux/types.h>\n#include <linux/swab.h>\n\n#define __constant_htonl(x) ((__force __be32)___constant_swab32((x)))\n#define __constant_ntohl(x) ___constant_swab32((__force __be32)(x))\n#define __constant_htons(x) ((__force __be16)___constant_swab16((x)))\n#define __constant_ntohs(x) ___constant_swab16((__force __be16)(x))\n#define __constant_cpu_to_le64(x) ((__force __le64)(__u64)(x))\n#define __constant_le64_to_cpu(x) ((__force __u64)(__le64)(x))\n#define __constant_cpu_to_le32(x) ((__force __le32)(__u32)(x))\n#define __constant_le32_to_cpu(x) ((__force __u32)(__le32)(x))\n#define __constant_cpu_to_le16(x) ((__force __le16)(__u16)(x))\n#define __constant_le16_to_cpu(x) ((__force __u16)(__le16)(x))\n#define __constant_cpu_to_be64(x) ((__force __be64)___constant_swab64((x)))\n#define __constant_be64_to_cpu(x) ___constant_swab64((__force __u64)(__be64)(x))\n#define __constant_cpu_to_be32(x) ((__force __be32)___constant_swab32((x)))\n#define __constant_be32_to_cpu(x) ___constant_swab32((__force __u32)(__be32)(x))\n#define __constant_cpu_to_be16(x) ((__force __be16)___constant_swab16((x)))\n#define __constant_be16_to_cpu(x) ___constant_swab16((__force __u16)(__be16)(x))\n#define __cpu_to_le64(x) ((__force __le64)(__u64)(x))\n#define __le64_to_cpu(x) ((__force __u64)(__le64)(x))\n#define __cpu_to_le32(x) ((__force __le32)(__u32)(x))\n#define __le32_to_cpu(x) ((__force __u32)(__le32)(x))\n#define __cpu_to_le16(x) ((__force __le16)(__u16)(x))\n#define __le16_to_cpu(x) ((__force __u16)(__le16)(x))\n#define __cpu_to_be64(x) ((__force __be64)__swab64((x)))\n#define __be64_to_cpu(x) __swab64((__force __u64)(__be64)(x))\n#define __cpu_to_be32(x) ((__force __be32)__swab32((x)))\n#define __be32_to_cpu(x) __swab32((__force __u32)(__be32)(x))\n#define __cpu_to_be16(x) ((__force __be16)__swab16((x)))\n#define __be16_to_cpu(x) __swab16((__force __u16)(__be16)(x))\n\nstatic __always_inline __le64 __cpu_to_le64p(const __u64 *p)\n{\n\treturn (__force __le64)*p;\n}\nstatic __always_inline __u64 __le64_to_cpup(const __le64 *p)\n{\n\treturn (__force __u64)*p;\n}\nstatic __always_inline __le32 __cpu_to_le32p(const __u32 *p)\n{\n\treturn (__force __le32)*p;\n}\nstatic __always_inline __u32 __le32_to_cpup(const __le32 *p)\n{\n\treturn (__force __u32)*p;\n}\nstatic __always_inline __le16 __cpu_to_le16p(const __u16 *p)\n{\n\treturn (__force __le16)*p;\n}\nstatic __always_inline __u16 __le16_to_cpup(const __le16 *p)\n{\n\treturn (__force __u16)*p;\n}\nstatic __always_inline __be64 __cpu_to_be64p(const __u64 *p)\n{\n\treturn (__force __be64)__swab64p(p);\n}\nstatic __always_inline __u64 __be64_to_cpup(const __be64 *p)\n{\n\treturn __swab64p((__u64 *)p);\n}\nstatic __always_inline __be32 __cpu_to_be32p(const __u32 *p)\n{\n\treturn (__force __be32)__swab32p(p);\n}\nstatic __always_inline __u32 __be32_to_cpup(const __be32 *p)\n{\n\treturn __swab32p((__u32 *)p);\n}\nstatic __always_inline __be16 __cpu_to_be16p(const __u16 *p)\n{\n\treturn (__force __be16)__swab16p(p);\n}\nstatic __always_inline __u16 __be16_to_cpup(const __be16 *p)\n{\n\treturn __swab16p((__u16 *)p);\n}\n#define __cpu_to_le64s(x) do { (void)(x); } while (0)\n#define __le64_to_cpus(x) do { (void)(x); } while (0)\n#define __cpu_to_le32s(x) do { (void)(x); } while (0)\n#define __le32_to_cpus(x) do { (void)(x); } while (0)\n#define __cpu_to_le16s(x) do { (void)(x); } while (0)\n#define __le16_to_cpus(x) do { (void)(x); } while (0)\n#define __cpu_to_be64s(x) __swab64s((x))\n#define __be64_to_cpus(x) __swab64s((x))\n#define __cpu_to_be32s(x) __swab32s((x))\n#define __be32_to_cpus(x) __swab32s((x))\n#define __cpu_to_be16s(x) __swab16s((x))\n#define __be16_to_cpus(x) __swab16s((x))\n\n\n#endif /* _UAPI_LINUX_BYTEORDER_LITTLE_ENDIAN_H */\n"}, "3": {"id": 3, "path": "/src/fs/ext4/ext4.h", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n *  ext4.h\n *\n * Copyright (C) 1992, 1993, 1994, 1995\n * Remy Card (card@masi.ibp.fr)\n * Laboratoire MASI - Institut Blaise Pascal\n * Universite Pierre et Marie Curie (Paris VI)\n *\n *  from\n *\n *  linux/include/linux/minix_fs.h\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n#ifndef _EXT4_H\n#define _EXT4_H\n\n#include <linux/types.h>\n#include <linux/blkdev.h>\n#include <linux/magic.h>\n#include <linux/jbd2.h>\n#include <linux/quota.h>\n#include <linux/rwsem.h>\n#include <linux/rbtree.h>\n#include <linux/seqlock.h>\n#include <linux/mutex.h>\n#include <linux/timer.h>\n#include <linux/wait.h>\n#include <linux/sched/signal.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <crypto/hash.h>\n#include <linux/falloc.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/fiemap.h>\n#ifdef __KERNEL__\n#include <linux/compat.h>\n#endif\n\n#include <linux/fscrypt.h>\n#include <linux/fsverity.h>\n\n#include <linux/compiler.h>\n\n/*\n * The fourth extended filesystem constants/structures\n */\n\n/*\n * with AGGRESSIVE_CHECK allocator runs consistency checks over\n * structures. these checks slow things down a lot\n */\n#define AGGRESSIVE_CHECK__\n\n/*\n * with DOUBLE_CHECK defined mballoc creates persistent in-core\n * bitmaps, maintains and uses them to check for double allocations\n */\n#define DOUBLE_CHECK__\n\n/*\n * Define EXT4FS_DEBUG to produce debug messages\n */\n#undef EXT4FS_DEBUG\n\n/*\n * Debug code\n */\n#ifdef EXT4FS_DEBUG\n#define ext4_debug(f, a...)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"EXT4-fs DEBUG (%s, %d): %s:\",\t\\\n\t\t\t__FILE__, __LINE__, __func__);\t\t\t\\\n\t\tprintk(KERN_DEBUG f, ## a);\t\t\t\t\\\n\t} while (0)\n#else\n#define ext4_debug(fmt, ...)\tno_printk(fmt, ##__VA_ARGS__)\n#endif\n\n /*\n  * Turn on EXT_DEBUG to enable ext4_ext_show_path/leaf/move in extents.c\n  */\n#define EXT_DEBUG__\n\n/*\n * Dynamic printk for controlled extents debugging.\n */\n#ifdef CONFIG_EXT4_DEBUG\n#define ext_debug(ino, fmt, ...)\t\t\t\t\t\\\n\tpr_debug(\"[%s/%d] EXT4-fs (%s): ino %lu: (%s, %d): %s:\" fmt,\t\\\n\t\t current->comm, task_pid_nr(current),\t\t\t\\\n\t\t ino->i_sb->s_id, ino->i_ino, __FILE__, __LINE__,\t\\\n\t\t __func__, ##__VA_ARGS__)\n#else\n#define ext_debug(ino, fmt, ...)\tno_printk(fmt, ##__VA_ARGS__)\n#endif\n\n#define ASSERT(assert)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely(!(assert))) {\t\t\t\t\t\\\n\t\tprintk(KERN_EMERG\t\t\t\t\t\\\n\t\t       \"Assertion failure in %s() at %s:%d: '%s'\\n\",\t\\\n\t\t       __func__, __FILE__, __LINE__, #assert);\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n/* data type for block offset of block group */\ntypedef int ext4_grpblk_t;\n\n/* data type for filesystem-wide blocks number */\ntypedef unsigned long long ext4_fsblk_t;\n\n/* data type for file logical block number */\ntypedef __u32 ext4_lblk_t;\n\n/* data type for block group number */\ntypedef unsigned int ext4_group_t;\n\nenum SHIFT_DIRECTION {\n\tSHIFT_LEFT = 0,\n\tSHIFT_RIGHT,\n};\n\n/*\n * Flags used in mballoc's allocation_context flags field.\n *\n * Also used to show what's going on for debugging purposes when the\n * flag field is exported via the traceport interface\n */\n\n/* prefer goal again. length */\n#define EXT4_MB_HINT_MERGE\t\t0x0001\n/* blocks already reserved */\n#define EXT4_MB_HINT_RESERVED\t\t0x0002\n/* metadata is being allocated */\n#define EXT4_MB_HINT_METADATA\t\t0x0004\n/* first blocks in the file */\n#define EXT4_MB_HINT_FIRST\t\t0x0008\n/* search for the best chunk */\n#define EXT4_MB_HINT_BEST\t\t0x0010\n/* data is being allocated */\n#define EXT4_MB_HINT_DATA\t\t0x0020\n/* don't preallocate (for tails) */\n#define EXT4_MB_HINT_NOPREALLOC\t\t0x0040\n/* allocate for locality group */\n#define EXT4_MB_HINT_GROUP_ALLOC\t0x0080\n/* allocate goal blocks or none */\n#define EXT4_MB_HINT_GOAL_ONLY\t\t0x0100\n/* goal is meaningful */\n#define EXT4_MB_HINT_TRY_GOAL\t\t0x0200\n/* blocks already pre-reserved by delayed allocation */\n#define EXT4_MB_DELALLOC_RESERVED\t0x0400\n/* We are doing stream allocation */\n#define EXT4_MB_STREAM_ALLOC\t\t0x0800\n/* Use reserved root blocks if needed */\n#define EXT4_MB_USE_ROOT_BLOCKS\t\t0x1000\n/* Use blocks from reserved pool */\n#define EXT4_MB_USE_RESERVED\t\t0x2000\n/* Do strict check for free blocks while retrying block allocation */\n#define EXT4_MB_STRICT_CHECK\t\t0x4000\n\nstruct ext4_allocation_request {\n\t/* target inode for block we're allocating */\n\tstruct inode *inode;\n\t/* how many blocks we want to allocate */\n\tunsigned int len;\n\t/* logical block in target inode */\n\text4_lblk_t logical;\n\t/* the closest logical allocated block to the left */\n\text4_lblk_t lleft;\n\t/* the closest logical allocated block to the right */\n\text4_lblk_t lright;\n\t/* phys. target (a hint) */\n\text4_fsblk_t goal;\n\t/* phys. block for the closest logical allocated block to the left */\n\text4_fsblk_t pleft;\n\t/* phys. block for the closest logical allocated block to the right */\n\text4_fsblk_t pright;\n\t/* flags. see above EXT4_MB_HINT_* */\n\tunsigned int flags;\n};\n\n/*\n * Logical to physical block mapping, used by ext4_map_blocks()\n *\n * This structure is used to pass requests into ext4_map_blocks() as\n * well as to store the information returned by ext4_map_blocks().  It\n * takes less room on the stack than a struct buffer_head.\n */\n#define EXT4_MAP_NEW\t\tBIT(BH_New)\n#define EXT4_MAP_MAPPED\t\tBIT(BH_Mapped)\n#define EXT4_MAP_UNWRITTEN\tBIT(BH_Unwritten)\n#define EXT4_MAP_BOUNDARY\tBIT(BH_Boundary)\n#define EXT4_MAP_FLAGS\t\t(EXT4_MAP_NEW | EXT4_MAP_MAPPED |\\\n\t\t\t\t EXT4_MAP_UNWRITTEN | EXT4_MAP_BOUNDARY)\n\nstruct ext4_map_blocks {\n\text4_fsblk_t m_pblk;\n\text4_lblk_t m_lblk;\n\tunsigned int m_len;\n\tunsigned int m_flags;\n};\n\n/*\n * Block validity checking, system zone rbtree.\n */\nstruct ext4_system_blocks {\n\tstruct rb_root root;\n\tstruct rcu_head rcu;\n};\n\n/*\n * Flags for ext4_io_end->flags\n */\n#define\tEXT4_IO_END_UNWRITTEN\t0x0001\n\nstruct ext4_io_end_vec {\n\tstruct list_head list;\t\t/* list of io_end_vec */\n\tloff_t offset;\t\t\t/* offset in the file */\n\tssize_t size;\t\t\t/* size of the extent */\n};\n\n/*\n * For converting unwritten extents on a work queue. 'handle' is used for\n * buffered writeback.\n */\ntypedef struct ext4_io_end {\n\tstruct list_head\tlist;\t\t/* per-file finished IO list */\n\thandle_t\t\t*handle;\t/* handle reserved for extent\n\t\t\t\t\t\t * conversion */\n\tstruct inode\t\t*inode;\t\t/* file being written to */\n\tstruct bio\t\t*bio;\t\t/* Linked list of completed\n\t\t\t\t\t\t * bios covering the extent */\n\tunsigned int\t\tflag;\t\t/* unwritten or not */\n\tatomic_t\t\tcount;\t\t/* reference counter */\n\tstruct list_head\tlist_vec;\t/* list of ext4_io_end_vec */\n} ext4_io_end_t;\n\nstruct ext4_io_submit {\n\tstruct writeback_control *io_wbc;\n\tstruct bio\t\t*io_bio;\n\text4_io_end_t\t\t*io_end;\n\tsector_t\t\tio_next_block;\n};\n\n/*\n * Special inodes numbers\n */\n#define\tEXT4_BAD_INO\t\t 1\t/* Bad blocks inode */\n#define EXT4_ROOT_INO\t\t 2\t/* Root inode */\n#define EXT4_USR_QUOTA_INO\t 3\t/* User quota inode */\n#define EXT4_GRP_QUOTA_INO\t 4\t/* Group quota inode */\n#define EXT4_BOOT_LOADER_INO\t 5\t/* Boot loader inode */\n#define EXT4_UNDEL_DIR_INO\t 6\t/* Undelete directory inode */\n#define EXT4_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */\n#define EXT4_JOURNAL_INO\t 8\t/* Journal inode */\n\n/* First non-reserved inode for old ext4 filesystems */\n#define EXT4_GOOD_OLD_FIRST_INO\t11\n\n/*\n * Maximal count of links to a file\n */\n#define EXT4_LINK_MAX\t\t65000\n\n/*\n * Macro-instructions used to manage several block sizes\n */\n#define EXT4_MIN_BLOCK_SIZE\t\t1024\n#define\tEXT4_MAX_BLOCK_SIZE\t\t65536\n#define EXT4_MIN_BLOCK_LOG_SIZE\t\t10\n#define EXT4_MAX_BLOCK_LOG_SIZE\t\t16\n#define EXT4_MAX_CLUSTER_LOG_SIZE\t30\n#ifdef __KERNEL__\n# define EXT4_BLOCK_SIZE(s)\t\t((s)->s_blocksize)\n#else\n# define EXT4_BLOCK_SIZE(s)\t\t(EXT4_MIN_BLOCK_SIZE << (s)->s_log_block_size)\n#endif\n#define\tEXT4_ADDR_PER_BLOCK(s)\t\t(EXT4_BLOCK_SIZE(s) / sizeof(__u32))\n#define EXT4_CLUSTER_SIZE(s)\t\t(EXT4_BLOCK_SIZE(s) << \\\n\t\t\t\t\t EXT4_SB(s)->s_cluster_bits)\n#ifdef __KERNEL__\n# define EXT4_BLOCK_SIZE_BITS(s)\t((s)->s_blocksize_bits)\n# define EXT4_CLUSTER_BITS(s)\t\t(EXT4_SB(s)->s_cluster_bits)\n#else\n# define EXT4_BLOCK_SIZE_BITS(s)\t((s)->s_log_block_size + 10)\n#endif\n#ifdef __KERNEL__\n#define\tEXT4_ADDR_PER_BLOCK_BITS(s)\t(EXT4_SB(s)->s_addr_per_block_bits)\n#define EXT4_INODE_SIZE(s)\t\t(EXT4_SB(s)->s_inode_size)\n#define EXT4_FIRST_INO(s)\t\t(EXT4_SB(s)->s_first_ino)\n#else\n#define EXT4_INODE_SIZE(s)\t(((s)->s_rev_level == EXT4_GOOD_OLD_REV) ? \\\n\t\t\t\t EXT4_GOOD_OLD_INODE_SIZE : \\\n\t\t\t\t (s)->s_inode_size)\n#define EXT4_FIRST_INO(s)\t(((s)->s_rev_level == EXT4_GOOD_OLD_REV) ? \\\n\t\t\t\t EXT4_GOOD_OLD_FIRST_INO : \\\n\t\t\t\t (s)->s_first_ino)\n#endif\n#define EXT4_BLOCK_ALIGN(size, blkbits)\t\tALIGN((size), (1 << (blkbits)))\n#define EXT4_MAX_BLOCKS(size, offset, blkbits) \\\n\t((EXT4_BLOCK_ALIGN(size + offset, blkbits) >> blkbits) - (offset >> \\\n\t\t\t\t\t\t\t\t  blkbits))\n\n/* Translate a block number to a cluster number */\n#define EXT4_B2C(sbi, blk)\t((blk) >> (sbi)->s_cluster_bits)\n/* Translate a cluster number to a block number */\n#define EXT4_C2B(sbi, cluster)\t((cluster) << (sbi)->s_cluster_bits)\n/* Translate # of blks to # of clusters */\n#define EXT4_NUM_B2C(sbi, blks)\t(((blks) + (sbi)->s_cluster_ratio - 1) >> \\\n\t\t\t\t (sbi)->s_cluster_bits)\n/* Mask out the low bits to get the starting block of the cluster */\n#define EXT4_PBLK_CMASK(s, pblk) ((pblk) &\t\t\t\t\\\n\t\t\t\t  ~((ext4_fsblk_t) (s)->s_cluster_ratio - 1))\n#define EXT4_LBLK_CMASK(s, lblk) ((lblk) &\t\t\t\t\\\n\t\t\t\t  ~((ext4_lblk_t) (s)->s_cluster_ratio - 1))\n/* Fill in the low bits to get the last block of the cluster */\n#define EXT4_LBLK_CFILL(sbi, lblk) ((lblk) |\t\t\t\t\\\n\t\t\t\t    ((ext4_lblk_t) (sbi)->s_cluster_ratio - 1))\n/* Get the cluster offset */\n#define EXT4_PBLK_COFF(s, pblk) ((pblk) &\t\t\t\t\\\n\t\t\t\t ((ext4_fsblk_t) (s)->s_cluster_ratio - 1))\n#define EXT4_LBLK_COFF(s, lblk) ((lblk) &\t\t\t\t\\\n\t\t\t\t ((ext4_lblk_t) (s)->s_cluster_ratio - 1))\n\n/*\n * Structure of a blocks group descriptor\n */\nstruct ext4_group_desc\n{\n\t__le32\tbg_block_bitmap_lo;\t/* Blocks bitmap block */\n\t__le32\tbg_inode_bitmap_lo;\t/* Inodes bitmap block */\n\t__le32\tbg_inode_table_lo;\t/* Inodes table block */\n\t__le16\tbg_free_blocks_count_lo;/* Free blocks count */\n\t__le16\tbg_free_inodes_count_lo;/* Free inodes count */\n\t__le16\tbg_used_dirs_count_lo;\t/* Directories count */\n\t__le16\tbg_flags;\t\t/* EXT4_BG_flags (INODE_UNINIT, etc) */\n\t__le32  bg_exclude_bitmap_lo;   /* Exclude bitmap for snapshots */\n\t__le16  bg_block_bitmap_csum_lo;/* crc32c(s_uuid+grp_num+bbitmap) LE */\n\t__le16  bg_inode_bitmap_csum_lo;/* crc32c(s_uuid+grp_num+ibitmap) LE */\n\t__le16  bg_itable_unused_lo;\t/* Unused inodes count */\n\t__le16  bg_checksum;\t\t/* crc16(sb_uuid+group+desc) */\n\t__le32\tbg_block_bitmap_hi;\t/* Blocks bitmap block MSB */\n\t__le32\tbg_inode_bitmap_hi;\t/* Inodes bitmap block MSB */\n\t__le32\tbg_inode_table_hi;\t/* Inodes table block MSB */\n\t__le16\tbg_free_blocks_count_hi;/* Free blocks count MSB */\n\t__le16\tbg_free_inodes_count_hi;/* Free inodes count MSB */\n\t__le16\tbg_used_dirs_count_hi;\t/* Directories count MSB */\n\t__le16  bg_itable_unused_hi;    /* Unused inodes count MSB */\n\t__le32  bg_exclude_bitmap_hi;   /* Exclude bitmap block MSB */\n\t__le16  bg_block_bitmap_csum_hi;/* crc32c(s_uuid+grp_num+bbitmap) BE */\n\t__le16  bg_inode_bitmap_csum_hi;/* crc32c(s_uuid+grp_num+ibitmap) BE */\n\t__u32   bg_reserved;\n};\n\n#define EXT4_BG_INODE_BITMAP_CSUM_HI_END\t\\\n\t(offsetof(struct ext4_group_desc, bg_inode_bitmap_csum_hi) + \\\n\t sizeof(__le16))\n#define EXT4_BG_BLOCK_BITMAP_CSUM_HI_END\t\\\n\t(offsetof(struct ext4_group_desc, bg_block_bitmap_csum_hi) + \\\n\t sizeof(__le16))\n\n/*\n * Structure of a flex block group info\n */\n\nstruct flex_groups {\n\tatomic64_t\tfree_clusters;\n\tatomic_t\tfree_inodes;\n\tatomic_t\tused_dirs;\n};\n\n#define EXT4_BG_INODE_UNINIT\t0x0001 /* Inode table/bitmap not in use */\n#define EXT4_BG_BLOCK_UNINIT\t0x0002 /* Block bitmap not in use */\n#define EXT4_BG_INODE_ZEROED\t0x0004 /* On-disk itable initialized to zero */\n\n/*\n * Macro-instructions used to manage group descriptors\n */\n#define EXT4_MIN_DESC_SIZE\t\t32\n#define EXT4_MIN_DESC_SIZE_64BIT\t64\n#define\tEXT4_MAX_DESC_SIZE\t\tEXT4_MIN_BLOCK_SIZE\n#define EXT4_DESC_SIZE(s)\t\t(EXT4_SB(s)->s_desc_size)\n#ifdef __KERNEL__\n# define EXT4_BLOCKS_PER_GROUP(s)\t(EXT4_SB(s)->s_blocks_per_group)\n# define EXT4_CLUSTERS_PER_GROUP(s)\t(EXT4_SB(s)->s_clusters_per_group)\n# define EXT4_DESC_PER_BLOCK(s)\t\t(EXT4_SB(s)->s_desc_per_block)\n# define EXT4_INODES_PER_GROUP(s)\t(EXT4_SB(s)->s_inodes_per_group)\n# define EXT4_DESC_PER_BLOCK_BITS(s)\t(EXT4_SB(s)->s_desc_per_block_bits)\n#else\n# define EXT4_BLOCKS_PER_GROUP(s)\t((s)->s_blocks_per_group)\n# define EXT4_DESC_PER_BLOCK(s)\t\t(EXT4_BLOCK_SIZE(s) / EXT4_DESC_SIZE(s))\n# define EXT4_INODES_PER_GROUP(s)\t((s)->s_inodes_per_group)\n#endif\n\n/*\n * Constants relative to the data blocks\n */\n#define\tEXT4_NDIR_BLOCKS\t\t12\n#define\tEXT4_IND_BLOCK\t\t\tEXT4_NDIR_BLOCKS\n#define\tEXT4_DIND_BLOCK\t\t\t(EXT4_IND_BLOCK + 1)\n#define\tEXT4_TIND_BLOCK\t\t\t(EXT4_DIND_BLOCK + 1)\n#define\tEXT4_N_BLOCKS\t\t\t(EXT4_TIND_BLOCK + 1)\n\n/*\n * Inode flags\n */\n#define\tEXT4_SECRM_FL\t\t\t0x00000001 /* Secure deletion */\n#define\tEXT4_UNRM_FL\t\t\t0x00000002 /* Undelete */\n#define\tEXT4_COMPR_FL\t\t\t0x00000004 /* Compress file */\n#define EXT4_SYNC_FL\t\t\t0x00000008 /* Synchronous updates */\n#define EXT4_IMMUTABLE_FL\t\t0x00000010 /* Immutable file */\n#define EXT4_APPEND_FL\t\t\t0x00000020 /* writes to file may only append */\n#define EXT4_NODUMP_FL\t\t\t0x00000040 /* do not dump file */\n#define EXT4_NOATIME_FL\t\t\t0x00000080 /* do not update atime */\n/* Reserved for compression usage... */\n#define EXT4_DIRTY_FL\t\t\t0x00000100\n#define EXT4_COMPRBLK_FL\t\t0x00000200 /* One or more compressed clusters */\n#define EXT4_NOCOMPR_FL\t\t\t0x00000400 /* Don't compress */\n\t/* nb: was previously EXT2_ECOMPR_FL */\n#define EXT4_ENCRYPT_FL\t\t\t0x00000800 /* encrypted file */\n/* End compression flags --- maybe not all used */\n#define EXT4_INDEX_FL\t\t\t0x00001000 /* hash-indexed directory */\n#define EXT4_IMAGIC_FL\t\t\t0x00002000 /* AFS directory */\n#define EXT4_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n#define EXT4_NOTAIL_FL\t\t\t0x00008000 /* file tail should not be merged */\n#define EXT4_DIRSYNC_FL\t\t\t0x00010000 /* dirsync behaviour (directories only) */\n#define EXT4_TOPDIR_FL\t\t\t0x00020000 /* Top of directory hierarchies*/\n#define EXT4_HUGE_FILE_FL               0x00040000 /* Set to each huge file */\n#define EXT4_EXTENTS_FL\t\t\t0x00080000 /* Inode uses extents */\n#define EXT4_VERITY_FL\t\t\t0x00100000 /* Verity protected inode */\n#define EXT4_EA_INODE_FL\t        0x00200000 /* Inode used for large EA */\n/* 0x00400000 was formerly EXT4_EOFBLOCKS_FL */\n\n#define EXT4_DAX_FL\t\t\t0x02000000 /* Inode is DAX */\n\n#define EXT4_INLINE_DATA_FL\t\t0x10000000 /* Inode has inline data. */\n#define EXT4_PROJINHERIT_FL\t\t0x20000000 /* Create with parents projid */\n#define EXT4_CASEFOLD_FL\t\t0x40000000 /* Casefolded directory */\n#define EXT4_RESERVED_FL\t\t0x80000000 /* reserved for ext4 lib */\n\n/* User modifiable flags */\n#define EXT4_FL_USER_MODIFIABLE\t\t(EXT4_SECRM_FL | \\\n\t\t\t\t\t EXT4_UNRM_FL | \\\n\t\t\t\t\t EXT4_COMPR_FL | \\\n\t\t\t\t\t EXT4_SYNC_FL | \\\n\t\t\t\t\t EXT4_IMMUTABLE_FL | \\\n\t\t\t\t\t EXT4_APPEND_FL | \\\n\t\t\t\t\t EXT4_NODUMP_FL | \\\n\t\t\t\t\t EXT4_NOATIME_FL | \\\n\t\t\t\t\t EXT4_JOURNAL_DATA_FL | \\\n\t\t\t\t\t EXT4_NOTAIL_FL | \\\n\t\t\t\t\t EXT4_DIRSYNC_FL | \\\n\t\t\t\t\t EXT4_TOPDIR_FL | \\\n\t\t\t\t\t EXT4_EXTENTS_FL | \\\n\t\t\t\t\t 0x00400000 /* EXT4_EOFBLOCKS_FL */ | \\\n\t\t\t\t\t EXT4_DAX_FL | \\\n\t\t\t\t\t EXT4_PROJINHERIT_FL | \\\n\t\t\t\t\t EXT4_CASEFOLD_FL)\n\n/* User visible flags */\n#define EXT4_FL_USER_VISIBLE\t\t(EXT4_FL_USER_MODIFIABLE | \\\n\t\t\t\t\t EXT4_DIRTY_FL | \\\n\t\t\t\t\t EXT4_COMPRBLK_FL | \\\n\t\t\t\t\t EXT4_NOCOMPR_FL | \\\n\t\t\t\t\t EXT4_ENCRYPT_FL | \\\n\t\t\t\t\t EXT4_INDEX_FL | \\\n\t\t\t\t\t EXT4_VERITY_FL | \\\n\t\t\t\t\t EXT4_INLINE_DATA_FL)\n\n/* Flags we can manipulate with through FS_IOC_FSSETXATTR */\n#define EXT4_FL_XFLAG_VISIBLE\t\t(EXT4_SYNC_FL | \\\n\t\t\t\t\t EXT4_IMMUTABLE_FL | \\\n\t\t\t\t\t EXT4_APPEND_FL | \\\n\t\t\t\t\t EXT4_NODUMP_FL | \\\n\t\t\t\t\t EXT4_NOATIME_FL | \\\n\t\t\t\t\t EXT4_PROJINHERIT_FL | \\\n\t\t\t\t\t EXT4_DAX_FL)\n\n/* Flags that should be inherited by new inodes from their parent. */\n#define EXT4_FL_INHERITED (EXT4_SECRM_FL | EXT4_UNRM_FL | EXT4_COMPR_FL |\\\n\t\t\t   EXT4_SYNC_FL | EXT4_NODUMP_FL | EXT4_NOATIME_FL |\\\n\t\t\t   EXT4_NOCOMPR_FL | EXT4_JOURNAL_DATA_FL |\\\n\t\t\t   EXT4_NOTAIL_FL | EXT4_DIRSYNC_FL |\\\n\t\t\t   EXT4_PROJINHERIT_FL | EXT4_CASEFOLD_FL |\\\n\t\t\t   EXT4_DAX_FL)\n\n/* Flags that are appropriate for regular files (all but dir-specific ones). */\n#define EXT4_REG_FLMASK (~(EXT4_DIRSYNC_FL | EXT4_TOPDIR_FL | EXT4_CASEFOLD_FL |\\\n\t\t\t   EXT4_PROJINHERIT_FL))\n\n/* Flags that are appropriate for non-directories/regular files. */\n#define EXT4_OTHER_FLMASK (EXT4_NODUMP_FL | EXT4_NOATIME_FL)\n\n/* The only flags that should be swapped */\n#define EXT4_FL_SHOULD_SWAP (EXT4_HUGE_FILE_FL | EXT4_EXTENTS_FL)\n\n/* Flags which are mutually exclusive to DAX */\n#define EXT4_DAX_MUT_EXCL (EXT4_VERITY_FL | EXT4_ENCRYPT_FL |\\\n\t\t\t   EXT4_JOURNAL_DATA_FL | EXT4_INLINE_DATA_FL)\n\n/* Mask out flags that are inappropriate for the given type of inode. */\nstatic inline __u32 ext4_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT4_REG_FLMASK;\n\telse\n\t\treturn flags & EXT4_OTHER_FLMASK;\n}\n\n/*\n * Inode flags used for atomic set/get\n */\nenum {\n\tEXT4_INODE_SECRM\t= 0,\t/* Secure deletion */\n\tEXT4_INODE_UNRM\t\t= 1,\t/* Undelete */\n\tEXT4_INODE_COMPR\t= 2,\t/* Compress file */\n\tEXT4_INODE_SYNC\t\t= 3,\t/* Synchronous updates */\n\tEXT4_INODE_IMMUTABLE\t= 4,\t/* Immutable file */\n\tEXT4_INODE_APPEND\t= 5,\t/* writes to file may only append */\n\tEXT4_INODE_NODUMP\t= 6,\t/* do not dump file */\n\tEXT4_INODE_NOATIME\t= 7,\t/* do not update atime */\n/* Reserved for compression usage... */\n\tEXT4_INODE_DIRTY\t= 8,\n\tEXT4_INODE_COMPRBLK\t= 9,\t/* One or more compressed clusters */\n\tEXT4_INODE_NOCOMPR\t= 10,\t/* Don't compress */\n\tEXT4_INODE_ENCRYPT\t= 11,\t/* Encrypted file */\n/* End compression flags --- maybe not all used */\n\tEXT4_INODE_INDEX\t= 12,\t/* hash-indexed directory */\n\tEXT4_INODE_IMAGIC\t= 13,\t/* AFS directory */\n\tEXT4_INODE_JOURNAL_DATA\t= 14,\t/* file data should be journaled */\n\tEXT4_INODE_NOTAIL\t= 15,\t/* file tail should not be merged */\n\tEXT4_INODE_DIRSYNC\t= 16,\t/* dirsync behaviour (directories only) */\n\tEXT4_INODE_TOPDIR\t= 17,\t/* Top of directory hierarchies*/\n\tEXT4_INODE_HUGE_FILE\t= 18,\t/* Set to each huge file */\n\tEXT4_INODE_EXTENTS\t= 19,\t/* Inode uses extents */\n\tEXT4_INODE_VERITY\t= 20,\t/* Verity protected inode */\n\tEXT4_INODE_EA_INODE\t= 21,\t/* Inode used for large EA */\n/* 22 was formerly EXT4_INODE_EOFBLOCKS */\n\tEXT4_INODE_DAX\t\t= 25,\t/* Inode is DAX */\n\tEXT4_INODE_INLINE_DATA\t= 28,\t/* Data in inode. */\n\tEXT4_INODE_PROJINHERIT\t= 29,\t/* Create with parents projid */\n\tEXT4_INODE_CASEFOLD\t= 30,\t/* Casefolded directory */\n\tEXT4_INODE_RESERVED\t= 31,\t/* reserved for ext4 lib */\n};\n\n/*\n * Since it's pretty easy to mix up bit numbers and hex values, we use a\n * build-time check to make sure that EXT4_XXX_FL is consistent with respect to\n * EXT4_INODE_XXX. If all is well, the macros will be dropped, so, it won't cost\n * any extra space in the compiled kernel image, otherwise, the build will fail.\n * It's important that these values are the same, since we are using\n * EXT4_INODE_XXX to test for flag values, but EXT4_XXX_FL must be consistent\n * with the values of FS_XXX_FL defined in include/linux/fs.h and the on-disk\n * values found in ext2, ext3 and ext4 filesystems, and of course the values\n * defined in e2fsprogs.\n *\n * It's not paranoia if the Murphy's Law really *is* out to get you.  :-)\n */\n#define TEST_FLAG_VALUE(FLAG) (EXT4_##FLAG##_FL == (1 << EXT4_INODE_##FLAG))\n#define CHECK_FLAG_VALUE(FLAG) BUILD_BUG_ON(!TEST_FLAG_VALUE(FLAG))\n\nstatic inline void ext4_check_flag_values(void)\n{\n\tCHECK_FLAG_VALUE(SECRM);\n\tCHECK_FLAG_VALUE(UNRM);\n\tCHECK_FLAG_VALUE(COMPR);\n\tCHECK_FLAG_VALUE(SYNC);\n\tCHECK_FLAG_VALUE(IMMUTABLE);\n\tCHECK_FLAG_VALUE(APPEND);\n\tCHECK_FLAG_VALUE(NODUMP);\n\tCHECK_FLAG_VALUE(NOATIME);\n\tCHECK_FLAG_VALUE(DIRTY);\n\tCHECK_FLAG_VALUE(COMPRBLK);\n\tCHECK_FLAG_VALUE(NOCOMPR);\n\tCHECK_FLAG_VALUE(ENCRYPT);\n\tCHECK_FLAG_VALUE(INDEX);\n\tCHECK_FLAG_VALUE(IMAGIC);\n\tCHECK_FLAG_VALUE(JOURNAL_DATA);\n\tCHECK_FLAG_VALUE(NOTAIL);\n\tCHECK_FLAG_VALUE(DIRSYNC);\n\tCHECK_FLAG_VALUE(TOPDIR);\n\tCHECK_FLAG_VALUE(HUGE_FILE);\n\tCHECK_FLAG_VALUE(EXTENTS);\n\tCHECK_FLAG_VALUE(VERITY);\n\tCHECK_FLAG_VALUE(EA_INODE);\n\tCHECK_FLAG_VALUE(INLINE_DATA);\n\tCHECK_FLAG_VALUE(PROJINHERIT);\n\tCHECK_FLAG_VALUE(CASEFOLD);\n\tCHECK_FLAG_VALUE(RESERVED);\n}\n\n/* Used to pass group descriptor data when online resize is done */\nstruct ext4_new_group_input {\n\t__u32 group;\t\t/* Group number for this data */\n\t__u64 block_bitmap;\t/* Absolute block number of block bitmap */\n\t__u64 inode_bitmap;\t/* Absolute block number of inode bitmap */\n\t__u64 inode_table;\t/* Absolute block number of inode table start */\n\t__u32 blocks_count;\t/* Total number of blocks in this group */\n\t__u16 reserved_blocks;\t/* Number of reserved blocks in this group */\n\t__u16 unused;\n};\n\n#if defined(__KERNEL__) && defined(CONFIG_COMPAT)\nstruct compat_ext4_new_group_input {\n\tu32 group;\n\tcompat_u64 block_bitmap;\n\tcompat_u64 inode_bitmap;\n\tcompat_u64 inode_table;\n\tu32 blocks_count;\n\tu16 reserved_blocks;\n\tu16 unused;\n};\n#endif\n\n/* The struct ext4_new_group_input in kernel space, with free_blocks_count */\nstruct ext4_new_group_data {\n\t__u32 group;\n\t__u64 block_bitmap;\n\t__u64 inode_bitmap;\n\t__u64 inode_table;\n\t__u32 blocks_count;\n\t__u16 reserved_blocks;\n\t__u16 mdata_blocks;\n\t__u32 free_clusters_count;\n};\n\n/* Indexes used to index group tables in ext4_new_group_data */\nenum {\n\tBLOCK_BITMAP = 0,\t/* block bitmap */\n\tINODE_BITMAP,\t\t/* inode bitmap */\n\tINODE_TABLE,\t\t/* inode tables */\n\tGROUP_TABLE_COUNT,\n};\n\n/*\n * Flags used by ext4_map_blocks()\n */\n\t/* Allocate any needed blocks and/or convert an unwritten\n\t   extent to be an initialized ext4 */\n#define EXT4_GET_BLOCKS_CREATE\t\t\t0x0001\n\t/* Request the creation of an unwritten extent */\n#define EXT4_GET_BLOCKS_UNWRIT_EXT\t\t0x0002\n#define EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT\t(EXT4_GET_BLOCKS_UNWRIT_EXT|\\\n\t\t\t\t\t\t EXT4_GET_BLOCKS_CREATE)\n\t/* Caller is from the delayed allocation writeout path\n\t * finally doing the actual allocation of delayed blocks */\n#define EXT4_GET_BLOCKS_DELALLOC_RESERVE\t0x0004\n\t/* caller is from the direct IO path, request to creation of an\n\tunwritten extents if not allocated, split the unwritten\n\textent if blocks has been preallocated already*/\n#define EXT4_GET_BLOCKS_PRE_IO\t\t\t0x0008\n#define EXT4_GET_BLOCKS_CONVERT\t\t\t0x0010\n#define EXT4_GET_BLOCKS_IO_CREATE_EXT\t\t(EXT4_GET_BLOCKS_PRE_IO|\\\n\t\t\t\t\t EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT)\n\t/* Convert extent to initialized after IO complete */\n#define EXT4_GET_BLOCKS_IO_CONVERT_EXT\t\t(EXT4_GET_BLOCKS_CONVERT|\\\n\t\t\t\t\t EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT)\n\t/* Eventual metadata allocation (due to growing extent tree)\n\t * should not fail, so try to use reserved blocks for that.*/\n#define EXT4_GET_BLOCKS_METADATA_NOFAIL\t\t0x0020\n\t/* Don't normalize allocation size (used for fallocate) */\n#define EXT4_GET_BLOCKS_NO_NORMALIZE\t\t0x0040\n\t/* Convert written extents to unwritten */\n#define EXT4_GET_BLOCKS_CONVERT_UNWRITTEN\t0x0100\n\t/* Write zeros to newly created written extents */\n#define EXT4_GET_BLOCKS_ZERO\t\t\t0x0200\n#define EXT4_GET_BLOCKS_CREATE_ZERO\t\t(EXT4_GET_BLOCKS_CREATE |\\\n\t\t\t\t\tEXT4_GET_BLOCKS_ZERO)\n\t/* Caller will submit data before dropping transaction handle. This\n\t * allows jbd2 to avoid submitting data before commit. */\n#define EXT4_GET_BLOCKS_IO_SUBMIT\t\t0x0400\n\n/*\n * The bit position of these flags must not overlap with any of the\n * EXT4_GET_BLOCKS_*.  They are used by ext4_find_extent(),\n * read_extent_tree_block(), ext4_split_extent_at(),\n * ext4_ext_insert_extent(), and ext4_ext_create_new_leaf().\n * EXT4_EX_NOCACHE is used to indicate that the we shouldn't be\n * caching the extents when reading from the extent tree while a\n * truncate or punch hole operation is in progress.\n */\n#define EXT4_EX_NOCACHE\t\t\t\t0x40000000\n#define EXT4_EX_FORCE_CACHE\t\t\t0x20000000\n#define EXT4_EX_NOFAIL\t\t\t\t0x10000000\n\n/*\n * Flags used by ext4_free_blocks\n */\n#define EXT4_FREE_BLOCKS_METADATA\t\t0x0001\n#define EXT4_FREE_BLOCKS_FORGET\t\t\t0x0002\n#define EXT4_FREE_BLOCKS_VALIDATED\t\t0x0004\n#define EXT4_FREE_BLOCKS_NO_QUOT_UPDATE\t\t0x0008\n#define EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER\t0x0010\n#define EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER\t0x0020\n#define EXT4_FREE_BLOCKS_RERESERVE_CLUSTER      0x0040\n\n/*\n * ioctl commands\n */\n#define\tEXT4_IOC_GETVERSION\t\t_IOR('f', 3, long)\n#define\tEXT4_IOC_SETVERSION\t\t_IOW('f', 4, long)\n#define\tEXT4_IOC_GETVERSION_OLD\t\tFS_IOC_GETVERSION\n#define\tEXT4_IOC_SETVERSION_OLD\t\tFS_IOC_SETVERSION\n#define EXT4_IOC_GETRSVSZ\t\t_IOR('f', 5, long)\n#define EXT4_IOC_SETRSVSZ\t\t_IOW('f', 6, long)\n#define EXT4_IOC_GROUP_EXTEND\t\t_IOW('f', 7, unsigned long)\n#define EXT4_IOC_GROUP_ADD\t\t_IOW('f', 8, struct ext4_new_group_input)\n#define EXT4_IOC_MIGRATE\t\t_IO('f', 9)\n /* note ioctl 10 reserved for an early version of the FIEMAP ioctl */\n /* note ioctl 11 reserved for filesystem-independent FIEMAP ioctl */\n#define EXT4_IOC_ALLOC_DA_BLKS\t\t_IO('f', 12)\n#define EXT4_IOC_MOVE_EXT\t\t_IOWR('f', 15, struct move_extent)\n#define EXT4_IOC_RESIZE_FS\t\t_IOW('f', 16, __u64)\n#define EXT4_IOC_SWAP_BOOT\t\t_IO('f', 17)\n#define EXT4_IOC_PRECACHE_EXTENTS\t_IO('f', 18)\n/* ioctl codes 19--39 are reserved for fscrypt */\n#define EXT4_IOC_CLEAR_ES_CACHE\t\t_IO('f', 40)\n#define EXT4_IOC_GETSTATE\t\t_IOW('f', 41, __u32)\n#define EXT4_IOC_GET_ES_CACHE\t\t_IOWR('f', 42, struct fiemap)\n\n#define EXT4_IOC_SHUTDOWN _IOR ('X', 125, __u32)\n\n/*\n * Flags for going down operation\n */\n#define EXT4_GOING_FLAGS_DEFAULT\t\t0x0\t/* going down */\n#define EXT4_GOING_FLAGS_LOGFLUSH\t\t0x1\t/* flush log but not data */\n#define EXT4_GOING_FLAGS_NOLOGFLUSH\t\t0x2\t/* don't flush log nor data */\n\n/*\n * Flags returned by EXT4_IOC_GETSTATE\n *\n * We only expose to userspace a subset of the state flags in\n * i_state_flags\n */\n#define EXT4_STATE_FLAG_EXT_PRECACHED\t0x00000001\n#define EXT4_STATE_FLAG_NEW\t\t0x00000002\n#define EXT4_STATE_FLAG_NEWENTRY\t0x00000004\n#define EXT4_STATE_FLAG_DA_ALLOC_CLOSE\t0x00000008\n\n#if defined(__KERNEL__) && defined(CONFIG_COMPAT)\n/*\n * ioctl commands in 32 bit emulation\n */\n#define EXT4_IOC32_GETVERSION\t\t_IOR('f', 3, int)\n#define EXT4_IOC32_SETVERSION\t\t_IOW('f', 4, int)\n#define EXT4_IOC32_GETRSVSZ\t\t_IOR('f', 5, int)\n#define EXT4_IOC32_SETRSVSZ\t\t_IOW('f', 6, int)\n#define EXT4_IOC32_GROUP_EXTEND\t\t_IOW('f', 7, unsigned int)\n#define EXT4_IOC32_GROUP_ADD\t\t_IOW('f', 8, struct compat_ext4_new_group_input)\n#define EXT4_IOC32_GETVERSION_OLD\tFS_IOC32_GETVERSION\n#define EXT4_IOC32_SETVERSION_OLD\tFS_IOC32_SETVERSION\n#endif\n\n/*\n * Returned by EXT4_IOC_GET_ES_CACHE as an additional possible flag.\n * It indicates that the entry in extent status cache is for a hole.\n */\n#define EXT4_FIEMAP_EXTENT_HOLE\t\t0x08000000\n\n/* Max physical block we can address w/o extents */\n#define EXT4_MAX_BLOCK_FILE_PHYS\t0xFFFFFFFF\n\n/* Max logical block we can support */\n#define EXT4_MAX_LOGICAL_BLOCK\t\t0xFFFFFFFE\n\n/*\n * Structure of an inode on the disk\n */\nstruct ext4_inode {\n\t__le16\ti_mode;\t\t/* File mode */\n\t__le16\ti_uid;\t\t/* Low 16 bits of Owner Uid */\n\t__le32\ti_size_lo;\t/* Size in bytes */\n\t__le32\ti_atime;\t/* Access time */\n\t__le32\ti_ctime;\t/* Inode Change time */\n\t__le32\ti_mtime;\t/* Modification time */\n\t__le32\ti_dtime;\t/* Deletion Time */\n\t__le16\ti_gid;\t\t/* Low 16 bits of Group Id */\n\t__le16\ti_links_count;\t/* Links count */\n\t__le32\ti_blocks_lo;\t/* Blocks count */\n\t__le32\ti_flags;\t/* File flags */\n\tunion {\n\t\tstruct {\n\t\t\t__le32  l_i_version;\n\t\t} linux1;\n\t\tstruct {\n\t\t\t__u32  h_i_translator;\n\t\t} hurd1;\n\t\tstruct {\n\t\t\t__u32  m_i_reserved1;\n\t\t} masix1;\n\t} osd1;\t\t\t\t/* OS dependent 1 */\n\t__le32\ti_block[EXT4_N_BLOCKS];/* Pointers to blocks */\n\t__le32\ti_generation;\t/* File version (for NFS) */\n\t__le32\ti_file_acl_lo;\t/* File ACL */\n\t__le32\ti_size_high;\n\t__le32\ti_obso_faddr;\t/* Obsoleted fragment address */\n\tunion {\n\t\tstruct {\n\t\t\t__le16\tl_i_blocks_high; /* were l_i_reserved1 */\n\t\t\t__le16\tl_i_file_acl_high;\n\t\t\t__le16\tl_i_uid_high;\t/* these 2 fields */\n\t\t\t__le16\tl_i_gid_high;\t/* were reserved2[0] */\n\t\t\t__le16\tl_i_checksum_lo;/* crc32c(uuid+inum+inode) LE */\n\t\t\t__le16\tl_i_reserved;\n\t\t} linux2;\n\t\tstruct {\n\t\t\t__le16\th_i_reserved1;\t/* Obsoleted fragment number/size which are removed in ext4 */\n\t\t\t__u16\th_i_mode_high;\n\t\t\t__u16\th_i_uid_high;\n\t\t\t__u16\th_i_gid_high;\n\t\t\t__u32\th_i_author;\n\t\t} hurd2;\n\t\tstruct {\n\t\t\t__le16\th_i_reserved1;\t/* Obsoleted fragment number/size which are removed in ext4 */\n\t\t\t__le16\tm_i_file_acl_high;\n\t\t\t__u32\tm_i_reserved2[2];\n\t\t} masix2;\n\t} osd2;\t\t\t\t/* OS dependent 2 */\n\t__le16\ti_extra_isize;\n\t__le16\ti_checksum_hi;\t/* crc32c(uuid+inum+inode) BE */\n\t__le32  i_ctime_extra;  /* extra Change time      (nsec << 2 | epoch) */\n\t__le32  i_mtime_extra;  /* extra Modification time(nsec << 2 | epoch) */\n\t__le32  i_atime_extra;  /* extra Access time      (nsec << 2 | epoch) */\n\t__le32  i_crtime;       /* File Creation time */\n\t__le32  i_crtime_extra; /* extra FileCreationtime (nsec << 2 | epoch) */\n\t__le32  i_version_hi;\t/* high 32 bits for 64-bit version */\n\t__le32\ti_projid;\t/* Project ID */\n};\n\nstruct move_extent {\n\t__u32 reserved;\t\t/* should be zero */\n\t__u32 donor_fd;\t\t/* donor file descriptor */\n\t__u64 orig_start;\t/* logical start offset in block for orig */\n\t__u64 donor_start;\t/* logical start offset in block for donor */\n\t__u64 len;\t\t/* block length to be moved */\n\t__u64 moved_len;\t/* moved block length */\n};\n\n#define EXT4_EPOCH_BITS 2\n#define EXT4_EPOCH_MASK ((1 << EXT4_EPOCH_BITS) - 1)\n#define EXT4_NSEC_MASK  (~0UL << EXT4_EPOCH_BITS)\n\n/*\n * Extended fields will fit into an inode if the filesystem was formatted\n * with large inodes (-I 256 or larger) and there are not currently any EAs\n * consuming all of the available space. For new inodes we always reserve\n * enough space for the kernel's known extended fields, but for inodes\n * created with an old kernel this might not have been the case. None of\n * the extended inode fields is critical for correct filesystem operation.\n * This macro checks if a certain field fits in the inode. Note that\n * inode-size = GOOD_OLD_INODE_SIZE + i_extra_isize\n */\n#define EXT4_FITS_IN_INODE(ext4_inode, einode, field)\t\\\n\t((offsetof(typeof(*ext4_inode), field) +\t\\\n\t  sizeof((ext4_inode)->field))\t\t\t\\\n\t<= (EXT4_GOOD_OLD_INODE_SIZE +\t\t\t\\\n\t    (einode)->i_extra_isize))\t\t\t\\\n\n/*\n * We use an encoding that preserves the times for extra epoch \"00\":\n *\n * extra  msb of                         adjust for signed\n * epoch  32-bit                         32-bit tv_sec to\n * bits   time    decoded 64-bit tv_sec  64-bit tv_sec      valid time range\n * 0 0    1    -0x80000000..-0x00000001  0x000000000 1901-12-13..1969-12-31\n * 0 0    0    0x000000000..0x07fffffff  0x000000000 1970-01-01..2038-01-19\n * 0 1    1    0x080000000..0x0ffffffff  0x100000000 2038-01-19..2106-02-07\n * 0 1    0    0x100000000..0x17fffffff  0x100000000 2106-02-07..2174-02-25\n * 1 0    1    0x180000000..0x1ffffffff  0x200000000 2174-02-25..2242-03-16\n * 1 0    0    0x200000000..0x27fffffff  0x200000000 2242-03-16..2310-04-04\n * 1 1    1    0x280000000..0x2ffffffff  0x300000000 2310-04-04..2378-04-22\n * 1 1    0    0x300000000..0x37fffffff  0x300000000 2378-04-22..2446-05-10\n *\n * Note that previous versions of the kernel on 64-bit systems would\n * incorrectly use extra epoch bits 1,1 for dates between 1901 and\n * 1970.  e2fsck will correct this, assuming that it is run on the\n * affected filesystem before 2242.\n */\n\nstatic inline __le32 ext4_encode_extra_time(struct timespec64 *time)\n{\n\tu32 extra =((time->tv_sec - (s32)time->tv_sec) >> 32) & EXT4_EPOCH_MASK;\n\treturn cpu_to_le32(extra | (time->tv_nsec << EXT4_EPOCH_BITS));\n}\n\nstatic inline void ext4_decode_extra_time(struct timespec64 *time,\n\t\t\t\t\t  __le32 extra)\n{\n\tif (unlikely(extra & cpu_to_le32(EXT4_EPOCH_MASK)))\n\t\ttime->tv_sec += (u64)(le32_to_cpu(extra) & EXT4_EPOCH_MASK) << 32;\n\ttime->tv_nsec = (le32_to_cpu(extra) & EXT4_NSEC_MASK) >> EXT4_EPOCH_BITS;\n}\n\n#define EXT4_INODE_SET_XTIME(xtime, inode, raw_inode)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tif (EXT4_FITS_IN_INODE(raw_inode, EXT4_I(inode), xtime ## _extra))     {\\\n\t\t(raw_inode)->xtime = cpu_to_le32((inode)->xtime.tv_sec);\t\\\n\t\t(raw_inode)->xtime ## _extra =\t\t\t\t\t\\\n\t\t\t\text4_encode_extra_time(&(inode)->xtime);\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\telse\t\\\n\t\t(raw_inode)->xtime = cpu_to_le32(clamp_t(int32_t, (inode)->xtime.tv_sec, S32_MIN, S32_MAX));\t\\\n} while (0)\n\n#define EXT4_EINODE_SET_XTIME(xtime, einode, raw_inode)\t\t\t       \\\ndo {\t\t\t\t\t\t\t\t\t       \\\n\tif (EXT4_FITS_IN_INODE(raw_inode, einode, xtime))\t\t       \\\n\t\t(raw_inode)->xtime = cpu_to_le32((einode)->xtime.tv_sec);      \\\n\tif (EXT4_FITS_IN_INODE(raw_inode, einode, xtime ## _extra))\t       \\\n\t\t(raw_inode)->xtime ## _extra =\t\t\t\t       \\\n\t\t\t\text4_encode_extra_time(&(einode)->xtime);      \\\n} while (0)\n\n#define EXT4_INODE_GET_XTIME(xtime, inode, raw_inode)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\t(inode)->xtime.tv_sec = (signed)le32_to_cpu((raw_inode)->xtime);\t\\\n\tif (EXT4_FITS_IN_INODE(raw_inode, EXT4_I(inode), xtime ## _extra)) {\t\\\n\t\text4_decode_extra_time(&(inode)->xtime,\t\t\t\t\\\n\t\t\t\t       raw_inode->xtime ## _extra);\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\t\\\n\t\t(inode)->xtime.tv_nsec = 0;\t\t\t\t\t\\\n} while (0)\n\n\n#define EXT4_EINODE_GET_XTIME(xtime, einode, raw_inode)\t\t\t       \\\ndo {\t\t\t\t\t\t\t\t\t       \\\n\tif (EXT4_FITS_IN_INODE(raw_inode, einode, xtime))\t\t       \\\n\t\t(einode)->xtime.tv_sec = \t\t\t\t       \\\n\t\t\t(signed)le32_to_cpu((raw_inode)->xtime);\t       \\\n\telse\t\t\t\t\t\t\t\t       \\\n\t\t(einode)->xtime.tv_sec = 0;\t\t\t\t       \\\n\tif (EXT4_FITS_IN_INODE(raw_inode, einode, xtime ## _extra))\t       \\\n\t\text4_decode_extra_time(&(einode)->xtime,\t\t       \\\n\t\t\t\t       raw_inode->xtime ## _extra);\t       \\\n\telse\t\t\t\t\t\t\t\t       \\\n\t\t(einode)->xtime.tv_nsec = 0;\t\t\t\t       \\\n} while (0)\n\n#define i_disk_version osd1.linux1.l_i_version\n\n#if defined(__KERNEL__) || defined(__linux__)\n#define i_reserved1\tosd1.linux1.l_i_reserved1\n#define i_file_acl_high\tosd2.linux2.l_i_file_acl_high\n#define i_blocks_high\tosd2.linux2.l_i_blocks_high\n#define i_uid_low\ti_uid\n#define i_gid_low\ti_gid\n#define i_uid_high\tosd2.linux2.l_i_uid_high\n#define i_gid_high\tosd2.linux2.l_i_gid_high\n#define i_checksum_lo\tosd2.linux2.l_i_checksum_lo\n\n#elif defined(__GNU__)\n\n#define i_translator\tosd1.hurd1.h_i_translator\n#define i_uid_high\tosd2.hurd2.h_i_uid_high\n#define i_gid_high\tosd2.hurd2.h_i_gid_high\n#define i_author\tosd2.hurd2.h_i_author\n\n#elif defined(__masix__)\n\n#define i_reserved1\tosd1.masix1.m_i_reserved1\n#define i_file_acl_high\tosd2.masix2.m_i_file_acl_high\n#define i_reserved2\tosd2.masix2.m_i_reserved2\n\n#endif /* defined(__KERNEL__) || defined(__linux__) */\n\n#include \"extents_status.h\"\n#include \"fast_commit.h\"\n\n/*\n * Lock subclasses for i_data_sem in the ext4_inode_info structure.\n *\n * These are needed to avoid lockdep false positives when we need to\n * allocate blocks to the quota inode during ext4_map_blocks(), while\n * holding i_data_sem for a normal (non-quota) inode.  Since we don't\n * do quota tracking for the quota inode, this avoids deadlock (as\n * well as infinite recursion, since it isn't turtles all the way\n * down...)\n *\n *  I_DATA_SEM_NORMAL - Used for most inodes\n *  I_DATA_SEM_OTHER  - Used by move_inode.c for the second normal inode\n *\t\t\t  where the second inode has larger inode number\n *\t\t\t  than the first\n *  I_DATA_SEM_QUOTA  - Used for quota inodes only\n */\nenum {\n\tI_DATA_SEM_NORMAL = 0,\n\tI_DATA_SEM_OTHER,\n\tI_DATA_SEM_QUOTA,\n};\n\n\n/*\n * fourth extended file system inode data in memory\n */\nstruct ext4_inode_info {\n\t__le32\ti_data[15];\t/* unconverted */\n\t__u32\ti_dtime;\n\text4_fsblk_t\ti_file_acl;\n\n\t/*\n\t * i_block_group is the number of the block group which contains\n\t * this file's inode.  Constant across the lifetime of the inode,\n\t * it is used for making block allocation decisions - we try to\n\t * place a file's data blocks near its inode block, and new inodes\n\t * near to their parent directory's inode.\n\t */\n\text4_group_t\ti_block_group;\n\text4_lblk_t\ti_dir_start_lookup;\n#if (BITS_PER_LONG < 64)\n\tunsigned long\ti_state_flags;\t\t/* Dynamic state flags */\n#endif\n\tunsigned long\ti_flags;\n\n\t/*\n\t * Extended attributes can be read independently of the main file\n\t * data. Taking i_mutex even when reading would cause contention\n\t * between readers of EAs and writers of regular file data, so\n\t * instead we synchronize on xattr_sem when reading or changing\n\t * EAs.\n\t */\n\tstruct rw_semaphore xattr_sem;\n\n\tstruct list_head i_orphan;\t/* unlinked but open inodes */\n\n\t/* Fast commit related info */\n\n\tstruct list_head i_fc_list;\t/*\n\t\t\t\t\t * inodes that need fast commit\n\t\t\t\t\t * protected by sbi->s_fc_lock.\n\t\t\t\t\t */\n\n\t/* Start of lblk range that needs to be committed in this fast commit */\n\text4_lblk_t i_fc_lblk_start;\n\n\t/* End of lblk range that needs to be committed in this fast commit */\n\text4_lblk_t i_fc_lblk_len;\n\n\t/* Number of ongoing updates on this inode */\n\tatomic_t  i_fc_updates;\n\n\t/* Fast commit wait queue for this inode */\n\twait_queue_head_t i_fc_wait;\n\n\t/* Protect concurrent accesses on i_fc_lblk_start, i_fc_lblk_len */\n\tstruct mutex i_fc_lock;\n\n\t/*\n\t * i_disksize keeps track of what the inode size is ON DISK, not\n\t * in memory.  During truncate, i_size is set to the new size by\n\t * the VFS prior to calling ext4_truncate(), but the filesystem won't\n\t * set i_disksize to 0 until the truncate is actually under way.\n\t *\n\t * The intent is that i_disksize always represents the blocks which\n\t * are used by this file.  This allows recovery to restart truncate\n\t * on orphans if we crash during truncate.  We actually write i_disksize\n\t * into the on-disk inode when writing inodes out, instead of i_size.\n\t *\n\t * The only time when i_disksize and i_size may be different is when\n\t * a truncate is in progress.  The only things which change i_disksize\n\t * are ext4_get_block (growth) and ext4_truncate (shrinkth).\n\t */\n\tloff_t\ti_disksize;\n\n\t/*\n\t * i_data_sem is for serialising ext4_truncate() against\n\t * ext4_getblock().  In the 2.4 ext2 design, great chunks of inode's\n\t * data tree are chopped off during truncate. We can't do that in\n\t * ext4 because whenever we perform intermediate commits during\n\t * truncate, the inode and all the metadata blocks *must* be in a\n\t * consistent state which allows truncation of the orphans to restart\n\t * during recovery.  Hence we must fix the get_block-vs-truncate race\n\t * by other means, so we have i_data_sem.\n\t */\n\tstruct rw_semaphore i_data_sem;\n\t/*\n\t * i_mmap_sem is for serializing page faults with truncate / punch hole\n\t * operations. We have to make sure that new page cannot be faulted in\n\t * a section of the inode that is being punched. We cannot easily use\n\t * i_data_sem for this since we need protection for the whole punch\n\t * operation and i_data_sem ranks below transaction start so we have\n\t * to occasionally drop it.\n\t */\n\tstruct rw_semaphore i_mmap_sem;\n\tstruct inode vfs_inode;\n\tstruct jbd2_inode *jinode;\n\n\tspinlock_t i_raw_lock;\t/* protects updates to the raw inode */\n\n\t/*\n\t * File creation time. Its function is same as that of\n\t * struct timespec64 i_{a,c,m}time in the generic inode.\n\t */\n\tstruct timespec64 i_crtime;\n\n\t/* mballoc */\n\tatomic_t i_prealloc_active;\n\tstruct list_head i_prealloc_list;\n\tspinlock_t i_prealloc_lock;\n\n\t/* extents status tree */\n\tstruct ext4_es_tree i_es_tree;\n\trwlock_t i_es_lock;\n\tstruct list_head i_es_list;\n\tunsigned int i_es_all_nr;\t/* protected by i_es_lock */\n\tunsigned int i_es_shk_nr;\t/* protected by i_es_lock */\n\text4_lblk_t i_es_shrink_lblk;\t/* Offset where we start searching for\n\t\t\t\t\t   extents to shrink. Protected by\n\t\t\t\t\t   i_es_lock  */\n\n\t/* ialloc */\n\text4_group_t\ti_last_alloc_group;\n\n\t/* allocation reservation info for delalloc */\n\t/* In case of bigalloc, this refer to clusters rather than blocks */\n\tunsigned int i_reserved_data_blocks;\n\n\t/* pending cluster reservations for bigalloc file systems */\n\tstruct ext4_pending_tree i_pending_tree;\n\n\t/* on-disk additional length */\n\t__u16 i_extra_isize;\n\n\t/* Indicate the inline data space. */\n\tu16 i_inline_off;\n\tu16 i_inline_size;\n\n#ifdef CONFIG_QUOTA\n\t/* quota space reservation, managed internally by quota code */\n\tqsize_t i_reserved_quota;\n#endif\n\n\t/* Lock protecting lists below */\n\tspinlock_t i_completed_io_lock;\n\t/*\n\t * Completed IOs that need unwritten extents handling and have\n\t * transaction reserved\n\t */\n\tstruct list_head i_rsv_conversion_list;\n\tstruct work_struct i_rsv_conversion_work;\n\tatomic_t i_unwritten; /* Nr. of inflight conversions pending */\n\n\tspinlock_t i_block_reservation_lock;\n\n\t/*\n\t * Transactions that contain inode's metadata needed to complete\n\t * fsync and fdatasync, respectively.\n\t */\n\ttid_t i_sync_tid;\n\ttid_t i_datasync_tid;\n\n#ifdef CONFIG_QUOTA\n\tstruct dquot *i_dquot[MAXQUOTAS];\n#endif\n\n\t/* Precomputed uuid+inum+igen checksum for seeding inode checksums */\n\t__u32 i_csum_seed;\n\n\tkprojid_t i_projid;\n};\n\n/*\n * File system states\n */\n#define\tEXT4_VALID_FS\t\t\t0x0001\t/* Unmounted cleanly */\n#define\tEXT4_ERROR_FS\t\t\t0x0002\t/* Errors detected */\n#define\tEXT4_ORPHAN_FS\t\t\t0x0004\t/* Orphans being recovered */\n#define EXT4_FC_REPLAY\t\t\t0x0020\t/* Fast commit replay ongoing */\n\n/*\n * Misc. filesystem flags\n */\n#define EXT2_FLAGS_SIGNED_HASH\t\t0x0001  /* Signed dirhash in use */\n#define EXT2_FLAGS_UNSIGNED_HASH\t0x0002  /* Unsigned dirhash in use */\n#define EXT2_FLAGS_TEST_FILESYS\t\t0x0004\t/* to test development code */\n\n/*\n * Mount flags set via mount options or defaults\n */\n#define EXT4_MOUNT_NO_MBCACHE\t\t0x00001 /* Do not use mbcache */\n#define EXT4_MOUNT_GRPID\t\t0x00004\t/* Create files with directory's group */\n#define EXT4_MOUNT_DEBUG\t\t0x00008\t/* Some debugging messages */\n#define EXT4_MOUNT_ERRORS_CONT\t\t0x00010\t/* Continue on errors */\n#define EXT4_MOUNT_ERRORS_RO\t\t0x00020\t/* Remount fs ro on errors */\n#define EXT4_MOUNT_ERRORS_PANIC\t\t0x00040\t/* Panic on errors */\n#define EXT4_MOUNT_ERRORS_MASK\t\t0x00070\n#define EXT4_MOUNT_MINIX_DF\t\t0x00080\t/* Mimics the Minix statfs */\n#define EXT4_MOUNT_NOLOAD\t\t0x00100\t/* Don't use existing journal*/\n#ifdef CONFIG_FS_DAX\n#define EXT4_MOUNT_DAX_ALWAYS\t\t0x00200\t/* Direct Access */\n#else\n#define EXT4_MOUNT_DAX_ALWAYS\t\t0\n#endif\n#define EXT4_MOUNT_DATA_FLAGS\t\t0x00C00\t/* Mode for data writes: */\n#define EXT4_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */\n#define EXT4_MOUNT_ORDERED_DATA\t\t0x00800\t/* Flush data before commit */\n#define EXT4_MOUNT_WRITEBACK_DATA\t0x00C00\t/* No data ordering */\n#define EXT4_MOUNT_UPDATE_JOURNAL\t0x01000\t/* Update the journal format */\n#define EXT4_MOUNT_NO_UID32\t\t0x02000  /* Disable 32-bit UIDs */\n#define EXT4_MOUNT_XATTR_USER\t\t0x04000\t/* Extended user attributes */\n#define EXT4_MOUNT_POSIX_ACL\t\t0x08000\t/* POSIX Access Control Lists */\n#define EXT4_MOUNT_NO_AUTO_DA_ALLOC\t0x10000\t/* No auto delalloc mapping */\n#define EXT4_MOUNT_BARRIER\t\t0x20000 /* Use block barriers */\n#define EXT4_MOUNT_QUOTA\t\t0x40000 /* Some quota option set */\n#define EXT4_MOUNT_USRQUOTA\t\t0x80000 /* \"old\" user quota,\n\t\t\t\t\t\t * enable enforcement for hidden\n\t\t\t\t\t\t * quota files */\n#define EXT4_MOUNT_GRPQUOTA\t\t0x100000 /* \"old\" group quota, enable\n\t\t\t\t\t\t  * enforcement for hidden quota\n\t\t\t\t\t\t  * files */\n#define EXT4_MOUNT_PRJQUOTA\t\t0x200000 /* Enable project quota\n\t\t\t\t\t\t  * enforcement */\n#define EXT4_MOUNT_DIOREAD_NOLOCK\t0x400000 /* Enable support for dio read nolocking */\n#define EXT4_MOUNT_JOURNAL_CHECKSUM\t0x800000 /* Journal checksums */\n#define EXT4_MOUNT_JOURNAL_ASYNC_COMMIT\t0x1000000 /* Journal Async Commit */\n#define EXT4_MOUNT_WARN_ON_ERROR\t0x2000000 /* Trigger WARN_ON on error */\n#define EXT4_MOUNT_PREFETCH_BLOCK_BITMAPS 0x4000000\n#define EXT4_MOUNT_DELALLOC\t\t0x8000000 /* Delalloc support */\n#define EXT4_MOUNT_DATA_ERR_ABORT\t0x10000000 /* Abort on file data write */\n#define EXT4_MOUNT_BLOCK_VALIDITY\t0x20000000 /* Block validity checking */\n#define EXT4_MOUNT_DISCARD\t\t0x40000000 /* Issue DISCARD requests */\n#define EXT4_MOUNT_INIT_INODE_TABLE\t0x80000000 /* Initialize uninitialized itables */\n\n/*\n * Mount flags set either automatically (could not be set by mount option)\n * based on per file system feature or property or in special cases such as\n * distinguishing between explicit mount option definition and default.\n */\n#define EXT4_MOUNT2_EXPLICIT_DELALLOC\t0x00000001 /* User explicitly\n\t\t\t\t\t\t      specified delalloc */\n#define EXT4_MOUNT2_STD_GROUP_SIZE\t0x00000002 /* We have standard group\n\t\t\t\t\t\t      size of blocksize * 8\n\t\t\t\t\t\t      blocks */\n#define EXT4_MOUNT2_HURD_COMPAT\t\t0x00000004 /* Support HURD-castrated\n\t\t\t\t\t\t      file systems */\n#define EXT4_MOUNT2_EXPLICIT_JOURNAL_CHECKSUM\t0x00000008 /* User explicitly\n\t\t\t\t\t\tspecified journal checksum */\n\n#define EXT4_MOUNT2_JOURNAL_FAST_COMMIT\t0x00000010 /* Journal fast commit */\n#define EXT4_MOUNT2_DAX_NEVER\t\t0x00000020 /* Do not allow Direct Access */\n#define EXT4_MOUNT2_DAX_INODE\t\t0x00000040 /* For printing options only */\n\n\n#define clear_opt(sb, opt)\t\tEXT4_SB(sb)->s_mount_opt &= \\\n\t\t\t\t\t\t~EXT4_MOUNT_##opt\n#define set_opt(sb, opt)\t\tEXT4_SB(sb)->s_mount_opt |= \\\n\t\t\t\t\t\tEXT4_MOUNT_##opt\n#define test_opt(sb, opt)\t\t(EXT4_SB(sb)->s_mount_opt & \\\n\t\t\t\t\t EXT4_MOUNT_##opt)\n\n#define clear_opt2(sb, opt)\t\tEXT4_SB(sb)->s_mount_opt2 &= \\\n\t\t\t\t\t\t~EXT4_MOUNT2_##opt\n#define set_opt2(sb, opt)\t\tEXT4_SB(sb)->s_mount_opt2 |= \\\n\t\t\t\t\t\tEXT4_MOUNT2_##opt\n#define test_opt2(sb, opt)\t\t(EXT4_SB(sb)->s_mount_opt2 & \\\n\t\t\t\t\t EXT4_MOUNT2_##opt)\n\n#define ext4_test_and_set_bit\t\t__test_and_set_bit_le\n#define ext4_set_bit\t\t\t__set_bit_le\n#define ext4_set_bit_atomic\t\text2_set_bit_atomic\n#define ext4_test_and_clear_bit\t\t__test_and_clear_bit_le\n#define ext4_clear_bit\t\t\t__clear_bit_le\n#define ext4_clear_bit_atomic\t\text2_clear_bit_atomic\n#define ext4_test_bit\t\t\ttest_bit_le\n#define ext4_find_next_zero_bit\t\tfind_next_zero_bit_le\n#define ext4_find_next_bit\t\tfind_next_bit_le\n\nextern void ext4_set_bits(void *bm, int cur, int len);\n\n/*\n * Maximal mount counts between two filesystem checks\n */\n#define EXT4_DFL_MAX_MNT_COUNT\t\t20\t/* Allow 20 mounts */\n#define EXT4_DFL_CHECKINTERVAL\t\t0\t/* Don't use interval check */\n\n/*\n * Behaviour when detecting errors\n */\n#define EXT4_ERRORS_CONTINUE\t\t1\t/* Continue execution */\n#define EXT4_ERRORS_RO\t\t\t2\t/* Remount fs read-only */\n#define EXT4_ERRORS_PANIC\t\t3\t/* Panic */\n#define EXT4_ERRORS_DEFAULT\t\tEXT4_ERRORS_CONTINUE\n\n/* Metadata checksum algorithm codes */\n#define EXT4_CRC32C_CHKSUM\t\t1\n\n/*\n * Structure of the super block\n */\nstruct ext4_super_block {\n/*00*/\t__le32\ts_inodes_count;\t\t/* Inodes count */\n\t__le32\ts_blocks_count_lo;\t/* Blocks count */\n\t__le32\ts_r_blocks_count_lo;\t/* Reserved blocks count */\n\t__le32\ts_free_blocks_count_lo;\t/* Free blocks count */\n/*10*/\t__le32\ts_free_inodes_count;\t/* Free inodes count */\n\t__le32\ts_first_data_block;\t/* First Data Block */\n\t__le32\ts_log_block_size;\t/* Block size */\n\t__le32\ts_log_cluster_size;\t/* Allocation cluster size */\n/*20*/\t__le32\ts_blocks_per_group;\t/* # Blocks per group */\n\t__le32\ts_clusters_per_group;\t/* # Clusters per group */\n\t__le32\ts_inodes_per_group;\t/* # Inodes per group */\n\t__le32\ts_mtime;\t\t/* Mount time */\n/*30*/\t__le32\ts_wtime;\t\t/* Write time */\n\t__le16\ts_mnt_count;\t\t/* Mount count */\n\t__le16\ts_max_mnt_count;\t/* Maximal mount count */\n\t__le16\ts_magic;\t\t/* Magic signature */\n\t__le16\ts_state;\t\t/* File system state */\n\t__le16\ts_errors;\t\t/* Behaviour when detecting errors */\n\t__le16\ts_minor_rev_level;\t/* minor revision level */\n/*40*/\t__le32\ts_lastcheck;\t\t/* time of last check */\n\t__le32\ts_checkinterval;\t/* max. time between checks */\n\t__le32\ts_creator_os;\t\t/* OS */\n\t__le32\ts_rev_level;\t\t/* Revision level */\n/*50*/\t__le16\ts_def_resuid;\t\t/* Default uid for reserved blocks */\n\t__le16\ts_def_resgid;\t\t/* Default gid for reserved blocks */\n\t/*\n\t * These fields are for EXT4_DYNAMIC_REV superblocks only.\n\t *\n\t * Note: the difference between the compatible feature set and\n\t * the incompatible feature set is that if there is a bit set\n\t * in the incompatible feature set that the kernel doesn't\n\t * know about, it should refuse to mount the filesystem.\n\t *\n\t * e2fsck's requirements are more strict; if it doesn't know\n\t * about a feature in either the compatible or incompatible\n\t * feature set, it must abort and not try to meddle with\n\t * things it doesn't understand...\n\t */\n\t__le32\ts_first_ino;\t\t/* First non-reserved inode */\n\t__le16  s_inode_size;\t\t/* size of inode structure */\n\t__le16\ts_block_group_nr;\t/* block group # of this superblock */\n\t__le32\ts_feature_compat;\t/* compatible feature set */\n/*60*/\t__le32\ts_feature_incompat;\t/* incompatible feature set */\n\t__le32\ts_feature_ro_compat;\t/* readonly-compatible feature set */\n/*68*/\t__u8\ts_uuid[16];\t\t/* 128-bit uuid for volume */\n/*78*/\tchar\ts_volume_name[16];\t/* volume name */\n/*88*/\tchar\ts_last_mounted[64] __nonstring;\t/* directory where last mounted */\n/*C8*/\t__le32\ts_algorithm_usage_bitmap; /* For compression */\n\t/*\n\t * Performance hints.  Directory preallocation should only\n\t * happen if the EXT4_FEATURE_COMPAT_DIR_PREALLOC flag is on.\n\t */\n\t__u8\ts_prealloc_blocks;\t/* Nr of blocks to try to preallocate*/\n\t__u8\ts_prealloc_dir_blocks;\t/* Nr to preallocate for dirs */\n\t__le16\ts_reserved_gdt_blocks;\t/* Per group desc for online growth */\n\t/*\n\t * Journaling support valid if EXT4_FEATURE_COMPAT_HAS_JOURNAL set.\n\t */\n/*D0*/\t__u8\ts_journal_uuid[16];\t/* uuid of journal superblock */\n/*E0*/\t__le32\ts_journal_inum;\t\t/* inode number of journal file */\n\t__le32\ts_journal_dev;\t\t/* device number of journal file */\n\t__le32\ts_last_orphan;\t\t/* start of list of inodes to delete */\n\t__le32\ts_hash_seed[4];\t\t/* HTREE hash seed */\n\t__u8\ts_def_hash_version;\t/* Default hash version to use */\n\t__u8\ts_jnl_backup_type;\n\t__le16  s_desc_size;\t\t/* size of group descriptor */\n/*100*/\t__le32\ts_default_mount_opts;\n\t__le32\ts_first_meta_bg;\t/* First metablock block group */\n\t__le32\ts_mkfs_time;\t\t/* When the filesystem was created */\n\t__le32\ts_jnl_blocks[17];\t/* Backup of the journal inode */\n\t/* 64bit support valid if EXT4_FEATURE_COMPAT_64BIT */\n/*150*/\t__le32\ts_blocks_count_hi;\t/* Blocks count */\n\t__le32\ts_r_blocks_count_hi;\t/* Reserved blocks count */\n\t__le32\ts_free_blocks_count_hi;\t/* Free blocks count */\n\t__le16\ts_min_extra_isize;\t/* All inodes have at least # bytes */\n\t__le16\ts_want_extra_isize; \t/* New inodes should reserve # bytes */\n\t__le32\ts_flags;\t\t/* Miscellaneous flags */\n\t__le16  s_raid_stride;\t\t/* RAID stride */\n\t__le16  s_mmp_update_interval;  /* # seconds to wait in MMP checking */\n\t__le64  s_mmp_block;            /* Block for multi-mount protection */\n\t__le32  s_raid_stripe_width;    /* blocks on all data disks (N*stride)*/\n\t__u8\ts_log_groups_per_flex;  /* FLEX_BG group size */\n\t__u8\ts_checksum_type;\t/* metadata checksum algorithm used */\n\t__u8\ts_encryption_level;\t/* versioning level for encryption */\n\t__u8\ts_reserved_pad;\t\t/* Padding to next 32bits */\n\t__le64\ts_kbytes_written;\t/* nr of lifetime kilobytes written */\n\t__le32\ts_snapshot_inum;\t/* Inode number of active snapshot */\n\t__le32\ts_snapshot_id;\t\t/* sequential ID of active snapshot */\n\t__le64\ts_snapshot_r_blocks_count; /* reserved blocks for active\n\t\t\t\t\t      snapshot's future use */\n\t__le32\ts_snapshot_list;\t/* inode number of the head of the\n\t\t\t\t\t   on-disk snapshot list */\n#define EXT4_S_ERR_START offsetof(struct ext4_super_block, s_error_count)\n\t__le32\ts_error_count;\t\t/* number of fs errors */\n\t__le32\ts_first_error_time;\t/* first time an error happened */\n\t__le32\ts_first_error_ino;\t/* inode involved in first error */\n\t__le64\ts_first_error_block;\t/* block involved of first error */\n\t__u8\ts_first_error_func[32] __nonstring;\t/* function where the error happened */\n\t__le32\ts_first_error_line;\t/* line number where error happened */\n\t__le32\ts_last_error_time;\t/* most recent time of an error */\n\t__le32\ts_last_error_ino;\t/* inode involved in last error */\n\t__le32\ts_last_error_line;\t/* line number where error happened */\n\t__le64\ts_last_error_block;\t/* block involved of last error */\n\t__u8\ts_last_error_func[32] __nonstring;\t/* function where the error happened */\n#define EXT4_S_ERR_END offsetof(struct ext4_super_block, s_mount_opts)\n\t__u8\ts_mount_opts[64];\n\t__le32\ts_usr_quota_inum;\t/* inode for tracking user quota */\n\t__le32\ts_grp_quota_inum;\t/* inode for tracking group quota */\n\t__le32\ts_overhead_clusters;\t/* overhead blocks/clusters in fs */\n\t__le32\ts_backup_bgs[2];\t/* groups with sparse_super2 SBs */\n\t__u8\ts_encrypt_algos[4];\t/* Encryption algorithms in use  */\n\t__u8\ts_encrypt_pw_salt[16];\t/* Salt used for string2key algorithm */\n\t__le32\ts_lpf_ino;\t\t/* Location of the lost+found inode */\n\t__le32\ts_prj_quota_inum;\t/* inode for tracking project quota */\n\t__le32\ts_checksum_seed;\t/* crc32c(uuid) if csum_seed set */\n\t__u8\ts_wtime_hi;\n\t__u8\ts_mtime_hi;\n\t__u8\ts_mkfs_time_hi;\n\t__u8\ts_lastcheck_hi;\n\t__u8\ts_first_error_time_hi;\n\t__u8\ts_last_error_time_hi;\n\t__u8\ts_first_error_errcode;\n\t__u8    s_last_error_errcode;\n\t__le16  s_encoding;\t\t/* Filename charset encoding */\n\t__le16  s_encoding_flags;\t/* Filename charset encoding flags */\n\t__le32\ts_reserved[95];\t\t/* Padding to the end of the block */\n\t__le32\ts_checksum;\t\t/* crc32c(superblock) */\n};\n\n#define EXT4_S_ERR_LEN (EXT4_S_ERR_END - EXT4_S_ERR_START)\n\n#ifdef __KERNEL__\n\n#ifdef CONFIG_FS_ENCRYPTION\n#define DUMMY_ENCRYPTION_ENABLED(sbi) ((sbi)->s_dummy_enc_policy.policy != NULL)\n#else\n#define DUMMY_ENCRYPTION_ENABLED(sbi) (0)\n#endif\n\n/* Number of quota types we support */\n#define EXT4_MAXQUOTAS 3\n\n#define EXT4_ENC_UTF8_12_1\t1\n\n/*\n * fourth extended-fs super-block data in memory\n */\nstruct ext4_sb_info {\n\tunsigned long s_desc_size;\t/* Size of a group descriptor in bytes */\n\tunsigned long s_inodes_per_block;/* Number of inodes per block */\n\tunsigned long s_blocks_per_group;/* Number of blocks in a group */\n\tunsigned long s_clusters_per_group; /* Number of clusters in a group */\n\tunsigned long s_inodes_per_group;/* Number of inodes in a group */\n\tunsigned long s_itb_per_group;\t/* Number of inode table blocks per group */\n\tunsigned long s_gdb_count;\t/* Number of group descriptor blocks */\n\tunsigned long s_desc_per_block;\t/* Number of group descriptors per block */\n\text4_group_t s_groups_count;\t/* Number of groups in the fs */\n\text4_group_t s_blockfile_groups;/* Groups acceptable for non-extent files */\n\tunsigned long s_overhead;  /* # of fs overhead clusters */\n\tunsigned int s_cluster_ratio;\t/* Number of blocks per cluster */\n\tunsigned int s_cluster_bits;\t/* log2 of s_cluster_ratio */\n\tloff_t s_bitmap_maxbytes;\t/* max bytes for bitmap files */\n\tstruct buffer_head * s_sbh;\t/* Buffer containing the super block */\n\tstruct ext4_super_block *s_es;\t/* Pointer to the super block in the buffer */\n\tstruct buffer_head * __rcu *s_group_desc;\n\tunsigned int s_mount_opt;\n\tunsigned int s_mount_opt2;\n\tunsigned long s_mount_flags;\n\tunsigned int s_def_mount_opt;\n\text4_fsblk_t s_sb_block;\n\tatomic64_t s_resv_clusters;\n\tkuid_t s_resuid;\n\tkgid_t s_resgid;\n\tunsigned short s_mount_state;\n\tunsigned short s_pad;\n\tint s_addr_per_block_bits;\n\tint s_desc_per_block_bits;\n\tint s_inode_size;\n\tint s_first_ino;\n\tunsigned int s_inode_readahead_blks;\n\tunsigned int s_inode_goal;\n\tu32 s_hash_seed[4];\n\tint s_def_hash_version;\n\tint s_hash_unsigned;\t/* 3 if hash should be signed, 0 if not */\n\tstruct percpu_counter s_freeclusters_counter;\n\tstruct percpu_counter s_freeinodes_counter;\n\tstruct percpu_counter s_dirs_counter;\n\tstruct percpu_counter s_dirtyclusters_counter;\n\tstruct blockgroup_lock *s_blockgroup_lock;\n\tstruct proc_dir_entry *s_proc;\n\tstruct kobject s_kobj;\n\tstruct completion s_kobj_unregister;\n\tstruct super_block *s_sb;\n\n\t/* Journaling */\n\tstruct journal_s *s_journal;\n\tstruct list_head s_orphan;\n\tstruct mutex s_orphan_lock;\n\tunsigned long s_ext4_flags;\t\t/* Ext4 superblock flags */\n\tunsigned long s_commit_interval;\n\tu32 s_max_batch_time;\n\tu32 s_min_batch_time;\n\tstruct block_device *s_journal_bdev;\n#ifdef CONFIG_QUOTA\n\t/* Names of quota files with journalled quota */\n\tchar __rcu *s_qf_names[EXT4_MAXQUOTAS];\n\tint s_jquota_fmt;\t\t\t/* Format of quota to use */\n#endif\n\tunsigned int s_want_extra_isize; /* New inodes should reserve # bytes */\n\tstruct ext4_system_blocks __rcu *s_system_blks;\n\n#ifdef EXTENTS_STATS\n\t/* ext4 extents stats */\n\tunsigned long s_ext_min;\n\tunsigned long s_ext_max;\n\tunsigned long s_depth_max;\n\tspinlock_t s_ext_stats_lock;\n\tunsigned long s_ext_blocks;\n\tunsigned long s_ext_extents;\n#endif\n\n\t/* for buddy allocator */\n\tstruct ext4_group_info ** __rcu *s_group_info;\n\tstruct inode *s_buddy_cache;\n\tspinlock_t s_md_lock;\n\tunsigned short *s_mb_offsets;\n\tunsigned int *s_mb_maxs;\n\tunsigned int s_group_info_size;\n\tunsigned int s_mb_free_pending;\n\tstruct list_head s_freed_data_list;\t/* List of blocks to be freed\n\t\t\t\t\t\t   after commit completed */\n\n\t/* tunables */\n\tunsigned long s_stripe;\n\tunsigned int s_mb_stream_request;\n\tunsigned int s_mb_max_to_scan;\n\tunsigned int s_mb_min_to_scan;\n\tunsigned int s_mb_stats;\n\tunsigned int s_mb_order2_reqs;\n\tunsigned int s_mb_group_prealloc;\n\tunsigned int s_mb_max_inode_prealloc;\n\tunsigned int s_max_dir_size_kb;\n\t/* where last allocation was done - for stream allocation */\n\tunsigned long s_mb_last_group;\n\tunsigned long s_mb_last_start;\n\tunsigned int s_mb_prefetch;\n\tunsigned int s_mb_prefetch_limit;\n\n\t/* stats for buddy allocator */\n\tatomic_t s_bal_reqs;\t/* number of reqs with len > 1 */\n\tatomic_t s_bal_success;\t/* we found long enough chunks */\n\tatomic_t s_bal_allocated;\t/* in blocks */\n\tatomic_t s_bal_ex_scanned;\t/* total extents scanned */\n\tatomic_t s_bal_goals;\t/* goal hits */\n\tatomic_t s_bal_breaks;\t/* too long searches */\n\tatomic_t s_bal_2orders;\t/* 2^order hits */\n\tspinlock_t s_bal_lock;\n\tunsigned long s_mb_buddies_generated;\n\tunsigned long long s_mb_generation_time;\n\tatomic_t s_mb_lost_chunks;\n\tatomic_t s_mb_preallocated;\n\tatomic_t s_mb_discarded;\n\tatomic_t s_lock_busy;\n\n\t/* locality groups */\n\tstruct ext4_locality_group __percpu *s_locality_groups;\n\n\t/* for write statistics */\n\tunsigned long s_sectors_written_start;\n\tu64 s_kbytes_written;\n\n\t/* the size of zero-out chunk */\n\tunsigned int s_extent_max_zeroout_kb;\n\n\tunsigned int s_log_groups_per_flex;\n\tstruct flex_groups * __rcu *s_flex_groups;\n\text4_group_t s_flex_groups_allocated;\n\n\t/* workqueue for reserved extent conversions (buffered io) */\n\tstruct workqueue_struct *rsv_conversion_wq;\n\n\t/* timer for periodic error stats printing */\n\tstruct timer_list s_err_report;\n\n\t/* Lazy inode table initialization info */\n\tstruct ext4_li_request *s_li_request;\n\t/* Wait multiplier for lazy initialization thread */\n\tunsigned int s_li_wait_mult;\n\n\t/* Kernel thread for multiple mount protection */\n\tstruct task_struct *s_mmp_tsk;\n\n\t/* record the last minlen when FITRIM is called. */\n\tatomic_t s_last_trim_minblks;\n\n\t/* Reference to checksum algorithm driver via cryptoapi */\n\tstruct crypto_shash *s_chksum_driver;\n\n\t/* Precomputed FS UUID checksum for seeding other checksums */\n\t__u32 s_csum_seed;\n\n\t/* Reclaim extents from extent status tree */\n\tstruct shrinker s_es_shrinker;\n\tstruct list_head s_es_list;\t/* List of inodes with reclaimable extents */\n\tlong s_es_nr_inode;\n\tstruct ext4_es_stats s_es_stats;\n\tstruct mb_cache *s_ea_block_cache;\n\tstruct mb_cache *s_ea_inode_cache;\n\tspinlock_t s_es_lock ____cacheline_aligned_in_smp;\n\n\t/* Ratelimit ext4 messages. */\n\tstruct ratelimit_state s_err_ratelimit_state;\n\tstruct ratelimit_state s_warning_ratelimit_state;\n\tstruct ratelimit_state s_msg_ratelimit_state;\n\tatomic_t s_warning_count;\n\tatomic_t s_msg_count;\n\n\t/* Encryption policy for '-o test_dummy_encryption' */\n\tstruct fscrypt_dummy_policy s_dummy_enc_policy;\n\n\t/*\n\t * Barrier between writepages ops and changing any inode's JOURNAL_DATA\n\t * or EXTENTS flag.\n\t */\n\tstruct percpu_rw_semaphore s_writepages_rwsem;\n\tstruct dax_device *s_daxdev;\n#ifdef CONFIG_EXT4_DEBUG\n\tunsigned long s_simulate_fail;\n#endif\n\t/* Record the errseq of the backing block device */\n\terrseq_t s_bdev_wb_err;\n\tspinlock_t s_bdev_wb_lock;\n\n\t/* Information about errors that happened during this mount */\n\tspinlock_t s_error_lock;\n\tint s_add_error_count;\n\tint s_first_error_code;\n\t__u32 s_first_error_line;\n\t__u32 s_first_error_ino;\n\t__u64 s_first_error_block;\n\tconst char *s_first_error_func;\n\ttime64_t s_first_error_time;\n\tint s_last_error_code;\n\t__u32 s_last_error_line;\n\t__u32 s_last_error_ino;\n\t__u64 s_last_error_block;\n\tconst char *s_last_error_func;\n\ttime64_t s_last_error_time;\n\t/*\n\t * If we are in a context where we cannot update error information in\n\t * the on-disk superblock, we queue this work to do it.\n\t */\n\tstruct work_struct s_error_work;\n\n\t/* Ext4 fast commit stuff */\n\tatomic_t s_fc_subtid;\n\tatomic_t s_fc_ineligible_updates;\n\t/*\n\t * After commit starts, the main queue gets locked, and the further\n\t * updates get added in the staging queue.\n\t */\n#define FC_Q_MAIN\t0\n#define FC_Q_STAGING\t1\n\tstruct list_head s_fc_q[2];\t/* Inodes staged for fast commit\n\t\t\t\t\t * that have data changes in them.\n\t\t\t\t\t */\n\tstruct list_head s_fc_dentry_q[2];\t/* directory entry updates */\n\tunsigned int s_fc_bytes;\n\t/*\n\t * Main fast commit lock. This lock protects accesses to the\n\t * following fields:\n\t * ei->i_fc_list, s_fc_dentry_q, s_fc_q, s_fc_bytes, s_fc_bh.\n\t */\n\tspinlock_t s_fc_lock;\n\tstruct buffer_head *s_fc_bh;\n\tstruct ext4_fc_stats s_fc_stats;\n\tu64 s_fc_avg_commit_time;\n#ifdef CONFIG_EXT4_DEBUG\n\tint s_fc_debug_max_replay;\n#endif\n\tstruct ext4_fc_replay_state s_fc_replay_state;\n};\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}\n\nstatic inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT4_ROOT_INO ||\n\t\t(ino >= EXT4_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));\n}\n\n/*\n * Returns: sbi->field[index]\n * Used to access an array element from the following sbi fields which require\n * rcu protection to avoid dereferencing an invalid pointer due to reassignment\n * - s_group_desc\n * - s_group_info\n * - s_flex_group\n */\n#define sbi_array_rcu_deref(sbi, field, index)\t\t\t\t   \\\n({\t\t\t\t\t\t\t\t\t   \\\n\ttypeof(*((sbi)->field)) _v;\t\t\t\t\t   \\\n\trcu_read_lock();\t\t\t\t\t\t   \\\n\t_v = ((typeof(_v)*)rcu_dereference((sbi)->field))[index];\t   \\\n\trcu_read_unlock();\t\t\t\t\t\t   \\\n\t_v;\t\t\t\t\t\t\t\t   \\\n})\n\n/*\n * run-time mount flags\n */\nenum {\n\tEXT4_MF_MNTDIR_SAMPLED,\n\tEXT4_MF_FS_ABORTED,\t/* Fatal error detected */\n\tEXT4_MF_FC_INELIGIBLE,\t/* Fast commit ineligible */\n\tEXT4_MF_FC_COMMITTING\t/* File system underoing a fast\n\t\t\t\t * commit.\n\t\t\t\t */\n};\n\nstatic inline void ext4_set_mount_flag(struct super_block *sb, int bit)\n{\n\tset_bit(bit, &EXT4_SB(sb)->s_mount_flags);\n}\n\nstatic inline void ext4_clear_mount_flag(struct super_block *sb, int bit)\n{\n\tclear_bit(bit, &EXT4_SB(sb)->s_mount_flags);\n}\n\nstatic inline int ext4_test_mount_flag(struct super_block *sb, int bit)\n{\n\treturn test_bit(bit, &EXT4_SB(sb)->s_mount_flags);\n}\n\n\n/*\n * Simulate_fail codes\n */\n#define EXT4_SIM_BBITMAP_EIO\t1\n#define EXT4_SIM_BBITMAP_CRC\t2\n#define EXT4_SIM_IBITMAP_EIO\t3\n#define EXT4_SIM_IBITMAP_CRC\t4\n#define EXT4_SIM_INODE_EIO\t5\n#define EXT4_SIM_INODE_CRC\t6\n#define EXT4_SIM_DIRBLOCK_EIO\t7\n#define EXT4_SIM_DIRBLOCK_CRC\t8\n\nstatic inline bool ext4_simulate_fail(struct super_block *sb,\n\t\t\t\t     unsigned long code)\n{\n#ifdef CONFIG_EXT4_DEBUG\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (unlikely(sbi->s_simulate_fail == code)) {\n\t\tsbi->s_simulate_fail = 0;\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic inline void ext4_simulate_fail_bh(struct super_block *sb,\n\t\t\t\t\t struct buffer_head *bh,\n\t\t\t\t\t unsigned long code)\n{\n\tif (!IS_ERR(bh) && ext4_simulate_fail(sb, code))\n\t\tclear_buffer_uptodate(bh);\n}\n\n/*\n * Error number codes for s_{first,last}_error_errno\n *\n * Linux errno numbers are architecture specific, so we need to translate\n * them into something which is architecture independent.   We don't define\n * codes for all errno's; just the ones which are most likely to be the cause\n * of an ext4_error() call.\n */\n#define EXT4_ERR_UNKNOWN\t 1\n#define EXT4_ERR_EIO\t\t 2\n#define EXT4_ERR_ENOMEM\t\t 3\n#define EXT4_ERR_EFSBADCRC\t 4\n#define EXT4_ERR_EFSCORRUPTED\t 5\n#define EXT4_ERR_ENOSPC\t\t 6\n#define EXT4_ERR_ENOKEY\t\t 7\n#define EXT4_ERR_EROFS\t\t 8\n#define EXT4_ERR_EFBIG\t\t 9\n#define EXT4_ERR_EEXIST\t\t10\n#define EXT4_ERR_ERANGE\t\t11\n#define EXT4_ERR_EOVERFLOW\t12\n#define EXT4_ERR_EBUSY\t\t13\n#define EXT4_ERR_ENOTDIR\t14\n#define EXT4_ERR_ENOTEMPTY\t15\n#define EXT4_ERR_ESHUTDOWN\t16\n#define EXT4_ERR_EFAULT\t\t17\n\n/*\n * Inode dynamic state flags\n */\nenum {\n\tEXT4_STATE_JDATA,\t\t/* journaled data exists */\n\tEXT4_STATE_NEW,\t\t\t/* inode is newly created */\n\tEXT4_STATE_XATTR,\t\t/* has in-inode xattrs */\n\tEXT4_STATE_NO_EXPAND,\t\t/* No space for expansion */\n\tEXT4_STATE_DA_ALLOC_CLOSE,\t/* Alloc DA blks on close */\n\tEXT4_STATE_EXT_MIGRATE,\t\t/* Inode is migrating */\n\tEXT4_STATE_NEWENTRY,\t\t/* File just added to dir */\n\tEXT4_STATE_MAY_INLINE_DATA,\t/* may have in-inode data */\n\tEXT4_STATE_EXT_PRECACHED,\t/* extents have been precached */\n\tEXT4_STATE_LUSTRE_EA_INODE,\t/* Lustre-style ea_inode */\n\tEXT4_STATE_VERITY_IN_PROGRESS,\t/* building fs-verity Merkle tree */\n\tEXT4_STATE_FC_COMMITTING,\t/* Fast commit ongoing */\n};\n\n#define EXT4_INODE_BIT_FNS(name, field, offset)\t\t\t\t\\\nstatic inline int ext4_test_inode_##name(struct inode *inode, int bit)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn test_bit(bit + (offset), &EXT4_I(inode)->i_##field);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void ext4_set_inode_##name(struct inode *inode, int bit)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tset_bit(bit + (offset), &EXT4_I(inode)->i_##field);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void ext4_clear_inode_##name(struct inode *inode, int bit) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tclear_bit(bit + (offset), &EXT4_I(inode)->i_##field);\t\t\\\n}\n\n/* Add these declarations here only so that these functions can be\n * found by name.  Otherwise, they are very hard to locate. */\nstatic inline int ext4_test_inode_flag(struct inode *inode, int bit);\nstatic inline void ext4_set_inode_flag(struct inode *inode, int bit);\nstatic inline void ext4_clear_inode_flag(struct inode *inode, int bit);\nEXT4_INODE_BIT_FNS(flag, flags, 0)\n\n/* Add these declarations here only so that these functions can be\n * found by name.  Otherwise, they are very hard to locate. */\nstatic inline int ext4_test_inode_state(struct inode *inode, int bit);\nstatic inline void ext4_set_inode_state(struct inode *inode, int bit);\nstatic inline void ext4_clear_inode_state(struct inode *inode, int bit);\n#if (BITS_PER_LONG < 64)\nEXT4_INODE_BIT_FNS(state, state_flags, 0)\n\nstatic inline void ext4_clear_state_flags(struct ext4_inode_info *ei)\n{\n\t(ei)->i_state_flags = 0;\n}\n#else\nEXT4_INODE_BIT_FNS(state, flags, 32)\n\nstatic inline void ext4_clear_state_flags(struct ext4_inode_info *ei)\n{\n\t/* We depend on the fact that callers will set i_flags */\n}\n#endif\n#else\n/* Assume that user mode programs are passing in an ext4fs superblock, not\n * a kernel struct super_block.  This will allow us to call the feature-test\n * macros from user land. */\n#define EXT4_SB(sb)\t(sb)\n#endif\n\nstatic inline bool ext4_verity_in_progress(struct inode *inode)\n{\n\treturn IS_ENABLED(CONFIG_FS_VERITY) &&\n\t       ext4_test_inode_state(inode, EXT4_STATE_VERITY_IN_PROGRESS);\n}\n\n#define NEXT_ORPHAN(inode) EXT4_I(inode)->i_dtime\n\n/*\n * Codes for operating systems\n */\n#define EXT4_OS_LINUX\t\t0\n#define EXT4_OS_HURD\t\t1\n#define EXT4_OS_MASIX\t\t2\n#define EXT4_OS_FREEBSD\t\t3\n#define EXT4_OS_LITES\t\t4\n\n/*\n * Revision levels\n */\n#define EXT4_GOOD_OLD_REV\t0\t/* The good old (original) format */\n#define EXT4_DYNAMIC_REV\t1\t/* V2 format w/ dynamic inode sizes */\n\n#define EXT4_MAX_SUPP_REV\tEXT4_DYNAMIC_REV\n\n#define EXT4_GOOD_OLD_INODE_SIZE 128\n\n#define EXT4_EXTRA_TIMESTAMP_MAX\t(((s64)1 << 34) - 1  + S32_MIN)\n#define EXT4_NON_EXTRA_TIMESTAMP_MAX\tS32_MAX\n#define EXT4_TIMESTAMP_MIN\t\tS32_MIN\n\n/*\n * Feature set definitions\n */\n\n#define EXT4_FEATURE_COMPAT_DIR_PREALLOC\t0x0001\n#define EXT4_FEATURE_COMPAT_IMAGIC_INODES\t0x0002\n#define EXT4_FEATURE_COMPAT_HAS_JOURNAL\t\t0x0004\n#define EXT4_FEATURE_COMPAT_EXT_ATTR\t\t0x0008\n#define EXT4_FEATURE_COMPAT_RESIZE_INODE\t0x0010\n#define EXT4_FEATURE_COMPAT_DIR_INDEX\t\t0x0020\n#define EXT4_FEATURE_COMPAT_SPARSE_SUPER2\t0x0200\n/*\n * The reason why \"FAST_COMMIT\" is a compat feature is that, FS becomes\n * incompatible only if fast commit blocks are present in the FS. Since we\n * clear the journal (and thus the fast commit blocks), we don't mark FS as\n * incompatible. We also have a JBD2 incompat feature, which gets set when\n * there are fast commit blocks present in the journal.\n */\n#define EXT4_FEATURE_COMPAT_FAST_COMMIT\t\t0x0400\n#define EXT4_FEATURE_COMPAT_STABLE_INODES\t0x0800\n\n#define EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER\t0x0001\n#define EXT4_FEATURE_RO_COMPAT_LARGE_FILE\t0x0002\n#define EXT4_FEATURE_RO_COMPAT_BTREE_DIR\t0x0004\n#define EXT4_FEATURE_RO_COMPAT_HUGE_FILE        0x0008\n#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010\n#define EXT4_FEATURE_RO_COMPAT_DIR_NLINK\t0x0020\n#define EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE\t0x0040\n#define EXT4_FEATURE_RO_COMPAT_QUOTA\t\t0x0100\n#define EXT4_FEATURE_RO_COMPAT_BIGALLOC\t\t0x0200\n/*\n * METADATA_CSUM also enables group descriptor checksums (GDT_CSUM).  When\n * METADATA_CSUM is set, group descriptor checksums use the same algorithm as\n * all other data structures' checksums.  However, the METADATA_CSUM and\n * GDT_CSUM bits are mutually exclusive.\n */\n#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400\n#define EXT4_FEATURE_RO_COMPAT_READONLY\t\t0x1000\n#define EXT4_FEATURE_RO_COMPAT_PROJECT\t\t0x2000\n#define EXT4_FEATURE_RO_COMPAT_VERITY\t\t0x8000\n\n#define EXT4_FEATURE_INCOMPAT_COMPRESSION\t0x0001\n#define EXT4_FEATURE_INCOMPAT_FILETYPE\t\t0x0002\n#define EXT4_FEATURE_INCOMPAT_RECOVER\t\t0x0004 /* Needs recovery */\n#define EXT4_FEATURE_INCOMPAT_JOURNAL_DEV\t0x0008 /* Journal device */\n#define EXT4_FEATURE_INCOMPAT_META_BG\t\t0x0010\n#define EXT4_FEATURE_INCOMPAT_EXTENTS\t\t0x0040 /* extents support */\n#define EXT4_FEATURE_INCOMPAT_64BIT\t\t0x0080\n#define EXT4_FEATURE_INCOMPAT_MMP               0x0100\n#define EXT4_FEATURE_INCOMPAT_FLEX_BG\t\t0x0200\n#define EXT4_FEATURE_INCOMPAT_EA_INODE\t\t0x0400 /* EA in inode */\n#define EXT4_FEATURE_INCOMPAT_DIRDATA\t\t0x1000 /* data in dirent */\n#define EXT4_FEATURE_INCOMPAT_CSUM_SEED\t\t0x2000\n#define EXT4_FEATURE_INCOMPAT_LARGEDIR\t\t0x4000 /* >2GB or 3-lvl htree */\n#define EXT4_FEATURE_INCOMPAT_INLINE_DATA\t0x8000 /* data in inode */\n#define EXT4_FEATURE_INCOMPAT_ENCRYPT\t\t0x10000\n#define EXT4_FEATURE_INCOMPAT_CASEFOLD\t\t0x20000\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\n\n#define EXT4_FEATURE_COMPAT_FUNCS(name, flagname) \\\nstatic inline bool ext4_has_feature_##name(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_compat & \\\n\t\tcpu_to_le32(EXT4_FEATURE_COMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void ext4_set_feature_##name(struct super_block *sb) \\\n{ \\\n\text4_update_dynamic_rev(sb); \\\n\tEXT4_SB(sb)->s_es->s_feature_compat |= \\\n\t\tcpu_to_le32(EXT4_FEATURE_COMPAT_##flagname); \\\n} \\\nstatic inline void ext4_clear_feature_##name(struct super_block *sb) \\\n{ \\\n\tEXT4_SB(sb)->s_es->s_feature_compat &= \\\n\t\t~cpu_to_le32(EXT4_FEATURE_COMPAT_##flagname); \\\n}\n\n#define EXT4_FEATURE_RO_COMPAT_FUNCS(name, flagname) \\\nstatic inline bool ext4_has_feature_##name(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_ro_compat & \\\n\t\tcpu_to_le32(EXT4_FEATURE_RO_COMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void ext4_set_feature_##name(struct super_block *sb) \\\n{ \\\n\text4_update_dynamic_rev(sb); \\\n\tEXT4_SB(sb)->s_es->s_feature_ro_compat |= \\\n\t\tcpu_to_le32(EXT4_FEATURE_RO_COMPAT_##flagname); \\\n} \\\nstatic inline void ext4_clear_feature_##name(struct super_block *sb) \\\n{ \\\n\tEXT4_SB(sb)->s_es->s_feature_ro_compat &= \\\n\t\t~cpu_to_le32(EXT4_FEATURE_RO_COMPAT_##flagname); \\\n}\n\n#define EXT4_FEATURE_INCOMPAT_FUNCS(name, flagname) \\\nstatic inline bool ext4_has_feature_##name(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_incompat & \\\n\t\tcpu_to_le32(EXT4_FEATURE_INCOMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void ext4_set_feature_##name(struct super_block *sb) \\\n{ \\\n\text4_update_dynamic_rev(sb); \\\n\tEXT4_SB(sb)->s_es->s_feature_incompat |= \\\n\t\tcpu_to_le32(EXT4_FEATURE_INCOMPAT_##flagname); \\\n} \\\nstatic inline void ext4_clear_feature_##name(struct super_block *sb) \\\n{ \\\n\tEXT4_SB(sb)->s_es->s_feature_incompat &= \\\n\t\t~cpu_to_le32(EXT4_FEATURE_INCOMPAT_##flagname); \\\n}\n\nEXT4_FEATURE_COMPAT_FUNCS(dir_prealloc,\t\tDIR_PREALLOC)\nEXT4_FEATURE_COMPAT_FUNCS(imagic_inodes,\tIMAGIC_INODES)\nEXT4_FEATURE_COMPAT_FUNCS(journal,\t\tHAS_JOURNAL)\nEXT4_FEATURE_COMPAT_FUNCS(xattr,\t\tEXT_ATTR)\nEXT4_FEATURE_COMPAT_FUNCS(resize_inode,\t\tRESIZE_INODE)\nEXT4_FEATURE_COMPAT_FUNCS(dir_index,\t\tDIR_INDEX)\nEXT4_FEATURE_COMPAT_FUNCS(sparse_super2,\tSPARSE_SUPER2)\nEXT4_FEATURE_COMPAT_FUNCS(fast_commit,\t\tFAST_COMMIT)\nEXT4_FEATURE_COMPAT_FUNCS(stable_inodes,\tSTABLE_INODES)\n\nEXT4_FEATURE_RO_COMPAT_FUNCS(sparse_super,\tSPARSE_SUPER)\nEXT4_FEATURE_RO_COMPAT_FUNCS(large_file,\tLARGE_FILE)\nEXT4_FEATURE_RO_COMPAT_FUNCS(btree_dir,\t\tBTREE_DIR)\nEXT4_FEATURE_RO_COMPAT_FUNCS(huge_file,\t\tHUGE_FILE)\nEXT4_FEATURE_RO_COMPAT_FUNCS(gdt_csum,\t\tGDT_CSUM)\nEXT4_FEATURE_RO_COMPAT_FUNCS(dir_nlink,\t\tDIR_NLINK)\nEXT4_FEATURE_RO_COMPAT_FUNCS(extra_isize,\tEXTRA_ISIZE)\nEXT4_FEATURE_RO_COMPAT_FUNCS(quota,\t\tQUOTA)\nEXT4_FEATURE_RO_COMPAT_FUNCS(bigalloc,\t\tBIGALLOC)\nEXT4_FEATURE_RO_COMPAT_FUNCS(metadata_csum,\tMETADATA_CSUM)\nEXT4_FEATURE_RO_COMPAT_FUNCS(readonly,\t\tREADONLY)\nEXT4_FEATURE_RO_COMPAT_FUNCS(project,\t\tPROJECT)\nEXT4_FEATURE_RO_COMPAT_FUNCS(verity,\t\tVERITY)\n\nEXT4_FEATURE_INCOMPAT_FUNCS(compression,\tCOMPRESSION)\nEXT4_FEATURE_INCOMPAT_FUNCS(filetype,\t\tFILETYPE)\nEXT4_FEATURE_INCOMPAT_FUNCS(journal_needs_recovery,\tRECOVER)\nEXT4_FEATURE_INCOMPAT_FUNCS(journal_dev,\tJOURNAL_DEV)\nEXT4_FEATURE_INCOMPAT_FUNCS(meta_bg,\t\tMETA_BG)\nEXT4_FEATURE_INCOMPAT_FUNCS(extents,\t\tEXTENTS)\nEXT4_FEATURE_INCOMPAT_FUNCS(64bit,\t\t64BIT)\nEXT4_FEATURE_INCOMPAT_FUNCS(mmp,\t\tMMP)\nEXT4_FEATURE_INCOMPAT_FUNCS(flex_bg,\t\tFLEX_BG)\nEXT4_FEATURE_INCOMPAT_FUNCS(ea_inode,\t\tEA_INODE)\nEXT4_FEATURE_INCOMPAT_FUNCS(dirdata,\t\tDIRDATA)\nEXT4_FEATURE_INCOMPAT_FUNCS(csum_seed,\t\tCSUM_SEED)\nEXT4_FEATURE_INCOMPAT_FUNCS(largedir,\t\tLARGEDIR)\nEXT4_FEATURE_INCOMPAT_FUNCS(inline_data,\tINLINE_DATA)\nEXT4_FEATURE_INCOMPAT_FUNCS(encrypt,\t\tENCRYPT)\nEXT4_FEATURE_INCOMPAT_FUNCS(casefold,\t\tCASEFOLD)\n\n#define EXT2_FEATURE_COMPAT_SUPP\tEXT4_FEATURE_COMPAT_EXT_ATTR\n#define EXT2_FEATURE_INCOMPAT_SUPP\t(EXT4_FEATURE_INCOMPAT_FILETYPE| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_META_BG)\n#define EXT2_FEATURE_RO_COMPAT_SUPP\t(EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_LARGE_FILE| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_BTREE_DIR)\n\n#define EXT3_FEATURE_COMPAT_SUPP\tEXT4_FEATURE_COMPAT_EXT_ATTR\n#define EXT3_FEATURE_INCOMPAT_SUPP\t(EXT4_FEATURE_INCOMPAT_FILETYPE| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_RECOVER| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_META_BG)\n#define EXT3_FEATURE_RO_COMPAT_SUPP\t(EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_LARGE_FILE| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_BTREE_DIR)\n\n#define EXT4_FEATURE_COMPAT_SUPP\tEXT4_FEATURE_COMPAT_EXT_ATTR\n#define EXT4_FEATURE_INCOMPAT_SUPP\t(EXT4_FEATURE_INCOMPAT_FILETYPE| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_RECOVER| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_META_BG| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_EXTENTS| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_64BIT| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_FLEX_BG| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_EA_INODE| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_MMP | \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_INLINE_DATA | \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_ENCRYPT | \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_CASEFOLD | \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_CSUM_SEED | \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_LARGEDIR)\n#define EXT4_FEATURE_RO_COMPAT_SUPP\t(EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_LARGE_FILE| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_GDT_CSUM| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_DIR_NLINK | \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE | \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_BTREE_DIR |\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_HUGE_FILE |\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_BIGALLOC |\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_METADATA_CSUM|\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_QUOTA |\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_PROJECT |\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_VERITY)\n\n#define EXTN_FEATURE_FUNCS(ver) \\\nstatic inline bool ext4_has_unknown_ext##ver##_compat_features(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_compat & \\\n\t\tcpu_to_le32(~EXT##ver##_FEATURE_COMPAT_SUPP)) != 0); \\\n} \\\nstatic inline bool ext4_has_unknown_ext##ver##_ro_compat_features(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_ro_compat & \\\n\t\tcpu_to_le32(~EXT##ver##_FEATURE_RO_COMPAT_SUPP)) != 0); \\\n} \\\nstatic inline bool ext4_has_unknown_ext##ver##_incompat_features(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_incompat & \\\n\t\tcpu_to_le32(~EXT##ver##_FEATURE_INCOMPAT_SUPP)) != 0); \\\n}\n\nEXTN_FEATURE_FUNCS(2)\nEXTN_FEATURE_FUNCS(3)\nEXTN_FEATURE_FUNCS(4)\n\nstatic inline bool ext4_has_compat_features(struct super_block *sb)\n{\n\treturn (EXT4_SB(sb)->s_es->s_feature_compat != 0);\n}\nstatic inline bool ext4_has_ro_compat_features(struct super_block *sb)\n{\n\treturn (EXT4_SB(sb)->s_es->s_feature_ro_compat != 0);\n}\nstatic inline bool ext4_has_incompat_features(struct super_block *sb)\n{\n\treturn (EXT4_SB(sb)->s_es->s_feature_incompat != 0);\n}\n\n/*\n * Superblock flags\n */\n#define EXT4_FLAGS_RESIZING\t0\n#define EXT4_FLAGS_SHUTDOWN\t1\n#define EXT4_FLAGS_BDEV_IS_DAX\t2\n\nstatic inline int ext4_forced_shutdown(struct ext4_sb_info *sbi)\n{\n\treturn test_bit(EXT4_FLAGS_SHUTDOWN, &sbi->s_ext4_flags);\n}\n\n\n/*\n * Default values for user and/or group using reserved blocks\n */\n#define\tEXT4_DEF_RESUID\t\t0\n#define\tEXT4_DEF_RESGID\t\t0\n\n/*\n * Default project ID\n */\n#define\tEXT4_DEF_PROJID\t\t0\n\n#define EXT4_DEF_INODE_READAHEAD_BLKS\t32\n\n/*\n * Default mount options\n */\n#define EXT4_DEFM_DEBUG\t\t0x0001\n#define EXT4_DEFM_BSDGROUPS\t0x0002\n#define EXT4_DEFM_XATTR_USER\t0x0004\n#define EXT4_DEFM_ACL\t\t0x0008\n#define EXT4_DEFM_UID16\t\t0x0010\n#define EXT4_DEFM_JMODE\t\t0x0060\n#define EXT4_DEFM_JMODE_DATA\t0x0020\n#define EXT4_DEFM_JMODE_ORDERED\t0x0040\n#define EXT4_DEFM_JMODE_WBACK\t0x0060\n#define EXT4_DEFM_NOBARRIER\t0x0100\n#define EXT4_DEFM_BLOCK_VALIDITY 0x0200\n#define EXT4_DEFM_DISCARD\t0x0400\n#define EXT4_DEFM_NODELALLOC\t0x0800\n\n/*\n * Default journal batch times\n */\n#define EXT4_DEF_MIN_BATCH_TIME\t0\n#define EXT4_DEF_MAX_BATCH_TIME\t15000 /* 15ms */\n\n/*\n * Minimum number of groups in a flexgroup before we separate out\n * directories into the first block group of a flexgroup\n */\n#define EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME\t4\n\n/*\n * Structure of a directory entry\n */\n#define EXT4_NAME_LEN 255\n\nstruct ext4_dir_entry {\n\t__le32\tinode;\t\t\t/* Inode number */\n\t__le16\trec_len;\t\t/* Directory entry length */\n\t__le16\tname_len;\t\t/* Name length */\n\tchar\tname[EXT4_NAME_LEN];\t/* File name */\n};\n\n/*\n * The new version of the directory entry.  Since EXT4 structures are\n * stored in intel byte order, and the name_len field could never be\n * bigger than 255 chars, it's safe to reclaim the extra byte for the\n * file_type field.\n */\nstruct ext4_dir_entry_2 {\n\t__le32\tinode;\t\t\t/* Inode number */\n\t__le16\trec_len;\t\t/* Directory entry length */\n\t__u8\tname_len;\t\t/* Name length */\n\t__u8\tfile_type;\t\t/* See file type macros EXT4_FT_* below */\n\tchar\tname[EXT4_NAME_LEN];\t/* File name */\n};\n\n/*\n * This is a bogus directory entry at the end of each leaf block that\n * records checksums.\n */\nstruct ext4_dir_entry_tail {\n\t__le32\tdet_reserved_zero1;\t/* Pretend to be unused */\n\t__le16\tdet_rec_len;\t\t/* 12 */\n\t__u8\tdet_reserved_zero2;\t/* Zero name length */\n\t__u8\tdet_reserved_ft;\t/* 0xDE, fake file type */\n\t__le32\tdet_checksum;\t\t/* crc32c(uuid+inum+dirblock) */\n};\n\n#define EXT4_DIRENT_TAIL(block, blocksize) \\\n\t((struct ext4_dir_entry_tail *)(((void *)(block)) + \\\n\t\t\t\t\t((blocksize) - \\\n\t\t\t\t\t sizeof(struct ext4_dir_entry_tail))))\n\n/*\n * Ext4 directory file types.  Only the low 3 bits are used.  The\n * other bits are reserved for now.\n */\n#define EXT4_FT_UNKNOWN\t\t0\n#define EXT4_FT_REG_FILE\t1\n#define EXT4_FT_DIR\t\t2\n#define EXT4_FT_CHRDEV\t\t3\n#define EXT4_FT_BLKDEV\t\t4\n#define EXT4_FT_FIFO\t\t5\n#define EXT4_FT_SOCK\t\t6\n#define EXT4_FT_SYMLINK\t\t7\n\n#define EXT4_FT_MAX\t\t8\n\n#define EXT4_FT_DIR_CSUM\t0xDE\n\n/*\n * EXT4_DIR_PAD defines the directory entries boundaries\n *\n * NOTE: It must be a multiple of 4\n */\n#define EXT4_DIR_PAD\t\t\t4\n#define EXT4_DIR_ROUND\t\t\t(EXT4_DIR_PAD - 1)\n#define EXT4_DIR_REC_LEN(name_len)\t(((name_len) + 8 + EXT4_DIR_ROUND) & \\\n\t\t\t\t\t ~EXT4_DIR_ROUND)\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\n/*\n * If we ever get support for fs block sizes > page_size, we'll need\n * to remove the #if statements in the next two functions...\n */\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}\n\nstatic inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}\n\n/*\n * Hash Tree Directory indexing\n * (c) Daniel Phillips, 2001\n */\n\n#define is_dx(dir) (ext4_has_feature_dir_index((dir)->i_sb) && \\\n\t\t    ext4_test_inode_flag((dir), EXT4_INODE_INDEX))\n#define EXT4_DIR_LINK_MAX(dir) unlikely((dir)->i_nlink >= EXT4_LINK_MAX && \\\n\t\t    !(ext4_has_feature_dir_nlink((dir)->i_sb) && is_dx(dir)))\n#define EXT4_DIR_LINK_EMPTY(dir) ((dir)->i_nlink == 2 || (dir)->i_nlink == 1)\n\n/* Legal values for the dx_root hash_version field: */\n\n#define DX_HASH_LEGACY\t\t\t0\n#define DX_HASH_HALF_MD4\t\t1\n#define DX_HASH_TEA\t\t\t2\n#define DX_HASH_LEGACY_UNSIGNED\t\t3\n#define DX_HASH_HALF_MD4_UNSIGNED\t4\n#define DX_HASH_TEA_UNSIGNED\t\t5\n\nstatic inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\t*(u32 *)desc.ctx = crc;\n\n\tBUG_ON(crypto_shash_update(&desc.shash, address, length));\n\n\treturn *(u32 *)desc.ctx;\n}\n\n#ifdef __KERNEL__\n\n/* hash info structure used by the directory hash */\nstruct dx_hash_info\n{\n\tu32\t\thash;\n\tu32\t\tminor_hash;\n\tint\t\thash_version;\n\tu32\t\t*seed;\n};\n\n\n/* 32 and 64 bit signed EOF for dx directories */\n#define EXT4_HTREE_EOF_32BIT   ((1UL  << (32 - 1)) - 1)\n#define EXT4_HTREE_EOF_64BIT   ((1ULL << (64 - 1)) - 1)\n\n\n/*\n * Control parameters used by ext4_htree_next_block\n */\n#define HASH_NB_ALWAYS\t\t1\n\nstruct ext4_filename {\n\tconst struct qstr *usr_fname;\n\tstruct fscrypt_str disk_name;\n\tstruct dx_hash_info hinfo;\n#ifdef CONFIG_FS_ENCRYPTION\n\tstruct fscrypt_str crypto_buf;\n#endif\n#ifdef CONFIG_UNICODE\n\tstruct fscrypt_str cf_name;\n#endif\n};\n\n#define fname_name(p) ((p)->disk_name.name)\n#define fname_len(p)  ((p)->disk_name.len)\n\n/*\n * Describe an inode's exact location on disk and in memory\n */\nstruct ext4_iloc\n{\n\tstruct buffer_head *bh;\n\tunsigned long offset;\n\text4_group_t block_group;\n};\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}\n\nstatic inline bool ext4_is_quota_file(struct inode *inode)\n{\n\treturn IS_NOQUOTA(inode) &&\n\t       !(EXT4_I(inode)->i_flags & EXT4_EA_INODE_FL);\n}\n\n/*\n * This structure is stuffed into the struct file's private_data field\n * for directories.  It is where we put information so that we can do\n * readdir operations in hash tree order.\n */\nstruct dir_private_info {\n\tstruct rb_root\troot;\n\tstruct rb_node\t*curr_node;\n\tstruct fname\t*extra_fname;\n\tloff_t\t\tlast_pos;\n\t__u32\t\tcurr_hash;\n\t__u32\t\tcurr_minor_hash;\n\t__u32\t\tnext_hash;\n};\n\n/* calculate the first block number of the group */\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}\n\n/*\n * Special error return code only used by dx_probe() and its callers.\n */\n#define ERR_BAD_DX_DIR\t(-(MAX_ERRNO - 1))\n\n/* htree levels for ext4 */\n#define\tEXT4_HTREE_LEVEL_COMPAT\t2\n#define\tEXT4_HTREE_LEVEL\t3\n\nstatic inline int ext4_dir_htree_level(struct super_block *sb)\n{\n\treturn ext4_has_feature_largedir(sb) ?\n\t\tEXT4_HTREE_LEVEL : EXT4_HTREE_LEVEL_COMPAT;\n}\n\n/*\n * Timeout and state flag for lazy initialization inode thread.\n */\n#define EXT4_DEF_LI_WAIT_MULT\t\t\t10\n#define EXT4_DEF_LI_MAX_START_DELAY\t\t5\n#define EXT4_LAZYINIT_QUIT\t\t\t0x0001\n#define EXT4_LAZYINIT_RUNNING\t\t\t0x0002\n\n/*\n * Lazy inode table initialization info\n */\nstruct ext4_lazy_init {\n\tunsigned long\t\tli_state;\n\tstruct list_head\tli_request_list;\n\tstruct mutex\t\tli_list_mtx;\n};\n\nenum ext4_li_mode {\n\tEXT4_LI_MODE_PREFETCH_BBITMAP,\n\tEXT4_LI_MODE_ITABLE,\n};\n\nstruct ext4_li_request {\n\tstruct super_block\t*lr_super;\n\tenum ext4_li_mode\tlr_mode;\n\text4_group_t\t\tlr_first_not_zeroed;\n\text4_group_t\t\tlr_next_group;\n\tstruct list_head\tlr_request;\n\tunsigned long\t\tlr_next_sched;\n\tunsigned long\t\tlr_timeout;\n};\n\nstruct ext4_features {\n\tstruct kobject f_kobj;\n\tstruct completion f_kobj_unregister;\n};\n\n/*\n * This structure will be used for multiple mount protection. It will be\n * written into the block number saved in the s_mmp_block field in the\n * superblock. Programs that check MMP should assume that if\n * SEQ_FSCK (or any unknown code above SEQ_MAX) is present then it is NOT safe\n * to use the filesystem, regardless of how old the timestamp is.\n */\n#define EXT4_MMP_MAGIC     0x004D4D50U /* ASCII for MMP */\n#define EXT4_MMP_SEQ_CLEAN 0xFF4D4D50U /* mmp_seq value for clean unmount */\n#define EXT4_MMP_SEQ_FSCK  0xE24D4D50U /* mmp_seq value when being fscked */\n#define EXT4_MMP_SEQ_MAX   0xE24D4D4FU /* maximum valid mmp_seq value */\n\nstruct mmp_struct {\n\t__le32\tmmp_magic;\t\t/* Magic number for MMP */\n\t__le32\tmmp_seq;\t\t/* Sequence no. updated periodically */\n\n\t/*\n\t * mmp_time, mmp_nodename & mmp_bdevname are only used for information\n\t * purposes and do not affect the correctness of the algorithm\n\t */\n\t__le64\tmmp_time;\t\t/* Time last updated */\n\tchar\tmmp_nodename[64];\t/* Node which last updated MMP block */\n\tchar\tmmp_bdevname[32];\t/* Bdev which last updated MMP block */\n\n\t/*\n\t * mmp_check_interval is used to verify if the MMP block has been\n\t * updated on the block device. The value is updated based on the\n\t * maximum time to write the MMP block during an update cycle.\n\t */\n\t__le16\tmmp_check_interval;\n\n\t__le16\tmmp_pad1;\n\t__le32\tmmp_pad2[226];\n\t__le32\tmmp_checksum;\t\t/* crc32c(uuid+mmp_block) */\n};\n\n/* arguments passed to the mmp thread */\nstruct mmpd_data {\n\tstruct buffer_head *bh; /* bh from initial read_mmp_block() */\n\tstruct super_block *sb;  /* super block of the fs */\n};\n\n/*\n * Check interval multiplier\n * The MMP block is written every update interval and initially checked every\n * update interval x the multiplier (the value is then adapted based on the\n * write latency). The reason is that writes can be delayed under load and we\n * don't want readers to incorrectly assume that the filesystem is no longer\n * in use.\n */\n#define EXT4_MMP_CHECK_MULT\t\t2UL\n\n/*\n * Minimum interval for MMP checking in seconds.\n */\n#define EXT4_MMP_MIN_CHECK_INTERVAL\t5UL\n\n/*\n * Maximum interval for MMP checking in seconds.\n */\n#define EXT4_MMP_MAX_CHECK_INTERVAL\t300UL\n\n/*\n * Function prototypes\n */\n\n/*\n * Ok, these declarations are also in <linux/kernel.h> but none of the\n * ext4 source programs needs to include it so they are duplicated here.\n */\n# define NORET_TYPE\t/**/\n# define ATTRIB_NORET\t__attribute__((noreturn))\n# define NORET_AND\tnoreturn,\n\n/* bitmap.c */\nextern unsigned int ext4_count_free(char *bitmap, unsigned numchars);\nvoid ext4_inode_bitmap_csum_set(struct super_block *sb, ext4_group_t group,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh, int sz);\nint ext4_inode_bitmap_csum_verify(struct super_block *sb, ext4_group_t group,\n\t\t\t\t  struct ext4_group_desc *gdp,\n\t\t\t\t  struct buffer_head *bh, int sz);\nvoid ext4_block_bitmap_csum_set(struct super_block *sb, ext4_group_t group,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh);\nint ext4_block_bitmap_csum_verify(struct super_block *sb, ext4_group_t group,\n\t\t\t\t  struct ext4_group_desc *gdp,\n\t\t\t\t  struct buffer_head *bh);\n\n/* balloc.c */\nextern void ext4_get_group_no_and_offset(struct super_block *sb,\n\t\t\t\t\t ext4_fsblk_t blocknr,\n\t\t\t\t\t ext4_group_t *blockgrpp,\n\t\t\t\t\t ext4_grpblk_t *offsetp);\nextern ext4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t\t  ext4_fsblk_t block);\n\nextern unsigned int ext4_block_group(struct super_block *sb,\n\t\t\text4_fsblk_t blocknr);\nextern ext4_grpblk_t ext4_block_group_offset(struct super_block *sb,\n\t\t\text4_fsblk_t blocknr);\nextern int ext4_bg_has_super(struct super_block *sb, ext4_group_t group);\nextern unsigned long ext4_bg_num_gdb(struct super_block *sb,\n\t\t\text4_group_t group);\nextern ext4_fsblk_t ext4_new_meta_blocks(handle_t *handle, struct inode *inode,\n\t\t\t\t\t ext4_fsblk_t goal,\n\t\t\t\t\t unsigned int flags,\n\t\t\t\t\t unsigned long *count,\n\t\t\t\t\t int *errp);\nextern int ext4_claim_free_clusters(struct ext4_sb_info *sbi,\n\t\t\t\t    s64 nclusters, unsigned int flags);\nextern ext4_fsblk_t ext4_count_free_clusters(struct super_block *);\nextern void ext4_check_blocks_bitmap(struct super_block *);\nextern struct ext4_group_desc * ext4_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);\nextern int ext4_should_retry_alloc(struct super_block *sb, int *retries);\n\nextern struct buffer_head *ext4_read_block_bitmap_nowait(struct super_block *sb,\n\t\t\t\t\t\text4_group_t block_group,\n\t\t\t\t\t\tbool ignore_locked);\nextern int ext4_wait_block_bitmap(struct super_block *sb,\n\t\t\t\t  ext4_group_t block_group,\n\t\t\t\t  struct buffer_head *bh);\nextern struct buffer_head *ext4_read_block_bitmap(struct super_block *sb,\n\t\t\t\t\t\t  ext4_group_t block_group);\nextern unsigned ext4_free_clusters_after_init(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t block_group,\n\t\t\t\t\t      struct ext4_group_desc *gdp);\next4_fsblk_t ext4_inode_to_goal_block(struct inode *);\n\n#ifdef CONFIG_UNICODE\nextern void ext4_fname_setup_ci_filename(struct inode *dir,\n\t\t\t\t\t const struct qstr *iname,\n\t\t\t\t\t struct fscrypt_str *fname);\n#endif\n\n#ifdef CONFIG_FS_ENCRYPTION\nstatic inline void ext4_fname_from_fscrypt_name(struct ext4_filename *dst,\n\t\t\t\t\t\tconst struct fscrypt_name *src)\n{\n\tmemset(dst, 0, sizeof(*dst));\n\n\tdst->usr_fname = src->usr_fname;\n\tdst->disk_name = src->disk_name;\n\tdst->hinfo.hash = src->hash;\n\tdst->hinfo.minor_hash = src->minor_hash;\n\tdst->crypto_buf = src->crypto_buf;\n}\n\nstatic inline int ext4_fname_setup_filename(struct inode *dir,\n\t\t\t\t\t    const struct qstr *iname,\n\t\t\t\t\t    int lookup,\n\t\t\t\t\t    struct ext4_filename *fname)\n{\n\tstruct fscrypt_name name;\n\tint err;\n\n\terr = fscrypt_setup_filename(dir, iname, lookup, &name);\n\tif (err)\n\t\treturn err;\n\n\text4_fname_from_fscrypt_name(fname, &name);\n\n#ifdef CONFIG_UNICODE\n\text4_fname_setup_ci_filename(dir, iname, &fname->cf_name);\n#endif\n\treturn 0;\n}\n\nstatic inline int ext4_fname_prepare_lookup(struct inode *dir,\n\t\t\t\t\t    struct dentry *dentry,\n\t\t\t\t\t    struct ext4_filename *fname)\n{\n\tstruct fscrypt_name name;\n\tint err;\n\n\terr = fscrypt_prepare_lookup(dir, dentry, &name);\n\tif (err)\n\t\treturn err;\n\n\text4_fname_from_fscrypt_name(fname, &name);\n\n#ifdef CONFIG_UNICODE\n\text4_fname_setup_ci_filename(dir, &dentry->d_name, &fname->cf_name);\n#endif\n\treturn 0;\n}\n\nstatic inline void ext4_fname_free_filename(struct ext4_filename *fname)\n{\n\tstruct fscrypt_name name;\n\n\tname.crypto_buf = fname->crypto_buf;\n\tfscrypt_free_filename(&name);\n\n\tfname->crypto_buf.name = NULL;\n\tfname->usr_fname = NULL;\n\tfname->disk_name.name = NULL;\n\n#ifdef CONFIG_UNICODE\n\tkfree(fname->cf_name.name);\n\tfname->cf_name.name = NULL;\n#endif\n}\n#else /* !CONFIG_FS_ENCRYPTION */\nstatic inline int ext4_fname_setup_filename(struct inode *dir,\n\t\t\t\t\t    const struct qstr *iname,\n\t\t\t\t\t    int lookup,\n\t\t\t\t\t    struct ext4_filename *fname)\n{\n\tfname->usr_fname = iname;\n\tfname->disk_name.name = (unsigned char *) iname->name;\n\tfname->disk_name.len = iname->len;\n\n#ifdef CONFIG_UNICODE\n\text4_fname_setup_ci_filename(dir, iname, &fname->cf_name);\n#endif\n\n\treturn 0;\n}\n\nstatic inline int ext4_fname_prepare_lookup(struct inode *dir,\n\t\t\t\t\t    struct dentry *dentry,\n\t\t\t\t\t    struct ext4_filename *fname)\n{\n\treturn ext4_fname_setup_filename(dir, &dentry->d_name, 1, fname);\n}\n\nstatic inline void ext4_fname_free_filename(struct ext4_filename *fname)\n{\n#ifdef CONFIG_UNICODE\n\tkfree(fname->cf_name.name);\n\tfname->cf_name.name = NULL;\n#endif\n}\n#endif /* !CONFIG_FS_ENCRYPTION */\n\n/* dir.c */\nextern int __ext4_check_dir_entry(const char *, unsigned int, struct inode *,\n\t\t\t\t  struct file *,\n\t\t\t\t  struct ext4_dir_entry_2 *,\n\t\t\t\t  struct buffer_head *, char *, int,\n\t\t\t\t  unsigned int);\n#define ext4_check_dir_entry(dir, filp, de, bh, buf, size, offset)\t\\\n\tunlikely(__ext4_check_dir_entry(__func__, __LINE__, (dir), (filp), \\\n\t\t\t\t\t(de), (bh), (buf), (size), (offset)))\nextern int ext4_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t\t__u32 minor_hash,\n\t\t\t\tstruct ext4_dir_entry_2 *dirent,\n\t\t\t\tstruct fscrypt_str *ent_name);\nextern void ext4_htree_free_dir_info(struct dir_private_info *p);\nextern int ext4_find_dest_de(struct inode *dir, struct inode *inode,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     void *buf, int buf_size,\n\t\t\t     struct ext4_filename *fname,\n\t\t\t     struct ext4_dir_entry_2 **dest_de);\nvoid ext4_insert_dentry(struct inode *inode,\n\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\tint buf_size,\n\t\t\tstruct ext4_filename *fname);\nstatic inline void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!ext4_has_feature_dir_index(inode->i_sb) &&\n\t    ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) {\n\t\t/* ext4_iget() should have caught this... */\n\t\tWARN_ON_ONCE(ext4_has_feature_metadata_csum(inode->i_sb));\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n\t}\n}\nstatic const unsigned char ext4_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};\n\nstatic inline  unsigned char get_dtype(struct super_block *sb, int filetype)\n{\n\tif (!ext4_has_feature_filetype(sb) || filetype >= EXT4_FT_MAX)\n\t\treturn DT_UNKNOWN;\n\n\treturn ext4_filetype_table[filetype];\n}\nextern int ext4_check_all_de(struct inode *dir, struct buffer_head *bh,\n\t\t\t     void *buf, int buf_size);\n\n/* fsync.c */\nextern int ext4_sync_file(struct file *, loff_t, loff_t, int);\n\n/* hash.c */\nextern int ext4fs_dirhash(const struct inode *dir, const char *name, int len,\n\t\t\t  struct dx_hash_info *hinfo);\n\n/* ialloc.c */\nextern int ext4_mark_inode_used(struct super_block *sb, int ino);\nextern struct inode *__ext4_new_inode(handle_t *, struct inode *, umode_t,\n\t\t\t\t      const struct qstr *qstr, __u32 goal,\n\t\t\t\t      uid_t *owner, __u32 i_flags,\n\t\t\t\t      int handle_type, unsigned int line_no,\n\t\t\t\t      int nblocks);\n\n#define ext4_new_inode(handle, dir, mode, qstr, goal, owner, i_flags) \\\n\t__ext4_new_inode((handle), (dir), (mode), (qstr), (goal), (owner), \\\n\t\t\t i_flags, 0, 0, 0)\n#define ext4_new_inode_start_handle(dir, mode, qstr, goal, owner, \\\n\t\t\t\t    type, nblocks)\t\t    \\\n\t__ext4_new_inode(NULL, (dir), (mode), (qstr), (goal), (owner), \\\n\t\t\t 0, (type), __LINE__, (nblocks))\n\n\nextern void ext4_free_inode(handle_t *, struct inode *);\nextern struct inode * ext4_orphan_get(struct super_block *, unsigned long);\nextern unsigned long ext4_count_free_inodes(struct super_block *);\nextern unsigned long ext4_count_dirs(struct super_block *);\nextern void ext4_check_inodes_bitmap(struct super_block *);\nextern void ext4_mark_bitmap_end(int start_bit, int end_bit, char *bitmap);\nextern int ext4_init_inode_table(struct super_block *sb,\n\t\t\t\t ext4_group_t group, int barrier);\nextern void ext4_end_bitmap_read(struct buffer_head *bh, int uptodate);\n\n/* fast_commit.c */\nint ext4_fc_info_show(struct seq_file *seq, void *v);\nvoid ext4_fc_init(struct super_block *sb, journal_t *journal);\nvoid ext4_fc_init_inode(struct inode *inode);\nvoid ext4_fc_track_range(handle_t *handle, struct inode *inode, ext4_lblk_t start,\n\t\t\t ext4_lblk_t end);\nvoid __ext4_fc_track_unlink(handle_t *handle, struct inode *inode,\n\tstruct dentry *dentry);\nvoid __ext4_fc_track_link(handle_t *handle, struct inode *inode,\n\tstruct dentry *dentry);\nvoid ext4_fc_track_unlink(handle_t *handle, struct dentry *dentry);\nvoid ext4_fc_track_link(handle_t *handle, struct dentry *dentry);\nvoid ext4_fc_track_create(handle_t *handle, struct dentry *dentry);\nvoid ext4_fc_track_inode(handle_t *handle, struct inode *inode);\nvoid ext4_fc_mark_ineligible(struct super_block *sb, int reason);\nvoid ext4_fc_start_ineligible(struct super_block *sb, int reason);\nvoid ext4_fc_stop_ineligible(struct super_block *sb);\nvoid ext4_fc_start_update(struct inode *inode);\nvoid ext4_fc_stop_update(struct inode *inode);\nvoid ext4_fc_del(struct inode *inode);\nbool ext4_fc_replay_check_excluded(struct super_block *sb, ext4_fsblk_t block);\nvoid ext4_fc_replay_cleanup(struct super_block *sb);\nint ext4_fc_commit(journal_t *journal, tid_t commit_tid);\nint __init ext4_fc_init_dentry_cache(void);\n\n/* mballoc.c */\nextern const struct seq_operations ext4_mb_seq_groups_ops;\nextern long ext4_mb_stats;\nextern long ext4_mb_max_to_scan;\nextern int ext4_mb_init(struct super_block *);\nextern int ext4_mb_release(struct super_block *);\nextern ext4_fsblk_t ext4_mb_new_blocks(handle_t *,\n\t\t\t\tstruct ext4_allocation_request *, int *);\nextern int ext4_mb_reserve_blocks(struct super_block *, int);\nextern void ext4_discard_preallocations(struct inode *, unsigned int);\nextern int __init ext4_init_mballoc(void);\nextern void ext4_exit_mballoc(void);\nextern ext4_group_t ext4_mb_prefetch(struct super_block *sb,\n\t\t\t\t     ext4_group_t group,\n\t\t\t\t     unsigned int nr, int *cnt);\nextern void ext4_mb_prefetch_fini(struct super_block *sb, ext4_group_t group,\n\t\t\t\t  unsigned int nr);\n\nextern void ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\t     struct buffer_head *bh, ext4_fsblk_t block,\n\t\t\t     unsigned long count, int flags);\nextern int ext4_mb_alloc_groupinfo(struct super_block *sb,\n\t\t\t\t   ext4_group_t ngroups);\nextern int ext4_mb_add_groupinfo(struct super_block *sb,\n\t\text4_group_t i, struct ext4_group_desc *desc);\nextern int ext4_group_add_blocks(handle_t *handle, struct super_block *sb,\n\t\t\t\text4_fsblk_t block, unsigned long count);\nextern int ext4_trim_fs(struct super_block *, struct fstrim_range *);\nextern void ext4_process_freed_data(struct super_block *sb, tid_t commit_tid);\nextern void ext4_mb_mark_bb(struct super_block *sb, ext4_fsblk_t block,\n\t\t       int len, int state);\n\n/* inode.c */\nvoid ext4_inode_csum_set(struct inode *inode, struct ext4_inode *raw,\n\t\t\t struct ext4_inode_info *ei);\nint ext4_inode_is_fast_symlink(struct inode *inode);\nstruct buffer_head *ext4_getblk(handle_t *, struct inode *, ext4_lblk_t, int);\nstruct buffer_head *ext4_bread(handle_t *, struct inode *, ext4_lblk_t, int);\nint ext4_bread_batch(struct inode *inode, ext4_lblk_t block, int bh_count,\n\t\t     bool wait, struct buffer_head **bhs);\nint ext4_get_block_unwritten(struct inode *inode, sector_t iblock,\n\t\t\t     struct buffer_head *bh_result, int create);\nint ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\nint ext4_da_get_block_prep(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int create);\nint ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh));\nint do_journal_get_write_access(handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n#define FALL_BACK_TO_NONDELALLOC 1\n#define CONVERT_INLINE_DATA\t 2\n\ntypedef enum {\n\tEXT4_IGET_NORMAL =\t0,\n\tEXT4_IGET_SPECIAL =\t0x0001, /* OK to iget a system inode */\n\tEXT4_IGET_HANDLE = \t0x0002\t/* Inode # is from a handle */\n} ext4_iget_flags;\n\nextern struct inode *__ext4_iget(struct super_block *sb, unsigned long ino,\n\t\t\t\t ext4_iget_flags flags, const char *function,\n\t\t\t\t unsigned int line);\n\n#define ext4_iget(sb, ino, flags) \\\n\t__ext4_iget((sb), (ino), (flags), __func__, __LINE__)\n\nextern int  ext4_write_inode(struct inode *, struct writeback_control *);\nextern int  ext4_setattr(struct dentry *, struct iattr *);\nextern int  ext4_getattr(const struct path *, struct kstat *, u32, unsigned int);\nextern void ext4_evict_inode(struct inode *);\nextern void ext4_clear_inode(struct inode *);\nextern int  ext4_file_getattr(const struct path *, struct kstat *, u32, unsigned int);\nextern int  ext4_sync_inode(handle_t *, struct inode *);\nextern void ext4_dirty_inode(struct inode *, int);\nextern int ext4_change_inode_journal_flag(struct inode *, int);\nextern int ext4_get_inode_loc(struct inode *, struct ext4_iloc *);\nextern int ext4_get_fc_inode_loc(struct super_block *sb, unsigned long ino,\n\t\t\t  struct ext4_iloc *iloc);\nextern int ext4_inode_attach_jinode(struct inode *inode);\nextern int ext4_can_truncate(struct inode *inode);\nextern int ext4_truncate(struct inode *);\nextern int ext4_break_layouts(struct inode *);\nextern int ext4_punch_hole(struct inode *inode, loff_t offset, loff_t length);\nextern void ext4_set_inode_flags(struct inode *, bool init);\nextern int ext4_alloc_da_blocks(struct inode *inode);\nextern void ext4_set_aops(struct inode *inode);\nextern int ext4_writepage_trans_blocks(struct inode *);\nextern int ext4_chunk_trans_blocks(struct inode *, int nrblocks);\nextern int ext4_zero_partial_blocks(handle_t *handle, struct inode *inode,\n\t\t\t     loff_t lstart, loff_t lend);\nextern vm_fault_t ext4_page_mkwrite(struct vm_fault *vmf);\nextern vm_fault_t ext4_filemap_fault(struct vm_fault *vmf);\nextern qsize_t *ext4_get_reserved_space(struct inode *inode);\nextern int ext4_get_projid(struct inode *inode, kprojid_t *projid);\nextern void ext4_da_release_space(struct inode *inode, int to_free);\nextern void ext4_da_update_reserve_space(struct inode *inode,\n\t\t\t\t\tint used, int quota_claim);\nextern int ext4_issue_zeroout(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_fsblk_t pblk, ext4_lblk_t len);\n\n/* indirect.c */\nextern int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_map_blocks *map, int flags);\nextern int ext4_ind_trans_blocks(struct inode *inode, int nrblocks);\nextern void ext4_ind_truncate(handle_t *, struct inode *inode);\nextern int ext4_ind_remove_space(handle_t *handle, struct inode *inode,\n\t\t\t\t ext4_lblk_t start, ext4_lblk_t end);\n\n/* ioctl.c */\nextern long ext4_ioctl(struct file *, unsigned int, unsigned long);\nextern long ext4_compat_ioctl(struct file *, unsigned int, unsigned long);\nextern void ext4_reset_inode_seed(struct inode *inode);\n\n/* migrate.c */\nextern int ext4_ext_migrate(struct inode *);\nextern int ext4_ind_migrate(struct inode *inode);\n\n/* namei.c */\nextern int ext4_init_new_dir(handle_t *handle, struct inode *dir,\n\t\t\t     struct inode *inode);\nextern int ext4_dirblock_csum_verify(struct inode *inode,\n\t\t\t\t     struct buffer_head *bh);\nextern int ext4_orphan_add(handle_t *, struct inode *);\nextern int ext4_orphan_del(handle_t *, struct inode *);\nextern int ext4_htree_fill_tree(struct file *dir_file, __u32 start_hash,\n\t\t\t\t__u32 start_minor_hash, __u32 *next_hash);\nextern int ext4_search_dir(struct buffer_head *bh,\n\t\t\t   char *search_buf,\n\t\t\t   int buf_size,\n\t\t\t   struct inode *dir,\n\t\t\t   struct ext4_filename *fname,\n\t\t\t   unsigned int offset,\n\t\t\t   struct ext4_dir_entry_2 **res_dir);\nextern int ext4_generic_delete_entry(struct inode *dir,\n\t\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     void *entry_buf,\n\t\t\t\t     int buf_size,\n\t\t\t\t     int csum_size);\nextern bool ext4_empty_dir(struct inode *inode);\n\n/* resize.c */\nextern void ext4_kvfree_array_rcu(void *to_free);\nextern int ext4_group_add(struct super_block *sb,\n\t\t\t\tstruct ext4_new_group_data *input);\nextern int ext4_group_extend(struct super_block *sb,\n\t\t\t\tstruct ext4_super_block *es,\n\t\t\t\text4_fsblk_t n_blocks_count);\nextern int ext4_resize_fs(struct super_block *sb, ext4_fsblk_t n_blocks_count);\n\n/* super.c */\nextern struct buffer_head *ext4_sb_bread(struct super_block *sb,\n\t\t\t\t\t sector_t block, int op_flags);\nextern struct buffer_head *ext4_sb_bread_unmovable(struct super_block *sb,\n\t\t\t\t\t\t   sector_t block);\nextern void ext4_read_bh_nowait(struct buffer_head *bh, int op_flags,\n\t\t\t\tbh_end_io_t *end_io);\nextern int ext4_read_bh(struct buffer_head *bh, int op_flags,\n\t\t\tbh_end_io_t *end_io);\nextern int ext4_read_bh_lock(struct buffer_head *bh, int op_flags, bool wait);\nextern void ext4_sb_breadahead_unmovable(struct super_block *sb, sector_t block);\nextern int ext4_seq_options_show(struct seq_file *seq, void *offset);\nextern int ext4_calculate_overhead(struct super_block *sb);\nextern void ext4_superblock_csum_set(struct super_block *sb);\nextern int ext4_alloc_flex_bg_array(struct super_block *sb,\n\t\t\t\t    ext4_group_t ngroup);\nextern const char *ext4_decode_error(struct super_block *sb, int errno,\n\t\t\t\t     char nbuf[16]);\nextern void ext4_mark_group_bitmap_corrupted(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     unsigned int flags);\n\nextern __printf(7, 8)\nvoid __ext4_error(struct super_block *, const char *, unsigned int, bool,\n\t\t  int, __u64, const char *, ...);\nextern __printf(6, 7)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int,\n\t\t\text4_fsblk_t, int, const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning_inode(const struct inode *inode, const char *function,\n\t\t\t  unsigned int line, const char *fmt, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#define EXT4_ERROR_INODE(inode, fmt, a...) \\\n\text4_error_inode((inode), __func__, __LINE__, 0, (fmt), ## a)\n\n#define EXT4_ERROR_INODE_ERR(inode, err, fmt, a...)\t\t\t\\\n\t__ext4_error_inode((inode), __func__, __LINE__, 0, (err), (fmt), ## a)\n\n#define ext4_error_inode_block(inode, block, err, fmt, a...)\t\t\\\n\t__ext4_error_inode((inode), __func__, __LINE__, (block), (err),\t\\\n\t\t\t   (fmt), ## a)\n\n#define EXT4_ERROR_FILE(file, block, fmt, a...)\t\t\t\t\\\n\text4_error_file((file), __func__, __LINE__, (block), (fmt), ## a)\n\n#define ext4_abort(sb, err, fmt, a...)\t\t\t\t\t\\\n\t__ext4_error((sb), __func__, __LINE__, true, (err), 0, (fmt), ## a)\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, 0, fmt, ##__VA_ARGS__)\n#define ext4_error_inode_err(inode, func, line, block, err, fmt, ...)\t\\\n\t__ext4_error_inode((inode), (func), (line), (block), \t\t\\\n\t\t\t   (err), (fmt), ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error((sb), __func__, __LINE__, false, 0, 0, (fmt),\t\\\n\t\t##__VA_ARGS__)\n#define ext4_error_err(sb, err, fmt, ...)\t\t\t\t\\\n\t__ext4_error((sb), __func__, __LINE__, false, (err), 0, (fmt),\t\\\n\t\t##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning_inode(inode, fmt, ...)\t\t\t\t\\\n\t__ext4_warning_inode(inode, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, 0, \" \");\t\t\\\n} while (0)\n#define ext4_error_inode_err(inode, func, line, block, err, fmt, ...)\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, err, \" \");\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, false, 0, 0, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_err(sb, err, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, false, err, 0, \" \");\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning_inode(inode, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning_inode(inode, \"\", 0, \" \");\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(ext4_has_feature_metadata_csum(sb) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn ext4_has_feature_metadata_csum(sb) &&\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn ext4_has_feature_gdt_csum(sb) || ext4_has_metadata_csum(sb);\n}\n\n#define ext4_read_incompat_64bit_val(es, name) \\\n\t(((es)->s_feature_incompat & cpu_to_le32(EXT4_FEATURE_INCOMPAT_64BIT) \\\n\t\t? (ext4_fsblk_t)le32_to_cpu(es->name##_hi) << 32 : 0) | \\\n\t\tle32_to_cpu(es->name##_lo))\n\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ext4_read_incompat_64bit_val(es, s_blocks_count);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ext4_read_incompat_64bit_val(es, s_r_blocks_count);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ext4_read_incompat_64bit_val(es, s_free_blocks_count);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct super_block *sb,\n\t\t\t\tstruct ext4_inode *raw_inode)\n{\n\tif (ext4_has_feature_largedir(sb) ||\n\t    S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\n\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info **grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t grp_info = sbi_array_rcu_deref(EXT4_SB(sb), s_group_info, indexv);\n\t return grp_info[indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !inode_is_locked(inode));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tWRITE_ONCE(EXT4_I(inode)->i_disksize, newsize);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nint ext4_update_disksize_before_punch(struct inode *inode, loff_t offset,\n\t\t\t\t      loff_t len);\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n#ifdef AGGRESSIVE_CHECK\n\tunsigned long\tbb_check_counter;\n#endif\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT\t\t\\\n\t(1 << EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT)\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT\t\t\\\n\t(1 << EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT)\n#define EXT4_GROUP_INFO_BBITMAP_READ_BIT\t4\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_TEST_AND_SET_READ(grp)\t\\\n\t(test_and_set_bit(EXT4_GROUP_INFO_BBITMAP_READ_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}\n\n/*\n * Returns true if the filesystem is busy enough that attempts to\n * access the block group locks has run into contention.\n */\nstatic inline int ext4_fs_is_busy(struct ext4_sb_info *sbi)\n{\n\treturn (atomic_read(&sbi->s_lock_busy) > EXT4_CONTENTION_THRESHOLD);\n}\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}\n\n#ifdef CONFIG_QUOTA\nstatic inline bool ext4_quota_capable(struct super_block *sb)\n{\n\treturn (test_opt(sb, QUOTA) || ext4_has_feature_quota(sb));\n}\n\nstatic inline bool ext4_is_quota_journalled(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\treturn (ext4_has_feature_quota(sb) ||\n\t\tsbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]);\n}\n#endif\n\n/*\n * Block validity checking\n */\n#define ext4_check_indirect_blockref(inode, bh)\t\t\t\t\\\n\text4_check_blockref(__func__, __LINE__, inode,\t\t\t\\\n\t\t\t    (__le32 *)(bh)->b_data,\t\t\t\\\n\t\t\t    EXT4_ADDR_PER_BLOCK((inode)->i_sb))\n\n#define ext4_ind_check_inode(inode)\t\t\t\t\t\\\n\text4_check_blockref(__func__, __LINE__, inode,\t\t\t\\\n\t\t\t    EXT4_I(inode)->i_data,\t\t\t\\\n\t\t\t    EXT4_NDIR_BLOCKS)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext4_dir_operations;\n\n/* file.c */\nextern const struct inode_operations ext4_file_inode_operations;\nextern const struct file_operations ext4_file_operations;\nextern loff_t ext4_llseek(struct file *file, loff_t offset, int origin);\n\n/* inline.c */\nextern int ext4_get_max_inline_size(struct inode *inode);\nextern int ext4_find_inline_data_nolock(struct inode *inode);\nextern int ext4_init_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t unsigned int len);\nextern int ext4_destroy_inline_data(handle_t *handle, struct inode *inode);\n\nextern int ext4_readpage_inline(struct inode *inode, struct page *page);\nextern int ext4_try_to_write_inline_data(struct address_space *mapping,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t loff_t pos, unsigned len,\n\t\t\t\t\t unsigned flags,\n\t\t\t\t\t struct page **pagep);\nextern int ext4_write_inline_data_end(struct inode *inode,\n\t\t\t\t      loff_t pos, unsigned len,\n\t\t\t\t      unsigned copied,\n\t\t\t\t      struct page *page);\nextern struct buffer_head *\next4_journalled_write_inline_data(struct inode *inode,\n\t\t\t\t  unsigned len,\n\t\t\t\t  struct page *page);\nextern int ext4_da_write_inline_data_begin(struct address_space *mapping,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   loff_t pos, unsigned len,\n\t\t\t\t\t   unsigned flags,\n\t\t\t\t\t   struct page **pagep,\n\t\t\t\t\t   void **fsdata);\nextern int ext4_da_write_inline_data_end(struct inode *inode, loff_t pos,\n\t\t\t\t\t unsigned len, unsigned copied,\n\t\t\t\t\t struct page *page);\nextern int ext4_try_add_inline_entry(handle_t *handle,\n\t\t\t\t     struct ext4_filename *fname,\n\t\t\t\t     struct inode *dir, struct inode *inode);\nextern int ext4_try_create_inline_dir(handle_t *handle,\n\t\t\t\t      struct inode *parent,\n\t\t\t\t      struct inode *inode);\nextern int ext4_read_inline_dir(struct file *filp,\n\t\t\t\tstruct dir_context *ctx,\n\t\t\t\tint *has_inline_data);\nextern int ext4_inlinedir_to_tree(struct file *dir_file,\n\t\t\t\t  struct inode *dir, ext4_lblk_t block,\n\t\t\t\t  struct dx_hash_info *hinfo,\n\t\t\t\t  __u32 start_hash, __u32 start_minor_hash,\n\t\t\t\t  int *has_inline_data);\nextern struct buffer_head *ext4_find_inline_entry(struct inode *dir,\n\t\t\t\t\tstruct ext4_filename *fname,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *has_inline_data);\nextern int ext4_delete_inline_entry(handle_t *handle,\n\t\t\t\t    struct inode *dir,\n\t\t\t\t    struct ext4_dir_entry_2 *de_del,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    int *has_inline_data);\nextern bool empty_inline_dir(struct inode *dir, int *has_inline_data);\nextern struct buffer_head *ext4_get_first_inline_block(struct inode *inode,\n\t\t\t\t\tstruct ext4_dir_entry_2 **parent_de,\n\t\t\t\t\tint *retval);\nextern int ext4_inline_data_fiemap(struct inode *inode,\n\t\t\t\t   struct fiemap_extent_info *fieinfo,\n\t\t\t\t   int *has_inline, __u64 start, __u64 len);\n\nstruct iomap;\nextern int ext4_inline_data_iomap(struct inode *inode, struct iomap *iomap);\n\nextern int ext4_inline_data_truncate(struct inode *inode, int *has_inline);\n\nextern int ext4_convert_inline_data(struct inode *inode);\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}\n\n/* namei.c */\nextern const struct inode_operations ext4_dir_inode_operations;\nextern const struct inode_operations ext4_special_inode_operations;\nextern struct dentry *ext4_get_parent(struct dentry *child);\nextern struct ext4_dir_entry_2 *ext4_init_dot_dotdot(struct inode *inode,\n\t\t\t\t struct ext4_dir_entry_2 *de,\n\t\t\t\t int blocksize, int csum_size,\n\t\t\t\t unsigned int parent_ino, int dotdot_real_len);\nextern void ext4_initialize_dirent_tail(struct buffer_head *bh,\n\t\t\t\t\tunsigned int blocksize);\nextern int ext4_handle_dirty_dirblock(handle_t *handle, struct inode *inode,\n\t\t\t\t      struct buffer_head *bh);\nextern int ext4_ci_compare(const struct inode *parent,\n\t\t\t   const struct qstr *fname,\n\t\t\t   const struct qstr *entry, bool quick);\nextern int __ext4_unlink(handle_t *handle, struct inode *dir, const struct qstr *d_name,\n\t\t\t struct inode *inode);\nextern int __ext4_link(struct inode *dir, struct inode *inode,\n\t\t       struct dentry *dentry);\n\n#define S_SHIFT 12\nstatic const unsigned char ext4_type_by_mode[(S_IFMT >> S_SHIFT) + 1] = {\n\t[S_IFREG >> S_SHIFT]\t= EXT4_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= EXT4_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= EXT4_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= EXT4_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= EXT4_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= EXT4_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= EXT4_FT_SYMLINK,\n};\n\nstatic inline void ext4_set_de_type(struct super_block *sb,\n\t\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\t\tumode_t mode) {\n\tif (ext4_has_feature_filetype(sb))\n\t\tde->file_type = ext4_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}\n\n/* readpages.c */\nextern int ext4_mpage_readpages(struct inode *inode,\n\t\tstruct readahead_control *rac, struct page *page);\nextern int __init ext4_init_post_read_processing(void);\nextern void ext4_exit_post_read_processing(void);\n\n/* symlink.c */\nextern const struct inode_operations ext4_encrypted_symlink_inode_operations;\nextern const struct inode_operations ext4_symlink_inode_operations;\nextern const struct inode_operations ext4_fast_symlink_inode_operations;\n\n/* sysfs.c */\nextern int ext4_register_sysfs(struct super_block *sb);\nextern void ext4_unregister_sysfs(struct super_block *sb);\nextern int __init ext4_init_sysfs(void);\nextern void ext4_exit_sysfs(void);\n\n/* block_validity */\nextern void ext4_release_system_zone(struct super_block *sb);\nextern int ext4_setup_system_zone(struct super_block *sb);\nextern int __init ext4_init_system_zone(void);\nextern void ext4_exit_system_zone(void);\nextern int ext4_inode_block_valid(struct inode *inode,\n\t\t\t\t  ext4_fsblk_t start_blk,\n\t\t\t\t  unsigned int count);\nextern int ext4_check_blockref(const char *, unsigned int,\n\t\t\t       struct inode *, __le32 *, unsigned int);\n\n/* extents.c */\nstruct ext4_ext_path;\nstruct ext4_extent;\n\n/*\n * Maximum number of logical blocks in a file; ext4_extent's ee_block is\n * __le32.\n */\n#define EXT_MAX_BLOCKS\t0xffffffff\n\nextern void ext4_ext_tree_init(handle_t *handle, struct inode *inode);\nextern int ext4_ext_index_trans_blocks(struct inode *inode, int extents);\nextern int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\t       struct ext4_map_blocks *map, int flags);\nextern int ext4_ext_truncate(handle_t *, struct inode *);\nextern int ext4_ext_remove_space(struct inode *inode, ext4_lblk_t start,\n\t\t\t\t ext4_lblk_t end);\nextern void ext4_ext_init(struct super_block *);\nextern void ext4_ext_release(struct super_block *);\nextern long ext4_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\t  loff_t len);\nextern int ext4_convert_unwritten_extents(handle_t *handle, struct inode *inode,\n\t\t\t\t\t  loff_t offset, ssize_t len);\nextern int ext4_convert_unwritten_io_end_vec(handle_t *handle,\n\t\t\t\t\t     ext4_io_end_t *io_end);\nextern int ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\t   struct ext4_map_blocks *map, int flags);\nextern int ext4_ext_calc_credits_for_single_extent(struct inode *inode,\n\t\t\t\t\t\t   int num,\n\t\t\t\t\t\t   struct ext4_ext_path *path);\nextern int ext4_ext_insert_extent(handle_t *, struct inode *,\n\t\t\t\t  struct ext4_ext_path **,\n\t\t\t\t  struct ext4_extent *, int);\nextern struct ext4_ext_path *ext4_find_extent(struct inode *, ext4_lblk_t,\n\t\t\t\t\t      struct ext4_ext_path **,\n\t\t\t\t\t      int flags);\nextern void ext4_ext_drop_refs(struct ext4_ext_path *);\nextern int ext4_ext_check_inode(struct inode *inode);\nextern ext4_lblk_t ext4_ext_next_allocated_block(struct ext4_ext_path *path);\nextern int ext4_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t\t__u64 start, __u64 len);\nextern int ext4_get_es_cache(struct inode *inode,\n\t\t\t     struct fiemap_extent_info *fieinfo,\n\t\t\t     __u64 start, __u64 len);\nextern int ext4_ext_precache(struct inode *inode);\nextern int ext4_swap_extents(handle_t *handle, struct inode *inode1,\n\t\t\t\tstruct inode *inode2, ext4_lblk_t lblk1,\n\t\t\t     ext4_lblk_t lblk2,  ext4_lblk_t count,\n\t\t\t     int mark_unwritten,int *err);\nextern int ext4_clu_mapped(struct inode *inode, ext4_lblk_t lclu);\nextern int ext4_datasem_ensure_credits(handle_t *handle, struct inode *inode,\n\t\t\t\t       int check_cred, int restart_cred,\n\t\t\t\t       int revoke_cred);\nextern void ext4_ext_replay_shrink_inode(struct inode *inode, ext4_lblk_t end);\nextern int ext4_ext_replay_set_iblocks(struct inode *inode);\nextern int ext4_ext_replay_update_ex(struct inode *inode, ext4_lblk_t start,\n\t\tint len, int unwritten, ext4_fsblk_t pblk);\nextern int ext4_ext_clear_bb(struct inode *inode);\n\n\n/* move_extent.c */\nextern void ext4_double_down_write_data_sem(struct inode *first,\n\t\t\t\t\t    struct inode *second);\nextern void ext4_double_up_write_data_sem(struct inode *orig_inode,\n\t\t\t\t\t  struct inode *donor_inode);\nextern int ext4_move_extents(struct file *o_filp, struct file *d_filp,\n\t\t\t     __u64 start_orig, __u64 start_donor,\n\t\t\t     __u64 len, __u64 *moved_len);\n\n/* page-io.c */\nextern int __init ext4_init_pageio(void);\nextern void ext4_exit_pageio(void);\nextern ext4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags);\nextern ext4_io_end_t *ext4_get_io_end(ext4_io_end_t *io_end);\nextern int ext4_put_io_end(ext4_io_end_t *io_end);\nextern void ext4_put_io_end_defer(ext4_io_end_t *io_end);\nextern void ext4_io_submit_init(struct ext4_io_submit *io,\n\t\t\t\tstruct writeback_control *wbc);\nextern void ext4_end_io_rsv_work(struct work_struct *work);\nextern void ext4_io_submit(struct ext4_io_submit *io);\nextern int ext4_bio_write_page(struct ext4_io_submit *io,\n\t\t\t       struct page *page,\n\t\t\t       int len,\n\t\t\t       bool keep_towrite);\nextern struct ext4_io_end_vec *ext4_alloc_io_end_vec(ext4_io_end_t *io_end);\nextern struct ext4_io_end_vec *ext4_last_io_end_vec(ext4_io_end_t *io_end);\n\n/* mmp.c */\nextern int ext4_multi_mount_protect(struct super_block *, ext4_fsblk_t);\n\n/* verity.c */\nextern const struct fsverity_operations ext4_verityops;\n\n/*\n * Add new method to test whether block and inode bitmaps are properly\n * initialized. With uninit_bg reading the block from disk is not enough\n * to mark the bitmap uptodate. We need to also zero-out the bitmap\n */\n#define BH_BITMAP_UPTODATE BH_JBDPrivateStart\n\nstatic inline int bitmap_uptodate(struct buffer_head *bh)\n{\n\treturn (buffer_uptodate(bh) &&\n\t\t\ttest_bit(BH_BITMAP_UPTODATE, &(bh)->b_state));\n}\nstatic inline void set_bitmap_uptodate(struct buffer_head *bh)\n{\n\tset_bit(BH_BITMAP_UPTODATE, &(bh)->b_state);\n}\n\n#define in_range(b, first, len)\t((b) >= (first) && (b) <= (first) + (len) - 1)\n\n/* For ioend & aio unwritten conversion wait queues */\n#define EXT4_WQ_HASH_SZ\t\t37\n#define ext4_ioend_wq(v)   (&ext4__ioend_wq[((unsigned long)(v)) %\\\n\t\t\t\t\t    EXT4_WQ_HASH_SZ])\nextern wait_queue_head_t ext4__ioend_wq[EXT4_WQ_HASH_SZ];\n\nextern int ext4_resize_begin(struct super_block *sb);\nextern void ext4_resize_end(struct super_block *sb);\n\nstatic inline void ext4_set_io_unwritten_flag(struct inode *inode,\n\t\t\t\t\t      struct ext4_io_end *io_end)\n{\n\tif (!(io_end->flag & EXT4_IO_END_UNWRITTEN)) {\n\t\tio_end->flag |= EXT4_IO_END_UNWRITTEN;\n\t\tatomic_inc(&EXT4_I(inode)->i_unwritten);\n\t}\n}\n\nstatic inline void ext4_clear_io_unwritten_flag(ext4_io_end_t *io_end)\n{\n\tstruct inode *inode = io_end->inode;\n\n\tif (io_end->flag & EXT4_IO_END_UNWRITTEN) {\n\t\tio_end->flag &= ~EXT4_IO_END_UNWRITTEN;\n\t\t/* Wake up anyone waiting on unwritten extent conversion */\n\t\tif (atomic_dec_and_test(&EXT4_I(inode)->i_unwritten))\n\t\t\twake_up_all(ext4_ioend_wq(inode));\n\t}\n}\n\nextern const struct iomap_ops ext4_iomap_ops;\nextern const struct iomap_ops ext4_iomap_overwrite_ops;\nextern const struct iomap_ops ext4_iomap_report_ops;\n\nstatic inline int ext4_buffer_uptodate(struct buffer_head *bh)\n{\n\t/*\n\t * If the buffer has the write error flag, we have failed\n\t * to write out data in the block.  In this  case, we don't\n\t * have to read the block because we may read the old data\n\t * successfully.\n\t */\n\tif (!buffer_uptodate(bh) && buffer_write_io_error(bh))\n\t\tset_buffer_uptodate(bh);\n\treturn buffer_uptodate(bh);\n}\n\n#endif\t/* __KERNEL__ */\n\n#define EFSBADCRC\tEBADMSG\t\t/* Bad CRC detected */\n#define EFSCORRUPTED\tEUCLEAN\t\t/* Filesystem is corrupted */\n\n#endif\t/* _EXT4_H */\n"}, "4": {"id": 4, "path": "/src/include/linux/err.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_ERR_H\n#define _LINUX_ERR_H\n\n#include <linux/compiler.h>\n#include <linux/types.h>\n\n#include <asm/errno.h>\n\n/*\n * Kernel pointers have redundant information, so we can use a\n * scheme where we can return either an error code or a normal\n * pointer with the same return value.\n *\n * This should be a per-architecture thing, to allow different\n * error and pointer decisions.\n */\n#define MAX_ERRNO\t4095\n\n#ifndef __ASSEMBLY__\n\n#define IS_ERR_VALUE(x) unlikely((unsigned long)(void *)(x) >= (unsigned long)-MAX_ERRNO)\n\nstatic inline void * __must_check ERR_PTR(long error)\n{\n\treturn (void *) error;\n}\n\nstatic inline long __must_check PTR_ERR(__force const void *ptr)\n{\n\treturn (long) ptr;\n}\n\nstatic inline bool __must_check IS_ERR(__force const void *ptr)\n{\n\treturn IS_ERR_VALUE((unsigned long)ptr);\n}\n\nstatic inline bool __must_check IS_ERR_OR_NULL(__force const void *ptr)\n{\n\treturn unlikely(!ptr) || IS_ERR_VALUE((unsigned long)ptr);\n}\n\n/**\n * ERR_CAST - Explicitly cast an error-valued pointer to another pointer type\n * @ptr: The pointer to cast.\n *\n * Explicitly cast an error-valued pointer to another pointer type in such a\n * way as to make it clear that's what's going on.\n */\nstatic inline void * __must_check ERR_CAST(__force const void *ptr)\n{\n\t/* cast away the const */\n\treturn (void *) ptr;\n}\n\nstatic inline int __must_check PTR_ERR_OR_ZERO(__force const void *ptr)\n{\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\telse\n\t\treturn 0;\n}\n\n#endif\n\n#endif /* _LINUX_ERR_H */\n"}, "5": {"id": 5, "path": "/src/include/linux/compiler.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_H\n#define __LINUX_COMPILER_H\n\n#include <linux/compiler_types.h>\n\n#ifndef __ASSEMBLY__\n\n#ifdef __KERNEL__\n\n/*\n * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code\n * to disable branch tracing on a per file basis.\n */\n#if defined(CONFIG_TRACE_BRANCH_PROFILING) \\\n    && !defined(DISABLE_BRANCH_PROFILING) && !defined(__CHECKER__)\nvoid ftrace_likely_update(struct ftrace_likely_data *f, int val,\n\t\t\t  int expect, int is_constant);\n\n#define likely_notrace(x)\t__builtin_expect(!!(x), 1)\n#define unlikely_notrace(x)\t__builtin_expect(!!(x), 0)\n\n#define __branch_check__(x, expect, is_constant) ({\t\t\t\\\n\t\t\tlong ______r;\t\t\t\t\t\\\n\t\t\tstatic struct ftrace_likely_data\t\t\\\n\t\t\t\t__aligned(4)\t\t\t\t\\\n\t\t\t\t__section(\"_ftrace_annotated_branch\")\t\\\n\t\t\t\t______f = {\t\t\t\t\\\n\t\t\t\t.data.func = __func__,\t\t\t\\\n\t\t\t\t.data.file = __FILE__,\t\t\t\\\n\t\t\t\t.data.line = __LINE__,\t\t\t\\\n\t\t\t};\t\t\t\t\t\t\\\n\t\t\t______r = __builtin_expect(!!(x), expect);\t\\\n\t\t\tftrace_likely_update(&______f, ______r,\t\t\\\n\t\t\t\t\t     expect, is_constant);\t\\\n\t\t\t______r;\t\t\t\t\t\\\n\t\t})\n\n/*\n * Using __builtin_constant_p(x) to ignore cases where the return\n * value is always the same.  This idea is taken from a similar patch\n * written by Daniel Walker.\n */\n# ifndef likely\n#  define likely(x)\t(__branch_check__(x, 1, __builtin_constant_p(x)))\n# endif\n# ifndef unlikely\n#  define unlikely(x)\t(__branch_check__(x, 0, __builtin_constant_p(x)))\n# endif\n\n#ifdef CONFIG_PROFILE_ALL_BRANCHES\n/*\n * \"Define 'is'\", Bill Clinton\n * \"Define 'if'\", Steven Rostedt\n */\n#define if(cond, ...) if ( __trace_if_var( !!(cond , ## __VA_ARGS__) ) )\n\n#define __trace_if_var(cond) (__builtin_constant_p(cond) ? (cond) : __trace_if_value(cond))\n\n#define __trace_if_value(cond) ({\t\t\t\\\n\tstatic struct ftrace_branch_data\t\t\\\n\t\t__aligned(4)\t\t\t\t\\\n\t\t__section(\"_ftrace_branch\")\t\t\\\n\t\t__if_trace = {\t\t\t\t\\\n\t\t\t.func = __func__,\t\t\\\n\t\t\t.file = __FILE__,\t\t\\\n\t\t\t.line = __LINE__,\t\t\\\n\t\t};\t\t\t\t\t\\\n\t(cond) ?\t\t\t\t\t\\\n\t\t(__if_trace.miss_hit[1]++,1) :\t\t\\\n\t\t(__if_trace.miss_hit[0]++,0);\t\t\\\n})\n\n#endif /* CONFIG_PROFILE_ALL_BRANCHES */\n\n#else\n# define likely(x)\t__builtin_expect(!!(x), 1)\n# define unlikely(x)\t__builtin_expect(!!(x), 0)\n#endif\n\n/* Optimization barrier */\n#ifndef barrier\n/* The \"volatile\" is due to gcc bugs */\n# define barrier() __asm__ __volatile__(\"\": : :\"memory\")\n#endif\n\n#ifndef barrier_data\n/*\n * This version is i.e. to prevent dead stores elimination on @ptr\n * where gcc and llvm may behave differently when otherwise using\n * normal barrier(): while gcc behavior gets along with a normal\n * barrier(), llvm needs an explicit input variable to be assumed\n * clobbered. The issue is as follows: while the inline asm might\n * access any memory it wants, the compiler could have fit all of\n * @ptr into memory registers instead, and since @ptr never escaped\n * from that, it proved that the inline asm wasn't touching any of\n * it. This version works well with both compilers, i.e. we're telling\n * the compiler that the inline asm absolutely may see the contents\n * of @ptr. See also: https://llvm.org/bugs/show_bug.cgi?id=15495\n */\n# define barrier_data(ptr) __asm__ __volatile__(\"\": :\"r\"(ptr) :\"memory\")\n#endif\n\n/* workaround for GCC PR82365 if needed */\n#ifndef barrier_before_unreachable\n# define barrier_before_unreachable() do { } while (0)\n#endif\n\n/* Unreachable code */\n#ifdef CONFIG_STACK_VALIDATION\n/*\n * These macros help objtool understand GCC code flow for unreachable code.\n * The __COUNTER__ based labels are a hack to make each instance of the macros\n * unique, to convince GCC not to merge duplicate inline asm statements.\n */\n#define annotate_reachable() ({\t\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.reachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define annotate_unreachable() ({\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.unreachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define ASM_UNREACHABLE\t\t\t\t\t\t\t\\\n\t\"999:\\n\\t\"\t\t\t\t\t\t\t\\\n\t\".pushsection .discard.unreachable\\n\\t\"\t\t\t\t\\\n\t\".long 999b - .\\n\\t\"\t\t\t\t\t\t\\\n\t\".popsection\\n\\t\"\n\n/* Annotate a C jump table to allow objtool to follow the code flow */\n#define __annotate_jump_table __section(\".rodata..c_jump_table\")\n\n#else\n#define annotate_reachable()\n#define annotate_unreachable()\n#define __annotate_jump_table\n#endif\n\n#ifndef ASM_UNREACHABLE\n# define ASM_UNREACHABLE\n#endif\n#ifndef unreachable\n# define unreachable() do {\t\t\\\n\tannotate_unreachable();\t\t\\\n\t__builtin_unreachable();\t\\\n} while (0)\n#endif\n\n/*\n * KENTRY - kernel entry point\n * This can be used to annotate symbols (functions or data) that are used\n * without their linker symbol being referenced explicitly. For example,\n * interrupt vector handlers, or functions in the kernel image that are found\n * programatically.\n *\n * Not required for symbols exported with EXPORT_SYMBOL, or initcalls. Those\n * are handled in their own way (with KEEP() in linker scripts).\n *\n * KENTRY can be avoided if the symbols in question are marked as KEEP() in the\n * linker script. For example an architecture could KEEP() its entire\n * boot/exception vector code rather than annotate each function and data.\n */\n#ifndef KENTRY\n# define KENTRY(sym)\t\t\t\t\t\t\\\n\textern typeof(sym) sym;\t\t\t\t\t\\\n\tstatic const unsigned long __kentry_##sym\t\t\\\n\t__used\t\t\t\t\t\t\t\\\n\t__attribute__((__section__(\"___kentry+\" #sym)))\t\t\\\n\t= (unsigned long)&sym;\n#endif\n\n#ifndef RELOC_HIDE\n# define RELOC_HIDE(ptr, off)\t\t\t\t\t\\\n  ({ unsigned long __ptr;\t\t\t\t\t\\\n     __ptr = (unsigned long) (ptr);\t\t\t\t\\\n    (typeof(ptr)) (__ptr + (off)); })\n#endif\n\n#ifndef OPTIMIZER_HIDE_VAR\n/* Make the optimizer believe the variable can be manipulated arbitrarily. */\n#define OPTIMIZER_HIDE_VAR(var)\t\t\t\t\t\t\\\n\t__asm__ (\"\" : \"=r\" (var) : \"0\" (var))\n#endif\n\n/* Not-quite-unique ID. */\n#ifndef __UNIQUE_ID\n# define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)\n#endif\n\n/**\n * data_race - mark an expression as containing intentional data races\n *\n * This data_race() macro is useful for situations in which data races\n * should be forgiven.  One example is diagnostic code that accesses\n * shared variables but is not a part of the core synchronization design.\n *\n * This macro *does not* affect normal code generation, but is a hint\n * to tooling that data races here are to be ignored.\n */\n#define data_race(expr)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__unqual_scalar_typeof(({ expr; })) __v = ({\t\t\t\\\n\t\t__kcsan_disable_current();\t\t\t\t\\\n\t\texpr;\t\t\t\t\t\t\t\\\n\t});\t\t\t\t\t\t\t\t\\\n\t__kcsan_enable_current();\t\t\t\t\t\\\n\t__v;\t\t\t\t\t\t\t\t\\\n})\n\n#endif /* __KERNEL__ */\n\n/*\n * Force the compiler to emit 'sym' as a symbol, so that we can reference\n * it from inline assembler. Necessary in case 'sym' could be inlined\n * otherwise, or eliminated entirely due to lack of references that are\n * visible to the compiler.\n */\n#define __ADDRESSABLE(sym) \\\n\tstatic void * __section(\".discard.addressable\") __used \\\n\t\t__UNIQUE_ID(__PASTE(__addressable_,sym)) = (void *)&sym;\n\n/**\n * offset_to_ptr - convert a relative memory offset to an absolute pointer\n * @off:\tthe address of the 32-bit offset value\n */\nstatic inline void *offset_to_ptr(const int *off)\n{\n\treturn (void *)((unsigned long)off + *off);\n}\n\n#endif /* __ASSEMBLY__ */\n\n/* &a[0] degrades to a pointer: a different type from an array */\n#define __must_be_array(a)\tBUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))\n\n/*\n * This is needed in functions which generate the stack canary, see\n * arch/x86/kernel/smpboot.c::start_secondary() for an example.\n */\n#define prevent_tail_call_optimization()\tmb()\n\n#include <asm/rwonce.h>\n\n#endif /* __LINUX_COMPILER_H */\n"}, "6": {"id": 6, "path": "/src/include/asm-generic/bug.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _ASM_GENERIC_BUG_H\n#define _ASM_GENERIC_BUG_H\n\n#include <linux/compiler.h>\n#include <linux/instrumentation.h>\n\n#define CUT_HERE\t\t\"------------[ cut here ]------------\\n\"\n\n#ifdef CONFIG_GENERIC_BUG\n#define BUGFLAG_WARNING\t\t(1 << 0)\n#define BUGFLAG_ONCE\t\t(1 << 1)\n#define BUGFLAG_DONE\t\t(1 << 2)\n#define BUGFLAG_NO_CUT_HERE\t(1 << 3)\t/* CUT_HERE already sent */\n#define BUGFLAG_TAINT(taint)\t((taint) << 8)\n#define BUG_GET_TAINT(bug)\t((bug)->flags >> 8)\n#endif\n\n#ifndef __ASSEMBLY__\n#include <linux/kernel.h>\n\n#ifdef CONFIG_BUG\n\n#ifdef CONFIG_GENERIC_BUG\nstruct bug_entry {\n#ifndef CONFIG_GENERIC_BUG_RELATIVE_POINTERS\n\tunsigned long\tbug_addr;\n#else\n\tsigned int\tbug_addr_disp;\n#endif\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n#ifndef CONFIG_GENERIC_BUG_RELATIVE_POINTERS\n\tconst char\t*file;\n#else\n\tsigned int\tfile_disp;\n#endif\n\tunsigned short\tline;\n#endif\n\tunsigned short\tflags;\n};\n#endif\t/* CONFIG_GENERIC_BUG */\n\n/*\n * Don't use BUG() or BUG_ON() unless there's really no way out; one\n * example might be detecting data structure corruption in the middle\n * of an operation that can't be backed out of.  If the (sub)system\n * can somehow continue operating, perhaps with reduced functionality,\n * it's probably not BUG-worthy.\n *\n * If you're tempted to BUG(), think again:  is completely giving up\n * really the *only* solution?  There are usually better options, where\n * users don't need to reboot ASAP and can mostly shut down cleanly.\n */\n#ifndef HAVE_ARCH_BUG\n#define BUG() do { \\\n\tprintk(\"BUG: failure at %s:%d/%s()!\\n\", __FILE__, __LINE__, __func__); \\\n\tbarrier_before_unreachable(); \\\n\tpanic(\"BUG!\"); \\\n} while (0)\n#endif\n\n#ifndef HAVE_ARCH_BUG_ON\n#define BUG_ON(condition) do { if (unlikely(condition)) BUG(); } while (0)\n#endif\n\n/*\n * WARN(), WARN_ON(), WARN_ON_ONCE, and so on can be used to report\n * significant kernel issues that need prompt attention if they should ever\n * appear at runtime.\n *\n * Do not use these macros when checking for invalid external inputs\n * (e.g. invalid system call arguments, or invalid data coming from\n * network/devices), and on transient conditions like ENOMEM or EAGAIN.\n * These macros should be used for recoverable kernel issues only.\n * For invalid external inputs, transient conditions, etc use\n * pr_err[_once/_ratelimited]() followed by dump_stack(), if necessary.\n * Do not include \"BUG\"/\"WARNING\" in format strings manually to make these\n * conditions distinguishable from kernel issues.\n *\n * Use the versions with printk format strings to provide better diagnostics.\n */\n#ifndef __WARN_FLAGS\nextern __printf(4, 5)\nvoid warn_slowpath_fmt(const char *file, const int line, unsigned taint,\n\t\t       const char *fmt, ...);\n#define __WARN()\t\t__WARN_printf(TAINT_WARN, NULL)\n#define __WARN_printf(taint, arg...) do {\t\t\t\t\\\n\t\tinstrumentation_begin();\t\t\t\t\\\n\t\twarn_slowpath_fmt(__FILE__, __LINE__, taint, arg);\t\\\n\t\tinstrumentation_end();\t\t\t\t\t\\\n\t} while (0)\n#else\nextern __printf(1, 2) void __warn_printk(const char *fmt, ...);\n#define __WARN()\t\t__WARN_FLAGS(BUGFLAG_TAINT(TAINT_WARN))\n#define __WARN_printf(taint, arg...) do {\t\t\t\t\\\n\t\tinstrumentation_begin();\t\t\t\t\\\n\t\t__warn_printk(arg);\t\t\t\t\t\\\n\t\t__WARN_FLAGS(BUGFLAG_NO_CUT_HERE | BUGFLAG_TAINT(taint));\\\n\t\tinstrumentation_end();\t\t\t\t\t\\\n\t} while (0)\n#define WARN_ON_ONCE(condition) ({\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\\\n\t\t__WARN_FLAGS(BUGFLAG_ONCE |\t\t\t\\\n\t\t\t     BUGFLAG_TAINT(TAINT_WARN));\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\\\n})\n#endif\n\n/* used internally by panic.c */\nstruct warn_args;\nstruct pt_regs;\n\nvoid __warn(const char *file, int line, void *caller, unsigned taint,\n\t    struct pt_regs *regs, struct warn_args *args);\n\n#ifndef WARN_ON\n#define WARN_ON(condition) ({\t\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN();\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#ifndef WARN\n#define WARN(condition, format...) ({\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN_printf(TAINT_WARN, format);\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#define WARN_TAINT(condition, taint, format...) ({\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN_printf(taint, format);\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n\n#ifndef WARN_ON_ONCE\n#define WARN_ON_ONCE(condition)\t({\t\t\t\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN_ON(1);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n#endif\n\n#define WARN_ONCE(condition, format...)\t({\t\t\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN(1, format);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n\n#define WARN_TAINT_ONCE(condition, taint, format...)\t({\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN_TAINT(1, taint, format);\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n\n#else /* !CONFIG_BUG */\n#ifndef HAVE_ARCH_BUG\n#define BUG() do {} while (1)\n#endif\n\n#ifndef HAVE_ARCH_BUG_ON\n#define BUG_ON(condition) do { if (unlikely(condition)) BUG(); } while (0)\n#endif\n\n#ifndef HAVE_ARCH_WARN_ON\n#define WARN_ON(condition) ({\t\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#ifndef WARN\n#define WARN(condition, format...) ({\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tno_printk(format);\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#define WARN_ON_ONCE(condition) WARN_ON(condition)\n#define WARN_ONCE(condition, format...) WARN(condition, format)\n#define WARN_TAINT(condition, taint, format...) WARN(condition, format)\n#define WARN_TAINT_ONCE(condition, taint, format...) WARN(condition, format)\n\n#endif\n\n/*\n * WARN_ON_SMP() is for cases that the warning is either\n * meaningless for !SMP or may even cause failures.\n * It can also be used with values that are only defined\n * on SMP:\n *\n * struct foo {\n *  [...]\n * #ifdef CONFIG_SMP\n *\tint bar;\n * #endif\n * };\n *\n * void func(struct foo *zoot)\n * {\n *\tWARN_ON_SMP(!zoot->bar);\n *\n * For CONFIG_SMP, WARN_ON_SMP() should act the same as WARN_ON(),\n * and should be a nop and return false for uniprocessor.\n *\n * if (WARN_ON_SMP(x)) returns true only when CONFIG_SMP is set\n * and x is true.\n */\n#ifdef CONFIG_SMP\n# define WARN_ON_SMP(x)\t\t\tWARN_ON(x)\n#else\n/*\n * Use of ({0;}) because WARN_ON_SMP(x) may be used either as\n * a stand alone line statement or as a condition in an if ()\n * statement.\n * A simple \"0\" would cause gcc to give a \"statement has no effect\"\n * warning.\n */\n# define WARN_ON_SMP(x)\t\t\t({0;})\n#endif\n\n#endif /* __ASSEMBLY__ */\n\n#endif\n"}, "7": {"id": 7, "path": "/src/include/linux/jbd2.h", "content": "/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * linux/include/linux/jbd2.h\n *\n * Written by Stephen C. Tweedie <sct@redhat.com>\n *\n * Copyright 1998-2000 Red Hat, Inc --- All Rights Reserved\n *\n * Definitions for transaction data structures for the buffer cache\n * filesystem journaling support.\n */\n\n#ifndef _LINUX_JBD2_H\n#define _LINUX_JBD2_H\n\n/* Allow this file to be included directly into e2fsprogs */\n#ifndef __KERNEL__\n#include \"jfs_compat.h\"\n#define JBD2_DEBUG\n#else\n\n#include <linux/types.h>\n#include <linux/buffer_head.h>\n#include <linux/journal-head.h>\n#include <linux/stddef.h>\n#include <linux/mutex.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/blkdev.h>\n#include <crypto/hash.h>\n#endif\n\n#define journal_oom_retry 1\n\n/*\n * Define JBD2_PARANIOD_IOFAIL to cause a kernel BUG() if ext4 finds\n * certain classes of error which can occur due to failed IOs.  Under\n * normal use we want ext4 to continue after such errors, because\n * hardware _can_ fail, but for debugging purposes when running tests on\n * known-good hardware we may want to trap these errors.\n */\n#undef JBD2_PARANOID_IOFAIL\n\n/*\n * The default maximum commit age, in seconds.\n */\n#define JBD2_DEFAULT_MAX_COMMIT_AGE 5\n\n#ifdef CONFIG_JBD2_DEBUG\n/*\n * Define JBD2_EXPENSIVE_CHECKING to enable more expensive internal\n * consistency checks.  By default we don't do this unless\n * CONFIG_JBD2_DEBUG is on.\n */\n#define JBD2_EXPENSIVE_CHECKING\nextern ushort jbd2_journal_enable_debug;\nvoid __jbd2_debug(int level, const char *file, const char *func,\n\t\t  unsigned int line, const char *fmt, ...);\n\n#define jbd_debug(n, fmt, a...) \\\n\t__jbd2_debug((n), __FILE__, __func__, __LINE__, (fmt), ##a)\n#else\n#define jbd_debug(n, fmt, a...)    /**/\n#endif\n\nextern void *jbd2_alloc(size_t size, gfp_t flags);\nextern void jbd2_free(void *ptr, size_t size);\n\n#define JBD2_MIN_JOURNAL_BLOCKS 1024\n#define JBD2_DEFAULT_FAST_COMMIT_BLOCKS 256\n\n#ifdef __KERNEL__\n\n/**\n * typedef handle_t - The handle_t type represents a single atomic update being performed by some process.\n *\n * All filesystem modifications made by the process go\n * through this handle.  Recursive operations (such as quota operations)\n * are gathered into a single update.\n *\n * The buffer credits field is used to account for journaled buffers\n * being modified by the running process.  To ensure that there is\n * enough log space for all outstanding operations, we need to limit the\n * number of outstanding buffers possible at any time.  When the\n * operation completes, any buffer credits not used are credited back to\n * the transaction, so that at all times we know how many buffers the\n * outstanding updates on a transaction might possibly touch.\n *\n * This is an opaque datatype.\n **/\ntypedef struct jbd2_journal_handle handle_t;\t/* Atomic operation type */\n\n\n/**\n * typedef journal_t - The journal_t maintains all of the journaling state information for a single filesystem.\n *\n * journal_t is linked to from the fs superblock structure.\n *\n * We use the journal_t to keep track of all outstanding transaction\n * activity on the filesystem, and to manage the state of the log\n * writing process.\n *\n * This is an opaque datatype.\n **/\ntypedef struct journal_s\tjournal_t;\t/* Journal control structure */\n#endif\n\n/*\n * Internal structures used by the logging mechanism:\n */\n\n#define JBD2_MAGIC_NUMBER 0xc03b3998U /* The first 4 bytes of /dev/random! */\n\n/*\n * On-disk structures\n */\n\n/*\n * Descriptor block types:\n */\n\n#define JBD2_DESCRIPTOR_BLOCK\t1\n#define JBD2_COMMIT_BLOCK\t2\n#define JBD2_SUPERBLOCK_V1\t3\n#define JBD2_SUPERBLOCK_V2\t4\n#define JBD2_REVOKE_BLOCK\t5\n\n/*\n * Standard header for all descriptor blocks:\n */\ntypedef struct journal_header_s\n{\n\t__be32\t\th_magic;\n\t__be32\t\th_blocktype;\n\t__be32\t\th_sequence;\n} journal_header_t;\n\n/*\n * Checksum types.\n */\n#define JBD2_CRC32_CHKSUM   1\n#define JBD2_MD5_CHKSUM     2\n#define JBD2_SHA1_CHKSUM    3\n#define JBD2_CRC32C_CHKSUM  4\n\n#define JBD2_CRC32_CHKSUM_SIZE 4\n\n#define JBD2_CHECKSUM_BYTES (32 / sizeof(u32))\n/*\n * Commit block header for storing transactional checksums:\n *\n * NOTE: If FEATURE_COMPAT_CHECKSUM (checksum v1) is set, the h_chksum*\n * fields are used to store a checksum of the descriptor and data blocks.\n *\n * If FEATURE_INCOMPAT_CSUM_V2 (checksum v2) is set, then the h_chksum\n * field is used to store crc32c(uuid+commit_block).  Each journal metadata\n * block gets its own checksum, and data block checksums are stored in\n * journal_block_tag (in the descriptor).  The other h_chksum* fields are\n * not used.\n *\n * If FEATURE_INCOMPAT_CSUM_V3 is set, the descriptor block uses\n * journal_block_tag3_t to store a full 32-bit checksum.  Everything else\n * is the same as v2.\n *\n * Checksum v1, v2, and v3 are mutually exclusive features.\n */\nstruct commit_header {\n\t__be32\t\th_magic;\n\t__be32          h_blocktype;\n\t__be32          h_sequence;\n\tunsigned char   h_chksum_type;\n\tunsigned char   h_chksum_size;\n\tunsigned char \th_padding[2];\n\t__be32 \t\th_chksum[JBD2_CHECKSUM_BYTES];\n\t__be64\t\th_commit_sec;\n\t__be32\t\th_commit_nsec;\n};\n\n/*\n * The block tag: used to describe a single buffer in the journal.\n * t_blocknr_high is only used if INCOMPAT_64BIT is set, so this\n * raw struct shouldn't be used for pointer math or sizeof() - use\n * journal_tag_bytes(journal) instead to compute this.\n */\ntypedef struct journal_block_tag3_s\n{\n\t__be32\t\tt_blocknr;\t/* The on-disk block number */\n\t__be32\t\tt_flags;\t/* See below */\n\t__be32\t\tt_blocknr_high; /* most-significant high 32bits. */\n\t__be32\t\tt_checksum;\t/* crc32c(uuid+seq+block) */\n} journal_block_tag3_t;\n\ntypedef struct journal_block_tag_s\n{\n\t__be32\t\tt_blocknr;\t/* The on-disk block number */\n\t__be16\t\tt_checksum;\t/* truncated crc32c(uuid+seq+block) */\n\t__be16\t\tt_flags;\t/* See below */\n\t__be32\t\tt_blocknr_high; /* most-significant high 32bits. */\n} journal_block_tag_t;\n\n/* Tail of descriptor or revoke block, for checksumming */\nstruct jbd2_journal_block_tail {\n\t__be32\t\tt_checksum;\t/* crc32c(uuid+descr_block) */\n};\n\n/*\n * The revoke descriptor: used on disk to describe a series of blocks to\n * be revoked from the log\n */\ntypedef struct jbd2_journal_revoke_header_s\n{\n\tjournal_header_t r_header;\n\t__be32\t\t r_count;\t/* Count of bytes used in the block */\n} jbd2_journal_revoke_header_t;\n\n/* Definitions for the journal tag flags word: */\n#define JBD2_FLAG_ESCAPE\t\t1\t/* on-disk block is escaped */\n#define JBD2_FLAG_SAME_UUID\t2\t/* block has same uuid as previous */\n#define JBD2_FLAG_DELETED\t4\t/* block deleted by this transaction */\n#define JBD2_FLAG_LAST_TAG\t8\t/* last tag in this descriptor block */\n\n\n/*\n * The journal superblock.  All fields are in big-endian byte order.\n */\ntypedef struct journal_superblock_s\n{\n/* 0x0000 */\n\tjournal_header_t s_header;\n\n/* 0x000C */\n\t/* Static information describing the journal */\n\t__be32\ts_blocksize;\t\t/* journal device blocksize */\n\t__be32\ts_maxlen;\t\t/* total blocks in journal file */\n\t__be32\ts_first;\t\t/* first block of log information */\n\n/* 0x0018 */\n\t/* Dynamic information describing the current state of the log */\n\t__be32\ts_sequence;\t\t/* first commit ID expected in log */\n\t__be32\ts_start;\t\t/* blocknr of start of log */\n\n/* 0x0020 */\n\t/* Error value, as set by jbd2_journal_abort(). */\n\t__be32\ts_errno;\n\n/* 0x0024 */\n\t/* Remaining fields are only valid in a version-2 superblock */\n\t__be32\ts_feature_compat;\t/* compatible feature set */\n\t__be32\ts_feature_incompat;\t/* incompatible feature set */\n\t__be32\ts_feature_ro_compat;\t/* readonly-compatible feature set */\n/* 0x0030 */\n\t__u8\ts_uuid[16];\t\t/* 128-bit uuid for journal */\n\n/* 0x0040 */\n\t__be32\ts_nr_users;\t\t/* Nr of filesystems sharing log */\n\n\t__be32\ts_dynsuper;\t\t/* Blocknr of dynamic superblock copy*/\n\n/* 0x0048 */\n\t__be32\ts_max_transaction;\t/* Limit of journal blocks per trans.*/\n\t__be32\ts_max_trans_data;\t/* Limit of data blocks per trans. */\n\n/* 0x0050 */\n\t__u8\ts_checksum_type;\t/* checksum type */\n\t__u8\ts_padding2[3];\n/* 0x0054 */\n\t__be32\ts_num_fc_blks;\t\t/* Number of fast commit blocks */\n/* 0x0058 */\n\t__u32\ts_padding[41];\n\t__be32\ts_checksum;\t\t/* crc32c(superblock) */\n\n/* 0x0100 */\n\t__u8\ts_users[16*48];\t\t/* ids of all fs'es sharing the log */\n/* 0x0400 */\n} journal_superblock_t;\n\n/* Use the jbd2_{has,set,clear}_feature_* helpers; these will be removed */\n#define JBD2_HAS_COMPAT_FEATURE(j,mask)\t\t\t\t\t\\\n\t((j)->j_format_version >= 2 &&\t\t\t\t\t\\\n\t ((j)->j_superblock->s_feature_compat & cpu_to_be32((mask))))\n#define JBD2_HAS_RO_COMPAT_FEATURE(j,mask)\t\t\t\t\\\n\t((j)->j_format_version >= 2 &&\t\t\t\t\t\\\n\t ((j)->j_superblock->s_feature_ro_compat & cpu_to_be32((mask))))\n#define JBD2_HAS_INCOMPAT_FEATURE(j,mask)\t\t\t\t\\\n\t((j)->j_format_version >= 2 &&\t\t\t\t\t\\\n\t ((j)->j_superblock->s_feature_incompat & cpu_to_be32((mask))))\n\n#define JBD2_FEATURE_COMPAT_CHECKSUM\t\t0x00000001\n\n#define JBD2_FEATURE_INCOMPAT_REVOKE\t\t0x00000001\n#define JBD2_FEATURE_INCOMPAT_64BIT\t\t0x00000002\n#define JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT\t0x00000004\n#define JBD2_FEATURE_INCOMPAT_CSUM_V2\t\t0x00000008\n#define JBD2_FEATURE_INCOMPAT_CSUM_V3\t\t0x00000010\n#define JBD2_FEATURE_INCOMPAT_FAST_COMMIT\t0x00000020\n\n/* See \"journal feature predicate functions\" below */\n\n/* Features known to this kernel version: */\n#define JBD2_KNOWN_COMPAT_FEATURES\tJBD2_FEATURE_COMPAT_CHECKSUM\n#define JBD2_KNOWN_ROCOMPAT_FEATURES\t0\n#define JBD2_KNOWN_INCOMPAT_FEATURES\t(JBD2_FEATURE_INCOMPAT_REVOKE | \\\n\t\t\t\t\tJBD2_FEATURE_INCOMPAT_64BIT | \\\n\t\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT | \\\n\t\t\t\t\tJBD2_FEATURE_INCOMPAT_CSUM_V2 | \\\n\t\t\t\t\tJBD2_FEATURE_INCOMPAT_CSUM_V3 | \\\n\t\t\t\t\tJBD2_FEATURE_INCOMPAT_FAST_COMMIT)\n\n#ifdef __KERNEL__\n\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nenum jbd_state_bits {\n\tBH_JBD\t\t\t/* Has an attached ext3 journal_head */\n\t  = BH_PrivateStart,\n\tBH_JWrite,\t\t/* Being written to log (@@@ DEBUGGING) */\n\tBH_Freed,\t\t/* Has been freed (truncated) */\n\tBH_Revoked,\t\t/* Has been revoked from the log */\n\tBH_RevokeValid,\t\t/* Revoked flag is valid */\n\tBH_JBDDirty,\t\t/* Is dirty but journaled */\n\tBH_JournalHead,\t\t/* Pins bh->b_private and jh->b_bh */\n\tBH_Shadow,\t\t/* IO on shadow buffer is running */\n\tBH_Verified,\t\t/* Metadata block has been verified ok */\n\tBH_JBDPrivateStart,\t/* First bit available for private use by FS */\n};\n\nBUFFER_FNS(JBD, jbd)\nBUFFER_FNS(JWrite, jwrite)\nBUFFER_FNS(JBDDirty, jbddirty)\nTAS_BUFFER_FNS(JBDDirty, jbddirty)\nBUFFER_FNS(Revoked, revoked)\nTAS_BUFFER_FNS(Revoked, revoked)\nBUFFER_FNS(RevokeValid, revokevalid)\nTAS_BUFFER_FNS(RevokeValid, revokevalid)\nBUFFER_FNS(Freed, freed)\nBUFFER_FNS(Shadow, shadow)\nBUFFER_FNS(Verified, verified)\n\nstatic inline struct buffer_head *jh2bh(struct journal_head *jh)\n{\n\treturn jh->b_bh;\n}\n\nstatic inline struct journal_head *bh2jh(struct buffer_head *bh)\n{\n\treturn bh->b_private;\n}\n\nstatic inline void jbd_lock_bh_journal_head(struct buffer_head *bh)\n{\n\tbit_spin_lock(BH_JournalHead, &bh->b_state);\n}\n\nstatic inline void jbd_unlock_bh_journal_head(struct buffer_head *bh)\n{\n\tbit_spin_unlock(BH_JournalHead, &bh->b_state);\n}\n\n#define J_ASSERT(assert)\tBUG_ON(!(assert))\n\n#define J_ASSERT_BH(bh, expr)\tJ_ASSERT(expr)\n#define J_ASSERT_JH(jh, expr)\tJ_ASSERT(expr)\n\n#if defined(JBD2_PARANOID_IOFAIL)\n#define J_EXPECT(expr, why...)\t\tJ_ASSERT(expr)\n#define J_EXPECT_BH(bh, expr, why...)\tJ_ASSERT_BH(bh, expr)\n#define J_EXPECT_JH(jh, expr, why...)\tJ_ASSERT_JH(jh, expr)\n#else\n#define __journal_expect(expr, why...)\t\t\t\t\t     \\\n\t({\t\t\t\t\t\t\t\t     \\\n\t\tint val = (expr);\t\t\t\t\t     \\\n\t\tif (!val) {\t\t\t\t\t\t     \\\n\t\t\tprintk(KERN_ERR\t\t\t\t\t     \\\n\t\t\t       \"JBD2 unexpected failure: %s: %s;\\n\",\t     \\\n\t\t\t       __func__, #expr);\t\t\t     \\\n\t\t\tprintk(KERN_ERR why \"\\n\");\t\t\t     \\\n\t\t}\t\t\t\t\t\t\t     \\\n\t\tval;\t\t\t\t\t\t\t     \\\n\t})\n#define J_EXPECT(expr, why...)\t\t__journal_expect(expr, ## why)\n#define J_EXPECT_BH(bh, expr, why...)\t__journal_expect(expr, ## why)\n#define J_EXPECT_JH(jh, expr, why...)\t__journal_expect(expr, ## why)\n#endif\n\n/* Flags in jbd_inode->i_flags */\n#define __JI_COMMIT_RUNNING 0\n#define __JI_WRITE_DATA 1\n#define __JI_WAIT_DATA 2\n\n/*\n * Commit of the inode data in progress. We use this flag to protect us from\n * concurrent deletion of inode. We cannot use reference to inode for this\n * since we cannot afford doing last iput() on behalf of kjournald\n */\n#define JI_COMMIT_RUNNING (1 << __JI_COMMIT_RUNNING)\n/* Write allocated dirty buffers in this inode before commit */\n#define JI_WRITE_DATA (1 << __JI_WRITE_DATA)\n/* Wait for outstanding data writes for this inode before commit */\n#define JI_WAIT_DATA (1 << __JI_WAIT_DATA)\n\n/**\n * struct jbd2_inode - The jbd_inode type is the structure linking inodes in\n * ordered mode present in a transaction so that we can sync them during commit.\n */\nstruct jbd2_inode {\n\t/**\n\t * @i_transaction:\n\t *\n\t * Which transaction does this inode belong to? Either the running\n\t * transaction or the committing one. [j_list_lock]\n\t */\n\ttransaction_t *i_transaction;\n\n\t/**\n\t * @i_next_transaction:\n\t *\n\t * Pointer to the running transaction modifying inode's data in case\n\t * there is already a committing transaction touching it. [j_list_lock]\n\t */\n\ttransaction_t *i_next_transaction;\n\n\t/**\n\t * @i_list: List of inodes in the i_transaction [j_list_lock]\n\t */\n\tstruct list_head i_list;\n\n\t/**\n\t * @i_vfs_inode:\n\t *\n\t * VFS inode this inode belongs to [constant for lifetime of structure]\n\t */\n\tstruct inode *i_vfs_inode;\n\n\t/**\n\t * @i_flags: Flags of inode [j_list_lock]\n\t */\n\tunsigned long i_flags;\n\n\t/**\n\t * @i_dirty_start:\n\t *\n\t * Offset in bytes where the dirty range for this inode starts.\n\t * [j_list_lock]\n\t */\n\tloff_t i_dirty_start;\n\n\t/**\n\t * @i_dirty_end:\n\t *\n\t * Inclusive offset in bytes where the dirty range for this inode\n\t * ends. [j_list_lock]\n\t */\n\tloff_t i_dirty_end;\n};\n\nstruct jbd2_revoke_table_s;\n\n/**\n * struct jbd2_journal_handle - The jbd2_journal_handle type is the concrete\n *     type associated with handle_t.\n * @h_transaction: Which compound transaction is this update a part of?\n * @h_journal: Which journal handle belongs to - used iff h_reserved set.\n * @h_rsv_handle: Handle reserved for finishing the logical operation.\n * @h_total_credits: Number of remaining buffers we are allowed to add to\n *\tjournal. These are dirty buffers and revoke descriptor blocks.\n * @h_revoke_credits: Number of remaining revoke records available for handle\n * @h_ref: Reference count on this handle.\n * @h_err: Field for caller's use to track errors through large fs operations.\n * @h_sync: Flag for sync-on-close.\n * @h_jdata: Flag to force data journaling.\n * @h_reserved: Flag for handle for reserved credits.\n * @h_aborted: Flag indicating fatal error on handle.\n * @h_type: For handle statistics.\n * @h_line_no: For handle statistics.\n * @h_start_jiffies: Handle Start time.\n * @h_requested_credits: Holds @h_total_credits after handle is started.\n * @h_revoke_credits_requested: Holds @h_revoke_credits after handle is started.\n * @saved_alloc_context: Saved context while transaction is open.\n **/\n\n/* Docbook can't yet cope with the bit fields, but will leave the documentation\n * in so it can be fixed later.\n */\n\nstruct jbd2_journal_handle\n{\n\tunion {\n\t\ttransaction_t\t*h_transaction;\n\t\t/* Which journal handle belongs to - used iff h_reserved set */\n\t\tjournal_t\t*h_journal;\n\t};\n\n\thandle_t\t\t*h_rsv_handle;\n\tint\t\t\th_total_credits;\n\tint\t\t\th_revoke_credits;\n\tint\t\t\th_revoke_credits_requested;\n\tint\t\t\th_ref;\n\tint\t\t\th_err;\n\n\t/* Flags [no locking] */\n\tunsigned int\th_sync:\t\t1;\n\tunsigned int\th_jdata:\t1;\n\tunsigned int\th_reserved:\t1;\n\tunsigned int\th_aborted:\t1;\n\tunsigned int\th_type:\t\t8;\n\tunsigned int\th_line_no:\t16;\n\n\tunsigned long\t\th_start_jiffies;\n\tunsigned int\t\th_requested_credits;\n\n\tunsigned int\t\tsaved_alloc_context;\n};\n\n\n/*\n * Some stats for checkpoint phase\n */\nstruct transaction_chp_stats_s {\n\tunsigned long\t\tcs_chp_time;\n\t__u32\t\t\tcs_forced_to_close;\n\t__u32\t\t\tcs_written;\n\t__u32\t\t\tcs_dropped;\n};\n\n/* The transaction_t type is the guts of the journaling mechanism.  It\n * tracks a compound transaction through its various states:\n *\n * RUNNING:\taccepting new updates\n * LOCKED:\tUpdates still running but we don't accept new ones\n * RUNDOWN:\tUpdates are tidying up but have finished requesting\n *\t\tnew buffers to modify (state not used for now)\n * FLUSH:       All updates complete, but we are still writing to disk\n * COMMIT:      All data on disk, writing commit record\n * FINISHED:\tWe still have to keep the transaction for checkpointing.\n *\n * The transaction keeps track of all of the buffers modified by a\n * running transaction, and all of the buffers committed but not yet\n * flushed to home for finished transactions.\n * (Locking Documentation improved by LockDoc)\n */\n\n/*\n * Lock ranking:\n *\n *    j_list_lock\n *      ->jbd_lock_bh_journal_head()\t(This is \"innermost\")\n *\n *    j_state_lock\n *    ->b_state_lock\n *\n *    b_state_lock\n *    ->j_list_lock\n *\n *    j_state_lock\n *    ->t_handle_lock\n *\n *    j_state_lock\n *    ->j_list_lock\t\t\t(journal_unmap_buffer)\n *\n */\n\nstruct transaction_s\n{\n\t/* Pointer to the journal for this transaction. [no locking] */\n\tjournal_t\t\t*t_journal;\n\n\t/* Sequence number for this transaction [no locking] */\n\ttid_t\t\t\tt_tid;\n\n\t/*\n\t * Transaction's current state\n\t * [no locking - only kjournald2 alters this]\n\t * [j_list_lock] guards transition of a transaction into T_FINISHED\n\t * state and subsequent call of __jbd2_journal_drop_transaction()\n\t * FIXME: needs barriers\n\t * KLUDGE: [use j_state_lock]\n\t */\n\tenum {\n\t\tT_RUNNING,\n\t\tT_LOCKED,\n\t\tT_SWITCH,\n\t\tT_FLUSH,\n\t\tT_COMMIT,\n\t\tT_COMMIT_DFLUSH,\n\t\tT_COMMIT_JFLUSH,\n\t\tT_COMMIT_CALLBACK,\n\t\tT_FINISHED\n\t}\t\t\tt_state;\n\n\t/*\n\t * Where in the log does this transaction's commit start? [no locking]\n\t */\n\tunsigned long\t\tt_log_start;\n\n\t/* Number of buffers on the t_buffers list [j_list_lock] */\n\tint\t\t\tt_nr_buffers;\n\n\t/*\n\t * Doubly-linked circular list of all buffers reserved but not yet\n\t * modified by this transaction [j_list_lock]\n\t */\n\tstruct journal_head\t*t_reserved_list;\n\n\t/*\n\t * Doubly-linked circular list of all metadata buffers owned by this\n\t * transaction [j_list_lock]\n\t */\n\tstruct journal_head\t*t_buffers;\n\n\t/*\n\t * Doubly-linked circular list of all forget buffers (superseded\n\t * buffers which we can un-checkpoint once this transaction commits)\n\t * [j_list_lock]\n\t */\n\tstruct journal_head\t*t_forget;\n\n\t/*\n\t * Doubly-linked circular list of all buffers still to be flushed before\n\t * this transaction can be checkpointed. [j_list_lock]\n\t */\n\tstruct journal_head\t*t_checkpoint_list;\n\n\t/*\n\t * Doubly-linked circular list of all buffers submitted for IO while\n\t * checkpointing. [j_list_lock]\n\t */\n\tstruct journal_head\t*t_checkpoint_io_list;\n\n\t/*\n\t * Doubly-linked circular list of metadata buffers being shadowed by log\n\t * IO.  The IO buffers on the iobuf list and the shadow buffers on this\n\t * list match each other one for one at all times. [j_list_lock]\n\t */\n\tstruct journal_head\t*t_shadow_list;\n\n\t/*\n\t * List of inodes associated with the transaction; e.g., ext4 uses\n\t * this to track inodes in data=ordered and data=journal mode that\n\t * need special handling on transaction commit; also used by ocfs2.\n\t * [j_list_lock]\n\t */\n\tstruct list_head\tt_inode_list;\n\n\t/*\n\t * Protects info related to handles\n\t */\n\tspinlock_t\t\tt_handle_lock;\n\n\t/*\n\t * Longest time some handle had to wait for running transaction\n\t */\n\tunsigned long\t\tt_max_wait;\n\n\t/*\n\t * When transaction started\n\t */\n\tunsigned long\t\tt_start;\n\n\t/*\n\t * When commit was requested [j_state_lock]\n\t */\n\tunsigned long\t\tt_requested;\n\n\t/*\n\t * Checkpointing stats [j_list_lock]\n\t */\n\tstruct transaction_chp_stats_s t_chp_stats;\n\n\t/*\n\t * Number of outstanding updates running on this transaction\n\t * [none]\n\t */\n\tatomic_t\t\tt_updates;\n\n\t/*\n\t * Number of blocks reserved for this transaction in the journal.\n\t * This is including all credits reserved when starting transaction\n\t * handles as well as all journal descriptor blocks needed for this\n\t * transaction. [none]\n\t */\n\tatomic_t\t\tt_outstanding_credits;\n\n\t/*\n\t * Number of revoke records for this transaction added by already\n\t * stopped handles. [none]\n\t */\n\tatomic_t\t\tt_outstanding_revokes;\n\n\t/*\n\t * How many handles used this transaction? [none]\n\t */\n\tatomic_t\t\tt_handle_count;\n\n\t/*\n\t * Forward and backward links for the circular list of all transactions\n\t * awaiting checkpoint. [j_list_lock]\n\t */\n\ttransaction_t\t\t*t_cpnext, *t_cpprev;\n\n\t/*\n\t * When will the transaction expire (become due for commit), in jiffies?\n\t * [no locking]\n\t */\n\tunsigned long\t\tt_expires;\n\n\t/*\n\t * When this transaction started, in nanoseconds [no locking]\n\t */\n\tktime_t\t\t\tt_start_time;\n\n\t/*\n\t * This transaction is being forced and some process is\n\t * waiting for it to finish.\n\t */\n\tunsigned int t_synchronous_commit:1;\n\n\t/* Disk flush needs to be sent to fs partition [no locking] */\n\tint\t\t\tt_need_data_flush;\n\n\t/*\n\t * For use by the filesystem to store fs-specific data\n\t * structures associated with the transaction\n\t */\n\tstruct list_head\tt_private_list;\n};\n\nstruct transaction_run_stats_s {\n\tunsigned long\t\trs_wait;\n\tunsigned long\t\trs_request_delay;\n\tunsigned long\t\trs_running;\n\tunsigned long\t\trs_locked;\n\tunsigned long\t\trs_flushing;\n\tunsigned long\t\trs_logging;\n\n\t__u32\t\t\trs_handle_count;\n\t__u32\t\t\trs_blocks;\n\t__u32\t\t\trs_blocks_logged;\n};\n\nstruct transaction_stats_s {\n\tunsigned long\t\tts_tid;\n\tunsigned long\t\tts_requested;\n\tstruct transaction_run_stats_s run;\n};\n\nstatic inline unsigned long\njbd2_time_diff(unsigned long start, unsigned long end)\n{\n\tif (end >= start)\n\t\treturn end - start;\n\n\treturn end + (MAX_JIFFY_OFFSET - start);\n}\n\n#define JBD2_NR_BATCH\t64\n\nenum passtype {PASS_SCAN, PASS_REVOKE, PASS_REPLAY};\n\n#define JBD2_FC_REPLAY_STOP\t0\n#define JBD2_FC_REPLAY_CONTINUE\t1\n\n/**\n * struct journal_s - The journal_s type is the concrete type associated with\n *     journal_t.\n */\nstruct journal_s\n{\n\t/**\n\t * @j_flags: General journaling state flags [j_state_lock]\n\t */\n\tunsigned long\t\tj_flags;\n\n\t/**\n\t * @j_errno:\n\t *\n\t * Is there an outstanding uncleared error on the journal (from a prior\n\t * abort)? [j_state_lock]\n\t */\n\tint\t\t\tj_errno;\n\n\t/**\n\t * @j_abort_mutex: Lock the whole aborting procedure.\n\t */\n\tstruct mutex\t\tj_abort_mutex;\n\n\t/**\n\t * @j_sb_buffer: The first part of the superblock buffer.\n\t */\n\tstruct buffer_head\t*j_sb_buffer;\n\n\t/**\n\t * @j_superblock: The second part of the superblock buffer.\n\t */\n\tjournal_superblock_t\t*j_superblock;\n\n\t/**\n\t * @j_format_version: Version of the superblock format.\n\t */\n\tint\t\t\tj_format_version;\n\n\t/**\n\t * @j_state_lock: Protect the various scalars in the journal.\n\t */\n\trwlock_t\t\tj_state_lock;\n\n\t/**\n\t * @j_barrier_count:\n\t *\n\t * Number of processes waiting to create a barrier lock [j_state_lock]\n\t */\n\tint\t\t\tj_barrier_count;\n\n\t/**\n\t * @j_barrier: The barrier lock itself.\n\t */\n\tstruct mutex\t\tj_barrier;\n\n\t/**\n\t * @j_running_transaction:\n\t *\n\t * Transactions: The current running transaction...\n\t * [j_state_lock] [caller holding open handle]\n\t */\n\ttransaction_t\t\t*j_running_transaction;\n\n\t/**\n\t * @j_committing_transaction:\n\t *\n\t * the transaction we are pushing to disk\n\t * [j_state_lock] [caller holding open handle]\n\t */\n\ttransaction_t\t\t*j_committing_transaction;\n\n\t/**\n\t * @j_checkpoint_transactions:\n\t *\n\t * ... and a linked circular list of all transactions waiting for\n\t * checkpointing. [j_list_lock]\n\t */\n\ttransaction_t\t\t*j_checkpoint_transactions;\n\n\t/**\n\t * @j_wait_transaction_locked:\n\t *\n\t * Wait queue for waiting for a locked transaction to start committing,\n\t * or for a barrier lock to be released.\n\t */\n\twait_queue_head_t\tj_wait_transaction_locked;\n\n\t/**\n\t * @j_wait_done_commit: Wait queue for waiting for commit to complete.\n\t */\n\twait_queue_head_t\tj_wait_done_commit;\n\n\t/**\n\t * @j_wait_commit: Wait queue to trigger commit.\n\t */\n\twait_queue_head_t\tj_wait_commit;\n\n\t/**\n\t * @j_wait_updates: Wait queue to wait for updates to complete.\n\t */\n\twait_queue_head_t\tj_wait_updates;\n\n\t/**\n\t * @j_wait_reserved:\n\t *\n\t * Wait queue to wait for reserved buffer credits to drop.\n\t */\n\twait_queue_head_t\tj_wait_reserved;\n\n\t/**\n\t * @j_fc_wait:\n\t *\n\t * Wait queue to wait for completion of async fast commits.\n\t */\n\twait_queue_head_t\tj_fc_wait;\n\n\t/**\n\t * @j_checkpoint_mutex:\n\t *\n\t * Semaphore for locking against concurrent checkpoints.\n\t */\n\tstruct mutex\t\tj_checkpoint_mutex;\n\n\t/**\n\t * @j_chkpt_bhs:\n\t *\n\t * List of buffer heads used by the checkpoint routine.  This\n\t * was moved from jbd2_log_do_checkpoint() to reduce stack\n\t * usage.  Access to this array is controlled by the\n\t * @j_checkpoint_mutex.  [j_checkpoint_mutex]\n\t */\n\tstruct buffer_head\t*j_chkpt_bhs[JBD2_NR_BATCH];\n\n\t/**\n\t * @j_head:\n\t *\n\t * Journal head: identifies the first unused block in the journal.\n\t * [j_state_lock]\n\t */\n\tunsigned long\t\tj_head;\n\n\t/**\n\t * @j_tail:\n\t *\n\t * Journal tail: identifies the oldest still-used block in the journal.\n\t * [j_state_lock]\n\t */\n\tunsigned long\t\tj_tail;\n\n\t/**\n\t * @j_free:\n\t *\n\t * Journal free: how many free blocks are there in the journal?\n\t * [j_state_lock]\n\t */\n\tunsigned long\t\tj_free;\n\n\t/**\n\t * @j_first:\n\t *\n\t * The block number of the first usable block in the journal\n\t * [j_state_lock].\n\t */\n\tunsigned long\t\tj_first;\n\n\t/**\n\t * @j_last:\n\t *\n\t * The block number one beyond the last usable block in the journal\n\t * [j_state_lock].\n\t */\n\tunsigned long\t\tj_last;\n\n\t/**\n\t * @j_fc_first:\n\t *\n\t * The block number of the first fast commit block in the journal\n\t * [j_state_lock].\n\t */\n\tunsigned long\t\tj_fc_first;\n\n\t/**\n\t * @j_fc_off:\n\t *\n\t * Number of fast commit blocks currently allocated. Accessed only\n\t * during fast commit. Currently only process can do fast commit, so\n\t * this field is not protected by any lock.\n\t */\n\tunsigned long\t\tj_fc_off;\n\n\t/**\n\t * @j_fc_last:\n\t *\n\t * The block number one beyond the last fast commit block in the journal\n\t * [j_state_lock].\n\t */\n\tunsigned long\t\tj_fc_last;\n\n\t/**\n\t * @j_dev: Device where we store the journal.\n\t */\n\tstruct block_device\t*j_dev;\n\n\t/**\n\t * @j_blocksize: Block size for the location where we store the journal.\n\t */\n\tint\t\t\tj_blocksize;\n\n\t/**\n\t * @j_blk_offset:\n\t *\n\t * Starting block offset into the device where we store the journal.\n\t */\n\tunsigned long long\tj_blk_offset;\n\n\t/**\n\t * @j_devname: Journal device name.\n\t */\n\tchar\t\t\tj_devname[BDEVNAME_SIZE+24];\n\n\t/**\n\t * @j_fs_dev:\n\t *\n\t * Device which holds the client fs.  For internal journal this will be\n\t * equal to j_dev.\n\t */\n\tstruct block_device\t*j_fs_dev;\n\n\t/**\n\t * @j_total_len: Total maximum capacity of the journal region on disk.\n\t */\n\tunsigned int\t\tj_total_len;\n\n\t/**\n\t * @j_reserved_credits:\n\t *\n\t * Number of buffers reserved from the running transaction.\n\t */\n\tatomic_t\t\tj_reserved_credits;\n\n\t/**\n\t * @j_list_lock: Protects the buffer lists and internal buffer state.\n\t */\n\tspinlock_t\t\tj_list_lock;\n\n\t/**\n\t * @j_inode:\n\t *\n\t * Optional inode where we store the journal.  If present, all\n\t * journal block numbers are mapped into this inode via bmap().\n\t */\n\tstruct inode\t\t*j_inode;\n\n\t/**\n\t * @j_tail_sequence:\n\t *\n\t * Sequence number of the oldest transaction in the log [j_state_lock]\n\t */\n\ttid_t\t\t\tj_tail_sequence;\n\n\t/**\n\t * @j_transaction_sequence:\n\t *\n\t * Sequence number of the next transaction to grant [j_state_lock]\n\t */\n\ttid_t\t\t\tj_transaction_sequence;\n\n\t/**\n\t * @j_commit_sequence:\n\t *\n\t * Sequence number of the most recently committed transaction\n\t * [j_state_lock].\n\t */\n\ttid_t\t\t\tj_commit_sequence;\n\n\t/**\n\t * @j_commit_request:\n\t *\n\t * Sequence number of the most recent transaction wanting commit\n\t * [j_state_lock]\n\t */\n\ttid_t\t\t\tj_commit_request;\n\n\t/**\n\t * @j_uuid:\n\t *\n\t * Journal uuid: identifies the object (filesystem, LVM volume etc)\n\t * backed by this journal.  This will eventually be replaced by an array\n\t * of uuids, allowing us to index multiple devices within a single\n\t * journal and to perform atomic updates across them.\n\t */\n\t__u8\t\t\tj_uuid[16];\n\n\t/**\n\t * @j_task: Pointer to the current commit thread for this journal.\n\t */\n\tstruct task_struct\t*j_task;\n\n\t/**\n\t * @j_max_transaction_buffers:\n\t *\n\t * Maximum number of metadata buffers to allow in a single compound\n\t * commit transaction.\n\t */\n\tint\t\t\tj_max_transaction_buffers;\n\n\t/**\n\t * @j_revoke_records_per_block:\n\t *\n\t * Number of revoke records that fit in one descriptor block.\n\t */\n\tint\t\t\tj_revoke_records_per_block;\n\n\t/**\n\t * @j_commit_interval:\n\t *\n\t * What is the maximum transaction lifetime before we begin a commit?\n\t */\n\tunsigned long\t\tj_commit_interval;\n\n\t/**\n\t * @j_commit_timer: The timer used to wakeup the commit thread.\n\t */\n\tstruct timer_list\tj_commit_timer;\n\n\t/**\n\t * @j_revoke_lock: Protect the revoke table.\n\t */\n\tspinlock_t\t\tj_revoke_lock;\n\n\t/**\n\t * @j_revoke:\n\t *\n\t * The revoke table - maintains the list of revoked blocks in the\n\t * current transaction.\n\t */\n\tstruct jbd2_revoke_table_s *j_revoke;\n\n\t/**\n\t * @j_revoke_table: Alternate revoke tables for j_revoke.\n\t */\n\tstruct jbd2_revoke_table_s *j_revoke_table[2];\n\n\t/**\n\t * @j_wbuf: Array of bhs for jbd2_journal_commit_transaction.\n\t */\n\tstruct buffer_head\t**j_wbuf;\n\n\t/**\n\t * @j_fc_wbuf: Array of fast commit bhs for fast commit. Accessed only\n\t * during a fast commit. Currently only process can do fast commit, so\n\t * this field is not protected by any lock.\n\t */\n\tstruct buffer_head\t**j_fc_wbuf;\n\n\t/**\n\t * @j_wbufsize:\n\t *\n\t * Size of @j_wbuf array.\n\t */\n\tint\t\t\tj_wbufsize;\n\n\t/**\n\t * @j_fc_wbufsize:\n\t *\n\t * Size of @j_fc_wbuf array.\n\t */\n\tint\t\t\tj_fc_wbufsize;\n\n\t/**\n\t * @j_last_sync_writer:\n\t *\n\t * The pid of the last person to run a synchronous operation\n\t * through the journal.\n\t */\n\tpid_t\t\t\tj_last_sync_writer;\n\n\t/**\n\t * @j_average_commit_time:\n\t *\n\t * The average amount of time in nanoseconds it takes to commit a\n\t * transaction to disk. [j_state_lock]\n\t */\n\tu64\t\t\tj_average_commit_time;\n\n\t/**\n\t * @j_min_batch_time:\n\t *\n\t * Minimum time that we should wait for additional filesystem operations\n\t * to get batched into a synchronous handle in microseconds.\n\t */\n\tu32\t\t\tj_min_batch_time;\n\n\t/**\n\t * @j_max_batch_time:\n\t *\n\t * Maximum time that we should wait for additional filesystem operations\n\t * to get batched into a synchronous handle in microseconds.\n\t */\n\tu32\t\t\tj_max_batch_time;\n\n\t/**\n\t * @j_commit_callback:\n\t *\n\t * This function is called when a transaction is closed.\n\t */\n\tvoid\t\t\t(*j_commit_callback)(journal_t *,\n\t\t\t\t\t\t     transaction_t *);\n\n\t/**\n\t * @j_submit_inode_data_buffers:\n\t *\n\t * This function is called for all inodes associated with the\n\t * committing transaction marked with JI_WRITE_DATA flag\n\t * before we start to write out the transaction to the journal.\n\t */\n\tint\t\t\t(*j_submit_inode_data_buffers)\n\t\t\t\t\t(struct jbd2_inode *);\n\n\t/**\n\t * @j_finish_inode_data_buffers:\n\t *\n\t * This function is called for all inodes associated with the\n\t * committing transaction marked with JI_WAIT_DATA flag\n\t * after we have written the transaction to the journal\n\t * but before we write out the commit block.\n\t */\n\tint\t\t\t(*j_finish_inode_data_buffers)\n\t\t\t\t\t(struct jbd2_inode *);\n\n\t/*\n\t * Journal statistics\n\t */\n\n\t/**\n\t * @j_history_lock: Protect the transactions statistics history.\n\t */\n\tspinlock_t\t\tj_history_lock;\n\n\t/**\n\t * @j_proc_entry: procfs entry for the jbd statistics directory.\n\t */\n\tstruct proc_dir_entry\t*j_proc_entry;\n\n\t/**\n\t * @j_stats: Overall statistics.\n\t */\n\tstruct transaction_stats_s j_stats;\n\n\t/**\n\t * @j_failed_commit: Failed journal commit ID.\n\t */\n\tunsigned int\t\tj_failed_commit;\n\n\t/**\n\t * @j_private:\n\t *\n\t * An opaque pointer to fs-private information.  ext3 puts its\n\t * superblock pointer here.\n\t */\n\tvoid *j_private;\n\n\t/**\n\t * @j_chksum_driver:\n\t *\n\t * Reference to checksum algorithm driver via cryptoapi.\n\t */\n\tstruct crypto_shash *j_chksum_driver;\n\n\t/**\n\t * @j_csum_seed:\n\t *\n\t * Precomputed journal UUID checksum for seeding other checksums.\n\t */\n\t__u32 j_csum_seed;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t/**\n\t * @j_trans_commit_map:\n\t *\n\t * Lockdep entity to track transaction commit dependencies. Handles\n\t * hold this \"lock\" for read, when we wait for commit, we acquire the\n\t * \"lock\" for writing. This matches the properties of jbd2 journalling\n\t * where the running transaction has to wait for all handles to be\n\t * dropped to commit that transaction and also acquiring a handle may\n\t * require transaction commit to finish.\n\t */\n\tstruct lockdep_map\tj_trans_commit_map;\n#endif\n\n\t/**\n\t * @j_fc_cleanup_callback:\n\t *\n\t * Clean-up after fast commit or full commit. JBD2 calls this function\n\t * after every commit operation.\n\t */\n\tvoid (*j_fc_cleanup_callback)(struct journal_s *journal, int);\n\n\t/**\n\t * @j_fc_replay_callback:\n\t *\n\t * File-system specific function that performs replay of a fast\n\t * commit. JBD2 calls this function for each fast commit block found in\n\t * the journal. This function should return JBD2_FC_REPLAY_CONTINUE\n\t * to indicate that the block was processed correctly and more fast\n\t * commit replay should continue. Return value of JBD2_FC_REPLAY_STOP\n\t * indicates the end of replay (no more blocks remaining). A negative\n\t * return value indicates error.\n\t */\n\tint (*j_fc_replay_callback)(struct journal_s *journal,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    enum passtype pass, int off,\n\t\t\t\t    tid_t expected_commit_id);\n};\n\n#define jbd2_might_wait_for_commit(j) \\\n\tdo { \\\n\t\trwsem_acquire(&j->j_trans_commit_map, 0, 0, _THIS_IP_); \\\n\t\trwsem_release(&j->j_trans_commit_map, _THIS_IP_); \\\n\t} while (0)\n\n/* journal feature predicate functions */\n#define JBD2_FEATURE_COMPAT_FUNCS(name, flagname) \\\nstatic inline bool jbd2_has_feature_##name(journal_t *j) \\\n{ \\\n\treturn ((j)->j_format_version >= 2 && \\\n\t\t((j)->j_superblock->s_feature_compat & \\\n\t\t cpu_to_be32(JBD2_FEATURE_COMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void jbd2_set_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_compat |= \\\n\t\tcpu_to_be32(JBD2_FEATURE_COMPAT_##flagname); \\\n} \\\nstatic inline void jbd2_clear_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_compat &= \\\n\t\t~cpu_to_be32(JBD2_FEATURE_COMPAT_##flagname); \\\n}\n\n#define JBD2_FEATURE_RO_COMPAT_FUNCS(name, flagname) \\\nstatic inline bool jbd2_has_feature_##name(journal_t *j) \\\n{ \\\n\treturn ((j)->j_format_version >= 2 && \\\n\t\t((j)->j_superblock->s_feature_ro_compat & \\\n\t\t cpu_to_be32(JBD2_FEATURE_RO_COMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void jbd2_set_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_ro_compat |= \\\n\t\tcpu_to_be32(JBD2_FEATURE_RO_COMPAT_##flagname); \\\n} \\\nstatic inline void jbd2_clear_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_ro_compat &= \\\n\t\t~cpu_to_be32(JBD2_FEATURE_RO_COMPAT_##flagname); \\\n}\n\n#define JBD2_FEATURE_INCOMPAT_FUNCS(name, flagname) \\\nstatic inline bool jbd2_has_feature_##name(journal_t *j) \\\n{ \\\n\treturn ((j)->j_format_version >= 2 && \\\n\t\t((j)->j_superblock->s_feature_incompat & \\\n\t\t cpu_to_be32(JBD2_FEATURE_INCOMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void jbd2_set_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_incompat |= \\\n\t\tcpu_to_be32(JBD2_FEATURE_INCOMPAT_##flagname); \\\n} \\\nstatic inline void jbd2_clear_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_incompat &= \\\n\t\t~cpu_to_be32(JBD2_FEATURE_INCOMPAT_##flagname); \\\n}\n\nJBD2_FEATURE_COMPAT_FUNCS(checksum,\t\tCHECKSUM)\n\nJBD2_FEATURE_INCOMPAT_FUNCS(revoke,\t\tREVOKE)\nJBD2_FEATURE_INCOMPAT_FUNCS(64bit,\t\t64BIT)\nJBD2_FEATURE_INCOMPAT_FUNCS(async_commit,\tASYNC_COMMIT)\nJBD2_FEATURE_INCOMPAT_FUNCS(csum2,\t\tCSUM_V2)\nJBD2_FEATURE_INCOMPAT_FUNCS(csum3,\t\tCSUM_V3)\nJBD2_FEATURE_INCOMPAT_FUNCS(fast_commit,\tFAST_COMMIT)\n\n/*\n * Journal flag definitions\n */\n#define JBD2_UNMOUNT\t0x001\t/* Journal thread is being destroyed */\n#define JBD2_ABORT\t0x002\t/* Journaling has been aborted for errors. */\n#define JBD2_ACK_ERR\t0x004\t/* The errno in the sb has been acked */\n#define JBD2_FLUSHED\t0x008\t/* The journal superblock has been flushed */\n#define JBD2_LOADED\t0x010\t/* The journal superblock has been loaded */\n#define JBD2_BARRIER\t0x020\t/* Use IDE barriers */\n#define JBD2_ABORT_ON_SYNCDATA_ERR\t0x040\t/* Abort the journal on file\n\t\t\t\t\t\t * data write error in ordered\n\t\t\t\t\t\t * mode */\n#define JBD2_FAST_COMMIT_ONGOING\t0x100\t/* Fast commit is ongoing */\n#define JBD2_FULL_COMMIT_ONGOING\t0x200\t/* Full commit is ongoing */\n\n/*\n * Function declarations for the journaling transaction and buffer\n * management\n */\n\n/* Filing buffers */\nextern void jbd2_journal_unfile_buffer(journal_t *, struct journal_head *);\nextern bool __jbd2_journal_refile_buffer(struct journal_head *);\nextern void jbd2_journal_refile_buffer(journal_t *, struct journal_head *);\nextern void __jbd2_journal_file_buffer(struct journal_head *, transaction_t *, int);\nextern void __journal_free_buffer(struct journal_head *bh);\nextern void jbd2_journal_file_buffer(struct journal_head *, transaction_t *, int);\nextern void __journal_clean_data_list(transaction_t *transaction);\nstatic inline void jbd2_file_log_bh(struct list_head *head, struct buffer_head *bh)\n{\n\tlist_add_tail(&bh->b_assoc_buffers, head);\n}\nstatic inline void jbd2_unfile_log_bh(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n}\n\n/* Log buffer allocation */\nstruct buffer_head *jbd2_journal_get_descriptor_buffer(transaction_t *, int);\nvoid jbd2_descriptor_block_csum_set(journal_t *, struct buffer_head *);\nint jbd2_journal_next_log_block(journal_t *, unsigned long long *);\nint jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,\n\t\t\t      unsigned long *block);\nint __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);\nvoid jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);\n\n/* Commit management */\nextern void jbd2_journal_commit_transaction(journal_t *);\n\n/* Checkpoint list management */\nvoid __jbd2_journal_clean_checkpoint_list(journal_t *journal, bool destroy);\nint __jbd2_journal_remove_checkpoint(struct journal_head *);\nvoid jbd2_journal_destroy_checkpoint(journal_t *journal);\nvoid __jbd2_journal_insert_checkpoint(struct journal_head *, transaction_t *);\n\n\n/*\n * Triggers\n */\n\nstruct jbd2_buffer_trigger_type {\n\t/*\n\t * Fired a the moment data to write to the journal are known to be\n\t * stable - so either at the moment b_frozen_data is created or just\n\t * before a buffer is written to the journal.  mapped_data is a mapped\n\t * buffer that is the frozen data for commit.\n\t */\n\tvoid (*t_frozen)(struct jbd2_buffer_trigger_type *type,\n\t\t\t struct buffer_head *bh, void *mapped_data,\n\t\t\t size_t size);\n\n\t/*\n\t * Fired during journal abort for dirty buffers that will not be\n\t * committed.\n\t */\n\tvoid (*t_abort)(struct jbd2_buffer_trigger_type *type,\n\t\t\tstruct buffer_head *bh);\n};\n\nextern void jbd2_buffer_frozen_trigger(struct journal_head *jh,\n\t\t\t\t       void *mapped_data,\n\t\t\t\t       struct jbd2_buffer_trigger_type *triggers);\nextern void jbd2_buffer_abort_trigger(struct journal_head *jh,\n\t\t\t\t      struct jbd2_buffer_trigger_type *triggers);\n\n/* Buffer IO */\nextern int jbd2_journal_write_metadata_buffer(transaction_t *transaction,\n\t\t\t\t\t      struct journal_head *jh_in,\n\t\t\t\t\t      struct buffer_head **bh_out,\n\t\t\t\t\t      sector_t blocknr);\n\n/* Transaction locking */\nextern void\t\t__wait_on_journal (journal_t *);\n\n/* Transaction cache support */\nextern void jbd2_journal_destroy_transaction_cache(void);\nextern int __init jbd2_journal_init_transaction_cache(void);\nextern void jbd2_journal_free_transaction(transaction_t *);\n\n/*\n * Journal locking.\n *\n * We need to lock the journal during transaction state changes so that nobody\n * ever tries to take a handle on the running transaction while we are in the\n * middle of moving it to the commit phase.  j_state_lock does this.\n *\n * Note that the locking is completely interrupt unsafe.  We never touch\n * journal structures from interrupts.\n */\n\nstatic inline handle_t *journal_current_handle(void)\n{\n\treturn current->journal_info;\n}\n\n/* The journaling code user interface:\n *\n * Create and destroy handles\n * Register buffer modifications against the current transaction.\n */\n\nextern handle_t *jbd2_journal_start(journal_t *, int nblocks);\nextern handle_t *jbd2__journal_start(journal_t *, int blocks, int rsv_blocks,\n\t\t\t\t     int revoke_records, gfp_t gfp_mask,\n\t\t\t\t     unsigned int type, unsigned int line_no);\nextern int\t jbd2_journal_restart(handle_t *, int nblocks);\nextern int\t jbd2__journal_restart(handle_t *, int nblocks,\n\t\t\t\t       int revoke_records, gfp_t gfp_mask);\nextern int\t jbd2_journal_start_reserved(handle_t *handle,\n\t\t\t\tunsigned int type, unsigned int line_no);\nextern void\t jbd2_journal_free_reserved(handle_t *handle);\nextern int\t jbd2_journal_extend(handle_t *handle, int nblocks,\n\t\t\t\t     int revoke_records);\nextern int\t jbd2_journal_get_write_access(handle_t *, struct buffer_head *);\nextern int\t jbd2_journal_get_create_access (handle_t *, struct buffer_head *);\nextern int\t jbd2_journal_get_undo_access(handle_t *, struct buffer_head *);\nvoid\t\t jbd2_journal_set_triggers(struct buffer_head *,\n\t\t\t\t\t   struct jbd2_buffer_trigger_type *type);\nextern int\t jbd2_journal_dirty_metadata (handle_t *, struct buffer_head *);\nextern int\t jbd2_journal_forget (handle_t *, struct buffer_head *);\nextern int\t jbd2_journal_invalidatepage(journal_t *,\n\t\t\t\tstruct page *, unsigned int, unsigned int);\nextern int\t jbd2_journal_try_to_free_buffers(journal_t *journal, struct page *page);\nextern int\t jbd2_journal_stop(handle_t *);\nextern int\t jbd2_journal_flush (journal_t *);\nextern void\t jbd2_journal_lock_updates (journal_t *);\nextern void\t jbd2_journal_unlock_updates (journal_t *);\n\nextern journal_t * jbd2_journal_init_dev(struct block_device *bdev,\n\t\t\t\tstruct block_device *fs_dev,\n\t\t\t\tunsigned long long start, int len, int bsize);\nextern journal_t * jbd2_journal_init_inode (struct inode *);\nextern int\t   jbd2_journal_update_format (journal_t *);\nextern int\t   jbd2_journal_check_used_features\n\t\t   (journal_t *, unsigned long, unsigned long, unsigned long);\nextern int\t   jbd2_journal_check_available_features\n\t\t   (journal_t *, unsigned long, unsigned long, unsigned long);\nextern int\t   jbd2_journal_set_features\n\t\t   (journal_t *, unsigned long, unsigned long, unsigned long);\nextern void\t   jbd2_journal_clear_features\n\t\t   (journal_t *, unsigned long, unsigned long, unsigned long);\nextern int\t   jbd2_journal_load       (journal_t *journal);\nextern int\t   jbd2_journal_destroy    (journal_t *);\nextern int\t   jbd2_journal_recover    (journal_t *journal);\nextern int\t   jbd2_journal_wipe       (journal_t *, int);\nextern int\t   jbd2_journal_skip_recovery\t(journal_t *);\nextern void\t   jbd2_journal_update_sb_errno(journal_t *);\nextern int\t   jbd2_journal_update_sb_log_tail\t(journal_t *, tid_t,\n\t\t\t\tunsigned long, int);\nextern void\t   jbd2_journal_abort      (journal_t *, int);\nextern int\t   jbd2_journal_errno      (journal_t *);\nextern void\t   jbd2_journal_ack_err    (journal_t *);\nextern int\t   jbd2_journal_clear_err  (journal_t *);\nextern int\t   jbd2_journal_bmap(journal_t *, unsigned long, unsigned long long *);\nextern int\t   jbd2_journal_force_commit(journal_t *);\nextern int\t   jbd2_journal_force_commit_nested(journal_t *);\nextern int\t   jbd2_journal_inode_ranged_write(handle_t *handle,\n\t\t\tstruct jbd2_inode *inode, loff_t start_byte,\n\t\t\tloff_t length);\nextern int\t   jbd2_journal_inode_ranged_wait(handle_t *handle,\n\t\t\tstruct jbd2_inode *inode, loff_t start_byte,\n\t\t\tloff_t length);\nextern int\t   jbd2_journal_submit_inode_data_buffers(\n\t\t\tstruct jbd2_inode *jinode);\nextern int\t   jbd2_journal_finish_inode_data_buffers(\n\t\t\tstruct jbd2_inode *jinode);\nextern int\t   jbd2_journal_begin_ordered_truncate(journal_t *journal,\n\t\t\t\tstruct jbd2_inode *inode, loff_t new_size);\nextern void\t   jbd2_journal_init_jbd_inode(struct jbd2_inode *jinode, struct inode *inode);\nextern void\t   jbd2_journal_release_jbd_inode(journal_t *journal, struct jbd2_inode *jinode);\n\n/*\n * journal_head management\n */\nstruct journal_head *jbd2_journal_add_journal_head(struct buffer_head *bh);\nstruct journal_head *jbd2_journal_grab_journal_head(struct buffer_head *bh);\nvoid jbd2_journal_put_journal_head(struct journal_head *jh);\n\n/*\n * handle management\n */\nextern struct kmem_cache *jbd2_handle_cache;\n\nstatic inline handle_t *jbd2_alloc_handle(gfp_t gfp_flags)\n{\n\treturn kmem_cache_zalloc(jbd2_handle_cache, gfp_flags);\n}\n\nstatic inline void jbd2_free_handle(handle_t *handle)\n{\n\tkmem_cache_free(jbd2_handle_cache, handle);\n}\n\n/*\n * jbd2_inode management (optional, for those file systems that want to use\n * dynamically allocated jbd2_inode structures)\n */\nextern struct kmem_cache *jbd2_inode_cache;\n\nstatic inline struct jbd2_inode *jbd2_alloc_inode(gfp_t gfp_flags)\n{\n\treturn kmem_cache_alloc(jbd2_inode_cache, gfp_flags);\n}\n\nstatic inline void jbd2_free_inode(struct jbd2_inode *jinode)\n{\n\tkmem_cache_free(jbd2_inode_cache, jinode);\n}\n\n/* Primary revoke support */\n#define JOURNAL_REVOKE_DEFAULT_HASH 256\nextern int\t   jbd2_journal_init_revoke(journal_t *, int);\nextern void\t   jbd2_journal_destroy_revoke_record_cache(void);\nextern void\t   jbd2_journal_destroy_revoke_table_cache(void);\nextern int __init jbd2_journal_init_revoke_record_cache(void);\nextern int __init jbd2_journal_init_revoke_table_cache(void);\n\nextern void\t   jbd2_journal_destroy_revoke(journal_t *);\nextern int\t   jbd2_journal_revoke (handle_t *, unsigned long long, struct buffer_head *);\nextern int\t   jbd2_journal_cancel_revoke(handle_t *, struct journal_head *);\nextern void\t   jbd2_journal_write_revoke_records(transaction_t *transaction,\n\t\t\t\t\t\t     struct list_head *log_bufs);\n\n/* Recovery revoke support */\nextern int\tjbd2_journal_set_revoke(journal_t *, unsigned long long, tid_t);\nextern int\tjbd2_journal_test_revoke(journal_t *, unsigned long long, tid_t);\nextern void\tjbd2_journal_clear_revoke(journal_t *);\nextern void\tjbd2_journal_switch_revoke_table(journal_t *journal);\nextern void\tjbd2_clear_buffer_revoked_flags(journal_t *journal);\n\n/*\n * The log thread user interface:\n *\n * Request space in the current transaction, and force transaction commit\n * transitions on demand.\n */\n\nint jbd2_log_start_commit(journal_t *journal, tid_t tid);\nint __jbd2_log_start_commit(journal_t *journal, tid_t tid);\nint jbd2_journal_start_commit(journal_t *journal, tid_t *tid);\nint jbd2_log_wait_commit(journal_t *journal, tid_t tid);\nint jbd2_transaction_committed(journal_t *journal, tid_t tid);\nint jbd2_complete_transaction(journal_t *journal, tid_t tid);\nint jbd2_log_do_checkpoint(journal_t *journal);\nint jbd2_trans_will_send_data_barrier(journal_t *journal, tid_t tid);\n\nvoid __jbd2_log_wait_for_space(journal_t *journal);\nextern void __jbd2_journal_drop_transaction(journal_t *, transaction_t *);\nextern int jbd2_cleanup_journal_tail(journal_t *);\n\n/* Fast commit related APIs */\nint jbd2_fc_begin_commit(journal_t *journal, tid_t tid);\nint jbd2_fc_end_commit(journal_t *journal);\nint jbd2_fc_end_commit_fallback(journal_t *journal);\nint jbd2_fc_get_buf(journal_t *journal, struct buffer_head **bh_out);\nint jbd2_submit_inode_data(struct jbd2_inode *jinode);\nint jbd2_wait_inode_data(journal_t *journal, struct jbd2_inode *jinode);\nint jbd2_fc_wait_bufs(journal_t *journal, int num_blks);\nint jbd2_fc_release_bufs(journal_t *journal);\n\nstatic inline int jbd2_journal_get_max_txn_bufs(journal_t *journal)\n{\n\treturn (journal->j_total_len - journal->j_fc_wbufsize) / 4;\n}\n\n/*\n * is_journal_abort\n *\n * Simple test wrapper function to test the JBD2_ABORT state flag.  This\n * bit, when set, indicates that we have had a fatal error somewhere,\n * either inside the journaling layer or indicated to us by the client\n * (eg. ext3), and that we and should not commit any further\n * transactions.\n */\n\nstatic inline int is_journal_aborted(journal_t *journal)\n{\n\treturn journal->j_flags & JBD2_ABORT;\n}\n\nstatic inline int is_handle_aborted(handle_t *handle)\n{\n\tif (handle->h_aborted || !handle->h_transaction)\n\t\treturn 1;\n\treturn is_journal_aborted(handle->h_transaction->t_journal);\n}\n\nstatic inline void jbd2_journal_abort_handle(handle_t *handle)\n{\n\thandle->h_aborted = 1;\n}\n\n#endif /* __KERNEL__   */\n\n/* Comparison functions for transaction IDs: perform comparisons using\n * modulo arithmetic so that they work over sequence number wraps. */\n\nstatic inline int tid_gt(tid_t x, tid_t y)\n{\n\tint difference = (x - y);\n\treturn (difference > 0);\n}\n\nstatic inline int tid_geq(tid_t x, tid_t y)\n{\n\tint difference = (x - y);\n\treturn (difference >= 0);\n}\n\nextern int jbd2_journal_blocks_per_page(struct inode *inode);\nextern size_t journal_tag_bytes(journal_t *journal);\n\nstatic inline bool jbd2_journal_has_csum_v2or3_feature(journal_t *j)\n{\n\treturn jbd2_has_feature_csum2(j) || jbd2_has_feature_csum3(j);\n}\n\nstatic inline int jbd2_journal_has_csum_v2or3(journal_t *journal)\n{\n\tWARN_ON_ONCE(jbd2_journal_has_csum_v2or3_feature(journal) &&\n\t\t     journal->j_chksum_driver == NULL);\n\n\treturn journal->j_chksum_driver != NULL;\n}\n\nstatic inline int jbd2_journal_get_num_fc_blks(journal_superblock_t *jsb)\n{\n\tint num_fc_blocks = be32_to_cpu(jsb->s_num_fc_blks);\n\n\treturn num_fc_blocks ? num_fc_blocks : JBD2_DEFAULT_FAST_COMMIT_BLOCKS;\n}\n\n/*\n * Return number of free blocks in the log. Must be called under j_state_lock.\n */\nstatic inline unsigned long jbd2_log_space_left(journal_t *journal)\n{\n\t/* Allow for rounding errors */\n\tlong free = journal->j_free - 32;\n\n\tif (journal->j_committing_transaction) {\n\t\tfree -= atomic_read(&journal->\n                        j_committing_transaction->t_outstanding_credits);\n\t}\n\treturn max_t(long, free, 0);\n}\n\n/*\n * Definitions which augment the buffer_head layer\n */\n\n/* journaling buffer types */\n#define BJ_None\t\t0\t/* Not journaled */\n#define BJ_Metadata\t1\t/* Normal journaled metadata */\n#define BJ_Forget\t2\t/* Buffer superseded by this transaction */\n#define BJ_Shadow\t3\t/* Buffer contents being shadowed to the log */\n#define BJ_Reserved\t4\t/* Buffer is reserved for access by journal */\n#define BJ_Types\t5\n\nextern int jbd_blocks_per_page(struct inode *inode);\n\n/* JBD uses a CRC32 checksum */\n#define JBD_MAX_CHECKSUM_SIZE 4\n\nstatic inline u32 jbd2_chksum(journal_t *journal, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[JBD_MAX_CHECKSUM_SIZE];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(journal->j_chksum_driver) >\n\t\tJBD_MAX_CHECKSUM_SIZE);\n\n\tdesc.shash.tfm = journal->j_chksum_driver;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}\n\n/* Return most recent uncommitted transaction */\nstatic inline tid_t  jbd2_get_latest_transaction(journal_t *journal)\n{\n\ttid_t tid;\n\n\tread_lock(&journal->j_state_lock);\n\ttid = journal->j_commit_request;\n\tif (journal->j_running_transaction)\n\t\ttid = journal->j_running_transaction->t_tid;\n\tread_unlock(&journal->j_state_lock);\n\treturn tid;\n}\n\nstatic inline int jbd2_handle_buffer_credits(handle_t *handle)\n{\n\tjournal_t *journal;\n\n\tif (!handle->h_reserved)\n\t\tjournal = handle->h_transaction->t_journal;\n\telse\n\t\tjournal = handle->h_journal;\n\n\treturn handle->h_total_credits -\n\t\tDIV_ROUND_UP(handle->h_revoke_credits_requested,\n\t\t\t     journal->j_revoke_records_per_block);\n}\n\n#ifdef __KERNEL__\n\n#define buffer_trace_init(bh)\tdo {} while (0)\n#define print_buffer_fields(bh)\tdo {} while (0)\n#define print_buffer_trace(bh)\tdo {} while (0)\n#define BUFFER_TRACE(bh, info)\tdo {} while (0)\n#define BUFFER_TRACE2(bh, bh2, info)\tdo {} while (0)\n#define JBUFFER_TRACE(jh, info)\tdo {} while (0)\n\n#endif\t/* __KERNEL__ */\n\n#define EFSBADCRC\tEBADMSG\t\t/* Bad CRC detected */\n#define EFSCORRUPTED\tEUCLEAN\t\t/* Filesystem is corrupted */\n\n#endif\t/* _LINUX_JBD2_H */\n"}, "8": {"id": 8, "path": "/src/include/linux/rcupdate.h", "content": "/* SPDX-License-Identifier: GPL-2.0+ */\n/*\n * Read-Copy Update mechanism for mutual exclusion\n *\n * Copyright IBM Corporation, 2001\n *\n * Author: Dipankar Sarma <dipankar@in.ibm.com>\n *\n * Based on the original work by Paul McKenney <paulmck@vnet.ibm.com>\n * and inputs from Rusty Russell, Andrea Arcangeli and Andi Kleen.\n * Papers:\n * http://www.rdrop.com/users/paulmck/paper/rclockpdcsproof.pdf\n * http://lse.sourceforge.net/locking/rclock_OLS.2001.05.01c.sc.pdf (OLS2001)\n *\n * For detailed explanation of Read-Copy Update mechanism see -\n *\t\thttp://lse.sourceforge.net/locking/rcupdate.html\n *\n */\n\n#ifndef __LINUX_RCUPDATE_H\n#define __LINUX_RCUPDATE_H\n\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/irqflags.h>\n#include <linux/preempt.h>\n#include <linux/bottom_half.h>\n#include <linux/lockdep.h>\n#include <asm/processor.h>\n#include <linux/cpumask.h>\n\n#define ULONG_CMP_GE(a, b)\t(ULONG_MAX / 2 >= (a) - (b))\n#define ULONG_CMP_LT(a, b)\t(ULONG_MAX / 2 < (a) - (b))\n#define ulong2long(a)\t\t(*(long *)(&(a)))\n#define USHORT_CMP_GE(a, b)\t(USHRT_MAX / 2 >= (unsigned short)((a) - (b)))\n#define USHORT_CMP_LT(a, b)\t(USHRT_MAX / 2 < (unsigned short)((a) - (b)))\n\n/* Exported common interfaces */\nvoid call_rcu(struct rcu_head *head, rcu_callback_t func);\nvoid rcu_barrier_tasks(void);\nvoid rcu_barrier_tasks_rude(void);\nvoid synchronize_rcu(void);\n\n#ifdef CONFIG_PREEMPT_RCU\n\nvoid __rcu_read_lock(void);\nvoid __rcu_read_unlock(void);\n\n/*\n * Defined as a macro as it is a very low level header included from\n * areas that don't even know about current.  This gives the rcu_read_lock()\n * nesting depth, but makes sense only if CONFIG_PREEMPT_RCU -- in other\n * types of kernel builds, the rcu_read_lock() nesting depth is unknowable.\n */\n#define rcu_preempt_depth() (current->rcu_read_lock_nesting)\n\n#else /* #ifdef CONFIG_PREEMPT_RCU */\n\n#ifdef CONFIG_TINY_RCU\n#define rcu_read_unlock_strict() do { } while (0)\n#else\nvoid rcu_read_unlock_strict(void);\n#endif\n\nstatic inline void __rcu_read_lock(void)\n{\n\tpreempt_disable();\n}\n\nstatic inline void __rcu_read_unlock(void)\n{\n\tpreempt_enable();\n\trcu_read_unlock_strict();\n}\n\nstatic inline int rcu_preempt_depth(void)\n{\n\treturn 0;\n}\n\n#endif /* #else #ifdef CONFIG_PREEMPT_RCU */\n\n/* Internal to kernel */\nvoid rcu_init(void);\nextern int rcu_scheduler_active __read_mostly;\nvoid rcu_sched_clock_irq(int user);\nvoid rcu_report_dead(unsigned int cpu);\nvoid rcutree_migrate_callbacks(int cpu);\n\n#ifdef CONFIG_TASKS_RCU_GENERIC\nvoid rcu_init_tasks_generic(void);\n#else\nstatic inline void rcu_init_tasks_generic(void) { }\n#endif\n\n#ifdef CONFIG_RCU_STALL_COMMON\nvoid rcu_sysrq_start(void);\nvoid rcu_sysrq_end(void);\n#else /* #ifdef CONFIG_RCU_STALL_COMMON */\nstatic inline void rcu_sysrq_start(void) { }\nstatic inline void rcu_sysrq_end(void) { }\n#endif /* #else #ifdef CONFIG_RCU_STALL_COMMON */\n\n#ifdef CONFIG_NO_HZ_FULL\nvoid rcu_user_enter(void);\nvoid rcu_user_exit(void);\n#else\nstatic inline void rcu_user_enter(void) { }\nstatic inline void rcu_user_exit(void) { }\n#endif /* CONFIG_NO_HZ_FULL */\n\n#ifdef CONFIG_RCU_NOCB_CPU\nvoid rcu_init_nohz(void);\nint rcu_nocb_cpu_offload(int cpu);\nint rcu_nocb_cpu_deoffload(int cpu);\nvoid rcu_nocb_flush_deferred_wakeup(void);\n#else /* #ifdef CONFIG_RCU_NOCB_CPU */\nstatic inline void rcu_init_nohz(void) { }\nstatic inline int rcu_nocb_cpu_offload(int cpu) { return -EINVAL; }\nstatic inline int rcu_nocb_cpu_deoffload(int cpu) { return 0; }\nstatic inline void rcu_nocb_flush_deferred_wakeup(void) { }\n#endif /* #else #ifdef CONFIG_RCU_NOCB_CPU */\n\n/**\n * RCU_NONIDLE - Indicate idle-loop code that needs RCU readers\n * @a: Code that RCU needs to pay attention to.\n *\n * RCU read-side critical sections are forbidden in the inner idle loop,\n * that is, between the rcu_idle_enter() and the rcu_idle_exit() -- RCU\n * will happily ignore any such read-side critical sections.  However,\n * things like powertop need tracepoints in the inner idle loop.\n *\n * This macro provides the way out:  RCU_NONIDLE(do_something_with_RCU())\n * will tell RCU that it needs to pay attention, invoke its argument\n * (in this example, calling the do_something_with_RCU() function),\n * and then tell RCU to go back to ignoring this CPU.  It is permissible\n * to nest RCU_NONIDLE() wrappers, but not indefinitely (but the limit is\n * on the order of a million or so, even on 32-bit systems).  It is\n * not legal to block within RCU_NONIDLE(), nor is it permissible to\n * transfer control either into or out of RCU_NONIDLE()'s statement.\n */\n#define RCU_NONIDLE(a) \\\n\tdo { \\\n\t\trcu_irq_enter_irqson(); \\\n\t\tdo { a; } while (0); \\\n\t\trcu_irq_exit_irqson(); \\\n\t} while (0)\n\n/*\n * Note a quasi-voluntary context switch for RCU-tasks's benefit.\n * This is a macro rather than an inline function to avoid #include hell.\n */\n#ifdef CONFIG_TASKS_RCU_GENERIC\n\n# ifdef CONFIG_TASKS_RCU\n# define rcu_tasks_classic_qs(t, preempt)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!(preempt) && READ_ONCE((t)->rcu_tasks_holdout))\t\\\n\t\t\tWRITE_ONCE((t)->rcu_tasks_holdout, false);\t\\\n\t} while (0)\nvoid call_rcu_tasks(struct rcu_head *head, rcu_callback_t func);\nvoid synchronize_rcu_tasks(void);\n# else\n# define rcu_tasks_classic_qs(t, preempt) do { } while (0)\n# define call_rcu_tasks call_rcu\n# define synchronize_rcu_tasks synchronize_rcu\n# endif\n\n# ifdef CONFIG_TASKS_RCU_TRACE\n# define rcu_tasks_trace_qs(t)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!likely(READ_ONCE((t)->trc_reader_checked)) &&\t\\\n\t\t    !unlikely(READ_ONCE((t)->trc_reader_nesting))) {\t\\\n\t\t\tsmp_store_release(&(t)->trc_reader_checked, true); \\\n\t\t\tsmp_mb(); /* Readers partitioned by store. */\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n# else\n# define rcu_tasks_trace_qs(t) do { } while (0)\n# endif\n\n#define rcu_tasks_qs(t, preempt)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\trcu_tasks_classic_qs((t), (preempt));\t\t\t\t\\\n\trcu_tasks_trace_qs((t));\t\t\t\t\t\\\n} while (0)\n\n# ifdef CONFIG_TASKS_RUDE_RCU\nvoid call_rcu_tasks_rude(struct rcu_head *head, rcu_callback_t func);\nvoid synchronize_rcu_tasks_rude(void);\n# endif\n\n#define rcu_note_voluntary_context_switch(t) rcu_tasks_qs(t, false)\nvoid exit_tasks_rcu_start(void);\nvoid exit_tasks_rcu_finish(void);\n#else /* #ifdef CONFIG_TASKS_RCU_GENERIC */\n#define rcu_tasks_qs(t, preempt) do { } while (0)\n#define rcu_note_voluntary_context_switch(t) do { } while (0)\n#define call_rcu_tasks call_rcu\n#define synchronize_rcu_tasks synchronize_rcu\nstatic inline void exit_tasks_rcu_start(void) { }\nstatic inline void exit_tasks_rcu_finish(void) { }\n#endif /* #else #ifdef CONFIG_TASKS_RCU_GENERIC */\n\n/**\n * cond_resched_tasks_rcu_qs - Report potential quiescent states to RCU\n *\n * This macro resembles cond_resched(), except that it is defined to\n * report potential quiescent states to RCU-tasks even if the cond_resched()\n * machinery were to be shut off, as some advocate for PREEMPTION kernels.\n */\n#define cond_resched_tasks_rcu_qs() \\\ndo { \\\n\trcu_tasks_qs(current, false); \\\n\tcond_resched(); \\\n} while (0)\n\n/*\n * Infrastructure to implement the synchronize_() primitives in\n * TREE_RCU and rcu_barrier_() primitives in TINY_RCU.\n */\n\n#if defined(CONFIG_TREE_RCU)\n#include <linux/rcutree.h>\n#elif defined(CONFIG_TINY_RCU)\n#include <linux/rcutiny.h>\n#else\n#error \"Unknown RCU implementation specified to kernel configuration\"\n#endif\n\n/*\n * The init_rcu_head_on_stack() and destroy_rcu_head_on_stack() calls\n * are needed for dynamic initialization and destruction of rcu_head\n * on the stack, and init_rcu_head()/destroy_rcu_head() are needed for\n * dynamic initialization and destruction of statically allocated rcu_head\n * structures.  However, rcu_head structures allocated dynamically in the\n * heap don't need any initialization.\n */\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\nvoid init_rcu_head(struct rcu_head *head);\nvoid destroy_rcu_head(struct rcu_head *head);\nvoid init_rcu_head_on_stack(struct rcu_head *head);\nvoid destroy_rcu_head_on_stack(struct rcu_head *head);\n#else /* !CONFIG_DEBUG_OBJECTS_RCU_HEAD */\nstatic inline void init_rcu_head(struct rcu_head *head) { }\nstatic inline void destroy_rcu_head(struct rcu_head *head) { }\nstatic inline void init_rcu_head_on_stack(struct rcu_head *head) { }\nstatic inline void destroy_rcu_head_on_stack(struct rcu_head *head) { }\n#endif\t/* #else !CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n\n#if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU)\nbool rcu_lockdep_current_cpu_online(void);\n#else /* #if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU) */\nstatic inline bool rcu_lockdep_current_cpu_online(void) { return true; }\n#endif /* #else #if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU) */\n\nextern struct lockdep_map rcu_lock_map;\nextern struct lockdep_map rcu_bh_lock_map;\nextern struct lockdep_map rcu_sched_lock_map;\nextern struct lockdep_map rcu_callback_map;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\nstatic inline void rcu_lock_acquire(struct lockdep_map *map)\n{\n\tlock_acquire(map, 0, 0, 2, 0, NULL, _THIS_IP_);\n}\n\nstatic inline void rcu_lock_release(struct lockdep_map *map)\n{\n\tlock_release(map, _THIS_IP_);\n}\n\nint debug_lockdep_rcu_enabled(void);\nint rcu_read_lock_held(void);\nint rcu_read_lock_bh_held(void);\nint rcu_read_lock_sched_held(void);\nint rcu_read_lock_any_held(void);\n\n#else /* #ifdef CONFIG_DEBUG_LOCK_ALLOC */\n\n# define rcu_lock_acquire(a)\t\tdo { } while (0)\n# define rcu_lock_release(a)\t\tdo { } while (0)\n\nstatic inline int rcu_read_lock_held(void)\n{\n\treturn 1;\n}\n\nstatic inline int rcu_read_lock_bh_held(void)\n{\n\treturn 1;\n}\n\nstatic inline int rcu_read_lock_sched_held(void)\n{\n\treturn !preemptible();\n}\n\nstatic inline int rcu_read_lock_any_held(void)\n{\n\treturn !preemptible();\n}\n\n#endif /* #else #ifdef CONFIG_DEBUG_LOCK_ALLOC */\n\n#ifdef CONFIG_PROVE_RCU\n\n/**\n * RCU_LOCKDEP_WARN - emit lockdep splat if specified condition is met\n * @c: condition to check\n * @s: informative message\n */\n#define RCU_LOCKDEP_WARN(c, s)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstatic bool __section(\".data.unlikely\") __warned;\t\\\n\t\tif (debug_lockdep_rcu_enabled() && !__warned && (c)) {\t\\\n\t\t\t__warned = true;\t\t\t\t\\\n\t\t\tlockdep_rcu_suspicious(__FILE__, __LINE__, s);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#if defined(CONFIG_PROVE_RCU) && !defined(CONFIG_PREEMPT_RCU)\nstatic inline void rcu_preempt_sleep_check(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_lock_map),\n\t\t\t \"Illegal context switch in RCU read-side critical section\");\n}\n#else /* #ifdef CONFIG_PROVE_RCU */\nstatic inline void rcu_preempt_sleep_check(void) { }\n#endif /* #else #ifdef CONFIG_PROVE_RCU */\n\n#define rcu_sleep_check()\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\trcu_preempt_sleep_check();\t\t\t\t\\\n\t\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map),\t\\\n\t\t\t\t \"Illegal context switch in RCU-bh read-side critical section\"); \\\n\t\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_sched_lock_map),\t\\\n\t\t\t\t \"Illegal context switch in RCU-sched read-side critical section\"); \\\n\t} while (0)\n\n#else /* #ifdef CONFIG_PROVE_RCU */\n\n#define RCU_LOCKDEP_WARN(c, s) do { } while (0 && (c))\n#define rcu_sleep_check() do { } while (0)\n\n#endif /* #else #ifdef CONFIG_PROVE_RCU */\n\n/*\n * Helper functions for rcu_dereference_check(), rcu_dereference_protected()\n * and rcu_assign_pointer().  Some of these could be folded into their\n * callers, but they are left separate in order to ease introduction of\n * multiple pointers markings to match different RCU implementations\n * (e.g., __srcu), should this make sense in the future.\n */\n\n#ifdef __CHECKER__\n#define rcu_check_sparse(p, space) \\\n\t((void)(((typeof(*p) space *)p) == p))\n#else /* #ifdef __CHECKER__ */\n#define rcu_check_sparse(p, space)\n#endif /* #else #ifdef __CHECKER__ */\n\n#define __rcu_access_pointer(p, space) \\\n({ \\\n\ttypeof(*p) *_________p1 = (typeof(*p) *__force)READ_ONCE(p); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(_________p1)); \\\n})\n#define __rcu_dereference_check(p, c, space) \\\n({ \\\n\t/* Dependency order vs. p above. */ \\\n\ttypeof(*p) *________p1 = (typeof(*p) *__force)READ_ONCE(p); \\\n\tRCU_LOCKDEP_WARN(!(c), \"suspicious rcu_dereference_check() usage\"); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(________p1)); \\\n})\n#define __rcu_dereference_protected(p, c, space) \\\n({ \\\n\tRCU_LOCKDEP_WARN(!(c), \"suspicious rcu_dereference_protected() usage\"); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(p)); \\\n})\n#define rcu_dereference_raw(p) \\\n({ \\\n\t/* Dependency order vs. p above. */ \\\n\ttypeof(p) ________p1 = READ_ONCE(p); \\\n\t((typeof(*p) __force __kernel *)(________p1)); \\\n})\n\n/**\n * RCU_INITIALIZER() - statically initialize an RCU-protected global variable\n * @v: The value to statically initialize with.\n */\n#define RCU_INITIALIZER(v) (typeof(*(v)) __force __rcu *)(v)\n\n/**\n * rcu_assign_pointer() - assign to RCU-protected pointer\n * @p: pointer to assign to\n * @v: value to assign (publish)\n *\n * Assigns the specified value to the specified RCU-protected\n * pointer, ensuring that any concurrent RCU readers will see\n * any prior initialization.\n *\n * Inserts memory barriers on architectures that require them\n * (which is most of them), and also prevents the compiler from\n * reordering the code that initializes the structure after the pointer\n * assignment.  More importantly, this call documents which pointers\n * will be dereferenced by RCU read-side code.\n *\n * In some special cases, you may use RCU_INIT_POINTER() instead\n * of rcu_assign_pointer().  RCU_INIT_POINTER() is a bit faster due\n * to the fact that it does not constrain either the CPU or the compiler.\n * That said, using RCU_INIT_POINTER() when you should have used\n * rcu_assign_pointer() is a very bad thing that results in\n * impossible-to-diagnose memory corruption.  So please be careful.\n * See the RCU_INIT_POINTER() comment header for details.\n *\n * Note that rcu_assign_pointer() evaluates each of its arguments only\n * once, appearances notwithstanding.  One of the \"extra\" evaluations\n * is in typeof() and the other visible only to sparse (__CHECKER__),\n * neither of which actually execute the argument.  As with most cpp\n * macros, this execute-arguments-only-once property is important, so\n * please be careful when making changes to rcu_assign_pointer() and the\n * other macros that it invokes.\n */\n#define rcu_assign_pointer(p, v)\t\t\t\t\t      \\\ndo {\t\t\t\t\t\t\t\t\t      \\\n\tuintptr_t _r_a_p__v = (uintptr_t)(v);\t\t\t\t      \\\n\trcu_check_sparse(p, __rcu);\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (__builtin_constant_p(v) && (_r_a_p__v) == (uintptr_t)NULL)\t      \\\n\t\tWRITE_ONCE((p), (typeof(p))(_r_a_p__v));\t\t      \\\n\telse\t\t\t\t\t\t\t\t      \\\n\t\tsmp_store_release(&p, RCU_INITIALIZER((typeof(p))_r_a_p__v)); \\\n} while (0)\n\n/**\n * rcu_replace_pointer() - replace an RCU pointer, returning its old value\n * @rcu_ptr: RCU pointer, whose old value is returned\n * @ptr: regular pointer\n * @c: the lockdep conditions under which the dereference will take place\n *\n * Perform a replacement, where @rcu_ptr is an RCU-annotated\n * pointer and @c is the lockdep argument that is passed to the\n * rcu_dereference_protected() call used to read that pointer.  The old\n * value of @rcu_ptr is returned, and @rcu_ptr is set to @ptr.\n */\n#define rcu_replace_pointer(rcu_ptr, ptr, c)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(ptr) __tmp = rcu_dereference_protected((rcu_ptr), (c));\t\\\n\trcu_assign_pointer((rcu_ptr), (ptr));\t\t\t\t\\\n\t__tmp;\t\t\t\t\t\t\t\t\\\n})\n\n/**\n * rcu_access_pointer() - fetch RCU pointer with no dereferencing\n * @p: The pointer to read\n *\n * Return the value of the specified RCU-protected pointer, but omit the\n * lockdep checks for being in an RCU read-side critical section.  This is\n * useful when the value of this pointer is accessed, but the pointer is\n * not dereferenced, for example, when testing an RCU-protected pointer\n * against NULL.  Although rcu_access_pointer() may also be used in cases\n * where update-side locks prevent the value of the pointer from changing,\n * you should instead use rcu_dereference_protected() for this use case.\n *\n * It is also permissible to use rcu_access_pointer() when read-side\n * access to the pointer was removed at least one grace period ago, as\n * is the case in the context of the RCU callback that is freeing up\n * the data, or after a synchronize_rcu() returns.  This can be useful\n * when tearing down multi-linked structures after a grace period\n * has elapsed.\n */\n#define rcu_access_pointer(p) __rcu_access_pointer((p), __rcu)\n\n/**\n * rcu_dereference_check() - rcu_dereference with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * Do an rcu_dereference(), but check that the conditions under which the\n * dereference will take place are correct.  Typically the conditions\n * indicate the various locking conditions that should be held at that\n * point.  The check should return true if the conditions are satisfied.\n * An implicit check for being in an RCU read-side critical section\n * (rcu_read_lock()) is included.\n *\n * For example:\n *\n *\tbar = rcu_dereference_check(foo->bar, lockdep_is_held(&foo->lock));\n *\n * could be used to indicate to lockdep that foo->bar may only be dereferenced\n * if either rcu_read_lock() is held, or that the lock required to replace\n * the bar struct at foo->bar is held.\n *\n * Note that the list of conditions may also include indications of when a lock\n * need not be held, for example during initialisation or destruction of the\n * target struct:\n *\n *\tbar = rcu_dereference_check(foo->bar, lockdep_is_held(&foo->lock) ||\n *\t\t\t\t\t      atomic_read(&foo->usage) == 0);\n *\n * Inserts memory barriers on architectures that require them\n * (currently only the Alpha), prevents the compiler from refetching\n * (and from merging fetches), and, more importantly, documents exactly\n * which pointers are protected by RCU and checks that the pointer is\n * annotated as __rcu.\n */\n#define rcu_dereference_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_held(), __rcu)\n\n/**\n * rcu_dereference_bh_check() - rcu_dereference_bh with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * This is the RCU-bh counterpart to rcu_dereference_check().\n */\n#define rcu_dereference_bh_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_bh_held(), __rcu)\n\n/**\n * rcu_dereference_sched_check() - rcu_dereference_sched with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * This is the RCU-sched counterpart to rcu_dereference_check().\n */\n#define rcu_dereference_sched_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_sched_held(), \\\n\t\t\t\t__rcu)\n\n/*\n * The tracing infrastructure traces RCU (we want that), but unfortunately\n * some of the RCU checks causes tracing to lock up the system.\n *\n * The no-tracing version of rcu_dereference_raw() must not call\n * rcu_read_lock_held().\n */\n#define rcu_dereference_raw_check(p) __rcu_dereference_check((p), 1, __rcu)\n\n/**\n * rcu_dereference_protected() - fetch RCU pointer when updates prevented\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * Return the value of the specified RCU-protected pointer, but omit\n * the READ_ONCE().  This is useful in cases where update-side locks\n * prevent the value of the pointer from changing.  Please note that this\n * primitive does *not* prevent the compiler from repeating this reference\n * or combining it with other references, so it should not be used without\n * protection of appropriate locks.\n *\n * This function is only for update-side use.  Using this function\n * when protected only by rcu_read_lock() will result in infrequent\n * but very ugly failures.\n */\n#define rcu_dereference_protected(p, c) \\\n\t__rcu_dereference_protected((p), (c), __rcu)\n\n\n/**\n * rcu_dereference() - fetch RCU-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * This is a simple wrapper around rcu_dereference_check().\n */\n#define rcu_dereference(p) rcu_dereference_check(p, 0)\n\n/**\n * rcu_dereference_bh() - fetch an RCU-bh-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * Makes rcu_dereference_check() do the dirty work.\n */\n#define rcu_dereference_bh(p) rcu_dereference_bh_check(p, 0)\n\n/**\n * rcu_dereference_sched() - fetch RCU-sched-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * Makes rcu_dereference_check() do the dirty work.\n */\n#define rcu_dereference_sched(p) rcu_dereference_sched_check(p, 0)\n\n/**\n * rcu_pointer_handoff() - Hand off a pointer from RCU to other mechanism\n * @p: The pointer to hand off\n *\n * This is simply an identity function, but it documents where a pointer\n * is handed off from RCU to some other synchronization mechanism, for\n * example, reference counting or locking.  In C11, it would map to\n * kill_dependency().  It could be used as follows::\n *\n *\trcu_read_lock();\n *\tp = rcu_dereference(gp);\n *\tlong_lived = is_long_lived(p);\n *\tif (long_lived) {\n *\t\tif (!atomic_inc_not_zero(p->refcnt))\n *\t\t\tlong_lived = false;\n *\t\telse\n *\t\t\tp = rcu_pointer_handoff(p);\n *\t}\n *\trcu_read_unlock();\n */\n#define rcu_pointer_handoff(p) (p)\n\n/**\n * rcu_read_lock() - mark the beginning of an RCU read-side critical section\n *\n * When synchronize_rcu() is invoked on one CPU while other CPUs\n * are within RCU read-side critical sections, then the\n * synchronize_rcu() is guaranteed to block until after all the other\n * CPUs exit their critical sections.  Similarly, if call_rcu() is invoked\n * on one CPU while other CPUs are within RCU read-side critical\n * sections, invocation of the corresponding RCU callback is deferred\n * until after the all the other CPUs exit their critical sections.\n *\n * Note, however, that RCU callbacks are permitted to run concurrently\n * with new RCU read-side critical sections.  One way that this can happen\n * is via the following sequence of events: (1) CPU 0 enters an RCU\n * read-side critical section, (2) CPU 1 invokes call_rcu() to register\n * an RCU callback, (3) CPU 0 exits the RCU read-side critical section,\n * (4) CPU 2 enters a RCU read-side critical section, (5) the RCU\n * callback is invoked.  This is legal, because the RCU read-side critical\n * section that was running concurrently with the call_rcu() (and which\n * therefore might be referencing something that the corresponding RCU\n * callback would free up) has completed before the corresponding\n * RCU callback is invoked.\n *\n * RCU read-side critical sections may be nested.  Any deferred actions\n * will be deferred until the outermost RCU read-side critical section\n * completes.\n *\n * You can avoid reading and understanding the next paragraph by\n * following this rule: don't put anything in an rcu_read_lock() RCU\n * read-side critical section that would block in a !PREEMPTION kernel.\n * But if you want the full story, read on!\n *\n * In non-preemptible RCU implementations (pure TREE_RCU and TINY_RCU),\n * it is illegal to block while in an RCU read-side critical section.\n * In preemptible RCU implementations (PREEMPT_RCU) in CONFIG_PREEMPTION\n * kernel builds, RCU read-side critical sections may be preempted,\n * but explicit blocking is illegal.  Finally, in preemptible RCU\n * implementations in real-time (with -rt patchset) kernel builds, RCU\n * read-side critical sections may be preempted and they may also block, but\n * only when acquiring spinlocks that are subject to priority inheritance.\n */\nstatic __always_inline void rcu_read_lock(void)\n{\n\t__rcu_read_lock();\n\t__acquire(RCU);\n\trcu_lock_acquire(&rcu_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock() used illegally while idle\");\n}\n\n/*\n * So where is rcu_write_lock()?  It does not exist, as there is no\n * way for writers to lock out RCU readers.  This is a feature, not\n * a bug -- this property is what provides RCU's performance benefits.\n * Of course, writers must coordinate with each other.  The normal\n * spinlock primitives work well for this, but any other technique may be\n * used as well.  RCU does not care how the writers keep out of each\n * others' way, as long as they do so.\n */\n\n/**\n * rcu_read_unlock() - marks the end of an RCU read-side critical section.\n *\n * In most situations, rcu_read_unlock() is immune from deadlock.\n * However, in kernels built with CONFIG_RCU_BOOST, rcu_read_unlock()\n * is responsible for deboosting, which it does via rt_mutex_unlock().\n * Unfortunately, this function acquires the scheduler's runqueue and\n * priority-inheritance spinlocks.  This means that deadlock could result\n * if the caller of rcu_read_unlock() already holds one of these locks or\n * any lock that is ever acquired while holding them.\n *\n * That said, RCU readers are never priority boosted unless they were\n * preempted.  Therefore, one way to avoid deadlock is to make sure\n * that preemption never happens within any RCU read-side critical\n * section whose outermost rcu_read_unlock() is called with one of\n * rt_mutex_unlock()'s locks held.  Such preemption can be avoided in\n * a number of ways, for example, by invoking preempt_disable() before\n * critical section's outermost rcu_read_lock().\n *\n * Given that the set of locks acquired by rt_mutex_unlock() might change\n * at any time, a somewhat more future-proofed approach is to make sure\n * that that preemption never happens within any RCU read-side critical\n * section whose outermost rcu_read_unlock() is called with irqs disabled.\n * This approach relies on the fact that rt_mutex_unlock() currently only\n * acquires irq-disabled locks.\n *\n * The second of these two approaches is best in most situations,\n * however, the first approach can also be useful, at least to those\n * developers willing to keep abreast of the set of locks acquired by\n * rt_mutex_unlock().\n *\n * See rcu_read_lock() for more information.\n */\nstatic inline void rcu_read_unlock(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock() used illegally while idle\");\n\t__release(RCU);\n\t__rcu_read_unlock();\n\trcu_lock_release(&rcu_lock_map); /* Keep acq info for rls diags. */\n}\n\n/**\n * rcu_read_lock_bh() - mark the beginning of an RCU-bh critical section\n *\n * This is equivalent of rcu_read_lock(), but also disables softirqs.\n * Note that anything else that disables softirqs can also serve as\n * an RCU read-side critical section.\n *\n * Note that rcu_read_lock_bh() and the matching rcu_read_unlock_bh()\n * must occur in the same context, for example, it is illegal to invoke\n * rcu_read_unlock_bh() from one task if the matching rcu_read_lock_bh()\n * was invoked from some other task.\n */\nstatic inline void rcu_read_lock_bh(void)\n{\n\tlocal_bh_disable();\n\t__acquire(RCU_BH);\n\trcu_lock_acquire(&rcu_bh_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock_bh() used illegally while idle\");\n}\n\n/**\n * rcu_read_unlock_bh() - marks the end of a softirq-only RCU critical section\n *\n * See rcu_read_lock_bh() for more information.\n */\nstatic inline void rcu_read_unlock_bh(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock_bh() used illegally while idle\");\n\trcu_lock_release(&rcu_bh_lock_map);\n\t__release(RCU_BH);\n\tlocal_bh_enable();\n}\n\n/**\n * rcu_read_lock_sched() - mark the beginning of a RCU-sched critical section\n *\n * This is equivalent of rcu_read_lock(), but disables preemption.\n * Read-side critical sections can also be introduced by anything else\n * that disables preemption, including local_irq_disable() and friends.\n *\n * Note that rcu_read_lock_sched() and the matching rcu_read_unlock_sched()\n * must occur in the same context, for example, it is illegal to invoke\n * rcu_read_unlock_sched() from process context if the matching\n * rcu_read_lock_sched() was invoked from an NMI handler.\n */\nstatic inline void rcu_read_lock_sched(void)\n{\n\tpreempt_disable();\n\t__acquire(RCU_SCHED);\n\trcu_lock_acquire(&rcu_sched_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock_sched() used illegally while idle\");\n}\n\n/* Used by lockdep and tracing: cannot be traced, cannot call lockdep. */\nstatic inline notrace void rcu_read_lock_sched_notrace(void)\n{\n\tpreempt_disable_notrace();\n\t__acquire(RCU_SCHED);\n}\n\n/**\n * rcu_read_unlock_sched() - marks the end of a RCU-classic critical section\n *\n * See rcu_read_lock_sched() for more information.\n */\nstatic inline void rcu_read_unlock_sched(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock_sched() used illegally while idle\");\n\trcu_lock_release(&rcu_sched_lock_map);\n\t__release(RCU_SCHED);\n\tpreempt_enable();\n}\n\n/* Used by lockdep and tracing: cannot be traced, cannot call lockdep. */\nstatic inline notrace void rcu_read_unlock_sched_notrace(void)\n{\n\t__release(RCU_SCHED);\n\tpreempt_enable_notrace();\n}\n\n/**\n * RCU_INIT_POINTER() - initialize an RCU protected pointer\n * @p: The pointer to be initialized.\n * @v: The value to initialized the pointer to.\n *\n * Initialize an RCU-protected pointer in special cases where readers\n * do not need ordering constraints on the CPU or the compiler.  These\n * special cases are:\n *\n * 1.\tThis use of RCU_INIT_POINTER() is NULLing out the pointer *or*\n * 2.\tThe caller has taken whatever steps are required to prevent\n *\tRCU readers from concurrently accessing this pointer *or*\n * 3.\tThe referenced data structure has already been exposed to\n *\treaders either at compile time or via rcu_assign_pointer() *and*\n *\n *\ta.\tYou have not made *any* reader-visible changes to\n *\t\tthis structure since then *or*\n *\tb.\tIt is OK for readers accessing this structure from its\n *\t\tnew location to see the old state of the structure.  (For\n *\t\texample, the changes were to statistical counters or to\n *\t\tother state where exact synchronization is not required.)\n *\n * Failure to follow these rules governing use of RCU_INIT_POINTER() will\n * result in impossible-to-diagnose memory corruption.  As in the structures\n * will look OK in crash dumps, but any concurrent RCU readers might\n * see pre-initialized values of the referenced data structure.  So\n * please be very careful how you use RCU_INIT_POINTER()!!!\n *\n * If you are creating an RCU-protected linked structure that is accessed\n * by a single external-to-structure RCU-protected pointer, then you may\n * use RCU_INIT_POINTER() to initialize the internal RCU-protected\n * pointers, but you must use rcu_assign_pointer() to initialize the\n * external-to-structure pointer *after* you have completely initialized\n * the reader-accessible portions of the linked structure.\n *\n * Note that unlike rcu_assign_pointer(), RCU_INIT_POINTER() provides no\n * ordering guarantees for either the CPU or the compiler.\n */\n#define RCU_INIT_POINTER(p, v) \\\n\tdo { \\\n\t\trcu_check_sparse(p, __rcu); \\\n\t\tWRITE_ONCE(p, RCU_INITIALIZER(v)); \\\n\t} while (0)\n\n/**\n * RCU_POINTER_INITIALIZER() - statically initialize an RCU protected pointer\n * @p: The pointer to be initialized.\n * @v: The value to initialized the pointer to.\n *\n * GCC-style initialization for an RCU-protected pointer in a structure field.\n */\n#define RCU_POINTER_INITIALIZER(p, v) \\\n\t\t.p = RCU_INITIALIZER(v)\n\n/*\n * Does the specified offset indicate that the corresponding rcu_head\n * structure can be handled by kvfree_rcu()?\n */\n#define __is_kvfree_rcu_offset(offset) ((offset) < 4096)\n\n/**\n * kfree_rcu() - kfree an object after a grace period.\n * @ptr: pointer to kfree for both single- and double-argument invocations.\n * @rhf: the name of the struct rcu_head within the type of @ptr,\n *       but only for double-argument invocations.\n *\n * Many rcu callbacks functions just call kfree() on the base structure.\n * These functions are trivial, but their size adds up, and furthermore\n * when they are used in a kernel module, that module must invoke the\n * high-latency rcu_barrier() function at module-unload time.\n *\n * The kfree_rcu() function handles this issue.  Rather than encoding a\n * function address in the embedded rcu_head structure, kfree_rcu() instead\n * encodes the offset of the rcu_head structure within the base structure.\n * Because the functions are not allowed in the low-order 4096 bytes of\n * kernel virtual memory, offsets up to 4095 bytes can be accommodated.\n * If the offset is larger than 4095 bytes, a compile-time error will\n * be generated in kvfree_rcu_arg_2(). If this error is triggered, you can\n * either fall back to use of call_rcu() or rearrange the structure to\n * position the rcu_head structure into the first 4096 bytes.\n *\n * Note that the allowable offset might decrease in the future, for example,\n * to allow something like kmem_cache_free_rcu().\n *\n * The BUILD_BUG_ON check must not involve any function calls, hence the\n * checks are done in macros here.\n */\n#define kfree_rcu(ptr, rhf...) kvfree_rcu(ptr, ## rhf)\n\n/**\n * kvfree_rcu() - kvfree an object after a grace period.\n *\n * This macro consists of one or two arguments and it is\n * based on whether an object is head-less or not. If it\n * has a head then a semantic stays the same as it used\n * to be before:\n *\n *     kvfree_rcu(ptr, rhf);\n *\n * where @ptr is a pointer to kvfree(), @rhf is the name\n * of the rcu_head structure within the type of @ptr.\n *\n * When it comes to head-less variant, only one argument\n * is passed and that is just a pointer which has to be\n * freed after a grace period. Therefore the semantic is\n *\n *     kvfree_rcu(ptr);\n *\n * where @ptr is a pointer to kvfree().\n *\n * Please note, head-less way of freeing is permitted to\n * use from a context that has to follow might_sleep()\n * annotation. Otherwise, please switch and embed the\n * rcu_head structure within the type of @ptr.\n */\n#define kvfree_rcu(...) KVFREE_GET_MACRO(__VA_ARGS__,\t\t\\\n\tkvfree_rcu_arg_2, kvfree_rcu_arg_1)(__VA_ARGS__)\n\n#define KVFREE_GET_MACRO(_1, _2, NAME, ...) NAME\n#define kvfree_rcu_arg_2(ptr, rhf)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\ttypeof (ptr) ___p = (ptr);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (___p) {\t\t\t\t\t\t\t\t\t\\\n\t\tBUILD_BUG_ON(!__is_kvfree_rcu_offset(offsetof(typeof(*(ptr)), rhf)));\t\\\n\t\tkvfree_call_rcu(&((___p)->rhf), (rcu_callback_t)(unsigned long)\t\t\\\n\t\t\t(offsetof(typeof(*(ptr)), rhf)));\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define kvfree_rcu_arg_1(ptr)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\ttypeof(ptr) ___p = (ptr);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (___p)\t\t\t\t\t\t\\\n\t\tkvfree_call_rcu(NULL, (rcu_callback_t) (___p));\t\\\n} while (0)\n\n/*\n * Place this after a lock-acquisition primitive to guarantee that\n * an UNLOCK+LOCK pair acts as a full barrier.  This guarantee applies\n * if the UNLOCK and LOCK are executed by the same CPU or if the\n * UNLOCK and LOCK operate on the same lock variable.\n */\n#ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE\n#define smp_mb__after_unlock_lock()\tsmp_mb()  /* Full ordering for lock. */\n#else /* #ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE */\n#define smp_mb__after_unlock_lock()\tdo { } while (0)\n#endif /* #else #ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE */\n\n\n/* Has the specified rcu_head structure been handed to call_rcu()? */\n\n/**\n * rcu_head_init - Initialize rcu_head for rcu_head_after_call_rcu()\n * @rhp: The rcu_head structure to initialize.\n *\n * If you intend to invoke rcu_head_after_call_rcu() to test whether a\n * given rcu_head structure has already been passed to call_rcu(), then\n * you must also invoke this rcu_head_init() function on it just after\n * allocating that structure.  Calls to this function must not race with\n * calls to call_rcu(), rcu_head_after_call_rcu(), or callback invocation.\n */\nstatic inline void rcu_head_init(struct rcu_head *rhp)\n{\n\trhp->func = (rcu_callback_t)~0L;\n}\n\n/**\n * rcu_head_after_call_rcu() - Has this rcu_head been passed to call_rcu()?\n * @rhp: The rcu_head structure to test.\n * @f: The function passed to call_rcu() along with @rhp.\n *\n * Returns @true if the @rhp has been passed to call_rcu() with @func,\n * and @false otherwise.  Emits a warning in any other case, including\n * the case where @rhp has already been invoked after a grace period.\n * Calls to this function must not race with callback invocation.  One way\n * to avoid such races is to enclose the call to rcu_head_after_call_rcu()\n * in an RCU read-side critical section that includes a read-side fetch\n * of the pointer to the structure containing @rhp.\n */\nstatic inline bool\nrcu_head_after_call_rcu(struct rcu_head *rhp, rcu_callback_t f)\n{\n\trcu_callback_t func = READ_ONCE(rhp->func);\n\n\tif (func == f)\n\t\treturn true;\n\tWARN_ON_ONCE(func != (rcu_callback_t)~0L);\n\treturn false;\n}\n\n/* kernel/ksysfs.c definitions */\nextern int rcu_expedited;\nextern int rcu_normal;\n\n#endif /* __LINUX_RCUPDATE_H */\n"}}, "reports": [{"events": [{"location": {"col": 3, "file": 0, "line": 378}, "message": "Value stored to 'group' is never read"}, {"location": {"col": 3, "file": 0, "line": 378}, "message": "Value stored to 'group' is never read"}], "macros": [], "notes": [], "path": "/src/fs/ext4/resize.c", "reportHash": "9c5da8e787f2d61c5e0b72e3554be6a2", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 0, "line": 443}, "message": "Value stored to 'count2' is never read"}, {"location": {"col": 7, "file": 0, "line": 443}, "message": "Value stored to 'count2' is never read"}], "macros": [], "notes": [], "path": "/src/fs/ext4/resize.c", "reportHash": "17a6f6ea92ad53a09772393214247681", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 0, "line": 1637}, "message": "Assuming the condition is false"}, {"location": {"col": 21, "file": 0, "line": 1637}, "message": "'?' condition is false"}, {"location": {"col": 2, "file": 0, "line": 1639}, "message": "'inode' initialized to a null pointer value"}, {"location": {"col": 6, "file": 0, "line": 1646}, "message": "Assuming 'gdb_off' is not equal to 0"}, {"location": {"col": 19, "file": 0, "line": 1646}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 1651}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1651}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1657}, "message": "Assuming the condition is false"}, {"location": {"col": 21, "file": 1, "line": 89}, "message": "expanded from macro 'le32_to_cpu'"}, {"location": {"col": 26, "file": 2, "line": 34}, "message": "expanded from macro '__le32_to_cpu'"}, {"location": {"col": 2, "file": 0, "line": 1657}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1663}, "message": "'reserved_gdb' is 0"}, {"location": {"col": 6, "file": 0, "line": 1663}, "message": "Left side of '||' is false"}, {"location": {"col": 22, "file": 0, "line": 1663}, "message": "'gdb_off' is not equal to 0"}, {"location": {"col": 2, "file": 0, "line": 1663}, "message": "Taking false branch"}, {"location": {"col": 8, "file": 0, "line": 1678}, "message": "Calling 'verify_group_input'"}, {"location": {"col": 6, "file": 0, "line": 130}, "message": "Assuming 'group' is equal to field 's_groups_count'"}, {"location": {"col": 2, "file": 0, "line": 130}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 141}, "message": "Assuming the condition is false"}, {"location": {"col": 29, "file": 3, "line": 1256}, "message": "expanded from macro 'test_opt'"}, {"location": {"col": 2, "file": 0, "line": 141}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 149}, "message": "Assuming 'offset' is equal to 0"}, {"location": {"col": 2, "file": 0, "line": 149}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 151}, "message": "Assuming the condition is false"}, {"location": {"col": 7, "file": 0, "line": 151}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 154}, "message": "'free_blocks_count' is >= 0"}, {"location": {"col": 7, "file": 0, "line": 154}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 157}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 4, "line": 36}, "message": "Assuming the condition is true"}, {"location": {"col": 34, "file": 4, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 5, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 4, "line": 36}, "message": "Returning the value 1, which participates in a condition later"}, {"location": {"col": 11, "file": 0, "line": 157}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 7, "file": 0, "line": 157}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 0, "line": 203}, "message": "Returning value (loaded from 'err'), which participates in a condition later"}, {"location": {"col": 8, "file": 0, "line": 1678}, "message": "Returning from 'verify_group_input'"}, {"location": {"col": 6, "file": 0, "line": 1679}, "message": "Assuming 'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 1679}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1683}, "message": "Assuming 'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 1683}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1687}, "message": "Assuming 'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 1687}, "message": "Taking false branch"}, {"location": {"col": 32, "file": 0, "line": 1693}, "message": "Passing null pointer value via 2nd parameter 'resize_inode'"}, {"location": {"col": 8, "file": 0, "line": 1693}, "message": "Calling 'ext4_flex_group_add'"}, {"location": {"col": 19, "file": 0, "line": 1479}, "message": "Field 'count' is 1"}, {"location": {"col": 9, "file": 0, "line": 1479}, "message": "Left side of '||' is false"}, {"location": {"col": 38, "file": 0, "line": 1479}, "message": "Field 'groups' is non-null"}, {"location": {"col": 9, "file": 0, "line": 1479}, "message": "Left side of '||' is false"}, {"location": {"col": 2, "file": 0, "line": 1479}, "message": "Taking false branch"}, {"location": {"col": 32, "file": 6, "line": 63}, "message": "expanded from macro 'BUG_ON'"}, {"location": {"col": 2, "file": 0, "line": 1479}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 27, "file": 6, "line": 63}, "message": "expanded from macro 'BUG_ON'"}, {"location": {"col": 2, "file": 0, "line": 1484}, "message": "Assuming 'last' is 0"}, {"location": {"col": 36, "file": 6, "line": 63}, "message": "expanded from macro 'BUG_ON'"}, {"location": {"col": 40, "file": 5, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 1484}, "message": "Taking false branch"}, {"location": {"col": 32, "file": 6, "line": 63}, "message": "expanded from macro 'BUG_ON'"}, {"location": {"col": 2, "file": 0, "line": 1484}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 27, "file": 6, "line": 63}, "message": "expanded from macro 'BUG_ON'"}, {"location": {"col": 6, "file": 0, "line": 1487}, "message": "Assuming 'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 1487}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1501}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 4, "line": 36}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 4, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 5, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 4, "line": 36}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 1501}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 2, "file": 0, "line": 1501}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1506}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 32, "file": 7, "line": 1787}, "message": "expanded from macro 'BUFFER_TRACE'"}, {"location": {"col": 6, "file": 0, "line": 1508}, "message": "Assuming 'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 1508}, "message": "Taking false branch"}, {"location": {"col": 9, "file": 0, "line": 1512}, "message": "Assuming 'group' is equal to field 's_groups_count'"}, {"location": {"col": 45, "file": 6, "line": 63}, "message": "expanded from macro 'BUG_ON'"}, {"location": {"col": 42, "file": 5, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 1512}, "message": "Taking false branch"}, {"location": {"col": 32, "file": 6, "line": 63}, "message": "expanded from macro 'BUG_ON'"}, {"location": {"col": 2, "file": 0, "line": 1512}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 27, "file": 6, "line": 63}, "message": "expanded from macro 'BUG_ON'"}, {"location": {"col": 5, "file": 0, "line": 1514}, "message": "Passing null pointer value via 4th parameter 'resize_inode'"}, {"location": {"col": 8, "file": 0, "line": 1513}, "message": "Calling 'ext4_add_new_descs'"}, {"location": {"col": 14, "file": 0, "line": 1213}, "message": "Assuming 'i' is < 'count'"}, {"location": {"col": 2, "file": 0, "line": 1213}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 22, "file": 0, "line": 1214}, "message": "Assuming the condition is true"}, {"location": {"col": 22, "file": 0, "line": 1214}, "message": "'?' condition is true"}, {"location": {"col": 7, "file": 0, "line": 1226}, "message": "Assuming 'gdb_off' is not equal to 0"}, {"location": {"col": 3, "file": 0, "line": 1226}, "message": "Taking true branch"}, {"location": {"col": 13, "file": 0, "line": 1227}, "message": "Left side of '||' is false"}, {"location": {"col": 21, "file": 3, "line": 1710}, "message": "expanded from macro 'sbi_array_rcu_deref'"}, {"location": {"col": 28, "file": 8, "line": 571}, "message": "expanded from macro 'rcu_dereference'"}, {"location": {"col": 2, "file": 8, "line": 513}, "message": "expanded from macro 'rcu_dereference_check'"}, {"location": {"col": 27, "file": 0, "line": 983}, "message": "Access to field 'i_sb' results in a dereference of a null pointer (loaded from variable 'inode')"}], "macros": [], "notes": [], "path": "/src/fs/ext4/resize.c", "reportHash": "e7015adbb94c4b1f44f2accd62d5342d", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 1916}, "message": "Value stored to 'err' is never read"}, {"location": {"col": 3, "file": 0, "line": 1916}, "message": "Value stored to 'err' is never read"}], "macros": [], "notes": [], "path": "/src/fs/ext4/resize.c", "reportHash": "5eb6f1aa05c01e728c1f0a975d91c2c8", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
