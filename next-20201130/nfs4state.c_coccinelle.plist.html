<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/fs/nfsd/nfs4state.c", "content": "/*\n*  Copyright (c) 2001 The Regents of the University of Michigan.\n*  All rights reserved.\n*\n*  Kendrick Smith <kmsmith@umich.edu>\n*  Andy Adamson <kandros@umich.edu>\n*\n*  Redistribution and use in source and binary forms, with or without\n*  modification, are permitted provided that the following conditions\n*  are met:\n*\n*  1. Redistributions of source code must retain the above copyright\n*     notice, this list of conditions and the following disclaimer.\n*  2. Redistributions in binary form must reproduce the above copyright\n*     notice, this list of conditions and the following disclaimer in the\n*     documentation and/or other materials provided with the distribution.\n*  3. Neither the name of the University nor the names of its\n*     contributors may be used to endorse or promote products derived\n*     from this software without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\n*  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n*  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n*  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n*  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n*  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n*  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n*  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n*  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n*  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*\n*/\n\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/ratelimit.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/jhash.h>\n#include <linux/string_helpers.h>\n#include \"xdr4.h\"\n#include \"xdr4cb.h\"\n#include \"vfs.h\"\n#include \"current_stateid.h\"\n\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"filecache.h\"\n#include \"trace.h\"\n\n#define NFSDDBG_FACILITY                NFSDDBG_PROC\n\n#define all_ones {{~0,~0},~0}\nstatic const stateid_t one_stateid = {\n\t.si_generation = ~0,\n\t.si_opaque = all_ones,\n};\nstatic const stateid_t zero_stateid = {\n\t/* all fields zero */\n};\nstatic const stateid_t currentstateid = {\n\t.si_generation = 1,\n};\nstatic const stateid_t close_stateid = {\n\t.si_generation = 0xffffffffU,\n};\n\nstatic u64 current_sessionid = 1;\n\n#define ZERO_STATEID(stateid) (!memcmp((stateid), &zero_stateid, sizeof(stateid_t)))\n#define ONE_STATEID(stateid)  (!memcmp((stateid), &one_stateid, sizeof(stateid_t)))\n#define CURRENT_STATEID(stateid) (!memcmp((stateid), &currentstateid, sizeof(stateid_t)))\n#define CLOSE_STATEID(stateid)  (!memcmp((stateid), &close_stateid, sizeof(stateid_t)))\n\n/* forward declarations */\nstatic bool check_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner);\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\nvoid nfsd4_end_grace(struct nfsd_net *nn);\nstatic void _free_cpntf_state_locked(struct nfsd_net *nn, struct nfs4_cpntf_state *cps);\n\n/* Locking: */\n\n/*\n * Currently used for the del_recall_lru and file hash table.  In an\n * effort to decrease the scope of the client_mutex, this spinlock may\n * eventually cover more:\n */\nstatic DEFINE_SPINLOCK(state_lock);\n\nenum nfsd4_st_mutex_lock_subclass {\n\tOPEN_STATEID_MUTEX = 0,\n\tLOCK_STATEID_MUTEX = 1,\n};\n\n/*\n * A waitqueue for all in-progress 4.0 CLOSE operations that are waiting for\n * the refcount on the open stateid to drop.\n */\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\n/*\n * A waitqueue where a writer to clients/#/ctl destroying a client can\n * wait for cl_rpc_users to drop to 0 and then for the client to be\n * unhashed.\n */\nstatic DECLARE_WAIT_QUEUE_HEAD(expiry_wq);\n\nstatic struct kmem_cache *client_slab;\nstatic struct kmem_cache *openowner_slab;\nstatic struct kmem_cache *lockowner_slab;\nstatic struct kmem_cache *file_slab;\nstatic struct kmem_cache *stateid_slab;\nstatic struct kmem_cache *deleg_slab;\nstatic struct kmem_cache *odstate_slab;\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic const struct nfsd4_callback_ops nfsd4_cb_recall_ops;\nstatic const struct nfsd4_callback_ops nfsd4_cb_notify_lock_ops;\n\nstatic bool is_session_dead(struct nfsd4_session *ses)\n{\n\treturn ses->se_flags & NFS4_SESSION_DEAD;\n}\n\nstatic __be32 mark_session_dead_locked(struct nfsd4_session *ses, int ref_held_by_me)\n{\n\tif (atomic_read(&ses->se_ref) > ref_held_by_me)\n\t\treturn nfserr_jukebox;\n\tses->se_flags |= NFS4_SESSION_DEAD;\n\treturn nfs_ok;\n}\n\nstatic bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}\n\nstatic __be32 get_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (is_client_expired(clp))\n\t\treturn nfserr_expired;\n\tatomic_inc(&clp->cl_rpc_users);\n\treturn nfs_ok;\n}\n\n/* must be called under the client_lock */\nstatic inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = ktime_get_boottime_seconds();\n}\n\nstatic void put_client_renew_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (!atomic_dec_and_test(&clp->cl_rpc_users))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n\telse\n\t\twake_up_all(&expiry_wq);\n}\n\nstatic void put_client_renew(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (!atomic_dec_and_lock(&clp->cl_rpc_users, &nn->client_lock))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n\telse\n\t\twake_up_all(&expiry_wq);\n\tspin_unlock(&nn->client_lock);\n}\n\nstatic __be32 nfsd4_get_session_locked(struct nfsd4_session *ses)\n{\n\t__be32 status;\n\n\tif (is_session_dead(ses))\n\t\treturn nfserr_badsession;\n\tstatus = get_client_locked(ses->se_client);\n\tif (status)\n\t\treturn status;\n\tatomic_inc(&ses->se_ref);\n\treturn nfs_ok;\n}\n\nstatic void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}\n\nstatic void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}\n\nstatic struct nfsd4_blocked_lock *\nfind_blocked_lock(struct nfs4_lockowner *lo, struct knfsd_fh *fh,\n\t\t\tstruct nfsd_net *nn)\n{\n\tstruct nfsd4_blocked_lock *cur, *found = NULL;\n\n\tspin_lock(&nn->blocked_locks_lock);\n\tlist_for_each_entry(cur, &lo->lo_blocked, nbl_list) {\n\t\tif (fh_match(fh, &cur->nbl_fh)) {\n\t\t\tlist_del_init(&cur->nbl_list);\n\t\t\tlist_del_init(&cur->nbl_lru);\n\t\t\tfound = cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&nn->blocked_locks_lock);\n\tif (found)\n\t\tlocks_delete_block(&found->nbl_lock);\n\treturn found;\n}\n\nstatic struct nfsd4_blocked_lock *\nfind_or_allocate_block(struct nfs4_lockowner *lo, struct knfsd_fh *fh,\n\t\t\tstruct nfsd_net *nn)\n{\n\tstruct nfsd4_blocked_lock *nbl;\n\n\tnbl = find_blocked_lock(lo, fh, nn);\n\tif (!nbl) {\n\t\tnbl= kmalloc(sizeof(*nbl), GFP_KERNEL);\n\t\tif (nbl) {\n\t\t\tINIT_LIST_HEAD(&nbl->nbl_list);\n\t\t\tINIT_LIST_HEAD(&nbl->nbl_lru);\n\t\t\tfh_copy_shallow(&nbl->nbl_fh, fh);\n\t\t\tlocks_init_lock(&nbl->nbl_lock);\n\t\t\tnfsd4_init_cb(&nbl->nbl_cb, lo->lo_owner.so_client,\n\t\t\t\t\t&nfsd4_cb_notify_lock_ops,\n\t\t\t\t\tNFSPROC4_CLNT_CB_NOTIFY_LOCK);\n\t\t}\n\t}\n\treturn nbl;\n}\n\nstatic void\nfree_blocked_lock(struct nfsd4_blocked_lock *nbl)\n{\n\tlocks_delete_block(&nbl->nbl_lock);\n\tlocks_release_private(&nbl->nbl_lock);\n\tkfree(nbl);\n}\n\nstatic void\nremove_blocked_locks(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_blocked_lock *nbl;\n\tLIST_HEAD(reaplist);\n\n\t/* Dequeue all blocked locks */\n\tspin_lock(&nn->blocked_locks_lock);\n\twhile (!list_empty(&lo->lo_blocked)) {\n\t\tnbl = list_first_entry(&lo->lo_blocked,\n\t\t\t\t\tstruct nfsd4_blocked_lock,\n\t\t\t\t\tnbl_list);\n\t\tlist_del_init(&nbl->nbl_list);\n\t\tlist_move(&nbl->nbl_lru, &reaplist);\n\t}\n\tspin_unlock(&nn->blocked_locks_lock);\n\n\t/* Now free them */\n\twhile (!list_empty(&reaplist)) {\n\t\tnbl = list_first_entry(&reaplist, struct nfsd4_blocked_lock,\n\t\t\t\t\tnbl_lru);\n\t\tlist_del_init(&nbl->nbl_lru);\n\t\tfree_blocked_lock(nbl);\n\t}\n}\n\nstatic void\nnfsd4_cb_notify_lock_prepare(struct nfsd4_callback *cb)\n{\n\tstruct nfsd4_blocked_lock\t*nbl = container_of(cb,\n\t\t\t\t\t\tstruct nfsd4_blocked_lock, nbl_cb);\n\tlocks_delete_block(&nbl->nbl_lock);\n}\n\nstatic int\nnfsd4_cb_notify_lock_done(struct nfsd4_callback *cb, struct rpc_task *task)\n{\n\t/*\n\t * Since this is just an optimization, we don't try very hard if it\n\t * turns out not to succeed. We'll requeue it on NFS4ERR_DELAY, and\n\t * just quit trying on anything else.\n\t */\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_DELAY:\n\t\trpc_delay(task, 1 * HZ);\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic void\nnfsd4_cb_notify_lock_release(struct nfsd4_callback *cb)\n{\n\tstruct nfsd4_blocked_lock\t*nbl = container_of(cb,\n\t\t\t\t\t\tstruct nfsd4_blocked_lock, nbl_cb);\n\n\tfree_blocked_lock(nbl);\n}\n\nstatic const struct nfsd4_callback_ops nfsd4_cb_notify_lock_ops = {\n\t.prepare\t= nfsd4_cb_notify_lock_prepare,\n\t.done\t\t= nfsd4_cb_notify_lock_done,\n\t.release\t= nfsd4_cb_notify_lock_release,\n};\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}\n\nstatic int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}\n\nstatic struct nfs4_openowner *\nfind_openstateowner_str_locked(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\t\tif (!so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, &open->op_owner))\n\t\t\treturn openowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}\n\nstatic struct nfs4_openowner *\nfind_openstateowner_str(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\n\tspin_lock(&clp->cl_lock);\n\too = find_openstateowner_str_locked(hashval, open, clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn oo;\n}\n\nstatic inline u32\nopaque_hashval(const void *ptr, int nbytes)\n{\n\tunsigned char *cptr = (unsigned char *) ptr;\n\n\tu32 x = 0;\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x;\n}\n\nstatic void nfsd4_free_file_rcu(struct rcu_head *rcu)\n{\n\tstruct nfs4_file *fp = container_of(rcu, struct nfs4_file, fi_rcu);\n\n\tkmem_cache_free(file_slab, fp);\n}\n\nvoid\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (refcount_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_clnt_odstate));\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}\n\nstatic struct nfsd_file *\n__nfs4_get_fd(struct nfs4_file *f, int oflag)\n{\n\tif (f->fi_fds[oflag])\n\t\treturn nfsd_file_get(f->fi_fds[oflag]);\n\treturn NULL;\n}\n\nstatic struct nfsd_file *\nfind_writeable_file_locked(struct nfs4_file *f)\n{\n\tstruct nfsd_file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_WRONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}\n\nstatic struct nfsd_file *\nfind_writeable_file(struct nfs4_file *f)\n{\n\tstruct nfsd_file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_writeable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}\n\nstatic struct nfsd_file *\nfind_readable_file_locked(struct nfs4_file *f)\n{\n\tstruct nfsd_file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_RDONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}\n\nstatic struct nfsd_file *\nfind_readable_file(struct nfs4_file *f)\n{\n\tstruct nfsd_file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_readable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}\n\nstruct nfsd_file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct nfsd_file *ret;\n\n\tif (!f)\n\t\treturn NULL;\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}\n\nstatic struct nfsd_file *find_deleg_file(struct nfs4_file *f)\n{\n\tstruct nfsd_file *ret = NULL;\n\n\tspin_lock(&f->fi_lock);\n\tif (f->fi_deleg_file)\n\t\tret = nfsd_file_get(f->fi_deleg_file);\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}\n\nstatic atomic_long_t num_delegations;\nunsigned long max_delegations;\n\n/*\n * Open owner state (share locks)\n */\n\n/* hash tables for lock and open owners */\n#define OWNER_HASH_BITS              8\n#define OWNER_HASH_SIZE             (1 << OWNER_HASH_BITS)\n#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)\n\nstatic unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}\n\n/* hash table for nfs4_file */\n#define FILE_HASH_BITS                   8\n#define FILE_HASH_SIZE                  (1 << FILE_HASH_BITS)\n\nstatic unsigned int nfsd_fh_hashval(struct knfsd_fh *fh)\n{\n\treturn jhash2(fh->fh_base.fh_pad, XDR_QUADLEN(fh->fh_size), 0);\n}\n\nstatic unsigned int file_hashval(struct knfsd_fh *fh)\n{\n\treturn nfsd_fh_hashval(fh) & (FILE_HASH_SIZE - 1);\n}\n\nstatic struct hlist_head file_hashtbl[FILE_HASH_SIZE];\n\nstatic void\n__nfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\tatomic_inc(&fp->fi_access[O_WRONLY]);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\tatomic_inc(&fp->fi_access[O_RDONLY]);\n}\n\nstatic __be32\nnfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\t/* Does this access mode make sense? */\n\tif (access & ~NFS4_SHARE_ACCESS_BOTH)\n\t\treturn nfserr_inval;\n\n\t/* Does it conflict with a deny mode already set? */\n\tif ((access & fp->fi_share_deny) != 0)\n\t\treturn nfserr_share_denied;\n\n\t__nfs4_file_get_access(fp, access);\n\treturn nfs_ok;\n}\n\nstatic __be32 nfs4_file_check_deny(struct nfs4_file *fp, u32 deny)\n{\n\t/* Common case is that there is no deny mode. */\n\tif (deny) {\n\t\t/* Does this deny mode make sense? */\n\t\tif (deny & ~NFS4_SHARE_DENY_BOTH)\n\t\t\treturn nfserr_inval;\n\n\t\tif ((deny & NFS4_SHARE_DENY_READ) &&\n\t\t    atomic_read(&fp->fi_access[O_RDONLY]))\n\t\t\treturn nfserr_share_denied;\n\n\t\tif ((deny & NFS4_SHARE_DENY_WRITE) &&\n\t\t    atomic_read(&fp->fi_access[O_WRONLY]))\n\t\t\treturn nfserr_share_denied;\n\t}\n\treturn nfs_ok;\n}\n\nstatic void __nfs4_file_put_access(struct nfs4_file *fp, int oflag)\n{\n\tmight_lock(&fp->fi_lock);\n\n\tif (atomic_dec_and_lock(&fp->fi_access[oflag], &fp->fi_lock)) {\n\t\tstruct nfsd_file *f1 = NULL;\n\t\tstruct nfsd_file *f2 = NULL;\n\n\t\tswap(f1, fp->fi_fds[oflag]);\n\t\tif (atomic_read(&fp->fi_access[1 - oflag]) == 0)\n\t\t\tswap(f2, fp->fi_fds[O_RDWR]);\n\t\tspin_unlock(&fp->fi_lock);\n\t\tif (f1)\n\t\t\tnfsd_file_put(f1);\n\t\tif (f2)\n\t\t\tnfsd_file_put(f2);\n\t}\n}\n\nstatic void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}\n\n/*\n * Allocate a new open/delegation state counter. This is needed for\n * pNFS for proper return on close semantics.\n *\n * Note that we only allocate it for pNFS-enabled exports, otherwise\n * all pointers to struct nfs4_clnt_odstate are always NULL.\n */\nstatic struct nfs4_clnt_odstate *\nalloc_clnt_odstate(struct nfs4_client *clp)\n{\n\tstruct nfs4_clnt_odstate *co;\n\n\tco = kmem_cache_zalloc(odstate_slab, GFP_KERNEL);\n\tif (co) {\n\t\tco->co_client = clp;\n\t\trefcount_set(&co->co_odcount, 1);\n\t}\n\treturn co;\n}\n\nstatic void\nhash_clnt_odstate_locked(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp = co->co_file;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\tlist_add(&co->co_perfile, &fp->fi_clnt_odstate);\n}\n\nstatic inline void\nget_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tif (co)\n\t\trefcount_inc(&co->co_odcount);\n}\n\nstatic void\nput_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp;\n\n\tif (!co)\n\t\treturn;\n\n\tfp = co->co_file;\n\tif (refcount_dec_and_lock(&co->co_odcount, &fp->fi_lock)) {\n\t\tlist_del(&co->co_perfile);\n\t\tspin_unlock(&fp->fi_lock);\n\n\t\tnfsd4_return_all_file_layouts(co->co_client, fp);\n\t\tkmem_cache_free(odstate_slab, co);\n\t}\n}\n\nstatic struct nfs4_clnt_odstate *\nfind_or_hash_clnt_odstate(struct nfs4_file *fp, struct nfs4_clnt_odstate *new)\n{\n\tstruct nfs4_clnt_odstate *co;\n\tstruct nfs4_client *cl;\n\n\tif (!new)\n\t\treturn NULL;\n\n\tcl = new->co_client;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry(co, &fp->fi_clnt_odstate, co_perfile) {\n\t\tif (co->co_client == cl) {\n\t\t\tget_clnt_odstate(co);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tco = new;\n\tco->co_file = fp;\n\thash_clnt_odstate_locked(new);\nout:\n\tspin_unlock(&fp->fi_lock);\n\treturn co;\n}\n\nstruct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl, struct kmem_cache *slab,\n\t\t\t\t  void (*sc_free)(struct nfs4_stid *))\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\t/* Reserving 0 for start of file in nfsdfs \"states\" file: */\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 1, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\n\tstid->sc_free = sc_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\trefcount_set(&stid->sc_count, 1);\n\tspin_lock_init(&stid->sc_lock);\n\tINIT_LIST_HEAD(&stid->sc_cp_list);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}\n\n/*\n * Create a unique stateid_t to represent each COPY.\n */\nstatic int nfs4_init_cp_state(struct nfsd_net *nn, copy_stateid_t *stid,\n\t\t\t      unsigned char sc_type)\n{\n\tint new_id;\n\n\tstid->stid.si_opaque.so_clid.cl_boot = (u32)nn->boot_time;\n\tstid->stid.si_opaque.so_clid.cl_id = nn->s2s_cp_cl_id;\n\tstid->sc_type = sc_type;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&nn->s2s_cp_lock);\n\tnew_id = idr_alloc_cyclic(&nn->s2s_cp_stateids, stid, 0, 0, GFP_NOWAIT);\n\tstid->stid.si_opaque.so_id = new_id;\n\tspin_unlock(&nn->s2s_cp_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\treturn 0;\n\treturn 1;\n}\n\nint nfs4_init_copy_state(struct nfsd_net *nn, struct nfsd4_copy *copy)\n{\n\treturn nfs4_init_cp_state(nn, &copy->cp_stateid, NFS4_COPY_STID);\n}\n\nstruct nfs4_cpntf_state *nfs4_alloc_init_cpntf_state(struct nfsd_net *nn,\n\t\t\t\t\t\t     struct nfs4_stid *p_stid)\n{\n\tstruct nfs4_cpntf_state *cps;\n\n\tcps = kzalloc(sizeof(struct nfs4_cpntf_state), GFP_KERNEL);\n\tif (!cps)\n\t\treturn NULL;\n\tcps->cpntf_time = ktime_get_boottime_seconds();\n\trefcount_set(&cps->cp_stateid.sc_count, 1);\n\tif (!nfs4_init_cp_state(nn, &cps->cp_stateid, NFS4_COPYNOTIFY_STID))\n\t\tgoto out_free;\n\tspin_lock(&nn->s2s_cp_lock);\n\tlist_add(&cps->cp_list, &p_stid->sc_cp_list);\n\tspin_unlock(&nn->s2s_cp_lock);\n\treturn cps;\nout_free:\n\tkfree(cps);\n\treturn NULL;\n}\n\nvoid nfs4_free_copy_state(struct nfsd4_copy *copy)\n{\n\tstruct nfsd_net *nn;\n\n\tWARN_ON_ONCE(copy->cp_stateid.sc_type != NFS4_COPY_STID);\n\tnn = net_generic(copy->cp_clp->net, nfsd_net_id);\n\tspin_lock(&nn->s2s_cp_lock);\n\tidr_remove(&nn->s2s_cp_stateids,\n\t\t   copy->cp_stateid.stid.si_opaque.so_id);\n\tspin_unlock(&nn->s2s_cp_lock);\n}\n\nstatic void nfs4_free_cpntf_statelist(struct net *net, struct nfs4_stid *stid)\n{\n\tstruct nfs4_cpntf_state *cps;\n\tstruct nfsd_net *nn;\n\n\tnn = net_generic(net, nfsd_net_id);\n\tspin_lock(&nn->s2s_cp_lock);\n\twhile (!list_empty(&stid->sc_cp_list)) {\n\t\tcps = list_first_entry(&stid->sc_cp_list,\n\t\t\t\t       struct nfs4_cpntf_state, cp_list);\n\t\t_free_cpntf_state_locked(nn, cps);\n\t}\n\tspin_unlock(&nn->s2s_cp_lock);\n}\n\nstatic struct nfs4_ol_stateid * nfs4_alloc_open_stateid(struct nfs4_client *clp)\n{\n\tstruct nfs4_stid *stid;\n\n\tstid = nfs4_alloc_stid(clp, stateid_slab, nfs4_free_ol_stateid);\n\tif (!stid)\n\t\treturn NULL;\n\n\treturn openlockstateid(stid);\n}\n\nstatic void nfs4_free_deleg(struct nfs4_stid *stid)\n{\n\tkmem_cache_free(deleg_slab, stid);\n\tatomic_long_dec(&num_delegations);\n}\n\n/*\n * When we recall a delegation, we should be careful not to hand it\n * out again straight away.\n * To ensure this we keep a pair of bloom filters ('new' and 'old')\n * in which the filehandles of recalled delegations are \"stored\".\n * If a filehandle appear in either filter, a delegation is blocked.\n * When a delegation is recalled, the filehandle is stored in the \"new\"\n * filter.\n * Every 30 seconds we swap the filters and clear the \"new\" one,\n * unless both are empty of course.\n *\n * Each filter is 256 bits.  We hash the filehandle to 32bit and use the\n * low 3 bytes as hash-table indices.\n *\n * 'blocked_delegations_lock', which is always taken in block_delegations(),\n * is used to manage concurrent access.  Testing does not need the lock\n * except when swapping the two filters.\n */\nstatic DEFINE_SPINLOCK(blocked_delegations_lock);\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime64_t swap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic int delegation_blocked(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\tif (bd->entries == 0)\n\t\treturn 0;\n\tif (ktime_get_seconds() - bd->swap_time > 30) {\n\t\tspin_lock(&blocked_delegations_lock);\n\t\tif (ktime_get_seconds() - bd->swap_time > 30) {\n\t\t\tbd->entries -= bd->old_entries;\n\t\t\tbd->old_entries = bd->entries;\n\t\t\tmemset(bd->set[bd->new], 0,\n\t\t\t       sizeof(bd->set[0]));\n\t\t\tbd->new = 1-bd->new;\n\t\t\tbd->swap_time = ktime_get_seconds();\n\t\t}\n\t\tspin_unlock(&blocked_delegations_lock);\n\t}\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\tif (test_bit(hash&255, bd->set[0]) &&\n\t    test_bit((hash>>8)&255, bd->set[0]) &&\n\t    test_bit((hash>>16)&255, bd->set[0]))\n\t\treturn 1;\n\n\tif (test_bit(hash&255, bd->set[1]) &&\n\t    test_bit((hash>>8)&255, bd->set[1]) &&\n\t    test_bit((hash>>16)&255, bd->set[1]))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void block_delegations(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\n\tspin_lock(&blocked_delegations_lock);\n\t__set_bit(hash&255, bd->set[bd->new]);\n\t__set_bit((hash>>8)&255, bd->set[bd->new]);\n\t__set_bit((hash>>16)&255, bd->set[bd->new]);\n\tif (bd->entries == 0)\n\t\tbd->swap_time = ktime_get_seconds();\n\tbd->entries += 1;\n\tspin_unlock(&blocked_delegations_lock);\n}\n\nstatic struct nfs4_delegation *\nalloc_init_deleg(struct nfs4_client *clp, struct nfs4_file *fp,\n\t\t struct svc_fh *current_fh,\n\t\t struct nfs4_clnt_odstate *odstate)\n{\n\tstruct nfs4_delegation *dp;\n\tlong n;\n\n\tdprintk(\"NFSD alloc_init_deleg\\n\");\n\tn = atomic_long_inc_return(&num_delegations);\n\tif (n < 0 || n > max_delegations)\n\t\tgoto out_dec;\n\tif (delegation_blocked(&current_fh->fh_handle))\n\t\tgoto out_dec;\n\tdp = delegstateid(nfs4_alloc_stid(clp, deleg_slab, nfs4_free_deleg));\n\tif (dp == NULL)\n\t\tgoto out_dec;\n\n\t/*\n\t * delegation seqid's are never incremented.  The 4.1 special\n\t * meaning of seqid 0 isn't meaningful, really, but let's avoid\n\t * 0 anyway just for consistency and use 1:\n\t */\n\tdp->dl_stid.sc_stateid.si_generation = 1;\n\tINIT_LIST_HEAD(&dp->dl_perfile);\n\tINIT_LIST_HEAD(&dp->dl_perclnt);\n\tINIT_LIST_HEAD(&dp->dl_recall_lru);\n\tdp->dl_clnt_odstate = odstate;\n\tget_clnt_odstate(odstate);\n\tdp->dl_type = NFS4_OPEN_DELEGATE_READ;\n\tdp->dl_retries = 1;\n\tnfsd4_init_cb(&dp->dl_recall, dp->dl_stid.sc_client,\n\t\t      &nfsd4_cb_recall_ops, NFSPROC4_CLNT_CB_RECALL);\n\tget_nfs4_file(fp);\n\tdp->dl_stid.sc_file = fp;\n\treturn dp;\nout_dec:\n\tatomic_long_dec(&num_delegations);\n\treturn NULL;\n}\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!refcount_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tnfs4_free_cpntf_statelist(clp->net, s);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}\n\nvoid\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}\n\nstatic void put_deleg_file(struct nfs4_file *fp)\n{\n\tstruct nfsd_file *nf = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (--fp->fi_delegees == 0)\n\t\tswap(nf, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (nf)\n\t\tnfsd_file_put(nf);\n}\n\nstatic void nfs4_unlock_deleg_lease(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\tstruct nfsd_file *nf = fp->fi_deleg_file;\n\n\tWARN_ON_ONCE(!fp->fi_delegees);\n\n\tvfs_setlease(nf->nf_file, F_UNLCK, NULL, (void **)&dp);\n\tput_deleg_file(fp);\n}\n\nstatic void destroy_unhashed_deleg(struct nfs4_delegation *dp)\n{\n\tput_clnt_odstate(dp->dl_clnt_odstate);\n\tnfs4_unlock_deleg_lease(dp);\n\tnfs4_put_stid(&dp->dl_stid);\n}\n\nvoid nfs4_unhash_stid(struct nfs4_stid *s)\n{\n\ts->sc_type = 0;\n}\n\n/**\n * nfs4_delegation_exists - Discover if this delegation already exists\n * @clp:     a pointer to the nfs4_client we're granting a delegation to\n * @fp:      a pointer to the nfs4_file we're granting a delegation on\n *\n * Return:\n *      On success: true iff an existing delegation is found\n */\n\nstatic bool\nnfs4_delegation_exists(struct nfs4_client *clp, struct nfs4_file *fp)\n{\n\tstruct nfs4_delegation *searchdp = NULL;\n\tstruct nfs4_client *searchclp = NULL;\n\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tlist_for_each_entry(searchdp, &fp->fi_delegations, dl_perfile) {\n\t\tsearchclp = searchdp->dl_stid.sc_client;\n\t\tif (clp == searchclp) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * hash_delegation_locked - Add a delegation to the appropriate lists\n * @dp:     a pointer to the nfs4_delegation we are adding.\n * @fp:     a pointer to the nfs4_file we're granting a delegation on\n *\n * Return:\n *      On success: NULL if the delegation was successfully hashed.\n *\n *      On error: -EAGAIN if one was previously granted to this\n *                 nfs4_client for this nfs4_file. Delegation is not hashed.\n *\n */\n\nstatic int\nhash_delegation_locked(struct nfs4_delegation *dp, struct nfs4_file *fp)\n{\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (nfs4_delegation_exists(clp, fp))\n\t\treturn -EAGAIN;\n\trefcount_inc(&dp->dl_stid.sc_count);\n\tdp->dl_stid.sc_type = NFS4_DELEG_STID;\n\tlist_add(&dp->dl_perfile, &fp->fi_delegations);\n\tlist_add(&dp->dl_perclnt, &clp->cl_delegations);\n\treturn 0;\n}\n\nstatic bool\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tif (list_empty(&dp->dl_perfile))\n\t\treturn false;\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n\treturn true;\n}\n\nstatic void destroy_delegation(struct nfs4_delegation *dp)\n{\n\tbool unhashed;\n\n\tspin_lock(&state_lock);\n\tunhashed = unhash_delegation_locked(dp);\n\tspin_unlock(&state_lock);\n\tif (unhashed)\n\t\tdestroy_unhashed_deleg(dp);\n}\n\nstatic void revoke_delegation(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tWARN_ON(!list_empty(&dp->dl_recall_lru));\n\n\tif (clp->cl_minorversion) {\n\t\tdp->dl_stid.sc_type = NFS4_REVOKED_DELEG_STID;\n\t\trefcount_inc(&dp->dl_stid.sc_count);\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_add(&dp->dl_recall_lru, &clp->cl_revoked);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\tdestroy_unhashed_deleg(dp);\n}\n\n/* \n * SETCLIENTID state \n */\n\nstatic unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}\n\nstatic unsigned int clientstr_hashval(struct xdr_netobj name)\n{\n\treturn opaque_hashval(name.data, 8) & CLIENT_HASH_MASK;\n}\n\n/*\n * We store the NONE, READ, WRITE, and BOTH bits separately in the\n * st_{access,deny}_bmap field of the stateid, in order to track not\n * only what share bits are currently in force, but also what\n * combinations of share bits previous opens have used.  This allows us\n * to enforce the recommendation of rfc 3530 14.2.19 that the server\n * return an error if the client attempt to downgrade to a combination\n * of share bits not explicable by closing some of its previous opens.\n *\n * XXX: This enforcement is actually incomplete, since we don't keep\n * track of access/deny bit combinations; so, e.g., we allow:\n *\n *\tOPEN allow read, deny write\n *\tOPEN allow both, deny none\n *\tDOWNGRADE allow read, deny none\n *\n * which we should reject.\n */\nstatic unsigned int\nbmap_to_share_mode(unsigned long bmap) {\n\tint i;\n\tunsigned int access = 0;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_bit(i, &bmap))\n\t\t\taccess |= i;\n\t}\n\treturn access;\n}\n\n/* set share access for a given stateid */\nstatic inline void\nset_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap |= mask;\n}\n\n/* clear share access for a given stateid */\nstatic inline void\nclear_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap &= ~mask;\n}\n\n/* test whether a given stateid has access */\nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}\n\n/* set share deny for a given stateid */\nstatic inline void\nset_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap |= mask;\n}\n\n/* clear share deny for a given stateid */\nstatic inline void\nclear_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap &= ~mask;\n}\n\n/* test whether a given stateid is denying specific access */\nstatic inline bool\ntest_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\treturn (bool)(stp->st_deny_bmap & mask);\n}\n\nstatic int nfs4_access_to_omode(u32 access)\n{\n\tswitch (access & NFS4_SHARE_ACCESS_BOTH) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\treturn O_RDONLY;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\treturn O_WRONLY;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\treturn O_RDWR;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn O_RDONLY;\n}\n\n/*\n * A stateid that had a deny mode associated with it is being released\n * or downgraded. Recalculate the deny mode on the file.\n */\nstatic void\nrecalculate_deny_mode(struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_share_deny = 0;\n\tlist_for_each_entry(stp, &fp->fi_stateids, st_perfile)\n\t\tfp->fi_share_deny |= bmap_to_share_mode(stp->st_deny_bmap);\n\tspin_unlock(&fp->fi_lock);\n}\n\nstatic void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t/* Recalculate per-file deny mode if there was a change */\n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}\n\n/* release all access and file references for a given stateid */\nstatic void\nrelease_all_access(struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tif (fp && stp->st_deny_bmap != 0)\n\t\trecalculate_deny_mode(fp);\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_access(i, stp))\n\t\t\tnfs4_file_put_access(stp->st_stid.sc_file, i);\n\t\tclear_access(i, stp);\n\t}\n}\n\nstatic inline void nfs4_free_stateowner(struct nfs4_stateowner *sop)\n{\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}\n\nstatic bool\nnfs4_ol_stateid_unhashed(const struct nfs4_ol_stateid *stp)\n{\n\treturn list_empty(&stp->st_perfile);\n}\n\nstatic bool unhash_ol_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&stp->st_stateowner->so_client->cl_lock);\n\n\tif (list_empty(&stp->st_perfile))\n\t\treturn false;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&stp->st_perfile);\n\tspin_unlock(&fp->fi_lock);\n\tlist_del(&stp->st_perstateowner);\n\treturn true;\n}\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(stid);\n\n\tput_clnt_odstate(stp->st_clnt_odstate);\n\trelease_all_access(stp);\n\tif (stp->st_stateowner)\n\t\tnfs4_put_stateowner(stp->st_stateowner);\n\tkmem_cache_free(stateid_slab, stid);\n}\n\nstatic void nfs4_free_lock_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(stid);\n\tstruct nfs4_lockowner *lo = lockowner(stp->st_stateowner);\n\tstruct nfsd_file *nf;\n\n\tnf = find_any_file(stp->st_stid.sc_file);\n\tif (nf) {\n\t\tget_file(nf->nf_file);\n\t\tfilp_close(nf->nf_file, (fl_owner_t)lo);\n\t\tnfsd_file_put(nf);\n\t}\n\tnfs4_free_ol_stateid(stid);\n}\n\n/*\n * Put the persistent reference to an already unhashed generic stateid, while\n * holding the cl_lock. If it's the last reference, then put it onto the\n * reaplist for later destruction.\n */\nstatic void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!refcount_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}\n\nstatic bool unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tif (!unhash_ol_stateid(stp))\n\t\treturn false;\n\tlist_del_init(&stp->st_locks);\n\tnfs4_unhash_stid(&stp->st_stid);\n\treturn true;\n}\n\nstatic void release_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_client *clp = stp->st_stid.sc_client;\n\tbool unhashed;\n\n\tspin_lock(&clp->cl_lock);\n\tunhashed = unhash_lock_stateid(stp);\n\tspin_unlock(&clp->cl_lock);\n\tif (unhashed)\n\t\tnfs4_put_stid(&stp->st_stid);\n}\n\nstatic void unhash_lockowner_locked(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&lo->lo_owner.so_strhash);\n}\n\n/*\n * Free a list of generic stateids that were collected earlier after being\n * fully unhashed.\n */\nstatic void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}\n\nstatic void release_open_stateid_locks(struct nfs4_ol_stateid *open_stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tlockdep_assert_held(&open_stp->st_stid.sc_client->cl_lock);\n\n\twhile (!list_empty(&open_stp->st_locks)) {\n\t\tstp = list_entry(open_stp->st_locks.next,\n\t\t\t\tstruct nfs4_ol_stateid, st_locks);\n\t\tWARN_ON(!unhash_lock_stateid(stp));\n\t\tput_ol_stateid_locked(stp, reaplist);\n\t}\n}\n\nstatic bool unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tif (!unhash_ol_stateid(stp))\n\t\treturn false;\n\trelease_open_stateid_locks(stp, reaplist);\n\treturn true;\n}\n\nstatic void release_open_stateid(struct nfs4_ol_stateid *stp)\n{\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&stp->st_stid.sc_client->cl_lock);\n\tif (unhash_open_stateid(stp, &reaplist))\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\tspin_unlock(&stp->st_stid.sc_client->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n}\n\nstatic void unhash_openowner_locked(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&oo->oo_owner.so_strhash);\n\tlist_del_init(&oo->oo_perclient);\n}\n\nstatic void release_last_closed_stateid(struct nfs4_openowner *oo)\n{\n\tstruct nfsd_net *nn = net_generic(oo->oo_owner.so_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\tstruct nfs4_ol_stateid *s;\n\n\tspin_lock(&nn->client_lock);\n\ts = oo->oo_last_closed_stid;\n\tif (s) {\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\too->oo_last_closed_stid = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tif (s)\n\t\tnfs4_put_stid(&s->st_stid);\n}\n\nstatic void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tif (unhash_open_stateid(stp, &reaplist))\n\t\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}\n\nstatic inline int\nhash_sessionid(struct nfs4_sessionid *sessionid)\n{\n\tstruct nfsd4_sessionid *sid = (struct nfsd4_sessionid *)sessionid;\n\n\treturn sid->sequence % SESSION_HASH_SIZE;\n}\n\n#ifdef CONFIG_SUNRPC_DEBUG\nstatic inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n\tu32 *ptr = (u32 *)(&sessionid->data[0]);\n\tdprintk(\"%s: %u:%u:%u:%u\\n\", fn, ptr[0], ptr[1], ptr[2], ptr[3]);\n}\n#else\nstatic inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n}\n#endif\n\n/*\n * Bump the seqid on cstate->replay_owner, and clear replay_owner if it\n * won't be used for replay.\n */\nvoid nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}\n\nstatic void\ngen_sessionid(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_sessionid *sid;\n\n\tsid = (struct nfsd4_sessionid *)ses->se_sessionid.data;\n\tsid->clientid = clp->cl_clientid;\n\tsid->sequence = current_sessionid++;\n\tsid->reserved = 0;\n}\n\n/*\n * The protocol defines ca_maxresponssize_cached to include the size of\n * the rpc header, but all we need to cache is the data starting after\n * the end of the initial SEQUENCE operation--the rest we regenerate\n * each time.  Therefore we can advertise a ca_maxresponssize_cached\n * value that is the number of bytes in our cache plus a few additional\n * bytes.  In order to stay on the safe side, and not promise more than\n * we can cache, those additional bytes must be the minimum possible: 24\n * bytes of rpc header (xid through accept state, with AUTH_NULL\n * verifier), 12 for the compound header (with zero-length tag), and 44\n * for the SEQUENCE op response:\n */\n#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)\n\nstatic void\nfree_session_slots(struct nfsd4_session *ses)\n{\n\tint i;\n\n\tfor (i = 0; i < ses->se_fchannel.maxreqs; i++) {\n\t\tfree_svc_cred(&ses->se_slots[i]->sl_cred);\n\t\tkfree(ses->se_slots[i]);\n\t}\n}\n\n/*\n * We don't actually need to cache the rpc and session headers, so we\n * can allocate a little less for each slot:\n */\nstatic inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}\n\n/*\n * XXX: If we run out of reserved DRC memory we could (up to a point)\n * re-negotiate active sessions and reduce their slot usage to make\n * room for new connections. For now we just fail the create session.\n */\nstatic u32 nfsd4_get_drc_mem(struct nfsd4_channel_attrs *ca, struct nfsd_net *nn)\n{\n\tu32 slotsize = slot_bytes(ca);\n\tu32 num = ca->maxreqs;\n\tunsigned long avail, total_avail;\n\tunsigned int scale_factor;\n\n\tspin_lock(&nfsd_drc_lock);\n\tif (nfsd_drc_max_mem > nfsd_drc_mem_used)\n\t\ttotal_avail = nfsd_drc_max_mem - nfsd_drc_mem_used;\n\telse\n\t\t/* We have handed out more space than we chose in\n\t\t * set_max_drc() to allow.  That isn't really a\n\t\t * problem as long as that doesn't make us think we\n\t\t * have lots more due to integer overflow.\n\t\t */\n\t\ttotal_avail = 0;\n\tavail = min((unsigned long)NFSD_MAX_MEM_PER_SESSION, total_avail);\n\t/*\n\t * Never use more than a fraction of the remaining memory,\n\t * unless it's the only way to give this client a slot.\n\t * The chosen fraction is either 1/8 or 1/number of threads,\n\t * whichever is smaller.  This ensures there are adequate\n\t * slots to support multiple clients per thread.\n\t * Give the client one slot even if that would require\n\t * over-allocation--it is better than failure.\n\t */\n\tscale_factor = max_t(unsigned int, 8, nn->nfsd_serv->sv_nrthreads);\n\n\tavail = clamp_t(unsigned long, avail, slotsize,\n\t\t\ttotal_avail/scale_factor);\n\tnum = min_t(int, num, avail / slotsize);\n\tnum = max_t(int, num, 1);\n\tnfsd_drc_mem_used += num * slotsize;\n\tspin_unlock(&nfsd_drc_lock);\n\n\treturn num;\n}\n\nstatic void nfsd4_put_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tint slotsize = slot_bytes(ca);\n\n\tspin_lock(&nfsd_drc_lock);\n\tnfsd_drc_mem_used -= slotsize * ca->maxreqs;\n\tspin_unlock(&nfsd_drc_lock);\n}\n\nstatic struct nfsd4_session *alloc_session(struct nfsd4_channel_attrs *fattrs,\n\t\t\t\t\t   struct nfsd4_channel_attrs *battrs)\n{\n\tint numslots = fattrs->maxreqs;\n\tint slotsize = slot_bytes(fattrs);\n\tstruct nfsd4_session *new;\n\tint mem, i;\n\n\tBUILD_BUG_ON(NFSD_MAX_SLOTS_PER_SESSION * sizeof(struct nfsd4_slot *)\n\t\t\t+ sizeof(struct nfsd4_session) > PAGE_SIZE);\n\tmem = numslots * sizeof(struct nfsd4_slot *);\n\n\tnew = kzalloc(sizeof(*new) + mem, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\t/* allocate each struct nfsd4_slot and data cache in one piece */\n\tfor (i = 0; i < numslots; i++) {\n\t\tnew->se_slots[i] = kzalloc(slotsize, GFP_KERNEL);\n\t\tif (!new->se_slots[i])\n\t\t\tgoto out_free;\n\t}\n\n\tmemcpy(&new->se_fchannel, fattrs, sizeof(struct nfsd4_channel_attrs));\n\tmemcpy(&new->se_bchannel, battrs, sizeof(struct nfsd4_channel_attrs));\n\n\treturn new;\nout_free:\n\twhile (i--)\n\t\tkfree(new->se_slots[i]);\n\tkfree(new);\n\treturn NULL;\n}\n\nstatic void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}\n\nstatic void nfsd4_conn_lost(struct svc_xpt_user *u)\n{\n\tstruct nfsd4_conn *c = container_of(u, struct nfsd4_conn, cn_xpt_user);\n\tstruct nfs4_client *clp = c->cn_session->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\tif (!list_empty(&c->cn_persession)) {\n\t\tlist_del(&c->cn_persession);\n\t\tfree_conn(c);\n\t}\n\tnfsd4_probe_callback(clp);\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic struct nfsd4_conn *alloc_conn(struct svc_rqst *rqstp, u32 flags)\n{\n\tstruct nfsd4_conn *conn;\n\n\tconn = kmalloc(sizeof(struct nfsd4_conn), GFP_KERNEL);\n\tif (!conn)\n\t\treturn NULL;\n\tsvc_xprt_get(rqstp->rq_xprt);\n\tconn->cn_xprt = rqstp->rq_xprt;\n\tconn->cn_flags = flags;\n\tINIT_LIST_HEAD(&conn->cn_xpt_user.list);\n\treturn conn;\n}\n\nstatic void __nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tconn->cn_session = ses;\n\tlist_add(&conn->cn_persession, &ses->se_conns);\n}\n\nstatic void nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\t__nfsd4_hash_conn(conn, ses);\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic int nfsd4_register_conn(struct nfsd4_conn *conn)\n{\n\tconn->cn_xpt_user.callback = nfsd4_conn_lost;\n\treturn register_xpt_user(conn->cn_xprt, &conn->cn_xpt_user);\n}\n\nstatic void nfsd4_init_conn(struct svc_rqst *rqstp, struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tint ret;\n\n\tnfsd4_hash_conn(conn, ses);\n\tret = nfsd4_register_conn(conn);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&conn->cn_xpt_user);\n\t/* We may have gained or lost a callback channel: */\n\tnfsd4_probe_callback_sync(ses->se_client);\n}\n\nstatic struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}\n\n/* must be called under client_lock */\nstatic void nfsd4_del_conns(struct nfsd4_session *s)\n{\n\tstruct nfs4_client *clp = s->se_client;\n\tstruct nfsd4_conn *c;\n\n\tspin_lock(&clp->cl_lock);\n\twhile (!list_empty(&s->se_conns)) {\n\t\tc = list_first_entry(&s->se_conns, struct nfsd4_conn, cn_persession);\n\t\tlist_del_init(&c->cn_persession);\n\t\tspin_unlock(&clp->cl_lock);\n\n\t\tunregister_xpt_user(c->cn_xprt, &c->cn_xpt_user);\n\t\tfree_conn(c);\n\n\t\tspin_lock(&clp->cl_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic void __free_session(struct nfsd4_session *ses)\n{\n\tfree_session_slots(ses);\n\tkfree(ses);\n}\n\nstatic void free_session(struct nfsd4_session *ses)\n{\n\tnfsd4_del_conns(ses);\n\tnfsd4_put_drc_mem(&ses->se_fchannel);\n\t__free_session(ses);\n}\n\nstatic void init_session(struct svc_rqst *rqstp, struct nfsd4_session *new, struct nfs4_client *clp, struct nfsd4_create_session *cses)\n{\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew->se_client = clp;\n\tgen_sessionid(new);\n\n\tINIT_LIST_HEAD(&new->se_conns);\n\n\tnew->se_cb_seq_nr = 1;\n\tnew->se_flags = cses->flags;\n\tnew->se_cb_prog = cses->callback_prog;\n\tnew->se_cb_sec = cses->cb_sec;\n\tatomic_set(&new->se_ref, 0);\n\tidx = hash_sessionid(&new->se_sessionid);\n\tlist_add(&new->se_hash, &nn->sessionid_hashtbl[idx]);\n\tspin_lock(&clp->cl_lock);\n\tlist_add(&new->se_perclnt, &clp->cl_sessions);\n\tspin_unlock(&clp->cl_lock);\n\n\t{\n\t\tstruct sockaddr *sa = svc_addr(rqstp);\n\t\t/*\n\t\t * This is a little silly; with sessions there's no real\n\t\t * use for the callback address.  Use the peer address\n\t\t * as a reasonable default for now, but consider fixing\n\t\t * the rpc client not to require an address in the\n\t\t * future:\n\t\t */\n\t\trpc_copy_addr((struct sockaddr *)&clp->cl_cb_conn.cb_addr, sa);\n\t\tclp->cl_cb_conn.cb_addrlen = svc_addr_len(sa);\n\t}\n}\n\n/* caller must hold client_lock */\nstatic struct nfsd4_session *\n__find_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net)\n{\n\tstruct nfsd4_session *elem;\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdump_sessionid(__func__, sessionid);\n\tidx = hash_sessionid(sessionid);\n\t/* Search in the appropriate list */\n\tlist_for_each_entry(elem, &nn->sessionid_hashtbl[idx], se_hash) {\n\t\tif (!memcmp(elem->se_sessionid.data, sessionid->data,\n\t\t\t    NFS4_MAX_SESSIONID_LEN)) {\n\t\t\treturn elem;\n\t\t}\n\t}\n\n\tdprintk(\"%s: session not found\\n\", __func__);\n\treturn NULL;\n}\n\nstatic struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}\n\n/* caller must hold client_lock */\nstatic void\nunhash_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tlist_del(&ses->se_hash);\n\tspin_lock(&ses->se_client->cl_lock);\n\tlist_del(&ses->se_perclnt);\n\tspin_unlock(&ses->se_client->cl_lock);\n}\n\n/* SETCLIENTID and SETCLIENTID_CONFIRM Helper functions */\nstatic int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\ttrace_nfsd_clid_stale(clid);\n\treturn 1;\n}\n\n/* \n * XXX Should we use a slab cache ?\n * This type of memory management is somewhat inefficient, but we use it\n * anyway since SETCLIENTID is not a common operation.\n */\nstatic struct nfs4_client *alloc_client(struct xdr_netobj name)\n{\n\tstruct nfs4_client *clp;\n\tint i;\n\n\tclp = kmem_cache_zalloc(client_slab, GFP_KERNEL);\n\tif (clp == NULL)\n\t\treturn NULL;\n\txdr_netobj_dup(&clp->cl_name, &name, GFP_KERNEL);\n\tif (clp->cl_name.data == NULL)\n\t\tgoto err_no_name;\n\tclp->cl_ownerstr_hashtbl = kmalloc_array(OWNER_HASH_SIZE,\n\t\t\t\t\t\t sizeof(struct list_head),\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!clp->cl_ownerstr_hashtbl)\n\t\tgoto err_no_hashtbl;\n\tfor (i = 0; i < OWNER_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&clp->cl_ownerstr_hashtbl[i]);\n\tINIT_LIST_HEAD(&clp->cl_sessions);\n\tidr_init(&clp->cl_stateids);\n\tatomic_set(&clp->cl_rpc_users, 0);\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tINIT_LIST_HEAD(&clp->cl_idhash);\n\tINIT_LIST_HEAD(&clp->cl_openowners);\n\tINIT_LIST_HEAD(&clp->cl_delegations);\n\tINIT_LIST_HEAD(&clp->cl_lru);\n\tINIT_LIST_HEAD(&clp->cl_revoked);\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&clp->cl_lo_states);\n#endif\n\tINIT_LIST_HEAD(&clp->async_copies);\n\tspin_lock_init(&clp->async_lock);\n\tspin_lock_init(&clp->cl_lock);\n\trpc_init_wait_queue(&clp->cl_cb_waitq, \"Backchannel slot table\");\n\treturn clp;\nerr_no_hashtbl:\n\tkfree(clp->cl_name.data);\nerr_no_name:\n\tkmem_cache_free(client_slab, clp);\n\treturn NULL;\n}\n\nstatic void __free_client(struct kref *k)\n{\n\tstruct nfsdfs_client *c = container_of(k, struct nfsdfs_client, cl_ref);\n\tstruct nfs4_client *clp = container_of(c, struct nfs4_client, cl_nfsdfs);\n\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tkfree(clp->cl_nii_domain.data);\n\tkfree(clp->cl_nii_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkmem_cache_free(client_slab, clp);\n}\n\nstatic void drop_client(struct nfs4_client *clp)\n{\n\tkref_put(&clp->cl_nfsdfs.cl_ref, __free_client);\n}\n\nstatic void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tif (clp->cl_nfsd_dentry) {\n\t\tnfsd_client_rmdir(clp->cl_nfsd_dentry);\n\t\tclp->cl_nfsd_dentry = NULL;\n\t\twake_up_all(&expiry_wq);\n\t}\n\tdrop_client(clp);\n}\n\n/* must be called under the client_lock */\nstatic void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic void\nunhash_client(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunhash_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_rpc_users))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}\n\nstatic void\n__destroy_client(struct nfs4_client *clp)\n{\n\tint i;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\twhile (!list_empty(&clp->cl_delegations)) {\n\t\tdp = list_entry(clp->cl_delegations.next, struct nfs4_delegation, dl_perclnt);\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_entry(reaplist.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tdestroy_unhashed_deleg(dp);\n\t}\n\twhile (!list_empty(&clp->cl_revoked)) {\n\t\tdp = list_entry(clp->cl_revoked.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_openowners)) {\n\t\too = list_entry(clp->cl_openowners.next, struct nfs4_openowner, oo_perclient);\n\t\tnfs4_get_stateowner(&oo->oo_owner);\n\t\trelease_openowner(oo);\n\t}\n\tfor (i = 0; i < OWNER_HASH_SIZE; i++) {\n\t\tstruct nfs4_stateowner *so, *tmp;\n\n\t\tlist_for_each_entry_safe(so, tmp, &clp->cl_ownerstr_hashtbl[i],\n\t\t\t\t\t so_strhash) {\n\t\t\t/* Should be no openowners at this point */\n\t\t\tWARN_ON_ONCE(so->so_is_open_owner);\n\t\t\tremove_blocked_locks(lockowner(so));\n\t\t}\n\t}\n\tnfsd4_return_all_client_layouts(clp);\n\tnfsd4_shutdown_copy(clp);\n\tnfsd4_shutdown_callback(clp);\n\tif (clp->cl_cb_conn.cb_xprt)\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\tfree_client(clp);\n\twake_up_all(&expiry_wq);\n}\n\nstatic void\ndestroy_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\t__destroy_client(clp);\n}\n\nstatic void inc_reclaim_complete(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (!nn->track_reclaim_completes)\n\t\treturn;\n\tif (!nfsd4_find_reclaim_client(clp->cl_name, nn))\n\t\treturn;\n\tif (atomic_inc_return(&nn->nr_reclaim_complete) ==\n\t\t\tnn->reclaim_str_hashtbl_size) {\n\t\tprintk(KERN_INFO \"NFSD: all clients done reclaiming, ending NFSv4 grace period (net %x)\\n\",\n\t\t\t\tclp->net->ns.inum);\n\t\tnfsd4_end_grace(nn);\n\t}\n}\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}\n\nstatic void copy_verf(struct nfs4_client *target, nfs4_verifier *source)\n{\n\tmemcpy(target->cl_verifier.data, source->data,\n\t\t\tsizeof(target->cl_verifier.data));\n}\n\nstatic void copy_clid(struct nfs4_client *target, struct nfs4_client *source)\n{\n\ttarget->cl_clientid.cl_boot = source->cl_clientid.cl_boot; \n\ttarget->cl_clientid.cl_id = source->cl_clientid.cl_id; \n}\n\nstatic int copy_cred(struct svc_cred *target, struct svc_cred *source)\n{\n\ttarget->cr_principal = kstrdup(source->cr_principal, GFP_KERNEL);\n\ttarget->cr_raw_principal = kstrdup(source->cr_raw_principal,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\ttarget->cr_targ_princ = kstrdup(source->cr_targ_princ, GFP_KERNEL);\n\tif ((source->cr_principal && !target->cr_principal) ||\n\t    (source->cr_raw_principal && !target->cr_raw_principal) ||\n\t    (source->cr_targ_princ && !target->cr_targ_princ))\n\t\treturn -ENOMEM;\n\n\ttarget->cr_flavor = source->cr_flavor;\n\ttarget->cr_uid = source->cr_uid;\n\ttarget->cr_gid = source->cr_gid;\n\ttarget->cr_group_info = source->cr_group_info;\n\tget_group_info(target->cr_group_info);\n\ttarget->cr_gss_mech = source->cr_gss_mech;\n\tif (source->cr_gss_mech)\n\t\tgss_mech_get(source->cr_gss_mech);\n\treturn 0;\n}\n\nstatic int\ncompare_blob(const struct xdr_netobj *o1, const struct xdr_netobj *o2)\n{\n\tif (o1->len < o2->len)\n\t\treturn -1;\n\tif (o1->len > o2->len)\n\t\treturn 1;\n\treturn memcmp(o1->data, o2->data, o1->len);\n}\n\nstatic int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}\n\nstatic int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}\n\nstatic bool groups_equal(struct group_info *g1, struct group_info *g2)\n{\n\tint i;\n\n\tif (g1->ngroups != g2->ngroups)\n\t\treturn false;\n\tfor (i=0; i<g1->ngroups; i++)\n\t\tif (!gid_eq(g1->gid[i], g2->gid[i]))\n\t\t\treturn false;\n\treturn true;\n}\n\n/*\n * RFC 3530 language requires clid_inuse be returned when the\n * \"principal\" associated with a requests differs from that previously\n * used.  We use uid, gid's, and gss principal string as our best\n * approximation.  We also don't want to allow non-gss use of a client\n * established using gss: in theory cr_principal should catch that\n * change, but in practice cr_principal can be null even in the gss case\n * since gssd doesn't always pass down a principal string.\n */\nstatic bool is_gss_cred(struct svc_cred *cr)\n{\n\t/* Is cr_flavor one of the gss \"pseudoflavors\"?: */\n\treturn (cr->cr_flavor > RPC_AUTH_MAXFLAVOR);\n}\n\n\nstatic bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\t/* XXX: check that cr_targ_princ fields match ? */\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}\n\nstatic bool svc_rqst_integrity_protected(struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\tu32 service;\n\n\tif (!cr->cr_gss_mech)\n\t\treturn false;\n\tservice = gss_pseudoflavor_to_service(cr->cr_gss_mech, cr->cr_flavor);\n\treturn service == RPC_GSS_SVC_INTEGRITY ||\n\t       service == RPC_GSS_SVC_PRIVACY;\n}\n\nbool nfsd4_mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (cl->cl_cred.cr_raw_principal)\n\t\treturn 0 == strcmp(cl->cl_cred.cr_raw_principal,\n\t\t\t\t\t\tcr->cr_raw_principal);\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}\n\nstatic void gen_confirm(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\t__be32 verf[2];\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)(u32)ktime_get_real_seconds();\n\tverf[1] = (__force __be32)nn->clverifier_counter++;\n\tmemcpy(clp->cl_confirm.data, verf, sizeof(clp->cl_confirm.data));\n}\n\nstatic void gen_clid(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\tclp->cl_clientid.cl_boot = (u32)nn->boot_time;\n\tclp->cl_clientid.cl_id = nn->clientid_counter++;\n\tgen_confirm(clp, nn);\n}\n\nstatic struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}\n\nstatic struct nfs4_stid *\nfind_stateid_by_type(struct nfs4_client *cl, stateid_t *t, char typemask)\n{\n\tstruct nfs4_stid *s;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, t);\n\tif (s != NULL) {\n\t\tif (typemask & s->sc_type)\n\t\t\trefcount_inc(&s->sc_count);\n\t\telse\n\t\t\ts = NULL;\n\t}\n\tspin_unlock(&cl->cl_lock);\n\treturn s;\n}\n\nstatic struct nfs4_client *get_nfsdfs_clp(struct inode *inode)\n{\n\tstruct nfsdfs_client *nc;\n\tnc = get_nfsdfs_client(inode);\n\tif (!nc)\n\t\treturn NULL;\n\treturn container_of(nc, struct nfs4_client, cl_nfsdfs);\n}\n\nstatic void seq_quote_mem(struct seq_file *m, char *data, int len)\n{\n\tseq_printf(m, \"\\\"\");\n\tseq_escape_mem_ascii(m, data, len);\n\tseq_printf(m, \"\\\"\");\n}\n\nstatic int client_info_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct nfs4_client *clp;\n\tu64 clid;\n\n\tclp = get_nfsdfs_clp(inode);\n\tif (!clp)\n\t\treturn -ENXIO;\n\tmemcpy(&clid, &clp->cl_clientid, sizeof(clid));\n\tseq_printf(m, \"clientid: 0x%llx\\n\", clid);\n\tseq_printf(m, \"address: \\\"%pISpc\\\"\\n\", (struct sockaddr *)&clp->cl_addr);\n\tseq_printf(m, \"name: \");\n\tseq_quote_mem(m, clp->cl_name.data, clp->cl_name.len);\n\tseq_printf(m, \"\\nminor version: %d\\n\", clp->cl_minorversion);\n\tif (clp->cl_nii_domain.data) {\n\t\tseq_printf(m, \"Implementation domain: \");\n\t\tseq_quote_mem(m, clp->cl_nii_domain.data,\n\t\t\t\t\tclp->cl_nii_domain.len);\n\t\tseq_printf(m, \"\\nImplementation name: \");\n\t\tseq_quote_mem(m, clp->cl_nii_name.data, clp->cl_nii_name.len);\n\t\tseq_printf(m, \"\\nImplementation time: [%lld, %ld]\\n\",\n\t\t\tclp->cl_nii_time.tv_sec, clp->cl_nii_time.tv_nsec);\n\t}\n\tdrop_client(clp);\n\n\treturn 0;\n}\n\nstatic int client_info_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, client_info_show, inode);\n}\n\nstatic const struct file_operations client_info_fops = {\n\t.open\t\t= client_info_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic void *states_start(struct seq_file *s, loff_t *pos)\n\t__acquires(&clp->cl_lock)\n{\n\tstruct nfs4_client *clp = s->private;\n\tunsigned long id = *pos;\n\tvoid *ret;\n\n\tspin_lock(&clp->cl_lock);\n\tret = idr_get_next_ul(&clp->cl_stateids, &id);\n\t*pos = id;\n\treturn ret;\n}\n\nstatic void *states_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct nfs4_client *clp = s->private;\n\tunsigned long id = *pos;\n\tvoid *ret;\n\n\tid = *pos;\n\tid++;\n\tret = idr_get_next_ul(&clp->cl_stateids, &id);\n\t*pos = id;\n\treturn ret;\n}\n\nstatic void states_stop(struct seq_file *s, void *v)\n\t__releases(&clp->cl_lock)\n{\n\tstruct nfs4_client *clp = s->private;\n\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic void nfs4_show_fname(struct seq_file *s, struct nfsd_file *f)\n{\n         seq_printf(s, \"filename: \\\"%pD2\\\"\", f->nf_file);\n}\n\nstatic void nfs4_show_superblock(struct seq_file *s, struct nfsd_file *f)\n{\n\tstruct inode *inode = f->nf_inode;\n\n\tseq_printf(s, \"superblock: \\\"%02x:%02x:%ld\\\"\",\n\t\t\t\t\tMAJOR(inode->i_sb->s_dev),\n\t\t\t\t\t MINOR(inode->i_sb->s_dev),\n\t\t\t\t\t inode->i_ino);\n}\n\nstatic void nfs4_show_owner(struct seq_file *s, struct nfs4_stateowner *oo)\n{\n\tseq_printf(s, \"owner: \");\n\tseq_quote_mem(s, oo->so_owner.data, oo->so_owner.len);\n}\n\nstatic void nfs4_show_stateid(struct seq_file *s, stateid_t *stid)\n{\n\tseq_printf(s, \"0x%.8x\", stid->si_generation);\n\tseq_printf(s, \"%12phN\", &stid->si_opaque);\n}\n\nstatic int nfs4_show_open(struct seq_file *s, struct nfs4_stid *st)\n{\n\tstruct nfs4_ol_stateid *ols;\n\tstruct nfs4_file *nf;\n\tstruct nfsd_file *file;\n\tstruct nfs4_stateowner *oo;\n\tunsigned int access, deny;\n\n\tif (st->sc_type != NFS4_OPEN_STID && st->sc_type != NFS4_LOCK_STID)\n\t\treturn 0; /* XXX: or SEQ_SKIP? */\n\tols = openlockstateid(st);\n\too = ols->st_stateowner;\n\tnf = st->sc_file;\n\tfile = find_any_file(nf);\n\tif (!file)\n\t\treturn 0;\n\n\tseq_printf(s, \"- \");\n\tnfs4_show_stateid(s, &st->sc_stateid);\n\tseq_printf(s, \": { type: open, \");\n\n\taccess = bmap_to_share_mode(ols->st_access_bmap);\n\tdeny   = bmap_to_share_mode(ols->st_deny_bmap);\n\n\tseq_printf(s, \"access: %s%s, \",\n\t\taccess & NFS4_SHARE_ACCESS_READ ? \"r\" : \"-\",\n\t\taccess & NFS4_SHARE_ACCESS_WRITE ? \"w\" : \"-\");\n\tseq_printf(s, \"deny: %s%s, \",\n\t\tdeny & NFS4_SHARE_ACCESS_READ ? \"r\" : \"-\",\n\t\tdeny & NFS4_SHARE_ACCESS_WRITE ? \"w\" : \"-\");\n\n\tnfs4_show_superblock(s, file);\n\tseq_printf(s, \", \");\n\tnfs4_show_fname(s, file);\n\tseq_printf(s, \", \");\n\tnfs4_show_owner(s, oo);\n\tseq_printf(s, \" }\\n\");\n\tnfsd_file_put(file);\n\n\treturn 0;\n}\n\nstatic int nfs4_show_lock(struct seq_file *s, struct nfs4_stid *st)\n{\n\tstruct nfs4_ol_stateid *ols;\n\tstruct nfs4_file *nf;\n\tstruct nfsd_file *file;\n\tstruct nfs4_stateowner *oo;\n\n\tols = openlockstateid(st);\n\too = ols->st_stateowner;\n\tnf = st->sc_file;\n\tfile = find_any_file(nf);\n\tif (!file)\n\t\treturn 0;\n\n\tseq_printf(s, \"- \");\n\tnfs4_show_stateid(s, &st->sc_stateid);\n\tseq_printf(s, \": { type: lock, \");\n\n\t/*\n\t * Note: a lock stateid isn't really the same thing as a lock,\n\t * it's the locking state held by one owner on a file, and there\n\t * may be multiple (or no) lock ranges associated with it.\n\t * (Same for the matter is true of open stateids.)\n\t */\n\n\tnfs4_show_superblock(s, file);\n\t/* XXX: open stateid? */\n\tseq_printf(s, \", \");\n\tnfs4_show_fname(s, file);\n\tseq_printf(s, \", \");\n\tnfs4_show_owner(s, oo);\n\tseq_printf(s, \" }\\n\");\n\tnfsd_file_put(file);\n\n\treturn 0;\n}\n\nstatic int nfs4_show_deleg(struct seq_file *s, struct nfs4_stid *st)\n{\n\tstruct nfs4_delegation *ds;\n\tstruct nfs4_file *nf;\n\tstruct nfsd_file *file;\n\n\tds = delegstateid(st);\n\tnf = st->sc_file;\n\tfile = find_deleg_file(nf);\n\tif (!file)\n\t\treturn 0;\n\n\tseq_printf(s, \"- \");\n\tnfs4_show_stateid(s, &st->sc_stateid);\n\tseq_printf(s, \": { type: deleg, \");\n\n\t/* Kinda dead code as long as we only support read delegs: */\n\tseq_printf(s, \"access: %s, \",\n\t\tds->dl_type == NFS4_OPEN_DELEGATE_READ ? \"r\" : \"w\");\n\n\t/* XXX: lease time, whether it's being recalled. */\n\n\tnfs4_show_superblock(s, file);\n\tseq_printf(s, \", \");\n\tnfs4_show_fname(s, file);\n\tseq_printf(s, \" }\\n\");\n\tnfsd_file_put(file);\n\n\treturn 0;\n}\n\nstatic int nfs4_show_layout(struct seq_file *s, struct nfs4_stid *st)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfsd_file *file;\n\n\tls = container_of(st, struct nfs4_layout_stateid, ls_stid);\n\tfile = ls->ls_file;\n\n\tseq_printf(s, \"- \");\n\tnfs4_show_stateid(s, &st->sc_stateid);\n\tseq_printf(s, \": { type: layout, \");\n\n\t/* XXX: What else would be useful? */\n\n\tnfs4_show_superblock(s, file);\n\tseq_printf(s, \", \");\n\tnfs4_show_fname(s, file);\n\tseq_printf(s, \" }\\n\");\n\n\treturn 0;\n}\n\nstatic int states_show(struct seq_file *s, void *v)\n{\n\tstruct nfs4_stid *st = v;\n\n\tswitch (st->sc_type) {\n\tcase NFS4_OPEN_STID:\n\t\treturn nfs4_show_open(s, st);\n\tcase NFS4_LOCK_STID:\n\t\treturn nfs4_show_lock(s, st);\n\tcase NFS4_DELEG_STID:\n\t\treturn nfs4_show_deleg(s, st);\n\tcase NFS4_LAYOUT_STID:\n\t\treturn nfs4_show_layout(s, st);\n\tdefault:\n\t\treturn 0; /* XXX: or SEQ_SKIP? */\n\t}\n\t/* XXX: copy stateids? */\n}\n\nstatic struct seq_operations states_seq_ops = {\n\t.start = states_start,\n\t.next = states_next,\n\t.stop = states_stop,\n\t.show = states_show\n};\n\nstatic int client_states_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *s;\n\tstruct nfs4_client *clp;\n\tint ret;\n\n\tclp = get_nfsdfs_clp(inode);\n\tif (!clp)\n\t\treturn -ENXIO;\n\n\tret = seq_open(file, &states_seq_ops);\n\tif (ret)\n\t\treturn ret;\n\ts = file->private_data;\n\ts->private = clp;\n\treturn 0;\n}\n\nstatic int client_opens_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct nfs4_client *clp = m->private;\n\n\t/* XXX: alternatively, we could get/drop in seq start/stop */\n\tdrop_client(clp);\n\treturn 0;\n}\n\nstatic const struct file_operations client_states_fops = {\n\t.open\t\t= client_states_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= client_opens_release,\n};\n\n/*\n * Normally we refuse to destroy clients that are in use, but here the\n * administrator is telling us to just do it.  We also want to wait\n * so the caller has a guarantee that the client's locks are gone by\n * the time the write returns:\n */\nstatic void force_expire_client(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tbool already_expired;\n\n\tspin_lock(&clp->cl_lock);\n\tclp->cl_time = 0;\n\tspin_unlock(&clp->cl_lock);\n\n\twait_event(expiry_wq, atomic_read(&clp->cl_rpc_users) == 0);\n\tspin_lock(&nn->client_lock);\n\talready_expired = list_empty(&clp->cl_lru);\n\tif (!already_expired)\n\t\tunhash_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n\n\tif (!already_expired)\n\t\texpire_client(clp);\n\telse\n\t\twait_event(expiry_wq, clp->cl_nfsd_dentry == NULL);\n}\n\nstatic ssize_t client_ctl_write(struct file *file, const char __user *buf,\n\t\t\t\t   size_t size, loff_t *pos)\n{\n\tchar *data;\n\tstruct nfs4_client *clp;\n\n\tdata = simple_transaction_get(file, buf, size);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\tif (size != 7 || 0 != memcmp(data, \"expire\\n\", 7))\n\t\treturn -EINVAL;\n\tclp = get_nfsdfs_clp(file_inode(file));\n\tif (!clp)\n\t\treturn -ENXIO;\n\tforce_expire_client(clp);\n\tdrop_client(clp);\n\treturn 7;\n}\n\nstatic const struct file_operations client_ctl_fops = {\n\t.write\t\t= client_ctl_write,\n\t.release\t= simple_transaction_release,\n};\n\nstatic const struct tree_descr client_files[] = {\n\t[0] = {\"info\", &client_info_fops, S_IRUSR},\n\t[1] = {\"states\", &client_states_fops, S_IRUSR},\n\t[2] = {\"ctl\", &client_ctl_fops, S_IWUSR},\n\t[3] = {\"\"},\n};\n\nstatic struct nfs4_client *create_client(struct xdr_netobj name,\n\t\tstruct svc_rqst *rqstp, nfs4_verifier *verf)\n{\n\tstruct nfs4_client *clp;\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tint ret;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tclp = alloc_client(name);\n\tif (clp == NULL)\n\t\treturn NULL;\n\n\tret = copy_cred(&clp->cl_cred, &rqstp->rq_cred);\n\tif (ret) {\n\t\tfree_client(clp);\n\t\treturn NULL;\n\t}\n\tgen_clid(clp, nn);\n\tkref_init(&clp->cl_nfsdfs.cl_ref);\n\tnfsd4_init_cb(&clp->cl_cb_null, clp, NULL, NFSPROC4_CLNT_CB_NULL);\n\tclp->cl_time = ktime_get_boottime_seconds();\n\tclear_bit(0, &clp->cl_cb_slot_busy);\n\tcopy_verf(clp, verf);\n\tmemcpy(&clp->cl_addr, sa, sizeof(struct sockaddr_storage));\n\tclp->cl_cb_session = NULL;\n\tclp->net = net;\n\tclp->cl_nfsd_dentry = nfsd_client_mkdir(nn, &clp->cl_nfsdfs,\n\t\t\tclp->cl_clientid.cl_id - nn->clientid_base,\n\t\t\tclient_files);\n\tif (!clp->cl_nfsd_dentry) {\n\t\tfree_client(clp);\n\t\treturn NULL;\n\t}\n\treturn clp;\n}\n\nstatic void\nadd_clp_to_name_tree(struct nfs4_client *new_clp, struct rb_root *root)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct nfs4_client *clp;\n\n\twhile (*new) {\n\t\tclp = rb_entry(*new, struct nfs4_client, cl_namenode);\n\t\tparent = *new;\n\n\t\tif (compare_blob(&clp->cl_name, &new_clp->cl_name) > 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_clp->cl_namenode, parent, new);\n\trb_insert_color(&new_clp->cl_namenode, root);\n}\n\nstatic struct nfs4_client *\nfind_clp_in_name_tree(struct xdr_netobj *name, struct rb_root *root)\n{\n\tint cmp;\n\tstruct rb_node *node = root->rb_node;\n\tstruct nfs4_client *clp;\n\n\twhile (node) {\n\t\tclp = rb_entry(node, struct nfs4_client, cl_namenode);\n\t\tcmp = compare_blob(&clp->cl_name, name);\n\t\tif (cmp > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}\n\nstatic void\nadd_to_unconfirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tclear_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\tadd_clp_to_name_tree(clp, &nn->unconf_name_tree);\n\tidhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tlist_add(&clp->cl_idhash, &nn->unconf_id_hashtbl[idhashval]);\n\trenew_client_locked(clp);\n}\n\nstatic void\nmove_to_confirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdprintk(\"NFSD: move_to_confirm nfs4_client %p\\n\", clp);\n\tlist_move(&clp->cl_idhash, &nn->conf_id_hashtbl[idhashval]);\n\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\tadd_clp_to_name_tree(clp, &nn->conf_name_tree);\n\tset_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\trenew_client_locked(clp);\n}\n\nstatic struct nfs4_client *\nfind_client_in_id_table(struct list_head *tbl, clientid_t *clid, bool sessions)\n{\n\tstruct nfs4_client *clp;\n\tunsigned int idhashval = clientid_hashval(clid->cl_id);\n\n\tlist_for_each_entry(clp, &tbl[idhashval], cl_idhash) {\n\t\tif (same_clid(&clp->cl_clientid, clid)) {\n\t\t\tif ((bool)clp->cl_minorversion != sessions)\n\t\t\t\treturn NULL;\n\t\t\trenew_client_locked(clp);\n\t\t\treturn clp;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}\n\nstatic struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}\n\nstatic bool clp_used_exchangeid(struct nfs4_client *clp)\n{\n\treturn clp->cl_exchange_flags != 0;\n} \n\nstatic struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}\n\nstatic struct nfs4_client *\nfind_unconfirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->unconf_name_tree);\n}\n\nstatic void\ngen_callback(struct nfs4_client *clp, struct nfsd4_setclientid *se, struct svc_rqst *rqstp)\n{\n\tstruct nfs4_cb_conn *conn = &clp->cl_cb_conn;\n\tstruct sockaddr\t*sa = svc_addr(rqstp);\n\tu32 scopeid = rpc_get_scope_id(sa);\n\tunsigned short expected_family;\n\n\t/* Currently, we only support tcp and tcp6 for the callback channel */\n\tif (se->se_callback_netid_len == 3 &&\n\t    !memcmp(se->se_callback_netid_val, \"tcp\", 3))\n\t\texpected_family = AF_INET;\n\telse if (se->se_callback_netid_len == 4 &&\n\t\t !memcmp(se->se_callback_netid_val, \"tcp6\", 4))\n\t\texpected_family = AF_INET6;\n\telse\n\t\tgoto out_err;\n\n\tconn->cb_addrlen = rpc_uaddr2sockaddr(clp->net, se->se_callback_addr_val,\n\t\t\t\t\t    se->se_callback_addr_len,\n\t\t\t\t\t    (struct sockaddr *)&conn->cb_addr,\n\t\t\t\t\t    sizeof(conn->cb_addr));\n\n\tif (!conn->cb_addrlen || conn->cb_addr.ss_family != expected_family)\n\t\tgoto out_err;\n\n\tif (conn->cb_addr.ss_family == AF_INET6)\n\t\t((struct sockaddr_in6 *)&conn->cb_addr)->sin6_scope_id = scopeid;\n\n\tconn->cb_prog = se->se_callback_prog;\n\tconn->cb_ident = se->se_callback_ident;\n\tmemcpy(&conn->cb_saddr, &rqstp->rq_daddr, rqstp->rq_daddrlen);\n\ttrace_nfsd_cb_args(clp, conn);\n\treturn;\nout_err:\n\tconn->cb_addr.ss_family = AF_UNSPEC;\n\tconn->cb_addrlen = 0;\n\ttrace_nfsd_cb_nodelegs(clp);\n\treturn;\n}\n\n/*\n * Cache a reply. nfsd4_check_resp_size() has bounded the cache size.\n */\nstatic void\nnfsd4_store_cache_entry(struct nfsd4_compoundres *resp)\n{\n\tstruct xdr_buf *buf = resp->xdr.buf;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tunsigned int base;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tslot->sl_flags |= NFSD4_SLOT_INITIALIZED;\n\tslot->sl_opcnt = resp->opcnt;\n\tslot->sl_status = resp->cstate.status;\n\tfree_svc_cred(&slot->sl_cred);\n\tcopy_cred(&slot->sl_cred, &resp->rqstp->rq_cred);\n\n\tif (!nfsd4_cache_this(resp)) {\n\t\tslot->sl_flags &= ~NFSD4_SLOT_CACHED;\n\t\treturn;\n\t}\n\tslot->sl_flags |= NFSD4_SLOT_CACHED;\n\n\tbase = resp->cstate.data_offset;\n\tslot->sl_datalen = buf->len - base;\n\tif (read_bytes_from_xdr_buf(buf, base, slot->sl_data, slot->sl_datalen))\n\t\tWARN(1, \"%s: sessions DRC could not cache compound\\n\",\n\t\t     __func__);\n\treturn;\n}\n\n/*\n * Encode the replay sequence operation from the slot values.\n * If cachethis is FALSE encode the uncached rep error on the next\n * operation which sets resp->p and increments resp->opcnt for\n * nfs4svc_encode_compoundres.\n *\n */\nstatic __be32\nnfsd4_enc_sequence_replay(struct nfsd4_compoundargs *args,\n\t\t\t  struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_op *op;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t/* Encode the replayed sequence operation */\n\top = &args->ops[resp->opcnt - 1];\n\tnfsd4_encode_operation(resp, op);\n\n\tif (slot->sl_flags & NFSD4_SLOT_CACHED)\n\t\treturn op->status;\n\tif (args->opcnt == 1) {\n\t\t/*\n\t\t * The original operation wasn't a solo sequence--we\n\t\t * always cache those--so this retry must not match the\n\t\t * original:\n\t\t */\n\t\top->status = nfserr_seq_false_retry;\n\t} else {\n\t\top = &args->ops[resp->opcnt++];\n\t\top->status = nfserr_retry_uncached_rep;\n\t\tnfsd4_encode_operation(resp, op);\n\t}\n\treturn op->status;\n}\n\n/*\n * The sequence operation is not cached because we can use the slot and\n * session values.\n */\nstatic __be32\nnfsd4_replay_cache_entry(struct nfsd4_compoundres *resp,\n\t\t\t struct nfsd4_sequence *seq)\n{\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\t__be32 status;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tstatus = nfsd4_enc_sequence_replay(resp->rqstp->rq_argp, resp);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_reserve_space(xdr, slot->sl_datalen);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_serverfault;\n\t}\n\txdr_encode_opaque_fixed(p, slot->sl_data, slot->sl_datalen);\n\txdr_commit_encode(xdr);\n\n\tresp->opcnt = slot->sl_opcnt;\n\treturn slot->sl_status;\n}\n\n/*\n * Set the exchange_id flags returned by the server.\n */\nstatic void\nnfsd4_set_ex_flags(struct nfs4_client *new, struct nfsd4_exchange_id *clid)\n{\n#ifdef CONFIG_NFSD_PNFS\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_PNFS_MDS;\n#else\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_NON_PNFS;\n#endif\n\n\t/* Referrals are supported, Migration is not. */\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_SUPP_MOVED_REFER;\n\n\t/* set the wire flags to return to client. */\n\tclid->flags = new->cl_exchange_flags;\n}\n\nstatic bool client_has_openowners(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\n\tlist_for_each_entry(oo, &clp->cl_openowners, oo_perclient) {\n\t\tif (!list_empty(&oo->oo_owner.so_stateids))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool client_has_state(struct nfs4_client *clp)\n{\n\treturn client_has_openowners(clp)\n#ifdef CONFIG_NFSD_PNFS\n\t\t|| !list_empty(&clp->cl_lo_states)\n#endif\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions)\n\t\t|| !list_empty(&clp->async_copies);\n}\n\nstatic __be32 copy_impl_id(struct nfs4_client *clp,\n\t\t\t\tstruct nfsd4_exchange_id *exid)\n{\n\tif (!exid->nii_domain.data)\n\t\treturn 0;\n\txdr_netobj_dup(&clp->cl_nii_domain, &exid->nii_domain, GFP_KERNEL);\n\tif (!clp->cl_nii_domain.data)\n\t\treturn nfserr_jukebox;\n\txdr_netobj_dup(&clp->cl_nii_name, &exid->nii_name, GFP_KERNEL);\n\tif (!clp->cl_nii_name.data)\n\t\treturn nfserr_jukebox;\n\tclp->cl_nii_time = exid->nii_time;\n\treturn 0;\n}\n\n__be32\nnfsd4_exchange_id(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_exchange_id *exid = &u->exchange_id;\n\tstruct nfs4_client *conf, *new;\n\tstruct nfs4_client *unconf = NULL;\n\t__be32 status;\n\tchar\t\t\taddr_str[INET6_ADDRSTRLEN];\n\tnfs4_verifier\t\tverf = exid->verifier;\n\tstruct sockaddr\t\t*sa = svc_addr(rqstp);\n\tbool\tupdate = exid->flags & EXCHGID4_FLAG_UPD_CONFIRMED_REC_A;\n\tstruct nfsd_net\t\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\trpc_ntop(sa, addr_str, sizeof(addr_str));\n\tdprintk(\"%s rqstp=%p exid=%p clname.len=%u clname.data=%p \"\n\t\t\"ip_addr=%s flags %x, spa_how %u\\n\",\n\t\t__func__, rqstp, exid, exid->clname.len, exid->clname.data,\n\t\taddr_str, exid->flags, exid->spa_how);\n\n\tif (exid->flags & ~EXCHGID4_FLAG_MASK_A)\n\t\treturn nfserr_inval;\n\n\tnew = create_client(exid->clname, rqstp, &verf);\n\tif (new == NULL)\n\t\treturn nfserr_jukebox;\n\tstatus = copy_impl_id(new, exid);\n\tif (status)\n\t\tgoto out_nolock;\n\n\tswitch (exid->spa_how) {\n\tcase SP4_MACH_CRED:\n\t\texid->spo_must_enforce[0] = 0;\n\t\texid->spo_must_enforce[1] = (\n\t\t\t1 << (OP_BIND_CONN_TO_SESSION - 32) |\n\t\t\t1 << (OP_EXCHANGE_ID - 32) |\n\t\t\t1 << (OP_CREATE_SESSION - 32) |\n\t\t\t1 << (OP_DESTROY_SESSION - 32) |\n\t\t\t1 << (OP_DESTROY_CLIENTID - 32));\n\n\t\texid->spo_must_allow[0] &= (1 << (OP_CLOSE) |\n\t\t\t\t\t1 << (OP_OPEN_DOWNGRADE) |\n\t\t\t\t\t1 << (OP_LOCKU) |\n\t\t\t\t\t1 << (OP_DELEGRETURN));\n\n\t\texid->spo_must_allow[1] &= (\n\t\t\t\t\t1 << (OP_TEST_STATEID - 32) |\n\t\t\t\t\t1 << (OP_FREE_STATEID - 32));\n\t\tif (!svc_rqst_integrity_protected(rqstp)) {\n\t\t\tstatus = nfserr_inval;\n\t\t\tgoto out_nolock;\n\t\t}\n\t\t/*\n\t\t * Sometimes userspace doesn't give us a principal.\n\t\t * Which is a bug, really.  Anyway, we can't enforce\n\t\t * MACH_CRED in that case, better to give up now:\n\t\t */\n\t\tif (!new->cl_cred.cr_principal &&\n\t\t\t\t\t!new->cl_cred.cr_raw_principal) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out_nolock;\n\t\t}\n\t\tnew->cl_mach_cred = true;\n\tcase SP4_NONE:\n\t\tbreak;\n\tdefault:\t\t\t\t/* checked by xdr code */\n\t\tWARN_ON_ONCE(1);\n\t\tfallthrough;\n\tcase SP4_SSV:\n\t\tstatus = nfserr_encr_alg_unsupp;\n\t\tgoto out_nolock;\n\t}\n\n\t/* Cases below refer to rfc 5661 section 18.35.4: */\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client_by_name(&exid->clname, nn);\n\tif (conf) {\n\t\tbool creds_match = same_creds(&conf->cl_cred, &rqstp->rq_cred);\n\t\tbool verfs_match = same_verf(&verf, &conf->cl_verifier);\n\n\t\tif (update) {\n\t\t\tif (!clp_used_exchangeid(conf)) { /* buggy client */\n\t\t\t\tstatus = nfserr_inval;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!nfsd4_mach_creds_match(conf, rqstp)) {\n\t\t\t\tstatus = nfserr_wrong_cred;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!creds_match) { /* case 9 */\n\t\t\t\tstatus = nfserr_perm;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!verfs_match) { /* case 8 */\n\t\t\t\tstatus = nfserr_not_same;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* case 6 */\n\t\t\texid->flags |= EXCHGID4_FLAG_CONFIRMED_R;\n\t\t\tgoto out_copy;\n\t\t}\n\t\tif (!creds_match) { /* case 3 */\n\t\t\tif (client_has_state(conf)) {\n\t\t\t\tstatus = nfserr_clid_inuse;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto out_new;\n\t\t}\n\t\tif (verfs_match) { /* case 2 */\n\t\t\tconf->cl_exchange_flags |= EXCHGID4_FLAG_CONFIRMED_R;\n\t\t\tgoto out_copy;\n\t\t}\n\t\t/* case 5, client reboot */\n\t\tconf = NULL;\n\t\tgoto out_new;\n\t}\n\n\tif (update) { /* case 7 */\n\t\tstatus = nfserr_noent;\n\t\tgoto out;\n\t}\n\n\tunconf  = find_unconfirmed_client_by_name(&exid->clname, nn);\n\tif (unconf) /* case 4, possible retry or client restart */\n\t\tunhash_client_locked(unconf);\n\n\t/* case 1 (normal case) */\nout_new:\n\tif (conf) {\n\t\tstatus = mark_client_expired_locked(conf);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tnew->cl_minorversion = cstate->minorversion;\n\tnew->cl_spo_must_allow.u.words[0] = exid->spo_must_allow[0];\n\tnew->cl_spo_must_allow.u.words[1] = exid->spo_must_allow[1];\n\n\tadd_to_unconfirmed(new);\n\tswap(new, conf);\nout_copy:\n\texid->clientid.cl_boot = conf->cl_clientid.cl_boot;\n\texid->clientid.cl_id = conf->cl_clientid.cl_id;\n\n\texid->seqid = conf->cl_cs_slot.sl_seqid + 1;\n\tnfsd4_set_ex_flags(conf, exid);\n\n\tdprintk(\"nfsd4_exchange_id seqid %d flags %x\\n\",\n\t\tconf->cl_cs_slot.sl_seqid, conf->cl_exchange_flags);\n\tstatus = nfs_ok;\n\nout:\n\tspin_unlock(&nn->client_lock);\nout_nolock:\n\tif (new)\n\t\texpire_client(new);\n\tif (unconf)\n\t\texpire_client(unconf);\n\treturn status;\n}\n\nstatic __be32\ncheck_slot_seqid(u32 seqid, u32 slot_seqid, int slot_inuse)\n{\n\tdprintk(\"%s enter. seqid %d slot_seqid %d\\n\", __func__, seqid,\n\t\tslot_seqid);\n\n\t/* The slot is in use, and no response has been sent. */\n\tif (slot_inuse) {\n\t\tif (seqid == slot_seqid)\n\t\t\treturn nfserr_jukebox;\n\t\telse\n\t\t\treturn nfserr_seq_misordered;\n\t}\n\t/* Note unsigned 32-bit arithmetic handles wraparound: */\n\tif (likely(seqid == slot_seqid + 1))\n\t\treturn nfs_ok;\n\tif (seqid == slot_seqid)\n\t\treturn nfserr_replay_cache;\n\treturn nfserr_seq_misordered;\n}\n\n/*\n * Cache the create session result into the create session single DRC\n * slot cache by saving the xdr structure. sl_seqid has been set.\n * Do this for solo or embedded create session operations.\n */\nstatic void\nnfsd4_cache_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t   struct nfsd4_clid_slot *slot, __be32 nfserr)\n{\n\tslot->sl_status = nfserr;\n\tmemcpy(&slot->sl_cr_ses, cr_ses, sizeof(*cr_ses));\n}\n\nstatic __be32\nnfsd4_replay_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t    struct nfsd4_clid_slot *slot)\n{\n\tmemcpy(cr_ses, &slot->sl_cr_ses, sizeof(*cr_ses));\n\treturn slot->sl_status;\n}\n\n#define NFSD_MIN_REQ_HDR_SEQ_SZ\t((\\\n\t\t\t2 * 2 + /* credential,verifier: AUTH_NULL, length 0 */ \\\n\t\t\t1 +\t/* MIN tag is length with zero, only length */ \\\n\t\t\t3 +\t/* version, opcount, opcode */ \\\n\t\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + \\\n\t\t\t\t/* seqid, slotID, slotID, cache */ \\\n\t\t\t4 ) * sizeof(__be32))\n\n#define NFSD_MIN_RESP_HDR_SEQ_SZ ((\\\n\t\t\t2 +\t/* verifier: AUTH_NULL, length 0 */\\\n\t\t\t1 +\t/* status */ \\\n\t\t\t1 +\t/* MIN tag is length with zero, only length */ \\\n\t\t\t3 +\t/* opcount, opcode, opstatus*/ \\\n\t\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + \\\n\t\t\t\t/* seqid, slotID, slotID, slotID, status */ \\\n\t\t\t5 ) * sizeof(__be32))\n\nstatic __be32 check_forechannel_attrs(struct nfsd4_channel_attrs *ca, struct nfsd_net *nn)\n{\n\tu32 maxrpc = nn->nfsd_serv->sv_max_mesg;\n\n\tif (ca->maxreq_sz < NFSD_MIN_REQ_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_MIN_RESP_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tca->headerpadsz = 0;\n\tca->maxreq_sz = min_t(u32, ca->maxreq_sz, maxrpc);\n\tca->maxresp_sz = min_t(u32, ca->maxresp_sz, maxrpc);\n\tca->maxops = min_t(u32, ca->maxops, NFSD_MAX_OPS_PER_COMPOUND);\n\tca->maxresp_cached = min_t(u32, ca->maxresp_cached,\n\t\t\tNFSD_SLOT_CACHE_SIZE + NFSD_MIN_HDR_SEQ_SZ);\n\tca->maxreqs = min_t(u32, ca->maxreqs, NFSD_MAX_SLOTS_PER_SESSION);\n\t/*\n\t * Note decreasing slot size below client's request may make it\n\t * difficult for client to function correctly, whereas\n\t * decreasing the number of slots will (just?) affect\n\t * performance.  When short on memory we therefore prefer to\n\t * decrease number of slots instead of their size.  Clients that\n\t * request larger slots than they need will get poor results:\n\t * Note that we always allow at least one slot, because our\n\t * accounting is soft and provides no guarantees either way.\n\t */\n\tca->maxreqs = nfsd4_get_drc_mem(ca, nn);\n\n\treturn nfs_ok;\n}\n\n/*\n * Server's NFSv4.1 backchannel support is AUTH_SYS-only for now.\n * These are based on similar macros in linux/sunrpc/msg_prot.h .\n */\n#define RPC_MAX_HEADER_WITH_AUTH_SYS \\\n\t(RPC_CALLHDRSIZE + 2 * (2 + UNX_CALLSLACK))\n\n#define RPC_MAX_REPHEADER_WITH_AUTH_SYS \\\n\t(RPC_REPHDRSIZE + (2 + NUL_REPLYSLACK))\n\n#define NFSD_CB_MAX_REQ_SZ\t((NFS4_enc_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_HEADER_WITH_AUTH_SYS) * sizeof(__be32))\n#define NFSD_CB_MAX_RESP_SZ\t((NFS4_dec_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_REPHEADER_WITH_AUTH_SYS) * \\\n\t\t\t\t sizeof(__be32))\n\nstatic __be32 check_backchannel_attrs(struct nfsd4_channel_attrs *ca)\n{\n\tca->headerpadsz = 0;\n\n\tif (ca->maxreq_sz < NFSD_CB_MAX_REQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_CB_MAX_RESP_SZ)\n\t\treturn nfserr_toosmall;\n\tca->maxresp_cached = 0;\n\tif (ca->maxops < 2)\n\t\treturn nfserr_toosmall;\n\n\treturn nfs_ok;\n}\n\nstatic __be32 nfsd4_check_cb_sec(struct nfsd4_cb_sec *cbs)\n{\n\tswitch (cbs->flavor) {\n\tcase RPC_AUTH_NULL:\n\tcase RPC_AUTH_UNIX:\n\t\treturn nfs_ok;\n\tdefault:\n\t\t/*\n\t\t * GSS case: the spec doesn't allow us to return this\n\t\t * error.  But it also doesn't allow us not to support\n\t\t * GSS.\n\t\t * I'd rather this fail hard than return some error the\n\t\t * client might think it can already handle:\n\t\t */\n\t\treturn nfserr_encr_alg_unsupp;\n\t}\n}\n\n__be32\nnfsd4_create_session(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_create_session *cr_ses = &u->create_session;\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *old = NULL;\n\tstruct nfsd4_session *new;\n\tstruct nfsd4_conn *conn;\n\tstruct nfsd4_clid_slot *cs_slot = NULL;\n\t__be32 status = 0;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (cr_ses->flags & ~SESSION4_FLAG_MASK_A)\n\t\treturn nfserr_inval;\n\tstatus = nfsd4_check_cb_sec(&cr_ses->cb_sec);\n\tif (status)\n\t\treturn status;\n\tstatus = check_forechannel_attrs(&cr_ses->fore_channel, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_backchannel_attrs(&cr_ses->back_channel);\n\tif (status)\n\t\tgoto out_release_drc_mem;\n\tstatus = nfserr_jukebox;\n\tnew = alloc_session(&cr_ses->fore_channel, &cr_ses->back_channel);\n\tif (!new)\n\t\tgoto out_release_drc_mem;\n\tconn = alloc_conn_from_crses(rqstp, cr_ses);\n\tif (!conn)\n\t\tgoto out_free_session;\n\n\tspin_lock(&nn->client_lock);\n\tunconf = find_unconfirmed_client(&cr_ses->clientid, true, nn);\n\tconf = find_confirmed_client(&cr_ses->clientid, true, nn);\n\tWARN_ON_ONCE(conf && unconf);\n\n\tif (conf) {\n\t\tstatus = nfserr_wrong_cred;\n\t\tif (!nfsd4_mach_creds_match(conf, rqstp))\n\t\t\tgoto out_free_conn;\n\t\tcs_slot = &conf->cl_cs_slot;\n\t\tstatus = check_slot_seqid(cr_ses->seqid, cs_slot->sl_seqid, 0);\n\t\tif (status) {\n\t\t\tif (status == nfserr_replay_cache)\n\t\t\t\tstatus = nfsd4_replay_create_session(cr_ses, cs_slot);\n\t\t\tgoto out_free_conn;\n\t\t}\n\t} else if (unconf) {\n\t\tif (!same_creds(&unconf->cl_cred, &rqstp->rq_cred) ||\n\t\t    !rpc_cmp_addr(sa, (struct sockaddr *) &unconf->cl_addr)) {\n\t\t\tstatus = nfserr_clid_inuse;\n\t\t\tgoto out_free_conn;\n\t\t}\n\t\tstatus = nfserr_wrong_cred;\n\t\tif (!nfsd4_mach_creds_match(unconf, rqstp))\n\t\t\tgoto out_free_conn;\n\t\tcs_slot = &unconf->cl_cs_slot;\n\t\tstatus = check_slot_seqid(cr_ses->seqid, cs_slot->sl_seqid, 0);\n\t\tif (status) {\n\t\t\t/* an unconfirmed replay returns misordered */\n\t\t\tstatus = nfserr_seq_misordered;\n\t\t\tgoto out_free_conn;\n\t\t}\n\t\told = find_confirmed_client_by_name(&unconf->cl_name, nn);\n\t\tif (old) {\n\t\t\tstatus = mark_client_expired_locked(old);\n\t\t\tif (status) {\n\t\t\t\told = NULL;\n\t\t\t\tgoto out_free_conn;\n\t\t\t}\n\t\t}\n\t\tmove_to_confirmed(unconf);\n\t\tconf = unconf;\n\t} else {\n\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out_free_conn;\n\t}\n\tstatus = nfs_ok;\n\t/* Persistent sessions are not supported */\n\tcr_ses->flags &= ~SESSION4_PERSIST;\n\t/* Upshifting from TCP to RDMA is not supported */\n\tcr_ses->flags &= ~SESSION4_RDMA;\n\n\tinit_session(rqstp, new, conf, cr_ses);\n\tnfsd4_get_session_locked(new);\n\n\tmemcpy(cr_ses->sessionid.data, new->se_sessionid.data,\n\t       NFS4_MAX_SESSIONID_LEN);\n\tcs_slot->sl_seqid++;\n\tcr_ses->seqid = cs_slot->sl_seqid;\n\n\t/* cache solo and embedded create sessions under the client_lock */\n\tnfsd4_cache_create_session(cr_ses, cs_slot, status);\n\tspin_unlock(&nn->client_lock);\n\t/* init connection and backchannel */\n\tnfsd4_init_conn(rqstp, conn, new);\n\tnfsd4_put_session(new);\n\tif (old)\n\t\texpire_client(old);\n\treturn status;\nout_free_conn:\n\tspin_unlock(&nn->client_lock);\n\tfree_conn(conn);\n\tif (old)\n\t\texpire_client(old);\nout_free_session:\n\t__free_session(new);\nout_release_drc_mem:\n\tnfsd4_put_drc_mem(&cr_ses->fore_channel);\n\treturn status;\n}\n\nstatic __be32 nfsd4_map_bcts_dir(u32 *dir)\n{\n\tswitch (*dir) {\n\tcase NFS4_CDFC4_FORE:\n\tcase NFS4_CDFC4_BACK:\n\t\treturn nfs_ok;\n\tcase NFS4_CDFC4_FORE_OR_BOTH:\n\tcase NFS4_CDFC4_BACK_OR_BOTH:\n\t\t*dir = NFS4_CDFC4_BOTH;\n\t\treturn nfs_ok;\n\t}\n\treturn nfserr_inval;\n}\n\n__be32 nfsd4_backchannel_ctl(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_backchannel_ctl *bc = &u->backchannel_ctl;\n\tstruct nfsd4_session *session = cstate->session;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\t__be32 status;\n\n\tstatus = nfsd4_check_cb_sec(&bc->bc_cb_sec);\n\tif (status)\n\t\treturn status;\n\tspin_lock(&nn->client_lock);\n\tsession->se_cb_prog = bc->bc_cb_program;\n\tsession->se_cb_sec = bc->bc_cb_sec;\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd4_probe_callback(session->se_client);\n\n\treturn nfs_ok;\n}\n\nstatic struct nfsd4_conn *__nfsd4_find_conn(struct svc_xprt *xpt, struct nfsd4_session *s)\n{\n\tstruct nfsd4_conn *c;\n\n\tlist_for_each_entry(c, &s->se_conns, cn_persession) {\n\t\tif (c->cn_xprt == xpt) {\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic __be32 nfsd4_match_existing_connection(struct svc_rqst *rqst,\n\t\t\t\tstruct nfsd4_session *session, u32 req)\n{\n\tstruct nfs4_client *clp = session->se_client;\n\tstruct svc_xprt *xpt = rqst->rq_xprt;\n\tstruct nfsd4_conn *c;\n\t__be32 status;\n\n\t/* Following the last paragraph of RFC 5661 Section 18.34.3: */\n\tspin_lock(&clp->cl_lock);\n\tc = __nfsd4_find_conn(xpt, session);\n\tif (!c)\n\t\tstatus = nfserr_noent;\n\telse if (req == c->cn_flags)\n\t\tstatus = nfs_ok;\n\telse if (req == NFS4_CDFC4_FORE_OR_BOTH &&\n\t\t\t\tc->cn_flags != NFS4_CDFC4_BACK)\n\t\tstatus = nfs_ok;\n\telse if (req == NFS4_CDFC4_BACK_OR_BOTH &&\n\t\t\t\tc->cn_flags != NFS4_CDFC4_FORE)\n\t\tstatus = nfs_ok;\n\telse\n\t\tstatus = nfserr_inval;\n\tspin_unlock(&clp->cl_lock);\n\treturn status;\n}\n\n__be32 nfsd4_bind_conn_to_session(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate,\n\t\t     union nfsd4_op_u *u)\n{\n\tstruct nfsd4_bind_conn_to_session *bcts = &u->bind_conn_to_session;\n\t__be32 status;\n\tstruct nfsd4_conn *conn;\n\tstruct nfsd4_session *session;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nfsd4_last_compound_op(rqstp))\n\t\treturn nfserr_not_only_op;\n\tspin_lock(&nn->client_lock);\n\tsession = find_in_sessionid_hashtbl(&bcts->sessionid, net, &status);\n\tspin_unlock(&nn->client_lock);\n\tif (!session)\n\t\tgoto out_no_session;\n\tstatus = nfserr_wrong_cred;\n\tif (!nfsd4_mach_creds_match(session->se_client, rqstp))\n\t\tgoto out;\n\tstatus = nfsd4_match_existing_connection(rqstp, session, bcts->dir);\n\tif (status == nfs_ok || status == nfserr_inval)\n\t\tgoto out;\n\tstatus = nfsd4_map_bcts_dir(&bcts->dir);\n\tif (status)\n\t\tgoto out;\n\tconn = alloc_conn(rqstp, bcts->dir);\n\tstatus = nfserr_jukebox;\n\tif (!conn)\n\t\tgoto out;\n\tnfsd4_init_conn(rqstp, conn, session);\n\tstatus = nfs_ok;\nout:\n\tnfsd4_put_session(session);\nout_no_session:\n\treturn status;\n}\n\nstatic bool nfsd4_compound_in_session(struct nfsd4_compound_state *cstate, struct nfs4_sessionid *sid)\n{\n\tif (!cstate->session)\n\t\treturn false;\n\treturn !memcmp(sid, &cstate->session->se_sessionid, sizeof(*sid));\n}\n\n__be32\nnfsd4_destroy_session(struct svc_rqst *r, struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfs4_sessionid *sessionid = &u->destroy_session.sessionid;\n\tstruct nfsd4_session *ses;\n\t__be32 status;\n\tint ref_held_by_me = 0;\n\tstruct net *net = SVC_NET(r);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tstatus = nfserr_not_only_op;\n\tif (nfsd4_compound_in_session(cstate, sessionid)) {\n\t\tif (!nfsd4_last_compound_op(r))\n\t\t\tgoto out;\n\t\tref_held_by_me++;\n\t}\n\tdump_sessionid(__func__, sessionid);\n\tspin_lock(&nn->client_lock);\n\tses = find_in_sessionid_hashtbl(sessionid, net, &status);\n\tif (!ses)\n\t\tgoto out_client_lock;\n\tstatus = nfserr_wrong_cred;\n\tif (!nfsd4_mach_creds_match(ses->se_client, r))\n\t\tgoto out_put_session;\n\tstatus = mark_session_dead_locked(ses, 1 + ref_held_by_me);\n\tif (status)\n\t\tgoto out_put_session;\n\tunhash_session(ses);\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd4_probe_callback_sync(ses->se_client);\n\n\tspin_lock(&nn->client_lock);\n\tstatus = nfs_ok;\nout_put_session:\n\tnfsd4_put_session_locked(ses);\nout_client_lock:\n\tspin_unlock(&nn->client_lock);\nout:\n\treturn status;\n}\n\nstatic __be32 nfsd4_sequence_check_conn(struct nfsd4_conn *new, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_conn *c;\n\t__be32 status = nfs_ok;\n\tint ret;\n\n\tspin_lock(&clp->cl_lock);\n\tc = __nfsd4_find_conn(new->cn_xprt, ses);\n\tif (c)\n\t\tgoto out_free;\n\tstatus = nfserr_conn_not_bound_to_session;\n\tif (clp->cl_mach_cred)\n\t\tgoto out_free;\n\t__nfsd4_hash_conn(new, ses);\n\tspin_unlock(&clp->cl_lock);\n\tret = nfsd4_register_conn(new);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&new->cn_xpt_user);\n\treturn nfs_ok;\nout_free:\n\tspin_unlock(&clp->cl_lock);\n\tfree_conn(new);\n\treturn status;\n}\n\nstatic bool nfsd4_session_too_many_ops(struct svc_rqst *rqstp, struct nfsd4_session *session)\n{\n\tstruct nfsd4_compoundargs *args = rqstp->rq_argp;\n\n\treturn args->opcnt > session->se_fchannel.maxops;\n}\n\nstatic bool nfsd4_request_too_big(struct svc_rqst *rqstp,\n\t\t\t\t  struct nfsd4_session *session)\n{\n\tstruct xdr_buf *xb = &rqstp->rq_arg;\n\n\treturn xb->len > session->se_fchannel.maxreq_sz;\n}\n\nstatic bool replay_matches_cache(struct svc_rqst *rqstp,\n\t\t struct nfsd4_sequence *seq, struct nfsd4_slot *slot)\n{\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\n\tif ((bool)(slot->sl_flags & NFSD4_SLOT_CACHETHIS) !=\n\t    (bool)seq->cachethis)\n\t\treturn false;\n\t/*\n\t * If there's an error then the reply can have fewer ops than\n\t * the call.\n\t */\n\tif (slot->sl_opcnt < argp->opcnt && !slot->sl_status)\n\t\treturn false;\n\t/*\n\t * But if we cached a reply with *more* ops than the call you're\n\t * sending us now, then this new call is clearly not really a\n\t * replay of the old one:\n\t */\n\tif (slot->sl_opcnt > argp->opcnt)\n\t\treturn false;\n\t/* This is the only check explicitly called by spec: */\n\tif (!same_creds(&rqstp->rq_cred, &slot->sl_cred))\n\t\treturn false;\n\t/*\n\t * There may be more comparisons we could actually do, but the\n\t * spec doesn't require us to catch every case where the calls\n\t * don't match (that would require caching the call as well as\n\t * the reply), so we don't bother.\n\t */\n\treturn true;\n}\n\n__be32\nnfsd4_sequence(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_sequence *seq = &u->sequence;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfsd4_session *session;\n\tstruct nfs4_client *clp;\n\tstruct nfsd4_slot *slot;\n\tstruct nfsd4_conn *conn;\n\t__be32 status;\n\tint buflen;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (resp->opcnt != 1)\n\t\treturn nfserr_sequence_pos;\n\n\t/*\n\t * Will be either used or freed by nfsd4_sequence_check_conn\n\t * below.\n\t */\n\tconn = alloc_conn(rqstp, NFS4_CDFC4_FORE);\n\tif (!conn)\n\t\treturn nfserr_jukebox;\n\n\tspin_lock(&nn->client_lock);\n\tsession = find_in_sessionid_hashtbl(&seq->sessionid, net, &status);\n\tif (!session)\n\t\tgoto out_no_session;\n\tclp = session->se_client;\n\n\tstatus = nfserr_too_many_ops;\n\tif (nfsd4_session_too_many_ops(rqstp, session))\n\t\tgoto out_put_session;\n\n\tstatus = nfserr_req_too_big;\n\tif (nfsd4_request_too_big(rqstp, session))\n\t\tgoto out_put_session;\n\n\tstatus = nfserr_badslot;\n\tif (seq->slotid >= session->se_fchannel.maxreqs)\n\t\tgoto out_put_session;\n\n\tslot = session->se_slots[seq->slotid];\n\tdprintk(\"%s: slotid %d\\n\", __func__, seq->slotid);\n\n\t/* We do not negotiate the number of slots yet, so set the\n\t * maxslots to the session maxreqs which is used to encode\n\t * sr_highest_slotid and the sr_target_slot id to maxslots */\n\tseq->maxslots = session->se_fchannel.maxreqs;\n\n\tstatus = check_slot_seqid(seq->seqid, slot->sl_seqid,\n\t\t\t\t\tslot->sl_flags & NFSD4_SLOT_INUSE);\n\tif (status == nfserr_replay_cache) {\n\t\tstatus = nfserr_seq_misordered;\n\t\tif (!(slot->sl_flags & NFSD4_SLOT_INITIALIZED))\n\t\t\tgoto out_put_session;\n\t\tstatus = nfserr_seq_false_retry;\n\t\tif (!replay_matches_cache(rqstp, seq, slot))\n\t\t\tgoto out_put_session;\n\t\tcstate->slot = slot;\n\t\tcstate->session = session;\n\t\tcstate->clp = clp;\n\t\t/* Return the cached reply status and set cstate->status\n\t\t * for nfsd4_proc_compound processing */\n\t\tstatus = nfsd4_replay_cache_entry(resp, seq);\n\t\tcstate->status = nfserr_replay_cache;\n\t\tgoto out;\n\t}\n\tif (status)\n\t\tgoto out_put_session;\n\n\tstatus = nfsd4_sequence_check_conn(conn, session);\n\tconn = NULL;\n\tif (status)\n\t\tgoto out_put_session;\n\n\tbuflen = (seq->cachethis) ?\n\t\t\tsession->se_fchannel.maxresp_cached :\n\t\t\tsession->se_fchannel.maxresp_sz;\n\tstatus = (seq->cachethis) ? nfserr_rep_too_big_to_cache :\n\t\t\t\t    nfserr_rep_too_big;\n\tif (xdr_restrict_buflen(xdr, buflen - rqstp->rq_auth_slack))\n\t\tgoto out_put_session;\n\tsvc_reserve(rqstp, buflen);\n\n\tstatus = nfs_ok;\n\t/* Success! bump slot seqid */\n\tslot->sl_seqid = seq->seqid;\n\tslot->sl_flags |= NFSD4_SLOT_INUSE;\n\tif (seq->cachethis)\n\t\tslot->sl_flags |= NFSD4_SLOT_CACHETHIS;\n\telse\n\t\tslot->sl_flags &= ~NFSD4_SLOT_CACHETHIS;\n\n\tcstate->slot = slot;\n\tcstate->session = session;\n\tcstate->clp = clp;\n\nout:\n\tswitch (clp->cl_cb_state) {\n\tcase NFSD4_CB_DOWN:\n\t\tseq->status_flags = SEQ4_STATUS_CB_PATH_DOWN;\n\t\tbreak;\n\tcase NFSD4_CB_FAULT:\n\t\tseq->status_flags = SEQ4_STATUS_BACKCHANNEL_FAULT;\n\t\tbreak;\n\tdefault:\n\t\tseq->status_flags = 0;\n\t}\n\tif (!list_empty(&clp->cl_revoked))\n\t\tseq->status_flags |= SEQ4_STATUS_RECALLABLE_STATE_REVOKED;\nout_no_session:\n\tif (conn)\n\t\tfree_conn(conn);\n\tspin_unlock(&nn->client_lock);\n\treturn status;\nout_put_session:\n\tnfsd4_put_session_locked(session);\n\tgoto out_no_session;\n}\n\nvoid\nnfsd4_sequence_done(struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_compound_state *cs = &resp->cstate;\n\n\tif (nfsd4_has_session(cs)) {\n\t\tif (cs->status != nfserr_replay_cache) {\n\t\t\tnfsd4_store_cache_entry(resp);\n\t\t\tcs->slot->sl_flags &= ~NFSD4_SLOT_INUSE;\n\t\t}\n\t\t/* Drop session reference that was taken in nfsd4_sequence() */\n\t\tnfsd4_put_session(cs->session);\n\t} else if (cs->clp)\n\t\tput_client_renew(cs->clp);\n}\n\n__be32\nnfsd4_destroy_clientid(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_destroy_clientid *dc = &u->destroy_clientid;\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *clp = NULL;\n\t__be32 status = 0;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunconf = find_unconfirmed_client(&dc->clientid, true, nn);\n\tconf = find_confirmed_client(&dc->clientid, true, nn);\n\tWARN_ON_ONCE(conf && unconf);\n\n\tif (conf) {\n\t\tif (client_has_state(conf)) {\n\t\t\tstatus = nfserr_clientid_busy;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = mark_client_expired_locked(conf);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tclp = conf;\n\t} else if (unconf)\n\t\tclp = unconf;\n\telse {\n\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out;\n\t}\n\tif (!nfsd4_mach_creds_match(clp, rqstp)) {\n\t\tclp = NULL;\n\t\tstatus = nfserr_wrong_cred;\n\t\tgoto out;\n\t}\n\tunhash_client_locked(clp);\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (clp)\n\t\texpire_client(clp);\n\treturn status;\n}\n\n__be32\nnfsd4_reclaim_complete(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_reclaim_complete *rc = &u->reclaim_complete;\n\t__be32 status = 0;\n\n\tif (rc->rca_one_fs) {\n\t\tif (!cstate->current_fh.fh_dentry)\n\t\t\treturn nfserr_nofilehandle;\n\t\t/*\n\t\t * We don't take advantage of the rca_one_fs case.\n\t\t * That's OK, it's optional, we can safely ignore it.\n\t\t */\n\t\treturn nfs_ok;\n\t}\n\n\tstatus = nfserr_complete_already;\n\tif (test_and_set_bit(NFSD4_CLIENT_RECLAIM_COMPLETE,\n\t\t\t     &cstate->session->se_client->cl_flags))\n\t\tgoto out;\n\n\tstatus = nfserr_stale_clientid;\n\tif (is_client_expired(cstate->session->se_client))\n\t\t/*\n\t\t * The following error isn't really legal.\n\t\t * But we only get here if the client just explicitly\n\t\t * destroyed the client.  Surely it no longer cares what\n\t\t * error it gets back on an operation for the dead\n\t\t * client.\n\t\t */\n\t\tgoto out;\n\n\tstatus = nfs_ok;\n\tnfsd4_client_record_create(cstate->session->se_client);\n\tinc_reclaim_complete(cstate->session->se_client);\nout:\n\treturn status;\n}\n\n__be32\nnfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_setclientid *setclid = &u->setclientid;\n\tstruct xdr_netobj \tclname = setclid->se_name;\n\tnfs4_verifier\t\tclverifier = setclid->se_verf;\n\tstruct nfs4_client\t*conf, *new;\n\tstruct nfs4_client\t*unconf = NULL;\n\t__be32 \t\t\tstatus;\n\tstruct nfsd_net\t\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew = create_client(clname, rqstp, &clverifier);\n\tif (new == NULL)\n\t\treturn nfserr_jukebox;\n\t/* Cases below refer to rfc 3530 section 14.2.33: */\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client_by_name(&clname, nn);\n\tif (conf && client_has_state(conf)) {\n\t\t/* case 0: */\n\t\tstatus = nfserr_clid_inuse;\n\t\tif (clp_used_exchangeid(conf))\n\t\t\tgoto out;\n\t\tif (!same_creds(&conf->cl_cred, &rqstp->rq_cred)) {\n\t\t\ttrace_nfsd_clid_inuse_err(conf);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tunconf = find_unconfirmed_client_by_name(&clname, nn);\n\tif (unconf)\n\t\tunhash_client_locked(unconf);\n\t/* We need to handle only case 1: probable callback update */\n\tif (conf && same_verf(&conf->cl_verifier, &clverifier)) {\n\t\tcopy_clid(new, conf);\n\t\tgen_confirm(new, nn);\n\t}\n\tnew->cl_minorversion = 0;\n\tgen_callback(new, setclid, rqstp);\n\tadd_to_unconfirmed(new);\n\tsetclid->se_clientid.cl_boot = new->cl_clientid.cl_boot;\n\tsetclid->se_clientid.cl_id = new->cl_clientid.cl_id;\n\tmemcpy(setclid->se_confirm.data, new->cl_confirm.data, sizeof(setclid->se_confirm.data));\n\tnew = NULL;\n\tstatus = nfs_ok;\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (new)\n\t\tfree_client(new);\n\tif (unconf)\n\t\texpire_client(unconf);\n\treturn status;\n}\n\n\n__be32\nnfsd4_setclientid_confirm(struct svc_rqst *rqstp,\n\t\t\tstruct nfsd4_compound_state *cstate,\n\t\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_setclientid_confirm *setclientid_confirm =\n\t\t\t&u->setclientid_confirm;\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *old = NULL;\n\tnfs4_verifier confirm = setclientid_confirm->sc_confirm; \n\tclientid_t * clid = &setclientid_confirm->sc_clientid;\n\t__be32 status;\n\tstruct nfsd_net\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client(clid, false, nn);\n\tunconf = find_unconfirmed_client(clid, false, nn);\n\t/*\n\t * We try hard to give out unique clientid's, so if we get an\n\t * attempt to confirm the same clientid with a different cred,\n\t * the client may be buggy; this should never happen.\n\t *\n\t * Nevertheless, RFC 7530 recommends INUSE for this case:\n\t */\n\tstatus = nfserr_clid_inuse;\n\tif (unconf && !same_creds(&unconf->cl_cred, &rqstp->rq_cred))\n\t\tgoto out;\n\tif (conf && !same_creds(&conf->cl_cred, &rqstp->rq_cred))\n\t\tgoto out;\n\t/* cases below refer to rfc 3530 section 14.2.34: */\n\tif (!unconf || !same_verf(&confirm, &unconf->cl_confirm)) {\n\t\tif (conf && same_verf(&confirm, &conf->cl_confirm)) {\n\t\t\t/* case 2: probable retransmit */\n\t\t\tstatus = nfs_ok;\n\t\t} else /* case 4: client hasn't noticed we rebooted yet? */\n\t\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (conf) { /* case 1: callback update */\n\t\told = unconf;\n\t\tunhash_client_locked(old);\n\t\tnfsd4_change_callback(conf, &unconf->cl_cb_conn);\n\t} else { /* case 3: normal case; new or rebooted client */\n\t\told = find_confirmed_client_by_name(&unconf->cl_name, nn);\n\t\tif (old) {\n\t\t\tstatus = nfserr_clid_inuse;\n\t\t\tif (client_has_state(old)\n\t\t\t\t\t&& !same_creds(&unconf->cl_cred,\n\t\t\t\t\t\t\t&old->cl_cred))\n\t\t\t\tgoto out;\n\t\t\tstatus = mark_client_expired_locked(old);\n\t\t\tif (status) {\n\t\t\t\told = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tmove_to_confirmed(unconf);\n\t\tconf = unconf;\n\t}\n\tget_client_locked(conf);\n\tspin_unlock(&nn->client_lock);\n\tnfsd4_probe_callback(conf);\n\tspin_lock(&nn->client_lock);\n\tput_client_renew_locked(conf);\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (old)\n\t\texpire_client(old);\n\treturn status;\n}\n\nstatic struct nfs4_file *nfsd4_alloc_file(void)\n{\n\treturn kmem_cache_alloc(file_slab, GFP_KERNEL);\n}\n\n/* OPEN Share state helper functions */\nstatic void nfsd4_init_file(struct knfsd_fh *fh, unsigned int hashval,\n\t\t\t\tstruct nfs4_file *fp)\n{\n\tlockdep_assert_held(&state_lock);\n\n\trefcount_set(&fp->fi_ref, 1);\n\tspin_lock_init(&fp->fi_lock);\n\tINIT_LIST_HEAD(&fp->fi_stateids);\n\tINIT_LIST_HEAD(&fp->fi_delegations);\n\tINIT_LIST_HEAD(&fp->fi_clnt_odstate);\n\tfh_copy_shallow(&fp->fi_fhandle, fh);\n\tfp->fi_deleg_file = NULL;\n\tfp->fi_had_conflict = false;\n\tfp->fi_share_deny = 0;\n\tmemset(fp->fi_fds, 0, sizeof(fp->fi_fds));\n\tmemset(fp->fi_access, 0, sizeof(fp->fi_access));\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&fp->fi_lo_states);\n\tatomic_set(&fp->fi_lo_recalls, 0);\n#endif\n\thlist_add_head_rcu(&fp->fi_hash, &file_hashtbl[hashval]);\n}\n\nvoid\nnfsd4_free_slabs(void)\n{\n\tkmem_cache_destroy(client_slab);\n\tkmem_cache_destroy(openowner_slab);\n\tkmem_cache_destroy(lockowner_slab);\n\tkmem_cache_destroy(file_slab);\n\tkmem_cache_destroy(stateid_slab);\n\tkmem_cache_destroy(deleg_slab);\n\tkmem_cache_destroy(odstate_slab);\n}\n\nint\nnfsd4_init_slabs(void)\n{\n\tclient_slab = kmem_cache_create(\"nfsd4_clients\",\n\t\t\tsizeof(struct nfs4_client), 0, 0, NULL);\n\tif (client_slab == NULL)\n\t\tgoto out;\n\topenowner_slab = kmem_cache_create(\"nfsd4_openowners\",\n\t\t\tsizeof(struct nfs4_openowner), 0, 0, NULL);\n\tif (openowner_slab == NULL)\n\t\tgoto out_free_client_slab;\n\tlockowner_slab = kmem_cache_create(\"nfsd4_lockowners\",\n\t\t\tsizeof(struct nfs4_lockowner), 0, 0, NULL);\n\tif (lockowner_slab == NULL)\n\t\tgoto out_free_openowner_slab;\n\tfile_slab = kmem_cache_create(\"nfsd4_files\",\n\t\t\tsizeof(struct nfs4_file), 0, 0, NULL);\n\tif (file_slab == NULL)\n\t\tgoto out_free_lockowner_slab;\n\tstateid_slab = kmem_cache_create(\"nfsd4_stateids\",\n\t\t\tsizeof(struct nfs4_ol_stateid), 0, 0, NULL);\n\tif (stateid_slab == NULL)\n\t\tgoto out_free_file_slab;\n\tdeleg_slab = kmem_cache_create(\"nfsd4_delegations\",\n\t\t\tsizeof(struct nfs4_delegation), 0, 0, NULL);\n\tif (deleg_slab == NULL)\n\t\tgoto out_free_stateid_slab;\n\todstate_slab = kmem_cache_create(\"nfsd4_odstate\",\n\t\t\tsizeof(struct nfs4_clnt_odstate), 0, 0, NULL);\n\tif (odstate_slab == NULL)\n\t\tgoto out_free_deleg_slab;\n\treturn 0;\n\nout_free_deleg_slab:\n\tkmem_cache_destroy(deleg_slab);\nout_free_stateid_slab:\n\tkmem_cache_destroy(stateid_slab);\nout_free_file_slab:\n\tkmem_cache_destroy(file_slab);\nout_free_lockowner_slab:\n\tkmem_cache_destroy(lockowner_slab);\nout_free_openowner_slab:\n\tkmem_cache_destroy(openowner_slab);\nout_free_client_slab:\n\tkmem_cache_destroy(client_slab);\nout:\n\treturn -ENOMEM;\n}\n\nstatic void init_nfs4_replay(struct nfs4_replay *rp)\n{\n\trp->rp_status = nfserr_serverfault;\n\trp->rp_buflen = 0;\n\trp->rp_buf = rp->rp_ibuf;\n\tmutex_init(&rp->rp_mutex);\n}\n\nstatic void nfsd4_cstate_assign_replay(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stateowner *so)\n{\n\tif (!nfsd4_has_session(cstate)) {\n\t\tmutex_lock(&so->so_replay.rp_mutex);\n\t\tcstate->replay_owner = nfs4_get_stateowner(so);\n\t}\n}\n\nvoid nfsd4_cstate_clear_replay(struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (so != NULL) {\n\t\tcstate->replay_owner = NULL;\n\t\tmutex_unlock(&so->so_replay.rp_mutex);\n\t\tnfs4_put_stateowner(so);\n\t}\n}\n\nstatic inline void *alloc_stateowner(struct kmem_cache *slab, struct xdr_netobj *owner, struct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *sop;\n\n\tsop = kmem_cache_alloc(slab, GFP_KERNEL);\n\tif (!sop)\n\t\treturn NULL;\n\n\txdr_netobj_dup(&sop->so_owner, owner, GFP_KERNEL);\n\tif (!sop->so_owner.data) {\n\t\tkmem_cache_free(slab, sop);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&sop->so_stateids);\n\tsop->so_client = clp;\n\tinit_nfs4_replay(&sop->so_replay);\n\tatomic_set(&sop->so_count, 1);\n\treturn sop;\n}\n\nstatic void hash_openowner(struct nfs4_openowner *oo, struct nfs4_client *clp, unsigned int strhashval)\n{\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_add(&oo->oo_owner.so_strhash,\n\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\tlist_add(&oo->oo_perclient, &clp->cl_openowners);\n}\n\nstatic void nfs4_unhash_openowner(struct nfs4_stateowner *so)\n{\n\tunhash_openowner_locked(openowner(so));\n}\n\nstatic void nfs4_free_openowner(struct nfs4_stateowner *so)\n{\n\tstruct nfs4_openowner *oo = openowner(so);\n\n\tkmem_cache_free(openowner_slab, oo);\n}\n\nstatic const struct nfs4_stateowner_operations openowner_ops = {\n\t.so_unhash =\tnfs4_unhash_openowner,\n\t.so_free =\tnfs4_free_openowner,\n};\n\nstatic struct nfs4_ol_stateid *\nnfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\tstruct nfs4_ol_stateid *local, *ret = NULL;\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tlist_for_each_entry(local, &fp->fi_stateids, st_perfile) {\n\t\t/* ignore lock owners */\n\t\tif (local->st_stateowner->so_is_open_owner == 0)\n\t\t\tcontinue;\n\t\tif (local->st_stateowner != &oo->oo_owner)\n\t\t\tcontinue;\n\t\tif (local->st_stid.sc_type == NFS4_OPEN_STID) {\n\t\t\tret = local;\n\t\t\trefcount_inc(&ret->st_stid.sc_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic __be32\nnfsd4_verify_open_stid(struct nfs4_stid *s)\n{\n\t__be32 ret = nfs_ok;\n\n\tswitch (s->sc_type) {\n\tdefault:\n\t\tbreak;\n\tcase 0:\n\tcase NFS4_CLOSED_STID:\n\tcase NFS4_CLOSED_DELEG_STID:\n\t\tret = nfserr_bad_stateid;\n\t\tbreak;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tret = nfserr_deleg_revoked;\n\t}\n\treturn ret;\n}\n\n/* Lock the stateid st_mutex, and deal with races with CLOSE */\nstatic __be32\nnfsd4_lock_ol_stateid(struct nfs4_ol_stateid *stp)\n{\n\t__be32 ret;\n\n\tmutex_lock_nested(&stp->st_mutex, LOCK_STATEID_MUTEX);\n\tret = nfsd4_verify_open_stid(&stp->st_stid);\n\tif (ret != nfs_ok)\n\t\tmutex_unlock(&stp->st_mutex);\n\treturn ret;\n}\n\nstatic struct nfs4_ol_stateid *\nnfsd4_find_and_lock_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tfor (;;) {\n\t\tspin_lock(&fp->fi_lock);\n\t\tstp = nfsd4_find_existing_open(fp, open);\n\t\tspin_unlock(&fp->fi_lock);\n\t\tif (!stp || nfsd4_lock_ol_stateid(stp) == nfs_ok)\n\t\t\tbreak;\n\t\tnfs4_put_stid(&stp->st_stid);\n\t}\n\treturn stp;\n}\n\nstatic struct nfs4_openowner *\nalloc_init_open_stateowner(unsigned int strhashval, struct nfsd4_open *open,\n\t\t\t   struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_openowner *oo, *ret;\n\n\too = alloc_stateowner(openowner_slab, &open->op_owner, clp);\n\tif (!oo)\n\t\treturn NULL;\n\too->oo_owner.so_ops = &openowner_ops;\n\too->oo_owner.so_is_open_owner = 1;\n\too->oo_owner.so_seqid = open->op_seqid;\n\too->oo_flags = 0;\n\tif (nfsd4_has_session(cstate))\n\t\too->oo_flags |= NFS4_OO_CONFIRMED;\n\too->oo_time = 0;\n\too->oo_last_closed_stid = NULL;\n\tINIT_LIST_HEAD(&oo->oo_close_lru);\n\tspin_lock(&clp->cl_lock);\n\tret = find_openstateowner_str_locked(strhashval, open, clp);\n\tif (ret == NULL) {\n\t\thash_openowner(oo, clp, strhashval);\n\t\tret = oo;\n\t} else\n\t\tnfs4_free_stateowner(&oo->oo_owner);\n\n\tspin_unlock(&clp->cl_lock);\n\treturn ret;\n}\n\nstatic struct nfs4_ol_stateid *\ninit_open_stateid(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\tstruct nfs4_ol_stateid *retstp = NULL;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstp = open->op_stp;\n\t/* We are moving these outside of the spinlocks to avoid the warnings */\n\tmutex_init(&stp->st_mutex);\n\tmutex_lock_nested(&stp->st_mutex, OPEN_STATEID_MUTEX);\n\nretry:\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tspin_lock(&fp->fi_lock);\n\n\tretstp = nfsd4_find_existing_open(fp, open);\n\tif (retstp)\n\t\tgoto out_unlock;\n\n\topen->op_stp = NULL;\n\trefcount_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_OPEN_STID;\n\tINIT_LIST_HEAD(&stp->st_locks);\n\tstp->st_stateowner = nfs4_get_stateowner(&oo->oo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = 0;\n\tstp->st_openstp = NULL;\n\tlist_add(&stp->st_perstateowner, &oo->oo_owner.so_stateids);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n\tif (retstp) {\n\t\t/* Handle races with CLOSE */\n\t\tif (nfsd4_lock_ol_stateid(retstp) != nfs_ok) {\n\t\t\tnfs4_put_stid(&retstp->st_stid);\n\t\t\tgoto retry;\n\t\t}\n\t\t/* To keep mutex tracking happy */\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tstp = retstp;\n\t}\n\treturn stp;\n}\n\n/*\n * In the 4.0 case we need to keep the owners around a little while to handle\n * CLOSE replay. We still do need to release any file access that is held by\n * them before returning however.\n */\nstatic void\nmove_to_close_lru(struct nfs4_ol_stateid *s, struct net *net)\n{\n\tstruct nfs4_ol_stateid *last;\n\tstruct nfs4_openowner *oo = openowner(s->st_stateowner);\n\tstruct nfsd_net *nn = net_generic(s->st_stid.sc_client->net,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tdprintk(\"NFSD: move_to_close_lru nfs4_openowner %p\\n\", oo);\n\n\t/*\n\t * We know that we hold one reference via nfsd4_close, and another\n\t * \"persistent\" reference for the client. If the refcount is higher\n\t * than 2, then there are still calls in progress that are using this\n\t * stateid. We can't put the sc_file reference until they are finished.\n\t * Wait for the refcount to drop to 2. Since it has been unhashed,\n\t * there should be no danger of the refcount going back up again at\n\t * this point.\n\t */\n\twait_event(close_wq, refcount_read(&s->st_stid.sc_count) == 2);\n\n\trelease_all_access(s);\n\tif (s->st_stid.sc_file) {\n\t\tput_nfs4_file(s->st_stid.sc_file);\n\t\ts->st_stid.sc_file = NULL;\n\t}\n\n\tspin_lock(&nn->client_lock);\n\tlast = oo->oo_last_closed_stid;\n\too->oo_last_closed_stid = s;\n\tlist_move_tail(&oo->oo_close_lru, &nn->close_lru);\n\too->oo_time = ktime_get_boottime_seconds();\n\tspin_unlock(&nn->client_lock);\n\tif (last)\n\t\tnfs4_put_stid(&last->st_stid);\n}\n\n/* search file_hashtbl[] for file */\nstatic struct nfs4_file *\nfind_file_locked(struct knfsd_fh *fh, unsigned int hashval)\n{\n\tstruct nfs4_file *fp;\n\n\thlist_for_each_entry_rcu(fp, &file_hashtbl[hashval], fi_hash,\n\t\t\t\tlockdep_is_held(&state_lock)) {\n\t\tif (fh_match(&fp->fi_fhandle, fh)) {\n\t\t\tif (refcount_inc_not_zero(&fp->fi_ref))\n\t\t\t\treturn fp;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstruct nfs4_file *\nfind_file(struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\treturn fp;\n}\n\nstatic struct nfs4_file *\nfind_or_add_file(struct nfs4_file *new, struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\tif (fp)\n\t\treturn fp;\n\n\tspin_lock(&state_lock);\n\tfp = find_file_locked(fh, hashval);\n\tif (likely(fp == NULL)) {\n\t\tnfsd4_init_file(fh, hashval, new);\n\t\tfp = new;\n\t}\n\tspin_unlock(&state_lock);\n\n\treturn fp;\n}\n\n/*\n * Called to check deny when READ with all zero stateid or\n * WRITE with all zero or all one stateid\n */\nstatic __be32\nnfs4_share_conflict(struct svc_fh *current_fh, unsigned int deny_type)\n{\n\tstruct nfs4_file *fp;\n\t__be32 ret = nfs_ok;\n\n\tfp = find_file(&current_fh->fh_handle);\n\tif (!fp)\n\t\treturn ret;\n\t/* Check for conflicting share reservations */\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_share_deny & deny_type)\n\t\tret = nfserr_locked;\n\tspin_unlock(&fp->fi_lock);\n\tput_nfs4_file(fp);\n\treturn ret;\n}\n\nstatic void nfsd4_cb_recall_prepare(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\tstruct nfsd_net *nn = net_generic(dp->dl_stid.sc_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\n\tblock_delegations(&dp->dl_stid.sc_file->fi_fhandle);\n\n\t/*\n\t * We can't do this in nfsd_break_deleg_cb because it is\n\t * already holding inode->i_lock.\n\t *\n\t * If the dl_time != 0, then we know that it has already been\n\t * queued for a lease break. Don't queue it again.\n\t */\n\tspin_lock(&state_lock);\n\tif (dp->dl_time == 0) {\n\t\tdp->dl_time = ktime_get_boottime_seconds();\n\t\tlist_add_tail(&dp->dl_recall_lru, &nn->del_recall_lru);\n\t}\n\tspin_unlock(&state_lock);\n}\n\nstatic int nfsd4_cb_recall_done(struct nfsd4_callback *cb,\n\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\n\tif (dp->dl_stid.sc_type == NFS4_CLOSED_DELEG_STID ||\n\t    dp->dl_stid.sc_type == NFS4_REVOKED_DELEG_STID)\n\t        return 1;\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\treturn 1;\n\tcase -NFS4ERR_DELAY:\n\t\trpc_delay(task, 2 * HZ);\n\t\treturn 0;\n\tcase -EBADHANDLE:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\t/*\n\t\t * Race: client probably got cb_recall before open reply\n\t\t * granting delegation.\n\t\t */\n\t\tif (dp->dl_retries--) {\n\t\t\trpc_delay(task, 2 * HZ);\n\t\t\treturn 0;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic void nfsd4_cb_recall_release(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\n\tnfs4_put_stid(&dp->dl_stid);\n}\n\nstatic const struct nfsd4_callback_ops nfsd4_cb_recall_ops = {\n\t.prepare\t= nfsd4_cb_recall_prepare,\n\t.done\t\t= nfsd4_cb_recall_done,\n\t.release\t= nfsd4_cb_recall_release,\n};\n\nstatic void nfsd_break_one_deleg(struct nfs4_delegation *dp)\n{\n\t/*\n\t * We're assuming the state code never drops its reference\n\t * without first removing the lease.  Since we're in this lease\n\t * callback (and since the lease code is serialized by the\n\t * i_lock) we know the server hasn't removed the lease yet, and\n\t * we know it's safe to take a reference.\n\t */\n\trefcount_inc(&dp->dl_stid.sc_count);\n\tnfsd4_run_cb(&dp->dl_recall);\n}\n\n/* Called from break_lease() with i_lock held. */\nstatic bool\nnfsd_break_deleg_cb(struct file_lock *fl)\n{\n\tbool ret = false;\n\tstruct nfs4_delegation *dp = (struct nfs4_delegation *)fl->fl_owner;\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\ttrace_nfsd_deleg_break(&dp->dl_stid.sc_stateid);\n\n\t/*\n\t * We don't want the locks code to timeout the lease for us;\n\t * we'll remove it ourself if a delegation isn't returned\n\t * in time:\n\t */\n\tfl->fl_break_time = 0;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_had_conflict = true;\n\tnfsd_break_one_deleg(dp);\n\tspin_unlock(&fp->fi_lock);\n\treturn ret;\n}\n\nstatic bool nfsd_breaker_owns_lease(struct file_lock *fl)\n{\n\tstruct nfs4_delegation *dl = fl->fl_owner;\n\tstruct svc_rqst *rqst;\n\tstruct nfs4_client *clp;\n\n\tif (!i_am_nfsd())\n\t\treturn NULL;\n\trqst = kthread_data(current);\n\t/* Note rq_prog == NFS_ACL_PROGRAM is also possible: */\n\tif (rqst->rq_prog != NFS_PROGRAM || rqst->rq_vers < 4)\n\t\treturn NULL;\n\tclp = *(rqst->rq_lease_breaker);\n\treturn dl->dl_stid.sc_client == clp;\n}\n\nstatic int\nnfsd_change_deleg_cb(struct file_lock *onlist, int arg,\n\t\t     struct list_head *dispose)\n{\n\tif (arg & F_UNLCK)\n\t\treturn lease_modify(onlist, arg, dispose);\n\telse\n\t\treturn -EAGAIN;\n}\n\nstatic const struct lock_manager_operations nfsd_lease_mng_ops = {\n\t.lm_breaker_owns_lease = nfsd_breaker_owns_lease,\n\t.lm_break = nfsd_break_deleg_cb,\n\t.lm_change = nfsd_change_deleg_cb,\n};\n\nstatic __be32 nfsd4_check_seqid(struct nfsd4_compound_state *cstate, struct nfs4_stateowner *so, u32 seqid)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn nfs_ok;\n\tif (seqid == so->so_seqid - 1)\n\t\treturn nfserr_replay_me;\n\tif (seqid == so->so_seqid)\n\t\treturn nfs_ok;\n\treturn nfserr_bad_seqid;\n}\n\nstatic __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn,\n\t\tbool sessions)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, sessions, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_rpc_users);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}\n\n__be32\nnfsd4_process_open1(struct nfsd4_compound_state *cstate,\n\t\t    struct nfsd4_open *open, struct nfsd_net *nn)\n{\n\tclientid_t *clientid = &open->op_clientid;\n\tstruct nfs4_client *clp = NULL;\n\tunsigned int strhashval;\n\tstruct nfs4_openowner *oo = NULL;\n\t__be32 status;\n\n\tif (STALE_CLIENTID(&open->op_clientid, nn))\n\t\treturn nfserr_stale_clientid;\n\t/*\n\t * In case we need it later, after we've already created the\n\t * file and don't want to risk a further failure:\n\t */\n\topen->op_file = nfsd4_alloc_file();\n\tif (open->op_file == NULL)\n\t\treturn nfserr_jukebox;\n\n\tstatus = lookup_clientid(clientid, cstate, nn, false);\n\tif (status)\n\t\treturn status;\n\tclp = cstate->clp;\n\n\tstrhashval = ownerstr_hashval(&open->op_owner);\n\too = find_openstateowner_str(strhashval, open, clp);\n\topen->op_openowner = oo;\n\tif (!oo) {\n\t\tgoto new_owner;\n\t}\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\t/* Replace unconfirmed owners without checking for replay. */\n\t\trelease_openowner(oo);\n\t\topen->op_openowner = NULL;\n\t\tgoto new_owner;\n\t}\n\tstatus = nfsd4_check_seqid(cstate, &oo->oo_owner, open->op_seqid);\n\tif (status)\n\t\treturn status;\n\tgoto alloc_stateid;\nnew_owner:\n\too = alloc_init_open_stateowner(strhashval, open, cstate);\n\tif (oo == NULL)\n\t\treturn nfserr_jukebox;\n\topen->op_openowner = oo;\nalloc_stateid:\n\topen->op_stp = nfs4_alloc_open_stateid(clp);\n\tif (!open->op_stp)\n\t\treturn nfserr_jukebox;\n\n\tif (nfsd4_has_session(cstate) &&\n\t    (cstate->current_fh.fh_export->ex_flags & NFSEXP_PNFS)) {\n\t\topen->op_odstate = alloc_clnt_odstate(clp);\n\t\tif (!open->op_odstate)\n\t\t\treturn nfserr_jukebox;\n\t}\n\n\treturn nfs_ok;\n}\n\nstatic inline __be32\nnfs4_check_delegmode(struct nfs4_delegation *dp, int flags)\n{\n\tif ((flags & WR_STATE) && (dp->dl_type == NFS4_OPEN_DELEGATE_READ))\n\t\treturn nfserr_openmode;\n\telse\n\t\treturn nfs_ok;\n}\n\nstatic int share_access_to_flags(u32 share_access)\n{\n\treturn share_access == NFS4_SHARE_ACCESS_READ ? RD_STATE : WR_STATE;\n}\n\nstatic struct nfs4_delegation *find_deleg_stateid(struct nfs4_client *cl, stateid_t *s)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = find_stateid_by_type(cl, s,\n\t\t\t\tNFS4_DELEG_STID|NFS4_REVOKED_DELEG_STID);\n\tif (!ret)\n\t\treturn NULL;\n\treturn delegstateid(ret);\n}\n\nstatic bool nfsd4_is_deleg_cur(struct nfsd4_open *open)\n{\n\treturn open->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR ||\n\t       open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH;\n}\n\nstatic __be32\nnfs4_check_deleg(struct nfs4_client *cl, struct nfsd4_open *open,\n\t\tstruct nfs4_delegation **dp)\n{\n\tint flags;\n\t__be32 status = nfserr_bad_stateid;\n\tstruct nfs4_delegation *deleg;\n\n\tdeleg = find_deleg_stateid(cl, &open->op_delegate_stateid);\n\tif (deleg == NULL)\n\t\tgoto out;\n\tif (deleg->dl_stid.sc_type == NFS4_REVOKED_DELEG_STID) {\n\t\tnfs4_put_stid(&deleg->dl_stid);\n\t\tif (cl->cl_minorversion)\n\t\t\tstatus = nfserr_deleg_revoked;\n\t\tgoto out;\n\t}\n\tflags = share_access_to_flags(open->op_share_access);\n\tstatus = nfs4_check_delegmode(deleg, flags);\n\tif (status) {\n\t\tnfs4_put_stid(&deleg->dl_stid);\n\t\tgoto out;\n\t}\n\t*dp = deleg;\nout:\n\tif (!nfsd4_is_deleg_cur(open))\n\t\treturn nfs_ok;\n\tif (status)\n\t\treturn status;\n\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\treturn nfs_ok;\n}\n\nstatic inline int nfs4_access_to_access(u32 nfs4_access)\n{\n\tint flags = 0;\n\n\tif (nfs4_access & NFS4_SHARE_ACCESS_READ)\n\t\tflags |= NFSD_MAY_READ;\n\tif (nfs4_access & NFS4_SHARE_ACCESS_WRITE)\n\t\tflags |= NFSD_MAY_WRITE;\n\treturn flags;\n}\n\nstatic inline __be32\nnfsd4_truncate(struct svc_rqst *rqstp, struct svc_fh *fh,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct iattr iattr = {\n\t\t.ia_valid = ATTR_SIZE,\n\t\t.ia_size = 0,\n\t};\n\tif (!open->op_truncate)\n\t\treturn 0;\n\tif (!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\treturn nfsd_setattr(rqstp, fh, &iattr, 0, (time64_t)0);\n}\n\nstatic __be32 nfs4_get_vfs_file(struct svc_rqst *rqstp, struct nfs4_file *fp,\n\t\tstruct svc_fh *cur_fh, struct nfs4_ol_stateid *stp,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct nfsd_file *nf = NULL;\n\t__be32 status;\n\tint oflag = nfs4_access_to_omode(open->op_share_access);\n\tint access = nfs4_access_to_access(open->op_share_access);\n\tunsigned char old_access_bmap, old_deny_bmap;\n\n\tspin_lock(&fp->fi_lock);\n\n\t/*\n\t * Are we trying to set a deny mode that would conflict with\n\t * current access?\n\t */\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* set access to the file */\n\tstatus = nfs4_file_get_access(fp, open->op_share_access);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* Set access bits in stateid */\n\told_access_bmap = stp->st_access_bmap;\n\tset_access(open->op_share_access, stp);\n\n\t/* Set new deny mask */\n\told_deny_bmap = stp->st_deny_bmap;\n\tset_deny(open->op_share_deny, stp);\n\tfp->fi_share_deny |= (open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\n\tif (!fp->fi_fds[oflag]) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tstatus = nfsd_file_acquire(rqstp, cur_fh, access, &nf);\n\t\tif (status)\n\t\t\tgoto out_put_access;\n\t\tspin_lock(&fp->fi_lock);\n\t\tif (!fp->fi_fds[oflag]) {\n\t\t\tfp->fi_fds[oflag] = nf;\n\t\t\tnf = NULL;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\tif (nf)\n\t\tnfsd_file_put(nf);\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status)\n\t\tgoto out_put_access;\nout:\n\treturn status;\nout_put_access:\n\tstp->st_access_bmap = old_access_bmap;\n\tnfs4_file_put_access(fp, open->op_share_access);\n\treset_union_bmap_deny(bmap_to_share_mode(old_deny_bmap), stp);\n\tgoto out;\n}\n\nstatic __be32\nnfs4_upgrade_open(struct svc_rqst *rqstp, struct nfs4_file *fp, struct svc_fh *cur_fh, struct nfs4_ol_stateid *stp, struct nfsd4_open *open)\n{\n\t__be32 status;\n\tunsigned char old_deny_bmap = stp->st_deny_bmap;\n\n\tif (!test_access(open->op_share_access, stp))\n\t\treturn nfs4_get_vfs_file(rqstp, fp, cur_fh, stp, open);\n\n\t/* test and set deny mode */\n\tspin_lock(&fp->fi_lock);\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status == nfs_ok) {\n\t\tset_deny(open->op_share_deny, stp);\n\t\tfp->fi_share_deny |=\n\t\t\t\t(open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tif (status != nfs_ok)\n\t\treturn status;\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status != nfs_ok)\n\t\treset_union_bmap_deny(old_deny_bmap, stp);\n\treturn status;\n}\n\n/* Should we give out recallable state?: */\nstatic bool nfsd4_cb_channel_good(struct nfs4_client *clp)\n{\n\tif (clp->cl_cb_state == NFSD4_CB_UP)\n\t\treturn true;\n\t/*\n\t * In the sessions case, since we don't have to establish a\n\t * separate connection for callbacks, we assume it's OK\n\t * until we hear otherwise:\n\t */\n\treturn clp->cl_minorversion && clp->cl_cb_state == NFSD4_CB_UNKNOWN;\n}\n\nstatic struct file_lock *nfs4_alloc_init_lease(struct nfs4_delegation *dp,\n\t\t\t\t\t\tint flag)\n{\n\tstruct file_lock *fl;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn NULL;\n\tfl->fl_lmops = &nfsd_lease_mng_ops;\n\tfl->fl_flags = FL_DELEG;\n\tfl->fl_type = flag == NFS4_OPEN_DELEGATE_READ? F_RDLCK: F_WRLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = (fl_owner_t)dp;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = dp->dl_stid.sc_file->fi_deleg_file->nf_file;\n\treturn fl;\n}\n\nstatic int nfsd4_check_conflicting_opens(struct nfs4_client *clp,\n\t\t\t\t\t\tstruct nfs4_file *fp)\n{\n\tstruct nfs4_clnt_odstate *co;\n\tstruct file *f = fp->fi_deleg_file->nf_file;\n\tstruct inode *ino = locks_inode(f);\n\tint writes = atomic_read(&ino->i_writecount);\n\n\tif (fp->fi_fds[O_WRONLY])\n\t\twrites--;\n\tif (fp->fi_fds[O_RDWR])\n\t\twrites--;\n\tif (writes > 0)\n\t\treturn -EAGAIN;\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry(co, &fp->fi_clnt_odstate, co_perfile) {\n\t\tif (co->co_client != clp) {\n\t\t\tspin_unlock(&fp->fi_lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\treturn 0;\n}\n\nstatic struct nfs4_delegation *\nnfs4_set_delegation(struct nfs4_client *clp, struct svc_fh *fh,\n\t\t    struct nfs4_file *fp, struct nfs4_clnt_odstate *odstate)\n{\n\tint status = 0;\n\tstruct nfs4_delegation *dp;\n\tstruct nfsd_file *nf;\n\tstruct file_lock *fl;\n\n\t/*\n\t * The fi_had_conflict and nfs_get_existing_delegation checks\n\t * here are just optimizations; we'll need to recheck them at\n\t * the end:\n\t */\n\tif (fp->fi_had_conflict)\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tnf = find_readable_file(fp);\n\tif (!nf) {\n\t\t/*\n\t\t * We probably could attempt another open and get a read\n\t\t * delegation, but for now, don't bother until the\n\t\t * client actually sends us one.\n\t\t */\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tif (nfs4_delegation_exists(clp, fp))\n\t\tstatus = -EAGAIN;\n\telse if (!fp->fi_deleg_file) {\n\t\tfp->fi_deleg_file = nf;\n\t\t/* increment early to prevent fi_deleg_file from being\n\t\t * cleared */\n\t\tfp->fi_delegees = 1;\n\t\tnf = NULL;\n\t} else\n\t\tfp->fi_delegees++;\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\n\tif (nf)\n\t\tnfsd_file_put(nf);\n\tif (status)\n\t\treturn ERR_PTR(status);\n\n\tstatus = -ENOMEM;\n\tdp = alloc_init_deleg(clp, fp, fh, odstate);\n\tif (!dp)\n\t\tgoto out_delegees;\n\n\tfl = nfs4_alloc_init_lease(dp, NFS4_OPEN_DELEGATE_READ);\n\tif (!fl)\n\t\tgoto out_clnt_odstate;\n\n\tstatus = nfsd4_check_conflicting_opens(clp, fp);\n\tif (status) {\n\t\tlocks_free_lock(fl);\n\t\tgoto out_clnt_odstate;\n\t}\n\tstatus = vfs_setlease(fp->fi_deleg_file->nf_file, fl->fl_type, &fl, NULL);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (status)\n\t\tgoto out_clnt_odstate;\n\tstatus = nfsd4_check_conflicting_opens(clp, fp);\n\tif (status)\n\t\tgoto out_clnt_odstate;\n\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_had_conflict)\n\t\tstatus = -EAGAIN;\n\telse\n\t\tstatus = hash_delegation_locked(dp, fp);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\n\n\tif (status)\n\t\tgoto out_unlock;\n\n\treturn dp;\nout_unlock:\n\tvfs_setlease(fp->fi_deleg_file->nf_file, F_UNLCK, NULL, (void **)&dp);\nout_clnt_odstate:\n\tput_clnt_odstate(dp->dl_clnt_odstate);\n\tnfs4_put_stid(&dp->dl_stid);\nout_delegees:\n\tput_deleg_file(fp);\n\treturn ERR_PTR(status);\n}\n\nstatic void nfsd4_open_deleg_none_ext(struct nfsd4_open *open, int status)\n{\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\tif (status == -EAGAIN)\n\t\topen->op_why_no_deleg = WND4_CONTENTION;\n\telse {\n\t\topen->op_why_no_deleg = WND4_RESOURCE;\n\t\tswitch (open->op_deleg_want) {\n\t\tcase NFS4_SHARE_WANT_READ_DELEG:\n\t\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\t\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_CANCEL:\n\t\t\topen->op_why_no_deleg = WND4_CANCELLED;\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_NO_DELEG:\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t}\n}\n\n/*\n * Attempt to hand out a delegation.\n *\n * Note we don't support write delegations, and won't until the vfs has\n * proper support for them.\n */\nstatic void\nnfs4_open_delegation(struct svc_fh *fh, struct nfsd4_open *open,\n\t\t\tstruct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_openowner *oo = openowner(stp->st_stateowner);\n\tstruct nfs4_client *clp = stp->st_stid.sc_client;\n\tint cb_up;\n\tint status = 0;\n\n\tcb_up = nfsd4_cb_channel_good(oo->oo_owner.so_client);\n\topen->op_recall = 0;\n\tswitch (open->op_claim_type) {\n\t\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\t\tif (!cb_up)\n\t\t\t\topen->op_recall = 1;\n\t\t\tif (open->op_delegate_type != NFS4_OPEN_DELEGATE_READ)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tcase NFS4_OPEN_CLAIM_FH:\n\t\t\t/*\n\t\t\t * Let's not give out any delegations till everyone's\n\t\t\t * had the chance to reclaim theirs, *and* until\n\t\t\t * NLM locks have all been reclaimed:\n\t\t\t */\n\t\t\tif (locks_in_grace(clp->net))\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (!cb_up || !(oo->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_no_deleg;\n\t}\n\tdp = nfs4_set_delegation(clp, fh, stp->st_stid.sc_file, stp->st_clnt_odstate);\n\tif (IS_ERR(dp))\n\t\tgoto out_no_deleg;\n\n\tmemcpy(&open->op_delegate_stateid, &dp->dl_stid.sc_stateid, sizeof(dp->dl_stid.sc_stateid));\n\n\ttrace_nfsd_deleg_read(&dp->dl_stid.sc_stateid);\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_READ;\n\tnfs4_put_stid(&dp->dl_stid);\n\treturn;\nout_no_deleg:\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE;\n\tif (open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS &&\n\t    open->op_delegate_type != NFS4_OPEN_DELEGATE_NONE) {\n\t\tdprintk(\"NFSD: WARNING: refusing delegation reclaim\\n\");\n\t\topen->op_recall = 1;\n\t}\n\n\t/* 4.1 client asking for a delegation? */\n\tif (open->op_deleg_want)\n\t\tnfsd4_open_deleg_none_ext(open, status);\n\treturn;\n}\n\nstatic void nfsd4_deleg_xgrade_none_ext(struct nfsd4_open *open,\n\t\t\t\t\tstruct nfs4_delegation *dp)\n{\n\tif (open->op_deleg_want == NFS4_SHARE_WANT_READ_DELEG &&\n\t    dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_DOWNGRADE;\n\t} else if (open->op_deleg_want == NFS4_SHARE_WANT_WRITE_DELEG &&\n\t\t   dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_UPGRADE;\n\t}\n\t/* Otherwise the client must be confused wanting a delegation\n\t * it already has, therefore we don't return\n\t * NFS4_OPEN_DELEGATE_NONE_EXT and reason.\n\t */\n}\n\n__be32\nnfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfs4_client *cl = open->op_openowner->oo_owner.so_client;\n\tstruct nfs4_file *fp = NULL;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\t__be32 status;\n\tbool new_stp = false;\n\n\t/*\n\t * Lookup file; if found, lookup stateid and check open request,\n\t * and check for delegations in the process of being recalled.\n\t * If not found, create the nfs4_file struct\n\t */\n\tfp = find_or_add_file(open->op_file, &current_fh->fh_handle);\n\tif (fp != open->op_file) {\n\t\tstatus = nfs4_check_deleg(cl, open, &dp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tstp = nfsd4_find_and_lock_existing_open(fp, open);\n\t} else {\n\t\topen->op_file = NULL;\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (nfsd4_is_deleg_cur(open))\n\t\t\tgoto out;\n\t}\n\n\tif (!stp) {\n\t\tstp = init_open_stateid(fp, open);\n\t\tif (!open->op_stp)\n\t\t\tnew_stp = true;\n\t}\n\n\t/*\n\t * OPEN the file, or upgrade an existing OPEN.\n\t * If truncate fails, the OPEN fails.\n\t *\n\t * stp is already locked.\n\t */\n\tif (!new_stp) {\n\t\t/* Stateid was found, this is an OPEN upgrade */\n\t\tstatus = nfs4_upgrade_open(rqstp, fp, current_fh, stp, open);\n\t\tif (status) {\n\t\t\tmutex_unlock(&stp->st_mutex);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tstatus = nfs4_get_vfs_file(rqstp, fp, current_fh, stp, open);\n\t\tif (status) {\n\t\t\tstp->st_stid.sc_type = NFS4_CLOSED_STID;\n\t\t\trelease_open_stateid(stp);\n\t\t\tmutex_unlock(&stp->st_mutex);\n\t\t\tgoto out;\n\t\t}\n\n\t\tstp->st_clnt_odstate = find_or_hash_clnt_odstate(fp,\n\t\t\t\t\t\t\topen->op_odstate);\n\t\tif (stp->st_clnt_odstate == open->op_odstate)\n\t\t\topen->op_odstate = NULL;\n\t}\n\n\tnfs4_inc_and_copy_stateid(&open->op_stateid, &stp->st_stid);\n\tmutex_unlock(&stp->st_mutex);\n\n\tif (nfsd4_has_session(&resp->cstate)) {\n\t\tif (open->op_deleg_want & NFS4_SHARE_WANT_NO_DELEG) {\n\t\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\t\topen->op_why_no_deleg = WND4_NOT_WANTED;\n\t\t\tgoto nodeleg;\n\t\t}\n\t}\n\n\t/*\n\t* Attempt to hand out a delegation. No error return, because the\n\t* OPEN succeeds even if we fail.\n\t*/\n\tnfs4_open_delegation(current_fh, open, stp);\nnodeleg:\n\tstatus = nfs_ok;\n\ttrace_nfsd_open(&stp->st_stid.sc_stateid);\nout:\n\t/* 4.1 client trying to upgrade/downgrade delegation? */\n\tif (open->op_delegate_type == NFS4_OPEN_DELEGATE_NONE && dp &&\n\t    open->op_deleg_want)\n\t\tnfsd4_deleg_xgrade_none_ext(open, dp);\n\n\tif (fp)\n\t\tput_nfs4_file(fp);\n\tif (status == 0 && open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\t/*\n\t* To finish the open response, we just need to set the rflags.\n\t*/\n\topen->op_rflags = NFS4_OPEN_RESULT_LOCKTYPE_POSIX;\n\tif (nfsd4_has_session(&resp->cstate))\n\t\topen->op_rflags |= NFS4_OPEN_RESULT_MAY_NOTIFY_LOCK;\n\telse if (!(open->op_openowner->oo_flags & NFS4_OO_CONFIRMED))\n\t\topen->op_rflags |= NFS4_OPEN_RESULT_CONFIRM;\n\n\tif (dp)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\tif (stp)\n\t\tnfs4_put_stid(&stp->st_stid);\n\n\treturn status;\n}\n\nvoid nfsd4_cleanup_open_state(struct nfsd4_compound_state *cstate,\n\t\t\t      struct nfsd4_open *open)\n{\n\tif (open->op_openowner) {\n\t\tstruct nfs4_stateowner *so = &open->op_openowner->oo_owner;\n\n\t\tnfsd4_cstate_assign_replay(cstate, so);\n\t\tnfs4_put_stateowner(so);\n\t}\n\tif (open->op_file)\n\t\tkmem_cache_free(file_slab, open->op_file);\n\tif (open->op_stp)\n\t\tnfs4_put_stid(&open->op_stp->st_stid);\n\tif (open->op_odstate)\n\t\tkmem_cache_free(odstate_slab, open->op_odstate);\n}\n\n__be32\nnfsd4_renew(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    union nfsd4_op_u *u)\n{\n\tclientid_t *clid = &u->renew;\n\tstruct nfs4_client *clp;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\ttrace_nfsd_clid_renew(clid);\n\tstatus = lookup_clientid(clid, cstate, nn, false);\n\tif (status)\n\t\tgoto out;\n\tclp = cstate->clp;\n\tstatus = nfserr_cb_path_down;\n\tif (!list_empty(&clp->cl_delegations)\n\t\t\t&& clp->cl_cb_state != NFSD4_CB_UP)\n\t\tgoto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}\n\nvoid\nnfsd4_end_grace(struct nfsd_net *nn)\n{\n\t/* do nothing if grace period already ended */\n\tif (nn->grace_ended)\n\t\treturn;\n\n\ttrace_nfsd_grace_complete(nn);\n\tnn->grace_ended = true;\n\t/*\n\t * If the server goes down again right now, an NFSv4\n\t * client will still be allowed to reclaim after it comes back up,\n\t * even if it hasn't yet had a chance to reclaim state this time.\n\t *\n\t */\n\tnfsd4_record_grace_done(nn);\n\t/*\n\t * At this point, NFSv4 clients can still reclaim.  But if the\n\t * server crashes, any that have not yet reclaimed will be out\n\t * of luck on the next boot.\n\t *\n\t * (NFSv4.1+ clients are considered to have reclaimed once they\n\t * call RECLAIM_COMPLETE.  NFSv4.0 clients are considered to\n\t * have reclaimed after their first OPEN.)\n\t */\n\tlocks_end_grace(&nn->nfsd4_manager);\n\t/*\n\t * At this point, and once lockd and/or any other containers\n\t * exit their grace period, further reclaims will fail and\n\t * regular locking can resume.\n\t */\n}\n\n/*\n * If we've waited a lease period but there are still clients trying to\n * reclaim, wait a little longer to give them a chance to finish.\n */\nstatic bool clients_still_reclaiming(struct nfsd_net *nn)\n{\n\ttime64_t double_grace_period_end = nn->boot_time +\n\t\t\t\t\t   2 * nn->nfsd4_lease;\n\n\tif (nn->track_reclaim_completes &&\n\t\t\tatomic_read(&nn->nr_reclaim_complete) ==\n\t\t\tnn->reclaim_str_hashtbl_size)\n\t\treturn false;\n\tif (!nn->somebody_reclaimed)\n\t\treturn false;\n\tnn->somebody_reclaimed = false;\n\t/*\n\t * If we've given them *two* lease times to reclaim, and they're\n\t * still not done, give up:\n\t */\n\tif (ktime_get_boottime_seconds() > double_grace_period_end)\n\t\treturn false;\n\treturn true;\n}\n\nstatic time64_t\nnfs4_laundromat(struct nfsd_net *nn)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfsd4_blocked_lock *nbl;\n\tstruct list_head *pos, *next, reaplist;\n\ttime64_t cutoff = ktime_get_boottime_seconds() - nn->nfsd4_lease;\n\ttime64_t t, new_timeo = nn->nfsd4_lease;\n\tstruct nfs4_cpntf_state *cps;\n\tcopy_stateid_t *cps_t;\n\tint i;\n\n\tif (clients_still_reclaiming(nn)) {\n\t\tnew_timeo = 0;\n\t\tgoto out;\n\t}\n\tnfsd4_end_grace(nn);\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&nn->s2s_cp_lock);\n\tidr_for_each_entry(&nn->s2s_cp_stateids, cps_t, i) {\n\t\tcps = container_of(cps_t, struct nfs4_cpntf_state, cp_stateid);\n\t\tif (cps->cp_stateid.sc_type == NFS4_COPYNOTIFY_STID &&\n\t\t\t\tcps->cpntf_time > cutoff)\n\t\t\t_free_cpntf_state_locked(nn, cps);\n\t}\n\tspin_unlock(&nn->s2s_cp_lock);\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &nn->client_lru) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tif (clp->cl_time > cutoff) {\n\t\t\tt = clp->cl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tif (mark_client_expired_locked(clp)) {\n\t\t\ttrace_nfsd_clid_expired(&clp->cl_clientid);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_add(&clp->cl_lru, &reaplist);\n\t}\n\tspin_unlock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &reaplist) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\ttrace_nfsd_clid_purged(&clp->cl_clientid);\n\t\tlist_del_init(&clp->cl_lru);\n\t\texpire_client(clp);\n\t}\n\tspin_lock(&state_lock);\n\tlist_for_each_safe(pos, next, &nn->del_recall_lru) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tif (dp->dl_time > cutoff) {\n\t\t\tt = dp->dl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_first_entry(&reaplist, struct nfs4_delegation,\n\t\t\t\t\tdl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\trevoke_delegation(dp);\n\t}\n\n\tspin_lock(&nn->client_lock);\n\twhile (!list_empty(&nn->close_lru)) {\n\t\too = list_first_entry(&nn->close_lru, struct nfs4_openowner,\n\t\t\t\t\too_close_lru);\n\t\tif (oo->oo_time > cutoff) {\n\t\t\tt = oo->oo_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\tstp = oo->oo_last_closed_stid;\n\t\too->oo_last_closed_stid = NULL;\n\t\tspin_unlock(&nn->client_lock);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tspin_lock(&nn->client_lock);\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\t/*\n\t * It's possible for a client to try and acquire an already held lock\n\t * that is being held for a long time, and then lose interest in it.\n\t * So, we clean out any un-revisited request after a lease period\n\t * under the assumption that the client is no longer interested.\n\t *\n\t * RFC5661, sec. 9.6 states that the client must not rely on getting\n\t * notifications and must continue to poll for locks, even when the\n\t * server supports them. Thus this shouldn't lead to clients blocking\n\t * indefinitely once the lock does become free.\n\t */\n\tBUG_ON(!list_empty(&reaplist));\n\tspin_lock(&nn->blocked_locks_lock);\n\twhile (!list_empty(&nn->blocked_locks_lru)) {\n\t\tnbl = list_first_entry(&nn->blocked_locks_lru,\n\t\t\t\t\tstruct nfsd4_blocked_lock, nbl_lru);\n\t\tif (nbl->nbl_time > cutoff) {\n\t\t\tt = nbl->nbl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tlist_move(&nbl->nbl_lru, &reaplist);\n\t\tlist_del_init(&nbl->nbl_list);\n\t}\n\tspin_unlock(&nn->blocked_locks_lock);\n\n\twhile (!list_empty(&reaplist)) {\n\t\tnbl = list_first_entry(&reaplist,\n\t\t\t\t\tstruct nfsd4_blocked_lock, nbl_lru);\n\t\tlist_del_init(&nbl->nbl_lru);\n\t\tfree_blocked_lock(nbl);\n\t}\nout:\n\tnew_timeo = max_t(time64_t, new_timeo, NFSD_LAUNDROMAT_MINTIMEOUT);\n\treturn new_timeo;\n}\n\nstatic struct workqueue_struct *laundry_wq;\nstatic void laundromat_main(struct work_struct *);\n\nstatic void\nlaundromat_main(struct work_struct *laundry)\n{\n\ttime64_t t;\n\tstruct delayed_work *dwork = to_delayed_work(laundry);\n\tstruct nfsd_net *nn = container_of(dwork, struct nfsd_net,\n\t\t\t\t\t   laundromat_work);\n\n\tt = nfs4_laundromat(nn);\n\tqueue_delayed_work(laundry_wq, &nn->laundromat_work, t*HZ);\n}\n\nstatic inline __be32 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_stid *stp)\n{\n\tif (!fh_match(&fhp->fh_handle, &stp->sc_file->fi_fhandle))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}\n\nstatic inline int\naccess_permit_read(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_READ, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_WRITE, stp);\n}\n\nstatic inline int\naccess_permit_write(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_WRITE, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp);\n}\n\nstatic\n__be32 nfs4_check_openmode(struct nfs4_ol_stateid *stp, int flags)\n{\n        __be32 status = nfserr_openmode;\n\n\t/* For lock stateid's, we test the parent open, not the lock: */\n\tif (stp->st_openstp)\n\t\tstp = stp->st_openstp;\n\tif ((flags & WR_STATE) && !access_permit_write(stp))\n                goto out;\n\tif ((flags & RD_STATE) && !access_permit_read(stp))\n                goto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}\n\nstatic inline __be32\ncheck_special_stateids(struct net *net, svc_fh *current_fh, stateid_t *stateid, int flags)\n{\n\tif (ONE_STATEID(stateid) && (flags & RD_STATE))\n\t\treturn nfs_ok;\n\telse if (opens_in_grace(net)) {\n\t\t/* Answer in remaining cases depends on existence of\n\t\t * conflicting state; so we must wait out the grace period. */\n\t\treturn nfserr_grace;\n\t} else if (flags & WR_STATE)\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_WRITE);\n\telse /* (flags & RD_STATE) && ZERO_STATEID(stateid) */\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_READ);\n}\n\n/*\n * Allow READ/WRITE during grace period on recovered state only for files\n * that are not able to provide mandatory locking.\n */\nstatic inline int\ngrace_disallows_io(struct net *net, struct inode *inode)\n{\n\treturn opens_in_grace(net) && mandatory_lock(inode);\n}\n\nstatic __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (nfsd4_stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}\n\nstatic __be32 nfsd4_stid_check_stateid_generation(stateid_t *in, struct nfs4_stid *s, bool has_session)\n{\n\t__be32 ret;\n\n\tspin_lock(&s->sc_lock);\n\tret = nfsd4_verify_open_stid(s);\n\tif (ret == nfs_ok)\n\t\tret = check_stateid_generation(in, &s->sc_stateid, has_session);\n\tspin_unlock(&s->sc_lock);\n\treturn ret;\n}\n\nstatic __be32 nfsd4_check_openowner_confirmed(struct nfs4_ol_stateid *ols)\n{\n\tif (ols->st_stateowner->so_is_open_owner &&\n\t    !(openowner(ols->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}\n\nstatic __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)\n{\n\tstruct nfs4_stid *s;\n\t__be32 status = nfserr_bad_stateid;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid) ||\n\t\tCLOSE_STATEID(stateid))\n\t\treturn status;\n\tif (!same_clid(&stateid->si_opaque.so_clid, &cl->cl_clientid))\n\t\treturn status;\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, stateid);\n\tif (!s)\n\t\tgoto out_unlock;\n\tstatus = nfsd4_stid_check_stateid_generation(stateid, s, 1);\n\tif (status)\n\t\tgoto out_unlock;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tstatus = nfs_ok;\n\t\tbreak;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tstatus = nfserr_deleg_revoked;\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstatus = nfsd4_check_openowner_confirmed(openlockstateid(s));\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"unknown stateid type %x\\n\", s->sc_type);\n\t\tfallthrough;\n\tcase NFS4_CLOSED_STID:\n\tcase NFS4_CLOSED_DELEG_STID:\n\t\tstatus = nfserr_bad_stateid;\n\t}\nout_unlock:\n\tspin_unlock(&cl->cl_lock);\n\treturn status;\n}\n\n__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\tbool return_revoked = false;\n\n\t/*\n\t *  only return revoked delegations if explicitly asked.\n\t *  otherwise we report revoked or bad_stateid status.\n\t */\n\tif (typemask & NFS4_REVOKED_DELEG_STID)\n\t\treturn_revoked = true;\n\telse if (typemask & NFS4_DELEG_STID)\n\t\ttypemask |= NFS4_REVOKED_DELEG_STID;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid) ||\n\t\tCLOSE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn,\n\t\t\t\t false);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\tif (((*s)->sc_type == NFS4_REVOKED_DELEG_STID) && !return_revoked) {\n\t\tnfs4_put_stid(*s);\n\t\tif (cstate->minorversion)\n\t\t\treturn nfserr_deleg_revoked;\n\t\treturn nfserr_bad_stateid;\n\t}\n\treturn nfs_ok;\n}\n\nstatic struct nfsd_file *\nnfs4_find_file(struct nfs4_stid *s, int flags)\n{\n\tif (!s)\n\t\treturn NULL;\n\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tif (WARN_ON_ONCE(!s->sc_file->fi_deleg_file))\n\t\t\treturn NULL;\n\t\treturn nfsd_file_get(s->sc_file->fi_deleg_file);\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tif (flags & RD_STATE)\n\t\t\treturn find_readable_file(s->sc_file);\n\t\telse\n\t\t\treturn find_writeable_file(s->sc_file);\n\t}\n\n\treturn NULL;\n}\n\nstatic __be32\nnfs4_check_olstateid(struct nfs4_ol_stateid *ols, int flags)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_check_openowner_confirmed(ols);\n\tif (status)\n\t\treturn status;\n\treturn nfs4_check_openmode(ols, flags);\n}\n\nstatic __be32\nnfs4_check_file(struct svc_rqst *rqstp, struct svc_fh *fhp, struct nfs4_stid *s,\n\t\tstruct nfsd_file **nfp, int flags)\n{\n\tint acc = (flags & RD_STATE) ? NFSD_MAY_READ : NFSD_MAY_WRITE;\n\tstruct nfsd_file *nf;\n\t__be32 status;\n\n\tnf = nfs4_find_file(s, flags);\n\tif (nf) {\n\t\tstatus = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\tacc | NFSD_MAY_OWNER_OVERRIDE);\n\t\tif (status) {\n\t\t\tnfsd_file_put(nf);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tstatus = nfsd_file_acquire(rqstp, fhp, acc, &nf);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\t*nfp = nf;\nout:\n\treturn status;\n}\nstatic void\n_free_cpntf_state_locked(struct nfsd_net *nn, struct nfs4_cpntf_state *cps)\n{\n\tWARN_ON_ONCE(cps->cp_stateid.sc_type != NFS4_COPYNOTIFY_STID);\n\tif (!refcount_dec_and_test(&cps->cp_stateid.sc_count))\n\t\treturn;\n\tlist_del(&cps->cp_list);\n\tidr_remove(&nn->s2s_cp_stateids,\n\t\t   cps->cp_stateid.stid.si_opaque.so_id);\n\tkfree(cps);\n}\n/*\n * A READ from an inter server to server COPY will have a\n * copy stateid. Look up the copy notify stateid from the\n * idr structure and take a reference on it.\n */\n__be32 manage_cpntf_state(struct nfsd_net *nn, stateid_t *st,\n\t\t\t  struct nfs4_client *clp,\n\t\t\t  struct nfs4_cpntf_state **cps)\n{\n\tcopy_stateid_t *cps_t;\n\tstruct nfs4_cpntf_state *state = NULL;\n\n\tif (st->si_opaque.so_clid.cl_id != nn->s2s_cp_cl_id)\n\t\treturn nfserr_bad_stateid;\n\tspin_lock(&nn->s2s_cp_lock);\n\tcps_t = idr_find(&nn->s2s_cp_stateids, st->si_opaque.so_id);\n\tif (cps_t) {\n\t\tstate = container_of(cps_t, struct nfs4_cpntf_state,\n\t\t\t\t     cp_stateid);\n\t\tif (state->cp_stateid.sc_type != NFS4_COPYNOTIFY_STID) {\n\t\t\tstate = NULL;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (!clp)\n\t\t\trefcount_inc(&state->cp_stateid.sc_count);\n\t\telse\n\t\t\t_free_cpntf_state_locked(nn, state);\n\t}\nunlock:\n\tspin_unlock(&nn->s2s_cp_lock);\n\tif (!state)\n\t\treturn nfserr_bad_stateid;\n\tif (!clp && state)\n\t\t*cps = state;\n\treturn 0;\n}\n\nstatic __be32 find_cpntf_state(struct nfsd_net *nn, stateid_t *st,\n\t\t\t       struct nfs4_stid **stid)\n{\n\t__be32 status;\n\tstruct nfs4_cpntf_state *cps = NULL;\n\tstruct nfsd4_compound_state cstate;\n\n\tstatus = manage_cpntf_state(nn, st, NULL, &cps);\n\tif (status)\n\t\treturn status;\n\n\tcps->cpntf_time = ktime_get_boottime_seconds();\n\tmemset(&cstate, 0, sizeof(cstate));\n\tstatus = lookup_clientid(&cps->cp_p_clid, &cstate, nn, true);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd4_lookup_stateid(&cstate, &cps->cp_p_stateid,\n\t\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,\n\t\t\t\tstid, nn);\n\tput_client_renew(cstate.clp);\nout:\n\tnfs4_put_cpntf_state(nn, cps);\n\treturn status;\n}\n\nvoid nfs4_put_cpntf_state(struct nfsd_net *nn, struct nfs4_cpntf_state *cps)\n{\n\tspin_lock(&nn->s2s_cp_lock);\n\t_free_cpntf_state_locked(nn, cps);\n\tspin_unlock(&nn->s2s_cp_lock);\n}\n\n/*\n * Checks for stateid operations\n */\n__be32\nnfs4_preprocess_stateid_op(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, struct svc_fh *fhp,\n\t\tstateid_t *stateid, int flags, struct nfsd_file **nfp,\n\t\tstruct nfs4_stid **cstid)\n{\n\tstruct inode *ino = d_inode(fhp->fh_dentry);\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct nfs4_stid *s = NULL;\n\t__be32 status;\n\n\tif (nfp)\n\t\t*nfp = NULL;\n\n\tif (grace_disallows_io(net, ino))\n\t\treturn nfserr_grace;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid)) {\n\t\tstatus = check_special_stateids(net, fhp, stateid, flags);\n\t\tgoto done;\n\t}\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid,\n\t\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,\n\t\t\t\t&s, nn);\n\tif (status == nfserr_bad_stateid)\n\t\tstatus = find_cpntf_state(nn, stateid, &s);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_stid_check_stateid_generation(stateid, s,\n\t\t\tnfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto out;\n\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tstatus = nfs4_check_delegmode(delegstateid(s), flags);\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstatus = nfs4_check_olstateid(openlockstateid(s), flags);\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_bad_stateid;\n\t\tbreak;\n\t}\n\tif (status)\n\t\tgoto out;\n\tstatus = nfs4_check_fh(fhp, s);\n\ndone:\n\tif (status == nfs_ok && nfp)\n\t\tstatus = nfs4_check_file(rqstp, fhp, s, nfp, flags);\nout:\n\tif (s) {\n\t\tif (!status && cstid)\n\t\t\t*cstid = s;\n\t\telse\n\t\t\tnfs4_put_stid(s);\n\t}\n\treturn status;\n}\n\n/*\n * Test if the stateid is valid\n */\n__be32\nnfsd4_test_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_test_stateid *test_stateid = &u->test_stateid;\n\tstruct nfsd4_test_stateid_id *stateid;\n\tstruct nfs4_client *cl = cstate->session->se_client;\n\n\tlist_for_each_entry(stateid, &test_stateid->ts_stateid_list, ts_id_list)\n\t\tstateid->ts_id_status =\n\t\t\tnfsd4_validate_stateid(cl, &stateid->ts_id_stateid);\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_free_lock_stateid(stateid_t *stateid, struct nfs4_stid *s)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(s);\n\t__be32 ret;\n\n\tret = nfsd4_lock_ol_stateid(stp);\n\tif (ret)\n\t\tgoto out_put_stid;\n\n\tret = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tret = nfserr_locks_held;\n\tif (check_for_locks(stp->st_stid.sc_file,\n\t\t\t    lockowner(stp->st_stateowner)))\n\t\tgoto out;\n\n\trelease_lock_stateid(stp);\n\tret = nfs_ok;\n\nout:\n\tmutex_unlock(&stp->st_mutex);\nout_put_stid:\n\tnfs4_put_stid(s);\n\treturn ret;\n}\n\n__be32\nnfsd4_free_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_free_stateid *free_stateid = &u->free_stateid;\n\tstateid_t *stateid = &free_stateid->fr_stateid;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_client *cl = cstate->session->se_client;\n\t__be32 ret = nfserr_bad_stateid;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, stateid);\n\tif (!s)\n\t\tgoto out_unlock;\n\tspin_lock(&s->sc_lock);\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tret = nfserr_locks_held;\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\t\tret = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = nfserr_locks_held;\n\t\tbreak;\n\tcase NFS4_LOCK_STID:\n\t\tspin_unlock(&s->sc_lock);\n\t\trefcount_inc(&s->sc_count);\n\t\tspin_unlock(&cl->cl_lock);\n\t\tret = nfsd4_free_lock_stateid(stateid, s);\n\t\tgoto out;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tspin_unlock(&s->sc_lock);\n\t\tdp = delegstateid(s);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tspin_unlock(&cl->cl_lock);\n\t\tnfs4_put_stid(s);\n\t\tret = nfs_ok;\n\t\tgoto out;\n\t/* Default falls through and returns nfserr_bad_stateid */\n\t}\n\tspin_unlock(&s->sc_lock);\nout_unlock:\n\tspin_unlock(&cl->cl_lock);\nout:\n\treturn ret;\n}\n\nstatic inline int\nsetlkflg (int type)\n{\n\treturn (type == NFS4_READW_LT || type == NFS4_READ_LT) ?\n\t\tRD_STATE : WR_STATE;\n}\n\nstatic __be32 nfs4_seqid_op_checks(struct nfsd4_compound_state *cstate, stateid_t *stateid, u32 seqid, struct nfs4_ol_stateid *stp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct nfs4_stateowner *sop = stp->st_stateowner;\n\t__be32 status;\n\n\tstatus = nfsd4_check_seqid(cstate, sop, seqid);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_lock_ol_stateid(stp);\n\tif (status != nfs_ok)\n\t\treturn status;\n\tstatus = check_stateid_generation(stateid, &stp->st_stid.sc_stateid, nfsd4_has_session(cstate));\n\tif (status == nfs_ok)\n\t\tstatus = nfs4_check_fh(current_fh, &stp->st_stid);\n\tif (status != nfs_ok)\n\t\tmutex_unlock(&stp->st_mutex);\n\treturn status;\n}\n\n/* \n * Checks for sequence id mutating operations. \n */\nstatic __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\ttrace_nfsd_preprocess(seqid, stateid);\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}\n\nstatic __be32 nfs4_preprocess_confirmed_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t\t\t\t stateid_t *stateid, struct nfs4_ol_stateid **stpp, struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, seqid, stateid,\n\t\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\treturn status;\n\too = openowner(stp->st_stateowner);\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\treturn nfserr_bad_stateid;\n\t}\n\t*stpp = stp;\n\treturn nfs_ok;\n}\n\n__be32\nnfsd4_open_confirm(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_open_confirm *oc = &u->open_confirm;\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_open_confirm on file %pd\\n\",\n\t\t\tcstate->current_fh.fh_dentry);\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate,\n\t\t\t\t\toc->oc_seqid, &oc->oc_req_stateid,\n\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\tgoto out;\n\too = openowner(stp->st_stateowner);\n\tstatus = nfserr_bad_stateid;\n\tif (oo->oo_flags & NFS4_OO_CONFIRMED) {\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tgoto put_stateid;\n\t}\n\too->oo_flags |= NFS4_OO_CONFIRMED;\n\tnfs4_inc_and_copy_stateid(&oc->oc_resp_stateid, &stp->st_stid);\n\tmutex_unlock(&stp->st_mutex);\n\ttrace_nfsd_open_confirm(oc->oc_seqid, &stp->st_stid.sc_stateid);\n\tnfsd4_client_record_create(oo->oo_owner.so_client);\n\tstatus = nfs_ok;\nput_stateid:\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\treturn status;\n}\n\nstatic inline void nfs4_stateid_downgrade_bit(struct nfs4_ol_stateid *stp, u32 access)\n{\n\tif (!test_access(access, stp))\n\t\treturn;\n\tnfs4_file_put_access(stp->st_stid.sc_file, access);\n\tclear_access(access, stp);\n}\n\nstatic inline void nfs4_stateid_downgrade(struct nfs4_ol_stateid *stp, u32 to_access)\n{\n\tswitch (to_access) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_WRITE);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_READ);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}\n\n__be32\nnfsd4_open_downgrade(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_open_downgrade *od = &u->open_downgrade;\n\t__be32 status;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_open_downgrade on file %pd\\n\", \n\t\t\tcstate->current_fh.fh_dentry);\n\n\t/* We don't yet support WANT bits: */\n\tif (od->od_deleg_want)\n\t\tdprintk(\"NFSD: %s: od_deleg_want=0x%x ignored\\n\", __func__,\n\t\t\tod->od_deleg_want);\n\n\tstatus = nfs4_preprocess_confirmed_seqid_op(cstate, od->od_seqid,\n\t\t\t\t\t&od->od_stateid, &stp, nn);\n\tif (status)\n\t\tgoto out; \n\tstatus = nfserr_inval;\n\tif (!test_access(od->od_share_access, stp)) {\n\t\tdprintk(\"NFSD: access not a subset of current bitmap: 0x%hhx, input access=%08x\\n\",\n\t\t\tstp->st_access_bmap, od->od_share_access);\n\t\tgoto put_stateid;\n\t}\n\tif (!test_deny(od->od_share_deny, stp)) {\n\t\tdprintk(\"NFSD: deny not a subset of current bitmap: 0x%hhx, input deny=%08x\\n\",\n\t\t\tstp->st_deny_bmap, od->od_share_deny);\n\t\tgoto put_stateid;\n\t}\n\tnfs4_stateid_downgrade(stp, od->od_share_access);\n\treset_union_bmap_deny(od->od_share_deny, stp);\n\tnfs4_inc_and_copy_stateid(&od->od_stateid, &stp->st_stid);\n\tstatus = nfs_ok;\nput_stateid:\n\tmutex_unlock(&stp->st_mutex);\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\treturn status;\n}\n\nstatic void nfsd4_close_open_stateid(struct nfs4_ol_stateid *s)\n{\n\tstruct nfs4_client *clp = s->st_stid.sc_client;\n\tbool unhashed;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhashed = unhash_open_stateid(s, &reaplist);\n\n\tif (clp->cl_minorversion) {\n\t\tif (unhashed)\n\t\t\tput_ol_stateid_locked(s, &reaplist);\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t} else {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t\tif (unhashed)\n\t\t\tmove_to_close_lru(s, clp->net);\n\t}\n}\n\n/*\n * nfs4_unlock_state() called after encode\n */\n__be32\nnfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_close *close = &u->close;\n\t__be32 status;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_close on file %pd\\n\", \n\t\t\tcstate->current_fh.fh_dentry);\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, close->cl_seqid,\n\t\t\t\t\t&close->cl_stateid,\n\t\t\t\t\tNFS4_OPEN_STID|NFS4_CLOSED_STID,\n\t\t\t\t\t&stp, nn);\n\tnfsd4_bump_seqid(cstate, status);\n\tif (status)\n\t\tgoto out; \n\n\tstp->st_stid.sc_type = NFS4_CLOSED_STID;\n\n\t/*\n\t * Technically we don't _really_ have to increment or copy it, since\n\t * it should just be gone after this operation and we clobber the\n\t * copied value below, but we continue to do so here just to ensure\n\t * that racing ops see that there was a state change.\n\t */\n\tnfs4_inc_and_copy_stateid(&close->cl_stateid, &stp->st_stid);\n\n\tnfsd4_close_open_stateid(stp);\n\tmutex_unlock(&stp->st_mutex);\n\n\t/* v4.1+ suggests that we send a special stateid in here, since the\n\t * clients should just ignore this anyway. Since this is not useful\n\t * for v4.0 clients either, we set it to the special close_stateid\n\t * universally.\n\t *\n\t * See RFC5661 section 18.2.4, and RFC7530 section 16.2.5\n\t */\n\tmemcpy(&close->cl_stateid, &close_stateid, sizeof(close->cl_stateid));\n\n\t/* put reference from nfs4_preprocess_seqid_op */\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\treturn status;\n}\n\n__be32\nnfsd4_delegreturn(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_delegreturn *dr = &u->delegreturn;\n\tstruct nfs4_delegation *dp;\n\tstateid_t *stateid = &dr->dr_stateid;\n\tstruct nfs4_stid *s;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0)))\n\t\treturn status;\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, NFS4_DELEG_STID, &s, nn);\n\tif (status)\n\t\tgoto out;\n\tdp = delegstateid(s);\n\tstatus = nfsd4_stid_check_stateid_generation(stateid, &dp->dl_stid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto put_stateid;\n\n\tdestroy_delegation(dp);\nput_stateid:\n\tnfs4_put_stid(&dp->dl_stid);\nout:\n\treturn status;\n}\n\nstatic inline u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end: NFS4_MAX_UINT64;\n}\n\n/* last octet in a range */\nstatic inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}\n\n/*\n * TODO: Linux file offsets are _signed_ 64-bit quantities, which means that\n * we can't properly handle lock requests that go beyond the (2^63 - 1)-th\n * byte, because of sign extension problems.  Since NFSv4 calls for 64-bit\n * locking, this prevents us from being completely protocol-compliant.  The\n * real solution to this problem is to start using unsigned file offsets in\n * the VFS, but this is a very deep change!\n */\nstatic inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}\n\nstatic fl_owner_t\nnfsd4_fl_get_owner(fl_owner_t owner)\n{\n\tstruct nfs4_lockowner *lo = (struct nfs4_lockowner *)owner;\n\n\tnfs4_get_stateowner(&lo->lo_owner);\n\treturn owner;\n}\n\nstatic void\nnfsd4_fl_put_owner(fl_owner_t owner)\n{\n\tstruct nfs4_lockowner *lo = (struct nfs4_lockowner *)owner;\n\n\tif (lo)\n\t\tnfs4_put_stateowner(&lo->lo_owner);\n}\n\nstatic void\nnfsd4_lm_notify(struct file_lock *fl)\n{\n\tstruct nfs4_lockowner\t\t*lo = (struct nfs4_lockowner *)fl->fl_owner;\n\tstruct net\t\t\t*net = lo->lo_owner.so_client->net;\n\tstruct nfsd_net\t\t\t*nn = net_generic(net, nfsd_net_id);\n\tstruct nfsd4_blocked_lock\t*nbl = container_of(fl,\n\t\t\t\t\t\tstruct nfsd4_blocked_lock, nbl_lock);\n\tbool queue = false;\n\n\t/* An empty list means that something else is going to be using it */\n\tspin_lock(&nn->blocked_locks_lock);\n\tif (!list_empty(&nbl->nbl_list)) {\n\t\tlist_del_init(&nbl->nbl_list);\n\t\tlist_del_init(&nbl->nbl_lru);\n\t\tqueue = true;\n\t}\n\tspin_unlock(&nn->blocked_locks_lock);\n\n\tif (queue)\n\t\tnfsd4_run_cb(&nbl->nbl_cb);\n}\n\nstatic const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_notify = nfsd4_lm_notify,\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};\n\nstatic inline void\nnfs4_set_lock_denied(struct file_lock *fl, struct nfsd4_lock_denied *deny)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tif (fl->fl_lmops == &nfsd_posix_mng_ops) {\n\t\tlo = (struct nfs4_lockowner *) fl->fl_owner;\n\t\txdr_netobj_dup(&deny->ld_owner, &lo->lo_owner.so_owner,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!deny->ld_owner.data)\n\t\t\t/* We just don't care that much */\n\t\t\tgoto nevermind;\n\t\tdeny->ld_clientid = lo->lo_owner.so_client->cl_clientid;\n\t} else {\nnevermind:\n\t\tdeny->ld_owner.len = 0;\n\t\tdeny->ld_owner.data = NULL;\n\t\tdeny->ld_clientid.cl_boot = 0;\n\t\tdeny->ld_clientid.cl_id = 0;\n\t}\n\tdeny->ld_start = fl->fl_start;\n\tdeny->ld_length = NFS4_MAX_UINT64;\n\tif (fl->fl_end != NFS4_MAX_UINT64)\n\t\tdeny->ld_length = fl->fl_end - fl->fl_start + 1;        \n\tdeny->ld_type = NFS4_READ_LT;\n\tif (fl->fl_type != F_RDLCK)\n\t\tdeny->ld_type = NFS4_WRITE_LT;\n}\n\nstatic struct nfs4_lockowner *\nfind_lockowner_str_locked(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tunsigned int strhashval = ownerstr_hashval(owner);\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[strhashval],\n\t\t\t    so_strhash) {\n\t\tif (so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, owner))\n\t\t\treturn lockowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}\n\nstatic struct nfs4_lockowner *\nfind_lockowner_str(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tspin_lock(&clp->cl_lock);\n\tlo = find_lockowner_str_locked(clp, owner);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}\n\nstatic void nfs4_unhash_lockowner(struct nfs4_stateowner *sop)\n{\n\tunhash_lockowner_locked(lockowner(sop));\n}\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}\n\nstatic const struct nfs4_stateowner_operations lockowner_ops = {\n\t.so_unhash =\tnfs4_unhash_lockowner,\n\t.so_free =\tnfs4_free_lockowner,\n};\n\n/*\n * Alloc a lock owner structure.\n * Called in nfsd4_lock - therefore, OPEN and OPEN_CONFIRM (if needed) has \n * occurred. \n *\n * strhashval = ownerstr_hashval\n */\nstatic struct nfs4_lockowner *\nalloc_init_lock_stateowner(unsigned int strhashval, struct nfs4_client *clp,\n\t\t\t   struct nfs4_ol_stateid *open_stp,\n\t\t\t   struct nfsd4_lock *lock)\n{\n\tstruct nfs4_lockowner *lo, *ret;\n\n\tlo = alloc_stateowner(lockowner_slab, &lock->lk_new_owner, clp);\n\tif (!lo)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&lo->lo_blocked);\n\tINIT_LIST_HEAD(&lo->lo_owner.so_stateids);\n\tlo->lo_owner.so_is_open_owner = 0;\n\tlo->lo_owner.so_seqid = lock->lk_new_lock_seqid;\n\tlo->lo_owner.so_ops = &lockowner_ops;\n\tspin_lock(&clp->cl_lock);\n\tret = find_lockowner_str_locked(clp, &lock->lk_new_owner);\n\tif (ret == NULL) {\n\t\tlist_add(&lo->lo_owner.so_strhash,\n\t\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\t\tret = lo;\n\t} else\n\t\tnfs4_free_stateowner(&lo->lo_owner);\n\n\tspin_unlock(&clp->cl_lock);\n\treturn ret;\n}\n\nstatic struct nfs4_ol_stateid *\nfind_lock_stateid(const struct nfs4_lockowner *lo,\n\t\t  const struct nfs4_ol_stateid *ost)\n{\n\tstruct nfs4_ol_stateid *lst;\n\n\tlockdep_assert_held(&ost->st_stid.sc_client->cl_lock);\n\n\t/* If ost is not hashed, ost->st_locks will not be valid */\n\tif (!nfs4_ol_stateid_unhashed(ost))\n\t\tlist_for_each_entry(lst, &ost->st_locks, st_locks) {\n\t\t\tif (lst->st_stateowner == &lo->lo_owner) {\n\t\t\t\trefcount_inc(&lst->st_stid.sc_count);\n\t\t\t\treturn lst;\n\t\t\t}\n\t\t}\n\treturn NULL;\n}\n\nstatic struct nfs4_ol_stateid *\ninit_lock_stateid(struct nfs4_ol_stateid *stp, struct nfs4_lockowner *lo,\n\t\t  struct nfs4_file *fp, struct inode *inode,\n\t\t  struct nfs4_ol_stateid *open_stp)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\tstruct nfs4_ol_stateid *retstp;\n\n\tmutex_init(&stp->st_mutex);\n\tmutex_lock_nested(&stp->st_mutex, OPEN_STATEID_MUTEX);\nretry:\n\tspin_lock(&clp->cl_lock);\n\tif (nfs4_ol_stateid_unhashed(open_stp))\n\t\tgoto out_close;\n\tretstp = find_lock_stateid(lo, open_stp);\n\tif (retstp)\n\t\tgoto out_found;\n\trefcount_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_LOCK_STID;\n\tstp->st_stateowner = nfs4_get_stateowner(&lo->lo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = open_stp->st_deny_bmap;\n\tstp->st_openstp = open_stp;\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&stp->st_locks, &open_stp->st_locks);\n\tlist_add(&stp->st_perstateowner, &lo->lo_owner.so_stateids);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&clp->cl_lock);\n\treturn stp;\nout_found:\n\tspin_unlock(&clp->cl_lock);\n\tif (nfsd4_lock_ol_stateid(retstp) != nfs_ok) {\n\t\tnfs4_put_stid(&retstp->st_stid);\n\t\tgoto retry;\n\t}\n\t/* To keep mutex tracking happy */\n\tmutex_unlock(&stp->st_mutex);\n\treturn retstp;\nout_close:\n\tspin_unlock(&clp->cl_lock);\n\tmutex_unlock(&stp->st_mutex);\n\treturn NULL;\n}\n\nstatic struct nfs4_ol_stateid *\nfind_or_create_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fi,\n\t\t\t    struct inode *inode, struct nfs4_ol_stateid *ost,\n\t\t\t    bool *new)\n{\n\tstruct nfs4_stid *ns = NULL;\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\t*new = false;\n\tspin_lock(&clp->cl_lock);\n\tlst = find_lock_stateid(lo, ost);\n\tspin_unlock(&clp->cl_lock);\n\tif (lst != NULL) {\n\t\tif (nfsd4_lock_ol_stateid(lst) == nfs_ok)\n\t\t\tgoto out;\n\t\tnfs4_put_stid(&lst->st_stid);\n\t}\n\tns = nfs4_alloc_stid(clp, stateid_slab, nfs4_free_lock_stateid);\n\tif (ns == NULL)\n\t\treturn NULL;\n\n\tlst = init_lock_stateid(openlockstateid(ns), lo, fi, inode, ost);\n\tif (lst == openlockstateid(ns))\n\t\t*new = true;\n\telse\n\t\tnfs4_put_stid(ns);\nout:\n\treturn lst;\n}\n\nstatic int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0) || ((length != NFS4_MAX_UINT64) &&\n\t\t(length > ~offset)));\n}\n\nstatic void get_lock_access(struct nfs4_ol_stateid *lock_stp, u32 access)\n{\n\tstruct nfs4_file *fp = lock_stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (test_access(access, lock_stp))\n\t\treturn;\n\t__nfs4_file_get_access(fp, access);\n\tset_access(access, lock_stp);\n}\n\nstatic __be32\nlookup_or_create_lock_state(struct nfsd4_compound_state *cstate,\n\t\t\t    struct nfs4_ol_stateid *ost,\n\t\t\t    struct nfsd4_lock *lock,\n\t\t\t    struct nfs4_ol_stateid **plst, bool *new)\n{\n\t__be32 status;\n\tstruct nfs4_file *fi = ost->st_stid.sc_file;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *cl = oo->oo_owner.so_client;\n\tstruct inode *inode = d_inode(cstate->current_fh.fh_dentry);\n\tstruct nfs4_lockowner *lo;\n\tstruct nfs4_ol_stateid *lst;\n\tunsigned int strhashval;\n\n\tlo = find_lockowner_str(cl, &lock->lk_new_owner);\n\tif (!lo) {\n\t\tstrhashval = ownerstr_hashval(&lock->lk_new_owner);\n\t\tlo = alloc_init_lock_stateowner(strhashval, cl, ost, lock);\n\t\tif (lo == NULL)\n\t\t\treturn nfserr_jukebox;\n\t} else {\n\t\t/* with an existing lockowner, seqids must be the same */\n\t\tstatus = nfserr_bad_seqid;\n\t\tif (!cstate->minorversion &&\n\t\t    lock->lk_new_lock_seqid != lo->lo_owner.so_seqid)\n\t\t\tgoto out;\n\t}\n\n\tlst = find_or_create_lock_stateid(lo, fi, inode, ost, new);\n\tif (lst == NULL) {\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tstatus = nfs_ok;\n\t*plst = lst;\nout:\n\tnfs4_put_stateowner(&lo->lo_owner);\n\treturn status;\n}\n\n/*\n *  LOCK operation \n */\n__be32\nnfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_lock *lock = &u->lock;\n\tstruct nfs4_openowner *open_sop = NULL;\n\tstruct nfs4_lockowner *lock_sop = NULL;\n\tstruct nfs4_ol_stateid *lock_stp = NULL;\n\tstruct nfs4_ol_stateid *open_stp = NULL;\n\tstruct nfs4_file *fp;\n\tstruct nfsd_file *nf = NULL;\n\tstruct nfsd4_blocked_lock *nbl = NULL;\n\tstruct file_lock *file_lock = NULL;\n\tstruct file_lock *conflock = NULL;\n\t__be32 status = 0;\n\tint lkflg;\n\tint err;\n\tbool new = false;\n\tunsigned char fl_type;\n\tunsigned int fl_flags = FL_POSIX;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_lock: start=%Ld length=%Ld\\n\",\n\t\t(long long) lock->lk_offset,\n\t\t(long long) lock->lk_length);\n\n\tif (check_lock_length(lock->lk_offset, lock->lk_length))\n\t\t return nfserr_inval;\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh,\n\t\t\t\tS_IFREG, NFSD_MAY_LOCK))) {\n\t\tdprintk(\"NFSD: nfsd4_lock: permission denied!\\n\");\n\t\treturn status;\n\t}\n\n\tif (lock->lk_is_new) {\n\t\tif (nfsd4_has_session(cstate))\n\t\t\t/* See rfc 5661 18.10.3: given clientid is ignored: */\n\t\t\tmemcpy(&lock->lk_new_clientid,\n\t\t\t\t&cstate->session->se_client->cl_clientid,\n\t\t\t\tsizeof(clientid_t));\n\n\t\tstatus = nfserr_stale_clientid;\n\t\tif (STALE_CLIENTID(&lock->lk_new_clientid, nn))\n\t\t\tgoto out;\n\n\t\t/* validate and update open stateid and open seqid */\n\t\tstatus = nfs4_preprocess_confirmed_seqid_op(cstate,\n\t\t\t\t        lock->lk_new_open_seqid,\n\t\t                        &lock->lk_new_open_stateid,\n\t\t\t\t\t&open_stp, nn);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tmutex_unlock(&open_stp->st_mutex);\n\t\topen_sop = openowner(open_stp->st_stateowner);\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (!same_clid(&open_sop->oo_owner.so_client->cl_clientid,\n\t\t\t\t\t\t&lock->lk_new_clientid))\n\t\t\tgoto out;\n\t\tstatus = lookup_or_create_lock_state(cstate, open_stp, lock,\n\t\t\t\t\t\t\t&lock_stp, &new);\n\t} else {\n\t\tstatus = nfs4_preprocess_seqid_op(cstate,\n\t\t\t\t       lock->lk_old_lock_seqid,\n\t\t\t\t       &lock->lk_old_lock_stateid,\n\t\t\t\t       NFS4_LOCK_STID, &lock_stp, nn);\n\t}\n\tif (status)\n\t\tgoto out;\n\tlock_sop = lockowner(lock_stp->st_stateowner);\n\n\tlkflg = setlkflg(lock->lk_type);\n\tstatus = nfs4_check_openmode(lock_stp, lkflg);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = nfserr_grace;\n\tif (locks_in_grace(net) && !lock->lk_reclaim)\n\t\tgoto out;\n\tstatus = nfserr_no_grace;\n\tif (!locks_in_grace(net) && lock->lk_reclaim)\n\t\tgoto out;\n\n\tfp = lock_stp->st_stid.sc_file;\n\tswitch (lock->lk_type) {\n\t\tcase NFS4_READW_LT:\n\t\t\tif (nfsd4_has_session(cstate))\n\t\t\t\tfl_flags |= FL_SLEEP;\n\t\t\tfallthrough;\n\t\tcase NFS4_READ_LT:\n\t\t\tspin_lock(&fp->fi_lock);\n\t\t\tnf = find_readable_file_locked(fp);\n\t\t\tif (nf)\n\t\t\t\tget_lock_access(lock_stp, NFS4_SHARE_ACCESS_READ);\n\t\t\tspin_unlock(&fp->fi_lock);\n\t\t\tfl_type = F_RDLCK;\n\t\t\tbreak;\n\t\tcase NFS4_WRITEW_LT:\n\t\t\tif (nfsd4_has_session(cstate))\n\t\t\t\tfl_flags |= FL_SLEEP;\n\t\t\tfallthrough;\n\t\tcase NFS4_WRITE_LT:\n\t\t\tspin_lock(&fp->fi_lock);\n\t\t\tnf = find_writeable_file_locked(fp);\n\t\t\tif (nf)\n\t\t\t\tget_lock_access(lock_stp, NFS4_SHARE_ACCESS_WRITE);\n\t\t\tspin_unlock(&fp->fi_lock);\n\t\t\tfl_type = F_WRLCK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = nfserr_inval;\n\t\tgoto out;\n\t}\n\n\tif (!nf) {\n\t\tstatus = nfserr_openmode;\n\t\tgoto out;\n\t}\n\n\tnbl = find_or_allocate_block(lock_sop, &fp->fi_fhandle, nn);\n\tif (!nbl) {\n\t\tdprintk(\"NFSD: %s: unable to allocate block!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tfile_lock = &nbl->nbl_lock;\n\tfile_lock->fl_type = fl_type;\n\tfile_lock->fl_owner = (fl_owner_t)lockowner(nfs4_get_stateowner(&lock_sop->lo_owner));\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_file = nf->nf_file;\n\tfile_lock->fl_flags = fl_flags;\n\tfile_lock->fl_lmops = &nfsd_posix_mng_ops;\n\tfile_lock->fl_start = lock->lk_offset;\n\tfile_lock->fl_end = last_byte_offset(lock->lk_offset, lock->lk_length);\n\tnfs4_transform_lock_offset(file_lock);\n\n\tconflock = locks_alloc_lock();\n\tif (!conflock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tif (fl_flags & FL_SLEEP) {\n\t\tnbl->nbl_time = ktime_get_boottime_seconds();\n\t\tspin_lock(&nn->blocked_locks_lock);\n\t\tlist_add_tail(&nbl->nbl_list, &lock_sop->lo_blocked);\n\t\tlist_add_tail(&nbl->nbl_lru, &nn->blocked_locks_lru);\n\t\tspin_unlock(&nn->blocked_locks_lock);\n\t}\n\n\terr = vfs_lock_file(nf->nf_file, F_SETLK, file_lock, conflock);\n\tswitch (err) {\n\tcase 0: /* success! */\n\t\tnfs4_inc_and_copy_stateid(&lock->lk_resp_stateid, &lock_stp->st_stid);\n\t\tstatus = 0;\n\t\tif (lock->lk_reclaim)\n\t\t\tnn->somebody_reclaimed = true;\n\t\tbreak;\n\tcase FILE_LOCK_DEFERRED:\n\t\tnbl = NULL;\n\t\tfallthrough;\n\tcase -EAGAIN:\t\t/* conflock holds conflicting lock */\n\t\tstatus = nfserr_denied;\n\t\tdprintk(\"NFSD: nfsd4_lock: conflicting lock found!\\n\");\n\t\tnfs4_set_lock_denied(conflock, &lock->lk_denied);\n\t\tbreak;\n\tcase -EDEADLK:\n\t\tstatus = nfserr_deadlock;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"NFSD: nfsd4_lock: vfs_lock_file() failed! status %d\\n\",err);\n\t\tstatus = nfserrno(err);\n\t\tbreak;\n\t}\nout:\n\tif (nbl) {\n\t\t/* dequeue it if we queued it before */\n\t\tif (fl_flags & FL_SLEEP) {\n\t\t\tspin_lock(&nn->blocked_locks_lock);\n\t\t\tlist_del_init(&nbl->nbl_list);\n\t\t\tlist_del_init(&nbl->nbl_lru);\n\t\t\tspin_unlock(&nn->blocked_locks_lock);\n\t\t}\n\t\tfree_blocked_lock(nbl);\n\t}\n\tif (nf)\n\t\tnfsd_file_put(nf);\n\tif (lock_stp) {\n\t\t/* Bump seqid manually if the 4.0 replay owner is openowner */\n\t\tif (cstate->replay_owner &&\n\t\t    cstate->replay_owner != &lock_sop->lo_owner &&\n\t\t    seqid_mutating_err(ntohl(status)))\n\t\t\tlock_sop->lo_owner.so_seqid++;\n\n\t\t/*\n\t\t * If this is a new, never-before-used stateid, and we are\n\t\t * returning an error, then just go ahead and release it.\n\t\t */\n\t\tif (status && new)\n\t\t\trelease_lock_stateid(lock_stp);\n\n\t\tmutex_unlock(&lock_stp->st_mutex);\n\n\t\tnfs4_put_stid(&lock_stp->st_stid);\n\t}\n\tif (open_stp)\n\t\tnfs4_put_stid(&open_stp->st_stid);\n\tnfsd4_bump_seqid(cstate, status);\n\tif (conflock)\n\t\tlocks_free_lock(conflock);\n\treturn status;\n}\n\n/*\n * The NFSv4 spec allows a client to do a LOCKT without holding an OPEN,\n * so we do a temporary open here just to get an open file to pass to\n * vfs_test_lock.  (Arguably perhaps test_lock should be done with an\n * inode operation.)\n */\nstatic __be32 nfsd_test_lock(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file_lock *lock)\n{\n\tstruct nfsd_file *nf;\n\t__be32 err = nfsd_file_acquire(rqstp, fhp, NFSD_MAY_READ, &nf);\n\tif (!err) {\n\t\terr = nfserrno(vfs_test_lock(nf->nf_file, lock));\n\t\tnfsd_file_put(nf);\n\t}\n\treturn err;\n}\n\n/*\n * LOCKT operation\n */\n__be32\nnfsd4_lockt(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_lockt *lockt = &u->lockt;\n\tstruct file_lock *file_lock = NULL;\n\tstruct nfs4_lockowner *lo = NULL;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (locks_in_grace(SVC_NET(rqstp)))\n\t\treturn nfserr_grace;\n\n\tif (check_lock_length(lockt->lt_offset, lockt->lt_length))\n\t\t return nfserr_inval;\n\n\tif (!nfsd4_has_session(cstate)) {\n\t\tstatus = lookup_clientid(&lockt->lt_clientid, cstate, nn,\n\t\t\t\t\t false);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0)))\n\t\tgoto out;\n\n\tfile_lock = locks_alloc_lock();\n\tif (!file_lock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tswitch (lockt->lt_type) {\n\t\tcase NFS4_READ_LT:\n\t\tcase NFS4_READW_LT:\n\t\t\tfile_lock->fl_type = F_RDLCK;\n\t\t\tbreak;\n\t\tcase NFS4_WRITE_LT:\n\t\tcase NFS4_WRITEW_LT:\n\t\t\tfile_lock->fl_type = F_WRLCK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"NFSD: nfs4_lockt: bad lock type!\\n\");\n\t\t\tstatus = nfserr_inval;\n\t\t\tgoto out;\n\t}\n\n\tlo = find_lockowner_str(cstate->clp, &lockt->lt_owner);\n\tif (lo)\n\t\tfile_lock->fl_owner = (fl_owner_t)lo;\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_flags = FL_POSIX;\n\n\tfile_lock->fl_start = lockt->lt_offset;\n\tfile_lock->fl_end = last_byte_offset(lockt->lt_offset, lockt->lt_length);\n\n\tnfs4_transform_lock_offset(file_lock);\n\n\tstatus = nfsd_test_lock(rqstp, &cstate->current_fh, file_lock);\n\tif (status)\n\t\tgoto out;\n\n\tif (file_lock->fl_type != F_UNLCK) {\n\t\tstatus = nfserr_denied;\n\t\tnfs4_set_lock_denied(file_lock, &lockt->lt_denied);\n\t}\nout:\n\tif (lo)\n\t\tnfs4_put_stateowner(&lo->lo_owner);\n\tif (file_lock)\n\t\tlocks_free_lock(file_lock);\n\treturn status;\n}\n\n__be32\nnfsd4_locku(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_locku *locku = &u->locku;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfsd_file *nf = NULL;\n\tstruct file_lock *file_lock = NULL;\n\t__be32 status;\n\tint err;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_locku: start=%Ld length=%Ld\\n\",\n\t\t(long long) locku->lu_offset,\n\t\t(long long) locku->lu_length);\n\n\tif (check_lock_length(locku->lu_offset, locku->lu_length))\n\t\t return nfserr_inval;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, locku->lu_seqid,\n\t\t\t\t\t&locku->lu_stateid, NFS4_LOCK_STID,\n\t\t\t\t\t&stp, nn);\n\tif (status)\n\t\tgoto out;\n\tnf = find_any_file(stp->st_stid.sc_file);\n\tif (!nf) {\n\t\tstatus = nfserr_lock_range;\n\t\tgoto put_stateid;\n\t}\n\tfile_lock = locks_alloc_lock();\n\tif (!file_lock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto put_file;\n\t}\n\n\tfile_lock->fl_type = F_UNLCK;\n\tfile_lock->fl_owner = (fl_owner_t)lockowner(nfs4_get_stateowner(stp->st_stateowner));\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_file = nf->nf_file;\n\tfile_lock->fl_flags = FL_POSIX;\n\tfile_lock->fl_lmops = &nfsd_posix_mng_ops;\n\tfile_lock->fl_start = locku->lu_offset;\n\n\tfile_lock->fl_end = last_byte_offset(locku->lu_offset,\n\t\t\t\t\t\tlocku->lu_length);\n\tnfs4_transform_lock_offset(file_lock);\n\n\terr = vfs_lock_file(nf->nf_file, F_SETLK, file_lock, NULL);\n\tif (err) {\n\t\tdprintk(\"NFSD: nfs4_locku: vfs_lock_file failed!\\n\");\n\t\tgoto out_nfserr;\n\t}\n\tnfs4_inc_and_copy_stateid(&locku->lu_stateid, &stp->st_stid);\nput_file:\n\tnfsd_file_put(nf);\nput_stateid:\n\tmutex_unlock(&stp->st_mutex);\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\tif (file_lock)\n\t\tlocks_free_lock(file_lock);\n\treturn status;\n\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto put_file;\n}\n\n/*\n * returns\n * \ttrue:  locks held by lockowner\n * \tfalse: no locks held by lockowner\n */\nstatic bool\ncheck_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner)\n{\n\tstruct file_lock *fl;\n\tint status = false;\n\tstruct nfsd_file *nf = find_any_file(fp);\n\tstruct inode *inode;\n\tstruct file_lock_context *flctx;\n\n\tif (!nf) {\n\t\t/* Any valid lock stateid should have some sort of access */\n\t\tWARN_ON_ONCE(1);\n\t\treturn status;\n\t}\n\n\tinode = locks_inode(nf->nf_file);\n\tflctx = inode->i_flctx;\n\n\tif (flctx && !list_empty_careful(&flctx->flc_posix)) {\n\t\tspin_lock(&flctx->flc_lock);\n\t\tlist_for_each_entry(fl, &flctx->flc_posix, fl_list) {\n\t\t\tif (fl->fl_owner == (fl_owner_t)lowner) {\n\t\t\t\tstatus = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&flctx->flc_lock);\n\t}\n\tnfsd_file_put(nf);\n\treturn status;\n}\n\n__be32\nnfsd4_release_lockowner(struct svc_rqst *rqstp,\n\t\t\tstruct nfsd4_compound_state *cstate,\n\t\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_release_lockowner *rlockowner = &u->release_lockowner;\n\tclientid_t *clid = &rlockowner->rl_clientid;\n\tstruct nfs4_stateowner *sop;\n\tstruct nfs4_lockowner *lo = NULL;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct xdr_netobj *owner = &rlockowner->rl_owner;\n\tunsigned int hashval = ownerstr_hashval(owner);\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct nfs4_client *clp;\n\tLIST_HEAD (reaplist);\n\n\tdprintk(\"nfsd4_release_lockowner clientid: (%08x/%08x):\\n\",\n\t\tclid->cl_boot, clid->cl_id);\n\n\tstatus = lookup_clientid(clid, cstate, nn, false);\n\tif (status)\n\t\treturn status;\n\n\tclp = cstate->clp;\n\t/* Find the matching lock stateowner */\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(sop, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\n\t\tif (sop->so_is_open_owner || !same_owner_str(sop, owner))\n\t\t\tcontinue;\n\n\t\t/* see if there are still any locks associated with it */\n\t\tlo = lockowner(sop);\n\t\tlist_for_each_entry(stp, &sop->so_stateids, st_perstateowner) {\n\t\t\tif (check_for_locks(stp->st_stid.sc_file, lo)) {\n\t\t\t\tstatus = nfserr_locks_held;\n\t\t\t\tspin_unlock(&clp->cl_lock);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\n\t\tnfs4_get_stateowner(sop);\n\t\tbreak;\n\t}\n\tif (!lo) {\n\t\tspin_unlock(&clp->cl_lock);\n\t\treturn status;\n\t}\n\n\tunhash_lockowner_locked(lo);\n\twhile (!list_empty(&lo->lo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&lo->lo_owner.so_stateids,\n\t\t\t\t       struct nfs4_ol_stateid,\n\t\t\t\t       st_perstateowner);\n\t\tWARN_ON(!unhash_lock_stateid(stp));\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\tremove_blocked_locks(lo);\n\tnfs4_put_stateowner(&lo->lo_owner);\n\n\treturn status;\n}\n\nstatic inline struct nfs4_client_reclaim *\nalloc_reclaim(void)\n{\n\treturn kmalloc(sizeof(struct nfs4_client_reclaim), GFP_KERNEL);\n}\n\nbool\nnfs4_has_reclaimed_state(struct xdr_netobj name, struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp;\n\n\tcrp = nfsd4_find_reclaim_client(name, nn);\n\treturn (crp && crp->cr_clp);\n}\n\n/*\n * failure => all reset bets are off, nfserr_no_grace...\n *\n * The caller is responsible for freeing name.data if NULL is returned (it\n * will be freed in nfs4_remove_reclaim_record in the normal case).\n */\nstruct nfs4_client_reclaim *\nnfs4_client_to_reclaim(struct xdr_netobj name, struct xdr_netobj princhash,\n\t\tstruct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp;\n\n\ttrace_nfsd_clid_reclaim(nn, name.len, name.data);\n\tcrp = alloc_reclaim();\n\tif (crp) {\n\t\tstrhashval = clientstr_hashval(name);\n\t\tINIT_LIST_HEAD(&crp->cr_strhash);\n\t\tlist_add(&crp->cr_strhash, &nn->reclaim_str_hashtbl[strhashval]);\n\t\tcrp->cr_name.data = name.data;\n\t\tcrp->cr_name.len = name.len;\n\t\tcrp->cr_princhash.data = princhash.data;\n\t\tcrp->cr_princhash.len = princhash.len;\n\t\tcrp->cr_clp = NULL;\n\t\tnn->reclaim_str_hashtbl_size++;\n\t}\n\treturn crp;\n}\n\nvoid\nnfs4_remove_reclaim_record(struct nfs4_client_reclaim *crp, struct nfsd_net *nn)\n{\n\tlist_del(&crp->cr_strhash);\n\tkfree(crp->cr_name.data);\n\tkfree(crp->cr_princhash.data);\n\tkfree(crp);\n\tnn->reclaim_str_hashtbl_size--;\n}\n\nvoid\nnfs4_release_reclaim(struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp = NULL;\n\tint i;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->reclaim_str_hashtbl[i])) {\n\t\t\tcrp = list_entry(nn->reclaim_str_hashtbl[i].next,\n\t\t\t                struct nfs4_client_reclaim, cr_strhash);\n\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\n\tWARN_ON_ONCE(nn->reclaim_str_hashtbl_size);\n}\n\n/*\n * called from OPEN, CLAIM_PREVIOUS with a new clientid. */\nstruct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(struct xdr_netobj name, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\ttrace_nfsd_clid_find(nn, name.len, name.data);\n\n\tstrhashval = clientstr_hashval(name);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (compare_blob(&crp->cr_name, &name) == 0) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/*\n* Called from OPEN. Look for clientid in reclaim list.\n*/\n__be32\nnfs4_check_open_reclaim(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\t__be32 status;\n\n\t/* find clientid in conf_id_hashtbl */\n\tstatus = lookup_clientid(clid, cstate, nn, false);\n\tif (status)\n\t\treturn nfserr_reclaim_bad;\n\n\tif (test_bit(NFSD4_CLIENT_RECLAIM_COMPLETE, &cstate->clp->cl_flags))\n\t\treturn nfserr_no_grace;\n\n\tif (nfsd4_client_record_check(cstate->clp))\n\t\treturn nfserr_reclaim_bad;\n\n\treturn nfs_ok;\n}\n\n/*\n * Since the lifetime of a delegation isn't limited to that of an open, a\n * client may quite reasonably hang on to a delegation as long as it has\n * the inode cached.  This becomes an obvious problem the first time a\n * client's inode cache approaches the size of the server's total memory.\n *\n * For now we avoid this problem by imposing a hard limit on the number\n * of delegations, which varies according to the server's memory size.\n */\nstatic void\nset_max_delegations(void)\n{\n\t/*\n\t * Allow at most 4 delegations per megabyte of RAM.  Quick\n\t * estimates suggest that in the worst case (where every delegation\n\t * is for a different inode), a delegation could take about 1.5K,\n\t * giving a worst case usage of about 6% of memory.\n\t */\n\tmax_delegations = nr_free_buffer_pages() >> (20 - 2 - PAGE_SHIFT);\n}\n\nstatic int nfs4_state_create_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->conf_id_hashtbl = kmalloc_array(CLIENT_HASH_SIZE,\n\t\t\t\t\t    sizeof(struct list_head),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!nn->conf_id_hashtbl)\n\t\tgoto err;\n\tnn->unconf_id_hashtbl = kmalloc_array(CLIENT_HASH_SIZE,\n\t\t\t\t\t      sizeof(struct list_head),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!nn->unconf_id_hashtbl)\n\t\tgoto err_unconf_id;\n\tnn->sessionid_hashtbl = kmalloc_array(SESSION_HASH_SIZE,\n\t\t\t\t\t      sizeof(struct list_head),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!nn->sessionid_hashtbl)\n\t\tgoto err_sessionid;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\tINIT_LIST_HEAD(&nn->conf_id_hashtbl[i]);\n\t\tINIT_LIST_HEAD(&nn->unconf_id_hashtbl[i]);\n\t}\n\tfor (i = 0; i < SESSION_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->sessionid_hashtbl[i]);\n\tnn->conf_name_tree = RB_ROOT;\n\tnn->unconf_name_tree = RB_ROOT;\n\tnn->boot_time = ktime_get_real_seconds();\n\tnn->grace_ended = false;\n\tnn->nfsd4_manager.block_opens = true;\n\tINIT_LIST_HEAD(&nn->nfsd4_manager.list);\n\tINIT_LIST_HEAD(&nn->client_lru);\n\tINIT_LIST_HEAD(&nn->close_lru);\n\tINIT_LIST_HEAD(&nn->del_recall_lru);\n\tspin_lock_init(&nn->client_lock);\n\tspin_lock_init(&nn->s2s_cp_lock);\n\tidr_init(&nn->s2s_cp_stateids);\n\n\tspin_lock_init(&nn->blocked_locks_lock);\n\tINIT_LIST_HEAD(&nn->blocked_locks_lru);\n\n\tINIT_DELAYED_WORK(&nn->laundromat_work, laundromat_main);\n\tget_net(net);\n\n\treturn 0;\n\nerr_sessionid:\n\tkfree(nn->unconf_id_hashtbl);\nerr_unconf_id:\n\tkfree(nn->conf_id_hashtbl);\nerr:\n\treturn -ENOMEM;\n}\n\nstatic void\nnfs4_state_destroy_net(struct net *net)\n{\n\tint i;\n\tstruct nfs4_client *clp = NULL;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->conf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->conf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tWARN_ON(!list_empty(&nn->blocked_locks_lru));\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->unconf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->unconf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tkfree(nn->sessionid_hashtbl);\n\tkfree(nn->unconf_id_hashtbl);\n\tkfree(nn->conf_id_hashtbl);\n\tput_net(net);\n}\n\nint\nnfs4_state_start_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint ret;\n\n\tret = get_nfsdfs(net);\n\tif (ret)\n\t\treturn ret;\n\tret = nfs4_state_create_net(net);\n\tif (ret) {\n\t\tmntput(nn->nfsd_mnt);\n\t\treturn ret;\n\t}\n\tlocks_start_grace(net, &nn->nfsd4_manager);\n\tnfsd4_client_tracking_init(net);\n\tif (nn->track_reclaim_completes && nn->reclaim_str_hashtbl_size == 0)\n\t\tgoto skip_grace;\n\tprintk(KERN_INFO \"NFSD: starting %lld-second grace period (net %x)\\n\",\n\t       nn->nfsd4_grace, net->ns.inum);\n\ttrace_nfsd_grace_start(nn);\n\tqueue_delayed_work(laundry_wq, &nn->laundromat_work, nn->nfsd4_grace * HZ);\n\treturn 0;\n\nskip_grace:\n\tprintk(KERN_INFO \"NFSD: no clients to reclaim, skipping NFSv4 grace period (net %x)\\n\",\n\t\t\tnet->ns.inum);\n\tqueue_delayed_work(laundry_wq, &nn->laundromat_work, nn->nfsd4_lease * HZ);\n\tnfsd4_end_grace(nn);\n\treturn 0;\n}\n\n/* initialization to perform when the nfsd service is started: */\n\nint\nnfs4_state_start(void)\n{\n\tint ret;\n\n\tlaundry_wq = alloc_workqueue(\"%s\", WQ_UNBOUND, 0, \"nfsd4\");\n\tif (laundry_wq == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tret = nfsd4_create_callback_queue();\n\tif (ret)\n\t\tgoto out_free_laundry;\n\n\tset_max_delegations();\n\treturn 0;\n\nout_free_laundry:\n\tdestroy_workqueue(laundry_wq);\nout:\n\treturn ret;\n}\n\nvoid\nnfs4_state_shutdown_net(struct net *net)\n{\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct list_head *pos, *next, reaplist;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tcancel_delayed_work_sync(&nn->laundromat_work);\n\tlocks_end_grace(&nn->nfsd4_manager);\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\tlist_for_each_safe(pos, next, &nn->del_recall_lru) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\tlist_for_each_safe(pos, next, &reaplist) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tdestroy_unhashed_deleg(dp);\n\t}\n\n\tnfsd4_client_tracking_exit(net);\n\tnfs4_state_destroy_net(net);\n\tmntput(nn->nfsd_mnt);\n}\n\nvoid\nnfs4_state_shutdown(void)\n{\n\tdestroy_workqueue(laundry_wq);\n\tnfsd4_destroy_callback_queue();\n}\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_CSTATE_FLAG(cstate, CURRENT_STATE_ID_FLAG) &&\n\t    CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}\n\nstatic void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_CSTATE_FLAG(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}\n\nvoid\nclear_current_stateid(struct nfsd4_compound_state *cstate)\n{\n\tCLEAR_CSTATE_FLAG(cstate, CURRENT_STATE_ID_FLAG);\n}\n\n/*\n * functions to set current state id\n */\nvoid\nnfsd4_set_opendowngradestateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tput_stateid(cstate, &u->open_downgrade.od_stateid);\n}\n\nvoid\nnfsd4_set_openstateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tput_stateid(cstate, &u->open.op_stateid);\n}\n\nvoid\nnfsd4_set_closestateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tput_stateid(cstate, &u->close.cl_stateid);\n}\n\nvoid\nnfsd4_set_lockstateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tput_stateid(cstate, &u->lock.lk_resp_stateid);\n}\n\n/*\n * functions to consume current state id\n */\n\nvoid\nnfsd4_get_opendowngradestateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tget_stateid(cstate, &u->open_downgrade.od_stateid);\n}\n\nvoid\nnfsd4_get_delegreturnstateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tget_stateid(cstate, &u->delegreturn.dr_stateid);\n}\n\nvoid\nnfsd4_get_freestateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tget_stateid(cstate, &u->free_stateid.fr_stateid);\n}\n\nvoid\nnfsd4_get_setattrstateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tget_stateid(cstate, &u->setattr.sa_stateid);\n}\n\nvoid\nnfsd4_get_closestateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tget_stateid(cstate, &u->close.cl_stateid);\n}\n\nvoid\nnfsd4_get_lockustateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tget_stateid(cstate, &u->locku.lu_stateid);\n}\n\nvoid\nnfsd4_get_readstateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tget_stateid(cstate, &u->read.rd_stateid);\n}\n\nvoid\nnfsd4_get_writestateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tget_stateid(cstate, &u->write.wr_stateid);\n}\n"}}, "reports": [{"events": [{"location": {"col": 6, "file": 0, "line": 1318}, "message": "atomic_dec_and_test variation before object free at line 1322."}], "macros": [], "notes": [], "path": "/src/fs/nfsd/nfs4state.c", "reportHash": "5ec4a6396c8c27c35233e0e02b7c9e59", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 0, "line": 222}, "message": "atomic_dec_and_test variation before object free at line 223."}], "macros": [], "notes": [], "path": "/src/fs/nfsd/nfs4state.c", "reportHash": "fc1b0790a16c7c18abecd6c151b5dd92", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
