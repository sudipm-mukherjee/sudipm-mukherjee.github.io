<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c", "content": "/* Copyright 2008-2013 Broadcom Corporation\n * Copyright (c) 2014 QLogic Corporation\n * All rights reserved\n *\n * Unless you and QLogic execute a separate written software license\n * agreement governing use of this software, this software is licensed to you\n * under the terms of the GNU General Public License version 2, available\n * at http://www.gnu.org/licenses/gpl-2.0.html (the \"GPL\").\n *\n * Notwithstanding the above, under no circumstances may you combine this\n * software in any way with any other Qlogic software provided under a\n * license other than the GPL, without Qlogic's express prior written\n * consent.\n *\n * Written by Yaniv Rosner\n *\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/mutex.h>\n\n#include \"bnx2x.h\"\n#include \"bnx2x_cmn.h\"\n\ntypedef int (*read_sfp_module_eeprom_func_p)(struct bnx2x_phy *phy,\n\t\t\t\t\t     struct link_params *params,\n\t\t\t\t\t     u8 dev_addr, u16 addr, u8 byte_cnt,\n\t\t\t\t\t     u8 *o_buf, u8);\n/********************************************************/\n#define MDIO_ACCESS_TIMEOUT\t\t1000\n#define WC_LANE_MAX\t\t\t4\n#define I2C_SWITCH_WIDTH\t\t2\n#define I2C_BSC0\t\t\t0\n#define I2C_BSC1\t\t\t1\n#define I2C_WA_RETRY_CNT\t\t3\n#define I2C_WA_PWR_ITER\t\t\t(I2C_WA_RETRY_CNT - 1)\n#define MCPR_IMC_COMMAND_READ_OP\t1\n#define MCPR_IMC_COMMAND_WRITE_OP\t2\n\n/* LED Blink rate that will achieve ~15.9Hz */\n#define LED_BLINK_RATE_VAL_E3\t\t354\n#define LED_BLINK_RATE_VAL_E1X_E2\t480\n/***********************************************************/\n/*\t\t\tShortcut definitions\t\t   */\n/***********************************************************/\n\n#define NIG_LATCH_BC_ENABLE_MI_INT 0\n\n#define NIG_STATUS_EMAC0_MI_INT \\\n\t\tNIG_STATUS_INTERRUPT_PORT0_REG_STATUS_EMAC0_MISC_MI_INT\n#define NIG_STATUS_XGXS0_LINK10G \\\n\t\tNIG_STATUS_INTERRUPT_PORT0_REG_STATUS_XGXS0_LINK10G\n#define NIG_STATUS_XGXS0_LINK_STATUS \\\n\t\tNIG_STATUS_INTERRUPT_PORT0_REG_STATUS_XGXS0_LINK_STATUS\n#define NIG_STATUS_XGXS0_LINK_STATUS_SIZE \\\n\t\tNIG_STATUS_INTERRUPT_PORT0_REG_STATUS_XGXS0_LINK_STATUS_SIZE\n#define NIG_STATUS_SERDES0_LINK_STATUS \\\n\t\tNIG_STATUS_INTERRUPT_PORT0_REG_STATUS_SERDES0_LINK_STATUS\n#define NIG_MASK_MI_INT \\\n\t\tNIG_MASK_INTERRUPT_PORT0_REG_MASK_EMAC0_MISC_MI_INT\n#define NIG_MASK_XGXS0_LINK10G \\\n\t\tNIG_MASK_INTERRUPT_PORT0_REG_MASK_XGXS0_LINK10G\n#define NIG_MASK_XGXS0_LINK_STATUS \\\n\t\tNIG_MASK_INTERRUPT_PORT0_REG_MASK_XGXS0_LINK_STATUS\n#define NIG_MASK_SERDES0_LINK_STATUS \\\n\t\tNIG_MASK_INTERRUPT_PORT0_REG_MASK_SERDES0_LINK_STATUS\n\n#define MDIO_AN_CL73_OR_37_COMPLETE \\\n\t\t(MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_AUTONEG_COMPLETE | \\\n\t\t MDIO_GP_STATUS_TOP_AN_STATUS1_CL37_AUTONEG_COMPLETE)\n\n#define XGXS_RESET_BITS \\\n\t(MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_RSTB_HW |   \\\n\t MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_IDDQ |      \\\n\t MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_PWRDWN |    \\\n\t MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_PWRDWN_SD | \\\n\t MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_TXD_FIFO_RSTB)\n\n#define SERDES_RESET_BITS \\\n\t(MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_RSTB_HW | \\\n\t MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_IDDQ |    \\\n\t MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_PWRDWN |  \\\n\t MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_PWRDWN_SD)\n\n#define AUTONEG_CL37\t\tSHARED_HW_CFG_AN_ENABLE_CL37\n#define AUTONEG_CL73\t\tSHARED_HW_CFG_AN_ENABLE_CL73\n#define AUTONEG_BAM\t\tSHARED_HW_CFG_AN_ENABLE_BAM\n#define AUTONEG_PARALLEL \\\n\t\t\t\tSHARED_HW_CFG_AN_ENABLE_PARALLEL_DETECTION\n#define AUTONEG_SGMII_FIBER_AUTODET \\\n\t\t\t\tSHARED_HW_CFG_AN_EN_SGMII_FIBER_AUTO_DETECT\n#define AUTONEG_REMOTE_PHY\tSHARED_HW_CFG_AN_ENABLE_REMOTE_PHY\n\n#define GP_STATUS_PAUSE_RSOLUTION_TXSIDE \\\n\t\t\tMDIO_GP_STATUS_TOP_AN_STATUS1_PAUSE_RSOLUTION_TXSIDE\n#define GP_STATUS_PAUSE_RSOLUTION_RXSIDE \\\n\t\t\tMDIO_GP_STATUS_TOP_AN_STATUS1_PAUSE_RSOLUTION_RXSIDE\n#define GP_STATUS_SPEED_MASK \\\n\t\t\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_MASK\n#define GP_STATUS_10M\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10M\n#define GP_STATUS_100M\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_100M\n#define GP_STATUS_1G\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_1G\n#define GP_STATUS_2_5G\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_2_5G\n#define GP_STATUS_5G\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_5G\n#define GP_STATUS_6G\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_6G\n#define GP_STATUS_10G_HIG \\\n\t\t\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_HIG\n#define GP_STATUS_10G_CX4 \\\n\t\t\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_CX4\n#define GP_STATUS_1G_KX MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_1G_KX\n#define GP_STATUS_10G_KX4 \\\n\t\t\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_KX4\n#define\tGP_STATUS_10G_KR MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_KR\n#define\tGP_STATUS_10G_XFI   MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_XFI\n#define\tGP_STATUS_20G_DXGXS MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_20G_DXGXS\n#define\tGP_STATUS_10G_SFI   MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_SFI\n#define\tGP_STATUS_20G_KR2 MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_20G_KR2\n#define LINK_10THD\t\tLINK_STATUS_SPEED_AND_DUPLEX_10THD\n#define LINK_10TFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_10TFD\n#define LINK_100TXHD\t\tLINK_STATUS_SPEED_AND_DUPLEX_100TXHD\n#define LINK_100T4\t\tLINK_STATUS_SPEED_AND_DUPLEX_100T4\n#define LINK_100TXFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_100TXFD\n#define LINK_1000THD\t\tLINK_STATUS_SPEED_AND_DUPLEX_1000THD\n#define LINK_1000TFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_1000TFD\n#define LINK_1000XFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_1000XFD\n#define LINK_2500THD\t\tLINK_STATUS_SPEED_AND_DUPLEX_2500THD\n#define LINK_2500TFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_2500TFD\n#define LINK_2500XFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_2500XFD\n#define LINK_10GTFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_10GTFD\n#define LINK_10GXFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_10GXFD\n#define LINK_20GTFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_20GTFD\n#define LINK_20GXFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_20GXFD\n\n#define LINK_UPDATE_MASK \\\n\t\t\t(LINK_STATUS_SPEED_AND_DUPLEX_MASK | \\\n\t\t\t LINK_STATUS_LINK_UP | \\\n\t\t\t LINK_STATUS_PHYSICAL_LINK_FLAG | \\\n\t\t\t LINK_STATUS_AUTO_NEGOTIATE_COMPLETE | \\\n\t\t\t LINK_STATUS_RX_FLOW_CONTROL_FLAG_MASK | \\\n\t\t\t LINK_STATUS_TX_FLOW_CONTROL_FLAG_MASK | \\\n\t\t\t LINK_STATUS_PARALLEL_DETECTION_FLAG_MASK | \\\n\t\t\t LINK_STATUS_LINK_PARTNER_SYMMETRIC_PAUSE | \\\n\t\t\t LINK_STATUS_LINK_PARTNER_ASYMMETRIC_PAUSE)\n\n#define SFP_EEPROM_CON_TYPE_ADDR\t\t0x2\n\t#define SFP_EEPROM_CON_TYPE_VAL_UNKNOWN\t0x0\n\t#define SFP_EEPROM_CON_TYPE_VAL_LC\t0x7\n\t#define SFP_EEPROM_CON_TYPE_VAL_COPPER\t0x21\n\t#define SFP_EEPROM_CON_TYPE_VAL_RJ45\t0x22\n\n\n#define SFP_EEPROM_10G_COMP_CODE_ADDR\t\t0x3\n\t#define SFP_EEPROM_10G_COMP_CODE_SR_MASK\t(1<<4)\n\t#define SFP_EEPROM_10G_COMP_CODE_LR_MASK\t(1<<5)\n\t#define SFP_EEPROM_10G_COMP_CODE_LRM_MASK\t(1<<6)\n\n#define SFP_EEPROM_1G_COMP_CODE_ADDR\t\t0x6\n\t#define SFP_EEPROM_1G_COMP_CODE_SX\t(1<<0)\n\t#define SFP_EEPROM_1G_COMP_CODE_LX\t(1<<1)\n\t#define SFP_EEPROM_1G_COMP_CODE_CX\t(1<<2)\n\t#define SFP_EEPROM_1G_COMP_CODE_BASE_T\t(1<<3)\n\n#define SFP_EEPROM_FC_TX_TECH_ADDR\t\t0x8\n\t#define SFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_PASSIVE 0x4\n\t#define SFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_ACTIVE  0x8\n\n#define SFP_EEPROM_OPTIONS_ADDR\t\t\t0x40\n\t#define SFP_EEPROM_OPTIONS_LINEAR_RX_OUT_MASK 0x1\n#define SFP_EEPROM_OPTIONS_SIZE\t\t\t2\n\n#define EDC_MODE_LINEAR\t\t\t\t0x0022\n#define EDC_MODE_LIMITING\t\t\t\t0x0044\n#define EDC_MODE_PASSIVE_DAC\t\t\t0x0055\n#define EDC_MODE_ACTIVE_DAC\t\t\t0x0066\n\n/* ETS defines*/\n#define DCBX_INVALID_COS\t\t\t\t\t(0xFF)\n\n#define ETS_BW_LIMIT_CREDIT_UPPER_BOUND\t\t(0x5000)\n#define ETS_BW_LIMIT_CREDIT_WEIGHT\t\t(0x5000)\n#define ETS_E3B0_NIG_MIN_W_VAL_UP_TO_10GBPS\t\t(1360)\n#define ETS_E3B0_NIG_MIN_W_VAL_20GBPS\t\t\t(2720)\n#define ETS_E3B0_PBF_MIN_W_VAL\t\t\t\t(10000)\n\n#define MAX_PACKET_SIZE\t\t\t\t\t(9700)\n#define MAX_KR_LINK_RETRY\t\t\t\t4\n#define DEFAULT_TX_DRV_BRDCT\t\t2\n#define DEFAULT_TX_DRV_IFIR\t\t0\n#define DEFAULT_TX_DRV_POST2\t\t3\n#define DEFAULT_TX_DRV_IPRE_DRIVER\t6\n\n/**********************************************************/\n/*                     INTERFACE                          */\n/**********************************************************/\n\n#define CL22_WR_OVER_CL45(_bp, _phy, _bank, _addr, _val) \\\n\tbnx2x_cl45_write(_bp, _phy, \\\n\t\t(_phy)->def_md_devad, \\\n\t\t(_bank + (_addr & 0xf)), \\\n\t\t_val)\n\n#define CL22_RD_OVER_CL45(_bp, _phy, _bank, _addr, _val) \\\n\tbnx2x_cl45_read(_bp, _phy, \\\n\t\t(_phy)->def_md_devad, \\\n\t\t(_bank + (_addr & 0xf)), \\\n\t\t_val)\n\nstatic int bnx2x_check_half_open_conn(struct link_params *params,\n\t\t\t\t      struct link_vars *vars, u8 notify);\nstatic int bnx2x_sfp_module_detection(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params);\n\nstatic u32 bnx2x_bits_en(struct bnx2x *bp, u32 reg, u32 bits)\n{\n\tu32 val = REG_RD(bp, reg);\n\n\tval |= bits;\n\tREG_WR(bp, reg, val);\n\treturn val;\n}\n\nstatic u32 bnx2x_bits_dis(struct bnx2x *bp, u32 reg, u32 bits)\n{\n\tu32 val = REG_RD(bp, reg);\n\n\tval &= ~bits;\n\tREG_WR(bp, reg, val);\n\treturn val;\n}\n\n/*\n * bnx2x_check_lfa - This function checks if link reinitialization is required,\n *                   or link flap can be avoided.\n *\n * @params:\tlink parameters\n * Returns 0 if Link Flap Avoidance conditions are met otherwise, the failed\n *         condition code.\n */\nstatic int bnx2x_check_lfa(struct link_params *params)\n{\n\tu32 link_status, cfg_idx, lfa_mask, cfg_size;\n\tu32 cur_speed_cap_mask, cur_req_fc_auto_adv, additional_config;\n\tu32 saved_val, req_val, eee_status;\n\tstruct bnx2x *bp = params->bp;\n\n\tadditional_config =\n\t\tREG_RD(bp, params->lfa_base +\n\t\t\t   offsetof(struct shmem_lfa, additional_config));\n\n\t/* NOTE: must be first condition checked -\n\t* to verify DCC bit is cleared in any case!\n\t*/\n\tif (additional_config & NO_LFA_DUE_TO_DCC_MASK) {\n\t\tDP(NETIF_MSG_LINK, \"No LFA due to DCC flap after clp exit\\n\");\n\t\tREG_WR(bp, params->lfa_base +\n\t\t\t   offsetof(struct shmem_lfa, additional_config),\n\t\t       additional_config & ~NO_LFA_DUE_TO_DCC_MASK);\n\t\treturn LFA_DCC_LFA_DISABLED;\n\t}\n\n\t/* Verify that link is up */\n\tlink_status = REG_RD(bp, params->shmem_base +\n\t\t\t     offsetof(struct shmem_region,\n\t\t\t\t      port_mb[params->port].link_status));\n\tif (!(link_status & LINK_STATUS_LINK_UP))\n\t\treturn LFA_LINK_DOWN;\n\n\t/* if loaded after BOOT from SAN, don't flap the link in any case and\n\t * rely on link set by preboot driver\n\t */\n\tif (params->feature_config_flags & FEATURE_CONFIG_BOOT_FROM_SAN)\n\t\treturn 0;\n\n\t/* Verify that loopback mode is not set */\n\tif (params->loopback_mode)\n\t\treturn LFA_LOOPBACK_ENABLED;\n\n\t/* Verify that MFW supports LFA */\n\tif (!params->lfa_base)\n\t\treturn LFA_MFW_IS_TOO_OLD;\n\n\tif (params->num_phys == 3) {\n\t\tcfg_size = 2;\n\t\tlfa_mask = 0xffffffff;\n\t} else {\n\t\tcfg_size = 1;\n\t\tlfa_mask = 0xffff;\n\t}\n\n\t/* Compare Duplex */\n\tsaved_val = REG_RD(bp, params->lfa_base +\n\t\t\t   offsetof(struct shmem_lfa, req_duplex));\n\treq_val = params->req_duplex[0] | (params->req_duplex[1] << 16);\n\tif ((saved_val & lfa_mask) != (req_val & lfa_mask)) {\n\t\tDP(NETIF_MSG_LINK, \"Duplex mismatch %x vs. %x\\n\",\n\t\t\t       (saved_val & lfa_mask), (req_val & lfa_mask));\n\t\treturn LFA_DUPLEX_MISMATCH;\n\t}\n\t/* Compare Flow Control */\n\tsaved_val = REG_RD(bp, params->lfa_base +\n\t\t\t   offsetof(struct shmem_lfa, req_flow_ctrl));\n\treq_val = params->req_flow_ctrl[0] | (params->req_flow_ctrl[1] << 16);\n\tif ((saved_val & lfa_mask) != (req_val & lfa_mask)) {\n\t\tDP(NETIF_MSG_LINK, \"Flow control mismatch %x vs. %x\\n\",\n\t\t\t       (saved_val & lfa_mask), (req_val & lfa_mask));\n\t\treturn LFA_FLOW_CTRL_MISMATCH;\n\t}\n\t/* Compare Link Speed */\n\tsaved_val = REG_RD(bp, params->lfa_base +\n\t\t\t   offsetof(struct shmem_lfa, req_line_speed));\n\treq_val = params->req_line_speed[0] | (params->req_line_speed[1] << 16);\n\tif ((saved_val & lfa_mask) != (req_val & lfa_mask)) {\n\t\tDP(NETIF_MSG_LINK, \"Link speed mismatch %x vs. %x\\n\",\n\t\t\t       (saved_val & lfa_mask), (req_val & lfa_mask));\n\t\treturn LFA_LINK_SPEED_MISMATCH;\n\t}\n\n\tfor (cfg_idx = 0; cfg_idx < cfg_size; cfg_idx++) {\n\t\tcur_speed_cap_mask = REG_RD(bp, params->lfa_base +\n\t\t\t\t\t    offsetof(struct shmem_lfa,\n\t\t\t\t\t\t     speed_cap_mask[cfg_idx]));\n\n\t\tif (cur_speed_cap_mask != params->speed_cap_mask[cfg_idx]) {\n\t\t\tDP(NETIF_MSG_LINK, \"Speed Cap mismatch %x vs. %x\\n\",\n\t\t\t\t       cur_speed_cap_mask,\n\t\t\t\t       params->speed_cap_mask[cfg_idx]);\n\t\t\treturn LFA_SPEED_CAP_MISMATCH;\n\t\t}\n\t}\n\n\tcur_req_fc_auto_adv =\n\t\tREG_RD(bp, params->lfa_base +\n\t\t       offsetof(struct shmem_lfa, additional_config)) &\n\t\tREQ_FC_AUTO_ADV_MASK;\n\n\tif ((u16)cur_req_fc_auto_adv != params->req_fc_auto_adv) {\n\t\tDP(NETIF_MSG_LINK, \"Flow Ctrl AN mismatch %x vs. %x\\n\",\n\t\t\t       cur_req_fc_auto_adv, params->req_fc_auto_adv);\n\t\treturn LFA_FLOW_CTRL_MISMATCH;\n\t}\n\n\teee_status = REG_RD(bp, params->shmem2_base +\n\t\t\t    offsetof(struct shmem2_region,\n\t\t\t\t     eee_status[params->port]));\n\n\tif (((eee_status & SHMEM_EEE_LPI_REQUESTED_BIT) ^\n\t     (params->eee_mode & EEE_MODE_ENABLE_LPI)) ||\n\t    ((eee_status & SHMEM_EEE_REQUESTED_BIT) ^\n\t     (params->eee_mode & EEE_MODE_ADV_LPI))) {\n\t\tDP(NETIF_MSG_LINK, \"EEE mismatch %x vs. %x\\n\", params->eee_mode,\n\t\t\t       eee_status);\n\t\treturn LFA_EEE_MISMATCH;\n\t}\n\n\t/* LFA conditions are met */\n\treturn 0;\n}\n/******************************************************************/\n/*\t\t\tEPIO/GPIO section\t\t\t  */\n/******************************************************************/\nstatic void bnx2x_get_epio(struct bnx2x *bp, u32 epio_pin, u32 *en)\n{\n\tu32 epio_mask, gp_oenable;\n\t*en = 0;\n\t/* Sanity check */\n\tif (epio_pin > 31) {\n\t\tDP(NETIF_MSG_LINK, \"Invalid EPIO pin %d to get\\n\", epio_pin);\n\t\treturn;\n\t}\n\n\tepio_mask = 1 << epio_pin;\n\t/* Set this EPIO to output */\n\tgp_oenable = REG_RD(bp, MCP_REG_MCPR_GP_OENABLE);\n\tREG_WR(bp, MCP_REG_MCPR_GP_OENABLE, gp_oenable & ~epio_mask);\n\n\t*en = (REG_RD(bp, MCP_REG_MCPR_GP_INPUTS) & epio_mask) >> epio_pin;\n}\nstatic void bnx2x_set_epio(struct bnx2x *bp, u32 epio_pin, u32 en)\n{\n\tu32 epio_mask, gp_output, gp_oenable;\n\n\t/* Sanity check */\n\tif (epio_pin > 31) {\n\t\tDP(NETIF_MSG_LINK, \"Invalid EPIO pin %d to set\\n\", epio_pin);\n\t\treturn;\n\t}\n\tDP(NETIF_MSG_LINK, \"Setting EPIO pin %d to %d\\n\", epio_pin, en);\n\tepio_mask = 1 << epio_pin;\n\t/* Set this EPIO to output */\n\tgp_output = REG_RD(bp, MCP_REG_MCPR_GP_OUTPUTS);\n\tif (en)\n\t\tgp_output |= epio_mask;\n\telse\n\t\tgp_output &= ~epio_mask;\n\n\tREG_WR(bp, MCP_REG_MCPR_GP_OUTPUTS, gp_output);\n\n\t/* Set the value for this EPIO */\n\tgp_oenable = REG_RD(bp, MCP_REG_MCPR_GP_OENABLE);\n\tREG_WR(bp, MCP_REG_MCPR_GP_OENABLE, gp_oenable | epio_mask);\n}\n\nstatic void bnx2x_set_cfg_pin(struct bnx2x *bp, u32 pin_cfg, u32 val)\n{\n\tif (pin_cfg == PIN_CFG_NA)\n\t\treturn;\n\tif (pin_cfg >= PIN_CFG_EPIO0) {\n\t\tbnx2x_set_epio(bp, pin_cfg - PIN_CFG_EPIO0, val);\n\t} else {\n\t\tu8 gpio_num = (pin_cfg - PIN_CFG_GPIO0_P0) & 0x3;\n\t\tu8 gpio_port = (pin_cfg - PIN_CFG_GPIO0_P0) >> 2;\n\t\tbnx2x_set_gpio(bp, gpio_num, (u8)val, gpio_port);\n\t}\n}\n\nstatic u32 bnx2x_get_cfg_pin(struct bnx2x *bp, u32 pin_cfg, u32 *val)\n{\n\tif (pin_cfg == PIN_CFG_NA)\n\t\treturn -EINVAL;\n\tif (pin_cfg >= PIN_CFG_EPIO0) {\n\t\tbnx2x_get_epio(bp, pin_cfg - PIN_CFG_EPIO0, val);\n\t} else {\n\t\tu8 gpio_num = (pin_cfg - PIN_CFG_GPIO0_P0) & 0x3;\n\t\tu8 gpio_port = (pin_cfg - PIN_CFG_GPIO0_P0) >> 2;\n\t\t*val = bnx2x_get_gpio(bp, gpio_num, gpio_port);\n\t}\n\treturn 0;\n\n}\n/******************************************************************/\n/*\t\t\t\tETS section\t\t\t  */\n/******************************************************************/\nstatic void bnx2x_ets_e2e3a0_disabled(struct link_params *params)\n{\n\t/* ETS disabled configuration*/\n\tstruct bnx2x *bp = params->bp;\n\n\tDP(NETIF_MSG_LINK, \"ETS E2E3 disabled configuration\\n\");\n\n\t/* mapping between entry  priority to client number (0,1,2 -debug and\n\t * management clients, 3 - COS0 client, 4 - COS client)(HIGHEST)\n\t * 3bits client num.\n\t *   PRI4    |    PRI3    |    PRI2    |    PRI1    |    PRI0\n\t * cos1-100     cos0-011     dbg1-010     dbg0-001     MCP-000\n\t */\n\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT, 0x4688);\n\t/* Bitmap of 5bits length. Each bit specifies whether the entry behaves\n\t * as strict.  Bits 0,1,2 - debug and management entries, 3 -\n\t * COS0 entry, 4 - COS1 entry.\n\t * COS1 | COS0 | DEBUG1 | DEBUG0 | MGMT\n\t * bit4   bit3\t  bit2   bit1\t  bit0\n\t * MCP and debug are strict\n\t */\n\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT, 0x7);\n\t/* defines which entries (clients) are subjected to WFQ arbitration */\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_SUBJECT2WFQ, 0);\n\t/* For strict priority entries defines the number of consecutive\n\t * slots for the highest priority.\n\t */\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_NUM_STRICT_ARB_SLOTS, 0x100);\n\t/* mapping between the CREDIT_WEIGHT registers and actual client\n\t * numbers\n\t */\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_CREDIT_MAP, 0);\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_0, 0);\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_1, 0);\n\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_0, 0);\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_1, 0);\n\tREG_WR(bp, PBF_REG_HIGH_PRIORITY_COS_NUM, 0);\n\t/* ETS mode disable */\n\tREG_WR(bp, PBF_REG_ETS_ENABLED, 0);\n\t/* If ETS mode is enabled (there is no strict priority) defines a WFQ\n\t * weight for COS0/COS1.\n\t */\n\tREG_WR(bp, PBF_REG_COS0_WEIGHT, 0x2710);\n\tREG_WR(bp, PBF_REG_COS1_WEIGHT, 0x2710);\n\t/* Upper bound that COS0_WEIGHT can reach in the WFQ arbiter */\n\tREG_WR(bp, PBF_REG_COS0_UPPER_BOUND, 0x989680);\n\tREG_WR(bp, PBF_REG_COS1_UPPER_BOUND, 0x989680);\n\t/* Defines the number of consecutive slots for the strict priority */\n\tREG_WR(bp, PBF_REG_NUM_STRICT_ARB_SLOTS, 0);\n}\n/******************************************************************************\n* Description:\n*\tGetting min_w_val will be set according to line speed .\n*.\n******************************************************************************/\nstatic u32 bnx2x_ets_get_min_w_val_nig(const struct link_vars *vars)\n{\n\tu32 min_w_val = 0;\n\t/* Calculate min_w_val.*/\n\tif (vars->link_up) {\n\t\tif (vars->line_speed == SPEED_20000)\n\t\t\tmin_w_val = ETS_E3B0_NIG_MIN_W_VAL_20GBPS;\n\t\telse\n\t\t\tmin_w_val = ETS_E3B0_NIG_MIN_W_VAL_UP_TO_10GBPS;\n\t} else\n\t\tmin_w_val = ETS_E3B0_NIG_MIN_W_VAL_20GBPS;\n\t/* If the link isn't up (static configuration for example ) The\n\t * link will be according to 20GBPS.\n\t */\n\treturn min_w_val;\n}\n/******************************************************************************\n* Description:\n*\tGetting credit upper bound form min_w_val.\n*.\n******************************************************************************/\nstatic u32 bnx2x_ets_get_credit_upper_bound(const u32 min_w_val)\n{\n\tconst u32 credit_upper_bound = (u32)MAXVAL((150 * min_w_val),\n\t\t\t\t\t\tMAX_PACKET_SIZE);\n\treturn credit_upper_bound;\n}\n/******************************************************************************\n* Description:\n*\tSet credit upper bound for NIG.\n*.\n******************************************************************************/\nstatic void bnx2x_ets_e3b0_set_credit_upper_bound_nig(\n\tconst struct link_params *params,\n\tconst u32 min_w_val)\n{\n\tstruct bnx2x *bp = params->bp;\n\tconst u8 port = params->port;\n\tconst u32 credit_upper_bound =\n\t    bnx2x_ets_get_credit_upper_bound(min_w_val);\n\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_0 :\n\t\tNIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_0, credit_upper_bound);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_1 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_1, credit_upper_bound);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_2 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_2, credit_upper_bound);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_3 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_3, credit_upper_bound);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_4 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_4, credit_upper_bound);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_5 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_5, credit_upper_bound);\n\n\tif (!port) {\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_6,\n\t\t\tcredit_upper_bound);\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_7,\n\t\t\tcredit_upper_bound);\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_8,\n\t\t\tcredit_upper_bound);\n\t}\n}\n/******************************************************************************\n* Description:\n*\tWill return the NIG ETS registers to init values.Except\n*\tcredit_upper_bound.\n*\tThat isn't used in this configuration (No WFQ is enabled) and will be\n*\tconfigured according to spec\n*.\n******************************************************************************/\nstatic void bnx2x_ets_e3b0_nig_disabled(const struct link_params *params,\n\t\t\t\t\tconst struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tconst u8 port = params->port;\n\tconst u32 min_w_val = bnx2x_ets_get_min_w_val_nig(vars);\n\t/* Mapping between entry  priority to client number (0,1,2 -debug and\n\t * management clients, 3 - COS0 client, 4 - COS1, ... 8 -\n\t * COS5)(HIGHEST) 4bits client num.TODO_ETS - Should be done by\n\t * reset value or init tool\n\t */\n\tif (port) {\n\t\tREG_WR(bp, NIG_REG_P1_TX_ARB_PRIORITY_CLIENT2_LSB, 0x543210);\n\t\tREG_WR(bp, NIG_REG_P1_TX_ARB_PRIORITY_CLIENT2_MSB, 0x0);\n\t} else {\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT2_LSB, 0x76543210);\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT2_MSB, 0x8);\n\t}\n\t/* For strict priority entries defines the number of consecutive\n\t * slots for the highest priority.\n\t */\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_NUM_STRICT_ARB_SLOTS :\n\t\t   NIG_REG_P0_TX_ARB_NUM_STRICT_ARB_SLOTS, 0x100);\n\t/* Mapping between the CREDIT_WEIGHT registers and actual client\n\t * numbers\n\t */\n\tif (port) {\n\t\t/*Port 1 has 6 COS*/\n\t\tREG_WR(bp, NIG_REG_P1_TX_ARB_CLIENT_CREDIT_MAP2_LSB, 0x210543);\n\t\tREG_WR(bp, NIG_REG_P1_TX_ARB_CLIENT_CREDIT_MAP2_MSB, 0x0);\n\t} else {\n\t\t/*Port 0 has 9 COS*/\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_CREDIT_MAP2_LSB,\n\t\t       0x43210876);\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_CREDIT_MAP2_MSB, 0x5);\n\t}\n\n\t/* Bitmap of 5bits length. Each bit specifies whether the entry behaves\n\t * as strict.  Bits 0,1,2 - debug and management entries, 3 -\n\t * COS0 entry, 4 - COS1 entry.\n\t * COS1 | COS0 | DEBUG1 | DEBUG0 | MGMT\n\t * bit4   bit3\t  bit2   bit1\t  bit0\n\t * MCP and debug are strict\n\t */\n\tif (port)\n\t\tREG_WR(bp, NIG_REG_P1_TX_ARB_CLIENT_IS_STRICT, 0x3f);\n\telse\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT, 0x1ff);\n\t/* defines which entries (clients) are subjected to WFQ arbitration */\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CLIENT_IS_SUBJECT2WFQ :\n\t\t   NIG_REG_P0_TX_ARB_CLIENT_IS_SUBJECT2WFQ, 0);\n\n\t/* Please notice the register address are note continuous and a\n\t * for here is note appropriate.In 2 port mode port0 only COS0-5\n\t * can be used. DEBUG1,DEBUG1,MGMT are never used for WFQ* In 4\n\t * port mode port1 only COS0-2 can be used. DEBUG1,DEBUG1,MGMT\n\t * are never used for WFQ\n\t */\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_0 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_0, 0x0);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_1 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_1, 0x0);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_2 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_2, 0x0);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_3 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_3, 0x0);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_4 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_4, 0x0);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_5 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_5, 0x0);\n\tif (!port) {\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_6, 0x0);\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_7, 0x0);\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_8, 0x0);\n\t}\n\n\tbnx2x_ets_e3b0_set_credit_upper_bound_nig(params, min_w_val);\n}\n/******************************************************************************\n* Description:\n*\tSet credit upper bound for PBF.\n*.\n******************************************************************************/\nstatic void bnx2x_ets_e3b0_set_credit_upper_bound_pbf(\n\tconst struct link_params *params,\n\tconst u32 min_w_val)\n{\n\tstruct bnx2x *bp = params->bp;\n\tconst u32 credit_upper_bound =\n\t    bnx2x_ets_get_credit_upper_bound(min_w_val);\n\tconst u8 port = params->port;\n\tu32 base_upper_bound = 0;\n\tu8 max_cos = 0;\n\tu8 i = 0;\n\t/* In 2 port mode port0 has COS0-5 that can be used for WFQ.In 4\n\t * port mode port1 has COS0-2 that can be used for WFQ.\n\t */\n\tif (!port) {\n\t\tbase_upper_bound = PBF_REG_COS0_UPPER_BOUND_P0;\n\t\tmax_cos = DCBX_E3B0_MAX_NUM_COS_PORT0;\n\t} else {\n\t\tbase_upper_bound = PBF_REG_COS0_UPPER_BOUND_P1;\n\t\tmax_cos = DCBX_E3B0_MAX_NUM_COS_PORT1;\n\t}\n\n\tfor (i = 0; i < max_cos; i++)\n\t\tREG_WR(bp, base_upper_bound + (i << 2), credit_upper_bound);\n}\n\n/******************************************************************************\n* Description:\n*\tWill return the PBF ETS registers to init values.Except\n*\tcredit_upper_bound.\n*\tThat isn't used in this configuration (No WFQ is enabled) and will be\n*\tconfigured according to spec\n*.\n******************************************************************************/\nstatic void bnx2x_ets_e3b0_pbf_disabled(const struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tconst u8 port = params->port;\n\tconst u32 min_w_val_pbf = ETS_E3B0_PBF_MIN_W_VAL;\n\tu8 i = 0;\n\tu32 base_weight = 0;\n\tu8 max_cos = 0;\n\n\t/* Mapping between entry  priority to client number 0 - COS0\n\t * client, 2 - COS1, ... 5 - COS5)(HIGHEST) 4bits client num.\n\t * TODO_ETS - Should be done by reset value or init tool\n\t */\n\tif (port)\n\t\t/*  0x688 (|011|0 10|00 1|000) */\n\t\tREG_WR(bp, PBF_REG_ETS_ARB_PRIORITY_CLIENT_P1 , 0x688);\n\telse\n\t\t/*  (10 1|100 |011|0 10|00 1|000) */\n\t\tREG_WR(bp, PBF_REG_ETS_ARB_PRIORITY_CLIENT_P0 , 0x2C688);\n\n\t/* TODO_ETS - Should be done by reset value or init tool */\n\tif (port)\n\t\t/* 0x688 (|011|0 10|00 1|000)*/\n\t\tREG_WR(bp, PBF_REG_ETS_ARB_CLIENT_CREDIT_MAP_P1, 0x688);\n\telse\n\t/* 0x2C688 (10 1|100 |011|0 10|00 1|000) */\n\tREG_WR(bp, PBF_REG_ETS_ARB_CLIENT_CREDIT_MAP_P0, 0x2C688);\n\n\tREG_WR(bp, (port) ? PBF_REG_ETS_ARB_NUM_STRICT_ARB_SLOTS_P1 :\n\t\t   PBF_REG_ETS_ARB_NUM_STRICT_ARB_SLOTS_P0 , 0x100);\n\n\n\tREG_WR(bp, (port) ? PBF_REG_ETS_ARB_CLIENT_IS_STRICT_P1 :\n\t\t   PBF_REG_ETS_ARB_CLIENT_IS_STRICT_P0 , 0);\n\n\tREG_WR(bp, (port) ? PBF_REG_ETS_ARB_CLIENT_IS_SUBJECT2WFQ_P1 :\n\t\t   PBF_REG_ETS_ARB_CLIENT_IS_SUBJECT2WFQ_P0 , 0);\n\t/* In 2 port mode port0 has COS0-5 that can be used for WFQ.\n\t * In 4 port mode port1 has COS0-2 that can be used for WFQ.\n\t */\n\tif (!port) {\n\t\tbase_weight = PBF_REG_COS0_WEIGHT_P0;\n\t\tmax_cos = DCBX_E3B0_MAX_NUM_COS_PORT0;\n\t} else {\n\t\tbase_weight = PBF_REG_COS0_WEIGHT_P1;\n\t\tmax_cos = DCBX_E3B0_MAX_NUM_COS_PORT1;\n\t}\n\n\tfor (i = 0; i < max_cos; i++)\n\t\tREG_WR(bp, base_weight + (0x4 * i), 0);\n\n\tbnx2x_ets_e3b0_set_credit_upper_bound_pbf(params, min_w_val_pbf);\n}\n/******************************************************************************\n* Description:\n*\tE3B0 disable will return basically the values to init values.\n*.\n******************************************************************************/\nstatic int bnx2x_ets_e3b0_disabled(const struct link_params *params,\n\t\t\t\t   const struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tif (!CHIP_IS_E3B0(bp)) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"bnx2x_ets_e3b0_disabled the chip isn't E3B0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbnx2x_ets_e3b0_nig_disabled(params, vars);\n\n\tbnx2x_ets_e3b0_pbf_disabled(params);\n\n\treturn 0;\n}\n\n/******************************************************************************\n* Description:\n*\tDisable will return basically the values to init values.\n*\n******************************************************************************/\nint bnx2x_ets_disabled(struct link_params *params,\n\t\t      struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tint bnx2x_status = 0;\n\n\tif ((CHIP_IS_E2(bp)) || (CHIP_IS_E3A0(bp)))\n\t\tbnx2x_ets_e2e3a0_disabled(params);\n\telse if (CHIP_IS_E3B0(bp))\n\t\tbnx2x_status = bnx2x_ets_e3b0_disabled(params, vars);\n\telse {\n\t\tDP(NETIF_MSG_LINK, \"bnx2x_ets_disabled - chip not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn bnx2x_status;\n}\n\n/******************************************************************************\n* Description\n*\tSet the COS mappimg to SP and BW until this point all the COS are not\n*\tset as SP or BW.\n******************************************************************************/\nstatic int bnx2x_ets_e3b0_cli_map(const struct link_params *params,\n\t\t\t\t  const struct bnx2x_ets_params *ets_params,\n\t\t\t\t  const u8 cos_sp_bitmap,\n\t\t\t\t  const u8 cos_bw_bitmap)\n{\n\tstruct bnx2x *bp = params->bp;\n\tconst u8 port = params->port;\n\tconst u8 nig_cli_sp_bitmap = 0x7 | (cos_sp_bitmap << 3);\n\tconst u8 pbf_cli_sp_bitmap = cos_sp_bitmap;\n\tconst u8 nig_cli_subject2wfq_bitmap = cos_bw_bitmap << 3;\n\tconst u8 pbf_cli_subject2wfq_bitmap = cos_bw_bitmap;\n\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CLIENT_IS_STRICT :\n\t       NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT, nig_cli_sp_bitmap);\n\n\tREG_WR(bp, (port) ? PBF_REG_ETS_ARB_CLIENT_IS_STRICT_P1 :\n\t       PBF_REG_ETS_ARB_CLIENT_IS_STRICT_P0 , pbf_cli_sp_bitmap);\n\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CLIENT_IS_SUBJECT2WFQ :\n\t       NIG_REG_P0_TX_ARB_CLIENT_IS_SUBJECT2WFQ,\n\t       nig_cli_subject2wfq_bitmap);\n\n\tREG_WR(bp, (port) ? PBF_REG_ETS_ARB_CLIENT_IS_SUBJECT2WFQ_P1 :\n\t       PBF_REG_ETS_ARB_CLIENT_IS_SUBJECT2WFQ_P0,\n\t       pbf_cli_subject2wfq_bitmap);\n\n\treturn 0;\n}\n\n/******************************************************************************\n* Description:\n*\tThis function is needed because NIG ARB_CREDIT_WEIGHT_X are\n*\tnot continues and ARB_CREDIT_WEIGHT_0 + offset is suitable.\n******************************************************************************/\nstatic int bnx2x_ets_e3b0_set_cos_bw(struct bnx2x *bp,\n\t\t\t\t     const u8 cos_entry,\n\t\t\t\t     const u32 min_w_val_nig,\n\t\t\t\t     const u32 min_w_val_pbf,\n\t\t\t\t     const u16 total_bw,\n\t\t\t\t     const u8 bw,\n\t\t\t\t     const u8 port)\n{\n\tu32 nig_reg_adress_crd_weight = 0;\n\tu32 pbf_reg_adress_crd_weight = 0;\n\t/* Calculate and set BW for this COS - use 1 instead of 0 for BW */\n\tconst u32 cos_bw_nig = ((bw ? bw : 1) * min_w_val_nig) / total_bw;\n\tconst u32 cos_bw_pbf = ((bw ? bw : 1) * min_w_val_pbf) / total_bw;\n\n\tswitch (cos_entry) {\n\tcase 0:\n\t\tnig_reg_adress_crd_weight =\n\t\t\t(port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_0 :\n\t\t\tNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_0;\n\t\tpbf_reg_adress_crd_weight = (port) ?\n\t\t    PBF_REG_COS0_WEIGHT_P1 : PBF_REG_COS0_WEIGHT_P0;\n\t\tbreak;\n\tcase 1:\n\t\tnig_reg_adress_crd_weight = (port) ?\n\t\t\tNIG_REG_P1_TX_ARB_CREDIT_WEIGHT_1 :\n\t\t\tNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_1;\n\t\tpbf_reg_adress_crd_weight = (port) ?\n\t\t\tPBF_REG_COS1_WEIGHT_P1 : PBF_REG_COS1_WEIGHT_P0;\n\t\tbreak;\n\tcase 2:\n\t\tnig_reg_adress_crd_weight = (port) ?\n\t\t\tNIG_REG_P1_TX_ARB_CREDIT_WEIGHT_2 :\n\t\t\tNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_2;\n\n\t\tpbf_reg_adress_crd_weight = (port) ?\n\t\t\tPBF_REG_COS2_WEIGHT_P1 : PBF_REG_COS2_WEIGHT_P0;\n\t\tbreak;\n\tcase 3:\n\t\tif (port)\n\t\t\treturn -EINVAL;\n\t\tnig_reg_adress_crd_weight = NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_3;\n\t\tpbf_reg_adress_crd_weight = PBF_REG_COS3_WEIGHT_P0;\n\t\tbreak;\n\tcase 4:\n\t\tif (port)\n\t\t\treturn -EINVAL;\n\t\tnig_reg_adress_crd_weight = NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_4;\n\t\tpbf_reg_adress_crd_weight = PBF_REG_COS4_WEIGHT_P0;\n\t\tbreak;\n\tcase 5:\n\t\tif (port)\n\t\t\treturn -EINVAL;\n\t\tnig_reg_adress_crd_weight = NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_5;\n\t\tpbf_reg_adress_crd_weight = PBF_REG_COS5_WEIGHT_P0;\n\t\tbreak;\n\t}\n\n\tREG_WR(bp, nig_reg_adress_crd_weight, cos_bw_nig);\n\n\tREG_WR(bp, pbf_reg_adress_crd_weight, cos_bw_pbf);\n\n\treturn 0;\n}\n/******************************************************************************\n* Description:\n*\tCalculate the total BW.A value of 0 isn't legal.\n*\n******************************************************************************/\nstatic int bnx2x_ets_e3b0_get_total_bw(\n\tconst struct link_params *params,\n\tstruct bnx2x_ets_params *ets_params,\n\tu16 *total_bw)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 cos_idx = 0;\n\tu8 is_bw_cos_exist = 0;\n\n\t*total_bw = 0 ;\n\t/* Calculate total BW requested */\n\tfor (cos_idx = 0; cos_idx < ets_params->num_of_cos; cos_idx++) {\n\t\tif (ets_params->cos[cos_idx].state == bnx2x_cos_state_bw) {\n\t\t\tis_bw_cos_exist = 1;\n\t\t\tif (!ets_params->cos[cos_idx].params.bw_params.bw) {\n\t\t\t\tDP(NETIF_MSG_LINK, \"bnx2x_ets_E3B0_config BW\"\n\t\t\t\t\t\t   \"was set to 0\\n\");\n\t\t\t\t/* This is to prevent a state when ramrods\n\t\t\t\t * can't be sent\n\t\t\t\t */\n\t\t\t\tets_params->cos[cos_idx].params.bw_params.bw\n\t\t\t\t\t = 1;\n\t\t\t}\n\t\t\t*total_bw +=\n\t\t\t\tets_params->cos[cos_idx].params.bw_params.bw;\n\t\t}\n\t}\n\n\t/* Check total BW is valid */\n\tif ((is_bw_cos_exist == 1) && (*total_bw != 100)) {\n\t\tif (*total_bw == 0) {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"bnx2x_ets_E3B0_config total BW shouldn't be 0\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"bnx2x_ets_E3B0_config total BW should be 100\\n\");\n\t\t/* We can handle a case whre the BW isn't 100 this can happen\n\t\t * if the TC are joined.\n\t\t */\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\n* Description:\n*\tInvalidate all the sp_pri_to_cos.\n*\n******************************************************************************/\nstatic void bnx2x_ets_e3b0_sp_pri_to_cos_init(u8 *sp_pri_to_cos)\n{\n\tu8 pri = 0;\n\tfor (pri = 0; pri < DCBX_MAX_NUM_COS; pri++)\n\t\tsp_pri_to_cos[pri] = DCBX_INVALID_COS;\n}\n/******************************************************************************\n* Description:\n*\tCalculate and set the SP (ARB_PRIORITY_CLIENT) NIG and PBF registers\n*\taccording to sp_pri_to_cos.\n*\n******************************************************************************/\nstatic int bnx2x_ets_e3b0_sp_pri_to_cos_set(const struct link_params *params,\n\t\t\t\t\t    u8 *sp_pri_to_cos, const u8 pri,\n\t\t\t\t\t    const u8 cos_entry)\n{\n\tstruct bnx2x *bp = params->bp;\n\tconst u8 port = params->port;\n\tconst u8 max_num_of_cos = (port) ? DCBX_E3B0_MAX_NUM_COS_PORT1 :\n\t\tDCBX_E3B0_MAX_NUM_COS_PORT0;\n\n\tif (pri >= max_num_of_cos) {\n\t\tDP(NETIF_MSG_LINK, \"bnx2x_ets_e3b0_sp_pri_to_cos_set invalid \"\n\t\t   \"parameter Illegal strict priority\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sp_pri_to_cos[pri] != DCBX_INVALID_COS) {\n\t\tDP(NETIF_MSG_LINK, \"bnx2x_ets_e3b0_sp_pri_to_cos_set invalid \"\n\t\t\t\t   \"parameter There can't be two COS's with \"\n\t\t\t\t   \"the same strict pri\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsp_pri_to_cos[pri] = cos_entry;\n\treturn 0;\n\n}\n\n/******************************************************************************\n* Description:\n*\tReturns the correct value according to COS and priority in\n*\tthe sp_pri_cli register.\n*\n******************************************************************************/\nstatic u64 bnx2x_e3b0_sp_get_pri_cli_reg(const u8 cos, const u8 cos_offset,\n\t\t\t\t\t const u8 pri_set,\n\t\t\t\t\t const u8 pri_offset,\n\t\t\t\t\t const u8 entry_size)\n{\n\tu64 pri_cli_nig = 0;\n\tpri_cli_nig = ((u64)(cos + cos_offset)) << (entry_size *\n\t\t\t\t\t\t    (pri_set + pri_offset));\n\n\treturn pri_cli_nig;\n}\n/******************************************************************************\n* Description:\n*\tReturns the correct value according to COS and priority in the\n*\tsp_pri_cli register for NIG.\n*\n******************************************************************************/\nstatic u64 bnx2x_e3b0_sp_get_pri_cli_reg_nig(const u8 cos, const u8 pri_set)\n{\n\t/* MCP Dbg0 and dbg1 are always with higher strict pri*/\n\tconst u8 nig_cos_offset = 3;\n\tconst u8 nig_pri_offset = 3;\n\n\treturn bnx2x_e3b0_sp_get_pri_cli_reg(cos, nig_cos_offset, pri_set,\n\t\tnig_pri_offset, 4);\n\n}\n/******************************************************************************\n* Description:\n*\tReturns the correct value according to COS and priority in the\n*\tsp_pri_cli register for PBF.\n*\n******************************************************************************/\nstatic u64 bnx2x_e3b0_sp_get_pri_cli_reg_pbf(const u8 cos, const u8 pri_set)\n{\n\tconst u8 pbf_cos_offset = 0;\n\tconst u8 pbf_pri_offset = 0;\n\n\treturn bnx2x_e3b0_sp_get_pri_cli_reg(cos, pbf_cos_offset, pri_set,\n\t\tpbf_pri_offset, 3);\n\n}\n\n/******************************************************************************\n* Description:\n*\tCalculate and set the SP (ARB_PRIORITY_CLIENT) NIG and PBF registers\n*\taccording to sp_pri_to_cos.(which COS has higher priority)\n*\n******************************************************************************/\nstatic int bnx2x_ets_e3b0_sp_set_pri_cli_reg(const struct link_params *params,\n\t\t\t\t\t     u8 *sp_pri_to_cos)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 i = 0;\n\tconst u8 port = params->port;\n\t/* MCP Dbg0 and dbg1 are always with higher strict pri*/\n\tu64 pri_cli_nig = 0x210;\n\tu32 pri_cli_pbf = 0x0;\n\tu8 pri_set = 0;\n\tu8 pri_bitmask = 0;\n\tconst u8 max_num_of_cos = (port) ? DCBX_E3B0_MAX_NUM_COS_PORT1 :\n\t\tDCBX_E3B0_MAX_NUM_COS_PORT0;\n\n\tu8 cos_bit_to_set = (1 << max_num_of_cos) - 1;\n\n\t/* Set all the strict priority first */\n\tfor (i = 0; i < max_num_of_cos; i++) {\n\t\tif (sp_pri_to_cos[i] != DCBX_INVALID_COS) {\n\t\t\tif (sp_pri_to_cos[i] >= DCBX_MAX_NUM_COS) {\n\t\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t\t   \"bnx2x_ets_e3b0_sp_set_pri_cli_reg \"\n\t\t\t\t\t   \"invalid cos entry\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tpri_cli_nig |= bnx2x_e3b0_sp_get_pri_cli_reg_nig(\n\t\t\t    sp_pri_to_cos[i], pri_set);\n\n\t\t\tpri_cli_pbf |= bnx2x_e3b0_sp_get_pri_cli_reg_pbf(\n\t\t\t    sp_pri_to_cos[i], pri_set);\n\t\t\tpri_bitmask = 1 << sp_pri_to_cos[i];\n\t\t\t/* COS is used remove it from bitmap.*/\n\t\t\tif (!(pri_bitmask & cos_bit_to_set)) {\n\t\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t\t\"bnx2x_ets_e3b0_sp_set_pri_cli_reg \"\n\t\t\t\t\t\"invalid There can't be two COS's with\"\n\t\t\t\t\t\" the same strict pri\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcos_bit_to_set &= ~pri_bitmask;\n\t\t\tpri_set++;\n\t\t}\n\t}\n\n\t/* Set all the Non strict priority i= COS*/\n\tfor (i = 0; i < max_num_of_cos; i++) {\n\t\tpri_bitmask = 1 << i;\n\t\t/* Check if COS was already used for SP */\n\t\tif (pri_bitmask & cos_bit_to_set) {\n\t\t\t/* COS wasn't used for SP */\n\t\t\tpri_cli_nig |= bnx2x_e3b0_sp_get_pri_cli_reg_nig(\n\t\t\t    i, pri_set);\n\n\t\t\tpri_cli_pbf |= bnx2x_e3b0_sp_get_pri_cli_reg_pbf(\n\t\t\t    i, pri_set);\n\t\t\t/* COS is used remove it from bitmap.*/\n\t\t\tcos_bit_to_set &= ~pri_bitmask;\n\t\t\tpri_set++;\n\t\t}\n\t}\n\n\tif (pri_set != max_num_of_cos) {\n\t\tDP(NETIF_MSG_LINK, \"bnx2x_ets_e3b0_sp_set_pri_cli_reg not all \"\n\t\t\t\t   \"entries were set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (port) {\n\t\t/* Only 6 usable clients*/\n\t\tREG_WR(bp, NIG_REG_P1_TX_ARB_PRIORITY_CLIENT2_LSB,\n\t\t       (u32)pri_cli_nig);\n\n\t\tREG_WR(bp, PBF_REG_ETS_ARB_PRIORITY_CLIENT_P1 , pri_cli_pbf);\n\t} else {\n\t\t/* Only 9 usable clients*/\n\t\tconst u32 pri_cli_nig_lsb = (u32) (pri_cli_nig);\n\t\tconst u32 pri_cli_nig_msb = (u32) ((pri_cli_nig >> 32) & 0xF);\n\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT2_LSB,\n\t\t       pri_cli_nig_lsb);\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT2_MSB,\n\t\t       pri_cli_nig_msb);\n\n\t\tREG_WR(bp, PBF_REG_ETS_ARB_PRIORITY_CLIENT_P0 , pri_cli_pbf);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\n* Description:\n*\tConfigure the COS to ETS according to BW and SP settings.\n******************************************************************************/\nint bnx2x_ets_e3b0_config(const struct link_params *params,\n\t\t\t const struct link_vars *vars,\n\t\t\t struct bnx2x_ets_params *ets_params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tint bnx2x_status = 0;\n\tconst u8 port = params->port;\n\tu16 total_bw = 0;\n\tconst u32 min_w_val_nig = bnx2x_ets_get_min_w_val_nig(vars);\n\tconst u32 min_w_val_pbf = ETS_E3B0_PBF_MIN_W_VAL;\n\tu8 cos_bw_bitmap = 0;\n\tu8 cos_sp_bitmap = 0;\n\tu8 sp_pri_to_cos[DCBX_MAX_NUM_COS] = {0};\n\tconst u8 max_num_of_cos = (port) ? DCBX_E3B0_MAX_NUM_COS_PORT1 :\n\t\tDCBX_E3B0_MAX_NUM_COS_PORT0;\n\tu8 cos_entry = 0;\n\n\tif (!CHIP_IS_E3B0(bp)) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"bnx2x_ets_e3b0_disabled the chip isn't E3B0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((ets_params->num_of_cos > max_num_of_cos)) {\n\t\tDP(NETIF_MSG_LINK, \"bnx2x_ets_E3B0_config the number of COS \"\n\t\t\t\t   \"isn't supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Prepare sp strict priority parameters*/\n\tbnx2x_ets_e3b0_sp_pri_to_cos_init(sp_pri_to_cos);\n\n\t/* Prepare BW parameters*/\n\tbnx2x_status = bnx2x_ets_e3b0_get_total_bw(params, ets_params,\n\t\t\t\t\t\t   &total_bw);\n\tif (bnx2x_status) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"bnx2x_ets_E3B0_config get_total_bw failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Upper bound is set according to current link speed (min_w_val\n\t * should be the same for upper bound and COS credit val).\n\t */\n\tbnx2x_ets_e3b0_set_credit_upper_bound_nig(params, min_w_val_nig);\n\tbnx2x_ets_e3b0_set_credit_upper_bound_pbf(params, min_w_val_pbf);\n\n\n\tfor (cos_entry = 0; cos_entry < ets_params->num_of_cos; cos_entry++) {\n\t\tif (bnx2x_cos_state_bw == ets_params->cos[cos_entry].state) {\n\t\t\tcos_bw_bitmap |= (1 << cos_entry);\n\t\t\t/* The function also sets the BW in HW(not the mappin\n\t\t\t * yet)\n\t\t\t */\n\t\t\tbnx2x_status = bnx2x_ets_e3b0_set_cos_bw(\n\t\t\t\tbp, cos_entry, min_w_val_nig, min_w_val_pbf,\n\t\t\t\ttotal_bw,\n\t\t\t\tets_params->cos[cos_entry].params.bw_params.bw,\n\t\t\t\t port);\n\t\t} else if (bnx2x_cos_state_strict ==\n\t\t\tets_params->cos[cos_entry].state){\n\t\t\tcos_sp_bitmap |= (1 << cos_entry);\n\n\t\t\tbnx2x_status = bnx2x_ets_e3b0_sp_pri_to_cos_set(\n\t\t\t\tparams,\n\t\t\t\tsp_pri_to_cos,\n\t\t\t\tets_params->cos[cos_entry].params.sp_params.pri,\n\t\t\t\tcos_entry);\n\n\t\t} else {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"bnx2x_ets_e3b0_config cos state not valid\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (bnx2x_status) {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"bnx2x_ets_e3b0_config set cos bw failed\\n\");\n\t\t\treturn bnx2x_status;\n\t\t}\n\t}\n\n\t/* Set SP register (which COS has higher priority) */\n\tbnx2x_status = bnx2x_ets_e3b0_sp_set_pri_cli_reg(params,\n\t\t\t\t\t\t\t sp_pri_to_cos);\n\n\tif (bnx2x_status) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"bnx2x_ets_E3B0_config set_pri_cli_reg failed\\n\");\n\t\treturn bnx2x_status;\n\t}\n\n\t/* Set client mapping of BW and strict */\n\tbnx2x_status = bnx2x_ets_e3b0_cli_map(params, ets_params,\n\t\t\t\t\t      cos_sp_bitmap,\n\t\t\t\t\t      cos_bw_bitmap);\n\n\tif (bnx2x_status) {\n\t\tDP(NETIF_MSG_LINK, \"bnx2x_ets_E3B0_config SP failed\\n\");\n\t\treturn bnx2x_status;\n\t}\n\treturn 0;\n}\nstatic void bnx2x_ets_bw_limit_common(const struct link_params *params)\n{\n\t/* ETS disabled configuration */\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"ETS enabled BW limit configuration\\n\");\n\t/* Defines which entries (clients) are subjected to WFQ arbitration\n\t * COS0 0x8\n\t * COS1 0x10\n\t */\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_SUBJECT2WFQ, 0x18);\n\t/* Mapping between the ARB_CREDIT_WEIGHT registers and actual\n\t * client numbers (WEIGHT_0 does not actually have to represent\n\t * client 0)\n\t *    PRI4    |    PRI3    |    PRI2    |    PRI1    |    PRI0\n\t *  cos1-001     cos0-000     dbg1-100     dbg0-011     MCP-010\n\t */\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_CREDIT_MAP, 0x111A);\n\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_0,\n\t       ETS_BW_LIMIT_CREDIT_UPPER_BOUND);\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_1,\n\t       ETS_BW_LIMIT_CREDIT_UPPER_BOUND);\n\n\t/* ETS mode enabled*/\n\tREG_WR(bp, PBF_REG_ETS_ENABLED, 1);\n\n\t/* Defines the number of consecutive slots for the strict priority */\n\tREG_WR(bp, PBF_REG_NUM_STRICT_ARB_SLOTS, 0);\n\t/* Bitmap of 5bits length. Each bit specifies whether the entry behaves\n\t * as strict.  Bits 0,1,2 - debug and management entries, 3 - COS0\n\t * entry, 4 - COS1 entry.\n\t * COS1 | COS0 | DEBUG21 | DEBUG0 | MGMT\n\t * bit4   bit3\t  bit2     bit1\t   bit0\n\t * MCP and debug are strict\n\t */\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT, 0x7);\n\n\t/* Upper bound that COS0_WEIGHT can reach in the WFQ arbiter.*/\n\tREG_WR(bp, PBF_REG_COS0_UPPER_BOUND,\n\t       ETS_BW_LIMIT_CREDIT_UPPER_BOUND);\n\tREG_WR(bp, PBF_REG_COS1_UPPER_BOUND,\n\t       ETS_BW_LIMIT_CREDIT_UPPER_BOUND);\n}\n\nvoid bnx2x_ets_bw_limit(const struct link_params *params, const u32 cos0_bw,\n\t\t\tconst u32 cos1_bw)\n{\n\t/* ETS disabled configuration*/\n\tstruct bnx2x *bp = params->bp;\n\tconst u32 total_bw = cos0_bw + cos1_bw;\n\tu32 cos0_credit_weight = 0;\n\tu32 cos1_credit_weight = 0;\n\n\tDP(NETIF_MSG_LINK, \"ETS enabled BW limit configuration\\n\");\n\n\tif ((!total_bw) ||\n\t    (!cos0_bw) ||\n\t    (!cos1_bw)) {\n\t\tDP(NETIF_MSG_LINK, \"Total BW can't be zero\\n\");\n\t\treturn;\n\t}\n\n\tcos0_credit_weight = (cos0_bw * ETS_BW_LIMIT_CREDIT_WEIGHT)/\n\t\ttotal_bw;\n\tcos1_credit_weight = (cos1_bw * ETS_BW_LIMIT_CREDIT_WEIGHT)/\n\t\ttotal_bw;\n\n\tbnx2x_ets_bw_limit_common(params);\n\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_0, cos0_credit_weight);\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_1, cos1_credit_weight);\n\n\tREG_WR(bp, PBF_REG_COS0_WEIGHT, cos0_credit_weight);\n\tREG_WR(bp, PBF_REG_COS1_WEIGHT, cos1_credit_weight);\n}\n\nint bnx2x_ets_strict(const struct link_params *params, const u8 strict_cos)\n{\n\t/* ETS disabled configuration*/\n\tstruct bnx2x *bp = params->bp;\n\tu32 val\t= 0;\n\n\tDP(NETIF_MSG_LINK, \"ETS enabled strict configuration\\n\");\n\t/* Bitmap of 5bits length. Each bit specifies whether the entry behaves\n\t * as strict.  Bits 0,1,2 - debug and management entries,\n\t * 3 - COS0 entry, 4 - COS1 entry.\n\t *  COS1 | COS0 | DEBUG21 | DEBUG0 | MGMT\n\t *  bit4   bit3\t  bit2      bit1     bit0\n\t * MCP and debug are strict\n\t */\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT, 0x1F);\n\t/* For strict priority entries defines the number of consecutive slots\n\t * for the highest priority.\n\t */\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_NUM_STRICT_ARB_SLOTS, 0x100);\n\t/* ETS mode disable */\n\tREG_WR(bp, PBF_REG_ETS_ENABLED, 0);\n\t/* Defines the number of consecutive slots for the strict priority */\n\tREG_WR(bp, PBF_REG_NUM_STRICT_ARB_SLOTS, 0x100);\n\n\t/* Defines the number of consecutive slots for the strict priority */\n\tREG_WR(bp, PBF_REG_HIGH_PRIORITY_COS_NUM, strict_cos);\n\n\t/* Mapping between entry  priority to client number (0,1,2 -debug and\n\t * management clients, 3 - COS0 client, 4 - COS client)(HIGHEST)\n\t * 3bits client num.\n\t *   PRI4    |    PRI3    |    PRI2    |    PRI1    |    PRI0\n\t * dbg0-010     dbg1-001     cos1-100     cos0-011     MCP-000\n\t * dbg0-010     dbg1-001     cos0-011     cos1-100     MCP-000\n\t */\n\tval = (!strict_cos) ? 0x2318 : 0x22E0;\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT, val);\n\n\treturn 0;\n}\n\n/******************************************************************/\n/*\t\t\tPFC section\t\t\t\t  */\n/******************************************************************/\nstatic void bnx2x_update_pfc_xmac(struct link_params *params,\n\t\t\t\t  struct link_vars *vars,\n\t\t\t\t  u8 is_lb)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 xmac_base;\n\tu32 pause_val, pfc0_val, pfc1_val;\n\n\t/* XMAC base adrr */\n\txmac_base = (params->port) ? GRCBASE_XMAC1 : GRCBASE_XMAC0;\n\n\t/* Initialize pause and pfc registers */\n\tpause_val = 0x18000;\n\tpfc0_val = 0xFFFF8000;\n\tpfc1_val = 0x2;\n\n\t/* No PFC support */\n\tif (!(params->feature_config_flags &\n\t      FEATURE_CONFIG_PFC_ENABLED)) {\n\n\t\t/* RX flow control - Process pause frame in receive direction\n\t\t */\n\t\tif (vars->flow_ctrl & BNX2X_FLOW_CTRL_RX)\n\t\t\tpause_val |= XMAC_PAUSE_CTRL_REG_RX_PAUSE_EN;\n\n\t\t/* TX flow control - Send pause packet when buffer is full */\n\t\tif (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX)\n\t\t\tpause_val |= XMAC_PAUSE_CTRL_REG_TX_PAUSE_EN;\n\t} else {/* PFC support */\n\t\tpfc1_val |= XMAC_PFC_CTRL_HI_REG_PFC_REFRESH_EN |\n\t\t\tXMAC_PFC_CTRL_HI_REG_PFC_STATS_EN |\n\t\t\tXMAC_PFC_CTRL_HI_REG_RX_PFC_EN |\n\t\t\tXMAC_PFC_CTRL_HI_REG_TX_PFC_EN |\n\t\t\tXMAC_PFC_CTRL_HI_REG_FORCE_PFC_XON;\n\t\t/* Write pause and PFC registers */\n\t\tREG_WR(bp, xmac_base + XMAC_REG_PAUSE_CTRL, pause_val);\n\t\tREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL, pfc0_val);\n\t\tREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL_HI, pfc1_val);\n\t\tpfc1_val &= ~XMAC_PFC_CTRL_HI_REG_FORCE_PFC_XON;\n\n\t}\n\n\t/* Write pause and PFC registers */\n\tREG_WR(bp, xmac_base + XMAC_REG_PAUSE_CTRL, pause_val);\n\tREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL, pfc0_val);\n\tREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL_HI, pfc1_val);\n\n\n\t/* Set MAC address for source TX Pause/PFC frames */\n\tREG_WR(bp, xmac_base + XMAC_REG_CTRL_SA_LO,\n\t       ((params->mac_addr[2] << 24) |\n\t\t(params->mac_addr[3] << 16) |\n\t\t(params->mac_addr[4] << 8) |\n\t\t(params->mac_addr[5])));\n\tREG_WR(bp, xmac_base + XMAC_REG_CTRL_SA_HI,\n\t       ((params->mac_addr[0] << 8) |\n\t\t(params->mac_addr[1])));\n\n\tudelay(30);\n}\n\n/******************************************************************/\n/*\t\t\tMAC/PBF section\t\t\t\t  */\n/******************************************************************/\nstatic void bnx2x_set_mdio_clk(struct bnx2x *bp, u32 chip_id,\n\t\t\t       u32 emac_base)\n{\n\tu32 new_mode, cur_mode;\n\tu32 clc_cnt;\n\t/* Set clause 45 mode, slow down the MDIO clock to 2.5MHz\n\t * (a value of 49==0x31) and make sure that the AUTO poll is off\n\t */\n\tcur_mode = REG_RD(bp, emac_base + EMAC_REG_EMAC_MDIO_MODE);\n\n\tif (USES_WARPCORE(bp))\n\t\tclc_cnt = 74L << EMAC_MDIO_MODE_CLOCK_CNT_BITSHIFT;\n\telse\n\t\tclc_cnt = 49L << EMAC_MDIO_MODE_CLOCK_CNT_BITSHIFT;\n\n\tif (((cur_mode & EMAC_MDIO_MODE_CLOCK_CNT) == clc_cnt) &&\n\t    (cur_mode & (EMAC_MDIO_MODE_CLAUSE_45)))\n\t\treturn;\n\n\tnew_mode = cur_mode &\n\t\t~(EMAC_MDIO_MODE_AUTO_POLL | EMAC_MDIO_MODE_CLOCK_CNT);\n\tnew_mode |= clc_cnt;\n\tnew_mode |= (EMAC_MDIO_MODE_CLAUSE_45);\n\n\tDP(NETIF_MSG_LINK, \"Changing emac_mode from 0x%x to 0x%x\\n\",\n\t   cur_mode, new_mode);\n\tREG_WR(bp, emac_base + EMAC_REG_EMAC_MDIO_MODE, new_mode);\n\tudelay(40);\n}\n\nstatic void bnx2x_set_mdio_emac_per_phy(struct bnx2x *bp,\n\t\t\t\t\tstruct link_params *params)\n{\n\tu8 phy_index;\n\t/* Set mdio clock per phy */\n\tfor (phy_index = INT_PHY; phy_index < params->num_phys;\n\t      phy_index++)\n\t\tbnx2x_set_mdio_clk(bp, params->chip_id,\n\t\t\t\t   params->phy[phy_index].mdio_ctrl);\n}\n\nstatic u8 bnx2x_is_4_port_mode(struct bnx2x *bp)\n{\n\tu32 port4mode_ovwr_val;\n\t/* Check 4-port override enabled */\n\tport4mode_ovwr_val = REG_RD(bp, MISC_REG_PORT4MODE_EN_OVWR);\n\tif (port4mode_ovwr_val & (1<<0)) {\n\t\t/* Return 4-port mode override value */\n\t\treturn ((port4mode_ovwr_val & (1<<1)) == (1<<1));\n\t}\n\t/* Return 4-port mode from input pin */\n\treturn (u8)REG_RD(bp, MISC_REG_PORT4MODE_EN);\n}\n\nstatic void bnx2x_emac_init(struct link_params *params,\n\t\t\t    struct link_vars *vars)\n{\n\t/* reset and unreset the emac core */\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\tu32 emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;\n\tu32 val;\n\tu16 timeout;\n\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\n\t       (MISC_REGISTERS_RESET_REG_2_RST_EMAC0_HARD_CORE << port));\n\tudelay(5);\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,\n\t       (MISC_REGISTERS_RESET_REG_2_RST_EMAC0_HARD_CORE << port));\n\n\t/* init emac - use read-modify-write */\n\t/* self clear reset */\n\tval = REG_RD(bp, emac_base + EMAC_REG_EMAC_MODE);\n\tEMAC_WR(bp, EMAC_REG_EMAC_MODE, (val | EMAC_MODE_RESET));\n\n\ttimeout = 200;\n\tdo {\n\t\tval = REG_RD(bp, emac_base + EMAC_REG_EMAC_MODE);\n\t\tDP(NETIF_MSG_LINK, \"EMAC reset reg is %u\\n\", val);\n\t\tif (!timeout) {\n\t\t\tDP(NETIF_MSG_LINK, \"EMAC timeout!\\n\");\n\t\t\treturn;\n\t\t}\n\t\ttimeout--;\n\t} while (val & EMAC_MODE_RESET);\n\n\tbnx2x_set_mdio_emac_per_phy(bp, params);\n\t/* Set mac address */\n\tval = ((params->mac_addr[0] << 8) |\n\t\tparams->mac_addr[1]);\n\tEMAC_WR(bp, EMAC_REG_EMAC_MAC_MATCH, val);\n\n\tval = ((params->mac_addr[2] << 24) |\n\t       (params->mac_addr[3] << 16) |\n\t       (params->mac_addr[4] << 8) |\n\t\tparams->mac_addr[5]);\n\tEMAC_WR(bp, EMAC_REG_EMAC_MAC_MATCH + 4, val);\n}\n\nstatic void bnx2x_set_xumac_nig(struct link_params *params,\n\t\t\t\tu16 tx_pause_en,\n\t\t\t\tu8 enable)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tREG_WR(bp, params->port ? NIG_REG_P1_MAC_IN_EN : NIG_REG_P0_MAC_IN_EN,\n\t       enable);\n\tREG_WR(bp, params->port ? NIG_REG_P1_MAC_OUT_EN : NIG_REG_P0_MAC_OUT_EN,\n\t       enable);\n\tREG_WR(bp, params->port ? NIG_REG_P1_MAC_PAUSE_OUT_EN :\n\t       NIG_REG_P0_MAC_PAUSE_OUT_EN, tx_pause_en);\n}\n\nstatic void bnx2x_set_umac_rxtx(struct link_params *params, u8 en)\n{\n\tu32 umac_base = params->port ? GRCBASE_UMAC1 : GRCBASE_UMAC0;\n\tu32 val;\n\tstruct bnx2x *bp = params->bp;\n\tif (!(REG_RD(bp, MISC_REG_RESET_REG_2) &\n\t\t   (MISC_REGISTERS_RESET_REG_2_UMAC0 << params->port)))\n\t\treturn;\n\tval = REG_RD(bp, umac_base + UMAC_REG_COMMAND_CONFIG);\n\tif (en)\n\t\tval |= (UMAC_COMMAND_CONFIG_REG_TX_ENA |\n\t\t\tUMAC_COMMAND_CONFIG_REG_RX_ENA);\n\telse\n\t\tval &= ~(UMAC_COMMAND_CONFIG_REG_TX_ENA |\n\t\t\t UMAC_COMMAND_CONFIG_REG_RX_ENA);\n\t/* Disable RX and TX */\n\tREG_WR(bp, umac_base + UMAC_REG_COMMAND_CONFIG, val);\n}\n\nstatic void bnx2x_umac_enable(struct link_params *params,\n\t\t\t    struct link_vars *vars, u8 lb)\n{\n\tu32 val;\n\tu32 umac_base = params->port ? GRCBASE_UMAC1 : GRCBASE_UMAC0;\n\tstruct bnx2x *bp = params->bp;\n\t/* Reset UMAC */\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\n\t       (MISC_REGISTERS_RESET_REG_2_UMAC0 << params->port));\n\tusleep_range(1000, 2000);\n\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,\n\t       (MISC_REGISTERS_RESET_REG_2_UMAC0 << params->port));\n\n\tDP(NETIF_MSG_LINK, \"enabling UMAC\\n\");\n\n\t/* This register opens the gate for the UMAC despite its name */\n\tREG_WR(bp, NIG_REG_EGRESS_EMAC0_PORT + params->port*4, 1);\n\n\tval = UMAC_COMMAND_CONFIG_REG_PROMIS_EN |\n\t\tUMAC_COMMAND_CONFIG_REG_PAD_EN |\n\t\tUMAC_COMMAND_CONFIG_REG_SW_RESET |\n\t\tUMAC_COMMAND_CONFIG_REG_NO_LGTH_CHECK;\n\tswitch (vars->line_speed) {\n\tcase SPEED_10:\n\t\tval |= (0<<2);\n\t\tbreak;\n\tcase SPEED_100:\n\t\tval |= (1<<2);\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tval |= (2<<2);\n\t\tbreak;\n\tcase SPEED_2500:\n\t\tval |= (3<<2);\n\t\tbreak;\n\tdefault:\n\t\tDP(NETIF_MSG_LINK, \"Invalid speed for UMAC %d\\n\",\n\t\t\t       vars->line_speed);\n\t\tbreak;\n\t}\n\tif (!(vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\n\t\tval |= UMAC_COMMAND_CONFIG_REG_IGNORE_TX_PAUSE;\n\n\tif (!(vars->flow_ctrl & BNX2X_FLOW_CTRL_RX))\n\t\tval |= UMAC_COMMAND_CONFIG_REG_PAUSE_IGNORE;\n\n\tif (vars->duplex == DUPLEX_HALF)\n\t\tval |= UMAC_COMMAND_CONFIG_REG_HD_ENA;\n\n\tREG_WR(bp, umac_base + UMAC_REG_COMMAND_CONFIG, val);\n\tudelay(50);\n\n\t/* Configure UMAC for EEE */\n\tif (vars->eee_status & SHMEM_EEE_ADV_STATUS_MASK) {\n\t\tDP(NETIF_MSG_LINK, \"configured UMAC for EEE\\n\");\n\t\tREG_WR(bp, umac_base + UMAC_REG_UMAC_EEE_CTRL,\n\t\t       UMAC_UMAC_EEE_CTRL_REG_EEE_EN);\n\t\tREG_WR(bp, umac_base + UMAC_REG_EEE_WAKE_TIMER, 0x11);\n\t} else {\n\t\tREG_WR(bp, umac_base + UMAC_REG_UMAC_EEE_CTRL, 0x0);\n\t}\n\n\t/* Set MAC address for source TX Pause/PFC frames (under SW reset) */\n\tREG_WR(bp, umac_base + UMAC_REG_MAC_ADDR0,\n\t       ((params->mac_addr[2] << 24) |\n\t\t(params->mac_addr[3] << 16) |\n\t\t(params->mac_addr[4] << 8) |\n\t\t(params->mac_addr[5])));\n\tREG_WR(bp, umac_base + UMAC_REG_MAC_ADDR1,\n\t       ((params->mac_addr[0] << 8) |\n\t\t(params->mac_addr[1])));\n\n\t/* Enable RX and TX */\n\tval &= ~UMAC_COMMAND_CONFIG_REG_PAD_EN;\n\tval |= UMAC_COMMAND_CONFIG_REG_TX_ENA |\n\t\tUMAC_COMMAND_CONFIG_REG_RX_ENA;\n\tREG_WR(bp, umac_base + UMAC_REG_COMMAND_CONFIG, val);\n\tudelay(50);\n\n\t/* Remove SW Reset */\n\tval &= ~UMAC_COMMAND_CONFIG_REG_SW_RESET;\n\n\t/* Check loopback mode */\n\tif (lb)\n\t\tval |= UMAC_COMMAND_CONFIG_REG_LOOP_ENA;\n\tREG_WR(bp, umac_base + UMAC_REG_COMMAND_CONFIG, val);\n\n\t/* Maximum Frame Length (RW). Defines a 14-Bit maximum frame\n\t * length used by the MAC receive logic to check frames.\n\t */\n\tREG_WR(bp, umac_base + UMAC_REG_MAXFR, 0x2710);\n\tbnx2x_set_xumac_nig(params,\n\t\t\t    ((vars->flow_ctrl & BNX2X_FLOW_CTRL_TX) != 0), 1);\n\tvars->mac_type = MAC_TYPE_UMAC;\n\n}\n\n/* Define the XMAC mode */\nstatic void bnx2x_xmac_init(struct link_params *params, u32 max_speed)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 is_port4mode = bnx2x_is_4_port_mode(bp);\n\n\t/* In 4-port mode, need to set the mode only once, so if XMAC is\n\t * already out of reset, it means the mode has already been set,\n\t * and it must not* reset the XMAC again, since it controls both\n\t * ports of the path\n\t */\n\n\tif (((CHIP_NUM(bp) == CHIP_NUM_57840_4_10) ||\n\t     (CHIP_NUM(bp) == CHIP_NUM_57840_2_20) ||\n\t     (CHIP_NUM(bp) == CHIP_NUM_57840_OBSOLETE)) &&\n\t    is_port4mode &&\n\t    (REG_RD(bp, MISC_REG_RESET_REG_2) &\n\t     MISC_REGISTERS_RESET_REG_2_XMAC)) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"XMAC already out of reset in 4-port mode\\n\");\n\t\treturn;\n\t}\n\n\t/* Hard reset */\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\n\t       MISC_REGISTERS_RESET_REG_2_XMAC);\n\tusleep_range(1000, 2000);\n\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,\n\t       MISC_REGISTERS_RESET_REG_2_XMAC);\n\tif (is_port4mode) {\n\t\tDP(NETIF_MSG_LINK, \"Init XMAC to 2 ports x 10G per path\\n\");\n\n\t\t/* Set the number of ports on the system side to up to 2 */\n\t\tREG_WR(bp, MISC_REG_XMAC_CORE_PORT_MODE, 1);\n\n\t\t/* Set the number of ports on the Warp Core to 10G */\n\t\tREG_WR(bp, MISC_REG_XMAC_PHY_PORT_MODE, 3);\n\t} else {\n\t\t/* Set the number of ports on the system side to 1 */\n\t\tREG_WR(bp, MISC_REG_XMAC_CORE_PORT_MODE, 0);\n\t\tif (max_speed == SPEED_10000) {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"Init XMAC to 10G x 1 port per path\\n\");\n\t\t\t/* Set the number of ports on the Warp Core to 10G */\n\t\t\tREG_WR(bp, MISC_REG_XMAC_PHY_PORT_MODE, 3);\n\t\t} else {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"Init XMAC to 20G x 2 ports per path\\n\");\n\t\t\t/* Set the number of ports on the Warp Core to 20G */\n\t\t\tREG_WR(bp, MISC_REG_XMAC_PHY_PORT_MODE, 1);\n\t\t}\n\t}\n\t/* Soft reset */\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\n\t       MISC_REGISTERS_RESET_REG_2_XMAC_SOFT);\n\tusleep_range(1000, 2000);\n\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,\n\t       MISC_REGISTERS_RESET_REG_2_XMAC_SOFT);\n\n}\n\nstatic void bnx2x_set_xmac_rxtx(struct link_params *params, u8 en)\n{\n\tu8 port = params->port;\n\tstruct bnx2x *bp = params->bp;\n\tu32 pfc_ctrl, xmac_base = (port) ? GRCBASE_XMAC1 : GRCBASE_XMAC0;\n\tu32 val;\n\n\tif (REG_RD(bp, MISC_REG_RESET_REG_2) &\n\t    MISC_REGISTERS_RESET_REG_2_XMAC) {\n\t\t/* Send an indication to change the state in the NIG back to XON\n\t\t * Clearing this bit enables the next set of this bit to get\n\t\t * rising edge\n\t\t */\n\t\tpfc_ctrl = REG_RD(bp, xmac_base + XMAC_REG_PFC_CTRL_HI);\n\t\tREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL_HI,\n\t\t       (pfc_ctrl & ~(1<<1)));\n\t\tREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL_HI,\n\t\t       (pfc_ctrl | (1<<1)));\n\t\tDP(NETIF_MSG_LINK, \"Disable XMAC on port %x\\n\", port);\n\t\tval = REG_RD(bp, xmac_base + XMAC_REG_CTRL);\n\t\tif (en)\n\t\t\tval |= (XMAC_CTRL_REG_TX_EN | XMAC_CTRL_REG_RX_EN);\n\t\telse\n\t\t\tval &= ~(XMAC_CTRL_REG_TX_EN | XMAC_CTRL_REG_RX_EN);\n\t\tREG_WR(bp, xmac_base + XMAC_REG_CTRL, val);\n\t}\n}\n\nstatic int bnx2x_xmac_enable(struct link_params *params,\n\t\t\t     struct link_vars *vars, u8 lb)\n{\n\tu32 val, xmac_base;\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"enabling XMAC\\n\");\n\n\txmac_base = (params->port) ? GRCBASE_XMAC1 : GRCBASE_XMAC0;\n\n\tbnx2x_xmac_init(params, vars->line_speed);\n\n\t/* This register determines on which events the MAC will assert\n\t * error on the i/f to the NIG along w/ EOP.\n\t */\n\n\t/* This register tells the NIG whether to send traffic to UMAC\n\t * or XMAC\n\t */\n\tREG_WR(bp, NIG_REG_EGRESS_EMAC0_PORT + params->port*4, 0);\n\n\t/* When XMAC is in XLGMII mode, disable sending idles for fault\n\t * detection.\n\t */\n\tif (!(params->phy[INT_PHY].flags & FLAGS_TX_ERROR_CHECK)) {\n\t\tREG_WR(bp, xmac_base + XMAC_REG_RX_LSS_CTRL,\n\t\t       (XMAC_RX_LSS_CTRL_REG_LOCAL_FAULT_DISABLE |\n\t\t\tXMAC_RX_LSS_CTRL_REG_REMOTE_FAULT_DISABLE));\n\t\tREG_WR(bp, xmac_base + XMAC_REG_CLEAR_RX_LSS_STATUS, 0);\n\t\tREG_WR(bp, xmac_base + XMAC_REG_CLEAR_RX_LSS_STATUS,\n\t\t       XMAC_CLEAR_RX_LSS_STATUS_REG_CLEAR_LOCAL_FAULT_STATUS |\n\t\t       XMAC_CLEAR_RX_LSS_STATUS_REG_CLEAR_REMOTE_FAULT_STATUS);\n\t}\n\t/* Set Max packet size */\n\tREG_WR(bp, xmac_base + XMAC_REG_RX_MAX_SIZE, 0x2710);\n\n\t/* CRC append for Tx packets */\n\tREG_WR(bp, xmac_base + XMAC_REG_TX_CTRL, 0xC800);\n\n\t/* update PFC */\n\tbnx2x_update_pfc_xmac(params, vars, 0);\n\n\tif (vars->eee_status & SHMEM_EEE_ADV_STATUS_MASK) {\n\t\tDP(NETIF_MSG_LINK, \"Setting XMAC for EEE\\n\");\n\t\tREG_WR(bp, xmac_base + XMAC_REG_EEE_TIMERS_HI, 0x1380008);\n\t\tREG_WR(bp, xmac_base + XMAC_REG_EEE_CTRL, 0x1);\n\t} else {\n\t\tREG_WR(bp, xmac_base + XMAC_REG_EEE_CTRL, 0x0);\n\t}\n\n\t/* Enable TX and RX */\n\tval = XMAC_CTRL_REG_TX_EN | XMAC_CTRL_REG_RX_EN;\n\n\t/* Set MAC in XLGMII mode for dual-mode */\n\tif ((vars->line_speed == SPEED_20000) &&\n\t    (params->phy[INT_PHY].supported &\n\t     SUPPORTED_20000baseKR2_Full))\n\t\tval |= XMAC_CTRL_REG_XLGMII_ALIGN_ENB;\n\n\t/* Check loopback mode */\n\tif (lb)\n\t\tval |= XMAC_CTRL_REG_LINE_LOCAL_LPBK;\n\tREG_WR(bp, xmac_base + XMAC_REG_CTRL, val);\n\tbnx2x_set_xumac_nig(params,\n\t\t\t    ((vars->flow_ctrl & BNX2X_FLOW_CTRL_TX) != 0), 1);\n\n\tvars->mac_type = MAC_TYPE_XMAC;\n\n\treturn 0;\n}\n\nstatic int bnx2x_emac_enable(struct link_params *params,\n\t\t\t     struct link_vars *vars, u8 lb)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\tu32 emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;\n\tu32 val;\n\n\tDP(NETIF_MSG_LINK, \"enabling EMAC\\n\");\n\n\t/* Disable BMAC */\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\n\t       (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port));\n\n\t/* enable emac and not bmac */\n\tREG_WR(bp, NIG_REG_EGRESS_EMAC0_PORT + port*4, 1);\n\n\t/* ASIC */\n\tif (vars->phy_flags & PHY_XGXS_FLAG) {\n\t\tu32 ser_lane = ((params->lane_config &\n\t\t\t\t PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK) >>\n\t\t\t\tPORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT);\n\n\t\tDP(NETIF_MSG_LINK, \"XGXS\\n\");\n\t\t/* select the master lanes (out of 0-3) */\n\t\tREG_WR(bp, NIG_REG_XGXS_LANE_SEL_P0 + port*4, ser_lane);\n\t\t/* select XGXS */\n\t\tREG_WR(bp, NIG_REG_XGXS_SERDES0_MODE_SEL + port*4, 1);\n\n\t} else { /* SerDes */\n\t\tDP(NETIF_MSG_LINK, \"SerDes\\n\");\n\t\t/* select SerDes */\n\t\tREG_WR(bp, NIG_REG_XGXS_SERDES0_MODE_SEL + port*4, 0);\n\t}\n\n\tbnx2x_bits_en(bp, emac_base + EMAC_REG_EMAC_RX_MODE,\n\t\t      EMAC_RX_MODE_RESET);\n\tbnx2x_bits_en(bp, emac_base + EMAC_REG_EMAC_TX_MODE,\n\t\t      EMAC_TX_MODE_RESET);\n\n\t/* pause enable/disable */\n\tbnx2x_bits_dis(bp, emac_base + EMAC_REG_EMAC_RX_MODE,\n\t\t       EMAC_RX_MODE_FLOW_EN);\n\n\tbnx2x_bits_dis(bp,  emac_base + EMAC_REG_EMAC_TX_MODE,\n\t\t       (EMAC_TX_MODE_EXT_PAUSE_EN |\n\t\t\tEMAC_TX_MODE_FLOW_EN));\n\tif (!(params->feature_config_flags &\n\t      FEATURE_CONFIG_PFC_ENABLED)) {\n\t\tif (vars->flow_ctrl & BNX2X_FLOW_CTRL_RX)\n\t\t\tbnx2x_bits_en(bp, emac_base +\n\t\t\t\t      EMAC_REG_EMAC_RX_MODE,\n\t\t\t\t      EMAC_RX_MODE_FLOW_EN);\n\n\t\tif (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX)\n\t\t\tbnx2x_bits_en(bp, emac_base +\n\t\t\t\t      EMAC_REG_EMAC_TX_MODE,\n\t\t\t\t      (EMAC_TX_MODE_EXT_PAUSE_EN |\n\t\t\t\t       EMAC_TX_MODE_FLOW_EN));\n\t} else\n\t\tbnx2x_bits_en(bp, emac_base + EMAC_REG_EMAC_TX_MODE,\n\t\t\t      EMAC_TX_MODE_FLOW_EN);\n\n\t/* KEEP_VLAN_TAG, promiscuous */\n\tval = REG_RD(bp, emac_base + EMAC_REG_EMAC_RX_MODE);\n\tval |= EMAC_RX_MODE_KEEP_VLAN_TAG | EMAC_RX_MODE_PROMISCUOUS;\n\n\t/* Setting this bit causes MAC control frames (except for pause\n\t * frames) to be passed on for processing. This setting has no\n\t * affect on the operation of the pause frames. This bit effects\n\t * all packets regardless of RX Parser packet sorting logic.\n\t * Turn the PFC off to make sure we are in Xon state before\n\t * enabling it.\n\t */\n\tEMAC_WR(bp, EMAC_REG_RX_PFC_MODE, 0);\n\tif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED) {\n\t\tDP(NETIF_MSG_LINK, \"PFC is enabled\\n\");\n\t\t/* Enable PFC again */\n\t\tEMAC_WR(bp, EMAC_REG_RX_PFC_MODE,\n\t\t\tEMAC_REG_RX_PFC_MODE_RX_EN |\n\t\t\tEMAC_REG_RX_PFC_MODE_TX_EN |\n\t\t\tEMAC_REG_RX_PFC_MODE_PRIORITIES);\n\n\t\tEMAC_WR(bp, EMAC_REG_RX_PFC_PARAM,\n\t\t\t((0x0101 <<\n\t\t\t  EMAC_REG_RX_PFC_PARAM_OPCODE_BITSHIFT) |\n\t\t\t (0x00ff <<\n\t\t\t  EMAC_REG_RX_PFC_PARAM_PRIORITY_EN_BITSHIFT)));\n\t\tval |= EMAC_RX_MODE_KEEP_MAC_CONTROL;\n\t}\n\tEMAC_WR(bp, EMAC_REG_EMAC_RX_MODE, val);\n\n\t/* Set Loopback */\n\tval = REG_RD(bp, emac_base + EMAC_REG_EMAC_MODE);\n\tif (lb)\n\t\tval |= 0x810;\n\telse\n\t\tval &= ~0x810;\n\tEMAC_WR(bp, EMAC_REG_EMAC_MODE, val);\n\n\t/* Enable emac */\n\tREG_WR(bp, NIG_REG_NIG_EMAC0_EN + port*4, 1);\n\n\t/* Enable emac for jumbo packets */\n\tEMAC_WR(bp, EMAC_REG_EMAC_RX_MTU_SIZE,\n\t\t(EMAC_RX_MTU_SIZE_JUMBO_ENA |\n\t\t (ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVERHEAD)));\n\n\t/* Strip CRC */\n\tREG_WR(bp, NIG_REG_NIG_INGRESS_EMAC0_NO_CRC + port*4, 0x1);\n\n\t/* Disable the NIG in/out to the bmac */\n\tREG_WR(bp, NIG_REG_BMAC0_IN_EN + port*4, 0x0);\n\tREG_WR(bp, NIG_REG_BMAC0_PAUSE_OUT_EN + port*4, 0x0);\n\tREG_WR(bp, NIG_REG_BMAC0_OUT_EN + port*4, 0x0);\n\n\t/* Enable the NIG in/out to the emac */\n\tREG_WR(bp, NIG_REG_EMAC0_IN_EN + port*4, 0x1);\n\tval = 0;\n\tif ((params->feature_config_flags &\n\t      FEATURE_CONFIG_PFC_ENABLED) ||\n\t    (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\n\t\tval = 1;\n\n\tREG_WR(bp, NIG_REG_EMAC0_PAUSE_OUT_EN + port*4, val);\n\tREG_WR(bp, NIG_REG_EGRESS_EMAC0_OUT_EN + port*4, 0x1);\n\n\tREG_WR(bp, NIG_REG_BMAC0_REGS_OUT_EN + port*4, 0x0);\n\n\tvars->mac_type = MAC_TYPE_EMAC;\n\treturn 0;\n}\n\nstatic void bnx2x_update_pfc_bmac1(struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tu32 wb_data[2];\n\tstruct bnx2x *bp = params->bp;\n\tu32 bmac_addr =  params->port ? NIG_REG_INGRESS_BMAC1_MEM :\n\t\tNIG_REG_INGRESS_BMAC0_MEM;\n\n\tu32 val = 0x14;\n\tif ((!(params->feature_config_flags &\n\t      FEATURE_CONFIG_PFC_ENABLED)) &&\n\t\t(vars->flow_ctrl & BNX2X_FLOW_CTRL_RX))\n\t\t/* Enable BigMAC to react on received Pause packets */\n\t\tval |= (1<<5);\n\twb_data[0] = val;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_RX_CONTROL, wb_data, 2);\n\n\t/* TX control */\n\tval = 0xc0;\n\tif (!(params->feature_config_flags &\n\t      FEATURE_CONFIG_PFC_ENABLED) &&\n\t\t(vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\n\t\tval |= 0x800000;\n\twb_data[0] = val;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_TX_CONTROL, wb_data, 2);\n}\n\nstatic void bnx2x_update_pfc_bmac2(struct link_params *params,\n\t\t\t\t   struct link_vars *vars,\n\t\t\t\t   u8 is_lb)\n{\n\t/* Set rx control: Strip CRC and enable BigMAC to relay\n\t * control packets to the system as well\n\t */\n\tu32 wb_data[2];\n\tstruct bnx2x *bp = params->bp;\n\tu32 bmac_addr = params->port ? NIG_REG_INGRESS_BMAC1_MEM :\n\t\tNIG_REG_INGRESS_BMAC0_MEM;\n\tu32 val = 0x14;\n\n\tif ((!(params->feature_config_flags &\n\t      FEATURE_CONFIG_PFC_ENABLED)) &&\n\t\t(vars->flow_ctrl & BNX2X_FLOW_CTRL_RX))\n\t\t/* Enable BigMAC to react on received Pause packets */\n\t\tval |= (1<<5);\n\twb_data[0] = val;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_RX_CONTROL, wb_data, 2);\n\tudelay(30);\n\n\t/* Tx control */\n\tval = 0xc0;\n\tif (!(params->feature_config_flags &\n\t\t\t\tFEATURE_CONFIG_PFC_ENABLED) &&\n\t    (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\n\t\tval |= 0x800000;\n\twb_data[0] = val;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_TX_CONTROL, wb_data, 2);\n\n\tif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED) {\n\t\tDP(NETIF_MSG_LINK, \"PFC is enabled\\n\");\n\t\t/* Enable PFC RX & TX & STATS and set 8 COS  */\n\t\twb_data[0] = 0x0;\n\t\twb_data[0] |= (1<<0);  /* RX */\n\t\twb_data[0] |= (1<<1);  /* TX */\n\t\twb_data[0] |= (1<<2);  /* Force initial Xon */\n\t\twb_data[0] |= (1<<3);  /* 8 cos */\n\t\twb_data[0] |= (1<<5);  /* STATS */\n\t\twb_data[1] = 0;\n\t\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_PFC_CONTROL,\n\t\t\t    wb_data, 2);\n\t\t/* Clear the force Xon */\n\t\twb_data[0] &= ~(1<<2);\n\t} else {\n\t\tDP(NETIF_MSG_LINK, \"PFC is disabled\\n\");\n\t\t/* Disable PFC RX & TX & STATS and set 8 COS */\n\t\twb_data[0] = 0x8;\n\t\twb_data[1] = 0;\n\t}\n\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_PFC_CONTROL, wb_data, 2);\n\n\t/* Set Time (based unit is 512 bit time) between automatic\n\t * re-sending of PP packets amd enable automatic re-send of\n\t * Per-Priroity Packet as long as pp_gen is asserted and\n\t * pp_disable is low.\n\t */\n\tval = 0x8000;\n\tif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED)\n\t\tval |= (1<<16); /* enable automatic re-send */\n\n\twb_data[0] = val;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_TX_PAUSE_CONTROL,\n\t\t    wb_data, 2);\n\n\t/* mac control */\n\tval = 0x3; /* Enable RX and TX */\n\tif (is_lb) {\n\t\tval |= 0x4; /* Local loopback */\n\t\tDP(NETIF_MSG_LINK, \"enable bmac loopback\\n\");\n\t}\n\t/* When PFC enabled, Pass pause frames towards the NIG. */\n\tif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED)\n\t\tval |= ((1<<6)|(1<<5));\n\n\twb_data[0] = val;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_BMAC_CONTROL, wb_data, 2);\n}\n\n/******************************************************************************\n* Description:\n*  This function is needed because NIG ARB_CREDIT_WEIGHT_X are\n*  not continues and ARB_CREDIT_WEIGHT_0 + offset is suitable.\n******************************************************************************/\nstatic int bnx2x_pfc_nig_rx_priority_mask(struct bnx2x *bp,\n\t\t\t\t\t   u8 cos_entry,\n\t\t\t\t\t   u32 priority_mask, u8 port)\n{\n\tu32 nig_reg_rx_priority_mask_add = 0;\n\n\tswitch (cos_entry) {\n\tcase 0:\n\t     nig_reg_rx_priority_mask_add = (port) ?\n\t\t NIG_REG_P1_RX_COS0_PRIORITY_MASK :\n\t\t NIG_REG_P0_RX_COS0_PRIORITY_MASK;\n\t     break;\n\tcase 1:\n\t    nig_reg_rx_priority_mask_add = (port) ?\n\t\tNIG_REG_P1_RX_COS1_PRIORITY_MASK :\n\t\tNIG_REG_P0_RX_COS1_PRIORITY_MASK;\n\t    break;\n\tcase 2:\n\t    nig_reg_rx_priority_mask_add = (port) ?\n\t\tNIG_REG_P1_RX_COS2_PRIORITY_MASK :\n\t\tNIG_REG_P0_RX_COS2_PRIORITY_MASK;\n\t    break;\n\tcase 3:\n\t    if (port)\n\t\treturn -EINVAL;\n\t    nig_reg_rx_priority_mask_add = NIG_REG_P0_RX_COS3_PRIORITY_MASK;\n\t    break;\n\tcase 4:\n\t    if (port)\n\t\treturn -EINVAL;\n\t    nig_reg_rx_priority_mask_add = NIG_REG_P0_RX_COS4_PRIORITY_MASK;\n\t    break;\n\tcase 5:\n\t    if (port)\n\t\treturn -EINVAL;\n\t    nig_reg_rx_priority_mask_add = NIG_REG_P0_RX_COS5_PRIORITY_MASK;\n\t    break;\n\t}\n\n\tREG_WR(bp, nig_reg_rx_priority_mask_add, priority_mask);\n\n\treturn 0;\n}\nstatic void bnx2x_update_mng(struct link_params *params, u32 link_status)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tREG_WR(bp, params->shmem_base +\n\t       offsetof(struct shmem_region,\n\t\t\tport_mb[params->port].link_status), link_status);\n}\n\nstatic void bnx2x_update_link_attr(struct link_params *params, u32 link_attr)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tif (SHMEM2_HAS(bp, link_attr_sync))\n\t\tREG_WR(bp, params->shmem2_base +\n\t\t       offsetof(struct shmem2_region,\n\t\t\t\tlink_attr_sync[params->port]), link_attr);\n}\n\nstatic void bnx2x_update_pfc_nig(struct link_params *params,\n\t\tstruct link_vars *vars,\n\t\tstruct bnx2x_nig_brb_pfc_port_params *nig_params)\n{\n\tu32 xcm_mask = 0, ppp_enable = 0, pause_enable = 0, llfc_out_en = 0;\n\tu32 llfc_enable = 0, xcm_out_en = 0, hwpfc_enable = 0;\n\tu32 pkt_priority_to_cos = 0;\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\n\tint set_pfc = params->feature_config_flags &\n\t\tFEATURE_CONFIG_PFC_ENABLED;\n\tDP(NETIF_MSG_LINK, \"updating pfc nig parameters\\n\");\n\n\t/* When NIG_LLH0_XCM_MASK_REG_LLHX_XCM_MASK_BCN bit is set\n\t * MAC control frames (that are not pause packets)\n\t * will be forwarded to the XCM.\n\t */\n\txcm_mask = REG_RD(bp, port ? NIG_REG_LLH1_XCM_MASK :\n\t\t\t  NIG_REG_LLH0_XCM_MASK);\n\t/* NIG params will override non PFC params, since it's possible to\n\t * do transition from PFC to SAFC\n\t */\n\tif (set_pfc) {\n\t\tpause_enable = 0;\n\t\tllfc_out_en = 0;\n\t\tllfc_enable = 0;\n\t\tif (CHIP_IS_E3(bp))\n\t\t\tppp_enable = 0;\n\t\telse\n\t\t\tppp_enable = 1;\n\t\txcm_mask &= ~(port ? NIG_LLH1_XCM_MASK_REG_LLH1_XCM_MASK_BCN :\n\t\t\t\t     NIG_LLH0_XCM_MASK_REG_LLH0_XCM_MASK_BCN);\n\t\txcm_out_en = 0;\n\t\thwpfc_enable = 1;\n\t} else  {\n\t\tif (nig_params) {\n\t\t\tllfc_out_en = nig_params->llfc_out_en;\n\t\t\tllfc_enable = nig_params->llfc_enable;\n\t\t\tpause_enable = nig_params->pause_enable;\n\t\t} else  /* Default non PFC mode - PAUSE */\n\t\t\tpause_enable = 1;\n\n\t\txcm_mask |= (port ? NIG_LLH1_XCM_MASK_REG_LLH1_XCM_MASK_BCN :\n\t\t\tNIG_LLH0_XCM_MASK_REG_LLH0_XCM_MASK_BCN);\n\t\txcm_out_en = 1;\n\t}\n\n\tif (CHIP_IS_E3(bp))\n\t\tREG_WR(bp, port ? NIG_REG_BRB1_PAUSE_IN_EN :\n\t\t       NIG_REG_BRB0_PAUSE_IN_EN, pause_enable);\n\tREG_WR(bp, port ? NIG_REG_LLFC_OUT_EN_1 :\n\t       NIG_REG_LLFC_OUT_EN_0, llfc_out_en);\n\tREG_WR(bp, port ? NIG_REG_LLFC_ENABLE_1 :\n\t       NIG_REG_LLFC_ENABLE_0, llfc_enable);\n\tREG_WR(bp, port ? NIG_REG_PAUSE_ENABLE_1 :\n\t       NIG_REG_PAUSE_ENABLE_0, pause_enable);\n\n\tREG_WR(bp, port ? NIG_REG_PPP_ENABLE_1 :\n\t       NIG_REG_PPP_ENABLE_0, ppp_enable);\n\n\tREG_WR(bp, port ? NIG_REG_LLH1_XCM_MASK :\n\t       NIG_REG_LLH0_XCM_MASK, xcm_mask);\n\n\tREG_WR(bp, port ? NIG_REG_LLFC_EGRESS_SRC_ENABLE_1 :\n\t       NIG_REG_LLFC_EGRESS_SRC_ENABLE_0, 0x7);\n\n\t/* Output enable for RX_XCM # IF */\n\tREG_WR(bp, port ? NIG_REG_XCM1_OUT_EN :\n\t       NIG_REG_XCM0_OUT_EN, xcm_out_en);\n\n\t/* HW PFC TX enable */\n\tREG_WR(bp, port ? NIG_REG_P1_HWPFC_ENABLE :\n\t       NIG_REG_P0_HWPFC_ENABLE, hwpfc_enable);\n\n\tif (nig_params) {\n\t\tu8 i = 0;\n\t\tpkt_priority_to_cos = nig_params->pkt_priority_to_cos;\n\n\t\tfor (i = 0; i < nig_params->num_of_rx_cos_priority_mask; i++)\n\t\t\tbnx2x_pfc_nig_rx_priority_mask(bp, i,\n\t\tnig_params->rx_cos_priority_mask[i], port);\n\n\t\tREG_WR(bp, port ? NIG_REG_LLFC_HIGH_PRIORITY_CLASSES_1 :\n\t\t       NIG_REG_LLFC_HIGH_PRIORITY_CLASSES_0,\n\t\t       nig_params->llfc_high_priority_classes);\n\n\t\tREG_WR(bp, port ? NIG_REG_LLFC_LOW_PRIORITY_CLASSES_1 :\n\t\t       NIG_REG_LLFC_LOW_PRIORITY_CLASSES_0,\n\t\t       nig_params->llfc_low_priority_classes);\n\t}\n\tREG_WR(bp, port ? NIG_REG_P1_PKT_PRIORITY_TO_COS :\n\t       NIG_REG_P0_PKT_PRIORITY_TO_COS,\n\t       pkt_priority_to_cos);\n}\n\nint bnx2x_update_pfc(struct link_params *params,\n\t\t      struct link_vars *vars,\n\t\t      struct bnx2x_nig_brb_pfc_port_params *pfc_params)\n{\n\t/* The PFC and pause are orthogonal to one another, meaning when\n\t * PFC is enabled, the pause are disabled, and when PFC is\n\t * disabled, pause are set according to the pause result.\n\t */\n\tu32 val;\n\tstruct bnx2x *bp = params->bp;\n\tu8 bmac_loopback = (params->loopback_mode == LOOPBACK_BMAC);\n\n\tif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED)\n\t\tvars->link_status |= LINK_STATUS_PFC_ENABLED;\n\telse\n\t\tvars->link_status &= ~LINK_STATUS_PFC_ENABLED;\n\n\tbnx2x_update_mng(params, vars->link_status);\n\n\t/* Update NIG params */\n\tbnx2x_update_pfc_nig(params, vars, pfc_params);\n\n\tif (!vars->link_up)\n\t\treturn 0;\n\n\tDP(NETIF_MSG_LINK, \"About to update PFC in BMAC\\n\");\n\n\tif (CHIP_IS_E3(bp)) {\n\t\tif (vars->mac_type == MAC_TYPE_XMAC)\n\t\t\tbnx2x_update_pfc_xmac(params, vars, 0);\n\t} else {\n\t\tval = REG_RD(bp, MISC_REG_RESET_REG_2);\n\t\tif ((val &\n\t\t     (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << params->port))\n\t\t    == 0) {\n\t\t\tDP(NETIF_MSG_LINK, \"About to update PFC in EMAC\\n\");\n\t\t\tbnx2x_emac_enable(params, vars, 0);\n\t\t\treturn 0;\n\t\t}\n\t\tif (CHIP_IS_E2(bp))\n\t\t\tbnx2x_update_pfc_bmac2(params, vars, bmac_loopback);\n\t\telse\n\t\t\tbnx2x_update_pfc_bmac1(params, vars);\n\n\t\tval = 0;\n\t\tif ((params->feature_config_flags &\n\t\t     FEATURE_CONFIG_PFC_ENABLED) ||\n\t\t    (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\n\t\t\tval = 1;\n\t\tREG_WR(bp, NIG_REG_BMAC0_PAUSE_OUT_EN + params->port*4, val);\n\t}\n\treturn 0;\n}\n\nstatic int bnx2x_bmac1_enable(struct link_params *params,\n\t\t\t      struct link_vars *vars,\n\t\t\t      u8 is_lb)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\tu32 bmac_addr = port ? NIG_REG_INGRESS_BMAC1_MEM :\n\t\t\t       NIG_REG_INGRESS_BMAC0_MEM;\n\tu32 wb_data[2];\n\tu32 val;\n\n\tDP(NETIF_MSG_LINK, \"Enabling BigMAC1\\n\");\n\n\t/* XGXS control */\n\twb_data[0] = 0x3c;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_BMAC_XGXS_CONTROL,\n\t\t    wb_data, 2);\n\n\t/* TX MAC SA */\n\twb_data[0] = ((params->mac_addr[2] << 24) |\n\t\t       (params->mac_addr[3] << 16) |\n\t\t       (params->mac_addr[4] << 8) |\n\t\t\tparams->mac_addr[5]);\n\twb_data[1] = ((params->mac_addr[0] << 8) |\n\t\t\tparams->mac_addr[1]);\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_TX_SOURCE_ADDR, wb_data, 2);\n\n\t/* MAC control */\n\tval = 0x3;\n\tif (is_lb) {\n\t\tval |= 0x4;\n\t\tDP(NETIF_MSG_LINK, \"enable bmac loopback\\n\");\n\t}\n\twb_data[0] = val;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_BMAC_CONTROL, wb_data, 2);\n\n\t/* Set rx mtu */\n\twb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVERHEAD;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_RX_MAX_SIZE, wb_data, 2);\n\n\tbnx2x_update_pfc_bmac1(params, vars);\n\n\t/* Set tx mtu */\n\twb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVERHEAD;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_TX_MAX_SIZE, wb_data, 2);\n\n\t/* Set cnt max size */\n\twb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVERHEAD;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_CNT_MAX_SIZE, wb_data, 2);\n\n\t/* Configure SAFC */\n\twb_data[0] = 0x1000200;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_RX_LLFC_MSG_FLDS,\n\t\t    wb_data, 2);\n\n\treturn 0;\n}\n\nstatic int bnx2x_bmac2_enable(struct link_params *params,\n\t\t\t      struct link_vars *vars,\n\t\t\t      u8 is_lb)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\tu32 bmac_addr = port ? NIG_REG_INGRESS_BMAC1_MEM :\n\t\t\t       NIG_REG_INGRESS_BMAC0_MEM;\n\tu32 wb_data[2];\n\n\tDP(NETIF_MSG_LINK, \"Enabling BigMAC2\\n\");\n\n\twb_data[0] = 0;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_BMAC_CONTROL, wb_data, 2);\n\tudelay(30);\n\n\t/* XGXS control: Reset phy HW, MDIO registers, PHY PLL and BMAC */\n\twb_data[0] = 0x3c;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_BMAC_XGXS_CONTROL,\n\t\t    wb_data, 2);\n\n\tudelay(30);\n\n\t/* TX MAC SA */\n\twb_data[0] = ((params->mac_addr[2] << 24) |\n\t\t       (params->mac_addr[3] << 16) |\n\t\t       (params->mac_addr[4] << 8) |\n\t\t\tparams->mac_addr[5]);\n\twb_data[1] = ((params->mac_addr[0] << 8) |\n\t\t\tparams->mac_addr[1]);\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_TX_SOURCE_ADDR,\n\t\t    wb_data, 2);\n\n\tudelay(30);\n\n\t/* Configure SAFC */\n\twb_data[0] = 0x1000200;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_RX_LLFC_MSG_FLDS,\n\t\t    wb_data, 2);\n\tudelay(30);\n\n\t/* Set RX MTU */\n\twb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVERHEAD;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_RX_MAX_SIZE, wb_data, 2);\n\tudelay(30);\n\n\t/* Set TX MTU */\n\twb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVERHEAD;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_TX_MAX_SIZE, wb_data, 2);\n\tudelay(30);\n\t/* Set cnt max size */\n\twb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVERHEAD - 2;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_CNT_MAX_SIZE, wb_data, 2);\n\tudelay(30);\n\tbnx2x_update_pfc_bmac2(params, vars, is_lb);\n\n\treturn 0;\n}\n\nstatic int bnx2x_bmac_enable(struct link_params *params,\n\t\t\t     struct link_vars *vars,\n\t\t\t     u8 is_lb, u8 reset_bmac)\n{\n\tint rc = 0;\n\tu8 port = params->port;\n\tstruct bnx2x *bp = params->bp;\n\tu32 val;\n\t/* Reset and unreset the BigMac */\n\tif (reset_bmac) {\n\t\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\n\t\t       (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port));\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,\n\t       (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port));\n\n\t/* Enable access for bmac registers */\n\tREG_WR(bp, NIG_REG_BMAC0_REGS_OUT_EN + port*4, 0x1);\n\n\t/* Enable BMAC according to BMAC type*/\n\tif (CHIP_IS_E2(bp))\n\t\trc = bnx2x_bmac2_enable(params, vars, is_lb);\n\telse\n\t\trc = bnx2x_bmac1_enable(params, vars, is_lb);\n\tREG_WR(bp, NIG_REG_XGXS_SERDES0_MODE_SEL + port*4, 0x1);\n\tREG_WR(bp, NIG_REG_XGXS_LANE_SEL_P0 + port*4, 0x0);\n\tREG_WR(bp, NIG_REG_EGRESS_EMAC0_PORT + port*4, 0x0);\n\tval = 0;\n\tif ((params->feature_config_flags &\n\t      FEATURE_CONFIG_PFC_ENABLED) ||\n\t    (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\n\t\tval = 1;\n\tREG_WR(bp, NIG_REG_BMAC0_PAUSE_OUT_EN + port*4, val);\n\tREG_WR(bp, NIG_REG_EGRESS_EMAC0_OUT_EN + port*4, 0x0);\n\tREG_WR(bp, NIG_REG_EMAC0_IN_EN + port*4, 0x0);\n\tREG_WR(bp, NIG_REG_EMAC0_PAUSE_OUT_EN + port*4, 0x0);\n\tREG_WR(bp, NIG_REG_BMAC0_IN_EN + port*4, 0x1);\n\tREG_WR(bp, NIG_REG_BMAC0_OUT_EN + port*4, 0x1);\n\n\tvars->mac_type = MAC_TYPE_BMAC;\n\treturn rc;\n}\n\nstatic void bnx2x_set_bmac_rx(struct bnx2x *bp, u32 chip_id, u8 port, u8 en)\n{\n\tu32 bmac_addr = port ? NIG_REG_INGRESS_BMAC1_MEM :\n\t\t\tNIG_REG_INGRESS_BMAC0_MEM;\n\tu32 wb_data[2];\n\tu32 nig_bmac_enable = REG_RD(bp, NIG_REG_BMAC0_REGS_OUT_EN + port*4);\n\n\tif (CHIP_IS_E2(bp))\n\t\tbmac_addr += BIGMAC2_REGISTER_BMAC_CONTROL;\n\telse\n\t\tbmac_addr += BIGMAC_REGISTER_BMAC_CONTROL;\n\t/* Only if the bmac is out of reset */\n\tif (REG_RD(bp, MISC_REG_RESET_REG_2) &\n\t\t\t(MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port) &&\n\t    nig_bmac_enable) {\n\t\t/* Clear Rx Enable bit in BMAC_CONTROL register */\n\t\tREG_RD_DMAE(bp, bmac_addr, wb_data, 2);\n\t\tif (en)\n\t\t\twb_data[0] |= BMAC_CONTROL_RX_ENABLE;\n\t\telse\n\t\t\twb_data[0] &= ~BMAC_CONTROL_RX_ENABLE;\n\t\tREG_WR_DMAE(bp, bmac_addr, wb_data, 2);\n\t\tusleep_range(1000, 2000);\n\t}\n}\n\nstatic int bnx2x_pbf_update(struct link_params *params, u32 flow_ctrl,\n\t\t\t    u32 line_speed)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\tu32 init_crd, crd;\n\tu32 count = 1000;\n\n\t/* Disable port */\n\tREG_WR(bp, PBF_REG_DISABLE_NEW_TASK_PROC_P0 + port*4, 0x1);\n\n\t/* Wait for init credit */\n\tinit_crd = REG_RD(bp, PBF_REG_P0_INIT_CRD + port*4);\n\tcrd = REG_RD(bp, PBF_REG_P0_CREDIT + port*8);\n\tDP(NETIF_MSG_LINK, \"init_crd 0x%x  crd 0x%x\\n\", init_crd, crd);\n\n\twhile ((init_crd != crd) && count) {\n\t\tusleep_range(5000, 10000);\n\t\tcrd = REG_RD(bp, PBF_REG_P0_CREDIT + port*8);\n\t\tcount--;\n\t}\n\tcrd = REG_RD(bp, PBF_REG_P0_CREDIT + port*8);\n\tif (init_crd != crd) {\n\t\tDP(NETIF_MSG_LINK, \"BUG! init_crd 0x%x != crd 0x%x\\n\",\n\t\t\t  init_crd, crd);\n\t\treturn -EINVAL;\n\t}\n\n\tif (flow_ctrl & BNX2X_FLOW_CTRL_RX ||\n\t    line_speed == SPEED_10 ||\n\t    line_speed == SPEED_100 ||\n\t    line_speed == SPEED_1000 ||\n\t    line_speed == SPEED_2500) {\n\t\tREG_WR(bp, PBF_REG_P0_PAUSE_ENABLE + port*4, 1);\n\t\t/* Update threshold */\n\t\tREG_WR(bp, PBF_REG_P0_ARB_THRSH + port*4, 0);\n\t\t/* Update init credit */\n\t\tinit_crd = 778;\t\t/* (800-18-4) */\n\n\t} else {\n\t\tu32 thresh = (ETH_MAX_JUMBO_PACKET_SIZE +\n\t\t\t      ETH_OVERHEAD)/16;\n\t\tREG_WR(bp, PBF_REG_P0_PAUSE_ENABLE + port*4, 0);\n\t\t/* Update threshold */\n\t\tREG_WR(bp, PBF_REG_P0_ARB_THRSH + port*4, thresh);\n\t\t/* Update init credit */\n\t\tswitch (line_speed) {\n\t\tcase SPEED_10000:\n\t\t\tinit_crd = thresh + 553 - 22;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDP(NETIF_MSG_LINK, \"Invalid line_speed 0x%x\\n\",\n\t\t\t\t  line_speed);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tREG_WR(bp, PBF_REG_P0_INIT_CRD + port*4, init_crd);\n\tDP(NETIF_MSG_LINK, \"PBF updated to speed %d credit %d\\n\",\n\t\t line_speed, init_crd);\n\n\t/* Probe the credit changes */\n\tREG_WR(bp, PBF_REG_INIT_P0 + port*4, 0x1);\n\tusleep_range(5000, 10000);\n\tREG_WR(bp, PBF_REG_INIT_P0 + port*4, 0x0);\n\n\t/* Enable port */\n\tREG_WR(bp, PBF_REG_DISABLE_NEW_TASK_PROC_P0 + port*4, 0x0);\n\treturn 0;\n}\n\n/**\n * bnx2x_get_emac_base - retrive emac base address\n *\n * @bp:\t\t\tdriver handle\n * @mdc_mdio_access:\taccess type\n * @port:\t\tport id\n *\n * This function selects the MDC/MDIO access (through emac0 or\n * emac1) depend on the mdc_mdio_access, port, port swapped. Each\n * phy has a default access mode, which could also be overridden\n * by nvram configuration. This parameter, whether this is the\n * default phy configuration, or the nvram overrun\n * configuration, is passed here as mdc_mdio_access and selects\n * the emac_base for the CL45 read/writes operations\n */\nstatic u32 bnx2x_get_emac_base(struct bnx2x *bp,\n\t\t\t       u32 mdc_mdio_access, u8 port)\n{\n\tu32 emac_base = 0;\n\tswitch (mdc_mdio_access) {\n\tcase SHARED_HW_CFG_MDC_MDIO_ACCESS1_PHY_TYPE:\n\t\tbreak;\n\tcase SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC0:\n\t\tif (REG_RD(bp, NIG_REG_PORT_SWAP))\n\t\t\temac_base = GRCBASE_EMAC1;\n\t\telse\n\t\t\temac_base = GRCBASE_EMAC0;\n\t\tbreak;\n\tcase SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC1:\n\t\tif (REG_RD(bp, NIG_REG_PORT_SWAP))\n\t\t\temac_base = GRCBASE_EMAC0;\n\t\telse\n\t\t\temac_base = GRCBASE_EMAC1;\n\t\tbreak;\n\tcase SHARED_HW_CFG_MDC_MDIO_ACCESS1_BOTH:\n\t\temac_base = (port) ? GRCBASE_EMAC1 : GRCBASE_EMAC0;\n\t\tbreak;\n\tcase SHARED_HW_CFG_MDC_MDIO_ACCESS1_SWAPPED:\n\t\temac_base = (port) ? GRCBASE_EMAC0 : GRCBASE_EMAC1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn emac_base;\n\n}\n\n/******************************************************************/\n/*\t\t\tCL22 access functions\t\t\t  */\n/******************************************************************/\nstatic int bnx2x_cl22_write(struct bnx2x *bp,\n\t\t\t\t       struct bnx2x_phy *phy,\n\t\t\t\t       u16 reg, u16 val)\n{\n\tu32 tmp, mode;\n\tu8 i;\n\tint rc = 0;\n\t/* Switch to CL22 */\n\tmode = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE);\n\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE,\n\t       mode & ~EMAC_MDIO_MODE_CLAUSE_45);\n\n\t/* Address */\n\ttmp = ((phy->addr << 21) | (reg << 16) | val |\n\t       EMAC_MDIO_COMM_COMMAND_WRITE_22 |\n\t       EMAC_MDIO_COMM_START_BUSY);\n\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, tmp);\n\n\tfor (i = 0; i < 50; i++) {\n\t\tudelay(10);\n\n\t\ttmp = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM);\n\t\tif (!(tmp & EMAC_MDIO_COMM_START_BUSY)) {\n\t\t\tudelay(5);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tmp & EMAC_MDIO_COMM_START_BUSY) {\n\t\tDP(NETIF_MSG_LINK, \"write phy register failed\\n\");\n\t\trc = -EFAULT;\n\t}\n\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE, mode);\n\treturn rc;\n}\n\nstatic int bnx2x_cl22_read(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_phy *phy,\n\t\t\t\t      u16 reg, u16 *ret_val)\n{\n\tu32 val, mode;\n\tu16 i;\n\tint rc = 0;\n\n\t/* Switch to CL22 */\n\tmode = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE);\n\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE,\n\t       mode & ~EMAC_MDIO_MODE_CLAUSE_45);\n\n\t/* Address */\n\tval = ((phy->addr << 21) | (reg << 16) |\n\t       EMAC_MDIO_COMM_COMMAND_READ_22 |\n\t       EMAC_MDIO_COMM_START_BUSY);\n\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, val);\n\n\tfor (i = 0; i < 50; i++) {\n\t\tudelay(10);\n\n\t\tval = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM);\n\t\tif (!(val & EMAC_MDIO_COMM_START_BUSY)) {\n\t\t\t*ret_val = (u16)(val & EMAC_MDIO_COMM_DATA);\n\t\t\tudelay(5);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (val & EMAC_MDIO_COMM_START_BUSY) {\n\t\tDP(NETIF_MSG_LINK, \"read phy register failed\\n\");\n\n\t\t*ret_val = 0;\n\t\trc = -EFAULT;\n\t}\n\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE, mode);\n\treturn rc;\n}\n\n/******************************************************************/\n/*\t\t\tCL45 access functions\t\t\t  */\n/******************************************************************/\nstatic int bnx2x_cl45_read(struct bnx2x *bp, struct bnx2x_phy *phy,\n\t\t\t   u8 devad, u16 reg, u16 *ret_val)\n{\n\tu32 val;\n\tu16 i;\n\tint rc = 0;\n\tu32 chip_id;\n\tif (phy->flags & FLAGS_MDC_MDIO_WA_G) {\n\t\tchip_id = (REG_RD(bp, MISC_REG_CHIP_NUM) << 16) |\n\t\t\t  ((REG_RD(bp, MISC_REG_CHIP_REV) & 0xf) << 12);\n\t\tbnx2x_set_mdio_clk(bp, chip_id, phy->mdio_ctrl);\n\t}\n\n\tif (phy->flags & FLAGS_MDC_MDIO_WA_B0)\n\t\tbnx2x_bits_en(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_STATUS,\n\t\t\t      EMAC_MDIO_STATUS_10MB);\n\t/* Address */\n\tval = ((phy->addr << 21) | (devad << 16) | reg |\n\t       EMAC_MDIO_COMM_COMMAND_ADDRESS |\n\t       EMAC_MDIO_COMM_START_BUSY);\n\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, val);\n\n\tfor (i = 0; i < 50; i++) {\n\t\tudelay(10);\n\n\t\tval = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM);\n\t\tif (!(val & EMAC_MDIO_COMM_START_BUSY)) {\n\t\t\tudelay(5);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (val & EMAC_MDIO_COMM_START_BUSY) {\n\t\tDP(NETIF_MSG_LINK, \"read phy register failed\\n\");\n\t\tnetdev_err(bp->dev,  \"MDC/MDIO access timeout\\n\");\n\t\t*ret_val = 0;\n\t\trc = -EFAULT;\n\t} else {\n\t\t/* Data */\n\t\tval = ((phy->addr << 21) | (devad << 16) |\n\t\t       EMAC_MDIO_COMM_COMMAND_READ_45 |\n\t\t       EMAC_MDIO_COMM_START_BUSY);\n\t\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, val);\n\n\t\tfor (i = 0; i < 50; i++) {\n\t\t\tudelay(10);\n\n\t\t\tval = REG_RD(bp, phy->mdio_ctrl +\n\t\t\t\t     EMAC_REG_EMAC_MDIO_COMM);\n\t\t\tif (!(val & EMAC_MDIO_COMM_START_BUSY)) {\n\t\t\t\t*ret_val = (u16)(val & EMAC_MDIO_COMM_DATA);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (val & EMAC_MDIO_COMM_START_BUSY) {\n\t\t\tDP(NETIF_MSG_LINK, \"read phy register failed\\n\");\n\t\t\tnetdev_err(bp->dev,  \"MDC/MDIO access timeout\\n\");\n\t\t\t*ret_val = 0;\n\t\t\trc = -EFAULT;\n\t\t}\n\t}\n\t/* Work around for E3 A0 */\n\tif (phy->flags & FLAGS_MDC_MDIO_WA) {\n\t\tphy->flags ^= FLAGS_DUMMY_READ;\n\t\tif (phy->flags & FLAGS_DUMMY_READ) {\n\t\t\tu16 temp_val;\n\t\t\tbnx2x_cl45_read(bp, phy, devad, 0xf, &temp_val);\n\t\t}\n\t}\n\n\tif (phy->flags & FLAGS_MDC_MDIO_WA_B0)\n\t\tbnx2x_bits_dis(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_STATUS,\n\t\t\t       EMAC_MDIO_STATUS_10MB);\n\treturn rc;\n}\n\nstatic int bnx2x_cl45_write(struct bnx2x *bp, struct bnx2x_phy *phy,\n\t\t\t    u8 devad, u16 reg, u16 val)\n{\n\tu32 tmp;\n\tu8 i;\n\tint rc = 0;\n\tu32 chip_id;\n\tif (phy->flags & FLAGS_MDC_MDIO_WA_G) {\n\t\tchip_id = (REG_RD(bp, MISC_REG_CHIP_NUM) << 16) |\n\t\t\t  ((REG_RD(bp, MISC_REG_CHIP_REV) & 0xf) << 12);\n\t\tbnx2x_set_mdio_clk(bp, chip_id, phy->mdio_ctrl);\n\t}\n\n\tif (phy->flags & FLAGS_MDC_MDIO_WA_B0)\n\t\tbnx2x_bits_en(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_STATUS,\n\t\t\t      EMAC_MDIO_STATUS_10MB);\n\n\t/* Address */\n\ttmp = ((phy->addr << 21) | (devad << 16) | reg |\n\t       EMAC_MDIO_COMM_COMMAND_ADDRESS |\n\t       EMAC_MDIO_COMM_START_BUSY);\n\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, tmp);\n\n\tfor (i = 0; i < 50; i++) {\n\t\tudelay(10);\n\n\t\ttmp = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM);\n\t\tif (!(tmp & EMAC_MDIO_COMM_START_BUSY)) {\n\t\t\tudelay(5);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tmp & EMAC_MDIO_COMM_START_BUSY) {\n\t\tDP(NETIF_MSG_LINK, \"write phy register failed\\n\");\n\t\tnetdev_err(bp->dev,  \"MDC/MDIO access timeout\\n\");\n\t\trc = -EFAULT;\n\t} else {\n\t\t/* Data */\n\t\ttmp = ((phy->addr << 21) | (devad << 16) | val |\n\t\t       EMAC_MDIO_COMM_COMMAND_WRITE_45 |\n\t\t       EMAC_MDIO_COMM_START_BUSY);\n\t\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, tmp);\n\n\t\tfor (i = 0; i < 50; i++) {\n\t\t\tudelay(10);\n\n\t\t\ttmp = REG_RD(bp, phy->mdio_ctrl +\n\t\t\t\t     EMAC_REG_EMAC_MDIO_COMM);\n\t\t\tif (!(tmp & EMAC_MDIO_COMM_START_BUSY)) {\n\t\t\t\tudelay(5);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (tmp & EMAC_MDIO_COMM_START_BUSY) {\n\t\t\tDP(NETIF_MSG_LINK, \"write phy register failed\\n\");\n\t\t\tnetdev_err(bp->dev,  \"MDC/MDIO access timeout\\n\");\n\t\t\trc = -EFAULT;\n\t\t}\n\t}\n\t/* Work around for E3 A0 */\n\tif (phy->flags & FLAGS_MDC_MDIO_WA) {\n\t\tphy->flags ^= FLAGS_DUMMY_READ;\n\t\tif (phy->flags & FLAGS_DUMMY_READ) {\n\t\t\tu16 temp_val;\n\t\t\tbnx2x_cl45_read(bp, phy, devad, 0xf, &temp_val);\n\t\t}\n\t}\n\tif (phy->flags & FLAGS_MDC_MDIO_WA_B0)\n\t\tbnx2x_bits_dis(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_STATUS,\n\t\t\t       EMAC_MDIO_STATUS_10MB);\n\treturn rc;\n}\n\n/******************************************************************/\n/*\t\t\tEEE section\t\t\t\t   */\n/******************************************************************/\nstatic u8 bnx2x_eee_has_cap(struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tif (REG_RD(bp, params->shmem2_base) <=\n\t\t   offsetof(struct shmem2_region, eee_status[params->port]))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int bnx2x_eee_nvram_to_time(u32 nvram_mode, u32 *idle_timer)\n{\n\tswitch (nvram_mode) {\n\tcase PORT_FEAT_CFG_EEE_POWER_MODE_BALANCED:\n\t\t*idle_timer = EEE_MODE_NVRAM_BALANCED_TIME;\n\t\tbreak;\n\tcase PORT_FEAT_CFG_EEE_POWER_MODE_AGGRESSIVE:\n\t\t*idle_timer = EEE_MODE_NVRAM_AGGRESSIVE_TIME;\n\t\tbreak;\n\tcase PORT_FEAT_CFG_EEE_POWER_MODE_LOW_LATENCY:\n\t\t*idle_timer = EEE_MODE_NVRAM_LATENCY_TIME;\n\t\tbreak;\n\tdefault:\n\t\t*idle_timer = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_eee_time_to_nvram(u32 idle_timer, u32 *nvram_mode)\n{\n\tswitch (idle_timer) {\n\tcase EEE_MODE_NVRAM_BALANCED_TIME:\n\t\t*nvram_mode = PORT_FEAT_CFG_EEE_POWER_MODE_BALANCED;\n\t\tbreak;\n\tcase EEE_MODE_NVRAM_AGGRESSIVE_TIME:\n\t\t*nvram_mode = PORT_FEAT_CFG_EEE_POWER_MODE_AGGRESSIVE;\n\t\tbreak;\n\tcase EEE_MODE_NVRAM_LATENCY_TIME:\n\t\t*nvram_mode = PORT_FEAT_CFG_EEE_POWER_MODE_LOW_LATENCY;\n\t\tbreak;\n\tdefault:\n\t\t*nvram_mode = PORT_FEAT_CFG_EEE_POWER_MODE_DISABLED;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 bnx2x_eee_calc_timer(struct link_params *params)\n{\n\tu32 eee_mode, eee_idle;\n\tstruct bnx2x *bp = params->bp;\n\n\tif (params->eee_mode & EEE_MODE_OVERRIDE_NVRAM) {\n\t\tif (params->eee_mode & EEE_MODE_OUTPUT_TIME) {\n\t\t\t/* time value in eee_mode --> used directly*/\n\t\t\teee_idle = params->eee_mode & EEE_MODE_TIMER_MASK;\n\t\t} else {\n\t\t\t/* hsi value in eee_mode --> time */\n\t\t\tif (bnx2x_eee_nvram_to_time(params->eee_mode &\n\t\t\t\t\t\t    EEE_MODE_NVRAM_MASK,\n\t\t\t\t\t\t    &eee_idle))\n\t\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t/* hsi values in nvram --> time*/\n\t\teee_mode = ((REG_RD(bp, params->shmem_base +\n\t\t\t\t    offsetof(struct shmem_region, dev_info.\n\t\t\t\t    port_feature_config[params->port].\n\t\t\t\t    eee_power_mode)) &\n\t\t\t     PORT_FEAT_CFG_EEE_POWER_MODE_MASK) >>\n\t\t\t    PORT_FEAT_CFG_EEE_POWER_MODE_SHIFT);\n\n\t\tif (bnx2x_eee_nvram_to_time(eee_mode, &eee_idle))\n\t\t\treturn 0;\n\t}\n\n\treturn eee_idle;\n}\n\nstatic int bnx2x_eee_set_timers(struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tu32 eee_idle = 0, eee_mode;\n\tstruct bnx2x *bp = params->bp;\n\n\teee_idle = bnx2x_eee_calc_timer(params);\n\n\tif (eee_idle) {\n\t\tREG_WR(bp, MISC_REG_CPMU_LP_IDLE_THR_P0 + (params->port << 2),\n\t\t       eee_idle);\n\t} else if ((params->eee_mode & EEE_MODE_ENABLE_LPI) &&\n\t\t   (params->eee_mode & EEE_MODE_OVERRIDE_NVRAM) &&\n\t\t   (params->eee_mode & EEE_MODE_OUTPUT_TIME)) {\n\t\tDP(NETIF_MSG_LINK, \"Error: Tx LPI is enabled with timer 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvars->eee_status &= ~(SHMEM_EEE_TIMER_MASK | SHMEM_EEE_TIME_OUTPUT_BIT);\n\tif (params->eee_mode & EEE_MODE_OUTPUT_TIME) {\n\t\t/* eee_idle in 1u --> eee_status in 16u */\n\t\teee_idle >>= 4;\n\t\tvars->eee_status |= (eee_idle & SHMEM_EEE_TIMER_MASK) |\n\t\t\t\t    SHMEM_EEE_TIME_OUTPUT_BIT;\n\t} else {\n\t\tif (bnx2x_eee_time_to_nvram(eee_idle, &eee_mode))\n\t\t\treturn -EINVAL;\n\t\tvars->eee_status |= eee_mode;\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_eee_initial_config(struct link_params *params,\n\t\t\t\t     struct link_vars *vars, u8 mode)\n{\n\tvars->eee_status |= ((u32) mode) << SHMEM_EEE_SUPPORTED_SHIFT;\n\n\t/* Propagate params' bits --> vars (for migration exposure) */\n\tif (params->eee_mode & EEE_MODE_ENABLE_LPI)\n\t\tvars->eee_status |= SHMEM_EEE_LPI_REQUESTED_BIT;\n\telse\n\t\tvars->eee_status &= ~SHMEM_EEE_LPI_REQUESTED_BIT;\n\n\tif (params->eee_mode & EEE_MODE_ADV_LPI)\n\t\tvars->eee_status |= SHMEM_EEE_REQUESTED_BIT;\n\telse\n\t\tvars->eee_status &= ~SHMEM_EEE_REQUESTED_BIT;\n\n\treturn bnx2x_eee_set_timers(params, vars);\n}\n\nstatic int bnx2x_eee_disable(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params,\n\t\t\t\tstruct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\t/* Make Certain LPI is disabled */\n\tREG_WR(bp, MISC_REG_CPMU_LP_FW_ENABLE_P0 + (params->port << 2), 0);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_EEE_ADV, 0x0);\n\n\tvars->eee_status &= ~SHMEM_EEE_ADV_STATUS_MASK;\n\n\treturn 0;\n}\n\nstatic int bnx2x_eee_advertise(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params,\n\t\t\t\t  struct link_vars *vars, u8 modes)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val = 0;\n\n\t/* Mask events preventing LPI generation */\n\tREG_WR(bp, MISC_REG_CPMU_LP_MASK_EXT_P0 + (params->port << 2), 0xfc20);\n\n\tif (modes & SHMEM_EEE_10G_ADV) {\n\t\tDP(NETIF_MSG_LINK, \"Advertise 10GBase-T EEE\\n\");\n\t\tval |= 0x8;\n\t}\n\tif (modes & SHMEM_EEE_1G_ADV) {\n\t\tDP(NETIF_MSG_LINK, \"Advertise 1GBase-T EEE\\n\");\n\t\tval |= 0x4;\n\t}\n\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_EEE_ADV, val);\n\n\tvars->eee_status &= ~SHMEM_EEE_ADV_STATUS_MASK;\n\tvars->eee_status |= (modes << SHMEM_EEE_ADV_STATUS_SHIFT);\n\n\treturn 0;\n}\n\nstatic void bnx2x_update_mng_eee(struct link_params *params, u32 eee_status)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tif (bnx2x_eee_has_cap(params))\n\t\tREG_WR(bp, params->shmem2_base +\n\t\t       offsetof(struct shmem2_region,\n\t\t\t\teee_status[params->port]), eee_status);\n}\n\nstatic void bnx2x_eee_an_resolve(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params,\n\t\t\t\t  struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 adv = 0, lp = 0;\n\tu32 lp_adv = 0;\n\tu8 neg = 0;\n\n\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_EEE_ADV, &adv);\n\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_LP_EEE_ADV, &lp);\n\n\tif (lp & 0x2) {\n\t\tlp_adv |= SHMEM_EEE_100M_ADV;\n\t\tif (adv & 0x2) {\n\t\t\tif (vars->line_speed == SPEED_100)\n\t\t\t\tneg = 1;\n\t\t\tDP(NETIF_MSG_LINK, \"EEE negotiated - 100M\\n\");\n\t\t}\n\t}\n\tif (lp & 0x14) {\n\t\tlp_adv |= SHMEM_EEE_1G_ADV;\n\t\tif (adv & 0x14) {\n\t\t\tif (vars->line_speed == SPEED_1000)\n\t\t\t\tneg = 1;\n\t\t\tDP(NETIF_MSG_LINK, \"EEE negotiated - 1G\\n\");\n\t\t}\n\t}\n\tif (lp & 0x68) {\n\t\tlp_adv |= SHMEM_EEE_10G_ADV;\n\t\tif (adv & 0x68) {\n\t\t\tif (vars->line_speed == SPEED_10000)\n\t\t\t\tneg = 1;\n\t\t\tDP(NETIF_MSG_LINK, \"EEE negotiated - 10G\\n\");\n\t\t}\n\t}\n\n\tvars->eee_status &= ~SHMEM_EEE_LP_ADV_STATUS_MASK;\n\tvars->eee_status |= (lp_adv << SHMEM_EEE_LP_ADV_STATUS_SHIFT);\n\n\tif (neg) {\n\t\tDP(NETIF_MSG_LINK, \"EEE is active\\n\");\n\t\tvars->eee_status |= SHMEM_EEE_ACTIVE_BIT;\n\t}\n\n}\n\n/******************************************************************/\n/*\t\t\tBSC access functions from E3\t          */\n/******************************************************************/\nstatic void bnx2x_bsc_module_sel(struct link_params *params)\n{\n\tint idx;\n\tu32 board_cfg, sfp_ctrl;\n\tu32 i2c_pins[I2C_SWITCH_WIDTH], i2c_val[I2C_SWITCH_WIDTH];\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\t/* Read I2C output PINs */\n\tboard_cfg = REG_RD(bp, params->shmem_base +\n\t\t\t   offsetof(struct shmem_region,\n\t\t\t\t    dev_info.shared_hw_config.board));\n\ti2c_pins[I2C_BSC0] = board_cfg & SHARED_HW_CFG_E3_I2C_MUX0_MASK;\n\ti2c_pins[I2C_BSC1] = (board_cfg & SHARED_HW_CFG_E3_I2C_MUX1_MASK) >>\n\t\t\tSHARED_HW_CFG_E3_I2C_MUX1_SHIFT;\n\n\t/* Read I2C output value */\n\tsfp_ctrl = REG_RD(bp, params->shmem_base +\n\t\t\t  offsetof(struct shmem_region,\n\t\t\t\t dev_info.port_hw_config[port].e3_cmn_pin_cfg));\n\ti2c_val[I2C_BSC0] = (sfp_ctrl & PORT_HW_CFG_E3_I2C_MUX0_MASK) > 0;\n\ti2c_val[I2C_BSC1] = (sfp_ctrl & PORT_HW_CFG_E3_I2C_MUX1_MASK) > 0;\n\tDP(NETIF_MSG_LINK, \"Setting BSC switch\\n\");\n\tfor (idx = 0; idx < I2C_SWITCH_WIDTH; idx++)\n\t\tbnx2x_set_cfg_pin(bp, i2c_pins[idx], i2c_val[idx]);\n}\n\nstatic int bnx2x_bsc_read(struct link_params *params,\n\t\t\t  struct bnx2x *bp,\n\t\t\t  u8 sl_devid,\n\t\t\t  u16 sl_addr,\n\t\t\t  u8 lc_addr,\n\t\t\t  u8 xfer_cnt,\n\t\t\t  u32 *data_array)\n{\n\tu64 t0, delta;\n\tu32 val, i;\n\tint rc = 0;\n\n\tif (xfer_cnt > 16) {\n\t\tDP(NETIF_MSG_LINK, \"invalid xfer_cnt %d. Max is 16 bytes\\n\",\n\t\t\t\t\txfer_cnt);\n\t\treturn -EINVAL;\n\t}\n\tbnx2x_bsc_module_sel(params);\n\n\txfer_cnt = 16 - lc_addr;\n\n\t/* Enable the engine */\n\tval = REG_RD(bp, MCP_REG_MCPR_IMC_COMMAND);\n\tval |= MCPR_IMC_COMMAND_ENABLE;\n\tREG_WR(bp, MCP_REG_MCPR_IMC_COMMAND, val);\n\n\t/* Program slave device ID */\n\tval = (sl_devid << 16) | sl_addr;\n\tREG_WR(bp, MCP_REG_MCPR_IMC_SLAVE_CONTROL, val);\n\n\t/* Start xfer with 0 byte to update the address pointer ???*/\n\tval = (MCPR_IMC_COMMAND_ENABLE) |\n\t      (MCPR_IMC_COMMAND_WRITE_OP <<\n\t\tMCPR_IMC_COMMAND_OPERATION_BITSHIFT) |\n\t\t(lc_addr << MCPR_IMC_COMMAND_TRANSFER_ADDRESS_BITSHIFT) | (0);\n\tREG_WR(bp, MCP_REG_MCPR_IMC_COMMAND, val);\n\n\t/* Poll for completion */\n\tt0 = ktime_get_ns();\n\tval = REG_RD(bp, MCP_REG_MCPR_IMC_COMMAND);\n\twhile (((val >> MCPR_IMC_COMMAND_IMC_STATUS_BITSHIFT) & 0x3) != 1) {\n\t\tdelta = ktime_get_ns() - t0;\n\t\tif (delta > 10 * NSEC_PER_MSEC) {\n\t\t\tDP(NETIF_MSG_LINK, \"wr 0 byte timed out after %Lu ns\\n\",\n\t\t\t\t\t   delta);\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(10, 20);\n\t\tval = REG_RD(bp, MCP_REG_MCPR_IMC_COMMAND);\n\t}\n\tif (rc == -EFAULT)\n\t\treturn rc;\n\n\t/* Start xfer with read op */\n\tval = (MCPR_IMC_COMMAND_ENABLE) |\n\t\t(MCPR_IMC_COMMAND_READ_OP <<\n\t\tMCPR_IMC_COMMAND_OPERATION_BITSHIFT) |\n\t\t(lc_addr << MCPR_IMC_COMMAND_TRANSFER_ADDRESS_BITSHIFT) |\n\t\t  (xfer_cnt);\n\tREG_WR(bp, MCP_REG_MCPR_IMC_COMMAND, val);\n\n\t/* Poll for completion */\n\tt0 = ktime_get_ns();\n\tval = REG_RD(bp, MCP_REG_MCPR_IMC_COMMAND);\n\twhile (((val >> MCPR_IMC_COMMAND_IMC_STATUS_BITSHIFT) & 0x3) != 1) {\n\t\tdelta = ktime_get_ns() - t0;\n\t\tif (delta > 10 * NSEC_PER_MSEC) {\n\t\t\tDP(NETIF_MSG_LINK, \"rd op timed out after %Lu ns\\n\",\n\t\t\t\t\t   delta);\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(10, 20);\n\t\tval = REG_RD(bp, MCP_REG_MCPR_IMC_COMMAND);\n\t}\n\tif (rc == -EFAULT)\n\t\treturn rc;\n\n\tfor (i = (lc_addr >> 2); i < 4; i++) {\n\t\tdata_array[i] = REG_RD(bp, (MCP_REG_MCPR_IMC_DATAREG0 + i*4));\n#ifdef __BIG_ENDIAN\n\t\tdata_array[i] = ((data_array[i] & 0x000000ff) << 24) |\n\t\t\t\t((data_array[i] & 0x0000ff00) << 8) |\n\t\t\t\t((data_array[i] & 0x00ff0000) >> 8) |\n\t\t\t\t((data_array[i] & 0xff000000) >> 24);\n#endif\n\t}\n\treturn rc;\n}\n\nstatic void bnx2x_cl45_read_or_write(struct bnx2x *bp, struct bnx2x_phy *phy,\n\t\t\t\t     u8 devad, u16 reg, u16 or_val)\n{\n\tu16 val;\n\tbnx2x_cl45_read(bp, phy, devad, reg, &val);\n\tbnx2x_cl45_write(bp, phy, devad, reg, val | or_val);\n}\n\nstatic void bnx2x_cl45_read_and_write(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_phy *phy,\n\t\t\t\t      u8 devad, u16 reg, u16 and_val)\n{\n\tu16 val;\n\tbnx2x_cl45_read(bp, phy, devad, reg, &val);\n\tbnx2x_cl45_write(bp, phy, devad, reg, val & and_val);\n}\n\nint bnx2x_phy_read(struct link_params *params, u8 phy_addr,\n\t\t   u8 devad, u16 reg, u16 *ret_val)\n{\n\tu8 phy_index;\n\t/* Probe for the phy according to the given phy_addr, and execute\n\t * the read request on it\n\t */\n\tfor (phy_index = 0; phy_index < params->num_phys; phy_index++) {\n\t\tif (params->phy[phy_index].addr == phy_addr) {\n\t\t\treturn bnx2x_cl45_read(params->bp,\n\t\t\t\t\t       &params->phy[phy_index], devad,\n\t\t\t\t\t       reg, ret_val);\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nint bnx2x_phy_write(struct link_params *params, u8 phy_addr,\n\t\t    u8 devad, u16 reg, u16 val)\n{\n\tu8 phy_index;\n\t/* Probe for the phy according to the given phy_addr, and execute\n\t * the write request on it\n\t */\n\tfor (phy_index = 0; phy_index < params->num_phys; phy_index++) {\n\t\tif (params->phy[phy_index].addr == phy_addr) {\n\t\t\treturn bnx2x_cl45_write(params->bp,\n\t\t\t\t\t\t&params->phy[phy_index], devad,\n\t\t\t\t\t\treg, val);\n\t\t}\n\t}\n\treturn -EINVAL;\n}\nstatic u8 bnx2x_get_warpcore_lane(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params)\n{\n\tu8 lane = 0;\n\tstruct bnx2x *bp = params->bp;\n\tu32 path_swap, path_swap_ovr;\n\tu8 path, port;\n\n\tpath = BP_PATH(bp);\n\tport = params->port;\n\n\tif (bnx2x_is_4_port_mode(bp)) {\n\t\tu32 port_swap, port_swap_ovr;\n\n\t\t/* Figure out path swap value */\n\t\tpath_swap_ovr = REG_RD(bp, MISC_REG_FOUR_PORT_PATH_SWAP_OVWR);\n\t\tif (path_swap_ovr & 0x1)\n\t\t\tpath_swap = (path_swap_ovr & 0x2);\n\t\telse\n\t\t\tpath_swap = REG_RD(bp, MISC_REG_FOUR_PORT_PATH_SWAP);\n\n\t\tif (path_swap)\n\t\t\tpath = path ^ 1;\n\n\t\t/* Figure out port swap value */\n\t\tport_swap_ovr = REG_RD(bp, MISC_REG_FOUR_PORT_PORT_SWAP_OVWR);\n\t\tif (port_swap_ovr & 0x1)\n\t\t\tport_swap = (port_swap_ovr & 0x2);\n\t\telse\n\t\t\tport_swap = REG_RD(bp, MISC_REG_FOUR_PORT_PORT_SWAP);\n\n\t\tif (port_swap)\n\t\t\tport = port ^ 1;\n\n\t\tlane = (port<<1) + path;\n\t} else { /* Two port mode - no port swap */\n\n\t\t/* Figure out path swap value */\n\t\tpath_swap_ovr =\n\t\t\tREG_RD(bp, MISC_REG_TWO_PORT_PATH_SWAP_OVWR);\n\t\tif (path_swap_ovr & 0x1) {\n\t\t\tpath_swap = (path_swap_ovr & 0x2);\n\t\t} else {\n\t\t\tpath_swap =\n\t\t\t\tREG_RD(bp, MISC_REG_TWO_PORT_PATH_SWAP);\n\t\t}\n\t\tif (path_swap)\n\t\t\tpath = path ^ 1;\n\n\t\tlane = path << 1 ;\n\t}\n\treturn lane;\n}\n\nstatic void bnx2x_set_aer_mmd(struct link_params *params,\n\t\t\t      struct bnx2x_phy *phy)\n{\n\tu32 ser_lane;\n\tu16 offset, aer_val;\n\tstruct bnx2x *bp = params->bp;\n\tser_lane = ((params->lane_config &\n\t\t     PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK) >>\n\t\t     PORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT);\n\n\toffset = (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) ?\n\t\t(phy->addr + ser_lane) : 0;\n\n\tif (USES_WARPCORE(bp)) {\n\t\taer_val = bnx2x_get_warpcore_lane(phy, params);\n\t\t/* In Dual-lane mode, two lanes are joined together,\n\t\t * so in order to configure them, the AER broadcast method is\n\t\t * used here.\n\t\t * 0x200 is the broadcast address for lanes 0,1\n\t\t * 0x201 is the broadcast address for lanes 2,3\n\t\t */\n\t\tif (phy->flags & FLAGS_WC_DUAL_MODE)\n\t\t\taer_val = (aer_val >> 1) | 0x200;\n\t} else if (CHIP_IS_E2(bp))\n\t\taer_val = 0x3800 + offset - 1;\n\telse\n\t\taer_val = 0x3800 + offset;\n\n\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t  MDIO_AER_BLOCK_AER_REG, aer_val);\n\n}\n\n/******************************************************************/\n/*\t\t\tInternal phy section\t\t\t  */\n/******************************************************************/\n\nstatic void bnx2x_set_serdes_access(struct bnx2x *bp, u8 port)\n{\n\tu32 emac_base = (port) ? GRCBASE_EMAC1 : GRCBASE_EMAC0;\n\n\t/* Set Clause 22 */\n\tREG_WR(bp, NIG_REG_SERDES0_CTRL_MD_ST + port*0x10, 1);\n\tREG_WR(bp, emac_base + EMAC_REG_EMAC_MDIO_COMM, 0x245f8000);\n\tudelay(500);\n\tREG_WR(bp, emac_base + EMAC_REG_EMAC_MDIO_COMM, 0x245d000f);\n\tudelay(500);\n\t /* Set Clause 45 */\n\tREG_WR(bp, NIG_REG_SERDES0_CTRL_MD_ST + port*0x10, 0);\n}\n\nstatic void bnx2x_serdes_deassert(struct bnx2x *bp, u8 port)\n{\n\tu32 val;\n\n\tDP(NETIF_MSG_LINK, \"bnx2x_serdes_deassert\\n\");\n\n\tval = SERDES_RESET_BITS << (port*16);\n\n\t/* Reset and unreset the SerDes/XGXS */\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_CLEAR, val);\n\tudelay(500);\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_SET, val);\n\n\tbnx2x_set_serdes_access(bp, port);\n\n\tREG_WR(bp, NIG_REG_SERDES0_CTRL_MD_DEVAD + port*0x10,\n\t       DEFAULT_PHY_DEV_ADDR);\n}\n\nstatic void bnx2x_xgxs_specific_func(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params,\n\t\t\t\t     u32 action)\n{\n\tstruct bnx2x *bp = params->bp;\n\tswitch (action) {\n\tcase PHY_INIT:\n\t\t/* Set correct devad */\n\t\tREG_WR(bp, NIG_REG_XGXS0_CTRL_MD_ST + params->port*0x18, 0);\n\t\tREG_WR(bp, NIG_REG_XGXS0_CTRL_MD_DEVAD + params->port*0x18,\n\t\t       phy->def_md_devad);\n\t\tbreak;\n\t}\n}\n\nstatic void bnx2x_xgxs_deassert(struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port;\n\tu32 val;\n\tDP(NETIF_MSG_LINK, \"bnx2x_xgxs_deassert\\n\");\n\tport = params->port;\n\n\tval = XGXS_RESET_BITS << (port*16);\n\n\t/* Reset and unreset the SerDes/XGXS */\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_CLEAR, val);\n\tudelay(500);\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_SET, val);\n\tbnx2x_xgxs_specific_func(&params->phy[INT_PHY], params,\n\t\t\t\t PHY_INIT);\n}\n\nstatic void bnx2x_calc_ieee_aneg_adv(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params, u16 *ieee_fc)\n{\n\tstruct bnx2x *bp = params->bp;\n\t*ieee_fc = MDIO_COMBO_IEEE0_AUTO_NEG_ADV_FULL_DUPLEX;\n\t/* Resolve pause mode and advertisement Please refer to Table\n\t * 28B-3 of the 802.3ab-1999 spec\n\t */\n\n\tswitch (phy->req_flow_ctrl) {\n\tcase BNX2X_FLOW_CTRL_AUTO:\n\t\tswitch (params->req_fc_auto_adv) {\n\t\tcase BNX2X_FLOW_CTRL_BOTH:\n\t\tcase BNX2X_FLOW_CTRL_RX:\n\t\t\t*ieee_fc |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH;\n\t\t\tbreak;\n\t\tcase BNX2X_FLOW_CTRL_TX:\n\t\t\t*ieee_fc |=\n\t\t\t\tMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BNX2X_FLOW_CTRL_TX:\n\t\t*ieee_fc |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC;\n\t\tbreak;\n\n\tcase BNX2X_FLOW_CTRL_RX:\n\tcase BNX2X_FLOW_CTRL_BOTH:\n\t\t*ieee_fc |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH;\n\t\tbreak;\n\n\tcase BNX2X_FLOW_CTRL_NONE:\n\tdefault:\n\t\t*ieee_fc |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_NONE;\n\t\tbreak;\n\t}\n\tDP(NETIF_MSG_LINK, \"ieee_fc = 0x%x\\n\", *ieee_fc);\n}\n\nstatic void set_phy_vars(struct link_params *params,\n\t\t\t struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 actual_phy_idx, phy_index, link_cfg_idx;\n\tu8 phy_config_swapped = params->multi_phy_config &\n\t\t\tPORT_HW_CFG_PHY_SWAPPED_ENABLED;\n\tfor (phy_index = INT_PHY; phy_index < params->num_phys;\n\t      phy_index++) {\n\t\tlink_cfg_idx = LINK_CONFIG_IDX(phy_index);\n\t\tactual_phy_idx = phy_index;\n\t\tif (phy_config_swapped) {\n\t\t\tif (phy_index == EXT_PHY1)\n\t\t\t\tactual_phy_idx = EXT_PHY2;\n\t\t\telse if (phy_index == EXT_PHY2)\n\t\t\t\tactual_phy_idx = EXT_PHY1;\n\t\t}\n\t\tparams->phy[actual_phy_idx].req_flow_ctrl =\n\t\t\tparams->req_flow_ctrl[link_cfg_idx];\n\n\t\tparams->phy[actual_phy_idx].req_line_speed =\n\t\t\tparams->req_line_speed[link_cfg_idx];\n\n\t\tparams->phy[actual_phy_idx].speed_cap_mask =\n\t\t\tparams->speed_cap_mask[link_cfg_idx];\n\n\t\tparams->phy[actual_phy_idx].req_duplex =\n\t\t\tparams->req_duplex[link_cfg_idx];\n\n\t\tif (params->req_line_speed[link_cfg_idx] ==\n\t\t    SPEED_AUTO_NEG)\n\t\t\tvars->link_status |= LINK_STATUS_AUTO_NEGOTIATE_ENABLED;\n\n\t\tDP(NETIF_MSG_LINK, \"req_flow_ctrl %x, req_line_speed %x,\"\n\t\t\t   \" speed_cap_mask %x\\n\",\n\t\t\t   params->phy[actual_phy_idx].req_flow_ctrl,\n\t\t\t   params->phy[actual_phy_idx].req_line_speed,\n\t\t\t   params->phy[actual_phy_idx].speed_cap_mask);\n\t}\n}\n\nstatic void bnx2x_ext_phy_set_pause(struct link_params *params,\n\t\t\t\t    struct bnx2x_phy *phy,\n\t\t\t\t    struct link_vars *vars)\n{\n\tu16 val;\n\tstruct bnx2x *bp = params->bp;\n\t/* Read modify write pause advertizing */\n\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_ADV_PAUSE, &val);\n\n\tval &= ~MDIO_AN_REG_ADV_PAUSE_BOTH;\n\n\t/* Please refer to Table 28B-3 of 802.3ab-1999 spec. */\n\tbnx2x_calc_ieee_aneg_adv(phy, params, &vars->ieee_fc);\n\tif ((vars->ieee_fc &\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) ==\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) {\n\t\tval |= MDIO_AN_REG_ADV_PAUSE_ASYMMETRIC;\n\t}\n\tif ((vars->ieee_fc &\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) ==\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) {\n\t\tval |= MDIO_AN_REG_ADV_PAUSE_PAUSE;\n\t}\n\tDP(NETIF_MSG_LINK, \"Ext phy AN advertize 0x%x\\n\", val);\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_ADV_PAUSE, val);\n}\n\nstatic void bnx2x_pause_resolve(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params,\n\t\t\t\tstruct link_vars *vars,\n\t\t\t\tu32 pause_result)\n{\n\tstruct bnx2x *bp = params->bp;\n\t\t\t\t\t\t/*  LD\t    LP\t */\n\tswitch (pause_result) {\t\t\t/* ASYM P ASYM P */\n\tcase 0xb:\t\t\t\t/*   1  0   1  1 */\n\t\tDP(NETIF_MSG_LINK, \"Flow Control: TX only\\n\");\n\t\tvars->flow_ctrl = BNX2X_FLOW_CTRL_TX;\n\t\tbreak;\n\n\tcase 0xe:\t\t\t\t/*   1  1   1  0 */\n\t\tDP(NETIF_MSG_LINK, \"Flow Control: RX only\\n\");\n\t\tvars->flow_ctrl = BNX2X_FLOW_CTRL_RX;\n\t\tbreak;\n\n\tcase 0x5:\t\t\t\t/*   0  1   0  1 */\n\tcase 0x7:\t\t\t\t/*   0  1   1  1 */\n\tcase 0xd:\t\t\t\t/*   1  1   0  1 */\n\tcase 0xf:\t\t\t\t/*   1  1   1  1 */\n\t\t/* If the user selected to advertise RX ONLY,\n\t\t * although we advertised both, need to enable\n\t\t * RX only.\n\t\t */\n\t\tif (params->req_fc_auto_adv == BNX2X_FLOW_CTRL_BOTH) {\n\t\t\tDP(NETIF_MSG_LINK, \"Flow Control: RX & TX\\n\");\n\t\t\tvars->flow_ctrl = BNX2X_FLOW_CTRL_BOTH;\n\t\t} else {\n\t\t\tDP(NETIF_MSG_LINK, \"Flow Control: RX only\\n\");\n\t\t\tvars->flow_ctrl = BNX2X_FLOW_CTRL_RX;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tDP(NETIF_MSG_LINK, \"Flow Control: None\\n\");\n\t\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\t\tbreak;\n\t}\n\tif (pause_result & (1<<0))\n\t\tvars->link_status |= LINK_STATUS_LINK_PARTNER_SYMMETRIC_PAUSE;\n\tif (pause_result & (1<<1))\n\t\tvars->link_status |= LINK_STATUS_LINK_PARTNER_ASYMMETRIC_PAUSE;\n\n}\n\nstatic void bnx2x_ext_phy_update_adv_fc(struct bnx2x_phy *phy,\n\t\t\t\t\tstruct link_params *params,\n\t\t\t\t\tstruct link_vars *vars)\n{\n\tu16 ld_pause;\t\t/* local */\n\tu16 lp_pause;\t\t/* link partner */\n\tu16 pause_result;\n\tstruct bnx2x *bp = params->bp;\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE) {\n\t\tbnx2x_cl22_read(bp, phy, 0x4, &ld_pause);\n\t\tbnx2x_cl22_read(bp, phy, 0x5, &lp_pause);\n\t} else if (CHIP_IS_E3(bp) &&\n\t\tSINGLE_MEDIA_DIRECT(params)) {\n\t\tu8 lane = bnx2x_get_warpcore_lane(phy, params);\n\t\tu16 gp_status, gp_mask;\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD, MDIO_WC_REG_GP2_STATUS_GP_2_4,\n\t\t\t\t&gp_status);\n\t\tgp_mask = (MDIO_WC_REG_GP2_STATUS_GP_2_4_CL73_AN_CMPL |\n\t\t\t   MDIO_WC_REG_GP2_STATUS_GP_2_4_CL37_LP_AN_CAP) <<\n\t\t\tlane;\n\t\tif ((gp_status & gp_mask) == gp_mask) {\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_AN_REG_ADV_PAUSE, &ld_pause);\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_AN_REG_LP_AUTO_NEG, &lp_pause);\n\t\t} else {\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_AN_REG_CL37_FC_LD, &ld_pause);\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_AN_REG_CL37_FC_LP, &lp_pause);\n\t\t\tld_pause = ((ld_pause &\n\t\t\t\t     MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH)\n\t\t\t\t    << 3);\n\t\t\tlp_pause = ((lp_pause &\n\t\t\t\t     MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH)\n\t\t\t\t    << 3);\n\t\t}\n\t} else {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_ADV_PAUSE, &ld_pause);\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_LP_AUTO_NEG, &lp_pause);\n\t}\n\tpause_result = (ld_pause &\n\t\t\tMDIO_AN_REG_ADV_PAUSE_MASK) >> 8;\n\tpause_result |= (lp_pause &\n\t\t\t MDIO_AN_REG_ADV_PAUSE_MASK) >> 10;\n\tDP(NETIF_MSG_LINK, \"Ext PHY pause result 0x%x\\n\", pause_result);\n\tbnx2x_pause_resolve(phy, params, vars, pause_result);\n\n}\n\nstatic u8 bnx2x_ext_phy_resolve_fc(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tu8 ret = 0;\n\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\tif (phy->req_flow_ctrl != BNX2X_FLOW_CTRL_AUTO) {\n\t\t/* Update the advertised flow-controled of LD/LP in AN */\n\t\tif (phy->req_line_speed == SPEED_AUTO_NEG)\n\t\t\tbnx2x_ext_phy_update_adv_fc(phy, params, vars);\n\t\t/* But set the flow-control result as the requested one */\n\t\tvars->flow_ctrl = phy->req_flow_ctrl;\n\t} else if (phy->req_line_speed != SPEED_AUTO_NEG)\n\t\tvars->flow_ctrl = params->req_fc_auto_adv;\n\telse if (vars->link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE) {\n\t\tret = 1;\n\t\tbnx2x_ext_phy_update_adv_fc(phy, params, vars);\n\t}\n\treturn ret;\n}\n/******************************************************************/\n/*\t\t\tWarpcore section\t\t\t  */\n/******************************************************************/\n/* The init_internal_warpcore should mirror the xgxs,\n * i.e. reset the lane (if needed), set aer for the\n * init configuration, and set/clear SGMII flag. Internal\n * phy init is done purely in phy_init stage.\n */\n#define WC_TX_DRIVER(post2, idriver, ipre, ifir) \\\n\t((post2 << MDIO_WC_REG_TX0_TX_DRIVER_POST2_COEFF_OFFSET) | \\\n\t (idriver << MDIO_WC_REG_TX0_TX_DRIVER_IDRIVER_OFFSET) | \\\n\t (ipre << MDIO_WC_REG_TX0_TX_DRIVER_IPRE_DRIVER_OFFSET) | \\\n\t (ifir << MDIO_WC_REG_TX0_TX_DRIVER_IFIR_OFFSET))\n\n#define WC_TX_FIR(post, main, pre) \\\n\t((post << MDIO_WC_REG_TX_FIR_TAP_POST_TAP_OFFSET) | \\\n\t (main << MDIO_WC_REG_TX_FIR_TAP_MAIN_TAP_OFFSET) | \\\n\t (pre << MDIO_WC_REG_TX_FIR_TAP_PRE_TAP_OFFSET))\n\nstatic void bnx2x_warpcore_enable_AN_KR2(struct bnx2x_phy *phy,\n\t\t\t\t\t struct link_params *params,\n\t\t\t\t\t struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 i;\n\tstatic struct bnx2x_reg_set reg_set[] = {\n\t\t/* Step 1 - Program the TX/RX alignment markers */\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL5, 0xa157},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL7, 0xcbe2},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL6, 0x7537},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL9, 0xa157},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_RX_CTRL11, 0xcbe2},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_RX_CTRL10, 0x7537},\n\t\t/* Step 2 - Configure the NP registers */\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_USERB0_CTRL, 0x000a},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CTRL1, 0x6400},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CTRL3, 0x0620},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CODE_FIELD, 0x0157},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI1, 0x6464},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI2, 0x3150},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI3, 0x3150},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_LD_BAM_CODE, 0x0157},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_LD_UD_CODE, 0x0620}\n\t};\n\tDP(NETIF_MSG_LINK, \"Enabling 20G-KR2\\n\");\n\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_CL49_USERB0_CTRL, (3<<6));\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\n\t\tbnx2x_cl45_write(bp, phy, reg_set[i].devad, reg_set[i].reg,\n\t\t\t\t reg_set[i].val);\n\n\t/* Start KR2 work-around timer which handles BCM8073 link-parner */\n\tparams->link_attr_sync |= LINK_ATTR_SYNC_KR2_ENABLE;\n\tbnx2x_update_link_attr(params, params->link_attr_sync);\n}\n\nstatic void bnx2x_disable_kr2(struct link_params *params,\n\t\t\t      struct link_vars *vars,\n\t\t\t      struct bnx2x_phy *phy)\n{\n\tstruct bnx2x *bp = params->bp;\n\tint i;\n\tstatic struct bnx2x_reg_set reg_set[] = {\n\t\t/* Step 1 - Program the TX/RX alignment markers */\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL5, 0x7690},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL7, 0xe647},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL6, 0xc4f0},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL9, 0x7690},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_RX_CTRL11, 0xe647},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_RX_CTRL10, 0xc4f0},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_USERB0_CTRL, 0x000c},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CTRL1, 0x6000},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CTRL3, 0x0000},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CODE_FIELD, 0x0002},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI1, 0x0000},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI2, 0x0af7},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI3, 0x0af7},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_LD_BAM_CODE, 0x0002},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_LD_UD_CODE, 0x0000}\n\t};\n\tDP(NETIF_MSG_LINK, \"Disabling 20G-KR2\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\n\t\tbnx2x_cl45_write(bp, phy, reg_set[i].devad, reg_set[i].reg,\n\t\t\t\t reg_set[i].val);\n\tparams->link_attr_sync &= ~LINK_ATTR_SYNC_KR2_ENABLE;\n\tbnx2x_update_link_attr(params, params->link_attr_sync);\n\n\tvars->check_kr2_recovery_cnt = CHECK_KR2_RECOVERY_CNT;\n}\n\nstatic void bnx2x_warpcore_set_lpi_passthrough(struct bnx2x_phy *phy,\n\t\t\t\t\t       struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tDP(NETIF_MSG_LINK, \"Configure WC for LPI pass through\\n\");\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_EEE_COMBO_CONTROL0, 0x7c);\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_DIGITAL4_MISC5, 0xc000);\n}\n\nstatic void bnx2x_warpcore_restart_AN_KR(struct bnx2x_phy *phy,\n\t\t\t\t\t struct link_params *params)\n{\n\t/* Restart autoneg on the leading lane only */\n\tstruct bnx2x *bp = params->bp;\n\tu16 lane = bnx2x_get_warpcore_lane(phy, params);\n\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t  MDIO_AER_BLOCK_AER_REG, lane);\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x1200);\n\n\t/* Restore AER */\n\tbnx2x_set_aer_mmd(params, phy);\n}\n\nstatic void bnx2x_warpcore_enable_AN_KR(struct bnx2x_phy *phy,\n\t\t\t\t\tstruct link_params *params,\n\t\t\t\t\tstruct link_vars *vars) {\n\tu16 lane, i, cl72_ctrl, an_adv = 0, val;\n\tu32 wc_lane_config;\n\tstruct bnx2x *bp = params->bp;\n\tstatic struct bnx2x_reg_set reg_set[] = {\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2, 0x7},\n\t\t{MDIO_PMA_DEVAD, MDIO_WC_REG_IEEE0BLK_AUTONEGNP, 0x0},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_RX66_CONTROL, 0x7415},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_MISC2, 0x6190},\n\t\t/* Disable Autoneg: re-enable it after adv is done. */\n\t\t{MDIO_AN_DEVAD, MDIO_WC_REG_IEEE0BLK_MIICNTL, 0},\n\t\t{MDIO_PMA_DEVAD, MDIO_WC_REG_PMD_KR_CONTROL, 0x2},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL72_USERB0_CL72_TX_FIR_TAP, 0},\n\t};\n\tDP(NETIF_MSG_LINK, \"Enable Auto Negotiation for KR\\n\");\n\t/* Set to default registers that may be overriden by 10G force */\n\tfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\n\t\tbnx2x_cl45_write(bp, phy, reg_set[i].devad, reg_set[i].reg,\n\t\t\t\t reg_set[i].val);\n\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL, &cl72_ctrl);\n\tcl72_ctrl &= 0x08ff;\n\tcl72_ctrl |= 0x3800;\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL, cl72_ctrl);\n\n\t/* Check adding advertisement for 1G KX */\n\tif (((vars->line_speed == SPEED_AUTO_NEG) &&\n\t     (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)) ||\n\t    (vars->line_speed == SPEED_1000)) {\n\t\tu16 addr = MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2;\n\t\tan_adv |= (1<<5);\n\n\t\t/* Enable CL37 1G Parallel Detect */\n\t\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD, addr, 0x1);\n\t\tDP(NETIF_MSG_LINK, \"Advertize 1G\\n\");\n\t}\n\tif (((vars->line_speed == SPEED_AUTO_NEG) &&\n\t     (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)) ||\n\t    (vars->line_speed ==  SPEED_10000)) {\n\t\t/* Check adding advertisement for 10G KR */\n\t\tan_adv |= (1<<7);\n\t\t/* Enable 10G Parallel Detect */\n\t\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t\t  MDIO_AER_BLOCK_AER_REG, 0);\n\n\t\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t MDIO_WC_REG_PAR_DET_10G_CTRL, 1);\n\t\tbnx2x_set_aer_mmd(params, phy);\n\t\tDP(NETIF_MSG_LINK, \"Advertize 10G\\n\");\n\t}\n\n\t/* Set Transmit PMD settings */\n\tlane = bnx2x_get_warpcore_lane(phy, params);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_TX0_TX_DRIVER + 0x10*lane,\n\t\t\t WC_TX_DRIVER(0x02, 0x06, 0x09, 0));\n\t/* Configure the next lane if dual mode */\n\tif (phy->flags & FLAGS_WC_DUAL_MODE)\n\t\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_TX0_TX_DRIVER + 0x10*(lane+1),\n\t\t\t\t WC_TX_DRIVER(0x02, 0x06, 0x09, 0));\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_CL72_USERB0_CL72_OS_DEF_CTRL,\n\t\t\t 0x03f0);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_CL72_USERB0_CL72_2P5_DEF_CTRL,\n\t\t\t 0x03f0);\n\n\t/* Advertised speeds */\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t MDIO_WC_REG_AN_IEEE1BLK_AN_ADVERTISEMENT1, an_adv);\n\n\t/* Advertised and set FEC (Forward Error Correction) */\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t MDIO_WC_REG_AN_IEEE1BLK_AN_ADVERTISEMENT2,\n\t\t\t (MDIO_WC_REG_AN_IEEE1BLK_AN_ADV2_FEC_ABILITY |\n\t\t\t  MDIO_WC_REG_AN_IEEE1BLK_AN_ADV2_FEC_REQ));\n\n\t/* Enable CL37 BAM */\n\tif (REG_RD(bp, params->shmem_base +\n\t\t   offsetof(struct shmem_region, dev_info.\n\t\t\t    port_hw_config[params->port].default_cfg)) &\n\t    PORT_HW_CFG_ENABLE_BAM_ON_KR_ENABLED) {\n\t\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t MDIO_WC_REG_DIGITAL6_MP5_NEXTPAGECTRL,\n\t\t\t\t\t 1);\n\t\tDP(NETIF_MSG_LINK, \"Enable CL37 BAM on KR\\n\");\n\t}\n\n\t/* Advertise pause */\n\tbnx2x_ext_phy_set_pause(params, phy, vars);\n\tvars->rx_tx_asic_rst = MAX_KR_LINK_RETRY;\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_DIGITAL5_MISC7, 0x100);\n\n\t/* Over 1G - AN local device user page 1 */\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_DIGITAL3_UP1, 0x1f);\n\n\tif (((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t     (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_20G)) ||\n\t    (phy->req_line_speed == SPEED_20000)) {\n\n\t\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t\t  MDIO_AER_BLOCK_AER_REG, lane);\n\n\t\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t MDIO_WC_REG_RX1_PCI_CTRL + (0x10*lane),\n\t\t\t\t\t (1<<11));\n\n\t\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_XGXS_X2_CONTROL3, 0x7);\n\t\tbnx2x_set_aer_mmd(params, phy);\n\n\t\tbnx2x_warpcore_enable_AN_KR2(phy, params, vars);\n\t} else {\n\t\t/* Enable Auto-Detect to support 1G over CL37 as well */\n\t\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1, 0x10);\n\t\twc_lane_config = REG_RD(bp, params->shmem_base +\n\t\t\t\t\toffsetof(struct shmem_region, dev_info.\n\t\t\t\t\tshared_hw_config.wc_lane_config));\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_RX0_PCI_CTRL + (lane << 4), &val);\n\t\t/* Force cl48 sync_status LOW to avoid getting stuck in CL73\n\t\t * parallel-detect loop when CL73 and CL37 are enabled.\n\t\t */\n\t\tval |= 1 << 11;\n\n\t\t/* Restore Polarity settings in case it was run over by\n\t\t * previous link owner\n\t\t */\n\t\tif (wc_lane_config &\n\t\t    (SHARED_HW_CFG_RX_LANE0_POL_FLIP_ENABLED << lane))\n\t\t\tval |= 3 << 2;\n\t\telse\n\t\t\tval &= ~(3 << 2);\n\t\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_RX0_PCI_CTRL + (lane << 4),\n\t\t\t\t val);\n\n\t\tbnx2x_disable_kr2(params, vars, phy);\n\t}\n\n\t/* Enable Autoneg: only on the main lane */\n\tbnx2x_warpcore_restart_AN_KR(phy, params);\n}\n\nstatic void bnx2x_warpcore_set_10G_KR(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params,\n\t\t\t\t      struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val16, i, lane;\n\tstatic struct bnx2x_reg_set reg_set[] = {\n\t\t/* Disable Autoneg */\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2, 0x7},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL,\n\t\t\t0x3f00},\n\t\t{MDIO_AN_DEVAD, MDIO_WC_REG_AN_IEEE1BLK_AN_ADVERTISEMENT1, 0},\n\t\t{MDIO_AN_DEVAD, MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x0},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_DIGITAL3_UP1, 0x1},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_DIGITAL5_MISC7, 0xa},\n\t\t/* Leave cl72 training enable, needed for KR */\n\t\t{MDIO_PMA_DEVAD, MDIO_WC_REG_PMD_KR_CONTROL, 0x2}\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\n\t\tbnx2x_cl45_write(bp, phy, reg_set[i].devad, reg_set[i].reg,\n\t\t\t\t reg_set[i].val);\n\n\tlane = bnx2x_get_warpcore_lane(phy, params);\n\t/* Global registers */\n\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t  MDIO_AER_BLOCK_AER_REG, 0);\n\t/* Disable CL36 PCS Tx */\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_XGXSBLK1_LANECTRL0, &val16);\n\tval16 &= ~(0x0011 << lane);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_XGXSBLK1_LANECTRL0, val16);\n\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_XGXSBLK1_LANECTRL1, &val16);\n\tval16 |= (0x0303 << (lane << 1));\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_XGXSBLK1_LANECTRL1, val16);\n\t/* Restore AER */\n\tbnx2x_set_aer_mmd(params, phy);\n\t/* Set speed via PMA/PMD register */\n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD,\n\t\t\t MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x2040);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD,\n\t\t\t MDIO_WC_REG_IEEE0BLK_AUTONEGNP, 0xB);\n\n\t/* Enable encoded forced speed */\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_SERDESDIGITAL_MISC2, 0x30);\n\n\t/* Turn TX scramble payload only the 64/66 scrambler */\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_TX66_CONTROL, 0x9);\n\n\t/* Turn RX scramble payload only the 64/66 scrambler */\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_RX66_CONTROL, 0xF9);\n\n\t/* Set and clear loopback to cause a reset to 64/66 decoder */\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x4000);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x0);\n\n}\n\nstatic void bnx2x_warpcore_set_10G_XFI(struct bnx2x_phy *phy,\n\t\t\t\t       struct link_params *params,\n\t\t\t\t       u8 is_xfi)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 misc1_val, tap_val, tx_driver_val, lane, val;\n\tu32 cfg_tap_val, tx_drv_brdct, tx_equal;\n\tu32 ifir_val, ipost2_val, ipre_driver_val;\n\n\t/* Hold rxSeqStart */\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_DSC2B0_DSC_MISC_CTRL0, 0x8000);\n\n\t/* Hold tx_fifo_reset */\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X3, 0x1);\n\n\t/* Disable CL73 AN */\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0);\n\n\t/* Disable 100FX Enable and Auto-Detect */\n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_FX100_CTRL1, 0xFFFA);\n\n\t/* Disable 100FX Idle detect */\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_FX100_CTRL3, 0x0080);\n\n\t/* Set Block address to Remote PHY & Clear forced_speed[5] */\n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_DIGITAL4_MISC3, 0xFF7F);\n\n\t/* Turn off auto-detect & fiber mode */\n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1,\n\t\t\t\t  0xFFEE);\n\n\t/* Set filter_force_link, disable_false_link and parallel_detect */\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2, &val);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2,\n\t\t\t ((val | 0x0006) & 0xFFFE));\n\n\t/* Set XFI / SFI */\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_SERDESDIGITAL_MISC1, &misc1_val);\n\n\tmisc1_val &= ~(0x1f);\n\n\tif (is_xfi) {\n\t\tmisc1_val |= 0x5;\n\t\ttap_val = WC_TX_FIR(0x08, 0x37, 0x00);\n\t\ttx_driver_val = WC_TX_DRIVER(0x00, 0x02, 0x03, 0);\n\t} else {\n\t\tcfg_tap_val = REG_RD(bp, params->shmem_base +\n\t\t\t\t     offsetof(struct shmem_region, dev_info.\n\t\t\t\t\t      port_hw_config[params->port].\n\t\t\t\t\t      sfi_tap_values));\n\n\t\ttx_equal = cfg_tap_val & PORT_HW_CFG_TX_EQUALIZATION_MASK;\n\n\t\tmisc1_val |= 0x9;\n\n\t\t/* TAP values are controlled by nvram, if value there isn't 0 */\n\t\tif (tx_equal)\n\t\t\ttap_val = (u16)tx_equal;\n\t\telse\n\t\t\ttap_val = WC_TX_FIR(0x0f, 0x2b, 0x02);\n\n\t\tifir_val = DEFAULT_TX_DRV_IFIR;\n\t\tipost2_val = DEFAULT_TX_DRV_POST2;\n\t\tipre_driver_val = DEFAULT_TX_DRV_IPRE_DRIVER;\n\t\ttx_drv_brdct = DEFAULT_TX_DRV_BRDCT;\n\n\t\t/* If any of the IFIR/IPRE_DRIVER/POST@ is set, apply all\n\t\t * configuration.\n\t\t */\n\t\tif (cfg_tap_val & (PORT_HW_CFG_TX_DRV_IFIR_MASK |\n\t\t\t\t   PORT_HW_CFG_TX_DRV_IPREDRIVER_MASK |\n\t\t\t\t   PORT_HW_CFG_TX_DRV_POST2_MASK)) {\n\t\t\tifir_val = (cfg_tap_val &\n\t\t\t\t    PORT_HW_CFG_TX_DRV_IFIR_MASK) >>\n\t\t\t\tPORT_HW_CFG_TX_DRV_IFIR_SHIFT;\n\t\t\tipre_driver_val = (cfg_tap_val &\n\t\t\t\t\t   PORT_HW_CFG_TX_DRV_IPREDRIVER_MASK)\n\t\t\t>> PORT_HW_CFG_TX_DRV_IPREDRIVER_SHIFT;\n\t\t\tipost2_val = (cfg_tap_val &\n\t\t\t\t      PORT_HW_CFG_TX_DRV_POST2_MASK) >>\n\t\t\t\tPORT_HW_CFG_TX_DRV_POST2_SHIFT;\n\t\t}\n\n\t\tif (cfg_tap_val & PORT_HW_CFG_TX_DRV_BROADCAST_MASK) {\n\t\t\ttx_drv_brdct = (cfg_tap_val &\n\t\t\t\t\tPORT_HW_CFG_TX_DRV_BROADCAST_MASK) >>\n\t\t\t\tPORT_HW_CFG_TX_DRV_BROADCAST_SHIFT;\n\t\t}\n\n\t\ttx_driver_val = WC_TX_DRIVER(ipost2_val, tx_drv_brdct,\n\t\t\t\t\t     ipre_driver_val, ifir_val);\n\t}\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_SERDESDIGITAL_MISC1, misc1_val);\n\n\t/* Set Transmit PMD settings */\n\tlane = bnx2x_get_warpcore_lane(phy, params);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_TX_FIR_TAP,\n\t\t\t tap_val | MDIO_WC_REG_TX_FIR_TAP_ENABLE);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_TX0_TX_DRIVER + 0x10*lane,\n\t\t\t tx_driver_val);\n\n\t/* Enable fiber mode, enable and invert sig_det */\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1, 0xd);\n\n\t/* Set Block address to Remote PHY & Set forced_speed[5], 40bit mode */\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_DIGITAL4_MISC3, 0x8080);\n\n\tbnx2x_warpcore_set_lpi_passthrough(phy, params);\n\n\t/* 10G XFI Full Duplex */\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x100);\n\n\t/* Release tx_fifo_reset */\n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X3,\n\t\t\t\t  0xFFFE);\n\t/* Release rxSeqStart */\n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_DSC2B0_DSC_MISC_CTRL0, 0x7FFF);\n}\n\nstatic void bnx2x_warpcore_set_20G_force_KR2(struct bnx2x_phy *phy,\n\t\t\t\t\t     struct link_params *params)\n{\n\tu16 val;\n\tstruct bnx2x *bp = params->bp;\n\t/* Set global registers, so set AER lane to 0 */\n\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t  MDIO_AER_BLOCK_AER_REG, 0);\n\n\t/* Disable sequencer */\n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_XGXSBLK0_XGXSCONTROL, ~(1<<13));\n\n\tbnx2x_set_aer_mmd(params, phy);\n\n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_PMA_DEVAD,\n\t\t\t\t  MDIO_WC_REG_PMD_KR_CONTROL, ~(1<<1));\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t MDIO_AN_REG_CTRL, 0);\n\t/* Turn off CL73 */\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_CL73_USERB0_CTRL, &val);\n\tval &= ~(1<<5);\n\tval |= (1<<6);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_CL73_USERB0_CTRL, val);\n\n\t/* Set 20G KR2 force speed */\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_SERDESDIGITAL_MISC1, 0x1f);\n\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_DIGITAL4_MISC3, (1<<7));\n\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL, &val);\n\tval &= ~(3<<14);\n\tval |= (1<<15);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL, val);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_CL72_USERB0_CL72_TX_FIR_TAP, 0x835A);\n\n\t/* Enable sequencer (over lane 0) */\n\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t  MDIO_AER_BLOCK_AER_REG, 0);\n\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_XGXSBLK0_XGXSCONTROL, (1<<13));\n\n\tbnx2x_set_aer_mmd(params, phy);\n}\n\nstatic void bnx2x_warpcore_set_20G_DXGXS(struct bnx2x *bp,\n\t\t\t\t\t struct bnx2x_phy *phy,\n\t\t\t\t\t u16 lane)\n{\n\t/* Rx0 anaRxControl1G */\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX0_ANARXCONTROL1G, 0x90);\n\n\t/* Rx2 anaRxControl1G */\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX2_ANARXCONTROL1G, 0x90);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX66_SCW0, 0xE070);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX66_SCW1, 0xC0D0);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX66_SCW2, 0xA0B0);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX66_SCW3, 0x8090);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX66_SCW0_MASK, 0xF0F0);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX66_SCW1_MASK, 0xF0F0);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX66_SCW2_MASK, 0xF0F0);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX66_SCW3_MASK, 0xF0F0);\n\n\t/* Serdes Digital Misc1 */\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_SERDESDIGITAL_MISC1, 0x6008);\n\n\t/* Serdes Digital4 Misc3 */\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_DIGITAL4_MISC3, 0x8088);\n\n\t/* Set Transmit PMD settings */\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_TX_FIR_TAP,\n\t\t\t (WC_TX_FIR(0x12, 0x2d, 0x00) |\n\t\t\t  MDIO_WC_REG_TX_FIR_TAP_ENABLE));\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_TX0_TX_DRIVER + 0x10*lane,\n\t\t\t WC_TX_DRIVER(0x02, 0x02, 0x02, 0));\n}\n\nstatic void bnx2x_warpcore_set_sgmii_speed(struct bnx2x_phy *phy,\n\t\t\t\t\t   struct link_params *params,\n\t\t\t\t\t   u8 fiber_mode,\n\t\t\t\t\t   u8 always_autoneg)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val16, digctrl_kx1, digctrl_kx2;\n\n\t/* Clear XFI clock comp in non-10G single lane mode. */\n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_RX66_CONTROL, ~(3<<13));\n\n\tbnx2x_warpcore_set_lpi_passthrough(phy, params);\n\n\tif (always_autoneg || phy->req_line_speed == SPEED_AUTO_NEG) {\n\t\t/* SGMII Autoneg */\n\t\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t MDIO_WC_REG_COMBO_IEEE0_MIICTRL,\n\t\t\t\t\t 0x1000);\n\t\tDP(NETIF_MSG_LINK, \"set SGMII AUTONEG\\n\");\n\t} else {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_COMBO_IEEE0_MIICTRL, &val16);\n\t\tval16 &= 0xcebf;\n\t\tswitch (phy->req_line_speed) {\n\t\tcase SPEED_10:\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tval16 |= 0x2000;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tval16 |= 0x0040;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"Speed not supported: 0x%x\\n\", phy->req_line_speed);\n\t\t\treturn;\n\t\t}\n\n\t\tif (phy->req_duplex == DUPLEX_FULL)\n\t\t\tval16 |= 0x0100;\n\n\t\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_COMBO_IEEE0_MIICTRL, val16);\n\n\t\tDP(NETIF_MSG_LINK, \"set SGMII force speed %d\\n\",\n\t\t\t       phy->req_line_speed);\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_COMBO_IEEE0_MIICTRL, &val16);\n\t\tDP(NETIF_MSG_LINK, \"  (readback) %x\\n\", val16);\n\t}\n\n\t/* SGMII Slave mode and disable signal detect */\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1, &digctrl_kx1);\n\tif (fiber_mode)\n\t\tdigctrl_kx1 = 1;\n\telse\n\t\tdigctrl_kx1 &= 0xff4a;\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1,\n\t\t\tdigctrl_kx1);\n\n\t/* Turn off parallel detect */\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2, &digctrl_kx2);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2,\n\t\t\t(digctrl_kx2 & ~(1<<2)));\n\n\t/* Re-enable parallel detect */\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2,\n\t\t\t(digctrl_kx2 | (1<<2)));\n\n\t/* Enable autodet */\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1,\n\t\t\t(digctrl_kx1 | 0x10));\n}\n\nstatic void bnx2x_warpcore_reset_lane(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_phy *phy,\n\t\t\t\t      u8 reset)\n{\n\tu16 val;\n\t/* Take lane out of reset after configuration is finished */\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_DIGITAL5_MISC6, &val);\n\tif (reset)\n\t\tval |= 0xC000;\n\telse\n\t\tval &= 0x3FFF;\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_DIGITAL5_MISC6, val);\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_DIGITAL5_MISC6, &val);\n}\n/* Clear SFI/XFI link settings registers */\nstatic void bnx2x_warpcore_clear_regs(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params,\n\t\t\t\t      u16 lane)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 i;\n\tstatic struct bnx2x_reg_set wc_regs[] = {\n\t\t{MDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_FX100_CTRL1, 0x014a},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_FX100_CTRL3, 0x0800},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_DIGITAL4_MISC3, 0x8008},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1,\n\t\t\t0x0195},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2,\n\t\t\t0x0007},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X3,\n\t\t\t0x0002},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_MISC1, 0x6000},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_TX_FIR_TAP, 0x0000},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x2040},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_COMBO_IEEE0_MIICTRL, 0x0140}\n\t};\n\t/* Set XFI clock comp as default. */\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_RX66_CONTROL, (3<<13));\n\n\tfor (i = 0; i < ARRAY_SIZE(wc_regs); i++)\n\t\tbnx2x_cl45_write(bp, phy, wc_regs[i].devad, wc_regs[i].reg,\n\t\t\t\t wc_regs[i].val);\n\n\tlane = bnx2x_get_warpcore_lane(phy, params);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_TX0_TX_DRIVER + 0x10*lane, 0x0990);\n\n}\n\nstatic int bnx2x_get_mod_abs_int_cfg(struct bnx2x *bp,\n\t\t\t\t\t\tu32 chip_id,\n\t\t\t\t\t\tu32 shmem_base, u8 port,\n\t\t\t\t\t\tu8 *gpio_num, u8 *gpio_port)\n{\n\tu32 cfg_pin;\n\t*gpio_num = 0;\n\t*gpio_port = 0;\n\tif (CHIP_IS_E3(bp)) {\n\t\tcfg_pin = (REG_RD(bp, shmem_base +\n\t\t\t\toffsetof(struct shmem_region,\n\t\t\t\tdev_info.port_hw_config[port].e3_sfp_ctrl)) &\n\t\t\t\tPORT_HW_CFG_E3_MOD_ABS_MASK) >>\n\t\t\t\tPORT_HW_CFG_E3_MOD_ABS_SHIFT;\n\n\t\t/* Should not happen. This function called upon interrupt\n\t\t * triggered by GPIO ( since EPIO can only generate interrupts\n\t\t * to MCP).\n\t\t * So if this function was called and none of the GPIOs was set,\n\t\t * it means the shit hit the fan.\n\t\t */\n\t\tif ((cfg_pin < PIN_CFG_GPIO0_P0) ||\n\t\t    (cfg_pin > PIN_CFG_GPIO3_P1)) {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"No cfg pin %x for module detect indication\\n\",\n\t\t\t   cfg_pin);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*gpio_num = (cfg_pin - PIN_CFG_GPIO0_P0) & 0x3;\n\t\t*gpio_port = (cfg_pin - PIN_CFG_GPIO0_P0) >> 2;\n\t} else {\n\t\t*gpio_num = MISC_REGISTERS_GPIO_3;\n\t\t*gpio_port = port;\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_is_sfp_module_plugged(struct bnx2x_phy *phy,\n\t\t\t\t       struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 gpio_num, gpio_port;\n\tu32 gpio_val;\n\tif (bnx2x_get_mod_abs_int_cfg(bp, params->chip_id,\n\t\t\t\t      params->shmem_base, params->port,\n\t\t\t\t      &gpio_num, &gpio_port) != 0)\n\t\treturn 0;\n\tgpio_val = bnx2x_get_gpio(bp, gpio_num, gpio_port);\n\n\t/* Call the handling function in case module is detected */\n\tif (gpio_val == 0)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\nstatic int bnx2x_warpcore_get_sigdet(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params)\n{\n\tu16 gp2_status_reg0, lane;\n\tstruct bnx2x *bp = params->bp;\n\n\tlane = bnx2x_get_warpcore_lane(phy, params);\n\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD, MDIO_WC_REG_GP2_STATUS_GP_2_0,\n\t\t\t\t &gp2_status_reg0);\n\n\treturn (gp2_status_reg0 >> (8+lane)) & 0x1;\n}\n\nstatic void bnx2x_warpcore_config_runtime(struct bnx2x_phy *phy,\n\t\t\t\t\t  struct link_params *params,\n\t\t\t\t\t  struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 serdes_net_if;\n\tu16 gp_status1 = 0, lnkup = 0, lnkup_kr = 0;\n\n\tvars->turn_to_run_wc_rt = vars->turn_to_run_wc_rt ? 0 : 1;\n\n\tif (!vars->turn_to_run_wc_rt)\n\t\treturn;\n\n\tif (vars->rx_tx_asic_rst) {\n\t\tu16 lane = bnx2x_get_warpcore_lane(phy, params);\n\t\tserdes_net_if = (REG_RD(bp, params->shmem_base +\n\t\t\t\toffsetof(struct shmem_region, dev_info.\n\t\t\t\tport_hw_config[params->port].default_cfg)) &\n\t\t\t\tPORT_HW_CFG_NET_SERDES_IF_MASK);\n\n\t\tswitch (serdes_net_if) {\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_KR:\n\t\t\t/* Do we get link yet? */\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD, 0x81d1,\n\t\t\t\t\t&gp_status1);\n\t\t\tlnkup = (gp_status1 >> (8+lane)) & 0x1;/* 1G */\n\t\t\t\t/*10G KR*/\n\t\t\tlnkup_kr = (gp_status1 >> (12+lane)) & 0x1;\n\n\t\t\tif (lnkup_kr || lnkup) {\n\t\t\t\tvars->rx_tx_asic_rst = 0;\n\t\t\t} else {\n\t\t\t\t/* Reset the lane to see if link comes up.*/\n\t\t\t\tbnx2x_warpcore_reset_lane(bp, phy, 1);\n\t\t\t\tbnx2x_warpcore_reset_lane(bp, phy, 0);\n\n\t\t\t\t/* Restart Autoneg */\n\t\t\t\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_WC_REG_IEEE0BLK_MIICNTL, 0x1200);\n\n\t\t\t\tvars->rx_tx_asic_rst--;\n\t\t\t\tDP(NETIF_MSG_LINK, \"0x%x retry left\\n\",\n\t\t\t\tvars->rx_tx_asic_rst);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t} /*params->rx_tx_asic_rst*/\n\n}\nstatic void bnx2x_warpcore_config_sfi(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params)\n{\n\tu16 lane = bnx2x_get_warpcore_lane(phy, params);\n\tstruct bnx2x *bp = params->bp;\n\tbnx2x_warpcore_clear_regs(phy, params, lane);\n\tif ((params->req_line_speed[LINK_CONFIG_IDX(INT_PHY)] ==\n\t     SPEED_10000) &&\n\t    (phy->media_type != ETH_PHY_SFP_1G_FIBER)) {\n\t\tDP(NETIF_MSG_LINK, \"Setting 10G SFI\\n\");\n\t\tbnx2x_warpcore_set_10G_XFI(phy, params, 0);\n\t} else {\n\t\tDP(NETIF_MSG_LINK, \"Setting 1G Fiber\\n\");\n\t\tbnx2x_warpcore_set_sgmii_speed(phy, params, 1, 0);\n\t}\n}\n\nstatic void bnx2x_sfp_e3_set_transmitter(struct link_params *params,\n\t\t\t\t\t struct bnx2x_phy *phy,\n\t\t\t\t\t u8 tx_en)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 cfg_pin;\n\tu8 port = params->port;\n\n\tcfg_pin = REG_RD(bp, params->shmem_base +\n\t\t\t offsetof(struct shmem_region,\n\t\t\t\t  dev_info.port_hw_config[port].e3_sfp_ctrl)) &\n\t\tPORT_HW_CFG_E3_TX_LASER_MASK;\n\t/* Set the !tx_en since this pin is DISABLE_TX_LASER */\n\tDP(NETIF_MSG_LINK, \"Setting WC TX to %d\\n\", tx_en);\n\n\t/* For 20G, the expected pin to be used is 3 pins after the current */\n\tbnx2x_set_cfg_pin(bp, cfg_pin, tx_en ^ 1);\n\tif (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_20G)\n\t\tbnx2x_set_cfg_pin(bp, cfg_pin + 3, tx_en ^ 1);\n}\n\nstatic void bnx2x_warpcore_config_init(struct bnx2x_phy *phy,\n\t\t\t\t       struct link_params *params,\n\t\t\t\t       struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 serdes_net_if;\n\tu8 fiber_mode;\n\tu16 lane = bnx2x_get_warpcore_lane(phy, params);\n\tserdes_net_if = (REG_RD(bp, params->shmem_base +\n\t\t\t offsetof(struct shmem_region, dev_info.\n\t\t\t\t  port_hw_config[params->port].default_cfg)) &\n\t\t\t PORT_HW_CFG_NET_SERDES_IF_MASK);\n\tDP(NETIF_MSG_LINK, \"Begin Warpcore init, link_speed %d, \"\n\t\t\t   \"serdes_net_if = 0x%x\\n\",\n\t\t       vars->line_speed, serdes_net_if);\n\tbnx2x_set_aer_mmd(params, phy);\n\tbnx2x_warpcore_reset_lane(bp, phy, 1);\n\tvars->phy_flags |= PHY_XGXS_FLAG;\n\tif ((serdes_net_if == PORT_HW_CFG_NET_SERDES_IF_SGMII) ||\n\t    (phy->req_line_speed &&\n\t     ((phy->req_line_speed == SPEED_100) ||\n\t      (phy->req_line_speed == SPEED_10)))) {\n\t\tvars->phy_flags |= PHY_SGMII_FLAG;\n\t\tDP(NETIF_MSG_LINK, \"Setting SGMII mode\\n\");\n\t\tbnx2x_warpcore_clear_regs(phy, params, lane);\n\t\tbnx2x_warpcore_set_sgmii_speed(phy, params, 0, 1);\n\t} else {\n\t\tswitch (serdes_net_if) {\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_KR:\n\t\t\t/* Enable KR Auto Neg */\n\t\t\tif (params->loopback_mode != LOOPBACK_EXT)\n\t\t\t\tbnx2x_warpcore_enable_AN_KR(phy, params, vars);\n\t\t\telse {\n\t\t\t\tDP(NETIF_MSG_LINK, \"Setting KR 10G-Force\\n\");\n\t\t\t\tbnx2x_warpcore_set_10G_KR(phy, params, vars);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_XFI:\n\t\t\tbnx2x_warpcore_clear_regs(phy, params, lane);\n\t\t\tif (vars->line_speed == SPEED_10000) {\n\t\t\t\tDP(NETIF_MSG_LINK, \"Setting 10G XFI\\n\");\n\t\t\t\tbnx2x_warpcore_set_10G_XFI(phy, params, 1);\n\t\t\t} else {\n\t\t\t\tif (SINGLE_MEDIA_DIRECT(params)) {\n\t\t\t\t\tDP(NETIF_MSG_LINK, \"1G Fiber\\n\");\n\t\t\t\t\tfiber_mode = 1;\n\t\t\t\t} else {\n\t\t\t\t\tDP(NETIF_MSG_LINK, \"10/100/1G SGMII\\n\");\n\t\t\t\t\tfiber_mode = 0;\n\t\t\t\t}\n\t\t\t\tbnx2x_warpcore_set_sgmii_speed(phy,\n\t\t\t\t\t\t\t\tparams,\n\t\t\t\t\t\t\t\tfiber_mode,\n\t\t\t\t\t\t\t\t0);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_SFI:\n\t\t\t/* Issue Module detection if module is plugged, or\n\t\t\t * enabled transmitter to avoid current leakage in case\n\t\t\t * no module is connected\n\t\t\t */\n\t\t\tif ((params->loopback_mode == LOOPBACK_NONE) ||\n\t\t\t    (params->loopback_mode == LOOPBACK_EXT)) {\n\t\t\t\tif (bnx2x_is_sfp_module_plugged(phy, params))\n\t\t\t\t\tbnx2x_sfp_module_detection(phy, params);\n\t\t\t\telse\n\t\t\t\t\tbnx2x_sfp_e3_set_transmitter(params,\n\t\t\t\t\t\t\t\t     phy, 1);\n\t\t\t}\n\n\t\t\tbnx2x_warpcore_config_sfi(phy, params);\n\t\t\tbreak;\n\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_DXGXS:\n\t\t\tif (vars->line_speed != SPEED_20000) {\n\t\t\t\tDP(NETIF_MSG_LINK, \"Speed not supported yet\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tDP(NETIF_MSG_LINK, \"Setting 20G DXGXS\\n\");\n\t\t\tbnx2x_warpcore_set_20G_DXGXS(bp, phy, lane);\n\t\t\t/* Issue Module detection */\n\n\t\t\tbnx2x_sfp_module_detection(phy, params);\n\t\t\tbreak;\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_KR2:\n\t\t\tif (!params->loopback_mode) {\n\t\t\t\tbnx2x_warpcore_enable_AN_KR(phy, params, vars);\n\t\t\t} else {\n\t\t\t\tDP(NETIF_MSG_LINK, \"Setting KR 20G-Force\\n\");\n\t\t\t\tbnx2x_warpcore_set_20G_force_KR2(phy, params);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"Unsupported Serdes Net Interface 0x%x\\n\",\n\t\t\t   serdes_net_if);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Take lane out of reset after configuration is finished */\n\tbnx2x_warpcore_reset_lane(bp, phy, 0);\n\tDP(NETIF_MSG_LINK, \"Exit config init\\n\");\n}\n\nstatic void bnx2x_warpcore_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val16, lane;\n\tbnx2x_sfp_e3_set_transmitter(params, phy, 0);\n\tbnx2x_set_mdio_emac_per_phy(bp, params);\n\tbnx2x_set_aer_mmd(params, phy);\n\t/* Global register */\n\tbnx2x_warpcore_reset_lane(bp, phy, 1);\n\n\t/* Clear loopback settings (if any) */\n\t/* 10G & 20G */\n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_COMBO_IEEE0_MIICTRL, 0xBFFF);\n\n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_IEEE0BLK_MIICNTL, 0xfffe);\n\n\t/* Update those 1-copy registers */\n\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t  MDIO_AER_BLOCK_AER_REG, 0);\n\t/* Enable 1G MDIO (1-copy) */\n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_XGXSBLK0_XGXSCONTROL,\n\t\t\t\t  ~0x10);\n\n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_XGXSBLK1_LANECTRL2, 0xff00);\n\tlane = bnx2x_get_warpcore_lane(phy, params);\n\t/* Disable CL36 PCS Tx */\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_XGXSBLK1_LANECTRL0, &val16);\n\tval16 |= (0x11 << lane);\n\tif (phy->flags & FLAGS_WC_DUAL_MODE)\n\t\tval16 |= (0x22 << lane);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_XGXSBLK1_LANECTRL0, val16);\n\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_XGXSBLK1_LANECTRL1, &val16);\n\tval16 &= ~(0x0303 << (lane << 1));\n\tval16 |= (0x0101 << (lane << 1));\n\tif (phy->flags & FLAGS_WC_DUAL_MODE) {\n\t\tval16 &= ~(0x0c0c << (lane << 1));\n\t\tval16 |= (0x0404 << (lane << 1));\n\t}\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_XGXSBLK1_LANECTRL1, val16);\n\t/* Restore AER */\n\tbnx2x_set_aer_mmd(params, phy);\n\n}\n\nstatic void bnx2x_set_warpcore_loopback(struct bnx2x_phy *phy,\n\t\t\t\t\tstruct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val16;\n\tu32 lane;\n\tDP(NETIF_MSG_LINK, \"Setting Warpcore loopback type %x, speed %d\\n\",\n\t\t       params->loopback_mode, phy->req_line_speed);\n\n\tif (phy->req_line_speed < SPEED_10000 ||\n\t    phy->supported & SUPPORTED_20000baseKR2_Full) {\n\t\t/* 10/100/1000/20G-KR2 */\n\n\t\t/* Update those 1-copy registers */\n\t\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t\t  MDIO_AER_BLOCK_AER_REG, 0);\n\t\t/* Enable 1G MDIO (1-copy) */\n\t\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t MDIO_WC_REG_XGXSBLK0_XGXSCONTROL,\n\t\t\t\t\t 0x10);\n\t\t/* Set 1G loopback based on lane (1-copy) */\n\t\tlane = bnx2x_get_warpcore_lane(phy, params);\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_XGXSBLK1_LANECTRL2, &val16);\n\t\tval16 |= (1<<lane);\n\t\tif (phy->flags & FLAGS_WC_DUAL_MODE)\n\t\t\tval16 |= (2<<lane);\n\t\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_XGXSBLK1_LANECTRL2,\n\t\t\t\t val16);\n\n\t\t/* Switch back to 4-copy registers */\n\t\tbnx2x_set_aer_mmd(params, phy);\n\t} else {\n\t\t/* 10G / 20G-DXGXS */\n\t\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t MDIO_WC_REG_COMBO_IEEE0_MIICTRL,\n\t\t\t\t\t 0x4000);\n\t\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x1);\n\t}\n}\n\n\n\nstatic void bnx2x_sync_link(struct link_params *params,\n\t\t\t     struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 link_10g_plus;\n\tif (vars->link_status & LINK_STATUS_PHYSICAL_LINK_FLAG)\n\t\tvars->phy_flags |= PHY_PHYSICAL_LINK_FLAG;\n\tvars->link_up = (vars->link_status & LINK_STATUS_LINK_UP);\n\tif (vars->link_up) {\n\t\tDP(NETIF_MSG_LINK, \"phy link up\\n\");\n\n\t\tvars->phy_link_up = 1;\n\t\tvars->duplex = DUPLEX_FULL;\n\t\tswitch (vars->link_status &\n\t\t\tLINK_STATUS_SPEED_AND_DUPLEX_MASK) {\n\t\tcase LINK_10THD:\n\t\t\tvars->duplex = DUPLEX_HALF;\n\t\t\tfallthrough;\n\t\tcase LINK_10TFD:\n\t\t\tvars->line_speed = SPEED_10;\n\t\t\tbreak;\n\n\t\tcase LINK_100TXHD:\n\t\t\tvars->duplex = DUPLEX_HALF;\n\t\t\tfallthrough;\n\t\tcase LINK_100T4:\n\t\tcase LINK_100TXFD:\n\t\t\tvars->line_speed = SPEED_100;\n\t\t\tbreak;\n\n\t\tcase LINK_1000THD:\n\t\t\tvars->duplex = DUPLEX_HALF;\n\t\t\tfallthrough;\n\t\tcase LINK_1000TFD:\n\t\t\tvars->line_speed = SPEED_1000;\n\t\t\tbreak;\n\n\t\tcase LINK_2500THD:\n\t\t\tvars->duplex = DUPLEX_HALF;\n\t\t\tfallthrough;\n\t\tcase LINK_2500TFD:\n\t\t\tvars->line_speed = SPEED_2500;\n\t\t\tbreak;\n\n\t\tcase LINK_10GTFD:\n\t\t\tvars->line_speed = SPEED_10000;\n\t\t\tbreak;\n\t\tcase LINK_20GTFD:\n\t\t\tvars->line_speed = SPEED_20000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tvars->flow_ctrl = 0;\n\t\tif (vars->link_status & LINK_STATUS_TX_FLOW_CONTROL_ENABLED)\n\t\t\tvars->flow_ctrl |= BNX2X_FLOW_CTRL_TX;\n\n\t\tif (vars->link_status & LINK_STATUS_RX_FLOW_CONTROL_ENABLED)\n\t\t\tvars->flow_ctrl |= BNX2X_FLOW_CTRL_RX;\n\n\t\tif (!vars->flow_ctrl)\n\t\t\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\n\t\tif (vars->line_speed &&\n\t\t    ((vars->line_speed == SPEED_10) ||\n\t\t     (vars->line_speed == SPEED_100))) {\n\t\t\tvars->phy_flags |= PHY_SGMII_FLAG;\n\t\t} else {\n\t\t\tvars->phy_flags &= ~PHY_SGMII_FLAG;\n\t\t}\n\t\tif (vars->line_speed &&\n\t\t    USES_WARPCORE(bp) &&\n\t\t    (vars->line_speed == SPEED_1000))\n\t\t\tvars->phy_flags |= PHY_SGMII_FLAG;\n\t\t/* Anything 10 and over uses the bmac */\n\t\tlink_10g_plus = (vars->line_speed >= SPEED_10000);\n\n\t\tif (link_10g_plus) {\n\t\t\tif (USES_WARPCORE(bp))\n\t\t\t\tvars->mac_type = MAC_TYPE_XMAC;\n\t\t\telse\n\t\t\t\tvars->mac_type = MAC_TYPE_BMAC;\n\t\t} else {\n\t\t\tif (USES_WARPCORE(bp))\n\t\t\t\tvars->mac_type = MAC_TYPE_UMAC;\n\t\t\telse\n\t\t\t\tvars->mac_type = MAC_TYPE_EMAC;\n\t\t}\n\t} else { /* Link down */\n\t\tDP(NETIF_MSG_LINK, \"phy link down\\n\");\n\n\t\tvars->phy_link_up = 0;\n\n\t\tvars->line_speed = 0;\n\t\tvars->duplex = DUPLEX_FULL;\n\t\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\n\t\t/* Indicate no mac active */\n\t\tvars->mac_type = MAC_TYPE_NONE;\n\t\tif (vars->link_status & LINK_STATUS_PHYSICAL_LINK_FLAG)\n\t\t\tvars->phy_flags |= PHY_HALF_OPEN_CONN_FLAG;\n\t\tif (vars->link_status & LINK_STATUS_SFP_TX_FAULT)\n\t\t\tvars->phy_flags |= PHY_SFP_TX_FAULT_FLAG;\n\t}\n}\n\nvoid bnx2x_link_status_update(struct link_params *params,\n\t\t\t      struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\tu32 sync_offset, media_types;\n\t/* Update PHY configuration */\n\tset_phy_vars(params, vars);\n\n\tvars->link_status = REG_RD(bp, params->shmem_base +\n\t\t\t\t   offsetof(struct shmem_region,\n\t\t\t\t\t    port_mb[port].link_status));\n\n\t/* Force link UP in non LOOPBACK_EXT loopback mode(s) */\n\tif (params->loopback_mode != LOOPBACK_NONE &&\n\t    params->loopback_mode != LOOPBACK_EXT)\n\t\tvars->link_status |= LINK_STATUS_LINK_UP;\n\n\tif (bnx2x_eee_has_cap(params))\n\t\tvars->eee_status = REG_RD(bp, params->shmem2_base +\n\t\t\t\t\t  offsetof(struct shmem2_region,\n\t\t\t\t\t\t   eee_status[params->port]));\n\n\tvars->phy_flags = PHY_XGXS_FLAG;\n\tbnx2x_sync_link(params, vars);\n\t/* Sync media type */\n\tsync_offset = params->shmem_base +\n\t\t\toffsetof(struct shmem_region,\n\t\t\t\t dev_info.port_hw_config[port].media_type);\n\tmedia_types = REG_RD(bp, sync_offset);\n\n\tparams->phy[INT_PHY].media_type =\n\t\t(media_types & PORT_HW_CFG_MEDIA_TYPE_PHY0_MASK) >>\n\t\tPORT_HW_CFG_MEDIA_TYPE_PHY0_SHIFT;\n\tparams->phy[EXT_PHY1].media_type =\n\t\t(media_types & PORT_HW_CFG_MEDIA_TYPE_PHY1_MASK) >>\n\t\tPORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT;\n\tparams->phy[EXT_PHY2].media_type =\n\t\t(media_types & PORT_HW_CFG_MEDIA_TYPE_PHY2_MASK) >>\n\t\tPORT_HW_CFG_MEDIA_TYPE_PHY2_SHIFT;\n\tDP(NETIF_MSG_LINK, \"media_types = 0x%x\\n\", media_types);\n\n\t/* Sync AEU offset */\n\tsync_offset = params->shmem_base +\n\t\t\toffsetof(struct shmem_region,\n\t\t\t\t dev_info.port_hw_config[port].aeu_int_mask);\n\n\tvars->aeu_int_mask = REG_RD(bp, sync_offset);\n\n\t/* Sync PFC status */\n\tif (vars->link_status & LINK_STATUS_PFC_ENABLED)\n\t\tparams->feature_config_flags |=\n\t\t\t\t\tFEATURE_CONFIG_PFC_ENABLED;\n\telse\n\t\tparams->feature_config_flags &=\n\t\t\t\t\t~FEATURE_CONFIG_PFC_ENABLED;\n\n\tif (SHMEM2_HAS(bp, link_attr_sync))\n\t\tparams->link_attr_sync = SHMEM2_RD(bp,\n\t\t\t\t\t\t link_attr_sync[params->port]);\n\n\tDP(NETIF_MSG_LINK, \"link_status 0x%x  phy_link_up %x int_mask 0x%x\\n\",\n\t\t vars->link_status, vars->phy_link_up, vars->aeu_int_mask);\n\tDP(NETIF_MSG_LINK, \"line_speed %x  duplex %x  flow_ctrl 0x%x\\n\",\n\t\t vars->line_speed, vars->duplex, vars->flow_ctrl);\n}\n\nstatic void bnx2x_set_master_ln(struct link_params *params,\n\t\t\t\tstruct bnx2x_phy *phy)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 new_master_ln, ser_lane;\n\tser_lane = ((params->lane_config &\n\t\t     PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK) >>\n\t\t    PORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT);\n\n\t/* Set the master_ln for AN */\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_XGXS_BLOCK2,\n\t\t\t  MDIO_XGXS_BLOCK2_TEST_MODE_LANE,\n\t\t\t  &new_master_ln);\n\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_XGXS_BLOCK2 ,\n\t\t\t  MDIO_XGXS_BLOCK2_TEST_MODE_LANE,\n\t\t\t  (new_master_ln | ser_lane));\n}\n\nstatic int bnx2x_reset_unicore(struct link_params *params,\n\t\t\t       struct bnx2x_phy *phy,\n\t\t\t       u8 set_serdes)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 mii_control;\n\tu16 i;\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL, &mii_control);\n\n\t/* Reset the unicore */\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL,\n\t\t\t  (mii_control |\n\t\t\t   MDIO_COMBO_IEEO_MII_CONTROL_RESET));\n\tif (set_serdes)\n\t\tbnx2x_set_serdes_access(bp, params->port);\n\n\t/* Wait for the reset to self clear */\n\tfor (i = 0; i < MDIO_ACCESS_TIMEOUT; i++) {\n\t\tudelay(5);\n\n\t\t/* The reset erased the previous bank value */\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL,\n\t\t\t\t  &mii_control);\n\n\t\tif (!(mii_control & MDIO_COMBO_IEEO_MII_CONTROL_RESET)) {\n\t\t\tudelay(5);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tnetdev_err(bp->dev,  \"Warning: PHY was not initialized,\"\n\t\t\t      \" Port %d\\n\",\n\t\t\t params->port);\n\tDP(NETIF_MSG_LINK, \"BUG! XGXS is still in reset!\\n\");\n\treturn -EINVAL;\n\n}\n\nstatic void bnx2x_set_swap_lanes(struct link_params *params,\n\t\t\t\t struct bnx2x_phy *phy)\n{\n\tstruct bnx2x *bp = params->bp;\n\t/* Each two bits represents a lane number:\n\t * No swap is 0123 => 0x1b no need to enable the swap\n\t */\n\tu16 rx_lane_swap, tx_lane_swap;\n\n\trx_lane_swap = ((params->lane_config &\n\t\t\t PORT_HW_CFG_LANE_SWAP_CFG_RX_MASK) >>\n\t\t\tPORT_HW_CFG_LANE_SWAP_CFG_RX_SHIFT);\n\ttx_lane_swap = ((params->lane_config &\n\t\t\t PORT_HW_CFG_LANE_SWAP_CFG_TX_MASK) >>\n\t\t\tPORT_HW_CFG_LANE_SWAP_CFG_TX_SHIFT);\n\n\tif (rx_lane_swap != 0x1b) {\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_XGXS_BLOCK2,\n\t\t\t\t  MDIO_XGXS_BLOCK2_RX_LN_SWAP,\n\t\t\t\t  (rx_lane_swap |\n\t\t\t\t   MDIO_XGXS_BLOCK2_RX_LN_SWAP_ENABLE |\n\t\t\t\t   MDIO_XGXS_BLOCK2_RX_LN_SWAP_FORCE_ENABLE));\n\t} else {\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_XGXS_BLOCK2,\n\t\t\t\t  MDIO_XGXS_BLOCK2_RX_LN_SWAP, 0);\n\t}\n\n\tif (tx_lane_swap != 0x1b) {\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_XGXS_BLOCK2,\n\t\t\t\t  MDIO_XGXS_BLOCK2_TX_LN_SWAP,\n\t\t\t\t  (tx_lane_swap |\n\t\t\t\t   MDIO_XGXS_BLOCK2_TX_LN_SWAP_ENABLE));\n\t} else {\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_XGXS_BLOCK2,\n\t\t\t\t  MDIO_XGXS_BLOCK2_TX_LN_SWAP, 0);\n\t}\n}\n\nstatic void bnx2x_set_parallel_detection(struct bnx2x_phy *phy,\n\t\t\t\t\t struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 control2;\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_A_1000X_CONTROL2,\n\t\t\t  &control2);\n\tif (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)\n\t\tcontrol2 |= MDIO_SERDES_DIGITAL_A_1000X_CONTROL2_PRL_DT_EN;\n\telse\n\t\tcontrol2 &= ~MDIO_SERDES_DIGITAL_A_1000X_CONTROL2_PRL_DT_EN;\n\tDP(NETIF_MSG_LINK, \"phy->speed_cap_mask = 0x%x, control2 = 0x%x\\n\",\n\t\tphy->speed_cap_mask, control2);\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_A_1000X_CONTROL2,\n\t\t\t  control2);\n\n\tif ((phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) &&\n\t     (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)) {\n\t\tDP(NETIF_MSG_LINK, \"XGXS\\n\");\n\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t MDIO_REG_BANK_10G_PARALLEL_DETECT,\n\t\t\t\t MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_LINK,\n\t\t\t\t MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_LINK_CNT);\n\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_10G_PARALLEL_DETECT,\n\t\t\t\t  MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL,\n\t\t\t\t  &control2);\n\n\n\t\tcontrol2 |=\n\t\t    MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL_PARDET10G_EN;\n\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_10G_PARALLEL_DETECT,\n\t\t\t\t  MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL,\n\t\t\t\t  control2);\n\n\t\t/* Disable parallel detection of HiG */\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_XGXS_BLOCK2,\n\t\t\t\t  MDIO_XGXS_BLOCK2_UNICORE_MODE_10G,\n\t\t\t\t  MDIO_XGXS_BLOCK2_UNICORE_MODE_10G_CX4_XGXS |\n\t\t\t\t  MDIO_XGXS_BLOCK2_UNICORE_MODE_10G_HIGIG_XGXS);\n\t}\n}\n\nstatic void bnx2x_set_autoneg(struct bnx2x_phy *phy,\n\t\t\t      struct link_params *params,\n\t\t\t      struct link_vars *vars,\n\t\t\t      u8 enable_cl73)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 reg_val;\n\n\t/* CL37 Autoneg */\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL, &reg_val);\n\n\t/* CL37 Autoneg Enabled */\n\tif (vars->line_speed == SPEED_AUTO_NEG)\n\t\treg_val |= MDIO_COMBO_IEEO_MII_CONTROL_AN_EN;\n\telse /* CL37 Autoneg Disabled */\n\t\treg_val &= ~(MDIO_COMBO_IEEO_MII_CONTROL_AN_EN |\n\t\t\t     MDIO_COMBO_IEEO_MII_CONTROL_RESTART_AN);\n\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL, reg_val);\n\n\t/* Enable/Disable Autodetection */\n\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_A_1000X_CONTROL1, &reg_val);\n\treg_val &= ~(MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_SIGNAL_DETECT_EN |\n\t\t    MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_INVERT_SIGNAL_DETECT);\n\treg_val |= MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_FIBER_MODE;\n\tif (vars->line_speed == SPEED_AUTO_NEG)\n\t\treg_val |= MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_AUTODET;\n\telse\n\t\treg_val &= ~MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_AUTODET;\n\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_A_1000X_CONTROL1, reg_val);\n\n\t/* Enable TetonII and BAM autoneg */\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_BAM_NEXT_PAGE,\n\t\t\t  MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL,\n\t\t\t  &reg_val);\n\tif (vars->line_speed == SPEED_AUTO_NEG) {\n\t\t/* Enable BAM aneg Mode and TetonII aneg Mode */\n\t\treg_val |= (MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_BAM_MODE |\n\t\t\t    MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_TETON_AN);\n\t} else {\n\t\t/* TetonII and BAM Autoneg Disabled */\n\t\treg_val &= ~(MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_BAM_MODE |\n\t\t\t     MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_TETON_AN);\n\t}\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_BAM_NEXT_PAGE,\n\t\t\t  MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL,\n\t\t\t  reg_val);\n\n\tif (enable_cl73) {\n\t\t/* Enable Cl73 FSM status bits */\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_CL73_USERB0,\n\t\t\t\t  MDIO_CL73_USERB0_CL73_UCTRL,\n\t\t\t\t  0xe);\n\n\t\t/* Enable BAM Station Manager*/\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\tMDIO_REG_BANK_CL73_USERB0,\n\t\t\tMDIO_CL73_USERB0_CL73_BAM_CTRL1,\n\t\t\tMDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_EN |\n\t\t\tMDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_STATION_MNGR_EN |\n\t\t\tMDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_NP_AFTER_BP_EN);\n\n\t\t/* Advertise CL73 link speeds */\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_CL73_IEEEB1,\n\t\t\t\t  MDIO_CL73_IEEEB1_AN_ADV2,\n\t\t\t\t  &reg_val);\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)\n\t\t\treg_val |= MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KX4;\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)\n\t\t\treg_val |= MDIO_CL73_IEEEB1_AN_ADV2_ADVR_1000M_KX;\n\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_CL73_IEEEB1,\n\t\t\t\t  MDIO_CL73_IEEEB1_AN_ADV2,\n\t\t\t\t  reg_val);\n\n\t\t/* CL73 Autoneg Enabled */\n\t\treg_val = MDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN;\n\n\t} else /* CL73 Autoneg Disabled */\n\t\treg_val = 0;\n\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_CL73_IEEEB0,\n\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL, reg_val);\n}\n\n/* Program SerDes, forced speed */\nstatic void bnx2x_program_serdes(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params,\n\t\t\t\t struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 reg_val;\n\n\t/* Program duplex, disable autoneg and sgmii*/\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL, &reg_val);\n\treg_val &= ~(MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX |\n\t\t     MDIO_COMBO_IEEO_MII_CONTROL_AN_EN |\n\t\t     MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_MASK);\n\tif (phy->req_duplex == DUPLEX_FULL)\n\t\treg_val |= MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX;\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL, reg_val);\n\n\t/* Program speed\n\t *  - needed only if the speed is greater than 1G (2.5G or 10G)\n\t */\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_MISC1, &reg_val);\n\t/* Clearing the speed value before setting the right speed */\n\tDP(NETIF_MSG_LINK, \"MDIO_REG_BANK_SERDES_DIGITAL = 0x%x\\n\", reg_val);\n\n\treg_val &= ~(MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_MASK |\n\t\t     MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_SEL);\n\n\tif (!((vars->line_speed == SPEED_1000) ||\n\t      (vars->line_speed == SPEED_100) ||\n\t      (vars->line_speed == SPEED_10))) {\n\n\t\treg_val |= (MDIO_SERDES_DIGITAL_MISC1_REFCLK_SEL_156_25M |\n\t\t\t    MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_SEL);\n\t\tif (vars->line_speed == SPEED_10000)\n\t\t\treg_val |=\n\t\t\t\tMDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_10G_CX4;\n\t}\n\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_MISC1, reg_val);\n\n}\n\nstatic void bnx2x_set_brcm_cl37_advertisement(struct bnx2x_phy *phy,\n\t\t\t\t\t      struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val = 0;\n\n\t/* Set extended capabilities */\n\tif (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G)\n\t\tval |= MDIO_OVER_1G_UP1_2_5G;\n\tif (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)\n\t\tval |= MDIO_OVER_1G_UP1_10G;\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_OVER_1G,\n\t\t\t  MDIO_OVER_1G_UP1, val);\n\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_OVER_1G,\n\t\t\t  MDIO_OVER_1G_UP3, 0x400);\n}\n\nstatic void bnx2x_set_ieee_aneg_advertisement(struct bnx2x_phy *phy,\n\t\t\t\t\t      struct link_params *params,\n\t\t\t\t\t      u16 ieee_fc)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val;\n\t/* For AN, we are always publishing full duplex */\n\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t  MDIO_COMBO_IEEE0_AUTO_NEG_ADV, ieee_fc);\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_CL73_IEEEB1,\n\t\t\t  MDIO_CL73_IEEEB1_AN_ADV1, &val);\n\tval &= ~MDIO_CL73_IEEEB1_AN_ADV1_PAUSE_BOTH;\n\tval |= ((ieee_fc<<3) & MDIO_CL73_IEEEB1_AN_ADV1_PAUSE_MASK);\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_CL73_IEEEB1,\n\t\t\t  MDIO_CL73_IEEEB1_AN_ADV1, val);\n}\n\nstatic void bnx2x_restart_autoneg(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params,\n\t\t\t\t  u8 enable_cl73)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 mii_control;\n\n\tDP(NETIF_MSG_LINK, \"bnx2x_restart_autoneg\\n\");\n\t/* Enable and restart BAM/CL37 aneg */\n\n\tif (enable_cl73) {\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_CL73_IEEEB0,\n\t\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL,\n\t\t\t\t  &mii_control);\n\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_CL73_IEEEB0,\n\t\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL,\n\t\t\t\t  (mii_control |\n\t\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN |\n\t\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL_RESTART_AN));\n\t} else {\n\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL,\n\t\t\t\t  &mii_control);\n\t\tDP(NETIF_MSG_LINK,\n\t\t\t \"bnx2x_restart_autoneg mii_control before = 0x%x\\n\",\n\t\t\t mii_control);\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL,\n\t\t\t\t  (mii_control |\n\t\t\t\t   MDIO_COMBO_IEEO_MII_CONTROL_AN_EN |\n\t\t\t\t   MDIO_COMBO_IEEO_MII_CONTROL_RESTART_AN));\n\t}\n}\n\nstatic void bnx2x_initialize_sgmii_process(struct bnx2x_phy *phy,\n\t\t\t\t\t   struct link_params *params,\n\t\t\t\t\t   struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 control1;\n\n\t/* In SGMII mode, the unicore is always slave */\n\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_A_1000X_CONTROL1,\n\t\t\t  &control1);\n\tcontrol1 |= MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_INVERT_SIGNAL_DETECT;\n\t/* Set sgmii mode (and not fiber) */\n\tcontrol1 &= ~(MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_FIBER_MODE |\n\t\t      MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_AUTODET |\n\t\t      MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_MSTR_MODE);\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_A_1000X_CONTROL1,\n\t\t\t  control1);\n\n\t/* If forced speed */\n\tif (!(vars->line_speed == SPEED_AUTO_NEG)) {\n\t\t/* Set speed, disable autoneg */\n\t\tu16 mii_control;\n\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL,\n\t\t\t\t  &mii_control);\n\t\tmii_control &= ~(MDIO_COMBO_IEEO_MII_CONTROL_AN_EN |\n\t\t\t\t MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_MASK|\n\t\t\t\t MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX);\n\n\t\tswitch (vars->line_speed) {\n\t\tcase SPEED_100:\n\t\t\tmii_control |=\n\t\t\t\tMDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_100;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tmii_control |=\n\t\t\t\tMDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_1000;\n\t\t\tbreak;\n\t\tcase SPEED_10:\n\t\t\t/* There is nothing to set for 10M */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Invalid speed for SGMII */\n\t\t\tDP(NETIF_MSG_LINK, \"Invalid line_speed 0x%x\\n\",\n\t\t\t\t  vars->line_speed);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Setting the full duplex */\n\t\tif (phy->req_duplex == DUPLEX_FULL)\n\t\t\tmii_control |=\n\t\t\t\tMDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX;\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL,\n\t\t\t\t  mii_control);\n\n\t} else { /* AN mode */\n\t\t/* Enable and restart AN */\n\t\tbnx2x_restart_autoneg(phy, params, 0);\n\t}\n}\n\n/* Link management\n */\nstatic int bnx2x_direct_parallel_detect_used(struct bnx2x_phy *phy,\n\t\t\t\t\t     struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 pd_10g, status2_1000x;\n\tif (phy->req_line_speed != SPEED_AUTO_NEG)\n\t\treturn 0;\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_A_1000X_STATUS2,\n\t\t\t  &status2_1000x);\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_A_1000X_STATUS2,\n\t\t\t  &status2_1000x);\n\tif (status2_1000x & MDIO_SERDES_DIGITAL_A_1000X_STATUS2_AN_DISABLED) {\n\t\tDP(NETIF_MSG_LINK, \"1G parallel detect link on port %d\\n\",\n\t\t\t params->port);\n\t\treturn 1;\n\t}\n\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_10G_PARALLEL_DETECT,\n\t\t\t  MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_STATUS,\n\t\t\t  &pd_10g);\n\n\tif (pd_10g & MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_STATUS_PD_LINK) {\n\t\tDP(NETIF_MSG_LINK, \"10G parallel detect link on port %d\\n\",\n\t\t\t params->port);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void bnx2x_update_adv_fc(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params,\n\t\t\t\tstruct link_vars *vars,\n\t\t\t\tu32 gp_status)\n{\n\tu16 ld_pause;   /* local driver */\n\tu16 lp_pause;   /* link partner */\n\tu16 pause_result;\n\tstruct bnx2x *bp = params->bp;\n\tif ((gp_status &\n\t     (MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_AUTONEG_COMPLETE |\n\t      MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_MR_LP_NP_AN_ABLE)) ==\n\t    (MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_AUTONEG_COMPLETE |\n\t     MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_MR_LP_NP_AN_ABLE)) {\n\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_CL73_IEEEB1,\n\t\t\t\t  MDIO_CL73_IEEEB1_AN_ADV1,\n\t\t\t\t  &ld_pause);\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_CL73_IEEEB1,\n\t\t\t\t  MDIO_CL73_IEEEB1_AN_LP_ADV1,\n\t\t\t\t  &lp_pause);\n\t\tpause_result = (ld_pause &\n\t\t\t\tMDIO_CL73_IEEEB1_AN_ADV1_PAUSE_MASK) >> 8;\n\t\tpause_result |= (lp_pause &\n\t\t\t\t MDIO_CL73_IEEEB1_AN_LP_ADV1_PAUSE_MASK) >> 10;\n\t\tDP(NETIF_MSG_LINK, \"pause_result CL73 0x%x\\n\", pause_result);\n\t} else {\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t\t  MDIO_COMBO_IEEE0_AUTO_NEG_ADV,\n\t\t\t\t  &ld_pause);\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\tMDIO_REG_BANK_COMBO_IEEE0,\n\t\t\tMDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1,\n\t\t\t&lp_pause);\n\t\tpause_result = (ld_pause &\n\t\t\t\tMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_MASK)>>5;\n\t\tpause_result |= (lp_pause &\n\t\t\t\t MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_MASK)>>7;\n\t\tDP(NETIF_MSG_LINK, \"pause_result CL37 0x%x\\n\", pause_result);\n\t}\n\tbnx2x_pause_resolve(phy, params, vars, pause_result);\n\n}\n\nstatic void bnx2x_flow_ctrl_resolve(struct bnx2x_phy *phy,\n\t\t\t\t    struct link_params *params,\n\t\t\t\t    struct link_vars *vars,\n\t\t\t\t    u32 gp_status)\n{\n\tstruct bnx2x *bp = params->bp;\n\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\n\t/* Resolve from gp_status in case of AN complete and not sgmii */\n\tif (phy->req_flow_ctrl != BNX2X_FLOW_CTRL_AUTO) {\n\t\t/* Update the advertised flow-controled of LD/LP in AN */\n\t\tif (phy->req_line_speed == SPEED_AUTO_NEG)\n\t\t\tbnx2x_update_adv_fc(phy, params, vars, gp_status);\n\t\t/* But set the flow-control result as the requested one */\n\t\tvars->flow_ctrl = phy->req_flow_ctrl;\n\t} else if (phy->req_line_speed != SPEED_AUTO_NEG)\n\t\tvars->flow_ctrl = params->req_fc_auto_adv;\n\telse if ((gp_status & MDIO_AN_CL73_OR_37_COMPLETE) &&\n\t\t (!(vars->phy_flags & PHY_SGMII_FLAG))) {\n\t\tif (bnx2x_direct_parallel_detect_used(phy, params)) {\n\t\t\tvars->flow_ctrl = params->req_fc_auto_adv;\n\t\t\treturn;\n\t\t}\n\t\tbnx2x_update_adv_fc(phy, params, vars, gp_status);\n\t}\n\tDP(NETIF_MSG_LINK, \"flow_ctrl 0x%x\\n\", vars->flow_ctrl);\n}\n\nstatic void bnx2x_check_fallback_to_cl37(struct bnx2x_phy *phy,\n\t\t\t\t\t struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 rx_status, ustat_val, cl37_fsm_received;\n\tDP(NETIF_MSG_LINK, \"bnx2x_check_fallback_to_cl37\\n\");\n\t/* Step 1: Make sure signal is detected */\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_RX0,\n\t\t\t  MDIO_RX0_RX_STATUS,\n\t\t\t  &rx_status);\n\tif ((rx_status & MDIO_RX0_RX_STATUS_SIGDET) !=\n\t    (MDIO_RX0_RX_STATUS_SIGDET)) {\n\t\tDP(NETIF_MSG_LINK, \"Signal is not detected. Restoring CL73.\"\n\t\t\t     \"rx_status(0x80b0) = 0x%x\\n\", rx_status);\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_CL73_IEEEB0,\n\t\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL,\n\t\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN);\n\t\treturn;\n\t}\n\t/* Step 2: Check CL73 state machine */\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_CL73_USERB0,\n\t\t\t  MDIO_CL73_USERB0_CL73_USTAT1,\n\t\t\t  &ustat_val);\n\tif ((ustat_val &\n\t     (MDIO_CL73_USERB0_CL73_USTAT1_LINK_STATUS_CHECK |\n\t      MDIO_CL73_USERB0_CL73_USTAT1_AN_GOOD_CHECK_BAM37)) !=\n\t    (MDIO_CL73_USERB0_CL73_USTAT1_LINK_STATUS_CHECK |\n\t      MDIO_CL73_USERB0_CL73_USTAT1_AN_GOOD_CHECK_BAM37)) {\n\t\tDP(NETIF_MSG_LINK, \"CL73 state-machine is not stable. \"\n\t\t\t     \"ustat_val(0x8371) = 0x%x\\n\", ustat_val);\n\t\treturn;\n\t}\n\t/* Step 3: Check CL37 Message Pages received to indicate LP\n\t * supports only CL37\n\t */\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_REMOTE_PHY,\n\t\t\t  MDIO_REMOTE_PHY_MISC_RX_STATUS,\n\t\t\t  &cl37_fsm_received);\n\tif ((cl37_fsm_received &\n\t     (MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_OVER1G_MSG |\n\t     MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_BRCM_OUI_MSG)) !=\n\t    (MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_OVER1G_MSG |\n\t      MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_BRCM_OUI_MSG)) {\n\t\tDP(NETIF_MSG_LINK, \"No CL37 FSM were received. \"\n\t\t\t     \"misc_rx_status(0x8330) = 0x%x\\n\",\n\t\t\t cl37_fsm_received);\n\t\treturn;\n\t}\n\t/* The combined cl37/cl73 fsm state information indicating that\n\t * we are connected to a device which does not support cl73, but\n\t * does support cl37 BAM. In this case we disable cl73 and\n\t * restart cl37 auto-neg\n\t */\n\n\t/* Disable CL73 */\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_CL73_IEEEB0,\n\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL,\n\t\t\t  0);\n\t/* Restart CL37 autoneg */\n\tbnx2x_restart_autoneg(phy, params, 0);\n\tDP(NETIF_MSG_LINK, \"Disabling CL73, and restarting CL37 autoneg\\n\");\n}\n\nstatic void bnx2x_xgxs_an_resolve(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params,\n\t\t\t\t  struct link_vars *vars,\n\t\t\t\t  u32 gp_status)\n{\n\tif (gp_status & MDIO_AN_CL73_OR_37_COMPLETE)\n\t\tvars->link_status |=\n\t\t\tLINK_STATUS_AUTO_NEGOTIATE_COMPLETE;\n\n\tif (bnx2x_direct_parallel_detect_used(phy, params))\n\t\tvars->link_status |=\n\t\t\tLINK_STATUS_PARALLEL_DETECTION_USED;\n}\nstatic int bnx2x_get_link_speed_duplex(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params,\n\t\t\t\t      struct link_vars *vars,\n\t\t\t\t      u16 is_link_up,\n\t\t\t\t      u16 speed_mask,\n\t\t\t\t      u16 is_duplex)\n{\n\tstruct bnx2x *bp = params->bp;\n\tif (phy->req_line_speed == SPEED_AUTO_NEG)\n\t\tvars->link_status |= LINK_STATUS_AUTO_NEGOTIATE_ENABLED;\n\tif (is_link_up) {\n\t\tDP(NETIF_MSG_LINK, \"phy link up\\n\");\n\n\t\tvars->phy_link_up = 1;\n\t\tvars->link_status |= LINK_STATUS_LINK_UP;\n\n\t\tswitch (speed_mask) {\n\t\tcase GP_STATUS_10M:\n\t\t\tvars->line_speed = SPEED_10;\n\t\t\tif (is_duplex == DUPLEX_FULL)\n\t\t\t\tvars->link_status |= LINK_10TFD;\n\t\t\telse\n\t\t\t\tvars->link_status |= LINK_10THD;\n\t\t\tbreak;\n\n\t\tcase GP_STATUS_100M:\n\t\t\tvars->line_speed = SPEED_100;\n\t\t\tif (is_duplex == DUPLEX_FULL)\n\t\t\t\tvars->link_status |= LINK_100TXFD;\n\t\t\telse\n\t\t\t\tvars->link_status |= LINK_100TXHD;\n\t\t\tbreak;\n\n\t\tcase GP_STATUS_1G:\n\t\tcase GP_STATUS_1G_KX:\n\t\t\tvars->line_speed = SPEED_1000;\n\t\t\tif (is_duplex == DUPLEX_FULL)\n\t\t\t\tvars->link_status |= LINK_1000TFD;\n\t\t\telse\n\t\t\t\tvars->link_status |= LINK_1000THD;\n\t\t\tbreak;\n\n\t\tcase GP_STATUS_2_5G:\n\t\t\tvars->line_speed = SPEED_2500;\n\t\t\tif (is_duplex == DUPLEX_FULL)\n\t\t\t\tvars->link_status |= LINK_2500TFD;\n\t\t\telse\n\t\t\t\tvars->link_status |= LINK_2500THD;\n\t\t\tbreak;\n\n\t\tcase GP_STATUS_5G:\n\t\tcase GP_STATUS_6G:\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t \"link speed unsupported  gp_status 0x%x\\n\",\n\t\t\t\t  speed_mask);\n\t\t\treturn -EINVAL;\n\n\t\tcase GP_STATUS_10G_KX4:\n\t\tcase GP_STATUS_10G_HIG:\n\t\tcase GP_STATUS_10G_CX4:\n\t\tcase GP_STATUS_10G_KR:\n\t\tcase GP_STATUS_10G_SFI:\n\t\tcase GP_STATUS_10G_XFI:\n\t\t\tvars->line_speed = SPEED_10000;\n\t\t\tvars->link_status |= LINK_10GTFD;\n\t\t\tbreak;\n\t\tcase GP_STATUS_20G_DXGXS:\n\t\tcase GP_STATUS_20G_KR2:\n\t\t\tvars->line_speed = SPEED_20000;\n\t\t\tvars->link_status |= LINK_20GTFD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t  \"link speed unsupported gp_status 0x%x\\n\",\n\t\t\t\t  speed_mask);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else { /* link_down */\n\t\tDP(NETIF_MSG_LINK, \"phy link down\\n\");\n\n\t\tvars->phy_link_up = 0;\n\n\t\tvars->duplex = DUPLEX_FULL;\n\t\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\t\tvars->mac_type = MAC_TYPE_NONE;\n\t}\n\tDP(NETIF_MSG_LINK, \" phy_link_up %x line_speed %d\\n\",\n\t\t    vars->phy_link_up, vars->line_speed);\n\treturn 0;\n}\n\nstatic u8 bnx2x_link_settings_status(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params,\n\t\t\t\t     struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tu16 gp_status, duplex = DUPLEX_HALF, link_up = 0, speed_mask;\n\tint rc = 0;\n\n\t/* Read gp_status */\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_GP_STATUS,\n\t\t\t  MDIO_GP_STATUS_TOP_AN_STATUS1,\n\t\t\t  &gp_status);\n\tif (gp_status & MDIO_GP_STATUS_TOP_AN_STATUS1_DUPLEX_STATUS)\n\t\tduplex = DUPLEX_FULL;\n\tif (gp_status & MDIO_GP_STATUS_TOP_AN_STATUS1_LINK_STATUS)\n\t\tlink_up = 1;\n\tspeed_mask = gp_status & GP_STATUS_SPEED_MASK;\n\tDP(NETIF_MSG_LINK, \"gp_status 0x%x, is_link_up %d, speed_mask 0x%x\\n\",\n\t\t       gp_status, link_up, speed_mask);\n\trc = bnx2x_get_link_speed_duplex(phy, params, vars, link_up, speed_mask,\n\t\t\t\t\t duplex);\n\tif (rc == -EINVAL)\n\t\treturn rc;\n\n\tif (gp_status & MDIO_GP_STATUS_TOP_AN_STATUS1_LINK_STATUS) {\n\t\tif (SINGLE_MEDIA_DIRECT(params)) {\n\t\t\tvars->duplex = duplex;\n\t\t\tbnx2x_flow_ctrl_resolve(phy, params, vars, gp_status);\n\t\t\tif (phy->req_line_speed == SPEED_AUTO_NEG)\n\t\t\t\tbnx2x_xgxs_an_resolve(phy, params, vars,\n\t\t\t\t\t\t      gp_status);\n\t\t}\n\t} else { /* Link_down */\n\t\tif ((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t\t    SINGLE_MEDIA_DIRECT(params)) {\n\t\t\t/* Check signal is detected */\n\t\t\tbnx2x_check_fallback_to_cl37(phy, params);\n\t\t}\n\t}\n\n\t/* Read LP advertised speeds*/\n\tif (SINGLE_MEDIA_DIRECT(params) &&\n\t    (vars->link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE)) {\n\t\tu16 val;\n\n\t\tCL22_RD_OVER_CL45(bp, phy, MDIO_REG_BANK_CL73_IEEEB1,\n\t\t\t\t  MDIO_CL73_IEEEB1_AN_LP_ADV2, &val);\n\n\t\tif (val & MDIO_CL73_IEEEB1_AN_ADV2_ADVR_1000M_KX)\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE;\n\t\tif (val & (MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KX4 |\n\t\t\t   MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KR))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\n\n\t\tCL22_RD_OVER_CL45(bp, phy, MDIO_REG_BANK_OVER_1G,\n\t\t\t\t  MDIO_OVER_1G_LP_UP1, &val);\n\n\t\tif (val & MDIO_OVER_1G_UP1_2_5G)\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_2500XFD_CAPABLE;\n\t\tif (val & (MDIO_OVER_1G_UP1_10G | MDIO_OVER_1G_UP1_10GH))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\n\t}\n\n\tDP(NETIF_MSG_LINK, \"duplex %x  flow_ctrl 0x%x link_status 0x%x\\n\",\n\t\t   vars->duplex, vars->flow_ctrl, vars->link_status);\n\treturn rc;\n}\n\nstatic u8 bnx2x_warpcore_read_status(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params,\n\t\t\t\t     struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 lane;\n\tu16 gp_status1, gp_speed, link_up, duplex = DUPLEX_FULL;\n\tint rc = 0;\n\tlane = bnx2x_get_warpcore_lane(phy, params);\n\t/* Read gp_status */\n\tif ((params->loopback_mode) &&\n\t    (phy->flags & FLAGS_WC_DUAL_MODE)) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_DIGITAL5_LINK_STATUS, &link_up);\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_DIGITAL5_LINK_STATUS, &link_up);\n\t\tlink_up &= 0x1;\n\t} else if ((phy->req_line_speed > SPEED_10000) &&\n\t\t(phy->supported & SUPPORTED_20000baseMLD2_Full)) {\n\t\tu16 temp_link_up;\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t1, &temp_link_up);\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t1, &link_up);\n\t\tDP(NETIF_MSG_LINK, \"PCS RX link status = 0x%x-->0x%x\\n\",\n\t\t\t       temp_link_up, link_up);\n\t\tlink_up &= (1<<2);\n\t\tif (link_up)\n\t\t\tbnx2x_ext_phy_resolve_fc(phy, params, vars);\n\t} else {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_GP2_STATUS_GP_2_1,\n\t\t\t\t&gp_status1);\n\t\tDP(NETIF_MSG_LINK, \"0x81d1 = 0x%x\\n\", gp_status1);\n\t\t/* Check for either KR, 1G, or AN up. */\n\t\tlink_up = ((gp_status1 >> 8) |\n\t\t\t   (gp_status1 >> 12) |\n\t\t\t   (gp_status1)) &\n\t\t\t(1 << lane);\n\t\tif (phy->supported & SUPPORTED_20000baseKR2_Full) {\n\t\t\tu16 an_link;\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_AN_REG_STATUS, &an_link);\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_AN_REG_STATUS, &an_link);\n\t\t\tlink_up |= (an_link & (1<<2));\n\t\t}\n\t\tif (link_up && SINGLE_MEDIA_DIRECT(params)) {\n\t\t\tu16 pd, gp_status4;\n\t\t\tif (phy->req_line_speed == SPEED_AUTO_NEG) {\n\t\t\t\t/* Check Autoneg complete */\n\t\t\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t\tMDIO_WC_REG_GP2_STATUS_GP_2_4,\n\t\t\t\t\t\t&gp_status4);\n\t\t\t\tif (gp_status4 & ((1<<12)<<lane))\n\t\t\t\t\tvars->link_status |=\n\t\t\t\t\tLINK_STATUS_AUTO_NEGOTIATE_COMPLETE;\n\n\t\t\t\t/* Check parallel detect used */\n\t\t\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t\tMDIO_WC_REG_PAR_DET_10G_STATUS,\n\t\t\t\t\t\t&pd);\n\t\t\t\tif (pd & (1<<15))\n\t\t\t\t\tvars->link_status |=\n\t\t\t\t\tLINK_STATUS_PARALLEL_DETECTION_USED;\n\t\t\t}\n\t\t\tbnx2x_ext_phy_resolve_fc(phy, params, vars);\n\t\t\tvars->duplex = duplex;\n\t\t}\n\t}\n\n\tif ((vars->link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE) &&\n\t    SINGLE_MEDIA_DIRECT(params)) {\n\t\tu16 val;\n\n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_LP_AUTO_NEG2, &val);\n\n\t\tif (val & MDIO_CL73_IEEEB1_AN_ADV2_ADVR_1000M_KX)\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE;\n\t\tif (val & (MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KX4 |\n\t\t\t   MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KR))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\n\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_DIGITAL3_LP_UP1, &val);\n\n\t\tif (val & MDIO_OVER_1G_UP1_2_5G)\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_2500XFD_CAPABLE;\n\t\tif (val & (MDIO_OVER_1G_UP1_10G | MDIO_OVER_1G_UP1_10GH))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\n\n\t}\n\n\n\tif (lane < 2) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_GP2_STATUS_GP_2_2, &gp_speed);\n\t} else {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_GP2_STATUS_GP_2_3, &gp_speed);\n\t}\n\tDP(NETIF_MSG_LINK, \"lane %d gp_speed 0x%x\\n\", lane, gp_speed);\n\n\tif ((lane & 1) == 0)\n\t\tgp_speed <<= 8;\n\tgp_speed &= 0x3f00;\n\tlink_up = !!link_up;\n\n\trc = bnx2x_get_link_speed_duplex(phy, params, vars, link_up, gp_speed,\n\t\t\t\t\t duplex);\n\n\t/* In case of KR link down, start up the recovering procedure */\n\tif ((!link_up) && (phy->media_type == ETH_PHY_KR) &&\n\t    (!(phy->flags & FLAGS_WC_DUAL_MODE)))\n\t\tvars->rx_tx_asic_rst = MAX_KR_LINK_RETRY;\n\n\tDP(NETIF_MSG_LINK, \"duplex %x  flow_ctrl 0x%x link_status 0x%x\\n\",\n\t\t   vars->duplex, vars->flow_ctrl, vars->link_status);\n\treturn rc;\n}\nstatic void bnx2x_set_gmii_tx_driver(struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tstruct bnx2x_phy *phy = &params->phy[INT_PHY];\n\tu16 lp_up2;\n\tu16 tx_driver;\n\tu16 bank;\n\n\t/* Read precomp */\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_OVER_1G,\n\t\t\t  MDIO_OVER_1G_LP_UP2, &lp_up2);\n\n\t/* Bits [10:7] at lp_up2, positioned at [15:12] */\n\tlp_up2 = (((lp_up2 & MDIO_OVER_1G_LP_UP2_PREEMPHASIS_MASK) >>\n\t\t   MDIO_OVER_1G_LP_UP2_PREEMPHASIS_SHIFT) <<\n\t\t  MDIO_TX0_TX_DRIVER_PREEMPHASIS_SHIFT);\n\n\tif (lp_up2 == 0)\n\t\treturn;\n\n\tfor (bank = MDIO_REG_BANK_TX0; bank <= MDIO_REG_BANK_TX3;\n\t      bank += (MDIO_REG_BANK_TX1 - MDIO_REG_BANK_TX0)) {\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  bank,\n\t\t\t\t  MDIO_TX0_TX_DRIVER, &tx_driver);\n\n\t\t/* Replace tx_driver bits [15:12] */\n\t\tif (lp_up2 !=\n\t\t    (tx_driver & MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK)) {\n\t\t\ttx_driver &= ~MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK;\n\t\t\ttx_driver |= lp_up2;\n\t\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t\t  bank,\n\t\t\t\t\t  MDIO_TX0_TX_DRIVER, tx_driver);\n\t\t}\n\t}\n}\n\nstatic int bnx2x_emac_program(struct link_params *params,\n\t\t\t      struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\tu16 mode = 0;\n\n\tDP(NETIF_MSG_LINK, \"setting link speed & duplex\\n\");\n\tbnx2x_bits_dis(bp, GRCBASE_EMAC0 + port*0x400 +\n\t\t       EMAC_REG_EMAC_MODE,\n\t\t       (EMAC_MODE_25G_MODE |\n\t\t\tEMAC_MODE_PORT_MII_10M |\n\t\t\tEMAC_MODE_HALF_DUPLEX));\n\tswitch (vars->line_speed) {\n\tcase SPEED_10:\n\t\tmode |= EMAC_MODE_PORT_MII_10M;\n\t\tbreak;\n\n\tcase SPEED_100:\n\t\tmode |= EMAC_MODE_PORT_MII;\n\t\tbreak;\n\n\tcase SPEED_1000:\n\t\tmode |= EMAC_MODE_PORT_GMII;\n\t\tbreak;\n\n\tcase SPEED_2500:\n\t\tmode |= (EMAC_MODE_25G_MODE | EMAC_MODE_PORT_GMII);\n\t\tbreak;\n\n\tdefault:\n\t\t/* 10G not valid for EMAC */\n\t\tDP(NETIF_MSG_LINK, \"Invalid line_speed 0x%x\\n\",\n\t\t\t   vars->line_speed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (vars->duplex == DUPLEX_HALF)\n\t\tmode |= EMAC_MODE_HALF_DUPLEX;\n\tbnx2x_bits_en(bp,\n\t\t      GRCBASE_EMAC0 + port*0x400 + EMAC_REG_EMAC_MODE,\n\t\t      mode);\n\n\tbnx2x_set_led(params, vars, LED_MODE_OPER, vars->line_speed);\n\treturn 0;\n}\n\nstatic void bnx2x_set_preemphasis(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params)\n{\n\n\tu16 bank, i = 0;\n\tstruct bnx2x *bp = params->bp;\n\n\tfor (bank = MDIO_REG_BANK_RX0, i = 0; bank <= MDIO_REG_BANK_RX3;\n\t      bank += (MDIO_REG_BANK_RX1-MDIO_REG_BANK_RX0), i++) {\n\t\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t\t  bank,\n\t\t\t\t\t  MDIO_RX0_RX_EQ_BOOST,\n\t\t\t\t\t  phy->rx_preemphasis[i]);\n\t}\n\n\tfor (bank = MDIO_REG_BANK_TX0, i = 0; bank <= MDIO_REG_BANK_TX3;\n\t\t      bank += (MDIO_REG_BANK_TX1 - MDIO_REG_BANK_TX0), i++) {\n\t\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t\t  bank,\n\t\t\t\t\t  MDIO_TX0_TX_DRIVER,\n\t\t\t\t\t  phy->tx_preemphasis[i]);\n\t}\n}\n\nstatic void bnx2x_xgxs_config_init(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 enable_cl73 = (SINGLE_MEDIA_DIRECT(params) ||\n\t\t\t  (params->loopback_mode == LOOPBACK_XGXS));\n\tif (!(vars->phy_flags & PHY_SGMII_FLAG)) {\n\t\tif (SINGLE_MEDIA_DIRECT(params) &&\n\t\t    (params->feature_config_flags &\n\t\t     FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED))\n\t\t\tbnx2x_set_preemphasis(phy, params);\n\n\t\t/* Forced speed requested? */\n\t\tif (vars->line_speed != SPEED_AUTO_NEG ||\n\t\t    (SINGLE_MEDIA_DIRECT(params) &&\n\t\t     params->loopback_mode == LOOPBACK_EXT)) {\n\t\t\tDP(NETIF_MSG_LINK, \"not SGMII, no AN\\n\");\n\n\t\t\t/* Disable autoneg */\n\t\t\tbnx2x_set_autoneg(phy, params, vars, 0);\n\n\t\t\t/* Program speed and duplex */\n\t\t\tbnx2x_program_serdes(phy, params, vars);\n\n\t\t} else { /* AN_mode */\n\t\t\tDP(NETIF_MSG_LINK, \"not SGMII, AN\\n\");\n\n\t\t\t/* AN enabled */\n\t\t\tbnx2x_set_brcm_cl37_advertisement(phy, params);\n\n\t\t\t/* Program duplex & pause advertisement (for aneg) */\n\t\t\tbnx2x_set_ieee_aneg_advertisement(phy, params,\n\t\t\t\t\t\t\t  vars->ieee_fc);\n\n\t\t\t/* Enable autoneg */\n\t\t\tbnx2x_set_autoneg(phy, params, vars, enable_cl73);\n\n\t\t\t/* Enable and restart AN */\n\t\t\tbnx2x_restart_autoneg(phy, params, enable_cl73);\n\t\t}\n\n\t} else { /* SGMII mode */\n\t\tDP(NETIF_MSG_LINK, \"SGMII\\n\");\n\n\t\tbnx2x_initialize_sgmii_process(phy, params, vars);\n\t}\n}\n\nstatic int bnx2x_prepare_xgxs(struct bnx2x_phy *phy,\n\t\t\t  struct link_params *params,\n\t\t\t  struct link_vars *vars)\n{\n\tint rc;\n\tvars->phy_flags |= PHY_XGXS_FLAG;\n\tif ((phy->req_line_speed &&\n\t     ((phy->req_line_speed == SPEED_100) ||\n\t      (phy->req_line_speed == SPEED_10))) ||\n\t    (!phy->req_line_speed &&\n\t     (phy->speed_cap_mask >=\n\t      PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL) &&\n\t     (phy->speed_cap_mask <\n\t      PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)) ||\n\t    (phy->type == PORT_HW_CFG_SERDES_EXT_PHY_TYPE_DIRECT_SD))\n\t\tvars->phy_flags |= PHY_SGMII_FLAG;\n\telse\n\t\tvars->phy_flags &= ~PHY_SGMII_FLAG;\n\n\tbnx2x_calc_ieee_aneg_adv(phy, params, &vars->ieee_fc);\n\tbnx2x_set_aer_mmd(params, phy);\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT)\n\t\tbnx2x_set_master_ln(params, phy);\n\n\trc = bnx2x_reset_unicore(params, phy, 0);\n\t/* Reset the SerDes and wait for reset bit return low */\n\tif (rc)\n\t\treturn rc;\n\n\tbnx2x_set_aer_mmd(params, phy);\n\t/* Setting the masterLn_def again after the reset */\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) {\n\t\tbnx2x_set_master_ln(params, phy);\n\t\tbnx2x_set_swap_lanes(params, phy);\n\t}\n\n\treturn rc;\n}\n\nstatic u16 bnx2x_wait_reset_complete(struct bnx2x *bp,\n\t\t\t\t     struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params)\n{\n\tu16 cnt, ctrl;\n\t/* Wait for soft reset to get cleared up to 1 sec */\n\tfor (cnt = 0; cnt < 1000; cnt++) {\n\t\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE)\n\t\t\tbnx2x_cl22_read(bp, phy,\n\t\t\t\tMDIO_PMA_REG_CTRL, &ctrl);\n\t\telse\n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_CTRL, &ctrl);\n\t\tif (!(ctrl & (1<<15)))\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tif (cnt == 1000)\n\t\tnetdev_err(bp->dev,  \"Warning: PHY was not initialized,\"\n\t\t\t\t      \" Port %d\\n\",\n\t\t\t params->port);\n\tDP(NETIF_MSG_LINK, \"control reg 0x%x (after %d ms)\\n\", ctrl, cnt);\n\treturn cnt;\n}\n\nstatic void bnx2x_link_int_enable(struct link_params *params)\n{\n\tu8 port = params->port;\n\tu32 mask;\n\tstruct bnx2x *bp = params->bp;\n\n\t/* Setting the status to report on link up for either XGXS or SerDes */\n\tif (CHIP_IS_E3(bp)) {\n\t\tmask = NIG_MASK_XGXS0_LINK_STATUS;\n\t\tif (!(SINGLE_MEDIA_DIRECT(params)))\n\t\t\tmask |= NIG_MASK_MI_INT;\n\t} else if (params->switch_cfg == SWITCH_CFG_10G) {\n\t\tmask = (NIG_MASK_XGXS0_LINK10G |\n\t\t\tNIG_MASK_XGXS0_LINK_STATUS);\n\t\tDP(NETIF_MSG_LINK, \"enabled XGXS interrupt\\n\");\n\t\tif (!(SINGLE_MEDIA_DIRECT(params)) &&\n\t\t\tparams->phy[INT_PHY].type !=\n\t\t\t\tPORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE) {\n\t\t\tmask |= NIG_MASK_MI_INT;\n\t\t\tDP(NETIF_MSG_LINK, \"enabled external phy int\\n\");\n\t\t}\n\n\t} else { /* SerDes */\n\t\tmask = NIG_MASK_SERDES0_LINK_STATUS;\n\t\tDP(NETIF_MSG_LINK, \"enabled SerDes interrupt\\n\");\n\t\tif (!(SINGLE_MEDIA_DIRECT(params)) &&\n\t\t\tparams->phy[INT_PHY].type !=\n\t\t\t\tPORT_HW_CFG_SERDES_EXT_PHY_TYPE_NOT_CONN) {\n\t\t\tmask |= NIG_MASK_MI_INT;\n\t\t\tDP(NETIF_MSG_LINK, \"enabled external phy int\\n\");\n\t\t}\n\t}\n\tbnx2x_bits_en(bp,\n\t\t      NIG_REG_MASK_INTERRUPT_PORT0 + port*4,\n\t\t      mask);\n\n\tDP(NETIF_MSG_LINK, \"port %x, is_xgxs %x, int_status 0x%x\\n\", port,\n\t\t (params->switch_cfg == SWITCH_CFG_10G),\n\t\t REG_RD(bp, NIG_REG_STATUS_INTERRUPT_PORT0 + port*4));\n\tDP(NETIF_MSG_LINK, \" int_mask 0x%x, MI_INT %x, SERDES_LINK %x\\n\",\n\t\t REG_RD(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4),\n\t\t REG_RD(bp, NIG_REG_EMAC0_STATUS_MISC_MI_INT + port*0x18),\n\t\t REG_RD(bp, NIG_REG_SERDES0_STATUS_LINK_STATUS+port*0x3c));\n\tDP(NETIF_MSG_LINK, \" 10G %x, XGXS_LINK %x\\n\",\n\t   REG_RD(bp, NIG_REG_XGXS0_STATUS_LINK10G + port*0x68),\n\t   REG_RD(bp, NIG_REG_XGXS0_STATUS_LINK_STATUS + port*0x68));\n}\n\nstatic void bnx2x_rearm_latch_signal(struct bnx2x *bp, u8 port,\n\t\t\t\t     u8 exp_mi_int)\n{\n\tu32 latch_status = 0;\n\n\t/* Disable the MI INT ( external phy int ) by writing 1 to the\n\t * status register. Link down indication is high-active-signal,\n\t * so in this case we need to write the status to clear the XOR\n\t */\n\t/* Read Latched signals */\n\tlatch_status = REG_RD(bp,\n\t\t\t\t    NIG_REG_LATCH_STATUS_0 + port*8);\n\tDP(NETIF_MSG_LINK, \"latch_status = 0x%x\\n\", latch_status);\n\t/* Handle only those with latched-signal=up.*/\n\tif (exp_mi_int)\n\t\tbnx2x_bits_en(bp,\n\t\t\t      NIG_REG_STATUS_INTERRUPT_PORT0\n\t\t\t      + port*4,\n\t\t\t      NIG_STATUS_EMAC0_MI_INT);\n\telse\n\t\tbnx2x_bits_dis(bp,\n\t\t\t       NIG_REG_STATUS_INTERRUPT_PORT0\n\t\t\t       + port*4,\n\t\t\t       NIG_STATUS_EMAC0_MI_INT);\n\n\tif (latch_status & 1) {\n\n\t\t/* For all latched-signal=up : Re-Arm Latch signals */\n\t\tREG_WR(bp, NIG_REG_LATCH_STATUS_0 + port*8,\n\t\t       (latch_status & 0xfffe) | (latch_status & 1));\n\t}\n\t/* For all latched-signal=up,Write original_signal to status */\n}\n\nstatic void bnx2x_link_int_ack(struct link_params *params,\n\t\t\t       struct link_vars *vars, u8 is_10g_plus)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\tu32 mask;\n\t/* First reset all status we assume only one line will be\n\t * change at a time\n\t */\n\tbnx2x_bits_dis(bp, NIG_REG_STATUS_INTERRUPT_PORT0 + port*4,\n\t\t       (NIG_STATUS_XGXS0_LINK10G |\n\t\t\tNIG_STATUS_XGXS0_LINK_STATUS |\n\t\t\tNIG_STATUS_SERDES0_LINK_STATUS));\n\tif (vars->phy_link_up) {\n\t\tif (USES_WARPCORE(bp))\n\t\t\tmask = NIG_STATUS_XGXS0_LINK_STATUS;\n\t\telse {\n\t\t\tif (is_10g_plus)\n\t\t\t\tmask = NIG_STATUS_XGXS0_LINK10G;\n\t\t\telse if (params->switch_cfg == SWITCH_CFG_10G) {\n\t\t\t\t/* Disable the link interrupt by writing 1 to\n\t\t\t\t * the relevant lane in the status register\n\t\t\t\t */\n\t\t\t\tu32 ser_lane =\n\t\t\t\t\t((params->lane_config &\n\t\t\t\t    PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK) >>\n\t\t\t\t    PORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT);\n\t\t\t\tmask = ((1 << ser_lane) <<\n\t\t\t\t       NIG_STATUS_XGXS0_LINK_STATUS_SIZE);\n\t\t\t} else\n\t\t\t\tmask = NIG_STATUS_SERDES0_LINK_STATUS;\n\t\t}\n\t\tDP(NETIF_MSG_LINK, \"Ack link up interrupt with mask 0x%x\\n\",\n\t\t\t       mask);\n\t\tbnx2x_bits_en(bp,\n\t\t\t      NIG_REG_STATUS_INTERRUPT_PORT0 + port*4,\n\t\t\t      mask);\n\t}\n}\n\nstatic int bnx2x_null_format_ver(u32 spirom_ver, u8 *str, u16 *len)\n{\n\tstr[0] = '\\0';\n\t(*len)--;\n\treturn 0;\n}\n\nstatic int bnx2x_format_ver(u32 num, u8 *str, u16 *len)\n{\n\tu16 ret;\n\n\tif (*len < 10) {\n\t\t/* Need more than 10chars for this format */\n\t\tbnx2x_null_format_ver(num, str, len);\n\t\treturn -EINVAL;\n\t}\n\n\tret = scnprintf(str, *len, \"%hx.%hx\", num >> 16, num);\n\t*len -= ret;\n\treturn 0;\n}\n\nstatic int bnx2x_3_seq_format_ver(u32 num, u8 *str, u16 *len)\n{\n\tu16 ret;\n\n\tif (*len < 10) {\n\t\t/* Need more than 10chars for this format */\n\t\tbnx2x_null_format_ver(num, str, len);\n\t\treturn -EINVAL;\n\t}\n\n\tret = scnprintf(str, *len, \"%hhx.%hhx.%hhx\", num >> 16, num >> 8, num);\n\t*len -= ret;\n\treturn 0;\n}\n\nint bnx2x_get_ext_phy_fw_version(struct link_params *params, u8 *version,\n\t\t\t\t u16 len)\n{\n\tstruct bnx2x *bp;\n\tu32 spirom_ver = 0;\n\tint status = 0;\n\tu8 *ver_p = version;\n\tu16 remain_len = len;\n\tif (version == NULL || params == NULL)\n\t\treturn -EINVAL;\n\tbp = params->bp;\n\n\t/* Extract first external phy*/\n\tversion[0] = '\\0';\n\tspirom_ver = REG_RD(bp, params->phy[EXT_PHY1].ver_addr);\n\n\tif (params->phy[EXT_PHY1].format_fw_ver) {\n\t\tstatus |= params->phy[EXT_PHY1].format_fw_ver(spirom_ver,\n\t\t\t\t\t\t\t      ver_p,\n\t\t\t\t\t\t\t      &remain_len);\n\t\tver_p += (len - remain_len);\n\t}\n\tif ((params->num_phys == MAX_PHYS) &&\n\t    (params->phy[EXT_PHY2].ver_addr != 0)) {\n\t\tspirom_ver = REG_RD(bp, params->phy[EXT_PHY2].ver_addr);\n\t\tif (params->phy[EXT_PHY2].format_fw_ver) {\n\t\t\t*ver_p = '/';\n\t\t\tver_p++;\n\t\t\tremain_len--;\n\t\t\tstatus |= params->phy[EXT_PHY2].format_fw_ver(\n\t\t\t\tspirom_ver,\n\t\t\t\tver_p,\n\t\t\t\t&remain_len);\n\t\t\tver_p = version + (len - remain_len);\n\t\t}\n\t}\n\t*ver_p = '\\0';\n\treturn status;\n}\n\nstatic void bnx2x_set_xgxs_loopback(struct bnx2x_phy *phy,\n\t\t\t\t    struct link_params *params)\n{\n\tu8 port = params->port;\n\tstruct bnx2x *bp = params->bp;\n\n\tif (phy->req_line_speed != SPEED_1000) {\n\t\tu32 md_devad = 0;\n\n\t\tDP(NETIF_MSG_LINK, \"XGXS 10G loopback enable\\n\");\n\n\t\tif (!CHIP_IS_E3(bp)) {\n\t\t\t/* Change the uni_phy_addr in the nig */\n\t\t\tmd_devad = REG_RD(bp, (NIG_REG_XGXS0_CTRL_MD_DEVAD +\n\t\t\t\t\t       port*0x18));\n\n\t\t\tREG_WR(bp, NIG_REG_XGXS0_CTRL_MD_DEVAD + port*0x18,\n\t\t\t       0x5);\n\t\t}\n\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t 5,\n\t\t\t\t (MDIO_REG_BANK_AER_BLOCK +\n\t\t\t\t  (MDIO_AER_BLOCK_AER_REG & 0xf)),\n\t\t\t\t 0x2800);\n\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t 5,\n\t\t\t\t (MDIO_REG_BANK_CL73_IEEEB0 +\n\t\t\t\t  (MDIO_CL73_IEEEB0_CL73_AN_CONTROL & 0xf)),\n\t\t\t\t 0x6041);\n\t\tmsleep(200);\n\t\t/* Set aer mmd back */\n\t\tbnx2x_set_aer_mmd(params, phy);\n\n\t\tif (!CHIP_IS_E3(bp)) {\n\t\t\t/* And md_devad */\n\t\t\tREG_WR(bp, NIG_REG_XGXS0_CTRL_MD_DEVAD + port*0x18,\n\t\t\t       md_devad);\n\t\t}\n\t} else {\n\t\tu16 mii_ctrl;\n\t\tDP(NETIF_MSG_LINK, \"XGXS 1G loopback enable\\n\");\n\t\tbnx2x_cl45_read(bp, phy, 5,\n\t\t\t\t(MDIO_REG_BANK_COMBO_IEEE0 +\n\t\t\t\t(MDIO_COMBO_IEEE0_MII_CONTROL & 0xf)),\n\t\t\t\t&mii_ctrl);\n\t\tbnx2x_cl45_write(bp, phy, 5,\n\t\t\t\t (MDIO_REG_BANK_COMBO_IEEE0 +\n\t\t\t\t (MDIO_COMBO_IEEE0_MII_CONTROL & 0xf)),\n\t\t\t\t mii_ctrl |\n\t\t\t\t MDIO_COMBO_IEEO_MII_CONTROL_LOOPBACK);\n\t}\n}\n\nint bnx2x_set_led(struct link_params *params,\n\t\t  struct link_vars *vars, u8 mode, u32 speed)\n{\n\tu8 port = params->port;\n\tu16 hw_led_mode = params->hw_led_mode;\n\tint rc = 0;\n\tu8 phy_idx;\n\tu32 tmp;\n\tu32 emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"bnx2x_set_led: port %x, mode %d\\n\", port, mode);\n\tDP(NETIF_MSG_LINK, \"speed 0x%x, hw_led_mode 0x%x\\n\",\n\t\t speed, hw_led_mode);\n\t/* In case */\n\tfor (phy_idx = EXT_PHY1; phy_idx < MAX_PHYS; phy_idx++) {\n\t\tif (params->phy[phy_idx].set_link_led) {\n\t\t\tparams->phy[phy_idx].set_link_led(\n\t\t\t\t&params->phy[phy_idx], params, mode);\n\t\t}\n\t}\n\n\tswitch (mode) {\n\tcase LED_MODE_FRONT_PANEL_OFF:\n\tcase LED_MODE_OFF:\n\t\tREG_WR(bp, NIG_REG_LED_10G_P0 + port*4, 0);\n\t\tREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4,\n\t\t       SHARED_HW_CFG_LED_MAC1);\n\n\t\ttmp = EMAC_RD(bp, EMAC_REG_EMAC_LED);\n\t\tif (params->phy[EXT_PHY1].type ==\n\t\t\tPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE)\n\t\t\ttmp &= ~(EMAC_LED_1000MB_OVERRIDE |\n\t\t\t\tEMAC_LED_100MB_OVERRIDE |\n\t\t\t\tEMAC_LED_10MB_OVERRIDE);\n\t\telse\n\t\t\ttmp |= EMAC_LED_OVERRIDE;\n\n\t\tEMAC_WR(bp, EMAC_REG_EMAC_LED, tmp);\n\t\tbreak;\n\n\tcase LED_MODE_OPER:\n\t\t/* For all other phys, OPER mode is same as ON, so in case\n\t\t * link is down, do nothing\n\t\t */\n\t\tif (!vars->link_up)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase LED_MODE_ON:\n\t\tif (((params->phy[EXT_PHY1].type ==\n\t\t\t  PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727) ||\n\t\t\t (params->phy[EXT_PHY1].type ==\n\t\t\t  PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722)) &&\n\t\t    CHIP_IS_E2(bp) && params->num_phys == 2) {\n\t\t\t/* This is a work-around for E2+8727 Configurations */\n\t\t\tif (mode == LED_MODE_ON ||\n\t\t\t\tspeed == SPEED_10000){\n\t\t\t\tREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4, 0);\n\t\t\t\tREG_WR(bp, NIG_REG_LED_10G_P0 + port*4, 1);\n\n\t\t\t\ttmp = EMAC_RD(bp, EMAC_REG_EMAC_LED);\n\t\t\t\tEMAC_WR(bp, EMAC_REG_EMAC_LED,\n\t\t\t\t\t(tmp | EMAC_LED_OVERRIDE));\n\t\t\t\t/* Return here without enabling traffic\n\t\t\t\t * LED blink and setting rate in ON mode.\n\t\t\t\t * In oper mode, enabling LED blink\n\t\t\t\t * and setting rate is needed.\n\t\t\t\t */\n\t\t\t\tif (mode == LED_MODE_ON)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else if (SINGLE_MEDIA_DIRECT(params)) {\n\t\t\t/* This is a work-around for HW issue found when link\n\t\t\t * is up in CL73\n\t\t\t */\n\t\t\tif ((!CHIP_IS_E3(bp)) ||\n\t\t\t    (CHIP_IS_E3(bp) &&\n\t\t\t     mode == LED_MODE_ON))\n\t\t\t\tREG_WR(bp, NIG_REG_LED_10G_P0 + port*4, 1);\n\n\t\t\tif (CHIP_IS_E1x(bp) ||\n\t\t\t    CHIP_IS_E2(bp) ||\n\t\t\t    (mode == LED_MODE_ON))\n\t\t\t\tREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4, 0);\n\t\t\telse\n\t\t\t\tREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4,\n\t\t\t\t       hw_led_mode);\n\t\t} else if ((params->phy[EXT_PHY1].type ==\n\t\t\t    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE) &&\n\t\t\t   (mode == LED_MODE_ON)) {\n\t\t\tREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4, 0);\n\t\t\ttmp = EMAC_RD(bp, EMAC_REG_EMAC_LED);\n\t\t\tEMAC_WR(bp, EMAC_REG_EMAC_LED, tmp |\n\t\t\t\tEMAC_LED_OVERRIDE | EMAC_LED_1000MB_OVERRIDE);\n\t\t\t/* Break here; otherwise, it'll disable the\n\t\t\t * intended override.\n\t\t\t */\n\t\t\tbreak;\n\t\t} else {\n\t\t\tu32 nig_led_mode = ((params->hw_led_mode <<\n\t\t\t\t\t     SHARED_HW_CFG_LED_MODE_SHIFT) ==\n\t\t\t\t\t    SHARED_HW_CFG_LED_EXTPHY2) ?\n\t\t\t\t(SHARED_HW_CFG_LED_PHY1 >>\n\t\t\t\t SHARED_HW_CFG_LED_MODE_SHIFT) : hw_led_mode;\n\t\t\tREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4,\n\t\t\t       nig_led_mode);\n\t\t}\n\n\t\tREG_WR(bp, NIG_REG_LED_CONTROL_OVERRIDE_TRAFFIC_P0 + port*4, 0);\n\t\t/* Set blinking rate to ~15.9Hz */\n\t\tif (CHIP_IS_E3(bp))\n\t\t\tREG_WR(bp, NIG_REG_LED_CONTROL_BLINK_RATE_P0 + port*4,\n\t\t\t       LED_BLINK_RATE_VAL_E3);\n\t\telse\n\t\t\tREG_WR(bp, NIG_REG_LED_CONTROL_BLINK_RATE_P0 + port*4,\n\t\t\t       LED_BLINK_RATE_VAL_E1X_E2);\n\t\tREG_WR(bp, NIG_REG_LED_CONTROL_BLINK_RATE_ENA_P0 +\n\t\t       port*4, 1);\n\t\ttmp = EMAC_RD(bp, EMAC_REG_EMAC_LED);\n\t\tEMAC_WR(bp, EMAC_REG_EMAC_LED,\n\t\t\t(tmp & (~EMAC_LED_OVERRIDE)));\n\n\t\tif (CHIP_IS_E1(bp) &&\n\t\t    ((speed == SPEED_2500) ||\n\t\t     (speed == SPEED_1000) ||\n\t\t     (speed == SPEED_100) ||\n\t\t     (speed == SPEED_10))) {\n\t\t\t/* For speeds less than 10G LED scheme is different */\n\t\t\tREG_WR(bp, NIG_REG_LED_CONTROL_OVERRIDE_TRAFFIC_P0\n\t\t\t       + port*4, 1);\n\t\t\tREG_WR(bp, NIG_REG_LED_CONTROL_TRAFFIC_P0 +\n\t\t\t       port*4, 0);\n\t\t\tREG_WR(bp, NIG_REG_LED_CONTROL_BLINK_TRAFFIC_P0 +\n\t\t\t       port*4, 1);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trc = -EINVAL;\n\t\tDP(NETIF_MSG_LINK, \"bnx2x_set_led: Invalid led mode %d\\n\",\n\t\t\t mode);\n\t\tbreak;\n\t}\n\treturn rc;\n\n}\n\n/* This function comes to reflect the actual link state read DIRECTLY from the\n * HW\n */\nint bnx2x_test_link(struct link_params *params, struct link_vars *vars,\n\t\t    u8 is_serdes)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 gp_status = 0, phy_index = 0;\n\tu8 ext_phy_link_up = 0, serdes_phy_type;\n\tstruct link_vars temp_vars;\n\tstruct bnx2x_phy *int_phy = &params->phy[INT_PHY];\n\n\tif (CHIP_IS_E3(bp)) {\n\t\tu16 link_up;\n\t\tif (params->req_line_speed[LINK_CONFIG_IDX(INT_PHY)]\n\t\t    > SPEED_10000) {\n\t\t\t/* Check 20G link */\n\t\t\tbnx2x_cl45_read(bp, int_phy, MDIO_WC_DEVAD,\n\t\t\t\t\t1, &link_up);\n\t\t\tbnx2x_cl45_read(bp, int_phy, MDIO_WC_DEVAD,\n\t\t\t\t\t1, &link_up);\n\t\t\tlink_up &= (1<<2);\n\t\t} else {\n\t\t\t/* Check 10G link and below*/\n\t\t\tu8 lane = bnx2x_get_warpcore_lane(int_phy, params);\n\t\t\tbnx2x_cl45_read(bp, int_phy, MDIO_WC_DEVAD,\n\t\t\t\t\tMDIO_WC_REG_GP2_STATUS_GP_2_1,\n\t\t\t\t\t&gp_status);\n\t\t\tgp_status = ((gp_status >> 8) & 0xf) |\n\t\t\t\t((gp_status >> 12) & 0xf);\n\t\t\tlink_up = gp_status & (1 << lane);\n\t\t}\n\t\tif (!link_up)\n\t\t\treturn -ESRCH;\n\t} else {\n\t\tCL22_RD_OVER_CL45(bp, int_phy,\n\t\t\t  MDIO_REG_BANK_GP_STATUS,\n\t\t\t  MDIO_GP_STATUS_TOP_AN_STATUS1,\n\t\t\t  &gp_status);\n\t\t/* Link is up only if both local phy and external phy are up */\n\t\tif (!(gp_status & MDIO_GP_STATUS_TOP_AN_STATUS1_LINK_STATUS))\n\t\t\treturn -ESRCH;\n\t}\n\t/* In XGXS loopback mode, do not check external PHY */\n\tif (params->loopback_mode == LOOPBACK_XGXS)\n\t\treturn 0;\n\n\tswitch (params->num_phys) {\n\tcase 1:\n\t\t/* No external PHY */\n\t\treturn 0;\n\tcase 2:\n\t\text_phy_link_up = params->phy[EXT_PHY1].read_status(\n\t\t\t&params->phy[EXT_PHY1],\n\t\t\tparams, &temp_vars);\n\t\tbreak;\n\tcase 3: /* Dual Media */\n\t\tfor (phy_index = EXT_PHY1; phy_index < params->num_phys;\n\t\t      phy_index++) {\n\t\t\tserdes_phy_type = ((params->phy[phy_index].media_type ==\n\t\t\t\t\t    ETH_PHY_SFPP_10G_FIBER) ||\n\t\t\t\t\t   (params->phy[phy_index].media_type ==\n\t\t\t\t\t    ETH_PHY_SFP_1G_FIBER) ||\n\t\t\t\t\t   (params->phy[phy_index].media_type ==\n\t\t\t\t\t    ETH_PHY_XFP_FIBER) ||\n\t\t\t\t\t   (params->phy[phy_index].media_type ==\n\t\t\t\t\t    ETH_PHY_DA_TWINAX));\n\n\t\t\tif (is_serdes != serdes_phy_type)\n\t\t\t\tcontinue;\n\t\t\tif (params->phy[phy_index].read_status) {\n\t\t\t\text_phy_link_up |=\n\t\t\t\t\tparams->phy[phy_index].read_status(\n\t\t\t\t\t\t&params->phy[phy_index],\n\t\t\t\t\t\tparams, &temp_vars);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tif (ext_phy_link_up)\n\t\treturn 0;\n\treturn -ESRCH;\n}\n\nstatic int bnx2x_link_initialize(struct link_params *params,\n\t\t\t\t struct link_vars *vars)\n{\n\tu8 phy_index, non_ext_phy;\n\tstruct bnx2x *bp = params->bp;\n\t/* In case of external phy existence, the line speed would be the\n\t * line speed linked up by the external phy. In case it is direct\n\t * only, then the line_speed during initialization will be\n\t * equal to the req_line_speed\n\t */\n\tvars->line_speed = params->phy[INT_PHY].req_line_speed;\n\n\t/* Initialize the internal phy in case this is a direct board\n\t * (no external phys), or this board has external phy which requires\n\t * to first.\n\t */\n\tif (!USES_WARPCORE(bp))\n\t\tbnx2x_prepare_xgxs(&params->phy[INT_PHY], params, vars);\n\t/* init ext phy and enable link state int */\n\tnon_ext_phy = (SINGLE_MEDIA_DIRECT(params) ||\n\t\t       (params->loopback_mode == LOOPBACK_XGXS));\n\n\tif (non_ext_phy ||\n\t    (params->phy[EXT_PHY1].flags & FLAGS_INIT_XGXS_FIRST) ||\n\t    (params->loopback_mode == LOOPBACK_EXT_PHY)) {\n\t\tstruct bnx2x_phy *phy = &params->phy[INT_PHY];\n\t\tif (vars->line_speed == SPEED_AUTO_NEG &&\n\t\t    (CHIP_IS_E1x(bp) ||\n\t\t     CHIP_IS_E2(bp)))\n\t\t\tbnx2x_set_parallel_detection(phy, params);\n\t\tif (params->phy[INT_PHY].config_init)\n\t\t\tparams->phy[INT_PHY].config_init(phy, params, vars);\n\t}\n\n\t/* Re-read this value in case it was changed inside config_init due to\n\t * limitations of optic module\n\t */\n\tvars->line_speed = params->phy[INT_PHY].req_line_speed;\n\n\t/* Init external phy*/\n\tif (non_ext_phy) {\n\t\tif (params->phy[INT_PHY].supported &\n\t\t    SUPPORTED_FIBRE)\n\t\t\tvars->link_status |= LINK_STATUS_SERDES_LINK;\n\t} else {\n\t\tfor (phy_index = EXT_PHY1; phy_index < params->num_phys;\n\t\t      phy_index++) {\n\t\t\t/* No need to initialize second phy in case of first\n\t\t\t * phy only selection. In case of second phy, we do\n\t\t\t * need to initialize the first phy, since they are\n\t\t\t * connected.\n\t\t\t */\n\t\t\tif (params->phy[phy_index].supported &\n\t\t\t    SUPPORTED_FIBRE)\n\t\t\t\tvars->link_status |= LINK_STATUS_SERDES_LINK;\n\n\t\t\tif (phy_index == EXT_PHY2 &&\n\t\t\t    (bnx2x_phy_selection(params) ==\n\t\t\t     PORT_HW_CFG_PHY_SELECTION_FIRST_PHY)) {\n\t\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t   \"Not initializing second phy\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparams->phy[phy_index].config_init(\n\t\t\t\t&params->phy[phy_index],\n\t\t\t\tparams, vars);\n\t\t}\n\t}\n\t/* Reset the interrupt indication after phy was initialized */\n\tbnx2x_bits_dis(bp, NIG_REG_STATUS_INTERRUPT_PORT0 +\n\t\t       params->port*4,\n\t\t       (NIG_STATUS_XGXS0_LINK10G |\n\t\t\tNIG_STATUS_XGXS0_LINK_STATUS |\n\t\t\tNIG_STATUS_SERDES0_LINK_STATUS |\n\t\t\tNIG_MASK_MI_INT));\n\treturn 0;\n}\n\nstatic void bnx2x_int_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params)\n{\n\t/* Reset the SerDes/XGXS */\n\tREG_WR(params->bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_CLEAR,\n\t       (0x1ff << (params->port*16)));\n}\n\nstatic void bnx2x_common_ext_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t\tstruct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 gpio_port;\n\t/* HW reset */\n\tif (CHIP_IS_E2(bp))\n\t\tgpio_port = BP_PATH(bp);\n\telse\n\t\tgpio_port = params->port;\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW,\n\t\t       gpio_port);\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW,\n\t\t       gpio_port);\n\tDP(NETIF_MSG_LINK, \"reset external PHY\\n\");\n}\n\nstatic int bnx2x_update_link_down(struct link_params *params,\n\t\t\t\t  struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\n\tDP(NETIF_MSG_LINK, \"Port %x: Link is down\\n\", port);\n\tbnx2x_set_led(params, vars, LED_MODE_OFF, 0);\n\tvars->phy_flags &= ~PHY_PHYSICAL_LINK_FLAG;\n\t/* Indicate no mac active */\n\tvars->mac_type = MAC_TYPE_NONE;\n\n\t/* Update shared memory */\n\tvars->link_status &= ~LINK_UPDATE_MASK;\n\tvars->line_speed = 0;\n\tbnx2x_update_mng(params, vars->link_status);\n\n\t/* Activate nig drain */\n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + port*4, 1);\n\n\t/* Disable emac */\n\tif (!CHIP_IS_E3(bp))\n\t\tREG_WR(bp, NIG_REG_NIG_EMAC0_EN + port*4, 0);\n\n\tusleep_range(10000, 20000);\n\t/* Reset BigMac/Xmac */\n\tif (CHIP_IS_E1x(bp) ||\n\t    CHIP_IS_E2(bp))\n\t\tbnx2x_set_bmac_rx(bp, params->chip_id, params->port, 0);\n\n\tif (CHIP_IS_E3(bp)) {\n\t\t/* Prevent LPI Generation by chip */\n\t\tREG_WR(bp, MISC_REG_CPMU_LP_FW_ENABLE_P0 + (params->port << 2),\n\t\t       0);\n\t\tREG_WR(bp, MISC_REG_CPMU_LP_MASK_ENT_P0 + (params->port << 2),\n\t\t       0);\n\t\tvars->eee_status &= ~(SHMEM_EEE_LP_ADV_STATUS_MASK |\n\t\t\t\t      SHMEM_EEE_ACTIVE_BIT);\n\n\t\tbnx2x_update_mng_eee(params, vars->eee_status);\n\t\tbnx2x_set_xmac_rxtx(params, 0);\n\t\tbnx2x_set_umac_rxtx(params, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_update_link_up(struct link_params *params,\n\t\t\t\tstruct link_vars *vars,\n\t\t\t\tu8 link_10g)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 phy_idx, port = params->port;\n\tint rc = 0;\n\n\tvars->link_status |= (LINK_STATUS_LINK_UP |\n\t\t\t      LINK_STATUS_PHYSICAL_LINK_FLAG);\n\tvars->phy_flags |= PHY_PHYSICAL_LINK_FLAG;\n\n\tif (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX)\n\t\tvars->link_status |=\n\t\t\tLINK_STATUS_TX_FLOW_CONTROL_ENABLED;\n\n\tif (vars->flow_ctrl & BNX2X_FLOW_CTRL_RX)\n\t\tvars->link_status |=\n\t\t\tLINK_STATUS_RX_FLOW_CONTROL_ENABLED;\n\tif (USES_WARPCORE(bp)) {\n\t\tif (link_10g) {\n\t\t\tif (bnx2x_xmac_enable(params, vars, 0) ==\n\t\t\t    -ESRCH) {\n\t\t\t\tDP(NETIF_MSG_LINK, \"Found errors on XMAC\\n\");\n\t\t\t\tvars->link_up = 0;\n\t\t\t\tvars->phy_flags |= PHY_HALF_OPEN_CONN_FLAG;\n\t\t\t\tvars->link_status &= ~LINK_STATUS_LINK_UP;\n\t\t\t}\n\t\t} else\n\t\t\tbnx2x_umac_enable(params, vars, 0);\n\t\tbnx2x_set_led(params, vars,\n\t\t\t      LED_MODE_OPER, vars->line_speed);\n\n\t\tif ((vars->eee_status & SHMEM_EEE_ACTIVE_BIT) &&\n\t\t    (vars->eee_status & SHMEM_EEE_LPI_REQUESTED_BIT)) {\n\t\t\tDP(NETIF_MSG_LINK, \"Enabling LPI assertion\\n\");\n\t\t\tREG_WR(bp, MISC_REG_CPMU_LP_FW_ENABLE_P0 +\n\t\t\t       (params->port << 2), 1);\n\t\t\tREG_WR(bp, MISC_REG_CPMU_LP_DR_ENABLE, 1);\n\t\t\tREG_WR(bp, MISC_REG_CPMU_LP_MASK_ENT_P0 +\n\t\t\t       (params->port << 2), 0xfc20);\n\t\t}\n\t}\n\tif ((CHIP_IS_E1x(bp) ||\n\t     CHIP_IS_E2(bp))) {\n\t\tif (link_10g) {\n\t\t\tif (bnx2x_bmac_enable(params, vars, 0, 1) ==\n\t\t\t    -ESRCH) {\n\t\t\t\tDP(NETIF_MSG_LINK, \"Found errors on BMAC\\n\");\n\t\t\t\tvars->link_up = 0;\n\t\t\t\tvars->phy_flags |= PHY_HALF_OPEN_CONN_FLAG;\n\t\t\t\tvars->link_status &= ~LINK_STATUS_LINK_UP;\n\t\t\t}\n\n\t\t\tbnx2x_set_led(params, vars,\n\t\t\t\t      LED_MODE_OPER, SPEED_10000);\n\t\t} else {\n\t\t\trc = bnx2x_emac_program(params, vars);\n\t\t\tbnx2x_emac_enable(params, vars, 0);\n\n\t\t\t/* AN complete? */\n\t\t\tif ((vars->link_status &\n\t\t\t     LINK_STATUS_AUTO_NEGOTIATE_COMPLETE)\n\t\t\t    && (!(vars->phy_flags & PHY_SGMII_FLAG)) &&\n\t\t\t    SINGLE_MEDIA_DIRECT(params))\n\t\t\t\tbnx2x_set_gmii_tx_driver(params);\n\t\t}\n\t}\n\n\t/* PBF - link up */\n\tif (CHIP_IS_E1x(bp))\n\t\trc |= bnx2x_pbf_update(params, vars->flow_ctrl,\n\t\t\t\t       vars->line_speed);\n\n\t/* Disable drain */\n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + port*4, 0);\n\n\t/* Update shared memory */\n\tbnx2x_update_mng(params, vars->link_status);\n\tbnx2x_update_mng_eee(params, vars->eee_status);\n\t/* Check remote fault */\n\tfor (phy_idx = INT_PHY; phy_idx < MAX_PHYS; phy_idx++) {\n\t\tif (params->phy[phy_idx].flags & FLAGS_TX_ERROR_CHECK) {\n\t\t\tbnx2x_check_half_open_conn(params, vars, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmsleep(20);\n\treturn rc;\n}\n\nstatic void bnx2x_chng_link_count(struct link_params *params, bool clear)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 addr, val;\n\n\t/* Verify the link_change_count is supported by the MFW */\n\tif (!(SHMEM2_HAS(bp, link_change_count)))\n\t\treturn;\n\n\taddr = params->shmem2_base +\n\t\toffsetof(struct shmem2_region, link_change_count[params->port]);\n\tif (clear)\n\t\tval = 0;\n\telse\n\t\tval = REG_RD(bp, addr) + 1;\n\tREG_WR(bp, addr, val);\n}\n\n/* The bnx2x_link_update function should be called upon link\n * interrupt.\n * Link is considered up as follows:\n * - DIRECT_SINGLE_MEDIA - Only XGXS link (internal link) needs\n *   to be up\n * - SINGLE_MEDIA - The link between the 577xx and the external\n *   phy (XGXS) need to up as well as the external link of the\n *   phy (PHY_EXT1)\n * - DUAL_MEDIA - The link between the 577xx and the first\n *   external phy needs to be up, and at least one of the 2\n *   external phy link must be up.\n */\nint bnx2x_link_update(struct link_params *params, struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tstruct link_vars phy_vars[MAX_PHYS];\n\tu8 port = params->port;\n\tu8 link_10g_plus, phy_index;\n\tu32 prev_link_status = vars->link_status;\n\tu8 ext_phy_link_up = 0, cur_link_up;\n\tint rc = 0;\n\tu8 is_mi_int = 0;\n\tu16 ext_phy_line_speed = 0, prev_line_speed = vars->line_speed;\n\tu8 active_external_phy = INT_PHY;\n\tvars->phy_flags &= ~PHY_HALF_OPEN_CONN_FLAG;\n\tvars->link_status &= ~LINK_UPDATE_MASK;\n\tfor (phy_index = INT_PHY; phy_index < params->num_phys;\n\t      phy_index++) {\n\t\tphy_vars[phy_index].flow_ctrl = 0;\n\t\tphy_vars[phy_index].link_status = 0;\n\t\tphy_vars[phy_index].line_speed = 0;\n\t\tphy_vars[phy_index].duplex = DUPLEX_FULL;\n\t\tphy_vars[phy_index].phy_link_up = 0;\n\t\tphy_vars[phy_index].link_up = 0;\n\t\tphy_vars[phy_index].fault_detected = 0;\n\t\t/* different consideration, since vars holds inner state */\n\t\tphy_vars[phy_index].eee_status = vars->eee_status;\n\t}\n\n\tif (USES_WARPCORE(bp))\n\t\tbnx2x_set_aer_mmd(params, &params->phy[INT_PHY]);\n\n\tDP(NETIF_MSG_LINK, \"port %x, XGXS?%x, int_status 0x%x\\n\",\n\t\t port, (vars->phy_flags & PHY_XGXS_FLAG),\n\t\t REG_RD(bp, NIG_REG_STATUS_INTERRUPT_PORT0 + port*4));\n\n\tis_mi_int = (u8)(REG_RD(bp, NIG_REG_EMAC0_STATUS_MISC_MI_INT +\n\t\t\t\tport*0x18) > 0);\n\tDP(NETIF_MSG_LINK, \"int_mask 0x%x MI_INT %x, SERDES_LINK %x\\n\",\n\t\t REG_RD(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4),\n\t\t is_mi_int,\n\t\t REG_RD(bp, NIG_REG_SERDES0_STATUS_LINK_STATUS + port*0x3c));\n\n\tDP(NETIF_MSG_LINK, \" 10G %x, XGXS_LINK %x\\n\",\n\t  REG_RD(bp, NIG_REG_XGXS0_STATUS_LINK10G + port*0x68),\n\t  REG_RD(bp, NIG_REG_XGXS0_STATUS_LINK_STATUS + port*0x68));\n\n\t/* Disable emac */\n\tif (!CHIP_IS_E3(bp))\n\t\tREG_WR(bp, NIG_REG_NIG_EMAC0_EN + port*4, 0);\n\n\t/* Step 1:\n\t * Check external link change only for external phys, and apply\n\t * priority selection between them in case the link on both phys\n\t * is up. Note that instead of the common vars, a temporary\n\t * vars argument is used since each phy may have different link/\n\t * speed/duplex result\n\t */\n\tfor (phy_index = EXT_PHY1; phy_index < params->num_phys;\n\t      phy_index++) {\n\t\tstruct bnx2x_phy *phy = &params->phy[phy_index];\n\t\tif (!phy->read_status)\n\t\t\tcontinue;\n\t\t/* Read link status and params of this ext phy */\n\t\tcur_link_up = phy->read_status(phy, params,\n\t\t\t\t\t       &phy_vars[phy_index]);\n\t\tif (cur_link_up) {\n\t\t\tDP(NETIF_MSG_LINK, \"phy in index %d link is up\\n\",\n\t\t\t\t   phy_index);\n\t\t} else {\n\t\t\tDP(NETIF_MSG_LINK, \"phy in index %d link is down\\n\",\n\t\t\t\t   phy_index);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ext_phy_link_up) {\n\t\t\text_phy_link_up = 1;\n\t\t\tactive_external_phy = phy_index;\n\t\t} else {\n\t\t\tswitch (bnx2x_phy_selection(params)) {\n\t\t\tcase PORT_HW_CFG_PHY_SELECTION_HARDWARE_DEFAULT:\n\t\t\tcase PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY:\n\t\t\t/* In this option, the first PHY makes sure to pass the\n\t\t\t * traffic through itself only.\n\t\t\t * It's not clear how to reset the link on the second\n\t\t\t * phy.\n\t\t\t */\n\t\t\t\tactive_external_phy = EXT_PHY1;\n\t\t\t\tbreak;\n\t\t\tcase PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY:\n\t\t\t/* In this option, the first PHY makes sure to pass the\n\t\t\t * traffic through the second PHY.\n\t\t\t */\n\t\t\t\tactive_external_phy = EXT_PHY2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t/* Link indication on both PHYs with the following cases\n\t\t\t * is invalid:\n\t\t\t * - FIRST_PHY means that second phy wasn't initialized,\n\t\t\t * hence its link is expected to be down\n\t\t\t * - SECOND_PHY means that first phy should not be able\n\t\t\t * to link up by itself (using configuration)\n\t\t\t * - DEFAULT should be overridden during initialization\n\t\t\t */\n\t\t\t\tDP(NETIF_MSG_LINK, \"Invalid link indication\"\n\t\t\t\t\t   \"mpc=0x%x. DISABLING LINK !!!\\n\",\n\t\t\t\t\t   params->multi_phy_config);\n\t\t\t\text_phy_link_up = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprev_line_speed = vars->line_speed;\n\t/* Step 2:\n\t * Read the status of the internal phy. In case of\n\t * DIRECT_SINGLE_MEDIA board, this link is the external link,\n\t * otherwise this is the link between the 577xx and the first\n\t * external phy\n\t */\n\tif (params->phy[INT_PHY].read_status)\n\t\tparams->phy[INT_PHY].read_status(\n\t\t\t&params->phy[INT_PHY],\n\t\t\tparams, vars);\n\t/* The INT_PHY flow control reside in the vars. This include the\n\t * case where the speed or flow control are not set to AUTO.\n\t * Otherwise, the active external phy flow control result is set\n\t * to the vars. The ext_phy_line_speed is needed to check if the\n\t * speed is different between the internal phy and external phy.\n\t * This case may be result of intermediate link speed change.\n\t */\n\tif (active_external_phy > INT_PHY) {\n\t\tvars->flow_ctrl = phy_vars[active_external_phy].flow_ctrl;\n\t\t/* Link speed is taken from the XGXS. AN and FC result from\n\t\t * the external phy.\n\t\t */\n\t\tvars->link_status |= phy_vars[active_external_phy].link_status;\n\n\t\t/* if active_external_phy is first PHY and link is up - disable\n\t\t * disable TX on second external PHY\n\t\t */\n\t\tif (active_external_phy == EXT_PHY1) {\n\t\t\tif (params->phy[EXT_PHY2].phy_specific_func) {\n\t\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t   \"Disabling TX on EXT_PHY2\\n\");\n\t\t\t\tparams->phy[EXT_PHY2].phy_specific_func(\n\t\t\t\t\t&params->phy[EXT_PHY2],\n\t\t\t\t\tparams, DISABLE_TX);\n\t\t\t}\n\t\t}\n\n\t\text_phy_line_speed = phy_vars[active_external_phy].line_speed;\n\t\tvars->duplex = phy_vars[active_external_phy].duplex;\n\t\tif (params->phy[active_external_phy].supported &\n\t\t    SUPPORTED_FIBRE)\n\t\t\tvars->link_status |= LINK_STATUS_SERDES_LINK;\n\t\telse\n\t\t\tvars->link_status &= ~LINK_STATUS_SERDES_LINK;\n\n\t\tvars->eee_status = phy_vars[active_external_phy].eee_status;\n\n\t\tDP(NETIF_MSG_LINK, \"Active external phy selected: %x\\n\",\n\t\t\t   active_external_phy);\n\t}\n\n\tfor (phy_index = EXT_PHY1; phy_index < params->num_phys;\n\t      phy_index++) {\n\t\tif (params->phy[phy_index].flags &\n\t\t    FLAGS_REARM_LATCH_SIGNAL) {\n\t\t\tbnx2x_rearm_latch_signal(bp, port,\n\t\t\t\t\t\t phy_index ==\n\t\t\t\t\t\t active_external_phy);\n\t\t\tbreak;\n\t\t}\n\t}\n\tDP(NETIF_MSG_LINK, \"vars->flow_ctrl = 0x%x, vars->link_status = 0x%x,\"\n\t\t   \" ext_phy_line_speed = %d\\n\", vars->flow_ctrl,\n\t\t   vars->link_status, ext_phy_line_speed);\n\t/* Upon link speed change set the NIG into drain mode. Comes to\n\t * deals with possible FIFO glitch due to clk change when speed\n\t * is decreased without link down indicator\n\t */\n\n\tif (vars->phy_link_up) {\n\t\tif (!(SINGLE_MEDIA_DIRECT(params)) && ext_phy_link_up &&\n\t\t    (ext_phy_line_speed != vars->line_speed)) {\n\t\t\tDP(NETIF_MSG_LINK, \"Internal link speed %d is\"\n\t\t\t\t   \" different than the external\"\n\t\t\t\t   \" link speed %d\\n\", vars->line_speed,\n\t\t\t\t   ext_phy_line_speed);\n\t\t\tvars->phy_link_up = 0;\n\t\t} else if (prev_line_speed != vars->line_speed) {\n\t\t\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4,\n\t\t\t       0);\n\t\t\tusleep_range(1000, 2000);\n\t\t}\n\t}\n\n\t/* Anything 10 and over uses the bmac */\n\tlink_10g_plus = (vars->line_speed >= SPEED_10000);\n\n\tbnx2x_link_int_ack(params, vars, link_10g_plus);\n\n\t/* In case external phy link is up, and internal link is down\n\t * (not initialized yet probably after link initialization, it\n\t * needs to be initialized.\n\t * Note that after link down-up as result of cable plug, the xgxs\n\t * link would probably become up again without the need\n\t * initialize it\n\t */\n\tif (!(SINGLE_MEDIA_DIRECT(params))) {\n\t\tDP(NETIF_MSG_LINK, \"ext_phy_link_up = %d, int_link_up = %d,\"\n\t\t\t   \" init_preceding = %d\\n\", ext_phy_link_up,\n\t\t\t   vars->phy_link_up,\n\t\t\t   params->phy[EXT_PHY1].flags &\n\t\t\t   FLAGS_INIT_XGXS_FIRST);\n\t\tif (!(params->phy[EXT_PHY1].flags &\n\t\t      FLAGS_INIT_XGXS_FIRST)\n\t\t    && ext_phy_link_up && !vars->phy_link_up) {\n\t\t\tvars->line_speed = ext_phy_line_speed;\n\t\t\tif (vars->line_speed < SPEED_1000)\n\t\t\t\tvars->phy_flags |= PHY_SGMII_FLAG;\n\t\t\telse\n\t\t\t\tvars->phy_flags &= ~PHY_SGMII_FLAG;\n\n\t\t\tif (params->phy[INT_PHY].config_init)\n\t\t\t\tparams->phy[INT_PHY].config_init(\n\t\t\t\t\t&params->phy[INT_PHY], params,\n\t\t\t\t\t\tvars);\n\t\t}\n\t}\n\t/* Link is up only if both local phy and external phy (in case of\n\t * non-direct board) are up and no fault detected on active PHY.\n\t */\n\tvars->link_up = (vars->phy_link_up &&\n\t\t\t (ext_phy_link_up ||\n\t\t\t  SINGLE_MEDIA_DIRECT(params)) &&\n\t\t\t (phy_vars[active_external_phy].fault_detected == 0));\n\n\t/* Update the PFC configuration in case it was changed */\n\tif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED)\n\t\tvars->link_status |= LINK_STATUS_PFC_ENABLED;\n\telse\n\t\tvars->link_status &= ~LINK_STATUS_PFC_ENABLED;\n\n\tif (vars->link_up)\n\t\trc = bnx2x_update_link_up(params, vars, link_10g_plus);\n\telse\n\t\trc = bnx2x_update_link_down(params, vars);\n\n\tif ((prev_link_status ^ vars->link_status) & LINK_STATUS_LINK_UP)\n\t\tbnx2x_chng_link_count(params, false);\n\n\t/* Update MCP link status was changed */\n\tif (params->feature_config_flags & FEATURE_CONFIG_BC_SUPPORTS_AFEX)\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_LINK_STATUS_CHANGED, 0);\n\n\treturn rc;\n}\n\n/*****************************************************************************/\n/*\t\t\t    External Phy section\t\t\t     */\n/*****************************************************************************/\nvoid bnx2x_ext_phy_hw_reset(struct bnx2x *bp, u8 port)\n{\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW, port);\n\tusleep_range(1000, 2000);\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH, port);\n}\n\nstatic void bnx2x_save_spirom_version(struct bnx2x *bp, u8 port,\n\t\t\t\t      u32 spirom_ver, u32 ver_addr)\n{\n\tDP(NETIF_MSG_LINK, \"FW version 0x%x:0x%x for port %d\\n\",\n\t\t (u16)(spirom_ver>>16), (u16)spirom_ver, port);\n\n\tif (ver_addr)\n\t\tREG_WR(bp, ver_addr, spirom_ver);\n}\n\nstatic void bnx2x_save_bcm_spirom_ver(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_phy *phy,\n\t\t\t\t      u8 port)\n{\n\tu16 fw_ver1, fw_ver2;\n\n\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_ROM_VER1, &fw_ver1);\n\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_ROM_VER2, &fw_ver2);\n\tbnx2x_save_spirom_version(bp, port, (u32)(fw_ver1<<16 | fw_ver2),\n\t\t\t\t  phy->ver_addr);\n}\n\nstatic void bnx2x_ext_phy_10G_an_resolve(struct bnx2x *bp,\n\t\t\t\t       struct bnx2x_phy *phy,\n\t\t\t\t       struct link_vars *vars)\n{\n\tu16 val;\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD,\n\t\t\tMDIO_AN_REG_STATUS, &val);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD,\n\t\t\tMDIO_AN_REG_STATUS, &val);\n\tif (val & (1<<5))\n\t\tvars->link_status |= LINK_STATUS_AUTO_NEGOTIATE_COMPLETE;\n\tif ((val & (1<<0)) == 0)\n\t\tvars->link_status |= LINK_STATUS_PARALLEL_DETECTION_USED;\n}\n\n/******************************************************************/\n/*\t\tcommon BCM8073/BCM8727 PHY SECTION\t\t  */\n/******************************************************************/\nstatic void bnx2x_8073_resolve_fc(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params,\n\t\t\t\t  struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tif (phy->req_line_speed == SPEED_10 ||\n\t    phy->req_line_speed == SPEED_100) {\n\t\tvars->flow_ctrl = phy->req_flow_ctrl;\n\t\treturn;\n\t}\n\n\tif (bnx2x_ext_phy_resolve_fc(phy, params, vars) &&\n\t    (vars->flow_ctrl == BNX2X_FLOW_CTRL_NONE)) {\n\t\tu16 pause_result;\n\t\tu16 ld_pause;\t\t/* local */\n\t\tu16 lp_pause;\t\t/* link partner */\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_CL37_FC_LD, &ld_pause);\n\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_CL37_FC_LP, &lp_pause);\n\t\tpause_result = (ld_pause &\n\t\t\t\tMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) >> 5;\n\t\tpause_result |= (lp_pause &\n\t\t\t\t MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) >> 7;\n\n\t\tbnx2x_pause_resolve(phy, params, vars, pause_result);\n\t\tDP(NETIF_MSG_LINK, \"Ext PHY CL37 pause result 0x%x\\n\",\n\t\t\t   pause_result);\n\t}\n}\nstatic int bnx2x_8073_8727_external_rom_boot(struct bnx2x *bp,\n\t\t\t\t\t     struct bnx2x_phy *phy,\n\t\t\t\t\t     u8 port)\n{\n\tu32 count = 0;\n\tu16 fw_ver1, fw_msgout;\n\tint rc = 0;\n\n\t/* Boot port from external ROM  */\n\t/* EDC grst */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL,\n\t\t\t 0x0001);\n\n\t/* Ucode reboot and rst */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL,\n\t\t\t 0x008c);\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_MISC_CTRL1, 0x0001);\n\n\t/* Reset internal microprocessor */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL,\n\t\t\t MDIO_PMA_REG_GEN_CTRL_ROM_MICRO_RESET);\n\n\t/* Release srst bit */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL,\n\t\t\t MDIO_PMA_REG_GEN_CTRL_ROM_RESET_INTERNAL_MP);\n\n\t/* Delay 100ms per the PHY specifications */\n\tmsleep(100);\n\n\t/* 8073 sometimes taking longer to download */\n\tdo {\n\t\tcount++;\n\t\tif (count > 300) {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t \"bnx2x_8073_8727_external_rom_boot port %x:\"\n\t\t\t\t \"Download failed. fw version = 0x%x\\n\",\n\t\t\t\t port, fw_ver1);\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_ROM_VER1, &fw_ver1);\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_M8051_MSGOUT_REG, &fw_msgout);\n\n\t\tusleep_range(1000, 2000);\n\t} while (fw_ver1 == 0 || fw_ver1 == 0x4321 ||\n\t\t\t((fw_msgout & 0xff) != 0x03 && (phy->type ==\n\t\t\tPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073)));\n\n\t/* Clear ser_boot_ctl bit */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_MISC_CTRL1, 0x0000);\n\tbnx2x_save_bcm_spirom_ver(bp, phy, port);\n\n\tDP(NETIF_MSG_LINK,\n\t\t \"bnx2x_8073_8727_external_rom_boot port %x:\"\n\t\t \"Download complete. fw version = 0x%x\\n\",\n\t\t port, fw_ver1);\n\n\treturn rc;\n}\n\n/******************************************************************/\n/*\t\t\tBCM8073 PHY SECTION\t\t\t  */\n/******************************************************************/\nstatic int bnx2x_8073_is_snr_needed(struct bnx2x *bp, struct bnx2x_phy *phy)\n{\n\t/* This is only required for 8073A1, version 102 only */\n\tu16 val;\n\n\t/* Read 8073 HW revision*/\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_8073_CHIP_REV, &val);\n\n\tif (val != 1) {\n\t\t/* No need to workaround in 8073 A1 */\n\t\treturn 0;\n\t}\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_ROM_VER2, &val);\n\n\t/* SNR should be applied only for version 0x102 */\n\tif (val != 0x102)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int bnx2x_8073_xaui_wa(struct bnx2x *bp, struct bnx2x_phy *phy)\n{\n\tu16 val, cnt, cnt1 ;\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_8073_CHIP_REV, &val);\n\n\tif (val > 0) {\n\t\t/* No need to workaround in 8073 A1 */\n\t\treturn 0;\n\t}\n\t/* XAUI workaround in 8073 A0: */\n\n\t/* After loading the boot ROM and restarting Autoneg, poll\n\t * Dev1, Reg $C820:\n\t */\n\n\tfor (cnt = 0; cnt < 1000; cnt++) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_8073_SPEED_LINK_STATUS,\n\t\t\t\t&val);\n\t\t  /* If bit [14] = 0 or bit [13] = 0, continue on with\n\t\t   * system initialization (XAUI work-around not required, as\n\t\t   * these bits indicate 2.5G or 1G link up).\n\t\t   */\n\t\tif (!(val & (1<<14)) || !(val & (1<<13))) {\n\t\t\tDP(NETIF_MSG_LINK, \"XAUI work-around not required\\n\");\n\t\t\treturn 0;\n\t\t} else if (!(val & (1<<15))) {\n\t\t\tDP(NETIF_MSG_LINK, \"bit 15 went off\\n\");\n\t\t\t/* If bit 15 is 0, then poll Dev1, Reg $C841 until it's\n\t\t\t * MSB (bit15) goes to 1 (indicating that the XAUI\n\t\t\t * workaround has completed), then continue on with\n\t\t\t * system initialization.\n\t\t\t */\n\t\t\tfor (cnt1 = 0; cnt1 < 1000; cnt1++) {\n\t\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8073_XAUI_WA, &val);\n\t\t\t\tif (val & (1<<15)) {\n\t\t\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t\t  \"XAUI workaround has completed\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tusleep_range(3000, 6000);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(3000, 6000);\n\t}\n\tDP(NETIF_MSG_LINK, \"Warning: XAUI work-around timeout !!!\\n\");\n\treturn -EINVAL;\n}\n\nstatic void bnx2x_807x_force_10G(struct bnx2x *bp, struct bnx2x_phy *phy)\n{\n\t/* Force KR or KX */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x2040);\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_10G_CTRL2, 0x000b);\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_BCM_CTRL, 0x0000);\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0x0000);\n}\n\nstatic void bnx2x_8073_set_pause_cl37(struct link_params *params,\n\t\t\t\t      struct bnx2x_phy *phy,\n\t\t\t\t      struct link_vars *vars)\n{\n\tu16 cl37_val;\n\tstruct bnx2x *bp = params->bp;\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LD, &cl37_val);\n\n\tcl37_val &= ~MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH;\n\t/* Please refer to Table 28B-3 of 802.3ab-1999 spec. */\n\tbnx2x_calc_ieee_aneg_adv(phy, params, &vars->ieee_fc);\n\tif ((vars->ieee_fc &\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_SYMMETRIC) ==\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_SYMMETRIC) {\n\t\tcl37_val |=  MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_SYMMETRIC;\n\t}\n\tif ((vars->ieee_fc &\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) ==\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) {\n\t\tcl37_val |=  MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC;\n\t}\n\tif ((vars->ieee_fc &\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) ==\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) {\n\t\tcl37_val |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH;\n\t}\n\tDP(NETIF_MSG_LINK,\n\t\t \"Ext phy AN advertize cl37 0x%x\\n\", cl37_val);\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LD, cl37_val);\n\tmsleep(500);\n}\n\nstatic void bnx2x_8073_specific_func(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params,\n\t\t\t\t     u32 action)\n{\n\tstruct bnx2x *bp = params->bp;\n\tswitch (action) {\n\tcase PHY_INIT:\n\t\t/* Enable LASI */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL, (1<<2));\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL,  0x0004);\n\t\tbreak;\n\t}\n}\n\nstatic void bnx2x_8073_config_init(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val = 0, tmp1;\n\tu8 gpio_port;\n\tDP(NETIF_MSG_LINK, \"Init 8073\\n\");\n\n\tif (CHIP_IS_E2(bp))\n\t\tgpio_port = BP_PATH(bp);\n\telse\n\t\tgpio_port = params->port;\n\t/* Restore normal power mode*/\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH, gpio_port);\n\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH, gpio_port);\n\n\tbnx2x_8073_specific_func(phy, params, PHY_INIT);\n\tbnx2x_8073_set_pause_cl37(params, phy, vars);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_M8051_MSGOUT_REG, &tmp1);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXSTAT, &tmp1);\n\n\tDP(NETIF_MSG_LINK, \"Before rom RX_ALARM(port1): 0x%x\\n\", tmp1);\n\n\t/* Swap polarity if required - Must be done only in non-1G mode */\n\tif (params->lane_config & PORT_HW_CFG_SWAP_PHY_POLARITY_ENABLED) {\n\t\t/* Configure the 8073 to swap _P and _N of the KR lines */\n\t\tDP(NETIF_MSG_LINK, \"Swapping polarity for the 8073\\n\");\n\t\t/* 10G Rx/Tx and 1G Tx signal polarity swap */\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_8073_OPT_DIGITAL_CTRL, &val);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_8073_OPT_DIGITAL_CTRL,\n\t\t\t\t (val | (3<<9)));\n\t}\n\n\n\t/* Enable CL37 BAM */\n\tif (REG_RD(bp, params->shmem_base +\n\t\t\t offsetof(struct shmem_region, dev_info.\n\t\t\t\t  port_hw_config[params->port].default_cfg)) &\n\t    PORT_HW_CFG_ENABLE_BAM_ON_KR_ENABLED) {\n\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_8073_BAM, &val);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD,\n\t\t\t\t MDIO_AN_REG_8073_BAM, val | 1);\n\t\tDP(NETIF_MSG_LINK, \"Enable CL37 BAM on KR\\n\");\n\t}\n\tif (params->loopback_mode == LOOPBACK_EXT) {\n\t\tbnx2x_807x_force_10G(bp, phy);\n\t\tDP(NETIF_MSG_LINK, \"Forced speed 10G on 807X\\n\");\n\t\treturn;\n\t} else {\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_BCM_CTRL, 0x0002);\n\t}\n\tif (phy->req_line_speed != SPEED_AUTO_NEG) {\n\t\tif (phy->req_line_speed == SPEED_10000) {\n\t\t\tval = (1<<7);\n\t\t} else if (phy->req_line_speed ==  SPEED_2500) {\n\t\t\tval = (1<<5);\n\t\t\t/* Note that 2.5G works only when used with 1G\n\t\t\t * advertisement\n\t\t\t */\n\t\t} else\n\t\t\tval = (1<<5);\n\t} else {\n\t\tval = 0;\n\t\tif (phy->speed_cap_mask &\n\t\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_10G)\n\t\t\tval |= (1<<7);\n\n\t\t/* Note that 2.5G works only when used with 1G advertisement */\n\t\tif (phy->speed_cap_mask &\n\t\t\t(PORT_HW_CFG_SPEED_CAPABILITY_D0_1G |\n\t\t\t PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G))\n\t\t\tval |= (1<<5);\n\t\tDP(NETIF_MSG_LINK, \"807x autoneg val = 0x%x\\n\", val);\n\t}\n\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_ADV, val);\n\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_8073_2_5G, &tmp1);\n\n\tif (((phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G) &&\n\t     (phy->req_line_speed == SPEED_AUTO_NEG)) ||\n\t    (phy->req_line_speed == SPEED_2500)) {\n\t\tu16 phy_ver;\n\t\t/* Allow 2.5G for A1 and above */\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_8073_CHIP_REV,\n\t\t\t\t&phy_ver);\n\t\tDP(NETIF_MSG_LINK, \"Add 2.5G\\n\");\n\t\tif (phy_ver > 0)\n\t\t\ttmp1 |= 1;\n\t\telse\n\t\t\ttmp1 &= 0xfffe;\n\t} else {\n\t\tDP(NETIF_MSG_LINK, \"Disable 2.5G\\n\");\n\t\ttmp1 &= 0xfffe;\n\t}\n\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_8073_2_5G, tmp1);\n\t/* Add support for CL37 (passive mode) II */\n\n\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LD, &tmp1);\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LD,\n\t\t\t (tmp1 | ((phy->req_duplex == DUPLEX_FULL) ?\n\t\t\t\t  0x20 : 0x40)));\n\n\t/* Add support for CL37 (passive mode) III */\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_CL37_AN, 0x1000);\n\n\t/* The SNR will improve about 2db by changing BW and FEE main\n\t * tap. Rest commands are executed after link is up\n\t * Change FFE main cursor to 5 in EDC register\n\t */\n\tif (bnx2x_8073_is_snr_needed(bp, phy))\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_EDC_FFE_MAIN,\n\t\t\t\t 0xFB0C);\n\n\t/* Enable FEC (Forware Error Correction) Request in the AN */\n\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_ADV2, &tmp1);\n\ttmp1 |= (1<<15);\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_ADV2, tmp1);\n\n\tbnx2x_ext_phy_set_pause(params, phy, vars);\n\n\t/* Restart autoneg */\n\tmsleep(500);\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0x1200);\n\tDP(NETIF_MSG_LINK, \"807x Autoneg Restart: Advertise 1G=%x, 10G=%x\\n\",\n\t\t   ((val & (1<<5)) > 0), ((val & (1<<7)) > 0));\n}\n\nstatic u8 bnx2x_8073_read_status(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params,\n\t\t\t\t struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 link_up = 0;\n\tu16 val1, val2;\n\tu16 link_status = 0;\n\tu16 an1000_status = 0;\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val1);\n\n\tDP(NETIF_MSG_LINK, \"8703 LASI status 0x%x\\n\", val1);\n\n\t/* Clear the interrupt LASI status register */\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PCS_DEVAD, MDIO_PCS_REG_STATUS, &val2);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PCS_DEVAD, MDIO_PCS_REG_STATUS, &val1);\n\tDP(NETIF_MSG_LINK, \"807x PCS status 0x%x->0x%x\\n\", val2, val1);\n\t/* Clear MSG-OUT */\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_M8051_MSGOUT_REG, &val1);\n\n\t/* Check the LASI */\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXSTAT, &val2);\n\n\tDP(NETIF_MSG_LINK, \"KR 0x9003 0x%x\\n\", val2);\n\n\t/* Check the link status */\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PCS_DEVAD, MDIO_PCS_REG_STATUS, &val2);\n\tDP(NETIF_MSG_LINK, \"KR PCS status 0x%x\\n\", val2);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val2);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val1);\n\tlink_up = ((val1 & 4) == 4);\n\tDP(NETIF_MSG_LINK, \"PMA_REG_STATUS=0x%x\\n\", val1);\n\n\tif (link_up &&\n\t     ((phy->req_line_speed != SPEED_10000))) {\n\t\tif (bnx2x_8073_xaui_wa(bp, phy) != 0)\n\t\t\treturn 0;\n\t}\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_LINK_STATUS, &an1000_status);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_LINK_STATUS, &an1000_status);\n\n\t/* Check the link status on 1.1.2 */\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val2);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val1);\n\tDP(NETIF_MSG_LINK, \"KR PMA status 0x%x->0x%x,\"\n\t\t   \"an_link_status=0x%x\\n\", val2, val1, an1000_status);\n\n\tlink_up = (((val1 & 4) == 4) || (an1000_status & (1<<1)));\n\tif (link_up && bnx2x_8073_is_snr_needed(bp, phy)) {\n\t\t/* The SNR will improve about 2dbby changing the BW and FEE main\n\t\t * tap. The 1st write to change FFE main tap is set before\n\t\t * restart AN. Change PLL Bandwidth in EDC register\n\t\t */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_PLL_BANDWIDTH,\n\t\t\t\t 0x26BC);\n\n\t\t/* Change CDR Bandwidth in EDC register */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CDR_BANDWIDTH,\n\t\t\t\t 0x0333);\n\t}\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_8073_SPEED_LINK_STATUS,\n\t\t\t&link_status);\n\n\t/* Bits 0..2 --> speed detected, bits 13..15--> link is down */\n\tif ((link_status & (1<<2)) && (!(link_status & (1<<15)))) {\n\t\tlink_up = 1;\n\t\tvars->line_speed = SPEED_10000;\n\t\tDP(NETIF_MSG_LINK, \"port %x: External link up in 10G\\n\",\n\t\t\t   params->port);\n\t} else if ((link_status & (1<<1)) && (!(link_status & (1<<14)))) {\n\t\tlink_up = 1;\n\t\tvars->line_speed = SPEED_2500;\n\t\tDP(NETIF_MSG_LINK, \"port %x: External link up in 2.5G\\n\",\n\t\t\t   params->port);\n\t} else if ((link_status & (1<<0)) && (!(link_status & (1<<13)))) {\n\t\tlink_up = 1;\n\t\tvars->line_speed = SPEED_1000;\n\t\tDP(NETIF_MSG_LINK, \"port %x: External link up in 1G\\n\",\n\t\t\t   params->port);\n\t} else {\n\t\tlink_up = 0;\n\t\tDP(NETIF_MSG_LINK, \"port %x: External link is down\\n\",\n\t\t\t   params->port);\n\t}\n\n\tif (link_up) {\n\t\t/* Swap polarity if required */\n\t\tif (params->lane_config &\n\t\t    PORT_HW_CFG_SWAP_PHY_POLARITY_ENABLED) {\n\t\t\t/* Configure the 8073 to swap P and N of the KR lines */\n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_XS_DEVAD,\n\t\t\t\t\tMDIO_XS_REG_8073_RX_CTRL_PCIE, &val1);\n\t\t\t/* Set bit 3 to invert Rx in 1G mode and clear this bit\n\t\t\t * when it`s in 10G mode.\n\t\t\t */\n\t\t\tif (vars->line_speed == SPEED_1000) {\n\t\t\t\tDP(NETIF_MSG_LINK, \"Swapping 1G polarity for\"\n\t\t\t\t\t      \"the 8073\\n\");\n\t\t\t\tval1 |= (1<<3);\n\t\t\t} else\n\t\t\t\tval1 &= ~(1<<3);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_XS_DEVAD,\n\t\t\t\t\t MDIO_XS_REG_8073_RX_CTRL_PCIE,\n\t\t\t\t\t val1);\n\t\t}\n\t\tbnx2x_ext_phy_10G_an_resolve(bp, phy, vars);\n\t\tbnx2x_8073_resolve_fc(phy, params, vars);\n\t\tvars->duplex = DUPLEX_FULL;\n\t}\n\n\tif (vars->link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_LP_AUTO_NEG2, &val1);\n\n\t\tif (val1 & (1<<5))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE;\n\t\tif (val1 & (1<<7))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\n\t}\n\n\treturn link_up;\n}\n\nstatic void bnx2x_8073_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 gpio_port;\n\tif (CHIP_IS_E2(bp))\n\t\tgpio_port = BP_PATH(bp);\n\telse\n\t\tgpio_port = params->port;\n\tDP(NETIF_MSG_LINK, \"Setting 8073 port %d into low power mode\\n\",\n\t   gpio_port);\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW,\n\t\t       gpio_port);\n}\n\n/******************************************************************/\n/*\t\t\tBCM8705 PHY SECTION\t\t\t  */\n/******************************************************************/\nstatic void bnx2x_8705_config_init(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"init 8705\\n\");\n\t/* Restore normal power mode*/\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH, params->port);\n\t/* HW reset */\n\tbnx2x_ext_phy_hw_reset(bp, params->port);\n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0xa040);\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_MISC_CTRL, 0x8288);\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER, 0x7fbf);\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CMU_PLL_BYPASS, 0x0100);\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_WIS_DEVAD, MDIO_WIS_REG_LASI_CNTL, 0x1);\n\t/* BCM8705 doesn't have microcode, hence the 0 */\n\tbnx2x_save_spirom_version(bp, params->port, params->shmem_base, 0);\n}\n\nstatic u8 bnx2x_8705_read_status(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params,\n\t\t\t\t struct link_vars *vars)\n{\n\tu8 link_up = 0;\n\tu16 val1, rx_sd;\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"read status 8705\\n\");\n\tbnx2x_cl45_read(bp, phy,\n\t\t      MDIO_WIS_DEVAD, MDIO_WIS_REG_LASI_STATUS, &val1);\n\tDP(NETIF_MSG_LINK, \"8705 LASI status 0x%x\\n\", val1);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t      MDIO_WIS_DEVAD, MDIO_WIS_REG_LASI_STATUS, &val1);\n\tDP(NETIF_MSG_LINK, \"8705 LASI status 0x%x\\n\", val1);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t      MDIO_PMA_DEVAD, MDIO_PMA_REG_RX_SD, &rx_sd);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t      MDIO_PMA_DEVAD, 0xc809, &val1);\n\tbnx2x_cl45_read(bp, phy,\n\t\t      MDIO_PMA_DEVAD, 0xc809, &val1);\n\n\tDP(NETIF_MSG_LINK, \"8705 1.c809 val=0x%x\\n\", val1);\n\tlink_up = ((rx_sd & 0x1) && (val1 & (1<<9)) && ((val1 & (1<<8)) == 0));\n\tif (link_up) {\n\t\tvars->line_speed = SPEED_10000;\n\t\tbnx2x_ext_phy_resolve_fc(phy, params, vars);\n\t}\n\treturn link_up;\n}\n\n/******************************************************************/\n/*\t\t\tSFP+ module Section\t\t\t  */\n/******************************************************************/\nstatic void bnx2x_set_disable_pmd_transmit(struct link_params *params,\n\t\t\t\t\t   struct bnx2x_phy *phy,\n\t\t\t\t\t   u8 pmd_dis)\n{\n\tstruct bnx2x *bp = params->bp;\n\t/* Disable transmitter only for bootcodes which can enable it afterwards\n\t * (for D3 link)\n\t */\n\tif (pmd_dis) {\n\t\tif (params->feature_config_flags &\n\t\t     FEATURE_CONFIG_BC_SUPPORTS_SFP_TX_DISABLED)\n\t\t\tDP(NETIF_MSG_LINK, \"Disabling PMD transmitter\\n\");\n\t\telse {\n\t\t\tDP(NETIF_MSG_LINK, \"NOT disabling PMD transmitter\\n\");\n\t\t\treturn;\n\t\t}\n\t} else\n\t\tDP(NETIF_MSG_LINK, \"Enabling PMD transmitter\\n\");\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_TX_DISABLE, pmd_dis);\n}\n\nstatic u8 bnx2x_get_gpio_port(struct link_params *params)\n{\n\tu8 gpio_port;\n\tu32 swap_val, swap_override;\n\tstruct bnx2x *bp = params->bp;\n\tif (CHIP_IS_E2(bp))\n\t\tgpio_port = BP_PATH(bp);\n\telse\n\t\tgpio_port = params->port;\n\tswap_val = REG_RD(bp, NIG_REG_PORT_SWAP);\n\tswap_override = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);\n\treturn gpio_port ^ (swap_val && swap_override);\n}\n\nstatic void bnx2x_sfp_e1e2_set_transmitter(struct link_params *params,\n\t\t\t\t\t   struct bnx2x_phy *phy,\n\t\t\t\t\t   u8 tx_en)\n{\n\tu16 val;\n\tu8 port = params->port;\n\tstruct bnx2x *bp = params->bp;\n\tu32 tx_en_mode;\n\n\t/* Disable/Enable transmitter ( TX laser of the SFP+ module.)*/\n\ttx_en_mode = REG_RD(bp, params->shmem_base +\n\t\t\t    offsetof(struct shmem_region,\n\t\t\t\t     dev_info.port_hw_config[port].sfp_ctrl)) &\n\t\tPORT_HW_CFG_TX_LASER_MASK;\n\tDP(NETIF_MSG_LINK, \"Setting transmitter tx_en=%x for port %x \"\n\t\t\t   \"mode = %x\\n\", tx_en, port, tx_en_mode);\n\tswitch (tx_en_mode) {\n\tcase PORT_HW_CFG_TX_LASER_MDIO:\n\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_PHY_IDENTIFIER,\n\t\t\t\t&val);\n\n\t\tif (tx_en)\n\t\t\tval &= ~(1<<15);\n\t\telse\n\t\t\tval |= (1<<15);\n\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_PHY_IDENTIFIER,\n\t\t\t\t val);\n\tbreak;\n\tcase PORT_HW_CFG_TX_LASER_GPIO0:\n\tcase PORT_HW_CFG_TX_LASER_GPIO1:\n\tcase PORT_HW_CFG_TX_LASER_GPIO2:\n\tcase PORT_HW_CFG_TX_LASER_GPIO3:\n\t{\n\t\tu16 gpio_pin;\n\t\tu8 gpio_port, gpio_mode;\n\t\tif (tx_en)\n\t\t\tgpio_mode = MISC_REGISTERS_GPIO_OUTPUT_HIGH;\n\t\telse\n\t\t\tgpio_mode = MISC_REGISTERS_GPIO_OUTPUT_LOW;\n\n\t\tgpio_pin = tx_en_mode - PORT_HW_CFG_TX_LASER_GPIO0;\n\t\tgpio_port = bnx2x_get_gpio_port(params);\n\t\tbnx2x_set_gpio(bp, gpio_pin, gpio_mode, gpio_port);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tDP(NETIF_MSG_LINK, \"Invalid TX_LASER_MDIO 0x%x\\n\", tx_en_mode);\n\t\tbreak;\n\t}\n}\n\nstatic void bnx2x_sfp_set_transmitter(struct link_params *params,\n\t\t\t\t      struct bnx2x_phy *phy,\n\t\t\t\t      u8 tx_en)\n{\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"Setting SFP+ transmitter to %d\\n\", tx_en);\n\tif (CHIP_IS_E3(bp))\n\t\tbnx2x_sfp_e3_set_transmitter(params, phy, tx_en);\n\telse\n\t\tbnx2x_sfp_e1e2_set_transmitter(params, phy, tx_en);\n}\n\nstatic int bnx2x_8726_read_sfp_module_eeprom(struct bnx2x_phy *phy,\n\t\t\t\t\t     struct link_params *params,\n\t\t\t\t\t     u8 dev_addr, u16 addr, u8 byte_cnt,\n\t\t\t\t\t     u8 *o_buf, u8 is_init)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val = 0;\n\tu16 i;\n\tif (byte_cnt > SFP_EEPROM_PAGE_SIZE) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"Reading from eeprom is limited to 0xf\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* Set the read command byte count */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_SFP_TWO_WIRE_BYTE_CNT,\n\t\t\t (byte_cnt | (dev_addr << 8)));\n\n\t/* Set the read command address */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_SFP_TWO_WIRE_MEM_ADDR,\n\t\t\t addr);\n\n\t/* Activate read command */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_SFP_TWO_WIRE_CTRL,\n\t\t\t 0x2c0f);\n\n\t/* Wait up to 500us for command complete status */\n\tfor (i = 0; i < 100; i++) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_SFP_TWO_WIRE_CTRL, &val);\n\t\tif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) ==\n\t\t    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE)\n\t\t\tbreak;\n\t\tudelay(5);\n\t}\n\n\tif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) !=\n\t\t    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t\t \"Got bad status 0x%x when reading from SFP+ EEPROM\\n\",\n\t\t\t (val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK));\n\t\treturn -EINVAL;\n\t}\n\n\t/* Read the buffer */\n\tfor (i = 0; i < byte_cnt; i++) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_8726_TWO_WIRE_DATA_BUF + i, &val);\n\t\to_buf[i] = (u8)(val & MDIO_PMA_REG_8726_TWO_WIRE_DATA_MASK);\n\t}\n\n\tfor (i = 0; i < 100; i++) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_SFP_TWO_WIRE_CTRL, &val);\n\t\tif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) ==\n\t\t    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_IDLE)\n\t\t\treturn 0;\n\t\tusleep_range(1000, 2000);\n\t}\n\treturn -EINVAL;\n}\n\nstatic void bnx2x_warpcore_power_module(struct link_params *params,\n\t\t\t\t\tu8 power)\n{\n\tu32 pin_cfg;\n\tstruct bnx2x *bp = params->bp;\n\n\tpin_cfg = (REG_RD(bp, params->shmem_base +\n\t\t\t  offsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[params->port].e3_sfp_ctrl)) &\n\t\t\tPORT_HW_CFG_E3_PWR_DIS_MASK) >>\n\t\t\tPORT_HW_CFG_E3_PWR_DIS_SHIFT;\n\n\tif (pin_cfg == PIN_CFG_NA)\n\t\treturn;\n\tDP(NETIF_MSG_LINK, \"Setting SFP+ module power to %d using pin cfg %d\\n\",\n\t\t       power, pin_cfg);\n\t/* Low ==> corresponding SFP+ module is powered\n\t * high ==> the SFP+ module is powered down\n\t */\n\tbnx2x_set_cfg_pin(bp, pin_cfg, power ^ 1);\n}\nstatic int bnx2x_warpcore_read_sfp_module_eeprom(struct bnx2x_phy *phy,\n\t\t\t\t\t\t struct link_params *params,\n\t\t\t\t\t\t u8 dev_addr,\n\t\t\t\t\t\t u16 addr, u8 byte_cnt,\n\t\t\t\t\t\t u8 *o_buf, u8 is_init)\n{\n\tint rc = 0;\n\tu8 i, j = 0, cnt = 0;\n\tu32 data_array[4];\n\tu16 addr32;\n\tstruct bnx2x *bp = params->bp;\n\n\tif (byte_cnt > SFP_EEPROM_PAGE_SIZE) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"Reading from eeprom is limited to 16 bytes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* 4 byte aligned address */\n\taddr32 = addr & (~0x3);\n\tdo {\n\t\tif ((!is_init) && (cnt == I2C_WA_PWR_ITER)) {\n\t\t\tbnx2x_warpcore_power_module(params, 0);\n\t\t\t/* Note that 100us are not enough here */\n\t\t\tusleep_range(1000, 2000);\n\t\t\tbnx2x_warpcore_power_module(params, 1);\n\t\t}\n\t\trc = bnx2x_bsc_read(params, bp, dev_addr, addr32, 0, byte_cnt,\n\t\t\t\t    data_array);\n\t} while ((rc != 0) && (++cnt < I2C_WA_RETRY_CNT));\n\n\tif (rc == 0) {\n\t\tfor (i = (addr - addr32); i < byte_cnt + (addr - addr32); i++) {\n\t\t\to_buf[j] = *((u8 *)data_array + i);\n\t\t\tj++;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int bnx2x_8727_read_sfp_module_eeprom(struct bnx2x_phy *phy,\n\t\t\t\t\t     struct link_params *params,\n\t\t\t\t\t     u8 dev_addr, u16 addr, u8 byte_cnt,\n\t\t\t\t\t     u8 *o_buf, u8 is_init)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val, i;\n\n\tif (byte_cnt > SFP_EEPROM_PAGE_SIZE) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"Reading from eeprom is limited to 0xf\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Set 2-wire transfer rate of SFP+ module EEPROM\n\t * to 100Khz since some DACs(direct attached cables) do\n\t * not work at 400Khz.\n\t */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_8727_TWO_WIRE_SLAVE_ADDR,\n\t\t\t ((dev_addr << 8) | 1));\n\n\t/* Need to read from 1.8000 to clear it */\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_SFP_TWO_WIRE_CTRL,\n\t\t\t&val);\n\n\t/* Set the read command byte count */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_SFP_TWO_WIRE_BYTE_CNT,\n\t\t\t ((byte_cnt < 2) ? 2 : byte_cnt));\n\n\t/* Set the read command address */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_SFP_TWO_WIRE_MEM_ADDR,\n\t\t\t addr);\n\t/* Set the destination address */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t 0x8004,\n\t\t\t MDIO_PMA_REG_8727_TWO_WIRE_DATA_BUF);\n\n\t/* Activate read command */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_SFP_TWO_WIRE_CTRL,\n\t\t\t 0x8002);\n\t/* Wait appropriate time for two-wire command to finish before\n\t * polling the status register\n\t */\n\tusleep_range(1000, 2000);\n\n\t/* Wait up to 500us for command complete status */\n\tfor (i = 0; i < 100; i++) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_SFP_TWO_WIRE_CTRL, &val);\n\t\tif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) ==\n\t\t    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE)\n\t\t\tbreak;\n\t\tudelay(5);\n\t}\n\n\tif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) !=\n\t\t    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t\t \"Got bad status 0x%x when reading from SFP+ EEPROM\\n\",\n\t\t\t (val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK));\n\t\treturn -EFAULT;\n\t}\n\n\t/* Read the buffer */\n\tfor (i = 0; i < byte_cnt; i++) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_8727_TWO_WIRE_DATA_BUF + i, &val);\n\t\to_buf[i] = (u8)(val & MDIO_PMA_REG_8727_TWO_WIRE_DATA_MASK);\n\t}\n\n\tfor (i = 0; i < 100; i++) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_SFP_TWO_WIRE_CTRL, &val);\n\t\tif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) ==\n\t\t    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_IDLE)\n\t\t\treturn 0;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn -EINVAL;\n}\nint bnx2x_read_sfp_module_eeprom(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params, u8 dev_addr,\n\t\t\t\t u16 addr, u16 byte_cnt, u8 *o_buf)\n{\n\tint rc = 0;\n\tstruct bnx2x *bp = params->bp;\n\tu8 xfer_size;\n\tu8 *user_data = o_buf;\n\tread_sfp_module_eeprom_func_p read_func;\n\n\tif ((dev_addr != 0xa0) && (dev_addr != 0xa2)) {\n\t\tDP(NETIF_MSG_LINK, \"invalid dev_addr 0x%x\\n\", dev_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (phy->type) {\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:\n\t\tread_func = bnx2x_8726_read_sfp_module_eeprom;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722:\n\t\tread_func = bnx2x_8727_read_sfp_module_eeprom;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT:\n\t\tread_func = bnx2x_warpcore_read_sfp_module_eeprom;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\twhile (!rc && (byte_cnt > 0)) {\n\t\txfer_size = (byte_cnt > SFP_EEPROM_PAGE_SIZE) ?\n\t\t\tSFP_EEPROM_PAGE_SIZE : byte_cnt;\n\t\trc = read_func(phy, params, dev_addr, addr, xfer_size,\n\t\t\t       user_data, 0);\n\t\tbyte_cnt -= xfer_size;\n\t\tuser_data += xfer_size;\n\t\taddr += xfer_size;\n\t}\n\treturn rc;\n}\n\nstatic int bnx2x_get_edc_mode(struct bnx2x_phy *phy,\n\t\t\t      struct link_params *params,\n\t\t\t      u16 *edc_mode)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 sync_offset = 0, phy_idx, media_types;\n\tu8 val[SFP_EEPROM_FC_TX_TECH_ADDR + 1], check_limiting_mode = 0;\n\t*edc_mode = EDC_MODE_LIMITING;\n\tphy->media_type = ETH_PHY_UNSPECIFIED;\n\t/* First check for copper cable */\n\tif (bnx2x_read_sfp_module_eeprom(phy,\n\t\t\t\t\t params,\n\t\t\t\t\t I2C_DEV_ADDR_A0,\n\t\t\t\t\t 0,\n\t\t\t\t\t SFP_EEPROM_FC_TX_TECH_ADDR + 1,\n\t\t\t\t\t (u8 *)val) != 0) {\n\t\tDP(NETIF_MSG_LINK, \"Failed to read from SFP+ module EEPROM\\n\");\n\t\treturn -EINVAL;\n\t}\n\tparams->link_attr_sync &= ~LINK_SFP_EEPROM_COMP_CODE_MASK;\n\tparams->link_attr_sync |= val[SFP_EEPROM_10G_COMP_CODE_ADDR] <<\n\t\tLINK_SFP_EEPROM_COMP_CODE_SHIFT;\n\tbnx2x_update_link_attr(params, params->link_attr_sync);\n\tswitch (val[SFP_EEPROM_CON_TYPE_ADDR]) {\n\tcase SFP_EEPROM_CON_TYPE_VAL_COPPER:\n\t{\n\t\tu8 copper_module_type;\n\t\tphy->media_type = ETH_PHY_DA_TWINAX;\n\t\t/* Check if its active cable (includes SFP+ module)\n\t\t * of passive cable\n\t\t */\n\t\tcopper_module_type = val[SFP_EEPROM_FC_TX_TECH_ADDR];\n\n\t\tif (copper_module_type &\n\t\t    SFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_ACTIVE) {\n\t\t\tDP(NETIF_MSG_LINK, \"Active Copper cable detected\\n\");\n\t\t\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT)\n\t\t\t\t*edc_mode = EDC_MODE_ACTIVE_DAC;\n\t\t\telse\n\t\t\t\tcheck_limiting_mode = 1;\n\t\t} else {\n\t\t\t*edc_mode = EDC_MODE_PASSIVE_DAC;\n\t\t\t/* Even in case PASSIVE_DAC indication is not set,\n\t\t\t * treat it as a passive DAC cable, since some cables\n\t\t\t * don't have this indication.\n\t\t\t */\n\t\t\tif (copper_module_type &\n\t\t\t    SFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_PASSIVE) {\n\t\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t   \"Passive Copper cable detected\\n\");\n\t\t\t} else {\n\t\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t   \"Unknown copper-cable-type\\n\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase SFP_EEPROM_CON_TYPE_VAL_UNKNOWN:\n\tcase SFP_EEPROM_CON_TYPE_VAL_LC:\n\tcase SFP_EEPROM_CON_TYPE_VAL_RJ45:\n\t\tcheck_limiting_mode = 1;\n\t\tif (((val[SFP_EEPROM_10G_COMP_CODE_ADDR] &\n\t\t     (SFP_EEPROM_10G_COMP_CODE_SR_MASK |\n\t\t      SFP_EEPROM_10G_COMP_CODE_LR_MASK |\n\t\t       SFP_EEPROM_10G_COMP_CODE_LRM_MASK)) == 0) &&\n\t\t    (val[SFP_EEPROM_1G_COMP_CODE_ADDR] != 0)) {\n\t\t\tDP(NETIF_MSG_LINK, \"1G SFP module detected\\n\");\n\t\t\tphy->media_type = ETH_PHY_SFP_1G_FIBER;\n\t\t\tif (phy->req_line_speed != SPEED_1000) {\n\t\t\t\tu8 gport = params->port;\n\t\t\t\tphy->req_line_speed = SPEED_1000;\n\t\t\t\tif (!CHIP_IS_E1x(bp)) {\n\t\t\t\t\tgport = BP_PATH(bp) +\n\t\t\t\t\t(params->port << 1);\n\t\t\t\t}\n\t\t\t\tnetdev_err(bp->dev,\n\t\t\t\t\t   \"Warning: Link speed was forced to 1000Mbps. Current SFP module in port %d is not compliant with 10G Ethernet\\n\",\n\t\t\t\t\t   gport);\n\t\t\t}\n\t\t\tif (val[SFP_EEPROM_1G_COMP_CODE_ADDR] &\n\t\t\t    SFP_EEPROM_1G_COMP_CODE_BASE_T) {\n\t\t\t\tbnx2x_sfp_set_transmitter(params, phy, 0);\n\t\t\t\tmsleep(40);\n\t\t\t\tbnx2x_sfp_set_transmitter(params, phy, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tint idx, cfg_idx = 0;\n\t\t\tDP(NETIF_MSG_LINK, \"10G Optic module detected\\n\");\n\t\t\tfor (idx = INT_PHY; idx < MAX_PHYS; idx++) {\n\t\t\t\tif (params->phy[idx].type == phy->type) {\n\t\t\t\t\tcfg_idx = LINK_CONFIG_IDX(idx);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tphy->media_type = ETH_PHY_SFPP_10G_FIBER;\n\t\t\tphy->req_line_speed = params->req_line_speed[cfg_idx];\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDP(NETIF_MSG_LINK, \"Unable to determine module type 0x%x !!!\\n\",\n\t\t\t val[SFP_EEPROM_CON_TYPE_ADDR]);\n\t\treturn -EINVAL;\n\t}\n\tsync_offset = params->shmem_base +\n\t\toffsetof(struct shmem_region,\n\t\t\t dev_info.port_hw_config[params->port].media_type);\n\tmedia_types = REG_RD(bp, sync_offset);\n\t/* Update media type for non-PMF sync */\n\tfor (phy_idx = INT_PHY; phy_idx < MAX_PHYS; phy_idx++) {\n\t\tif (&(params->phy[phy_idx]) == phy) {\n\t\t\tmedia_types &= ~(PORT_HW_CFG_MEDIA_TYPE_PHY0_MASK <<\n\t\t\t\t(PORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT * phy_idx));\n\t\t\tmedia_types |= ((phy->media_type &\n\t\t\t\t\tPORT_HW_CFG_MEDIA_TYPE_PHY0_MASK) <<\n\t\t\t\t(PORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT * phy_idx));\n\t\t\tbreak;\n\t\t}\n\t}\n\tREG_WR(bp, sync_offset, media_types);\n\tif (check_limiting_mode) {\n\t\tu8 options[SFP_EEPROM_OPTIONS_SIZE];\n\t\tif (bnx2x_read_sfp_module_eeprom(phy,\n\t\t\t\t\t\t params,\n\t\t\t\t\t\t I2C_DEV_ADDR_A0,\n\t\t\t\t\t\t SFP_EEPROM_OPTIONS_ADDR,\n\t\t\t\t\t\t SFP_EEPROM_OPTIONS_SIZE,\n\t\t\t\t\t\t options) != 0) {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"Failed to read Option field from module EEPROM\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((options[0] & SFP_EEPROM_OPTIONS_LINEAR_RX_OUT_MASK))\n\t\t\t*edc_mode = EDC_MODE_LINEAR;\n\t\telse\n\t\t\t*edc_mode = EDC_MODE_LIMITING;\n\t}\n\tDP(NETIF_MSG_LINK, \"EDC mode is set to 0x%x\\n\", *edc_mode);\n\treturn 0;\n}\n/* This function read the relevant field from the module (SFP+), and verify it\n * is compliant with this board\n */\nstatic int bnx2x_verify_sfp_module(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 val, cmd;\n\tu32 fw_resp, fw_cmd_param;\n\tchar vendor_name[SFP_EEPROM_VENDOR_NAME_SIZE+1];\n\tchar vendor_pn[SFP_EEPROM_PART_NO_SIZE+1];\n\tphy->flags &= ~FLAGS_SFP_NOT_APPROVED;\n\tval = REG_RD(bp, params->shmem_base +\n\t\t\t offsetof(struct shmem_region, dev_info.\n\t\t\t\t  port_feature_config[params->port].config));\n\tif ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) ==\n\t    PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_NO_ENFORCEMENT) {\n\t\tDP(NETIF_MSG_LINK, \"NOT enforcing module verification\\n\");\n\t\treturn 0;\n\t}\n\n\tif (params->feature_config_flags &\n\t    FEATURE_CONFIG_BC_SUPPORTS_DUAL_PHY_OPT_MDL_VRFY) {\n\t\t/* Use specific phy request */\n\t\tcmd = DRV_MSG_CODE_VRFY_SPECIFIC_PHY_OPT_MDL;\n\t} else if (params->feature_config_flags &\n\t\t   FEATURE_CONFIG_BC_SUPPORTS_OPT_MDL_VRFY) {\n\t\t/* Use first phy request only in case of non-dual media*/\n\t\tif (DUAL_MEDIA(params)) {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"FW does not support OPT MDL verification\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcmd = DRV_MSG_CODE_VRFY_FIRST_PHY_OPT_MDL;\n\t} else {\n\t\t/* No support in OPT MDL detection */\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"FW does not support OPT MDL verification\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfw_cmd_param = FW_PARAM_SET(phy->addr, phy->type, phy->mdio_ctrl);\n\tfw_resp = bnx2x_fw_command(bp, cmd, fw_cmd_param);\n\tif (fw_resp == FW_MSG_CODE_VRFY_OPT_MDL_SUCCESS) {\n\t\tDP(NETIF_MSG_LINK, \"Approved module\\n\");\n\t\treturn 0;\n\t}\n\n\t/* Format the warning message */\n\tif (bnx2x_read_sfp_module_eeprom(phy,\n\t\t\t\t\t params,\n\t\t\t\t\t I2C_DEV_ADDR_A0,\n\t\t\t\t\t SFP_EEPROM_VENDOR_NAME_ADDR,\n\t\t\t\t\t SFP_EEPROM_VENDOR_NAME_SIZE,\n\t\t\t\t\t (u8 *)vendor_name))\n\t\tvendor_name[0] = '\\0';\n\telse\n\t\tvendor_name[SFP_EEPROM_VENDOR_NAME_SIZE] = '\\0';\n\tif (bnx2x_read_sfp_module_eeprom(phy,\n\t\t\t\t\t params,\n\t\t\t\t\t I2C_DEV_ADDR_A0,\n\t\t\t\t\t SFP_EEPROM_PART_NO_ADDR,\n\t\t\t\t\t SFP_EEPROM_PART_NO_SIZE,\n\t\t\t\t\t (u8 *)vendor_pn))\n\t\tvendor_pn[0] = '\\0';\n\telse\n\t\tvendor_pn[SFP_EEPROM_PART_NO_SIZE] = '\\0';\n\n\tnetdev_err(bp->dev,  \"Warning: Unqualified SFP+ module detected,\"\n\t\t\t      \" Port %d from %s part number %s\\n\",\n\t\t\t params->port, vendor_name, vendor_pn);\n\tif ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) !=\n\t    PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_WARNING_MSG)\n\t\tphy->flags |= FLAGS_SFP_NOT_APPROVED;\n\treturn -EINVAL;\n}\n\nstatic int bnx2x_wait_for_sfp_module_initialized(struct bnx2x_phy *phy,\n\t\t\t\t\t\t struct link_params *params)\n\n{\n\tu8 val;\n\tint rc;\n\tstruct bnx2x *bp = params->bp;\n\tu16 timeout;\n\t/* Initialization time after hot-plug may take up to 300ms for\n\t * some phys type ( e.g. JDSU )\n\t */\n\n\tfor (timeout = 0; timeout < 60; timeout++) {\n\t\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT)\n\t\t\trc = bnx2x_warpcore_read_sfp_module_eeprom(\n\t\t\t\tphy, params, I2C_DEV_ADDR_A0, 1, 1, &val,\n\t\t\t\t1);\n\t\telse\n\t\t\trc = bnx2x_read_sfp_module_eeprom(phy, params,\n\t\t\t\t\t\t\t  I2C_DEV_ADDR_A0,\n\t\t\t\t\t\t\t  1, 1, &val);\n\t\tif (rc == 0) {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"SFP+ module initialization took %d ms\\n\",\n\t\t\t   timeout * 5);\n\t\t\treturn 0;\n\t\t}\n\t\tusleep_range(5000, 10000);\n\t}\n\trc = bnx2x_read_sfp_module_eeprom(phy, params, I2C_DEV_ADDR_A0,\n\t\t\t\t\t  1, 1, &val);\n\treturn rc;\n}\n\nstatic void bnx2x_8727_power_module(struct bnx2x *bp,\n\t\t\t\t    struct bnx2x_phy *phy,\n\t\t\t\t    u8 is_power_up) {\n\t/* Make sure GPIOs are not using for LED mode */\n\tu16 val;\n\t/* In the GPIO register, bit 4 is use to determine if the GPIOs are\n\t * operating as INPUT or as OUTPUT. Bit 1 is for input, and 0 for\n\t * output\n\t * Bits 0-1 determine the GPIOs value for OUTPUT in case bit 4 val is 0\n\t * Bits 8-9 determine the GPIOs value for INPUT in case bit 4 val is 1\n\t * where the 1st bit is the over-current(only input), and 2nd bit is\n\t * for power( only output )\n\t *\n\t * In case of NOC feature is disabled and power is up, set GPIO control\n\t *  as input to enable listening of over-current indication\n\t */\n\tif (phy->flags & FLAGS_NOC)\n\t\treturn;\n\tif (is_power_up)\n\t\tval = (1<<4);\n\telse\n\t\t/* Set GPIO control to OUTPUT, and set the power bit\n\t\t * to according to the is_power_up\n\t\t */\n\t\tval = (1<<1);\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_8727_GPIO_CTRL,\n\t\t\t val);\n}\n\nstatic int bnx2x_8726_set_limiting_mode(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_phy *phy,\n\t\t\t\t\tu16 edc_mode)\n{\n\tu16 cur_limiting_mode;\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_ROM_VER2,\n\t\t\t&cur_limiting_mode);\n\tDP(NETIF_MSG_LINK, \"Current Limiting mode is 0x%x\\n\",\n\t\t cur_limiting_mode);\n\n\tif (edc_mode == EDC_MODE_LIMITING) {\n\t\tDP(NETIF_MSG_LINK, \"Setting LIMITING MODE\\n\");\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_ROM_VER2,\n\t\t\t\t EDC_MODE_LIMITING);\n\t} else { /* LRM mode ( default )*/\n\n\t\tDP(NETIF_MSG_LINK, \"Setting LRM MODE\\n\");\n\n\t\t/* Changing to LRM mode takes quite few seconds. So do it only\n\t\t * if current mode is limiting (default is LRM)\n\t\t */\n\t\tif (cur_limiting_mode != EDC_MODE_LIMITING)\n\t\t\treturn 0;\n\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_LRM_MODE,\n\t\t\t\t 0);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_ROM_VER2,\n\t\t\t\t 0x128);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_MISC_CTRL0,\n\t\t\t\t 0x4008);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_LRM_MODE,\n\t\t\t\t 0xaaaa);\n\t}\n\treturn 0;\n}\n\nstatic int bnx2x_8727_set_limiting_mode(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_phy *phy,\n\t\t\t\t\tu16 edc_mode)\n{\n\tu16 phy_identifier;\n\tu16 rom_ver2_val;\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_PHY_IDENTIFIER,\n\t\t\t&phy_identifier);\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_PHY_IDENTIFIER,\n\t\t\t (phy_identifier & ~(1<<9)));\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_ROM_VER2,\n\t\t\t&rom_ver2_val);\n\t/* Keep the MSB 8-bits, and set the LSB 8-bits with the edc_mode */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_ROM_VER2,\n\t\t\t (rom_ver2_val & 0xff00) | (edc_mode & 0x00ff));\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_PHY_IDENTIFIER,\n\t\t\t (phy_identifier | (1<<9)));\n\n\treturn 0;\n}\n\nstatic void bnx2x_8727_specific_func(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params,\n\t\t\t\t     u32 action)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val;\n\tswitch (action) {\n\tcase DISABLE_TX:\n\t\tbnx2x_sfp_set_transmitter(params, phy, 0);\n\t\tbreak;\n\tcase ENABLE_TX:\n\t\tif (!(phy->flags & FLAGS_SFP_NOT_APPROVED))\n\t\t\tbnx2x_sfp_set_transmitter(params, phy, 1);\n\t\tbreak;\n\tcase PHY_INIT:\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL,\n\t\t\t\t (1<<2) | (1<<5));\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_TXCTRL,\n\t\t\t\t 0);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 0x0006);\n\t\t/* Make MOD_ABS give interrupt on change */\n\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_8727_PCS_OPT_CTRL,\n\t\t\t\t&val);\n\t\tval |= (1<<12);\n\t\tif (phy->flags & FLAGS_NOC)\n\t\t\tval |= (3<<5);\n\t\t/* Set 8727 GPIOs to input to allow reading from the 8727 GPIO0\n\t\t * status which reflect SFP+ module over-current\n\t\t */\n\t\tif (!(phy->flags & FLAGS_NOC))\n\t\t\tval &= 0xff8f; /* Reset bits 4-6 */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_8727_PCS_OPT_CTRL,\n\t\t\t\t val);\n\t\tbreak;\n\tdefault:\n\t\tDP(NETIF_MSG_LINK, \"Function 0x%x not supported by 8727\\n\",\n\t\t   action);\n\t\treturn;\n\t}\n}\n\nstatic void bnx2x_set_e1e2_module_fault_led(struct link_params *params,\n\t\t\t\t\t   u8 gpio_mode)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tu32 fault_led_gpio = REG_RD(bp, params->shmem_base +\n\t\t\t    offsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[params->port].sfp_ctrl)) &\n\t\tPORT_HW_CFG_FAULT_MODULE_LED_MASK;\n\tswitch (fault_led_gpio) {\n\tcase PORT_HW_CFG_FAULT_MODULE_LED_DISABLED:\n\t\treturn;\n\tcase PORT_HW_CFG_FAULT_MODULE_LED_GPIO0:\n\tcase PORT_HW_CFG_FAULT_MODULE_LED_GPIO1:\n\tcase PORT_HW_CFG_FAULT_MODULE_LED_GPIO2:\n\tcase PORT_HW_CFG_FAULT_MODULE_LED_GPIO3:\n\t{\n\t\tu8 gpio_port = bnx2x_get_gpio_port(params);\n\t\tu16 gpio_pin = fault_led_gpio -\n\t\t\tPORT_HW_CFG_FAULT_MODULE_LED_GPIO0;\n\t\tDP(NETIF_MSG_LINK, \"Set fault module-detected led \"\n\t\t\t\t   \"pin %x port %x mode %x\\n\",\n\t\t\t       gpio_pin, gpio_port, gpio_mode);\n\t\tbnx2x_set_gpio(bp, gpio_pin, gpio_mode, gpio_port);\n\t}\n\tbreak;\n\tdefault:\n\t\tDP(NETIF_MSG_LINK, \"Error: Invalid fault led mode 0x%x\\n\",\n\t\t\t       fault_led_gpio);\n\t}\n}\n\nstatic void bnx2x_set_e3_module_fault_led(struct link_params *params,\n\t\t\t\t\t  u8 gpio_mode)\n{\n\tu32 pin_cfg;\n\tu8 port = params->port;\n\tstruct bnx2x *bp = params->bp;\n\tpin_cfg = (REG_RD(bp, params->shmem_base +\n\t\t\t offsetof(struct shmem_region,\n\t\t\t\t  dev_info.port_hw_config[port].e3_sfp_ctrl)) &\n\t\tPORT_HW_CFG_E3_FAULT_MDL_LED_MASK) >>\n\t\tPORT_HW_CFG_E3_FAULT_MDL_LED_SHIFT;\n\tDP(NETIF_MSG_LINK, \"Setting Fault LED to %d using pin cfg %d\\n\",\n\t\t       gpio_mode, pin_cfg);\n\tbnx2x_set_cfg_pin(bp, pin_cfg, gpio_mode);\n}\n\nstatic void bnx2x_set_sfp_module_fault_led(struct link_params *params,\n\t\t\t\t\t   u8 gpio_mode)\n{\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"Setting SFP+ module fault LED to %d\\n\", gpio_mode);\n\tif (CHIP_IS_E3(bp)) {\n\t\t/* Low ==> if SFP+ module is supported otherwise\n\t\t * High ==> if SFP+ module is not on the approved vendor list\n\t\t */\n\t\tbnx2x_set_e3_module_fault_led(params, gpio_mode);\n\t} else\n\t\tbnx2x_set_e1e2_module_fault_led(params, gpio_mode);\n}\n\nstatic void bnx2x_warpcore_hw_reset(struct bnx2x_phy *phy,\n\t\t\t\t    struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tbnx2x_warpcore_power_module(params, 0);\n\t/* Put Warpcore in low power mode */\n\tREG_WR(bp, MISC_REG_WC0_RESET, 0x0c0e);\n\n\t/* Put LCPLL in low power mode */\n\tREG_WR(bp, MISC_REG_LCPLL_E40_PWRDWN, 1);\n\tREG_WR(bp, MISC_REG_LCPLL_E40_RESETB_ANA, 0);\n\tREG_WR(bp, MISC_REG_LCPLL_E40_RESETB_DIG, 0);\n}\n\nstatic void bnx2x_power_sfp_module(struct link_params *params,\n\t\t\t\t   struct bnx2x_phy *phy,\n\t\t\t\t   u8 power)\n{\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"Setting SFP+ power to %x\\n\", power);\n\n\tswitch (phy->type) {\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722:\n\t\tbnx2x_8727_power_module(params->bp, phy, power);\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT:\n\t\tbnx2x_warpcore_power_module(params, power);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nstatic void bnx2x_warpcore_set_limiting_mode(struct link_params *params,\n\t\t\t\t\t     struct bnx2x_phy *phy,\n\t\t\t\t\t     u16 edc_mode)\n{\n\tu16 val = 0;\n\tu16 mode = MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE_DEFAULT;\n\tstruct bnx2x *bp = params->bp;\n\n\tu8 lane = bnx2x_get_warpcore_lane(phy, params);\n\t/* This is a global register which controls all lanes */\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE, &val);\n\tval &= ~(0xf << (lane << 2));\n\n\tswitch (edc_mode) {\n\tcase EDC_MODE_LINEAR:\n\tcase EDC_MODE_LIMITING:\n\t\tmode = MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE_DEFAULT;\n\t\tbreak;\n\tcase EDC_MODE_PASSIVE_DAC:\n\tcase EDC_MODE_ACTIVE_DAC:\n\t\tmode = MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE_SFP_DAC;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tval |= (mode << (lane << 2));\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE, val);\n\t/* A must read */\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE, &val);\n\n\t/* Restart microcode to re-read the new mode */\n\tbnx2x_warpcore_reset_lane(bp, phy, 1);\n\tbnx2x_warpcore_reset_lane(bp, phy, 0);\n\n}\n\nstatic void bnx2x_set_limiting_mode(struct link_params *params,\n\t\t\t\t    struct bnx2x_phy *phy,\n\t\t\t\t    u16 edc_mode)\n{\n\tswitch (phy->type) {\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:\n\t\tbnx2x_8726_set_limiting_mode(params->bp, phy, edc_mode);\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722:\n\t\tbnx2x_8727_set_limiting_mode(params->bp, phy, edc_mode);\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT:\n\t\tbnx2x_warpcore_set_limiting_mode(params, phy, edc_mode);\n\t\tbreak;\n\t}\n}\n\nstatic int bnx2x_sfp_module_detection(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 edc_mode;\n\tint rc = 0;\n\n\tu32 val = REG_RD(bp, params->shmem_base +\n\t\t\t     offsetof(struct shmem_region, dev_info.\n\t\t\t\t     port_feature_config[params->port].config));\n\t/* Enabled transmitter by default */\n\tbnx2x_sfp_set_transmitter(params, phy, 1);\n\tDP(NETIF_MSG_LINK, \"SFP+ module plugged in/out detected on port %d\\n\",\n\t\t params->port);\n\t/* Power up module */\n\tbnx2x_power_sfp_module(params, phy, 1);\n\tif (bnx2x_get_edc_mode(phy, params, &edc_mode) != 0) {\n\t\tDP(NETIF_MSG_LINK, \"Failed to get valid module type\\n\");\n\t\treturn -EINVAL;\n\t} else if (bnx2x_verify_sfp_module(phy, params) != 0) {\n\t\t/* Check SFP+ module compatibility */\n\t\tDP(NETIF_MSG_LINK, \"Module verification failed!!\\n\");\n\t\trc = -EINVAL;\n\t\t/* Turn on fault module-detected led */\n\t\tbnx2x_set_sfp_module_fault_led(params,\n\t\t\t\t\t       MISC_REGISTERS_GPIO_HIGH);\n\n\t\t/* Check if need to power down the SFP+ module */\n\t\tif ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) ==\n\t\t     PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_POWER_DOWN) {\n\t\t\tDP(NETIF_MSG_LINK, \"Shutdown SFP+ module!!\\n\");\n\t\t\tbnx2x_power_sfp_module(params, phy, 0);\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\t/* Turn off fault module-detected led */\n\t\tbnx2x_set_sfp_module_fault_led(params, MISC_REGISTERS_GPIO_LOW);\n\t}\n\n\t/* Check and set limiting mode / LRM mode on 8726. On 8727 it\n\t * is done automatically\n\t */\n\tbnx2x_set_limiting_mode(params, phy, edc_mode);\n\n\t/* Disable transmit for this module if the module is not approved, and\n\t * laser needs to be disabled.\n\t */\n\tif ((rc) &&\n\t    ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) ==\n\t     PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_DISABLE_TX_LASER))\n\t\tbnx2x_sfp_set_transmitter(params, phy, 0);\n\n\treturn rc;\n}\n\nvoid bnx2x_handle_module_detect_int(struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tstruct bnx2x_phy *phy;\n\tu32 gpio_val;\n\tu8 gpio_num, gpio_port;\n\tif (CHIP_IS_E3(bp)) {\n\t\tphy = &params->phy[INT_PHY];\n\t\t/* Always enable TX laser,will be disabled in case of fault */\n\t\tbnx2x_sfp_set_transmitter(params, phy, 1);\n\t} else {\n\t\tphy = &params->phy[EXT_PHY1];\n\t}\n\tif (bnx2x_get_mod_abs_int_cfg(bp, params->chip_id, params->shmem_base,\n\t\t\t\t      params->port, &gpio_num, &gpio_port) ==\n\t    -EINVAL) {\n\t\tDP(NETIF_MSG_LINK, \"Failed to get MOD_ABS interrupt config\\n\");\n\t\treturn;\n\t}\n\n\t/* Set valid module led off */\n\tbnx2x_set_sfp_module_fault_led(params, MISC_REGISTERS_GPIO_HIGH);\n\n\t/* Get current gpio val reflecting module plugged in / out*/\n\tgpio_val = bnx2x_get_gpio(bp, gpio_num, gpio_port);\n\n\t/* Call the handling function in case module is detected */\n\tif (gpio_val == 0) {\n\t\tbnx2x_set_mdio_emac_per_phy(bp, params);\n\t\tbnx2x_set_aer_mmd(params, phy);\n\n\t\tbnx2x_power_sfp_module(params, phy, 1);\n\t\tbnx2x_set_gpio_int(bp, gpio_num,\n\t\t\t\t   MISC_REGISTERS_GPIO_INT_OUTPUT_CLR,\n\t\t\t\t   gpio_port);\n\t\tif (bnx2x_wait_for_sfp_module_initialized(phy, params) == 0) {\n\t\t\tbnx2x_sfp_module_detection(phy, params);\n\t\t\tif (CHIP_IS_E3(bp)) {\n\t\t\t\tu16 rx_tx_in_reset;\n\t\t\t\t/* In case WC is out of reset, reconfigure the\n\t\t\t\t * link speed while taking into account 1G\n\t\t\t\t * module limitation.\n\t\t\t\t */\n\t\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\t\tMDIO_WC_DEVAD,\n\t\t\t\t\t\tMDIO_WC_REG_DIGITAL5_MISC6,\n\t\t\t\t\t\t&rx_tx_in_reset);\n\t\t\t\tif ((!rx_tx_in_reset) &&\n\t\t\t\t    (params->link_flags &\n\t\t\t\t     PHY_INITIALIZED)) {\n\t\t\t\t\tbnx2x_warpcore_reset_lane(bp, phy, 1);\n\t\t\t\t\tbnx2x_warpcore_config_sfi(phy, params);\n\t\t\t\t\tbnx2x_warpcore_reset_lane(bp, phy, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tDP(NETIF_MSG_LINK, \"SFP+ module is not initialized\\n\");\n\t\t}\n\t} else {\n\t\tbnx2x_set_gpio_int(bp, gpio_num,\n\t\t\t\t   MISC_REGISTERS_GPIO_INT_OUTPUT_SET,\n\t\t\t\t   gpio_port);\n\t\t/* Module was plugged out.\n\t\t * Disable transmit for this module\n\t\t */\n\t\tphy->media_type = ETH_PHY_NOT_PRESENT;\n\t}\n}\n\n/******************************************************************/\n/*\t\tUsed by 8706 and 8727                             */\n/******************************************************************/\nstatic void bnx2x_sfp_mask_fault(struct bnx2x *bp,\n\t\t\t\t struct bnx2x_phy *phy,\n\t\t\t\t u16 alarm_status_offset,\n\t\t\t\t u16 alarm_ctrl_offset)\n{\n\tu16 alarm_status, val;\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, alarm_status_offset,\n\t\t\t&alarm_status);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, alarm_status_offset,\n\t\t\t&alarm_status);\n\t/* Mask or enable the fault event. */\n\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD, alarm_ctrl_offset, &val);\n\tif (alarm_status & (1<<0))\n\t\tval &= ~(1<<0);\n\telse\n\t\tval |= (1<<0);\n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, alarm_ctrl_offset, val);\n}\n/******************************************************************/\n/*\t\tcommon BCM8706/BCM8726 PHY SECTION\t\t  */\n/******************************************************************/\nstatic u8 bnx2x_8706_8726_read_status(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params,\n\t\t\t\t      struct link_vars *vars)\n{\n\tu8 link_up = 0;\n\tu16 val1, val2, rx_sd, pcs_status;\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"XGXS 8706/8726\\n\");\n\t/* Clear RX Alarm*/\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXSTAT, &val2);\n\n\tbnx2x_sfp_mask_fault(bp, phy, MDIO_PMA_LASI_TXSTAT,\n\t\t\t     MDIO_PMA_LASI_TXCTRL);\n\n\t/* Clear LASI indication*/\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val1);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val2);\n\tDP(NETIF_MSG_LINK, \"8706/8726 LASI status 0x%x--> 0x%x\\n\", val1, val2);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_RX_SD, &rx_sd);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PCS_DEVAD, MDIO_PCS_REG_STATUS, &pcs_status);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_LINK_STATUS, &val2);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_LINK_STATUS, &val2);\n\n\tDP(NETIF_MSG_LINK, \"8706/8726 rx_sd 0x%x pcs_status 0x%x 1Gbps\"\n\t\t\t\" link_status 0x%x\\n\", rx_sd, pcs_status, val2);\n\t/* Link is up if both bit 0 of pmd_rx_sd and bit 0 of pcs_status\n\t * are set, or if the autoneg bit 1 is set\n\t */\n\tlink_up = ((rx_sd & pcs_status & 0x1) || (val2 & (1<<1)));\n\tif (link_up) {\n\t\tif (val2 & (1<<1))\n\t\t\tvars->line_speed = SPEED_1000;\n\t\telse\n\t\t\tvars->line_speed = SPEED_10000;\n\t\tbnx2x_ext_phy_resolve_fc(phy, params, vars);\n\t\tvars->duplex = DUPLEX_FULL;\n\t}\n\n\t/* Capture 10G link fault. Read twice to clear stale value. */\n\tif (vars->line_speed == SPEED_10000) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\n\t\t\t    MDIO_PMA_LASI_TXSTAT, &val1);\n\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\n\t\t\t    MDIO_PMA_LASI_TXSTAT, &val1);\n\t\tif (val1 & (1<<0))\n\t\t\tvars->fault_detected = 1;\n\t}\n\n\treturn link_up;\n}\n\n/******************************************************************/\n/*\t\t\tBCM8706 PHY SECTION\t\t\t  */\n/******************************************************************/\nstatic void bnx2x_8706_config_init(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tu32 tx_en_mode;\n\tu16 cnt, val, tmp1;\n\tstruct bnx2x *bp = params->bp;\n\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH, params->port);\n\t/* HW reset */\n\tbnx2x_ext_phy_hw_reset(bp, params->port);\n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0xa040);\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\t/* Wait until fw is loaded */\n\tfor (cnt = 0; cnt < 100; cnt++) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_ROM_VER1, &val);\n\t\tif (val)\n\t\t\tbreak;\n\t\tusleep_range(10000, 20000);\n\t}\n\tDP(NETIF_MSG_LINK, \"XGXS 8706 is initialized after %d ms\\n\", cnt);\n\tif ((params->feature_config_flags &\n\t     FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED)) {\n\t\tu8 i;\n\t\tu16 reg;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\treg = MDIO_XS_8706_REG_BANK_RX0 +\n\t\t\t\ti*(MDIO_XS_8706_REG_BANK_RX1 -\n\t\t\t\t   MDIO_XS_8706_REG_BANK_RX0);\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_XS_DEVAD, reg, &val);\n\t\t\t/* Clear first 3 bits of the control */\n\t\t\tval &= ~0x7;\n\t\t\t/* Set control bits according to configuration */\n\t\t\tval |= (phy->rx_preemphasis[i] & 0x7);\n\t\t\tDP(NETIF_MSG_LINK, \"Setting RX Equalizer to BCM8706\"\n\t\t\t\t   \" reg 0x%x <-- val 0x%x\\n\", reg, val);\n\t\t\tbnx2x_cl45_write(bp, phy, MDIO_XS_DEVAD, reg, val);\n\t\t}\n\t}\n\t/* Force speed */\n\tif (phy->req_line_speed == SPEED_10000) {\n\t\tDP(NETIF_MSG_LINK, \"XGXS 8706 force 10Gbps\\n\");\n\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_DIGITAL_CTRL, 0x400);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_TXCTRL,\n\t\t\t\t 0);\n\t\t/* Arm LASI for link and Tx fault. */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 3);\n\t} else {\n\t\t/* Force 1Gbps using autoneg with 1G advertisement */\n\n\t\t/* Allow CL37 through CL73 */\n\t\tDP(NETIF_MSG_LINK, \"XGXS 8706 AutoNeg\\n\");\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_CL73, 0x040c);\n\n\t\t/* Enable Full-Duplex advertisement on CL37 */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LP, 0x0020);\n\t\t/* Enable CL37 AN */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_AN, 0x1000);\n\t\t/* 1G support */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_ADV, (1<<5));\n\n\t\t/* Enable clause 73 AN */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0x1200);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL,\n\t\t\t\t 0x0400);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL,\n\t\t\t\t 0x0004);\n\t}\n\tbnx2x_save_bcm_spirom_ver(bp, phy, params->port);\n\n\t/* If TX Laser is controlled by GPIO_0, do not let PHY go into low\n\t * power mode, if TX Laser is disabled\n\t */\n\n\ttx_en_mode = REG_RD(bp, params->shmem_base +\n\t\t\t    offsetof(struct shmem_region,\n\t\t\t\tdev_info.port_hw_config[params->port].sfp_ctrl))\n\t\t\t& PORT_HW_CFG_TX_LASER_MASK;\n\n\tif (tx_en_mode == PORT_HW_CFG_TX_LASER_GPIO0) {\n\t\tDP(NETIF_MSG_LINK, \"Enabling TXONOFF_PWRDN_DIS\\n\");\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_DIGITAL_CTRL, &tmp1);\n\t\ttmp1 |= 0x1;\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_DIGITAL_CTRL, tmp1);\n\t}\n}\n\nstatic u8 bnx2x_8706_read_status(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params,\n\t\t\t\t struct link_vars *vars)\n{\n\treturn bnx2x_8706_8726_read_status(phy, params, vars);\n}\n\n/******************************************************************/\n/*\t\t\tBCM8726 PHY SECTION\t\t\t  */\n/******************************************************************/\nstatic void bnx2x_8726_config_loopback(struct bnx2x_phy *phy,\n\t\t\t\t       struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"PMA/PMD ext_phy_loopback: 8726\\n\");\n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x0001);\n}\n\nstatic void bnx2x_8726_external_rom_boot(struct bnx2x_phy *phy,\n\t\t\t\t\t struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\t/* Need to wait 100ms after reset */\n\tmsleep(100);\n\n\t/* Micro controller re-boot */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_GEN_CTRL, 0x018B);\n\n\t/* Set soft reset */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL,\n\t\t\t MDIO_PMA_REG_GEN_CTRL_ROM_MICRO_RESET);\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_MISC_CTRL1, 0x0001);\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL,\n\t\t\t MDIO_PMA_REG_GEN_CTRL_ROM_RESET_INTERNAL_MP);\n\n\t/* Wait for 150ms for microcode load */\n\tmsleep(150);\n\n\t/* Disable serial boot control, tristates pins SS_N, SCK, MOSI, MISO */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_MISC_CTRL1, 0x0000);\n\n\tmsleep(200);\n\tbnx2x_save_bcm_spirom_ver(bp, phy, params->port);\n}\n\nstatic u8 bnx2x_8726_read_status(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params,\n\t\t\t\t struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val1;\n\tu8 link_up = bnx2x_8706_8726_read_status(phy, params, vars);\n\tif (link_up) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER,\n\t\t\t\t&val1);\n\t\tif (val1 & (1<<15)) {\n\t\t\tDP(NETIF_MSG_LINK, \"Tx is disabled\\n\");\n\t\t\tlink_up = 0;\n\t\t\tvars->line_speed = 0;\n\t\t}\n\t}\n\treturn link_up;\n}\n\n\nstatic void bnx2x_8726_config_init(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"Initializing BCM8726\\n\");\n\n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 1<<15);\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\tbnx2x_8726_external_rom_boot(phy, params);\n\n\t/* Need to call module detected on initialization since the module\n\t * detection triggered by actual module insertion might occur before\n\t * driver is loaded, and when driver is loaded, it reset all\n\t * registers, including the transmitter\n\t */\n\tbnx2x_sfp_module_detection(phy, params);\n\n\tif (phy->req_line_speed == SPEED_1000) {\n\t\tDP(NETIF_MSG_LINK, \"Setting 1G force\\n\");\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x40);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_10G_CTRL2, 0xD);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 0x5);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL,\n\t\t\t\t 0x400);\n\t} else if ((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t\t   (phy->speed_cap_mask &\n\t\t      PORT_HW_CFG_SPEED_CAPABILITY_D0_1G) &&\n\t\t   ((phy->speed_cap_mask &\n\t\t      PORT_HW_CFG_SPEED_CAPABILITY_D0_10G) !=\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)) {\n\t\tDP(NETIF_MSG_LINK, \"Setting 1G clause37\\n\");\n\t\t/* Set Flow control */\n\t\tbnx2x_ext_phy_set_pause(params, phy, vars);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_ADV, 0x20);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_CL73, 0x040c);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LD, 0x0020);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_AN, 0x1000);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0x1200);\n\t\t/* Enable RX-ALARM control to receive interrupt for 1G speed\n\t\t * change\n\t\t */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 0x4);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL,\n\t\t\t\t 0x400);\n\n\t} else { /* Default 10G. Set only LASI control */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 1);\n\t}\n\n\t/* Set TX PreEmphasis if needed */\n\tif ((params->feature_config_flags &\n\t     FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED)) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"Setting TX_CTRL1 0x%x, TX_CTRL2 0x%x\\n\",\n\t\t\t phy->tx_preemphasis[0],\n\t\t\t phy->tx_preemphasis[1]);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_8726_TX_CTRL1,\n\t\t\t\t phy->tx_preemphasis[0]);\n\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_8726_TX_CTRL2,\n\t\t\t\t phy->tx_preemphasis[1]);\n\t}\n}\n\nstatic void bnx2x_8726_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"bnx2x_8726_link_reset port %d\\n\", params->port);\n\t/* Set serial boot control for external load */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL, 0x0001);\n}\n\n/******************************************************************/\n/*\t\t\tBCM8727 PHY SECTION\t\t\t  */\n/******************************************************************/\n\nstatic void bnx2x_8727_set_link_led(struct bnx2x_phy *phy,\n\t\t\t\t    struct link_params *params, u8 mode)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 led_mode_bitmask = 0;\n\tu16 gpio_pins_bitmask = 0;\n\tu16 val;\n\t/* Only NOC flavor requires to set the LED specifically */\n\tif (!(phy->flags & FLAGS_NOC))\n\t\treturn;\n\tswitch (mode) {\n\tcase LED_MODE_FRONT_PANEL_OFF:\n\tcase LED_MODE_OFF:\n\t\tled_mode_bitmask = 0;\n\t\tgpio_pins_bitmask = 0x03;\n\t\tbreak;\n\tcase LED_MODE_ON:\n\t\tled_mode_bitmask = 0;\n\t\tgpio_pins_bitmask = 0x02;\n\t\tbreak;\n\tcase LED_MODE_OPER:\n\t\tled_mode_bitmask = 0x60;\n\t\tgpio_pins_bitmask = 0x11;\n\t\tbreak;\n\t}\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_8727_PCS_OPT_CTRL,\n\t\t\t&val);\n\tval &= 0xff8f;\n\tval |= led_mode_bitmask;\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_8727_PCS_OPT_CTRL,\n\t\t\t val);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_8727_GPIO_CTRL,\n\t\t\t&val);\n\tval &= 0xffe0;\n\tval |= gpio_pins_bitmask;\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_8727_GPIO_CTRL,\n\t\t\t val);\n}\nstatic void bnx2x_8727_hw_reset(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params) {\n\tu32 swap_val, swap_override;\n\tu8 port;\n\t/* The PHY reset is controlled by GPIO 1. Fake the port number\n\t * to cancel the swap done in set_gpio()\n\t */\n\tstruct bnx2x *bp = params->bp;\n\tswap_val = REG_RD(bp, NIG_REG_PORT_SWAP);\n\tswap_override = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);\n\tport = (swap_val && swap_override) ^ 1;\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW, port);\n}\n\nstatic void bnx2x_8727_config_speed(struct bnx2x_phy *phy,\n\t\t\t\t    struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 tmp1, val;\n\t/* Set option 1G speed */\n\tif ((phy->req_line_speed == SPEED_1000) ||\n\t    (phy->media_type == ETH_PHY_SFP_1G_FIBER)) {\n\t\tDP(NETIF_MSG_LINK, \"Setting 1G force\\n\");\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x40);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_10G_CTRL2, 0xD);\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_10G_CTRL2, &tmp1);\n\t\tDP(NETIF_MSG_LINK, \"1.7 = 0x%x\\n\", tmp1);\n\t\t/* Power down the XAUI until link is up in case of dual-media\n\t\t * and 1G\n\t\t */\n\t\tif (DUAL_MEDIA(params)) {\n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8727_PCS_GP, &val);\n\t\t\tval |= (3<<10);\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8727_PCS_GP, val);\n\t\t}\n\t} else if ((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t\t   ((phy->speed_cap_mask &\n\t\t     PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)) &&\n\t\t   ((phy->speed_cap_mask &\n\t\t      PORT_HW_CFG_SPEED_CAPABILITY_D0_10G) !=\n\t\t   PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)) {\n\n\t\tDP(NETIF_MSG_LINK, \"Setting 1G clause37\\n\");\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_8727_MISC_CTRL, 0);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_AN, 0x1300);\n\t} else {\n\t\t/* Since the 8727 has only single reset pin, need to set the 10G\n\t\t * registers although it is default\n\t\t */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_8727_MISC_CTRL,\n\t\t\t\t 0x0020);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_AN, 0x0100);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x2040);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_10G_CTRL2,\n\t\t\t\t 0x0008);\n\t}\n}\n\nstatic void bnx2x_8727_config_init(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tu32 tx_en_mode;\n\tu16 tmp1, mod_abs, tmp2;\n\tstruct bnx2x *bp = params->bp;\n\t/* Enable PMD link, MOD_ABS_FLT, and 1G link alarm */\n\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\tDP(NETIF_MSG_LINK, \"Initializing BCM8727\\n\");\n\n\tbnx2x_8727_specific_func(phy, params, PHY_INIT);\n\t/* Initially configure MOD_ABS to interrupt when module is\n\t * presence( bit 8)\n\t */\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER, &mod_abs);\n\t/* Set EDC off by setting OPTXLOS signal input to low (bit 9).\n\t * When the EDC is off it locks onto a reference clock and avoids\n\t * becoming 'lost'\n\t */\n\tmod_abs &= ~(1<<8);\n\tif (!(phy->flags & FLAGS_NOC))\n\t\tmod_abs &= ~(1<<9);\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER, mod_abs);\n\n\t/* Enable/Disable PHY transmitter output */\n\tbnx2x_set_disable_pmd_transmit(params, phy, 0);\n\n\tbnx2x_8727_power_module(bp, phy, 1);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_M8051_MSGOUT_REG, &tmp1);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXSTAT, &tmp1);\n\n\tbnx2x_8727_config_speed(phy, params);\n\n\n\t/* Set TX PreEmphasis if needed */\n\tif ((params->feature_config_flags &\n\t     FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED)) {\n\t\tDP(NETIF_MSG_LINK, \"Setting TX_CTRL1 0x%x, TX_CTRL2 0x%x\\n\",\n\t\t\t   phy->tx_preemphasis[0],\n\t\t\t   phy->tx_preemphasis[1]);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_8727_TX_CTRL1,\n\t\t\t\t phy->tx_preemphasis[0]);\n\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_8727_TX_CTRL2,\n\t\t\t\t phy->tx_preemphasis[1]);\n\t}\n\n\t/* If TX Laser is controlled by GPIO_0, do not let PHY go into low\n\t * power mode, if TX Laser is disabled\n\t */\n\ttx_en_mode = REG_RD(bp, params->shmem_base +\n\t\t\t    offsetof(struct shmem_region,\n\t\t\t\tdev_info.port_hw_config[params->port].sfp_ctrl))\n\t\t\t& PORT_HW_CFG_TX_LASER_MASK;\n\n\tif (tx_en_mode == PORT_HW_CFG_TX_LASER_GPIO0) {\n\n\t\tDP(NETIF_MSG_LINK, \"Enabling TXONOFF_PWRDN_DIS\\n\");\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_8727_OPT_CFG_REG, &tmp2);\n\t\ttmp2 |= 0x1000;\n\t\ttmp2 &= 0xFFEF;\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_8727_OPT_CFG_REG, tmp2);\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER,\n\t\t\t\t&tmp2);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER,\n\t\t\t\t (tmp2 & 0x7fff));\n\t}\n}\n\nstatic void bnx2x_8727_handle_mod_abs(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 mod_abs, rx_alarm_status;\n\tu32 val = REG_RD(bp, params->shmem_base +\n\t\t\t     offsetof(struct shmem_region, dev_info.\n\t\t\t\t      port_feature_config[params->port].\n\t\t\t\t      config));\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_PHY_IDENTIFIER, &mod_abs);\n\tif (mod_abs & (1<<8)) {\n\n\t\t/* Module is absent */\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"MOD_ABS indication show module is absent\\n\");\n\t\tphy->media_type = ETH_PHY_NOT_PRESENT;\n\t\t/* 1. Set mod_abs to detect next module\n\t\t *    presence event\n\t\t * 2. Set EDC off by setting OPTXLOS signal input to low\n\t\t *    (bit 9).\n\t\t *    When the EDC is off it locks onto a reference clock and\n\t\t *    avoids becoming 'lost'.\n\t\t */\n\t\tmod_abs &= ~(1<<8);\n\t\tif (!(phy->flags & FLAGS_NOC))\n\t\t\tmod_abs &= ~(1<<9);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_PHY_IDENTIFIER, mod_abs);\n\n\t\t/* Clear RX alarm since it stays up as long as\n\t\t * the mod_abs wasn't changed\n\t\t */\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_LASI_RXSTAT, &rx_alarm_status);\n\n\t} else {\n\t\t/* Module is present */\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"MOD_ABS indication show module is present\\n\");\n\t\t/* First disable transmitter, and if the module is ok, the\n\t\t * module_detection will enable it\n\t\t * 1. Set mod_abs to detect next module absent event ( bit 8)\n\t\t * 2. Restore the default polarity of the OPRXLOS signal and\n\t\t * this signal will then correctly indicate the presence or\n\t\t * absence of the Rx signal. (bit 9)\n\t\t */\n\t\tmod_abs |= (1<<8);\n\t\tif (!(phy->flags & FLAGS_NOC))\n\t\t\tmod_abs |= (1<<9);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_PHY_IDENTIFIER, mod_abs);\n\n\t\t/* Clear RX alarm since it stays up as long as the mod_abs\n\t\t * wasn't changed. This is need to be done before calling the\n\t\t * module detection, otherwise it will clear* the link update\n\t\t * alarm\n\t\t */\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_LASI_RXSTAT, &rx_alarm_status);\n\n\n\t\tif ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) ==\n\t\t    PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_DISABLE_TX_LASER)\n\t\t\tbnx2x_sfp_set_transmitter(params, phy, 0);\n\n\t\tif (bnx2x_wait_for_sfp_module_initialized(phy, params) == 0)\n\t\t\tbnx2x_sfp_module_detection(phy, params);\n\t\telse\n\t\t\tDP(NETIF_MSG_LINK, \"SFP+ module is not initialized\\n\");\n\n\t\t/* Reconfigure link speed based on module type limitations */\n\t\tbnx2x_8727_config_speed(phy, params);\n\t}\n\n\tDP(NETIF_MSG_LINK, \"8727 RX_ALARM_STATUS 0x%x\\n\",\n\t\t   rx_alarm_status);\n\t/* No need to check link status in case of module plugged in/out */\n}\n\nstatic u8 bnx2x_8727_read_status(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params,\n\t\t\t\t struct link_vars *vars)\n\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 link_up = 0, oc_port = params->port;\n\tu16 link_status = 0;\n\tu16 rx_alarm_status, lasi_ctrl, val1;\n\n\t/* If PHY is not initialized, do not check link status */\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL,\n\t\t\t&lasi_ctrl);\n\tif (!lasi_ctrl)\n\t\treturn 0;\n\n\t/* Check the LASI on Rx */\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXSTAT,\n\t\t\t&rx_alarm_status);\n\tvars->line_speed = 0;\n\tDP(NETIF_MSG_LINK, \"8727 RX_ALARM_STATUS  0x%x\\n\", rx_alarm_status);\n\n\tbnx2x_sfp_mask_fault(bp, phy, MDIO_PMA_LASI_TXSTAT,\n\t\t\t     MDIO_PMA_LASI_TXCTRL);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val1);\n\n\tDP(NETIF_MSG_LINK, \"8727 LASI status 0x%x\\n\", val1);\n\n\t/* Clear MSG-OUT */\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_M8051_MSGOUT_REG, &val1);\n\n\t/* If a module is present and there is need to check\n\t * for over current\n\t */\n\tif (!(phy->flags & FLAGS_NOC) && !(rx_alarm_status & (1<<5))) {\n\t\t/* Check over-current using 8727 GPIO0 input*/\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_8727_GPIO_CTRL,\n\t\t\t\t&val1);\n\n\t\tif ((val1 & (1<<8)) == 0) {\n\t\t\tif (!CHIP_IS_E1x(bp))\n\t\t\t\toc_port = BP_PATH(bp) + (params->port << 1);\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"8727 Power fault has been detected on port %d\\n\",\n\t\t\t   oc_port);\n\t\t\tnetdev_err(bp->dev, \"Error: Power fault on Port %d has \"\n\t\t\t\t\t    \"been detected and the power to \"\n\t\t\t\t\t    \"that SFP+ module has been removed \"\n\t\t\t\t\t    \"to prevent failure of the card. \"\n\t\t\t\t\t    \"Please remove the SFP+ module and \"\n\t\t\t\t\t    \"restart the system to clear this \"\n\t\t\t\t\t    \"error.\\n\",\n\t\t\t oc_port);\n\t\t\t/* Disable all RX_ALARMs except for mod_abs */\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_LASI_RXCTRL, (1<<5));\n\n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_PHY_IDENTIFIER, &val1);\n\t\t\t/* Wait for module_absent_event */\n\t\t\tval1 |= (1<<8);\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_PHY_IDENTIFIER, val1);\n\t\t\t/* Clear RX alarm */\n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_LASI_RXSTAT, &rx_alarm_status);\n\t\t\tbnx2x_8727_power_module(params->bp, phy, 0);\n\t\t\treturn 0;\n\t\t}\n\t} /* Over current check */\n\n\t/* When module absent bit is set, check module */\n\tif (rx_alarm_status & (1<<5)) {\n\t\tbnx2x_8727_handle_mod_abs(phy, params);\n\t\t/* Enable all mod_abs and link detection bits */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL,\n\t\t\t\t ((1<<5) | (1<<2)));\n\t}\n\n\tif (!(phy->flags & FLAGS_SFP_NOT_APPROVED)) {\n\t\tDP(NETIF_MSG_LINK, \"Enabling 8727 TX laser\\n\");\n\t\tbnx2x_sfp_set_transmitter(params, phy, 1);\n\t} else {\n\t\tDP(NETIF_MSG_LINK, \"Tx is disabled\\n\");\n\t\treturn 0;\n\t}\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_8073_SPEED_LINK_STATUS, &link_status);\n\n\t/* Bits 0..2 --> speed detected,\n\t * Bits 13..15--> link is down\n\t */\n\tif ((link_status & (1<<2)) && (!(link_status & (1<<15)))) {\n\t\tlink_up = 1;\n\t\tvars->line_speed = SPEED_10000;\n\t\tDP(NETIF_MSG_LINK, \"port %x: External link up in 10G\\n\",\n\t\t\t   params->port);\n\t} else if ((link_status & (1<<0)) && (!(link_status & (1<<13)))) {\n\t\tlink_up = 1;\n\t\tvars->line_speed = SPEED_1000;\n\t\tDP(NETIF_MSG_LINK, \"port %x: External link up in 1G\\n\",\n\t\t\t   params->port);\n\t} else {\n\t\tlink_up = 0;\n\t\tDP(NETIF_MSG_LINK, \"port %x: External link is down\\n\",\n\t\t\t   params->port);\n\t}\n\n\t/* Capture 10G link fault. */\n\tif (vars->line_speed == SPEED_10000) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\n\t\t\t    MDIO_PMA_LASI_TXSTAT, &val1);\n\n\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\n\t\t\t    MDIO_PMA_LASI_TXSTAT, &val1);\n\n\t\tif (val1 & (1<<0)) {\n\t\t\tvars->fault_detected = 1;\n\t\t}\n\t}\n\n\tif (link_up) {\n\t\tbnx2x_ext_phy_resolve_fc(phy, params, vars);\n\t\tvars->duplex = DUPLEX_FULL;\n\t\tDP(NETIF_MSG_LINK, \"duplex = 0x%x\\n\", vars->duplex);\n\t}\n\n\tif ((DUAL_MEDIA(params)) &&\n\t    (phy->req_line_speed == SPEED_1000)) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_8727_PCS_GP, &val1);\n\t\t/* In case of dual-media board and 1G, power up the XAUI side,\n\t\t * otherwise power it down. For 10G it is done automatically\n\t\t */\n\t\tif (link_up)\n\t\t\tval1 &= ~(3<<10);\n\t\telse\n\t\t\tval1 |= (3<<10);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_8727_PCS_GP, val1);\n\t}\n\treturn link_up;\n}\n\nstatic void bnx2x_8727_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\t/* Enable/Disable PHY transmitter output */\n\tbnx2x_set_disable_pmd_transmit(params, phy, 1);\n\n\t/* Disable Transmitter */\n\tbnx2x_sfp_set_transmitter(params, phy, 0);\n\t/* Clear LASI */\n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 0);\n\n}\n\n/******************************************************************/\n/*\t\tBCM8481/BCM84823/BCM84833 PHY SECTION\t          */\n/******************************************************************/\nstatic int bnx2x_is_8483x_8485x(struct bnx2x_phy *phy)\n{\n\treturn ((phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833) ||\n\t\t(phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834) ||\n\t\t(phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858));\n}\n\nstatic void bnx2x_save_848xx_spirom_version(struct bnx2x_phy *phy,\n\t\t\t\t\t    struct bnx2x *bp,\n\t\t\t\t\t    u8 port)\n{\n\tu16 val, fw_ver2, cnt, i;\n\tstatic struct bnx2x_reg_set reg_set[] = {\n\t\t{MDIO_PMA_DEVAD, 0xA819, 0x0014},\n\t\t{MDIO_PMA_DEVAD, 0xA81A, 0xc200},\n\t\t{MDIO_PMA_DEVAD, 0xA81B, 0x0000},\n\t\t{MDIO_PMA_DEVAD, 0xA81C, 0x0300},\n\t\t{MDIO_PMA_DEVAD, 0xA817, 0x0009}\n\t};\n\tu16 fw_ver1;\n\n\tif (bnx2x_is_8483x_8485x(phy)) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD, 0x400f, &fw_ver1);\n\t\tif (phy->type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858)\n\t\t\tfw_ver1 &= 0xfff;\n\t\tbnx2x_save_spirom_version(bp, port, fw_ver1, phy->ver_addr);\n\t} else {\n\t\t/* For 32-bit registers in 848xx, access via MDIO2ARM i/f. */\n\t\t/* (1) set reg 0xc200_0014(SPI_BRIDGE_CTRL_2) to 0x03000000 */\n\t\tfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\n\t\t\tbnx2x_cl45_write(bp, phy, reg_set[i].devad,\n\t\t\t\t\t reg_set[i].reg, reg_set[i].val);\n\n\t\tfor (cnt = 0; cnt < 100; cnt++) {\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD, 0xA818, &val);\n\t\t\tif (val & 1)\n\t\t\t\tbreak;\n\t\t\tudelay(5);\n\t\t}\n\t\tif (cnt == 100) {\n\t\t\tDP(NETIF_MSG_LINK, \"Unable to read 848xx \"\n\t\t\t\t\t\"phy fw version(1)\\n\");\n\t\t\tbnx2x_save_spirom_version(bp, port, 0,\n\t\t\t\t\t\t  phy->ver_addr);\n\t\t\treturn;\n\t\t}\n\n\n\t\t/* 2) read register 0xc200_0000 (SPI_FW_STATUS) */\n\t\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, 0xA819, 0x0000);\n\t\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, 0xA81A, 0xc200);\n\t\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, 0xA817, 0x000A);\n\t\tfor (cnt = 0; cnt < 100; cnt++) {\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD, 0xA818, &val);\n\t\t\tif (val & 1)\n\t\t\t\tbreak;\n\t\t\tudelay(5);\n\t\t}\n\t\tif (cnt == 100) {\n\t\t\tDP(NETIF_MSG_LINK, \"Unable to read 848xx phy fw \"\n\t\t\t\t\t\"version(2)\\n\");\n\t\t\tbnx2x_save_spirom_version(bp, port, 0,\n\t\t\t\t\t\t  phy->ver_addr);\n\t\t\treturn;\n\t\t}\n\n\t\t/* lower 16 bits of the register SPI_FW_STATUS */\n\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD, 0xA81B, &fw_ver1);\n\t\t/* upper 16 bits of register SPI_FW_STATUS */\n\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD, 0xA81C, &fw_ver2);\n\n\t\tbnx2x_save_spirom_version(bp, port, (fw_ver2<<16) | fw_ver1,\n\t\t\t\t\t  phy->ver_addr);\n\t}\n\n}\nstatic void bnx2x_848xx_set_led(struct bnx2x *bp,\n\t\t\t\tstruct bnx2x_phy *phy)\n{\n\tu16 val, led3_blink_rate, offset, i;\n\tstatic struct bnx2x_reg_set reg_set[] = {\n\t\t{MDIO_PMA_DEVAD, MDIO_PMA_REG_8481_LED1_MASK, 0x0080},\n\t\t{MDIO_PMA_DEVAD, MDIO_PMA_REG_8481_LED2_MASK, 0x0018},\n\t\t{MDIO_PMA_DEVAD, MDIO_PMA_REG_8481_LED3_MASK, 0x0006},\n\t\t{MDIO_PMA_DEVAD, MDIO_PMA_REG_84823_CTL_SLOW_CLK_CNT_HIGH,\n\t\t\tMDIO_PMA_REG_84823_BLINK_RATE_VAL_15P9HZ},\n\t\t{MDIO_AN_DEVAD, 0xFFFB, 0xFFFD}\n\t};\n\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858) {\n\t\t/* Set LED5 source */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_8481_LED5_MASK,\n\t\t\t\t 0x90);\n\t\tled3_blink_rate = 0x000f;\n\t} else {\n\t\tled3_blink_rate = 0x0000;\n\t}\n\t/* Set LED3 BLINK */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_8481_LED3_BLINK,\n\t\t\t led3_blink_rate);\n\n\t/* PHYC_CTL_LED_CTL */\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_8481_LINK_SIGNAL, &val);\n\tval &= 0xFE00;\n\tval |= 0x0092;\n\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858)\n\t\tval |= 2 << 12; /* LED5 ON based on source */\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_8481_LINK_SIGNAL, val);\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\n\t\tbnx2x_cl45_write(bp, phy, reg_set[i].devad, reg_set[i].reg,\n\t\t\t\t reg_set[i].val);\n\n\tif (bnx2x_is_8483x_8485x(phy))\n\t\toffset = MDIO_PMA_REG_84833_CTL_LED_CTL_1;\n\telse\n\t\toffset = MDIO_PMA_REG_84823_CTL_LED_CTL_1;\n\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858)\n\t\tval = MDIO_PMA_REG_84858_ALLOW_GPHY_ACT |\n\t\t      MDIO_PMA_REG_84823_LED3_STRETCH_EN;\n\telse\n\t\tval = MDIO_PMA_REG_84823_LED3_STRETCH_EN;\n\n\t/* stretch_en for LEDs */\n\tbnx2x_cl45_read_or_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t offset,\n\t\t\t\t val);\n}\n\nstatic void bnx2x_848xx_specific_func(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params,\n\t\t\t\t      u32 action)\n{\n\tstruct bnx2x *bp = params->bp;\n\tswitch (action) {\n\tcase PHY_INIT:\n\t\tif (bnx2x_is_8483x_8485x(phy)) {\n\t\t\t/* Save spirom version */\n\t\t\tbnx2x_save_848xx_spirom_version(phy, bp, params->port);\n\t\t}\n\t\t/* This phy uses the NIG latch mechanism since link indication\n\t\t * arrives through its LED4 and not via its LASI signal, so we\n\t\t * get steady signal instead of clear on read\n\t\t */\n\t\tbnx2x_bits_en(bp, NIG_REG_LATCH_BC_0 + params->port*4,\n\t\t\t      1 << NIG_LATCH_BC_ENABLE_MI_INT);\n\n\t\tbnx2x_848xx_set_led(bp, phy);\n\t\tbreak;\n\t}\n}\n\nstatic int bnx2x_848xx_cmn_config_init(struct bnx2x_phy *phy,\n\t\t\t\t       struct link_params *params,\n\t\t\t\t       struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 autoneg_val, an_1000_val, an_10_100_val;\n\n\tbnx2x_848xx_specific_func(phy, params, PHY_INIT);\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x0000);\n\n\t/* set 1000 speed advertisement */\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_8481_1000T_CTRL,\n\t\t\t&an_1000_val);\n\n\tbnx2x_ext_phy_set_pause(params, phy, vars);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD,\n\t\t\tMDIO_AN_REG_8481_LEGACY_AN_ADV,\n\t\t\t&an_10_100_val);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_8481_LEGACY_MII_CTRL,\n\t\t\t&autoneg_val);\n\t/* Disable forced speed */\n\tautoneg_val &= ~((1<<6) | (1<<8) | (1<<9) | (1<<12) | (1<<13));\n\tan_10_100_val &= ~((1<<5) | (1<<6) | (1<<7) | (1<<8));\n\n\tif (((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t     (phy->speed_cap_mask &\n\t     PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)) ||\n\t    (phy->req_line_speed == SPEED_1000)) {\n\t\tan_1000_val |= (1<<8);\n\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\tif (phy->req_duplex == DUPLEX_FULL)\n\t\t\tan_1000_val |= (1<<9);\n\t\tDP(NETIF_MSG_LINK, \"Advertising 1G\\n\");\n\t} else\n\t\tan_1000_val &= ~((1<<8) | (1<<9));\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_8481_1000T_CTRL,\n\t\t\t an_1000_val);\n\n\t/* Set 10/100 speed advertisement */\n\tif (phy->req_line_speed == SPEED_AUTO_NEG) {\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL) {\n\t\t\t/* Enable autoneg and restart autoneg for legacy speeds\n\t\t\t */\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tan_10_100_val |= (1<<8);\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 100M-FD\\n\");\n\t\t}\n\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF) {\n\t\t\t/* Enable autoneg and restart autoneg for legacy speeds\n\t\t\t */\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tan_10_100_val |= (1<<7);\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 100M-HD\\n\");\n\t\t}\n\n\t\tif ((phy->speed_cap_mask &\n\t\t     PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL) &&\n\t\t    (phy->supported & SUPPORTED_10baseT_Full)) {\n\t\t\tan_10_100_val |= (1<<6);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 10M-FD\\n\");\n\t\t}\n\n\t\tif ((phy->speed_cap_mask &\n\t\t     PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF) &&\n\t\t    (phy->supported & SUPPORTED_10baseT_Half)) {\n\t\t\tan_10_100_val |= (1<<5);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 10M-HD\\n\");\n\t\t}\n\t}\n\n\t/* Only 10/100 are allowed to work in FORCE mode */\n\tif ((phy->req_line_speed == SPEED_100) &&\n\t    (phy->supported &\n\t     (SUPPORTED_100baseT_Half |\n\t      SUPPORTED_100baseT_Full))) {\n\t\tautoneg_val |= (1<<13);\n\t\t/* Enabled AUTO-MDIX when autoneg is disabled */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_8481_AUX_CTRL,\n\t\t\t\t (1<<15 | 1<<9 | 7<<0));\n\t\t/* The PHY needs this set even for forced link. */\n\t\tan_10_100_val |= (1<<8) | (1<<7);\n\t\tDP(NETIF_MSG_LINK, \"Setting 100M force\\n\");\n\t}\n\tif ((phy->req_line_speed == SPEED_10) &&\n\t    (phy->supported &\n\t     (SUPPORTED_10baseT_Half |\n\t      SUPPORTED_10baseT_Full))) {\n\t\t/* Enabled AUTO-MDIX when autoneg is disabled */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_8481_AUX_CTRL,\n\t\t\t\t (1<<15 | 1<<9 | 7<<0));\n\t\tDP(NETIF_MSG_LINK, \"Setting 10M force\\n\");\n\t}\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_8481_LEGACY_AN_ADV,\n\t\t\t an_10_100_val);\n\n\tif (phy->req_duplex == DUPLEX_FULL)\n\t\tautoneg_val |= (1<<8);\n\n\t/* Always write this if this is not 84833/4.\n\t * For 84833/4, write it only when it's a forced speed.\n\t */\n\tif (!bnx2x_is_8483x_8485x(phy) ||\n\t    ((autoneg_val & (1<<12)) == 0))\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_AN_DEVAD,\n\t\t\t MDIO_AN_REG_8481_LEGACY_MII_CTRL, autoneg_val);\n\n\tif (((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t    (phy->speed_cap_mask &\n\t     PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)) ||\n\t\t(phy->req_line_speed == SPEED_10000)) {\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 10G\\n\");\n\t\t\t/* Restart autoneg for 10G*/\n\n\t\t\tbnx2x_cl45_read_or_write(\n\t\t\t\tbp, phy,\n\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_8481_10GBASE_T_AN_CTRL,\n\t\t\t\t0x1000);\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CTRL,\n\t\t\t\t\t 0x3200);\n\t} else\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD,\n\t\t\t\t MDIO_AN_REG_8481_10GBASE_T_AN_CTRL,\n\t\t\t\t 1);\n\n\treturn 0;\n}\n\nstatic void bnx2x_8481_config_init(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\t/* Restore normal power mode*/\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH, params->port);\n\n\t/* HW reset */\n\tbnx2x_ext_phy_hw_reset(bp, params->port);\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 1<<15);\n\tbnx2x_848xx_cmn_config_init(phy, params, vars);\n}\n\n#define PHY848xx_CMDHDLR_WAIT 300\n#define PHY848xx_CMDHDLR_MAX_ARGS 5\n\nstatic int bnx2x_84858_cmd_hdlr(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params,\n\t\t\t\tu16 fw_cmd,\n\t\t\t\tu16 cmd_args[], int argc)\n{\n\tint idx;\n\tu16 val;\n\tstruct bnx2x *bp = params->bp;\n\n\t/* Step 1: Poll the STATUS register to see whether the previous command\n\t * is in progress or the system is busy (CMD_IN_PROGRESS or\n\t * SYSTEM_BUSY). If previous command is in progress or system is busy,\n\t * check again until the previous command finishes execution and the\n\t * system is available for taking command\n\t */\n\n\tfor (idx = 0; idx < PHY848xx_CMDHDLR_WAIT; idx++) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\tMDIO_848xx_CMD_HDLR_STATUS, &val);\n\t\tif ((val != PHY84858_STATUS_CMD_IN_PROGRESS) &&\n\t\t    (val != PHY84858_STATUS_CMD_SYSTEM_BUSY))\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\tif (idx >= PHY848xx_CMDHDLR_WAIT) {\n\t\tDP(NETIF_MSG_LINK, \"FW cmd: FW not ready.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Step2: If any parameters are required for the function, write them\n\t * to the required DATA registers\n\t */\n\n\tfor (idx = 0; idx < argc; idx++) {\n\t\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\t MDIO_848xx_CMD_HDLR_DATA1 + idx,\n\t\t\t\t cmd_args[idx]);\n\t}\n\n\t/* Step3: When the firmware is ready for commands, write the 'Command\n\t * code' to the CMD register\n\t */\n\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t MDIO_848xx_CMD_HDLR_COMMAND, fw_cmd);\n\n\t/* Step4: Once the command has been written, poll the STATUS register\n\t * to check whether the command has completed (CMD_COMPLETED_PASS/\n\t * CMD_FOR_CMDS or CMD_COMPLETED_ERROR).\n\t */\n\n\tfor (idx = 0; idx < PHY848xx_CMDHDLR_WAIT; idx++) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\tMDIO_848xx_CMD_HDLR_STATUS, &val);\n\t\tif ((val == PHY84858_STATUS_CMD_COMPLETE_PASS) ||\n\t\t    (val == PHY84858_STATUS_CMD_COMPLETE_ERROR))\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\tif ((idx >= PHY848xx_CMDHDLR_WAIT) ||\n\t    (val == PHY84858_STATUS_CMD_COMPLETE_ERROR)) {\n\t\tDP(NETIF_MSG_LINK, \"FW cmd failed.\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* Step5: Once the command has completed, read the specficied DATA\n\t * registers for any saved results for the command, if applicable\n\t */\n\n\t/* Gather returning data */\n\tfor (idx = 0; idx < argc; idx++) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\tMDIO_848xx_CMD_HDLR_DATA1 + idx,\n\t\t\t\t&cmd_args[idx]);\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_84833_cmd_hdlr(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params, u16 fw_cmd,\n\t\t\t\tu16 cmd_args[], int argc, int process)\n{\n\tint idx;\n\tu16 val;\n\tstruct bnx2x *bp = params->bp;\n\tint rc = 0;\n\n\tif (process == PHY84833_MB_PROCESS2) {\n\t\t/* Write CMD_OPEN_OVERRIDE to STATUS reg */\n\t\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\t MDIO_848xx_CMD_HDLR_STATUS,\n\t\t\t\t PHY84833_STATUS_CMD_OPEN_OVERRIDE);\n\t}\n\n\tfor (idx = 0; idx < PHY848xx_CMDHDLR_WAIT; idx++) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\tMDIO_848xx_CMD_HDLR_STATUS, &val);\n\t\tif (val == PHY84833_STATUS_CMD_OPEN_FOR_CMDS)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\tif (idx >= PHY848xx_CMDHDLR_WAIT) {\n\t\tDP(NETIF_MSG_LINK, \"FW cmd: FW not ready.\\n\");\n\t\t/* if the status is CMD_COMPLETE_PASS or CMD_COMPLETE_ERROR\n\t\t * clear the status to CMD_CLEAR_COMPLETE\n\t\t */\n\t\tif (val == PHY84833_STATUS_CMD_COMPLETE_PASS ||\n\t\t    val == PHY84833_STATUS_CMD_COMPLETE_ERROR) {\n\t\t\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\t\t MDIO_848xx_CMD_HDLR_STATUS,\n\t\t\t\t\t PHY84833_STATUS_CMD_CLEAR_COMPLETE);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\tif (process == PHY84833_MB_PROCESS1 ||\n\t    process == PHY84833_MB_PROCESS2) {\n\t\t/* Prepare argument(s) */\n\t\tfor (idx = 0; idx < argc; idx++) {\n\t\t\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\t\t MDIO_848xx_CMD_HDLR_DATA1 + idx,\n\t\t\t\t\t cmd_args[idx]);\n\t\t}\n\t}\n\n\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\tMDIO_848xx_CMD_HDLR_COMMAND, fw_cmd);\n\tfor (idx = 0; idx < PHY848xx_CMDHDLR_WAIT; idx++) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\tMDIO_848xx_CMD_HDLR_STATUS, &val);\n\t\tif ((val == PHY84833_STATUS_CMD_COMPLETE_PASS) ||\n\t\t    (val == PHY84833_STATUS_CMD_COMPLETE_ERROR))\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\tif ((idx >= PHY848xx_CMDHDLR_WAIT) ||\n\t    (val == PHY84833_STATUS_CMD_COMPLETE_ERROR)) {\n\t\tDP(NETIF_MSG_LINK, \"FW cmd failed.\\n\");\n\t\trc = -EINVAL;\n\t}\n\tif (process == PHY84833_MB_PROCESS3 && rc == 0) {\n\t\t/* Gather returning data */\n\t\tfor (idx = 0; idx < argc; idx++) {\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\t\tMDIO_848xx_CMD_HDLR_DATA1 + idx,\n\t\t\t\t\t&cmd_args[idx]);\n\t\t}\n\t}\n\tif (val == PHY84833_STATUS_CMD_COMPLETE_ERROR ||\n\t    val == PHY84833_STATUS_CMD_COMPLETE_PASS) {\n\t\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\t MDIO_848xx_CMD_HDLR_STATUS,\n\t\t\t\t PHY84833_STATUS_CMD_CLEAR_COMPLETE);\n\t}\n\treturn rc;\n}\n\nstatic int bnx2x_848xx_cmd_hdlr(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params,\n\t\t\t\tu16 fw_cmd,\n\t\t\t\t\t   u16 cmd_args[], int argc,\n\t\t\t\t\t   int process)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tif ((phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858) ||\n\t    (REG_RD(bp, params->shmem2_base +\n\t\t    offsetof(struct shmem2_region,\n\t\t\t     link_attr_sync[params->port])) &\n\t     LINK_ATTR_84858)) {\n\t\treturn bnx2x_84858_cmd_hdlr(phy, params, fw_cmd, cmd_args,\n\t\t\t\t\t    argc);\n\t} else {\n\t\treturn bnx2x_84833_cmd_hdlr(phy, params, fw_cmd, cmd_args,\n\t\t\t\t\t    argc, process);\n\t}\n}\n\nstatic int bnx2x_848xx_pair_swap_cfg(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params,\n\t\t\t\t     struct link_vars *vars)\n{\n\tu32 pair_swap;\n\tu16 data[PHY848xx_CMDHDLR_MAX_ARGS];\n\tint status;\n\tstruct bnx2x *bp = params->bp;\n\n\t/* Check for configuration. */\n\tpair_swap = REG_RD(bp, params->shmem_base +\n\t\t\t   offsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[params->port].xgbt_phy_cfg)) &\n\t\tPORT_HW_CFG_RJ45_PAIR_SWAP_MASK;\n\n\tif (pair_swap == 0)\n\t\treturn 0;\n\n\t/* Only the second argument is used for this command */\n\tdata[1] = (u16)pair_swap;\n\n\tstatus = bnx2x_848xx_cmd_hdlr(phy, params,\n\t\t\t\t      PHY848xx_CMD_SET_PAIR_SWAP, data,\n\t\t\t\t      2, PHY84833_MB_PROCESS2);\n\tif (status == 0)\n\t\tDP(NETIF_MSG_LINK, \"Pairswap OK, val=0x%x\\n\", data[1]);\n\n\treturn status;\n}\n\nstatic u8 bnx2x_84833_get_reset_gpios(struct bnx2x *bp,\n\t\t\t\t      u32 shmem_base_path[],\n\t\t\t\t      u32 chip_id)\n{\n\tu32 reset_pin[2];\n\tu32 idx;\n\tu8 reset_gpios;\n\tif (CHIP_IS_E3(bp)) {\n\t\t/* Assume that these will be GPIOs, not EPIOs. */\n\t\tfor (idx = 0; idx < 2; idx++) {\n\t\t\t/* Map config param to register bit. */\n\t\t\treset_pin[idx] = REG_RD(bp, shmem_base_path[idx] +\n\t\t\t\toffsetof(struct shmem_region,\n\t\t\t\tdev_info.port_hw_config[0].e3_cmn_pin_cfg));\n\t\t\treset_pin[idx] = (reset_pin[idx] &\n\t\t\t\tPORT_HW_CFG_E3_PHY_RESET_MASK) >>\n\t\t\t\tPORT_HW_CFG_E3_PHY_RESET_SHIFT;\n\t\t\treset_pin[idx] -= PIN_CFG_GPIO0_P0;\n\t\t\treset_pin[idx] = (1 << reset_pin[idx]);\n\t\t}\n\t\treset_gpios = (u8)(reset_pin[0] | reset_pin[1]);\n\t} else {\n\t\t/* E2, look from diff place of shmem. */\n\t\tfor (idx = 0; idx < 2; idx++) {\n\t\t\treset_pin[idx] = REG_RD(bp, shmem_base_path[idx] +\n\t\t\t\toffsetof(struct shmem_region,\n\t\t\t\tdev_info.port_hw_config[0].default_cfg));\n\t\t\treset_pin[idx] &= PORT_HW_CFG_EXT_PHY_GPIO_RST_MASK;\n\t\t\treset_pin[idx] -= PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO0_P0;\n\t\t\treset_pin[idx] >>= PORT_HW_CFG_EXT_PHY_GPIO_RST_SHIFT;\n\t\t\treset_pin[idx] = (1 << reset_pin[idx]);\n\t\t}\n\t\treset_gpios = (u8)(reset_pin[0] | reset_pin[1]);\n\t}\n\n\treturn reset_gpios;\n}\n\nstatic void bnx2x_84833_hw_reset_phy(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 reset_gpios;\n\tu32 other_shmem_base_addr = REG_RD(bp, params->shmem2_base +\n\t\t\t\toffsetof(struct shmem2_region,\n\t\t\t\tother_shmem_base_addr));\n\n\tu32 shmem_base_path[2];\n\n\t/* Work around for 84833 LED failure inside RESET status */\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\tMDIO_AN_REG_8481_LEGACY_MII_CTRL,\n\t\tMDIO_AN_REG_8481_MII_CTRL_FORCE_1G);\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\tMDIO_AN_REG_8481_1G_100T_EXT_CTRL,\n\t\tMIDO_AN_REG_8481_EXT_CTRL_FORCE_LEDS_OFF);\n\n\tshmem_base_path[0] = params->shmem_base;\n\tshmem_base_path[1] = other_shmem_base_addr;\n\n\treset_gpios = bnx2x_84833_get_reset_gpios(bp, shmem_base_path,\n\t\t\t\t\t\t  params->chip_id);\n\n\tbnx2x_set_mult_gpio(bp, reset_gpios, MISC_REGISTERS_GPIO_OUTPUT_LOW);\n\tudelay(10);\n\tDP(NETIF_MSG_LINK, \"84833 hw reset on pin values 0x%x\\n\",\n\t\treset_gpios);\n}\n\nstatic int bnx2x_8483x_disable_eee(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tint rc;\n\tstruct bnx2x *bp = params->bp;\n\tu16 cmd_args = 0;\n\n\tDP(NETIF_MSG_LINK, \"Don't Advertise 10GBase-T EEE\\n\");\n\n\t/* Prevent Phy from working in EEE and advertising it */\n\trc = bnx2x_848xx_cmd_hdlr(phy, params, PHY848xx_CMD_SET_EEE_MODE,\n\t\t\t\t  &cmd_args, 1, PHY84833_MB_PROCESS1);\n\tif (rc) {\n\t\tDP(NETIF_MSG_LINK, \"EEE disable failed.\\n\");\n\t\treturn rc;\n\t}\n\n\treturn bnx2x_eee_disable(phy, params, vars);\n}\n\nstatic int bnx2x_8483x_enable_eee(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tint rc;\n\tstruct bnx2x *bp = params->bp;\n\tu16 cmd_args = 1;\n\n\trc = bnx2x_848xx_cmd_hdlr(phy, params, PHY848xx_CMD_SET_EEE_MODE,\n\t\t\t\t  &cmd_args, 1, PHY84833_MB_PROCESS1);\n\tif (rc) {\n\t\tDP(NETIF_MSG_LINK, \"EEE enable failed.\\n\");\n\t\treturn rc;\n\t}\n\n\treturn bnx2x_eee_advertise(phy, params, vars, SHMEM_EEE_10G_ADV);\n}\n\n#define PHY84833_CONSTANT_LATENCY 1193\nstatic void bnx2x_848x3_config_init(struct bnx2x_phy *phy,\n\t\t\t\t    struct link_params *params,\n\t\t\t\t    struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port, initialize = 1;\n\tu16 val;\n\tu32 actual_phy_selection;\n\tu16 cmd_args[PHY848xx_CMDHDLR_MAX_ARGS];\n\tint rc = 0;\n\n\tusleep_range(1000, 2000);\n\n\tif (!(CHIP_IS_E1x(bp)))\n\t\tport = BP_PATH(bp);\n\telse\n\t\tport = params->port;\n\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823) {\n\t\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_3,\n\t\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH,\n\t\t\t       port);\n\t} else {\n\t\t/* MDIO reset */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_CTRL, 0x8000);\n\t}\n\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\t/* Wait for GPHY to come out of reset */\n\tmsleep(50);\n\tif (!bnx2x_is_8483x_8485x(phy)) {\n\t\t/* BCM84823 requires that XGXS links up first @ 10G for normal\n\t\t * behavior.\n\t\t */\n\t\tu16 temp;\n\t\ttemp = vars->line_speed;\n\t\tvars->line_speed = SPEED_10000;\n\t\tbnx2x_set_autoneg(&params->phy[INT_PHY], params, vars, 0);\n\t\tbnx2x_program_serdes(&params->phy[INT_PHY], params, vars);\n\t\tvars->line_speed = temp;\n\t}\n\t/* Check if this is actually BCM84858 */\n\tif (phy->type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858) {\n\t\tu16 hw_rev;\n\n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_848xx_ID_MSB, &hw_rev);\n\t\tif (hw_rev == BCM84858_PHY_ID) {\n\t\t\tparams->link_attr_sync |= LINK_ATTR_84858;\n\t\t\tbnx2x_update_link_attr(params, params->link_attr_sync);\n\t\t}\n\t}\n\n\t/* Set dual-media configuration according to configuration */\n\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\tMDIO_CTL_REG_84823_MEDIA, &val);\n\tval &= ~(MDIO_CTL_REG_84823_MEDIA_MAC_MASK |\n\t\t MDIO_CTL_REG_84823_MEDIA_LINE_MASK |\n\t\t MDIO_CTL_REG_84823_MEDIA_COPPER_CORE_DOWN |\n\t\t MDIO_CTL_REG_84823_MEDIA_PRIORITY_MASK |\n\t\t MDIO_CTL_REG_84823_MEDIA_FIBER_1G);\n\n\tif (CHIP_IS_E3(bp)) {\n\t\tval &= ~(MDIO_CTL_REG_84823_MEDIA_MAC_MASK |\n\t\t\t MDIO_CTL_REG_84823_MEDIA_LINE_MASK);\n\t} else {\n\t\tval |= (MDIO_CTL_REG_84823_CTRL_MAC_XFI |\n\t\t\tMDIO_CTL_REG_84823_MEDIA_LINE_XAUI_L);\n\t}\n\n\tactual_phy_selection = bnx2x_phy_selection(params);\n\n\tswitch (actual_phy_selection) {\n\tcase PORT_HW_CFG_PHY_SELECTION_HARDWARE_DEFAULT:\n\t\t/* Do nothing. Essentially this is like the priority copper */\n\t\tbreak;\n\tcase PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY:\n\t\tval |= MDIO_CTL_REG_84823_MEDIA_PRIORITY_COPPER;\n\t\tbreak;\n\tcase PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY:\n\t\tval |= MDIO_CTL_REG_84823_MEDIA_PRIORITY_FIBER;\n\t\tbreak;\n\tcase PORT_HW_CFG_PHY_SELECTION_FIRST_PHY:\n\t\t/* Do nothing here. The first PHY won't be initialized at all */\n\t\tbreak;\n\tcase PORT_HW_CFG_PHY_SELECTION_SECOND_PHY:\n\t\tval |= MDIO_CTL_REG_84823_MEDIA_COPPER_CORE_DOWN;\n\t\tinitialize = 0;\n\t\tbreak;\n\t}\n\tif (params->phy[EXT_PHY2].req_line_speed == SPEED_1000)\n\t\tval |= MDIO_CTL_REG_84823_MEDIA_FIBER_1G;\n\n\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t MDIO_CTL_REG_84823_MEDIA, val);\n\tDP(NETIF_MSG_LINK, \"Multi_phy config = 0x%x, Media control = 0x%x\\n\",\n\t\t   params->multi_phy_config, val);\n\n\tif (bnx2x_is_8483x_8485x(phy)) {\n\t\tbnx2x_848xx_pair_swap_cfg(phy, params, vars);\n\n\t\t/* Keep AutogrEEEn disabled. */\n\t\tcmd_args[0] = 0x0;\n\t\tcmd_args[1] = 0x0;\n\t\tcmd_args[2] = PHY84833_CONSTANT_LATENCY + 1;\n\t\tcmd_args[3] = PHY84833_CONSTANT_LATENCY;\n\t\trc = bnx2x_848xx_cmd_hdlr(phy, params,\n\t\t\t\t\t  PHY848xx_CMD_SET_EEE_MODE, cmd_args,\n\t\t\t\t\t  4, PHY84833_MB_PROCESS1);\n\t\tif (rc)\n\t\t\tDP(NETIF_MSG_LINK, \"Cfg AutogrEEEn failed.\\n\");\n\t}\n\tif (initialize)\n\t\trc = bnx2x_848xx_cmn_config_init(phy, params, vars);\n\telse\n\t\tbnx2x_save_848xx_spirom_version(phy, bp, params->port);\n\t/* 84833 PHY has a better feature and doesn't need to support this. */\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823) {\n\t\tu32 cms_enable = REG_RD(bp, params->shmem_base +\n\t\t\toffsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[params->port].default_cfg)) &\n\t\t\tPORT_HW_CFG_ENABLE_CMS_MASK;\n\n\t\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\tMDIO_CTL_REG_84823_USER_CTRL_REG, &val);\n\t\tif (cms_enable)\n\t\t\tval |= MDIO_CTL_REG_84823_USER_CTRL_CMS;\n\t\telse\n\t\t\tval &= ~MDIO_CTL_REG_84823_USER_CTRL_CMS;\n\t\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\t MDIO_CTL_REG_84823_USER_CTRL_REG, val);\n\t}\n\n\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\tMDIO_84833_TOP_CFG_FW_REV, &val);\n\n\t/* Configure EEE support */\n\tif ((val >= MDIO_84833_TOP_CFG_FW_EEE) &&\n\t    (val != MDIO_84833_TOP_CFG_FW_NO_EEE) &&\n\t    bnx2x_eee_has_cap(params)) {\n\t\trc = bnx2x_eee_initial_config(params, vars, SHMEM_EEE_10G_ADV);\n\t\tif (rc) {\n\t\t\tDP(NETIF_MSG_LINK, \"Failed to configure EEE timers\\n\");\n\t\t\tbnx2x_8483x_disable_eee(phy, params, vars);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((phy->req_duplex == DUPLEX_FULL) &&\n\t\t    (params->eee_mode & EEE_MODE_ADV_LPI) &&\n\t\t    (bnx2x_eee_calc_timer(params) ||\n\t\t     !(params->eee_mode & EEE_MODE_ENABLE_LPI)))\n\t\t\trc = bnx2x_8483x_enable_eee(phy, params, vars);\n\t\telse\n\t\t\trc = bnx2x_8483x_disable_eee(phy, params, vars);\n\t\tif (rc) {\n\t\t\tDP(NETIF_MSG_LINK, \"Failed to set EEE advertisement\\n\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tvars->eee_status &= ~SHMEM_EEE_SUPPORTED_MASK;\n\t}\n\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833) {\n\t\t/* Additional settings for jumbo packets in 1000BASE-T mode */\n\t\t/* Allow rx extended length */\n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_8481_AUX_CTRL, &val);\n\t\tval |= 0x4000;\n\t\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t MDIO_AN_REG_8481_AUX_CTRL, val);\n\t\t/* TX FIFO Elasticity LSB */\n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_8481_1G_100T_EXT_CTRL, &val);\n\t\tval |= 0x1;\n\t\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t MDIO_AN_REG_8481_1G_100T_EXT_CTRL, val);\n\t\t/* TX FIFO Elasticity MSB */\n\t\t/* Enable expansion register 0x46 (Pattern Generator status) */\n\t\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t MDIO_AN_REG_8481_EXPANSION_REG_ACCESS, 0xf46);\n\n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_8481_EXPANSION_REG_RD_RW, &val);\n\t\tval |= 0x4000;\n\t\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t MDIO_AN_REG_8481_EXPANSION_REG_RD_RW, val);\n\t}\n\n\tif (bnx2x_is_8483x_8485x(phy)) {\n\t\t/* Bring PHY out of super isolate mode as the final step. */\n\t\tbnx2x_cl45_read_and_write(bp, phy,\n\t\t\t\t\t  MDIO_CTL_DEVAD,\n\t\t\t\t\t  MDIO_84833_TOP_CFG_XGPHY_STRAP1,\n\t\t\t\t\t  (u16)~MDIO_84833_SUPER_ISOLATE);\n\t}\n}\n\nstatic u8 bnx2x_848xx_read_status(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params,\n\t\t\t\t  struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val, val1, val2;\n\tu8 link_up = 0;\n\n\n\t/* Check 10G-BaseT link status */\n\t/* Check PMD signal ok */\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, 0xFFFA, &val1);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_8481_PMD_SIGNAL,\n\t\t\t&val2);\n\tDP(NETIF_MSG_LINK, \"BCM848xx: PMD_SIGNAL 1.a811 = 0x%x\\n\", val2);\n\n\t/* Check link 10G */\n\tif (val2 & (1<<11)) {\n\t\tvars->line_speed = SPEED_10000;\n\t\tvars->duplex = DUPLEX_FULL;\n\t\tlink_up = 1;\n\t\tbnx2x_ext_phy_10G_an_resolve(bp, phy, vars);\n\t} else { /* Check Legacy speed link */\n\t\tu16 legacy_status, legacy_speed;\n\n\t\t/* Enable expansion register 0x42 (Operation mode status) */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD,\n\t\t\t\t MDIO_AN_REG_8481_EXPANSION_REG_ACCESS, 0xf42);\n\n\t\t/* Get legacy speed operation status */\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_8481_EXPANSION_REG_RD_RW,\n\t\t\t\t&legacy_status);\n\n\t\tDP(NETIF_MSG_LINK, \"Legacy speed status = 0x%x\\n\",\n\t\t   legacy_status);\n\t\tlink_up = ((legacy_status & (1<<11)) == (1<<11));\n\t\tlegacy_speed = (legacy_status & (3<<9));\n\t\tif (legacy_speed == (0<<9))\n\t\t\tvars->line_speed = SPEED_10;\n\t\telse if (legacy_speed == (1<<9))\n\t\t\tvars->line_speed = SPEED_100;\n\t\telse if (legacy_speed == (2<<9))\n\t\t\tvars->line_speed = SPEED_1000;\n\t\telse { /* Should not happen: Treat as link down */\n\t\t\tvars->line_speed = 0;\n\t\t\tlink_up = 0;\n\t\t}\n\n\t\tif (link_up) {\n\t\t\tif (legacy_status & (1<<8))\n\t\t\t\tvars->duplex = DUPLEX_FULL;\n\t\t\telse\n\t\t\t\tvars->duplex = DUPLEX_HALF;\n\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"Link is up in %dMbps, is_duplex_full= %d\\n\",\n\t\t\t   vars->line_speed,\n\t\t\t   (vars->duplex == DUPLEX_FULL));\n\t\t\t/* Check legacy speed AN resolution */\n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_AN_REG_8481_LEGACY_MII_STATUS,\n\t\t\t\t\t&val);\n\t\t\tif (val & (1<<5))\n\t\t\t\tvars->link_status |=\n\t\t\t\t\tLINK_STATUS_AUTO_NEGOTIATE_COMPLETE;\n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_AN_REG_8481_LEGACY_AN_EXPANSION,\n\t\t\t\t\t&val);\n\t\t\tif ((val & (1<<0)) == 0)\n\t\t\t\tvars->link_status |=\n\t\t\t\t\tLINK_STATUS_PARALLEL_DETECTION_USED;\n\t\t}\n\t}\n\tif (link_up) {\n\t\tDP(NETIF_MSG_LINK, \"BCM848x3: link speed is %d\\n\",\n\t\t\t   vars->line_speed);\n\t\tbnx2x_ext_phy_resolve_fc(phy, params, vars);\n\n\t\t/* Read LP advertised speeds */\n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_CL37_FC_LP, &val);\n\t\tif (val & (1<<5))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10THD_CAPABLE;\n\t\tif (val & (1<<6))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10TFD_CAPABLE;\n\t\tif (val & (1<<7))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_100TXHD_CAPABLE;\n\t\tif (val & (1<<8))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_100TXFD_CAPABLE;\n\t\tif (val & (1<<9))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_100T4_CAPABLE;\n\n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_1000T_STATUS, &val);\n\n\t\tif (val & (1<<10))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_1000THD_CAPABLE;\n\t\tif (val & (1<<11))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE;\n\n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_MASTER_STATUS, &val);\n\n\t\tif (val & (1<<11))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\n\n\t\t/* Determine if EEE was negotiated */\n\t\tif (bnx2x_is_8483x_8485x(phy))\n\t\t\tbnx2x_eee_an_resolve(phy, params, vars);\n\t}\n\n\treturn link_up;\n}\n\nstatic int bnx2x_8485x_format_ver(u32 raw_ver, u8 *str, u16 *len)\n{\n\tu32 num;\n\n\tnum = ((raw_ver & 0xF80) >> 7) << 16 | ((raw_ver & 0x7F) << 8) |\n\t      ((raw_ver & 0xF000) >> 12);\n\treturn bnx2x_3_seq_format_ver(num, str, len);\n}\n\nstatic int bnx2x_848xx_format_ver(u32 raw_ver, u8 *str, u16 *len)\n{\n\tu32 spirom_ver;\n\n\tspirom_ver = ((raw_ver & 0xF80) >> 7) << 16 | (raw_ver & 0x7F);\n\treturn bnx2x_format_ver(spirom_ver, str, len);\n}\n\nstatic void bnx2x_8481_hw_reset(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params)\n{\n\tbnx2x_set_gpio(params->bp, MISC_REGISTERS_GPIO_1,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW, 0);\n\tbnx2x_set_gpio(params->bp, MISC_REGISTERS_GPIO_1,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW, 1);\n}\n\nstatic void bnx2x_8481_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t\tstruct link_params *params)\n{\n\tbnx2x_cl45_write(params->bp, phy,\n\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0x0000);\n\tbnx2x_cl45_write(params->bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 1);\n}\n\nstatic void bnx2x_848x3_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port;\n\tu16 val16;\n\n\tif (!(CHIP_IS_E1x(bp)))\n\t\tport = BP_PATH(bp);\n\telse\n\t\tport = params->port;\n\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823) {\n\t\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_3,\n\t\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW,\n\t\t\t       port);\n\t} else {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_CTL_DEVAD,\n\t\t\t\tMDIO_84833_TOP_CFG_XGPHY_STRAP1, &val16);\n\t\tval16 |= MDIO_84833_SUPER_ISOLATE;\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_CTL_DEVAD,\n\t\t\t\t MDIO_84833_TOP_CFG_XGPHY_STRAP1, val16);\n\t}\n}\n\nstatic void bnx2x_848xx_set_link_led(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params, u8 mode)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val;\n\tu8 port;\n\n\tif (!(CHIP_IS_E1x(bp)))\n\t\tport = BP_PATH(bp);\n\telse\n\t\tport = params->port;\n\n\tswitch (mode) {\n\tcase LED_MODE_OFF:\n\n\t\tDP(NETIF_MSG_LINK, \"Port 0x%x: LED MODE OFF\\n\", port);\n\n\t\tif ((params->hw_led_mode << SHARED_HW_CFG_LED_MODE_SHIFT) ==\n\t\t    SHARED_HW_CFG_LED_EXTPHY1) {\n\n\t\t\t/* Set LED masks */\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8481_LED1_MASK,\n\t\t\t\t\t0x0);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8481_LED2_MASK,\n\t\t\t\t\t0x0);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8481_LED3_MASK,\n\t\t\t\t\t0x0);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8481_LED5_MASK,\n\t\t\t\t\t0x0);\n\n\t\t} else {\n\t\t\t/* LED 1 OFF */\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED1_MASK,\n\t\t\t\t\t 0x0);\n\n\t\t\tif (phy->type ==\n\t\t\t\tPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858) {\n\t\t\t\t/* LED 2 OFF */\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LED2_MASK,\n\t\t\t\t\t\t 0x0);\n\t\t\t\t/* LED 3 OFF */\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LED3_MASK,\n\t\t\t\t\t\t 0x0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase LED_MODE_FRONT_PANEL_OFF:\n\n\t\tDP(NETIF_MSG_LINK, \"Port 0x%x: LED MODE FRONT PANEL OFF\\n\",\n\t\t   port);\n\n\t\tif ((params->hw_led_mode << SHARED_HW_CFG_LED_MODE_SHIFT) ==\n\t\t    SHARED_HW_CFG_LED_EXTPHY1) {\n\n\t\t\t/* Set LED masks */\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED1_MASK,\n\t\t\t\t\t 0x0);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED2_MASK,\n\t\t\t\t\t 0x0);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED3_MASK,\n\t\t\t\t\t 0x0);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED5_MASK,\n\t\t\t\t\t 0x20);\n\n\t\t} else {\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED1_MASK,\n\t\t\t\t\t 0x0);\n\t\t\tif (phy->type ==\n\t\t\t    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834) {\n\t\t\t\t/* Disable MI_INT interrupt before setting LED4\n\t\t\t\t * source to constant off.\n\t\t\t\t */\n\t\t\t\tif (REG_RD(bp, NIG_REG_MASK_INTERRUPT_PORT0 +\n\t\t\t\t\t   params->port*4) &\n\t\t\t\t    NIG_MASK_MI_INT) {\n\t\t\t\t\tparams->link_flags |=\n\t\t\t\t\tLINK_FLAGS_INT_DISABLED;\n\n\t\t\t\t\tbnx2x_bits_dis(\n\t\t\t\t\t\tbp,\n\t\t\t\t\t\tNIG_REG_MASK_INTERRUPT_PORT0 +\n\t\t\t\t\t\tparams->port*4,\n\t\t\t\t\t\tNIG_MASK_MI_INT);\n\t\t\t\t}\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_SIGNAL_MASK,\n\t\t\t\t\t\t 0x0);\n\t\t\t}\n\t\t\tif (phy->type ==\n\t\t\t\tPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858) {\n\t\t\t\t/* LED 2 OFF */\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LED2_MASK,\n\t\t\t\t\t\t 0x0);\n\t\t\t\t/* LED 3 OFF */\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LED3_MASK,\n\t\t\t\t\t\t 0x0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase LED_MODE_ON:\n\n\t\tDP(NETIF_MSG_LINK, \"Port 0x%x: LED MODE ON\\n\", port);\n\n\t\tif ((params->hw_led_mode << SHARED_HW_CFG_LED_MODE_SHIFT) ==\n\t\t    SHARED_HW_CFG_LED_EXTPHY1) {\n\t\t\t/* Set control reg */\n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8481_LINK_SIGNAL,\n\t\t\t\t\t&val);\n\t\t\tval &= 0x8000;\n\t\t\tval |= 0x2492;\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LINK_SIGNAL,\n\t\t\t\t\t val);\n\n\t\t\t/* Set LED masks */\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED1_MASK,\n\t\t\t\t\t 0x0);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED2_MASK,\n\t\t\t\t\t 0x20);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED3_MASK,\n\t\t\t\t\t 0x20);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED5_MASK,\n\t\t\t\t\t 0x0);\n\t\t} else {\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED1_MASK,\n\t\t\t\t\t 0x20);\n\t\t\tif (phy->type ==\n\t\t\t    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834) {\n\t\t\t\t/* Disable MI_INT interrupt before setting LED4\n\t\t\t\t * source to constant on.\n\t\t\t\t */\n\t\t\t\tif (REG_RD(bp, NIG_REG_MASK_INTERRUPT_PORT0 +\n\t\t\t\t\t   params->port*4) &\n\t\t\t\t    NIG_MASK_MI_INT) {\n\t\t\t\t\tparams->link_flags |=\n\t\t\t\t\tLINK_FLAGS_INT_DISABLED;\n\n\t\t\t\t\tbnx2x_bits_dis(\n\t\t\t\t\t\tbp,\n\t\t\t\t\t\tNIG_REG_MASK_INTERRUPT_PORT0 +\n\t\t\t\t\t\tparams->port*4,\n\t\t\t\t\t\tNIG_MASK_MI_INT);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (phy->type ==\n\t\t\t    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858) {\n\t\t\t\t/* Tell LED3 to constant on */\n\t\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\t\tMDIO_PMA_REG_8481_LINK_SIGNAL,\n\t\t\t\t\t\t&val);\n\t\t\t\tval &= ~(7<<6);\n\t\t\t\tval |= (2<<6);  /* A83B[8:6]= 2 */\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LINK_SIGNAL,\n\t\t\t\t\t\t val);\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LED3_MASK,\n\t\t\t\t\t\t 0x20);\n\t\t\t} else {\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_SIGNAL_MASK,\n\t\t\t\t\t\t 0x20);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase LED_MODE_OPER:\n\n\t\tDP(NETIF_MSG_LINK, \"Port 0x%x: LED MODE OPER\\n\", port);\n\n\t\tif ((params->hw_led_mode << SHARED_HW_CFG_LED_MODE_SHIFT) ==\n\t\t    SHARED_HW_CFG_LED_EXTPHY1) {\n\n\t\t\t/* Set control reg */\n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8481_LINK_SIGNAL,\n\t\t\t\t\t&val);\n\n\t\t\tif (!((val &\n\t\t\t       MDIO_PMA_REG_8481_LINK_SIGNAL_LED4_ENABLE_MASK)\n\t\t\t  >> MDIO_PMA_REG_8481_LINK_SIGNAL_LED4_ENABLE_SHIFT)) {\n\t\t\t\tDP(NETIF_MSG_LINK, \"Setting LINK_SIGNAL\\n\");\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LINK_SIGNAL,\n\t\t\t\t\t\t 0xa492);\n\t\t\t}\n\n\t\t\t/* Set LED masks */\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED1_MASK,\n\t\t\t\t\t 0x10);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED2_MASK,\n\t\t\t\t\t 0x80);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED3_MASK,\n\t\t\t\t\t 0x98);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED5_MASK,\n\t\t\t\t\t 0x40);\n\n\t\t} else {\n\t\t\t/* EXTPHY2 LED mode indicate that the 100M/1G/10G LED\n\t\t\t * sources are all wired through LED1, rather than only\n\t\t\t * 10G in other modes.\n\t\t\t */\n\t\t\tval = ((params->hw_led_mode <<\n\t\t\t\tSHARED_HW_CFG_LED_MODE_SHIFT) ==\n\t\t\t       SHARED_HW_CFG_LED_EXTPHY2) ? 0x98 : 0x80;\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED1_MASK,\n\t\t\t\t\t val);\n\n\t\t\t/* Tell LED3 to blink on source */\n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8481_LINK_SIGNAL,\n\t\t\t\t\t&val);\n\t\t\tval &= ~(7<<6);\n\t\t\tval |= (1<<6); /* A83B[8:6]= 1 */\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LINK_SIGNAL,\n\t\t\t\t\t val);\n\t\t\tif (phy->type ==\n\t\t\t    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858) {\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LED2_MASK,\n\t\t\t\t\t\t 0x18);\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LED3_MASK,\n\t\t\t\t\t\t 0x06);\n\t\t\t}\n\t\t\tif (phy->type ==\n\t\t\t    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834) {\n\t\t\t\t/* Restore LED4 source to external link,\n\t\t\t\t * and re-enable interrupts.\n\t\t\t\t */\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_SIGNAL_MASK,\n\t\t\t\t\t\t 0x40);\n\t\t\t\tif (params->link_flags &\n\t\t\t\t    LINK_FLAGS_INT_DISABLED) {\n\t\t\t\t\tbnx2x_link_int_enable(params);\n\t\t\t\t\tparams->link_flags &=\n\t\t\t\t\t\t~LINK_FLAGS_INT_DISABLED;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* This is a workaround for E3+84833 until autoneg\n\t * restart is fixed in f/w\n\t */\n\tif (CHIP_IS_E3(bp)) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_GP2_STATUS_GP_2_1, &val);\n\t}\n}\n\n/******************************************************************/\n/*\t\t\t54618SE PHY SECTION\t\t\t  */\n/******************************************************************/\nstatic void bnx2x_54618se_specific_func(struct bnx2x_phy *phy,\n\t\t\t\t\tstruct link_params *params,\n\t\t\t\t\tu32 action)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 temp;\n\tswitch (action) {\n\tcase PHY_INIT:\n\t\t/* Configure LED4: set to INTR (0x6). */\n\t\t/* Accessing shadow register 0xe. */\n\t\tbnx2x_cl22_write(bp, phy,\n\t\t\t\t MDIO_REG_GPHY_SHADOW,\n\t\t\t\t MDIO_REG_GPHY_SHADOW_LED_SEL2);\n\t\tbnx2x_cl22_read(bp, phy,\n\t\t\t\tMDIO_REG_GPHY_SHADOW,\n\t\t\t\t&temp);\n\t\ttemp &= ~(0xf << 4);\n\t\ttemp |= (0x6 << 4);\n\t\tbnx2x_cl22_write(bp, phy,\n\t\t\t\t MDIO_REG_GPHY_SHADOW,\n\t\t\t\t MDIO_REG_GPHY_SHADOW_WR_ENA | temp);\n\t\t/* Configure INTR based on link status change. */\n\t\tbnx2x_cl22_write(bp, phy,\n\t\t\t\t MDIO_REG_INTR_MASK,\n\t\t\t\t ~MDIO_REG_INTR_MASK_LINK_STATUS);\n\t\tbreak;\n\t}\n}\n\nstatic void bnx2x_54618se_config_init(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params,\n\t\t\t\t      struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port;\n\tu16 autoneg_val, an_1000_val, an_10_100_val, fc_val, temp;\n\tu32 cfg_pin;\n\n\tDP(NETIF_MSG_LINK, \"54618SE cfg init\\n\");\n\tusleep_range(1000, 2000);\n\n\t/* This works with E3 only, no need to check the chip\n\t * before determining the port.\n\t */\n\tport = params->port;\n\n\tcfg_pin = (REG_RD(bp, params->shmem_base +\n\t\t\toffsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[port].e3_cmn_pin_cfg)) &\n\t\t\tPORT_HW_CFG_E3_PHY_RESET_MASK) >>\n\t\t\tPORT_HW_CFG_E3_PHY_RESET_SHIFT;\n\n\t/* Drive pin high to bring the GPHY out of reset. */\n\tbnx2x_set_cfg_pin(bp, cfg_pin, 1);\n\n\t/* wait for GPHY to reset */\n\tmsleep(50);\n\n\t/* reset phy */\n\tbnx2x_cl22_write(bp, phy,\n\t\t\t MDIO_PMA_REG_CTRL, 0x8000);\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\t/* Wait for GPHY to reset */\n\tmsleep(50);\n\n\n\tbnx2x_54618se_specific_func(phy, params, PHY_INIT);\n\t/* Flip the signal detect polarity (set 0x1c.0x1e[8]). */\n\tbnx2x_cl22_write(bp, phy,\n\t\t\tMDIO_REG_GPHY_SHADOW,\n\t\t\tMDIO_REG_GPHY_SHADOW_AUTO_DET_MED);\n\tbnx2x_cl22_read(bp, phy,\n\t\t\tMDIO_REG_GPHY_SHADOW,\n\t\t\t&temp);\n\ttemp |= MDIO_REG_GPHY_SHADOW_INVERT_FIB_SD;\n\tbnx2x_cl22_write(bp, phy,\n\t\t\tMDIO_REG_GPHY_SHADOW,\n\t\t\tMDIO_REG_GPHY_SHADOW_WR_ENA | temp);\n\n\t/* Set up fc */\n\t/* Please refer to Table 28B-3 of 802.3ab-1999 spec. */\n\tbnx2x_calc_ieee_aneg_adv(phy, params, &vars->ieee_fc);\n\tfc_val = 0;\n\tif ((vars->ieee_fc & MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) ==\n\t\t\tMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC)\n\t\tfc_val |= MDIO_AN_REG_ADV_PAUSE_ASYMMETRIC;\n\n\tif ((vars->ieee_fc & MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) ==\n\t\t\tMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH)\n\t\tfc_val |= MDIO_AN_REG_ADV_PAUSE_PAUSE;\n\n\t/* Read all advertisement */\n\tbnx2x_cl22_read(bp, phy,\n\t\t\t0x09,\n\t\t\t&an_1000_val);\n\n\tbnx2x_cl22_read(bp, phy,\n\t\t\t0x04,\n\t\t\t&an_10_100_val);\n\n\tbnx2x_cl22_read(bp, phy,\n\t\t\tMDIO_PMA_REG_CTRL,\n\t\t\t&autoneg_val);\n\n\t/* Disable forced speed */\n\tautoneg_val &= ~((1<<6) | (1<<8) | (1<<9) | (1<<12) | (1<<13));\n\tan_10_100_val &= ~((1<<5) | (1<<6) | (1<<7) | (1<<8) | (1<<10) |\n\t\t\t   (1<<11));\n\n\tif (((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t     (phy->speed_cap_mask &\n\t      PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)) ||\n\t    (phy->req_line_speed == SPEED_1000)) {\n\t\tan_1000_val |= (1<<8);\n\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\tif (phy->req_duplex == DUPLEX_FULL)\n\t\t\tan_1000_val |= (1<<9);\n\t\tDP(NETIF_MSG_LINK, \"Advertising 1G\\n\");\n\t} else\n\t\tan_1000_val &= ~((1<<8) | (1<<9));\n\n\tbnx2x_cl22_write(bp, phy,\n\t\t\t0x09,\n\t\t\tan_1000_val);\n\tbnx2x_cl22_read(bp, phy,\n\t\t\t0x09,\n\t\t\t&an_1000_val);\n\n\t/* Advertise 10/100 link speed */\n\tif (phy->req_line_speed == SPEED_AUTO_NEG) {\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF) {\n\t\t\tan_10_100_val |= (1<<5);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 10M-HD\\n\");\n\t\t}\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL) {\n\t\t\tan_10_100_val |= (1<<6);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 10M-FD\\n\");\n\t\t}\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF) {\n\t\t\tan_10_100_val |= (1<<7);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 100M-HD\\n\");\n\t\t}\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL) {\n\t\t\tan_10_100_val |= (1<<8);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 100M-FD\\n\");\n\t\t}\n\t}\n\n\t/* Only 10/100 are allowed to work in FORCE mode */\n\tif (phy->req_line_speed == SPEED_100) {\n\t\tautoneg_val |= (1<<13);\n\t\t/* Enabled AUTO-MDIX when autoneg is disabled */\n\t\tbnx2x_cl22_write(bp, phy,\n\t\t\t\t0x18,\n\t\t\t\t(1<<15 | 1<<9 | 7<<0));\n\t\tDP(NETIF_MSG_LINK, \"Setting 100M force\\n\");\n\t}\n\tif (phy->req_line_speed == SPEED_10) {\n\t\t/* Enabled AUTO-MDIX when autoneg is disabled */\n\t\tbnx2x_cl22_write(bp, phy,\n\t\t\t\t0x18,\n\t\t\t\t(1<<15 | 1<<9 | 7<<0));\n\t\tDP(NETIF_MSG_LINK, \"Setting 10M force\\n\");\n\t}\n\n\tif ((phy->flags & FLAGS_EEE) && bnx2x_eee_has_cap(params)) {\n\t\tint rc;\n\n\t\tbnx2x_cl22_write(bp, phy, MDIO_REG_GPHY_EXP_ACCESS,\n\t\t\t\t MDIO_REG_GPHY_EXP_ACCESS_TOP |\n\t\t\t\t MDIO_REG_GPHY_EXP_TOP_2K_BUF);\n\t\tbnx2x_cl22_read(bp, phy, MDIO_REG_GPHY_EXP_ACCESS_GATE, &temp);\n\t\ttemp &= 0xfffe;\n\t\tbnx2x_cl22_write(bp, phy, MDIO_REG_GPHY_EXP_ACCESS_GATE, temp);\n\n\t\trc = bnx2x_eee_initial_config(params, vars, SHMEM_EEE_1G_ADV);\n\t\tif (rc) {\n\t\t\tDP(NETIF_MSG_LINK, \"Failed to configure EEE timers\\n\");\n\t\t\tbnx2x_eee_disable(phy, params, vars);\n\t\t} else if ((params->eee_mode & EEE_MODE_ADV_LPI) &&\n\t\t\t   (phy->req_duplex == DUPLEX_FULL) &&\n\t\t\t   (bnx2x_eee_calc_timer(params) ||\n\t\t\t    !(params->eee_mode & EEE_MODE_ENABLE_LPI))) {\n\t\t\t/* Need to advertise EEE only when requested,\n\t\t\t * and either no LPI assertion was requested,\n\t\t\t * or it was requested and a valid timer was set.\n\t\t\t * Also notice full duplex is required for EEE.\n\t\t\t */\n\t\t\tbnx2x_eee_advertise(phy, params, vars,\n\t\t\t\t\t    SHMEM_EEE_1G_ADV);\n\t\t} else {\n\t\t\tDP(NETIF_MSG_LINK, \"Don't Advertise 1GBase-T EEE\\n\");\n\t\t\tbnx2x_eee_disable(phy, params, vars);\n\t\t}\n\t} else {\n\t\tvars->eee_status &= ~SHMEM_EEE_1G_ADV <<\n\t\t\t\t    SHMEM_EEE_SUPPORTED_SHIFT;\n\n\t\tif (phy->flags & FLAGS_EEE) {\n\t\t\t/* Handle legacy auto-grEEEn */\n\t\t\tif (params->feature_config_flags &\n\t\t\t    FEATURE_CONFIG_AUTOGREEEN_ENABLED) {\n\t\t\t\ttemp = 6;\n\t\t\t\tDP(NETIF_MSG_LINK, \"Enabling Auto-GrEEEn\\n\");\n\t\t\t} else {\n\t\t\t\ttemp = 0;\n\t\t\t\tDP(NETIF_MSG_LINK, \"Don't Adv. EEE\\n\");\n\t\t\t}\n\t\t\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t\t MDIO_AN_REG_EEE_ADV, temp);\n\t\t}\n\t}\n\n\tbnx2x_cl22_write(bp, phy,\n\t\t\t0x04,\n\t\t\tan_10_100_val | fc_val);\n\n\tif (phy->req_duplex == DUPLEX_FULL)\n\t\tautoneg_val |= (1<<8);\n\n\tbnx2x_cl22_write(bp, phy,\n\t\t\tMDIO_PMA_REG_CTRL, autoneg_val);\n}\n\n\nstatic void bnx2x_5461x_set_link_led(struct bnx2x_phy *phy,\n\t\t\t\t       struct link_params *params, u8 mode)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 temp;\n\n\tbnx2x_cl22_write(bp, phy,\n\t\tMDIO_REG_GPHY_SHADOW,\n\t\tMDIO_REG_GPHY_SHADOW_LED_SEL1);\n\tbnx2x_cl22_read(bp, phy,\n\t\tMDIO_REG_GPHY_SHADOW,\n\t\t&temp);\n\ttemp &= 0xff00;\n\n\tDP(NETIF_MSG_LINK, \"54618x set link led (mode=%x)\\n\", mode);\n\tswitch (mode) {\n\tcase LED_MODE_FRONT_PANEL_OFF:\n\tcase LED_MODE_OFF:\n\t\ttemp |= 0x00ee;\n\t\tbreak;\n\tcase LED_MODE_OPER:\n\t\ttemp |= 0x0001;\n\t\tbreak;\n\tcase LED_MODE_ON:\n\t\ttemp |= 0x00ff;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tbnx2x_cl22_write(bp, phy,\n\t\tMDIO_REG_GPHY_SHADOW,\n\t\tMDIO_REG_GPHY_SHADOW_WR_ENA | temp);\n\treturn;\n}\n\n\nstatic void bnx2x_54618se_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 cfg_pin;\n\tu8 port;\n\n\t/* In case of no EPIO routed to reset the GPHY, put it\n\t * in low power mode.\n\t */\n\tbnx2x_cl22_write(bp, phy, MDIO_PMA_REG_CTRL, 0x800);\n\t/* This works with E3 only, no need to check the chip\n\t * before determining the port.\n\t */\n\tport = params->port;\n\tcfg_pin = (REG_RD(bp, params->shmem_base +\n\t\t\toffsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[port].e3_cmn_pin_cfg)) &\n\t\t\tPORT_HW_CFG_E3_PHY_RESET_MASK) >>\n\t\t\tPORT_HW_CFG_E3_PHY_RESET_SHIFT;\n\n\t/* Drive pin low to put GPHY in reset. */\n\tbnx2x_set_cfg_pin(bp, cfg_pin, 0);\n}\n\nstatic u8 bnx2x_54618se_read_status(struct bnx2x_phy *phy,\n\t\t\t\t    struct link_params *params,\n\t\t\t\t    struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val;\n\tu8 link_up = 0;\n\tu16 legacy_status, legacy_speed;\n\n\t/* Get speed operation status */\n\tbnx2x_cl22_read(bp, phy,\n\t\t\tMDIO_REG_GPHY_AUX_STATUS,\n\t\t\t&legacy_status);\n\tDP(NETIF_MSG_LINK, \"54618SE read_status: 0x%x\\n\", legacy_status);\n\n\t/* Read status to clear the PHY interrupt. */\n\tbnx2x_cl22_read(bp, phy,\n\t\t\tMDIO_REG_INTR_STATUS,\n\t\t\t&val);\n\n\tlink_up = ((legacy_status & (1<<2)) == (1<<2));\n\n\tif (link_up) {\n\t\tlegacy_speed = (legacy_status & (7<<8));\n\t\tif (legacy_speed == (7<<8)) {\n\t\t\tvars->line_speed = SPEED_1000;\n\t\t\tvars->duplex = DUPLEX_FULL;\n\t\t} else if (legacy_speed == (6<<8)) {\n\t\t\tvars->line_speed = SPEED_1000;\n\t\t\tvars->duplex = DUPLEX_HALF;\n\t\t} else if (legacy_speed == (5<<8)) {\n\t\t\tvars->line_speed = SPEED_100;\n\t\t\tvars->duplex = DUPLEX_FULL;\n\t\t}\n\t\t/* Omitting 100Base-T4 for now */\n\t\telse if (legacy_speed == (3<<8)) {\n\t\t\tvars->line_speed = SPEED_100;\n\t\t\tvars->duplex = DUPLEX_HALF;\n\t\t} else if (legacy_speed == (2<<8)) {\n\t\t\tvars->line_speed = SPEED_10;\n\t\t\tvars->duplex = DUPLEX_FULL;\n\t\t} else if (legacy_speed == (1<<8)) {\n\t\t\tvars->line_speed = SPEED_10;\n\t\t\tvars->duplex = DUPLEX_HALF;\n\t\t} else /* Should not happen */\n\t\t\tvars->line_speed = 0;\n\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"Link is up in %dMbps, is_duplex_full= %d\\n\",\n\t\t   vars->line_speed,\n\t\t   (vars->duplex == DUPLEX_FULL));\n\n\t\t/* Check legacy speed AN resolution */\n\t\tbnx2x_cl22_read(bp, phy,\n\t\t\t\t0x01,\n\t\t\t\t&val);\n\t\tif (val & (1<<5))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_AUTO_NEGOTIATE_COMPLETE;\n\t\tbnx2x_cl22_read(bp, phy,\n\t\t\t\t0x06,\n\t\t\t\t&val);\n\t\tif ((val & (1<<0)) == 0)\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_PARALLEL_DETECTION_USED;\n\n\t\tDP(NETIF_MSG_LINK, \"BCM54618SE: link speed is %d\\n\",\n\t\t\t   vars->line_speed);\n\n\t\tbnx2x_ext_phy_resolve_fc(phy, params, vars);\n\n\t\tif (vars->link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE) {\n\t\t\t/* Report LP advertised speeds */\n\t\t\tbnx2x_cl22_read(bp, phy, 0x5, &val);\n\n\t\t\tif (val & (1<<5))\n\t\t\t\tvars->link_status |=\n\t\t\t\t  LINK_STATUS_LINK_PARTNER_10THD_CAPABLE;\n\t\t\tif (val & (1<<6))\n\t\t\t\tvars->link_status |=\n\t\t\t\t  LINK_STATUS_LINK_PARTNER_10TFD_CAPABLE;\n\t\t\tif (val & (1<<7))\n\t\t\t\tvars->link_status |=\n\t\t\t\t  LINK_STATUS_LINK_PARTNER_100TXHD_CAPABLE;\n\t\t\tif (val & (1<<8))\n\t\t\t\tvars->link_status |=\n\t\t\t\t  LINK_STATUS_LINK_PARTNER_100TXFD_CAPABLE;\n\t\t\tif (val & (1<<9))\n\t\t\t\tvars->link_status |=\n\t\t\t\t  LINK_STATUS_LINK_PARTNER_100T4_CAPABLE;\n\n\t\t\tbnx2x_cl22_read(bp, phy, 0xa, &val);\n\t\t\tif (val & (1<<10))\n\t\t\t\tvars->link_status |=\n\t\t\t\t  LINK_STATUS_LINK_PARTNER_1000THD_CAPABLE;\n\t\t\tif (val & (1<<11))\n\t\t\t\tvars->link_status |=\n\t\t\t\t  LINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE;\n\n\t\t\tif ((phy->flags & FLAGS_EEE) &&\n\t\t\t    bnx2x_eee_has_cap(params))\n\t\t\t\tbnx2x_eee_an_resolve(phy, params, vars);\n\t\t}\n\t}\n\treturn link_up;\n}\n\nstatic void bnx2x_54618se_config_loopback(struct bnx2x_phy *phy,\n\t\t\t\t\t  struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val;\n\tu32 umac_base = params->port ? GRCBASE_UMAC1 : GRCBASE_UMAC0;\n\n\tDP(NETIF_MSG_LINK, \"2PMA/PMD ext_phy_loopback: 54618se\\n\");\n\n\t/* Enable master/slave manual mmode and set to master */\n\t/* mii write 9 [bits set 11 12] */\n\tbnx2x_cl22_write(bp, phy, 0x09, 3<<11);\n\n\t/* forced 1G and disable autoneg */\n\t/* set val [mii read 0] */\n\t/* set val [expr $val & [bits clear 6 12 13]] */\n\t/* set val [expr $val | [bits set 6 8]] */\n\t/* mii write 0 $val */\n\tbnx2x_cl22_read(bp, phy, 0x00, &val);\n\tval &= ~((1<<6) | (1<<12) | (1<<13));\n\tval |= (1<<6) | (1<<8);\n\tbnx2x_cl22_write(bp, phy, 0x00, val);\n\n\t/* Set external loopback and Tx using 6dB coding */\n\t/* mii write 0x18 7 */\n\t/* set val [mii read 0x18] */\n\t/* mii write 0x18 [expr $val | [bits set 10 15]] */\n\tbnx2x_cl22_write(bp, phy, 0x18, 7);\n\tbnx2x_cl22_read(bp, phy, 0x18, &val);\n\tbnx2x_cl22_write(bp, phy, 0x18, val | (1<<10) | (1<<15));\n\n\t/* This register opens the gate for the UMAC despite its name */\n\tREG_WR(bp, NIG_REG_EGRESS_EMAC0_PORT + params->port*4, 1);\n\n\t/* Maximum Frame Length (RW). Defines a 14-Bit maximum frame\n\t * length used by the MAC receive logic to check frames.\n\t */\n\tREG_WR(bp, umac_base + UMAC_REG_MAXFR, 0x2710);\n}\n\n/******************************************************************/\n/*\t\t\tSFX7101 PHY SECTION\t\t\t  */\n/******************************************************************/\nstatic void bnx2x_7101_config_loopback(struct bnx2x_phy *phy,\n\t\t\t\t       struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\t/* SFX7101_XGXS_TEST1 */\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_XS_DEVAD, MDIO_XS_SFX7101_XGXS_TEST1, 0x100);\n}\n\nstatic void bnx2x_7101_config_init(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tu16 fw_ver1, fw_ver2, val;\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"Setting the SFX7101 LASI indication\\n\");\n\n\t/* Restore normal power mode*/\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH, params->port);\n\t/* HW reset */\n\tbnx2x_ext_phy_hw_reset(bp, params->port);\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 0x1);\n\tDP(NETIF_MSG_LINK, \"Setting the SFX7101 LED to blink on traffic\\n\");\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_7107_LED_CNTL, (1<<3));\n\n\tbnx2x_ext_phy_set_pause(params, phy, vars);\n\t/* Restart autoneg */\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_CTRL, &val);\n\tval |= 0x200;\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CTRL, val);\n\n\t/* Save spirom version */\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_7101_VER1, &fw_ver1);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_7101_VER2, &fw_ver2);\n\tbnx2x_save_spirom_version(bp, params->port,\n\t\t\t\t  (u32)(fw_ver1<<16 | fw_ver2), phy->ver_addr);\n}\n\nstatic u8 bnx2x_7101_read_status(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params,\n\t\t\t\t struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 link_up;\n\tu16 val1, val2;\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val2);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val1);\n\tDP(NETIF_MSG_LINK, \"10G-base-T LASI status 0x%x->0x%x\\n\",\n\t\t   val2, val1);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val2);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val1);\n\tDP(NETIF_MSG_LINK, \"10G-base-T PMA status 0x%x->0x%x\\n\",\n\t\t   val2, val1);\n\tlink_up = ((val1 & 4) == 4);\n\t/* If link is up print the AN outcome of the SFX7101 PHY */\n\tif (link_up) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_MASTER_STATUS,\n\t\t\t\t&val2);\n\t\tvars->line_speed = SPEED_10000;\n\t\tvars->duplex = DUPLEX_FULL;\n\t\tDP(NETIF_MSG_LINK, \"SFX7101 AN status 0x%x->Master=%x\\n\",\n\t\t\t   val2, (val2 & (1<<14)));\n\t\tbnx2x_ext_phy_10G_an_resolve(bp, phy, vars);\n\t\tbnx2x_ext_phy_resolve_fc(phy, params, vars);\n\n\t\t/* Read LP advertised speeds */\n\t\tif (val2 & (1<<11))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\n\t}\n\treturn link_up;\n}\n\nstatic int bnx2x_7101_format_ver(u32 spirom_ver, u8 *str, u16 *len)\n{\n\tif (*len < 5)\n\t\treturn -EINVAL;\n\tstr[0] = (spirom_ver & 0xFF);\n\tstr[1] = (spirom_ver & 0xFF00) >> 8;\n\tstr[2] = (spirom_ver & 0xFF0000) >> 16;\n\tstr[3] = (spirom_ver & 0xFF000000) >> 24;\n\tstr[4] = '\\0';\n\t*len -= 5;\n\treturn 0;\n}\n\nvoid bnx2x_sfx7101_sp_sw_reset(struct bnx2x *bp, struct bnx2x_phy *phy)\n{\n\tu16 val, cnt;\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_7101_RESET, &val);\n\n\tfor (cnt = 0; cnt < 10; cnt++) {\n\t\tmsleep(50);\n\t\t/* Writes a self-clearing reset */\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_7101_RESET,\n\t\t\t\t (val | (1<<15)));\n\t\t/* Wait for clear */\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_7101_RESET, &val);\n\n\t\tif ((val & (1<<15)) == 0)\n\t\t\tbreak;\n\t}\n}\n\nstatic void bnx2x_7101_hw_reset(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params) {\n\t/* Low power mode is controlled by GPIO 2 */\n\tbnx2x_set_gpio(params->bp, MISC_REGISTERS_GPIO_2,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW, params->port);\n\t/* The PHY reset is controlled by GPIO 1 */\n\tbnx2x_set_gpio(params->bp, MISC_REGISTERS_GPIO_1,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW, params->port);\n}\n\nstatic void bnx2x_7101_set_link_led(struct bnx2x_phy *phy,\n\t\t\t\t    struct link_params *params, u8 mode)\n{\n\tu16 val = 0;\n\tstruct bnx2x *bp = params->bp;\n\tswitch (mode) {\n\tcase LED_MODE_FRONT_PANEL_OFF:\n\tcase LED_MODE_OFF:\n\t\tval = 2;\n\t\tbreak;\n\tcase LED_MODE_ON:\n\t\tval = 1;\n\t\tbreak;\n\tcase LED_MODE_OPER:\n\t\tval = 0;\n\t\tbreak;\n\t}\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_7107_LINK_LED_CNTL,\n\t\t\t val);\n}\n\n/******************************************************************/\n/*\t\t\tSTATIC PHY DECLARATION\t\t\t  */\n/******************************************************************/\n\nstatic const struct bnx2x_phy phy_null = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN,\n\t.addr\t\t= 0,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_INIT_XGXS_FIRST,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= 0,\n\t.media_type\t= ETH_PHY_NOT_PRESENT,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= NULL,\n\t.read_status\t= NULL,\n\t.link_reset\t= NULL,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= NULL,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= NULL,\n\t.phy_specific_func = NULL\n};\n\nstatic const struct bnx2x_phy phy_serdes = {\n\t.type\t\t= PORT_HW_CFG_SERDES_EXT_PHY_TYPE_DIRECT,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= 0,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10baseT_Half |\n\t\t\t   SUPPORTED_10baseT_Full |\n\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_2500baseX_Full |\n\t\t\t   SUPPORTED_TP |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_BASE_T,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_xgxs_config_init,\n\t.read_status\t= bnx2x_link_settings_status,\n\t.link_reset\t= bnx2x_int_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= NULL,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= NULL,\n\t.phy_specific_func = NULL\n};\n\nstatic const struct bnx2x_phy phy_xgxs = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= 0,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10baseT_Half |\n\t\t\t   SUPPORTED_10baseT_Full |\n\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_2500baseX_Full |\n\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_FIBRE |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_CX4,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_xgxs_config_init,\n\t.read_status\t= bnx2x_link_settings_status,\n\t.link_reset\t= bnx2x_int_link_reset,\n\t.config_loopback = bnx2x_set_xgxs_loopback,\n\t.format_fw_ver\t= NULL,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= NULL,\n\t.phy_specific_func = bnx2x_xgxs_specific_func\n};\nstatic const struct bnx2x_phy phy_warpcore = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_TX_ERROR_CHECK,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10baseT_Half |\n\t\t\t   SUPPORTED_10baseT_Full |\n\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_1000baseKX_Full |\n\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_10000baseKR_Full |\n\t\t\t   SUPPORTED_20000baseKR2_Full |\n\t\t\t   SUPPORTED_20000baseMLD2_Full |\n\t\t\t   SUPPORTED_FIBRE |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_UNSPECIFIED,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t/* req_duplex = */0,\n\t/* rsrv = */0,\n\t.config_init\t= bnx2x_warpcore_config_init,\n\t.read_status\t= bnx2x_warpcore_read_status,\n\t.link_reset\t= bnx2x_warpcore_link_reset,\n\t.config_loopback = bnx2x_set_warpcore_loopback,\n\t.format_fw_ver\t= NULL,\n\t.hw_reset\t= bnx2x_warpcore_hw_reset,\n\t.set_link_led\t= NULL,\n\t.phy_specific_func = NULL\n};\n\n\nstatic const struct bnx2x_phy phy_7101 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_FAN_FAILURE_DET_REQ,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_TP |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_BASE_T,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_7101_config_init,\n\t.read_status\t= bnx2x_7101_read_status,\n\t.link_reset\t= bnx2x_common_ext_link_reset,\n\t.config_loopback = bnx2x_7101_config_loopback,\n\t.format_fw_ver\t= bnx2x_7101_format_ver,\n\t.hw_reset\t= bnx2x_7101_hw_reset,\n\t.set_link_led\t= bnx2x_7101_set_link_led,\n\t.phy_specific_func = NULL\n};\nstatic const struct bnx2x_phy phy_8073 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= 0,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_2500baseX_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_FIBRE |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_KR,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_8073_config_init,\n\t.read_status\t= bnx2x_8073_read_status,\n\t.link_reset\t= bnx2x_8073_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_format_ver,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= NULL,\n\t.phy_specific_func = bnx2x_8073_specific_func\n};\nstatic const struct bnx2x_phy phy_8705 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_INIT_XGXS_FIRST,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_FIBRE |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_XFP_FIBER,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_8705_config_init,\n\t.read_status\t= bnx2x_8705_read_status,\n\t.link_reset\t= bnx2x_common_ext_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_null_format_ver,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= NULL,\n\t.phy_specific_func = NULL\n};\nstatic const struct bnx2x_phy phy_8706 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_INIT_XGXS_FIRST,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_FIBRE |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_SFPP_10G_FIBER,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_8706_config_init,\n\t.read_status\t= bnx2x_8706_read_status,\n\t.link_reset\t= bnx2x_common_ext_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_format_ver,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= NULL,\n\t.phy_specific_func = NULL\n};\n\nstatic const struct bnx2x_phy phy_8726 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= (FLAGS_INIT_XGXS_FIRST |\n\t\t\t   FLAGS_TX_ERROR_CHECK),\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_FIBRE |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_NOT_PRESENT,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_8726_config_init,\n\t.read_status\t= bnx2x_8726_read_status,\n\t.link_reset\t= bnx2x_8726_link_reset,\n\t.config_loopback = bnx2x_8726_config_loopback,\n\t.format_fw_ver\t= bnx2x_format_ver,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= NULL,\n\t.phy_specific_func = NULL\n};\n\nstatic const struct bnx2x_phy phy_8727 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= (FLAGS_FAN_FAILURE_DET_REQ |\n\t\t\t   FLAGS_TX_ERROR_CHECK),\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_FIBRE |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_NOT_PRESENT,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_8727_config_init,\n\t.read_status\t= bnx2x_8727_read_status,\n\t.link_reset\t= bnx2x_8727_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_format_ver,\n\t.hw_reset\t= bnx2x_8727_hw_reset,\n\t.set_link_led\t= bnx2x_8727_set_link_led,\n\t.phy_specific_func = bnx2x_8727_specific_func\n};\nstatic const struct bnx2x_phy phy_8481 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_FAN_FAILURE_DET_REQ |\n\t\t\t  FLAGS_REARM_LATCH_SIGNAL,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10baseT_Half |\n\t\t\t   SUPPORTED_10baseT_Full |\n\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_TP |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_BASE_T,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_8481_config_init,\n\t.read_status\t= bnx2x_848xx_read_status,\n\t.link_reset\t= bnx2x_8481_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_848xx_format_ver,\n\t.hw_reset\t= bnx2x_8481_hw_reset,\n\t.set_link_led\t= bnx2x_848xx_set_link_led,\n\t.phy_specific_func = NULL\n};\n\nstatic const struct bnx2x_phy phy_84823 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= (FLAGS_FAN_FAILURE_DET_REQ |\n\t\t\t   FLAGS_REARM_LATCH_SIGNAL |\n\t\t\t   FLAGS_TX_ERROR_CHECK),\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10baseT_Half |\n\t\t\t   SUPPORTED_10baseT_Full |\n\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_TP |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_BASE_T,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_848x3_config_init,\n\t.read_status\t= bnx2x_848xx_read_status,\n\t.link_reset\t= bnx2x_848x3_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_848xx_format_ver,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= bnx2x_848xx_set_link_led,\n\t.phy_specific_func = bnx2x_848xx_specific_func\n};\n\nstatic const struct bnx2x_phy phy_84833 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= (FLAGS_FAN_FAILURE_DET_REQ |\n\t\t\t   FLAGS_REARM_LATCH_SIGNAL |\n\t\t\t   FLAGS_TX_ERROR_CHECK),\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_TP |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_BASE_T,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_848x3_config_init,\n\t.read_status\t= bnx2x_848xx_read_status,\n\t.link_reset\t= bnx2x_848x3_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_848xx_format_ver,\n\t.hw_reset\t= bnx2x_84833_hw_reset_phy,\n\t.set_link_led\t= bnx2x_848xx_set_link_led,\n\t.phy_specific_func = bnx2x_848xx_specific_func\n};\n\nstatic const struct bnx2x_phy phy_84834 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_FAN_FAILURE_DET_REQ |\n\t\t\t    FLAGS_REARM_LATCH_SIGNAL,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_TP |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_BASE_T,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_848x3_config_init,\n\t.read_status\t= bnx2x_848xx_read_status,\n\t.link_reset\t= bnx2x_848x3_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_848xx_format_ver,\n\t.hw_reset\t= bnx2x_84833_hw_reset_phy,\n\t.set_link_led\t= bnx2x_848xx_set_link_led,\n\t.phy_specific_func = bnx2x_848xx_specific_func\n};\n\nstatic const struct bnx2x_phy phy_84858 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_FAN_FAILURE_DET_REQ |\n\t\t\t    FLAGS_REARM_LATCH_SIGNAL,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_TP |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_BASE_T,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_848x3_config_init,\n\t.read_status\t= bnx2x_848xx_read_status,\n\t.link_reset\t= bnx2x_848x3_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_8485x_format_ver,\n\t.hw_reset\t= bnx2x_84833_hw_reset_phy,\n\t.set_link_led\t= bnx2x_848xx_set_link_led,\n\t.phy_specific_func = bnx2x_848xx_specific_func\n};\n\nstatic const struct bnx2x_phy phy_54618se = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_INIT_XGXS_FIRST,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10baseT_Half |\n\t\t\t   SUPPORTED_10baseT_Full |\n\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_TP |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_BASE_T,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t/* req_duplex = */0,\n\t/* rsrv = */0,\n\t.config_init\t= bnx2x_54618se_config_init,\n\t.read_status\t= bnx2x_54618se_read_status,\n\t.link_reset\t= bnx2x_54618se_link_reset,\n\t.config_loopback = bnx2x_54618se_config_loopback,\n\t.format_fw_ver\t= NULL,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= bnx2x_5461x_set_link_led,\n\t.phy_specific_func = bnx2x_54618se_specific_func\n};\n/*****************************************************************/\n/*                                                               */\n/* Populate the phy according. Main function: bnx2x_populate_phy   */\n/*                                                               */\n/*****************************************************************/\n\nstatic void bnx2x_populate_preemphasis(struct bnx2x *bp, u32 shmem_base,\n\t\t\t\t     struct bnx2x_phy *phy, u8 port,\n\t\t\t\t     u8 phy_index)\n{\n\t/* Get the 4 lanes xgxs config rx and tx */\n\tu32 rx = 0, tx = 0, i;\n\tfor (i = 0; i < 2; i++) {\n\t\t/* INT_PHY and EXT_PHY1 share the same value location in\n\t\t * the shmem. When num_phys is greater than 1, than this value\n\t\t * applies only to EXT_PHY1\n\t\t */\n\t\tif (phy_index == INT_PHY || phy_index == EXT_PHY1) {\n\t\t\trx = REG_RD(bp, shmem_base +\n\t\t\t\t    offsetof(struct shmem_region,\n\t\t\t  dev_info.port_hw_config[port].xgxs_config_rx[i<<1]));\n\n\t\t\ttx = REG_RD(bp, shmem_base +\n\t\t\t\t    offsetof(struct shmem_region,\n\t\t\t  dev_info.port_hw_config[port].xgxs_config_tx[i<<1]));\n\t\t} else {\n\t\t\trx = REG_RD(bp, shmem_base +\n\t\t\t\t    offsetof(struct shmem_region,\n\t\t\t dev_info.port_hw_config[port].xgxs_config2_rx[i<<1]));\n\n\t\t\ttx = REG_RD(bp, shmem_base +\n\t\t\t\t    offsetof(struct shmem_region,\n\t\t\t dev_info.port_hw_config[port].xgxs_config2_rx[i<<1]));\n\t\t}\n\n\t\tphy->rx_preemphasis[i << 1] = ((rx>>16) & 0xffff);\n\t\tphy->rx_preemphasis[(i << 1) + 1] = (rx & 0xffff);\n\n\t\tphy->tx_preemphasis[i << 1] = ((tx>>16) & 0xffff);\n\t\tphy->tx_preemphasis[(i << 1) + 1] = (tx & 0xffff);\n\t}\n}\n\nstatic u32 bnx2x_get_ext_phy_config(struct bnx2x *bp, u32 shmem_base,\n\t\t\t\t    u8 phy_index, u8 port)\n{\n\tu32 ext_phy_config = 0;\n\tswitch (phy_index) {\n\tcase EXT_PHY1:\n\t\text_phy_config = REG_RD(bp, shmem_base +\n\t\t\t\t\t      offsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[port].external_phy_config));\n\t\tbreak;\n\tcase EXT_PHY2:\n\t\text_phy_config = REG_RD(bp, shmem_base +\n\t\t\t\t\t      offsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[port].external_phy_config2));\n\t\tbreak;\n\tdefault:\n\t\tDP(NETIF_MSG_LINK, \"Invalid phy_index %d\\n\", phy_index);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ext_phy_config;\n}\nstatic int bnx2x_populate_int_phy(struct bnx2x *bp, u32 shmem_base, u8 port,\n\t\t\t\t  struct bnx2x_phy *phy)\n{\n\tu32 phy_addr;\n\tu32 chip_id;\n\tu32 switch_cfg = (REG_RD(bp, shmem_base +\n\t\t\t\t       offsetof(struct shmem_region,\n\t\t\tdev_info.port_feature_config[port].link_config)) &\n\t\t\t  PORT_FEATURE_CONNECTED_SWITCH_MASK);\n\tchip_id = (REG_RD(bp, MISC_REG_CHIP_NUM) << 16) |\n\t\t((REG_RD(bp, MISC_REG_CHIP_REV) & 0xf) << 12);\n\n\tDP(NETIF_MSG_LINK, \":chip_id = 0x%x\\n\", chip_id);\n\tif (USES_WARPCORE(bp)) {\n\t\tu32 serdes_net_if;\n\t\tphy_addr = REG_RD(bp,\n\t\t\t\t  MISC_REG_WC0_CTRL_PHY_ADDR);\n\t\t*phy = phy_warpcore;\n\t\tif (REG_RD(bp, MISC_REG_PORT4MODE_EN_OVWR) == 0x3)\n\t\t\tphy->flags |= FLAGS_4_PORT_MODE;\n\t\telse\n\t\t\tphy->flags &= ~FLAGS_4_PORT_MODE;\n\t\t\t/* Check Dual mode */\n\t\tserdes_net_if = (REG_RD(bp, shmem_base +\n\t\t\t\t\toffsetof(struct shmem_region, dev_info.\n\t\t\t\t\tport_hw_config[port].default_cfg)) &\n\t\t\t\t PORT_HW_CFG_NET_SERDES_IF_MASK);\n\t\t/* Set the appropriate supported and flags indications per\n\t\t * interface type of the chip\n\t\t */\n\t\tswitch (serdes_net_if) {\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_SGMII:\n\t\t\tphy->supported &= (SUPPORTED_10baseT_Half |\n\t\t\t\t\t   SUPPORTED_10baseT_Full |\n\t\t\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t\t\t   SUPPORTED_FIBRE |\n\t\t\t\t\t   SUPPORTED_Autoneg |\n\t\t\t\t\t   SUPPORTED_Pause |\n\t\t\t\t\t   SUPPORTED_Asym_Pause);\n\t\t\tphy->media_type = ETH_PHY_BASE_T;\n\t\t\tbreak;\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_XFI:\n\t\t\tphy->supported &= (SUPPORTED_1000baseT_Full |\n\t\t\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t\t\t   SUPPORTED_FIBRE |\n\t\t\t\t\t   SUPPORTED_Pause |\n\t\t\t\t\t   SUPPORTED_Asym_Pause);\n\t\t\tphy->media_type = ETH_PHY_XFP_FIBER;\n\t\t\tbreak;\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_SFI:\n\t\t\tphy->supported &= (SUPPORTED_1000baseT_Full |\n\t\t\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t\t\t   SUPPORTED_FIBRE |\n\t\t\t\t\t   SUPPORTED_Pause |\n\t\t\t\t\t   SUPPORTED_Asym_Pause);\n\t\t\tphy->media_type = ETH_PHY_SFPP_10G_FIBER;\n\t\t\tbreak;\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_KR:\n\t\t\tphy->media_type = ETH_PHY_KR;\n\t\t\tphy->supported &= (SUPPORTED_1000baseKX_Full |\n\t\t\t\t\t   SUPPORTED_10000baseKR_Full |\n\t\t\t\t\t   SUPPORTED_FIBRE |\n\t\t\t\t\t   SUPPORTED_Autoneg |\n\t\t\t\t\t   SUPPORTED_Pause |\n\t\t\t\t\t   SUPPORTED_Asym_Pause);\n\t\t\tbreak;\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_DXGXS:\n\t\t\tphy->media_type = ETH_PHY_KR;\n\t\t\tphy->flags |= FLAGS_WC_DUAL_MODE;\n\t\t\tphy->supported &= (SUPPORTED_20000baseMLD2_Full |\n\t\t\t\t\t   SUPPORTED_FIBRE |\n\t\t\t\t\t   SUPPORTED_Pause |\n\t\t\t\t\t   SUPPORTED_Asym_Pause);\n\t\t\tbreak;\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_KR2:\n\t\t\tphy->media_type = ETH_PHY_KR;\n\t\t\tphy->flags |= FLAGS_WC_DUAL_MODE;\n\t\t\tphy->supported &= (SUPPORTED_20000baseKR2_Full |\n\t\t\t\t\t   SUPPORTED_10000baseKR_Full |\n\t\t\t\t\t   SUPPORTED_1000baseKX_Full |\n\t\t\t\t\t   SUPPORTED_Autoneg |\n\t\t\t\t\t   SUPPORTED_FIBRE |\n\t\t\t\t\t   SUPPORTED_Pause |\n\t\t\t\t\t   SUPPORTED_Asym_Pause);\n\t\t\tphy->flags &= ~FLAGS_TX_ERROR_CHECK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDP(NETIF_MSG_LINK, \"Unknown WC interface type 0x%x\\n\",\n\t\t\t\t       serdes_net_if);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Enable MDC/MDIO work-around for E3 A0 since free running MDC\n\t\t * was not set as expected. For B0, ECO will be enabled so there\n\t\t * won't be an issue there\n\t\t */\n\t\tif (CHIP_REV(bp) == CHIP_REV_Ax)\n\t\t\tphy->flags |= FLAGS_MDC_MDIO_WA;\n\t\telse\n\t\t\tphy->flags |= FLAGS_MDC_MDIO_WA_B0;\n\t} else {\n\t\tswitch (switch_cfg) {\n\t\tcase SWITCH_CFG_1G:\n\t\t\tphy_addr = REG_RD(bp,\n\t\t\t\t\t  NIG_REG_SERDES0_CTRL_PHY_ADDR +\n\t\t\t\t\t  port * 0x10);\n\t\t\t*phy = phy_serdes;\n\t\t\tbreak;\n\t\tcase SWITCH_CFG_10G:\n\t\t\tphy_addr = REG_RD(bp,\n\t\t\t\t\t  NIG_REG_XGXS0_CTRL_PHY_ADDR +\n\t\t\t\t\t  port * 0x18);\n\t\t\t*phy = phy_xgxs;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDP(NETIF_MSG_LINK, \"Invalid switch_cfg\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tphy->addr = (u8)phy_addr;\n\tphy->mdio_ctrl = bnx2x_get_emac_base(bp,\n\t\t\t\t\t    SHARED_HW_CFG_MDC_MDIO_ACCESS1_BOTH,\n\t\t\t\t\t    port);\n\tif (CHIP_IS_E2(bp))\n\t\tphy->def_md_devad = E2_DEFAULT_PHY_DEV_ADDR;\n\telse\n\t\tphy->def_md_devad = DEFAULT_PHY_DEV_ADDR;\n\n\tDP(NETIF_MSG_LINK, \"Internal phy port=%d, addr=0x%x, mdio_ctl=0x%x\\n\",\n\t\t   port, phy->addr, phy->mdio_ctrl);\n\n\tbnx2x_populate_preemphasis(bp, shmem_base, phy, port, INT_PHY);\n\treturn 0;\n}\n\nstatic int bnx2x_populate_ext_phy(struct bnx2x *bp,\n\t\t\t\t  u8 phy_index,\n\t\t\t\t  u32 shmem_base,\n\t\t\t\t  u32 shmem2_base,\n\t\t\t\t  u8 port,\n\t\t\t\t  struct bnx2x_phy *phy)\n{\n\tu32 ext_phy_config, phy_type, config2;\n\tu32 mdc_mdio_access = SHARED_HW_CFG_MDC_MDIO_ACCESS1_BOTH;\n\text_phy_config = bnx2x_get_ext_phy_config(bp, shmem_base,\n\t\t\t\t\t\t  phy_index, port);\n\tphy_type = XGXS_EXT_PHY_TYPE(ext_phy_config);\n\t/* Select the phy type */\n\tswitch (phy_type) {\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073:\n\t\tmdc_mdio_access = SHARED_HW_CFG_MDC_MDIO_ACCESS1_SWAPPED;\n\t\t*phy = phy_8073;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705:\n\t\t*phy = phy_8705;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706:\n\t\t*phy = phy_8706;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:\n\t\tmdc_mdio_access = SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC1;\n\t\t*phy = phy_8726;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727_NOC:\n\t\t/* BCM8727_NOC => BCM8727 no over current */\n\t\tmdc_mdio_access = SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC1;\n\t\t*phy = phy_8727;\n\t\tphy->flags |= FLAGS_NOC;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:\n\t\tmdc_mdio_access = SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC1;\n\t\t*phy = phy_8727;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481:\n\t\t*phy = phy_8481;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823:\n\t\t*phy = phy_84823;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833:\n\t\t*phy = phy_84833;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834:\n\t\t*phy = phy_84834;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858:\n\t\t*phy = phy_84858;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54616:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE:\n\t\t*phy = phy_54618se;\n\t\tif (phy_type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE)\n\t\t\tphy->flags |= FLAGS_EEE;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101:\n\t\t*phy = phy_7101;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE:\n\t\t*phy = phy_null;\n\t\treturn -EINVAL;\n\tdefault:\n\t\t*phy = phy_null;\n\t\t/* In case external PHY wasn't found */\n\t\tif ((phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) &&\n\t\t    (phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\tphy->addr = XGXS_EXT_PHY_ADDR(ext_phy_config);\n\tbnx2x_populate_preemphasis(bp, shmem_base, phy, port, phy_index);\n\n\t/* The shmem address of the phy version is located on different\n\t * structures. In case this structure is too old, do not set\n\t * the address\n\t */\n\tconfig2 = REG_RD(bp, shmem_base + offsetof(struct shmem_region,\n\t\t\t\t\tdev_info.shared_hw_config.config2));\n\tif (phy_index == EXT_PHY1) {\n\t\tphy->ver_addr = shmem_base + offsetof(struct shmem_region,\n\t\t\t\tport_mb[port].ext_phy_fw_version);\n\n\t\t/* Check specific mdc mdio settings */\n\t\tif (config2 & SHARED_HW_CFG_MDC_MDIO_ACCESS1_MASK)\n\t\t\tmdc_mdio_access = config2 &\n\t\t\tSHARED_HW_CFG_MDC_MDIO_ACCESS1_MASK;\n\t} else {\n\t\tu32 size = REG_RD(bp, shmem2_base);\n\n\t\tif (size >\n\t\t    offsetof(struct shmem2_region, ext_phy_fw_version2)) {\n\t\t\tphy->ver_addr = shmem2_base +\n\t\t\t    offsetof(struct shmem2_region,\n\t\t\t\t     ext_phy_fw_version2[port]);\n\t\t}\n\t\t/* Check specific mdc mdio settings */\n\t\tif (config2 & SHARED_HW_CFG_MDC_MDIO_ACCESS2_MASK)\n\t\t\tmdc_mdio_access = (config2 &\n\t\t\tSHARED_HW_CFG_MDC_MDIO_ACCESS2_MASK) >>\n\t\t\t(SHARED_HW_CFG_MDC_MDIO_ACCESS2_SHIFT -\n\t\t\t SHARED_HW_CFG_MDC_MDIO_ACCESS1_SHIFT);\n\t}\n\tphy->mdio_ctrl = bnx2x_get_emac_base(bp, mdc_mdio_access, port);\n\n\tif (bnx2x_is_8483x_8485x(phy) && (phy->ver_addr)) {\n\t\t/* Remove 100Mb link supported for BCM84833/4 when phy fw\n\t\t * version lower than or equal to 1.39\n\t\t */\n\t\tu32 raw_ver = REG_RD(bp, phy->ver_addr);\n\t\tif (((raw_ver & 0x7F) <= 39) &&\n\t\t    (((raw_ver & 0xF80) >> 7) <= 1))\n\t\t\tphy->supported &= ~(SUPPORTED_100baseT_Half |\n\t\t\t\t\t    SUPPORTED_100baseT_Full);\n\t}\n\n\tDP(NETIF_MSG_LINK, \"phy_type 0x%x port %d found in index %d\\n\",\n\t\t   phy_type, port, phy_index);\n\tDP(NETIF_MSG_LINK, \"             addr=0x%x, mdio_ctl=0x%x\\n\",\n\t\t   phy->addr, phy->mdio_ctrl);\n\treturn 0;\n}\n\nstatic int bnx2x_populate_phy(struct bnx2x *bp, u8 phy_index, u32 shmem_base,\n\t\t\t      u32 shmem2_base, u8 port, struct bnx2x_phy *phy)\n{\n\tphy->type = PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN;\n\tif (phy_index == INT_PHY)\n\t\treturn bnx2x_populate_int_phy(bp, shmem_base, port, phy);\n\n\treturn bnx2x_populate_ext_phy(bp, phy_index, shmem_base, shmem2_base,\n\t\t\t\t\tport, phy);\n}\n\nstatic void bnx2x_phy_def_cfg(struct link_params *params,\n\t\t\t      struct bnx2x_phy *phy,\n\t\t\t      u8 phy_index)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 link_config;\n\t/* Populate the default phy configuration for MF mode */\n\tif (phy_index == EXT_PHY2) {\n\t\tlink_config = REG_RD(bp, params->shmem_base +\n\t\t\t\t     offsetof(struct shmem_region, dev_info.\n\t\t\tport_feature_config[params->port].link_config2));\n\t\tphy->speed_cap_mask = REG_RD(bp, params->shmem_base +\n\t\t\t\t\t     offsetof(struct shmem_region,\n\t\t\t\t\t\t      dev_info.\n\t\t\tport_hw_config[params->port].speed_capability_mask2));\n\t} else {\n\t\tlink_config = REG_RD(bp, params->shmem_base +\n\t\t\t\t     offsetof(struct shmem_region, dev_info.\n\t\t\t\tport_feature_config[params->port].link_config));\n\t\tphy->speed_cap_mask = REG_RD(bp, params->shmem_base +\n\t\t\t\t\t     offsetof(struct shmem_region,\n\t\t\t\t\t\t      dev_info.\n\t\t\tport_hw_config[params->port].speed_capability_mask));\n\t}\n\tDP(NETIF_MSG_LINK,\n\t   \"Default config phy idx %x cfg 0x%x speed_cap_mask 0x%x\\n\",\n\t   phy_index, link_config, phy->speed_cap_mask);\n\n\tphy->req_duplex = DUPLEX_FULL;\n\tswitch (link_config  & PORT_FEATURE_LINK_SPEED_MASK) {\n\tcase PORT_FEATURE_LINK_SPEED_10M_HALF:\n\t\tphy->req_duplex = DUPLEX_HALF;\n\t\tfallthrough;\n\tcase PORT_FEATURE_LINK_SPEED_10M_FULL:\n\t\tphy->req_line_speed = SPEED_10;\n\t\tbreak;\n\tcase PORT_FEATURE_LINK_SPEED_100M_HALF:\n\t\tphy->req_duplex = DUPLEX_HALF;\n\t\tfallthrough;\n\tcase PORT_FEATURE_LINK_SPEED_100M_FULL:\n\t\tphy->req_line_speed = SPEED_100;\n\t\tbreak;\n\tcase PORT_FEATURE_LINK_SPEED_1G:\n\t\tphy->req_line_speed = SPEED_1000;\n\t\tbreak;\n\tcase PORT_FEATURE_LINK_SPEED_2_5G:\n\t\tphy->req_line_speed = SPEED_2500;\n\t\tbreak;\n\tcase PORT_FEATURE_LINK_SPEED_10G_CX4:\n\t\tphy->req_line_speed = SPEED_10000;\n\t\tbreak;\n\tdefault:\n\t\tphy->req_line_speed = SPEED_AUTO_NEG;\n\t\tbreak;\n\t}\n\n\tswitch (link_config  & PORT_FEATURE_FLOW_CONTROL_MASK) {\n\tcase PORT_FEATURE_FLOW_CONTROL_AUTO:\n\t\tphy->req_flow_ctrl = BNX2X_FLOW_CTRL_AUTO;\n\t\tbreak;\n\tcase PORT_FEATURE_FLOW_CONTROL_TX:\n\t\tphy->req_flow_ctrl = BNX2X_FLOW_CTRL_TX;\n\t\tbreak;\n\tcase PORT_FEATURE_FLOW_CONTROL_RX:\n\t\tphy->req_flow_ctrl = BNX2X_FLOW_CTRL_RX;\n\t\tbreak;\n\tcase PORT_FEATURE_FLOW_CONTROL_BOTH:\n\t\tphy->req_flow_ctrl = BNX2X_FLOW_CTRL_BOTH;\n\t\tbreak;\n\tdefault:\n\t\tphy->req_flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\t\tbreak;\n\t}\n}\n\nu32 bnx2x_phy_selection(struct link_params *params)\n{\n\tu32 phy_config_swapped, prio_cfg;\n\tu32 return_cfg = PORT_HW_CFG_PHY_SELECTION_HARDWARE_DEFAULT;\n\n\tphy_config_swapped = params->multi_phy_config &\n\t\tPORT_HW_CFG_PHY_SWAPPED_ENABLED;\n\n\tprio_cfg = params->multi_phy_config &\n\t\t\tPORT_HW_CFG_PHY_SELECTION_MASK;\n\n\tif (phy_config_swapped) {\n\t\tswitch (prio_cfg) {\n\t\tcase PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY:\n\t\t     return_cfg = PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY;\n\t\t     break;\n\t\tcase PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY:\n\t\t     return_cfg = PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY;\n\t\t     break;\n\t\tcase PORT_HW_CFG_PHY_SELECTION_SECOND_PHY:\n\t\t     return_cfg = PORT_HW_CFG_PHY_SELECTION_FIRST_PHY;\n\t\t     break;\n\t\tcase PORT_HW_CFG_PHY_SELECTION_FIRST_PHY:\n\t\t     return_cfg = PORT_HW_CFG_PHY_SELECTION_SECOND_PHY;\n\t\t     break;\n\t\t}\n\t} else\n\t\treturn_cfg = prio_cfg;\n\n\treturn return_cfg;\n}\n\nint bnx2x_phy_probe(struct link_params *params)\n{\n\tu8 phy_index, actual_phy_idx;\n\tu32 phy_config_swapped, sync_offset, media_types;\n\tstruct bnx2x *bp = params->bp;\n\tstruct bnx2x_phy *phy;\n\tparams->num_phys = 0;\n\tDP(NETIF_MSG_LINK, \"Begin phy probe\\n\");\n\tphy_config_swapped = params->multi_phy_config &\n\t\tPORT_HW_CFG_PHY_SWAPPED_ENABLED;\n\n\tfor (phy_index = INT_PHY; phy_index < MAX_PHYS;\n\t      phy_index++) {\n\t\tactual_phy_idx = phy_index;\n\t\tif (phy_config_swapped) {\n\t\t\tif (phy_index == EXT_PHY1)\n\t\t\t\tactual_phy_idx = EXT_PHY2;\n\t\t\telse if (phy_index == EXT_PHY2)\n\t\t\t\tactual_phy_idx = EXT_PHY1;\n\t\t}\n\t\tDP(NETIF_MSG_LINK, \"phy_config_swapped %x, phy_index %x,\"\n\t\t\t       \" actual_phy_idx %x\\n\", phy_config_swapped,\n\t\t\t   phy_index, actual_phy_idx);\n\t\tphy = &params->phy[actual_phy_idx];\n\t\tif (bnx2x_populate_phy(bp, phy_index, params->shmem_base,\n\t\t\t\t       params->shmem2_base, params->port,\n\t\t\t\t       phy) != 0) {\n\t\t\tparams->num_phys = 0;\n\t\t\tDP(NETIF_MSG_LINK, \"phy probe failed in phy index %d\\n\",\n\t\t\t\t   phy_index);\n\t\t\tfor (phy_index = INT_PHY;\n\t\t\t      phy_index < MAX_PHYS;\n\t\t\t      phy_index++)\n\t\t\t\t*phy = phy_null;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN)\n\t\t\tbreak;\n\n\t\tif (params->feature_config_flags &\n\t\t    FEATURE_CONFIG_DISABLE_REMOTE_FAULT_DET)\n\t\t\tphy->flags &= ~FLAGS_TX_ERROR_CHECK;\n\n\t\tif (!(params->feature_config_flags &\n\t\t      FEATURE_CONFIG_MT_SUPPORT))\n\t\t\tphy->flags |= FLAGS_MDC_MDIO_WA_G;\n\n\t\tsync_offset = params->shmem_base +\n\t\t\toffsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[params->port].media_type);\n\t\tmedia_types = REG_RD(bp, sync_offset);\n\n\t\t/* Update media type for non-PMF sync only for the first time\n\t\t * In case the media type changes afterwards, it will be updated\n\t\t * using the update_status function\n\t\t */\n\t\tif ((media_types & (PORT_HW_CFG_MEDIA_TYPE_PHY0_MASK <<\n\t\t\t\t    (PORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT *\n\t\t\t\t     actual_phy_idx))) == 0) {\n\t\t\tmedia_types |= ((phy->media_type &\n\t\t\t\t\tPORT_HW_CFG_MEDIA_TYPE_PHY0_MASK) <<\n\t\t\t\t(PORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT *\n\t\t\t\t actual_phy_idx));\n\t\t}\n\t\tREG_WR(bp, sync_offset, media_types);\n\n\t\tbnx2x_phy_def_cfg(params, phy, phy_index);\n\t\tparams->num_phys++;\n\t}\n\n\tDP(NETIF_MSG_LINK, \"End phy probe. #phys found %x\\n\", params->num_phys);\n\treturn 0;\n}\n\nstatic void bnx2x_init_bmac_loopback(struct link_params *params,\n\t\t\t\t     struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tvars->link_up = 1;\n\tvars->line_speed = SPEED_10000;\n\tvars->duplex = DUPLEX_FULL;\n\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\tvars->mac_type = MAC_TYPE_BMAC;\n\n\tvars->phy_flags = PHY_XGXS_FLAG;\n\n\tbnx2x_xgxs_deassert(params);\n\n\t/* Set bmac loopback */\n\tbnx2x_bmac_enable(params, vars, 1, 1);\n\n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port * 4, 0);\n}\n\nstatic void bnx2x_init_emac_loopback(struct link_params *params,\n\t\t\t\t     struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tvars->link_up = 1;\n\tvars->line_speed = SPEED_1000;\n\tvars->duplex = DUPLEX_FULL;\n\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\tvars->mac_type = MAC_TYPE_EMAC;\n\n\tvars->phy_flags = PHY_XGXS_FLAG;\n\n\tbnx2x_xgxs_deassert(params);\n\t/* Set bmac loopback */\n\tbnx2x_emac_enable(params, vars, 1);\n\tbnx2x_emac_program(params, vars);\n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port * 4, 0);\n}\n\nstatic void bnx2x_init_xmac_loopback(struct link_params *params,\n\t\t\t\t     struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tvars->link_up = 1;\n\tif (!params->req_line_speed[0])\n\t\tvars->line_speed = SPEED_10000;\n\telse\n\t\tvars->line_speed = params->req_line_speed[0];\n\tvars->duplex = DUPLEX_FULL;\n\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\tvars->mac_type = MAC_TYPE_XMAC;\n\tvars->phy_flags = PHY_XGXS_FLAG;\n\t/* Set WC to loopback mode since link is required to provide clock\n\t * to the XMAC in 20G mode\n\t */\n\tbnx2x_set_aer_mmd(params, &params->phy[0]);\n\tbnx2x_warpcore_reset_lane(bp, &params->phy[0], 0);\n\tparams->phy[INT_PHY].config_loopback(\n\t\t\t&params->phy[INT_PHY],\n\t\t\tparams);\n\n\tbnx2x_xmac_enable(params, vars, 1);\n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\n}\n\nstatic void bnx2x_init_umac_loopback(struct link_params *params,\n\t\t\t\t     struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tvars->link_up = 1;\n\tvars->line_speed = SPEED_1000;\n\tvars->duplex = DUPLEX_FULL;\n\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\tvars->mac_type = MAC_TYPE_UMAC;\n\tvars->phy_flags = PHY_XGXS_FLAG;\n\tbnx2x_umac_enable(params, vars, 1);\n\n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\n}\n\nstatic void bnx2x_init_xgxs_loopback(struct link_params *params,\n\t\t\t\t     struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tstruct bnx2x_phy *int_phy = &params->phy[INT_PHY];\n\tvars->link_up = 1;\n\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\tvars->duplex = DUPLEX_FULL;\n\tif (params->req_line_speed[0] == SPEED_1000)\n\t\tvars->line_speed = SPEED_1000;\n\telse if ((params->req_line_speed[0] == SPEED_20000) ||\n\t\t (int_phy->flags & FLAGS_WC_DUAL_MODE))\n\t\tvars->line_speed = SPEED_20000;\n\telse\n\t\tvars->line_speed = SPEED_10000;\n\n\tif (!USES_WARPCORE(bp))\n\t\tbnx2x_xgxs_deassert(params);\n\tbnx2x_link_initialize(params, vars);\n\n\tif (params->req_line_speed[0] == SPEED_1000) {\n\t\tif (USES_WARPCORE(bp))\n\t\t\tbnx2x_umac_enable(params, vars, 0);\n\t\telse {\n\t\t\tbnx2x_emac_program(params, vars);\n\t\t\tbnx2x_emac_enable(params, vars, 0);\n\t\t}\n\t} else {\n\t\tif (USES_WARPCORE(bp))\n\t\t\tbnx2x_xmac_enable(params, vars, 0);\n\t\telse\n\t\t\tbnx2x_bmac_enable(params, vars, 0, 1);\n\t}\n\n\tif (params->loopback_mode == LOOPBACK_XGXS) {\n\t\t/* Set 10G XGXS loopback */\n\t\tint_phy->config_loopback(int_phy, params);\n\t} else {\n\t\t/* Set external phy loopback */\n\t\tu8 phy_index;\n\t\tfor (phy_index = EXT_PHY1;\n\t\t      phy_index < params->num_phys; phy_index++)\n\t\t\tif (params->phy[phy_index].config_loopback)\n\t\t\t\tparams->phy[phy_index].config_loopback(\n\t\t\t\t\t&params->phy[phy_index],\n\t\t\t\t\tparams);\n\t}\n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\n\n\tbnx2x_set_led(params, vars, LED_MODE_OPER, vars->line_speed);\n}\n\nvoid bnx2x_set_rx_filter(struct link_params *params, u8 en)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 val = en * 0x1F;\n\n\t/* Open / close the gate between the NIG and the BRB */\n\tif (!CHIP_IS_E1x(bp))\n\t\tval |= en * 0x20;\n\tREG_WR(bp, NIG_REG_LLH0_BRB1_DRV_MASK + params->port*4, val);\n\n\tif (!CHIP_IS_E1(bp)) {\n\t\tREG_WR(bp, NIG_REG_LLH0_BRB1_DRV_MASK_MF + params->port*4,\n\t\t       en*0x3);\n\t}\n\n\tREG_WR(bp, (params->port ? NIG_REG_LLH1_BRB1_NOT_MCP :\n\t\t    NIG_REG_LLH0_BRB1_NOT_MCP), en);\n}\nstatic int bnx2x_avoid_link_flap(struct link_params *params,\n\t\t\t\t\t    struct link_vars *vars)\n{\n\tu32 phy_idx;\n\tu32 dont_clear_stat, lfa_sts;\n\tstruct bnx2x *bp = params->bp;\n\n\tbnx2x_set_mdio_emac_per_phy(bp, params);\n\t/* Sync the link parameters */\n\tbnx2x_link_status_update(params, vars);\n\n\t/*\n\t * The module verification was already done by previous link owner,\n\t * so this call is meant only to get warning message\n\t */\n\n\tfor (phy_idx = INT_PHY; phy_idx < params->num_phys; phy_idx++) {\n\t\tstruct bnx2x_phy *phy = &params->phy[phy_idx];\n\t\tif (phy->phy_specific_func) {\n\t\t\tDP(NETIF_MSG_LINK, \"Calling PHY specific func\\n\");\n\t\t\tphy->phy_specific_func(phy, params, PHY_INIT);\n\t\t}\n\t\tif ((phy->media_type == ETH_PHY_SFPP_10G_FIBER) ||\n\t\t    (phy->media_type == ETH_PHY_SFP_1G_FIBER) ||\n\t\t    (phy->media_type == ETH_PHY_DA_TWINAX))\n\t\t\tbnx2x_verify_sfp_module(phy, params);\n\t}\n\tlfa_sts = REG_RD(bp, params->lfa_base +\n\t\t\t offsetof(struct shmem_lfa,\n\t\t\t\t  lfa_sts));\n\n\tdont_clear_stat = lfa_sts & SHMEM_LFA_DONT_CLEAR_STAT;\n\n\t/* Re-enable the NIG/MAC */\n\tif (CHIP_IS_E3(bp)) {\n\t\tif (!dont_clear_stat) {\n\t\t\tREG_WR(bp, GRCBASE_MISC +\n\t\t\t       MISC_REGISTERS_RESET_REG_2_CLEAR,\n\t\t\t       (MISC_REGISTERS_RESET_REG_2_MSTAT0 <<\n\t\t\t\tparams->port));\n\t\t\tREG_WR(bp, GRCBASE_MISC +\n\t\t\t       MISC_REGISTERS_RESET_REG_2_SET,\n\t\t\t       (MISC_REGISTERS_RESET_REG_2_MSTAT0 <<\n\t\t\t\tparams->port));\n\t\t}\n\t\tif (vars->line_speed < SPEED_10000)\n\t\t\tbnx2x_umac_enable(params, vars, 0);\n\t\telse\n\t\t\tbnx2x_xmac_enable(params, vars, 0);\n\t} else {\n\t\tif (vars->line_speed < SPEED_10000)\n\t\t\tbnx2x_emac_enable(params, vars, 0);\n\t\telse\n\t\t\tbnx2x_bmac_enable(params, vars, 0, !dont_clear_stat);\n\t}\n\n\t/* Increment LFA count */\n\tlfa_sts = ((lfa_sts & ~LINK_FLAP_AVOIDANCE_COUNT_MASK) |\n\t\t   (((((lfa_sts & LINK_FLAP_AVOIDANCE_COUNT_MASK) >>\n\t\t       LINK_FLAP_AVOIDANCE_COUNT_OFFSET) + 1) & 0xff)\n\t\t    << LINK_FLAP_AVOIDANCE_COUNT_OFFSET));\n\t/* Clear link flap reason */\n\tlfa_sts &= ~LFA_LINK_FLAP_REASON_MASK;\n\n\tREG_WR(bp, params->lfa_base +\n\t       offsetof(struct shmem_lfa, lfa_sts), lfa_sts);\n\n\t/* Disable NIG DRAIN */\n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\n\n\t/* Enable interrupts */\n\tbnx2x_link_int_enable(params);\n\treturn 0;\n}\n\nstatic void bnx2x_cannot_avoid_link_flap(struct link_params *params,\n\t\t\t\t\t struct link_vars *vars,\n\t\t\t\t\t int lfa_status)\n{\n\tu32 lfa_sts, cfg_idx, tmp_val;\n\tstruct bnx2x *bp = params->bp;\n\n\tbnx2x_link_reset(params, vars, 1);\n\n\tif (!params->lfa_base)\n\t\treturn;\n\t/* Store the new link parameters */\n\tREG_WR(bp, params->lfa_base +\n\t       offsetof(struct shmem_lfa, req_duplex),\n\t       params->req_duplex[0] | (params->req_duplex[1] << 16));\n\n\tREG_WR(bp, params->lfa_base +\n\t       offsetof(struct shmem_lfa, req_flow_ctrl),\n\t       params->req_flow_ctrl[0] | (params->req_flow_ctrl[1] << 16));\n\n\tREG_WR(bp, params->lfa_base +\n\t       offsetof(struct shmem_lfa, req_line_speed),\n\t       params->req_line_speed[0] | (params->req_line_speed[1] << 16));\n\n\tfor (cfg_idx = 0; cfg_idx < SHMEM_LINK_CONFIG_SIZE; cfg_idx++) {\n\t\tREG_WR(bp, params->lfa_base +\n\t\t       offsetof(struct shmem_lfa,\n\t\t\t\tspeed_cap_mask[cfg_idx]),\n\t\t       params->speed_cap_mask[cfg_idx]);\n\t}\n\n\ttmp_val = REG_RD(bp, params->lfa_base +\n\t\t\t offsetof(struct shmem_lfa, additional_config));\n\ttmp_val &= ~REQ_FC_AUTO_ADV_MASK;\n\ttmp_val |= params->req_fc_auto_adv;\n\n\tREG_WR(bp, params->lfa_base +\n\t       offsetof(struct shmem_lfa, additional_config), tmp_val);\n\n\tlfa_sts = REG_RD(bp, params->lfa_base +\n\t\t\t offsetof(struct shmem_lfa, lfa_sts));\n\n\t/* Clear the \"Don't Clear Statistics\" bit, and set reason */\n\tlfa_sts &= ~SHMEM_LFA_DONT_CLEAR_STAT;\n\n\t/* Set link flap reason */\n\tlfa_sts &= ~LFA_LINK_FLAP_REASON_MASK;\n\tlfa_sts |= ((lfa_status & LFA_LINK_FLAP_REASON_MASK) <<\n\t\t    LFA_LINK_FLAP_REASON_OFFSET);\n\n\t/* Increment link flap counter */\n\tlfa_sts = ((lfa_sts & ~LINK_FLAP_COUNT_MASK) |\n\t\t   (((((lfa_sts & LINK_FLAP_COUNT_MASK) >>\n\t\t       LINK_FLAP_COUNT_OFFSET) + 1) & 0xff)\n\t\t    << LINK_FLAP_COUNT_OFFSET));\n\tREG_WR(bp, params->lfa_base +\n\t       offsetof(struct shmem_lfa, lfa_sts), lfa_sts);\n\t/* Proceed with regular link initialization */\n}\n\nint bnx2x_phy_init(struct link_params *params, struct link_vars *vars)\n{\n\tint lfa_status;\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"Phy Initialization started\\n\");\n\tDP(NETIF_MSG_LINK, \"(1) req_speed %d, req_flowctrl %d\\n\",\n\t\t   params->req_line_speed[0], params->req_flow_ctrl[0]);\n\tDP(NETIF_MSG_LINK, \"(2) req_speed %d, req_flowctrl %d\\n\",\n\t\t   params->req_line_speed[1], params->req_flow_ctrl[1]);\n\tDP(NETIF_MSG_LINK, \"req_adv_flow_ctrl 0x%x\\n\", params->req_fc_auto_adv);\n\tvars->link_status = 0;\n\tvars->phy_link_up = 0;\n\tvars->link_up = 0;\n\tvars->line_speed = 0;\n\tvars->duplex = DUPLEX_FULL;\n\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\tvars->mac_type = MAC_TYPE_NONE;\n\tvars->phy_flags = 0;\n\tvars->check_kr2_recovery_cnt = 0;\n\tparams->link_flags = PHY_INITIALIZED;\n\t/* Driver opens NIG-BRB filters */\n\tbnx2x_set_rx_filter(params, 1);\n\tbnx2x_chng_link_count(params, true);\n\t/* Check if link flap can be avoided */\n\tlfa_status = bnx2x_check_lfa(params);\n\n\tif (lfa_status == 0) {\n\t\tDP(NETIF_MSG_LINK, \"Link Flap Avoidance in progress\\n\");\n\t\treturn bnx2x_avoid_link_flap(params, vars);\n\t}\n\n\tDP(NETIF_MSG_LINK, \"Cannot avoid link flap lfa_sta=0x%x\\n\",\n\t\t       lfa_status);\n\tbnx2x_cannot_avoid_link_flap(params, vars, lfa_status);\n\n\t/* Disable attentions */\n\tbnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 + params->port*4,\n\t\t       (NIG_MASK_XGXS0_LINK_STATUS |\n\t\t\tNIG_MASK_XGXS0_LINK10G |\n\t\t\tNIG_MASK_SERDES0_LINK_STATUS |\n\t\t\tNIG_MASK_MI_INT));\n\n\tbnx2x_emac_init(params, vars);\n\n\tif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED)\n\t\tvars->link_status |= LINK_STATUS_PFC_ENABLED;\n\n\tif (params->num_phys == 0) {\n\t\tDP(NETIF_MSG_LINK, \"No phy found for initialization !!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tset_phy_vars(params, vars);\n\n\tDP(NETIF_MSG_LINK, \"Num of phys on board: %d\\n\", params->num_phys);\n\tswitch (params->loopback_mode) {\n\tcase LOOPBACK_BMAC:\n\t\tbnx2x_init_bmac_loopback(params, vars);\n\t\tbreak;\n\tcase LOOPBACK_EMAC:\n\t\tbnx2x_init_emac_loopback(params, vars);\n\t\tbreak;\n\tcase LOOPBACK_XMAC:\n\t\tbnx2x_init_xmac_loopback(params, vars);\n\t\tbreak;\n\tcase LOOPBACK_UMAC:\n\t\tbnx2x_init_umac_loopback(params, vars);\n\t\tbreak;\n\tcase LOOPBACK_XGXS:\n\tcase LOOPBACK_EXT_PHY:\n\t\tbnx2x_init_xgxs_loopback(params, vars);\n\t\tbreak;\n\tdefault:\n\t\tif (!CHIP_IS_E3(bp)) {\n\t\t\tif (params->switch_cfg == SWITCH_CFG_10G)\n\t\t\t\tbnx2x_xgxs_deassert(params);\n\t\t\telse\n\t\t\t\tbnx2x_serdes_deassert(bp, params->port);\n\t\t}\n\t\tbnx2x_link_initialize(params, vars);\n\t\tmsleep(30);\n\t\tbnx2x_link_int_enable(params);\n\t\tbreak;\n\t}\n\tbnx2x_update_mng(params, vars->link_status);\n\n\tbnx2x_update_mng_eee(params, vars->eee_status);\n\treturn 0;\n}\n\nint bnx2x_link_reset(struct link_params *params, struct link_vars *vars,\n\t\t     u8 reset_ext_phy)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 phy_index, port = params->port, clear_latch_ind = 0;\n\tDP(NETIF_MSG_LINK, \"Resetting the link of port %d\\n\", port);\n\t/* Disable attentions */\n\tvars->link_status = 0;\n\tbnx2x_chng_link_count(params, true);\n\tbnx2x_update_mng(params, vars->link_status);\n\tvars->eee_status &= ~(SHMEM_EEE_LP_ADV_STATUS_MASK |\n\t\t\t      SHMEM_EEE_ACTIVE_BIT);\n\tbnx2x_update_mng_eee(params, vars->eee_status);\n\tbnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4,\n\t\t       (NIG_MASK_XGXS0_LINK_STATUS |\n\t\t\tNIG_MASK_XGXS0_LINK10G |\n\t\t\tNIG_MASK_SERDES0_LINK_STATUS |\n\t\t\tNIG_MASK_MI_INT));\n\n\t/* Activate nig drain */\n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + port*4, 1);\n\n\t/* Disable nig egress interface */\n\tif (!CHIP_IS_E3(bp)) {\n\t\tREG_WR(bp, NIG_REG_BMAC0_OUT_EN + port*4, 0);\n\t\tREG_WR(bp, NIG_REG_EGRESS_EMAC0_OUT_EN + port*4, 0);\n\t}\n\n\tif (!CHIP_IS_E3(bp)) {\n\t\tbnx2x_set_bmac_rx(bp, params->chip_id, port, 0);\n\t} else {\n\t\tbnx2x_set_xmac_rxtx(params, 0);\n\t\tbnx2x_set_umac_rxtx(params, 0);\n\t}\n\t/* Disable emac */\n\tif (!CHIP_IS_E3(bp))\n\t\tREG_WR(bp, NIG_REG_NIG_EMAC0_EN + port*4, 0);\n\n\tusleep_range(10000, 20000);\n\t/* The PHY reset is controlled by GPIO 1\n\t * Hold it as vars low\n\t */\n\t /* Clear link led */\n\tbnx2x_set_mdio_emac_per_phy(bp, params);\n\tbnx2x_set_led(params, vars, LED_MODE_OFF, 0);\n\n\tif (reset_ext_phy) {\n\t\tfor (phy_index = EXT_PHY1; phy_index < params->num_phys;\n\t\t      phy_index++) {\n\t\t\tif (params->phy[phy_index].link_reset) {\n\t\t\t\tbnx2x_set_aer_mmd(params,\n\t\t\t\t\t\t  &params->phy[phy_index]);\n\t\t\t\tparams->phy[phy_index].link_reset(\n\t\t\t\t\t&params->phy[phy_index],\n\t\t\t\t\tparams);\n\t\t\t}\n\t\t\tif (params->phy[phy_index].flags &\n\t\t\t    FLAGS_REARM_LATCH_SIGNAL)\n\t\t\t\tclear_latch_ind = 1;\n\t\t}\n\t}\n\n\tif (clear_latch_ind) {\n\t\t/* Clear latching indication */\n\t\tbnx2x_rearm_latch_signal(bp, port, 0);\n\t\tbnx2x_bits_dis(bp, NIG_REG_LATCH_BC_0 + port*4,\n\t\t\t       1 << NIG_LATCH_BC_ENABLE_MI_INT);\n\t}\n\tif (params->phy[INT_PHY].link_reset)\n\t\tparams->phy[INT_PHY].link_reset(\n\t\t\t&params->phy[INT_PHY], params);\n\n\t/* Disable nig ingress interface */\n\tif (!CHIP_IS_E3(bp)) {\n\t\t/* Reset BigMac */\n\t\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\n\t\t       (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port));\n\t\tREG_WR(bp, NIG_REG_BMAC0_IN_EN + port*4, 0);\n\t\tREG_WR(bp, NIG_REG_EMAC0_IN_EN + port*4, 0);\n\t} else {\n\t\tu32 xmac_base = (params->port) ? GRCBASE_XMAC1 : GRCBASE_XMAC0;\n\t\tbnx2x_set_xumac_nig(params, 0, 0);\n\t\tif (REG_RD(bp, MISC_REG_RESET_REG_2) &\n\t\t    MISC_REGISTERS_RESET_REG_2_XMAC)\n\t\t\tREG_WR(bp, xmac_base + XMAC_REG_CTRL,\n\t\t\t       XMAC_CTRL_REG_SOFT_RESET);\n\t}\n\tvars->link_up = 0;\n\tvars->phy_flags = 0;\n\treturn 0;\n}\nint bnx2x_lfa_reset(struct link_params *params,\n\t\t\t       struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tvars->link_up = 0;\n\tvars->phy_flags = 0;\n\tparams->link_flags &= ~PHY_INITIALIZED;\n\tif (!params->lfa_base)\n\t\treturn bnx2x_link_reset(params, vars, 1);\n\t/*\n\t * Activate NIG drain so that during this time the device won't send\n\t * anything while it is unable to response.\n\t */\n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 1);\n\n\t/*\n\t * Close gracefully the gate from BMAC to NIG such that no half packets\n\t * are passed.\n\t */\n\tif (!CHIP_IS_E3(bp))\n\t\tbnx2x_set_bmac_rx(bp, params->chip_id, params->port, 0);\n\n\tif (CHIP_IS_E3(bp)) {\n\t\tbnx2x_set_xmac_rxtx(params, 0);\n\t\tbnx2x_set_umac_rxtx(params, 0);\n\t}\n\t/* Wait 10ms for the pipe to clean up*/\n\tusleep_range(10000, 20000);\n\n\t/* Clean the NIG-BRB using the network filters in a way that will\n\t * not cut a packet in the middle.\n\t */\n\tbnx2x_set_rx_filter(params, 0);\n\n\t/*\n\t * Re-open the gate between the BMAC and the NIG, after verifying the\n\t * gate to the BRB is closed, otherwise packets may arrive to the\n\t * firmware before driver had initialized it. The target is to achieve\n\t * minimum management protocol down time.\n\t */\n\tif (!CHIP_IS_E3(bp))\n\t\tbnx2x_set_bmac_rx(bp, params->chip_id, params->port, 1);\n\n\tif (CHIP_IS_E3(bp)) {\n\t\tbnx2x_set_xmac_rxtx(params, 1);\n\t\tbnx2x_set_umac_rxtx(params, 1);\n\t}\n\t/* Disable NIG drain */\n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\n\treturn 0;\n}\n\n/****************************************************************************/\n/*\t\t\t\tCommon function\t\t\t\t    */\n/****************************************************************************/\nstatic int bnx2x_8073_common_init_phy(struct bnx2x *bp,\n\t\t\t\t      u32 shmem_base_path[],\n\t\t\t\t      u32 shmem2_base_path[], u8 phy_index,\n\t\t\t\t      u32 chip_id)\n{\n\tstruct bnx2x_phy phy[PORT_MAX];\n\tstruct bnx2x_phy *phy_blk[PORT_MAX];\n\tu16 val;\n\ts8 port = 0;\n\ts8 port_of_path = 0;\n\tu32 swap_val, swap_override;\n\tswap_val = REG_RD(bp,  NIG_REG_PORT_SWAP);\n\tswap_override = REG_RD(bp,  NIG_REG_STRAP_OVERRIDE);\n\tport ^= (swap_val && swap_override);\n\tbnx2x_ext_phy_hw_reset(bp, port);\n\t/* PART1 - Reset both phys */\n\tfor (port = PORT_MAX - 1; port >= PORT_0; port--) {\n\t\tu32 shmem_base, shmem2_base;\n\t\t/* In E2, same phy is using for port0 of the two paths */\n\t\tif (CHIP_IS_E1x(bp)) {\n\t\t\tshmem_base = shmem_base_path[0];\n\t\t\tshmem2_base = shmem2_base_path[0];\n\t\t\tport_of_path = port;\n\t\t} else {\n\t\t\tshmem_base = shmem_base_path[port];\n\t\t\tshmem2_base = shmem2_base_path[port];\n\t\t\tport_of_path = 0;\n\t\t}\n\n\t\t/* Extract the ext phy address for the port */\n\t\tif (bnx2x_populate_phy(bp, phy_index, shmem_base, shmem2_base,\n\t\t\t\t       port_of_path, &phy[port]) !=\n\t\t    0) {\n\t\t\tDP(NETIF_MSG_LINK, \"populate_phy failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* Disable attentions */\n\t\tbnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 +\n\t\t\t       port_of_path*4,\n\t\t\t       (NIG_MASK_XGXS0_LINK_STATUS |\n\t\t\t\tNIG_MASK_XGXS0_LINK10G |\n\t\t\t\tNIG_MASK_SERDES0_LINK_STATUS |\n\t\t\t\tNIG_MASK_MI_INT));\n\n\t\t/* Need to take the phy out of low power mode in order\n\t\t * to write to access its registers\n\t\t */\n\t\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH,\n\t\t\t       port);\n\n\t\t/* Reset the phy */\n\t\tbnx2x_cl45_write(bp, &phy[port],\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_CTRL,\n\t\t\t\t 1<<15);\n\t}\n\n\t/* Add delay of 150ms after reset */\n\tmsleep(150);\n\n\tif (phy[PORT_0].addr & 0x1) {\n\t\tphy_blk[PORT_0] = &(phy[PORT_1]);\n\t\tphy_blk[PORT_1] = &(phy[PORT_0]);\n\t} else {\n\t\tphy_blk[PORT_0] = &(phy[PORT_0]);\n\t\tphy_blk[PORT_1] = &(phy[PORT_1]);\n\t}\n\n\t/* PART2 - Download firmware to both phys */\n\tfor (port = PORT_MAX - 1; port >= PORT_0; port--) {\n\t\tif (CHIP_IS_E1x(bp))\n\t\t\tport_of_path = port;\n\t\telse\n\t\t\tport_of_path = 0;\n\n\t\tDP(NETIF_MSG_LINK, \"Loading spirom for phy address 0x%x\\n\",\n\t\t\t   phy_blk[port]->addr);\n\t\tif (bnx2x_8073_8727_external_rom_boot(bp, phy_blk[port],\n\t\t\t\t\t\t      port_of_path))\n\t\t\treturn -EINVAL;\n\n\t\t/* Only set bit 10 = 1 (Tx power down) */\n\t\tbnx2x_cl45_read(bp, phy_blk[port],\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_TX_POWER_DOWN, &val);\n\n\t\t/* Phase1 of TX_POWER_DOWN reset */\n\t\tbnx2x_cl45_write(bp, phy_blk[port],\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_TX_POWER_DOWN,\n\t\t\t\t (val | 1<<10));\n\t}\n\n\t/* Toggle Transmitter: Power down and then up with 600ms delay\n\t * between\n\t */\n\tmsleep(600);\n\n\t/* PART3 - complete TX_POWER_DOWN process, and set GPIO2 back to low */\n\tfor (port = PORT_MAX - 1; port >= PORT_0; port--) {\n\t\t/* Phase2 of POWER_DOWN_RESET */\n\t\t/* Release bit 10 (Release Tx power down) */\n\t\tbnx2x_cl45_read(bp, phy_blk[port],\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_TX_POWER_DOWN, &val);\n\n\t\tbnx2x_cl45_write(bp, phy_blk[port],\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_TX_POWER_DOWN, (val & (~(1<<10))));\n\t\tusleep_range(15000, 30000);\n\n\t\t/* Read modify write the SPI-ROM version select register */\n\t\tbnx2x_cl45_read(bp, phy_blk[port],\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_EDC_FFE_MAIN, &val);\n\t\tbnx2x_cl45_write(bp, phy_blk[port],\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_EDC_FFE_MAIN, (val | (1<<12)));\n\n\t\t/* set GPIO2 back to LOW */\n\t\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW, port);\n\t}\n\treturn 0;\n}\nstatic int bnx2x_8726_common_init_phy(struct bnx2x *bp,\n\t\t\t\t      u32 shmem_base_path[],\n\t\t\t\t      u32 shmem2_base_path[], u8 phy_index,\n\t\t\t\t      u32 chip_id)\n{\n\tu32 val;\n\ts8 port;\n\tstruct bnx2x_phy phy;\n\t/* Use port1 because of the static port-swap */\n\t/* Enable the module detection interrupt */\n\tval = REG_RD(bp, MISC_REG_GPIO_EVENT_EN);\n\tval |= ((1<<MISC_REGISTERS_GPIO_3)|\n\t\t(1<<(MISC_REGISTERS_GPIO_3 + MISC_REGISTERS_GPIO_PORT_SHIFT)));\n\tREG_WR(bp, MISC_REG_GPIO_EVENT_EN, val);\n\n\tbnx2x_ext_phy_hw_reset(bp, 0);\n\tusleep_range(5000, 10000);\n\tfor (port = 0; port < PORT_MAX; port++) {\n\t\tu32 shmem_base, shmem2_base;\n\n\t\t/* In E2, same phy is using for port0 of the two paths */\n\t\tif (CHIP_IS_E1x(bp)) {\n\t\t\tshmem_base = shmem_base_path[0];\n\t\t\tshmem2_base = shmem2_base_path[0];\n\t\t} else {\n\t\t\tshmem_base = shmem_base_path[port];\n\t\t\tshmem2_base = shmem2_base_path[port];\n\t\t}\n\t\t/* Extract the ext phy address for the port */\n\t\tif (bnx2x_populate_phy(bp, phy_index, shmem_base, shmem2_base,\n\t\t\t\t       port, &phy) !=\n\t\t    0) {\n\t\t\tDP(NETIF_MSG_LINK, \"populate phy failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Reset phy*/\n\t\tbnx2x_cl45_write(bp, &phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_GEN_CTRL, 0x0001);\n\n\n\t\t/* Set fault module detected LED on */\n\t\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_0,\n\t\t\t       MISC_REGISTERS_GPIO_HIGH,\n\t\t\t       port);\n\t}\n\n\treturn 0;\n}\nstatic void bnx2x_get_ext_phy_reset_gpio(struct bnx2x *bp, u32 shmem_base,\n\t\t\t\t\t u8 *io_gpio, u8 *io_port)\n{\n\n\tu32 phy_gpio_reset = REG_RD(bp, shmem_base +\n\t\t\t\t\t  offsetof(struct shmem_region,\n\t\t\t\tdev_info.port_hw_config[PORT_0].default_cfg));\n\tswitch (phy_gpio_reset) {\n\tcase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO0_P0:\n\t\t*io_gpio = 0;\n\t\t*io_port = 0;\n\t\tbreak;\n\tcase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO1_P0:\n\t\t*io_gpio = 1;\n\t\t*io_port = 0;\n\t\tbreak;\n\tcase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO2_P0:\n\t\t*io_gpio = 2;\n\t\t*io_port = 0;\n\t\tbreak;\n\tcase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO3_P0:\n\t\t*io_gpio = 3;\n\t\t*io_port = 0;\n\t\tbreak;\n\tcase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO0_P1:\n\t\t*io_gpio = 0;\n\t\t*io_port = 1;\n\t\tbreak;\n\tcase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO1_P1:\n\t\t*io_gpio = 1;\n\t\t*io_port = 1;\n\t\tbreak;\n\tcase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO2_P1:\n\t\t*io_gpio = 2;\n\t\t*io_port = 1;\n\t\tbreak;\n\tcase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO3_P1:\n\t\t*io_gpio = 3;\n\t\t*io_port = 1;\n\t\tbreak;\n\tdefault:\n\t\t/* Don't override the io_gpio and io_port */\n\t\tbreak;\n\t}\n}\n\nstatic int bnx2x_8727_common_init_phy(struct bnx2x *bp,\n\t\t\t\t      u32 shmem_base_path[],\n\t\t\t\t      u32 shmem2_base_path[], u8 phy_index,\n\t\t\t\t      u32 chip_id)\n{\n\ts8 port, reset_gpio;\n\tu32 swap_val, swap_override;\n\tstruct bnx2x_phy phy[PORT_MAX];\n\tstruct bnx2x_phy *phy_blk[PORT_MAX];\n\ts8 port_of_path;\n\tswap_val = REG_RD(bp, NIG_REG_PORT_SWAP);\n\tswap_override = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);\n\n\treset_gpio = MISC_REGISTERS_GPIO_1;\n\tport = 1;\n\n\t/* Retrieve the reset gpio/port which control the reset.\n\t * Default is GPIO1, PORT1\n\t */\n\tbnx2x_get_ext_phy_reset_gpio(bp, shmem_base_path[0],\n\t\t\t\t     (u8 *)&reset_gpio, (u8 *)&port);\n\n\t/* Calculate the port based on port swap */\n\tport ^= (swap_val && swap_override);\n\n\t/* Initiate PHY reset*/\n\tbnx2x_set_gpio(bp, reset_gpio, MISC_REGISTERS_GPIO_OUTPUT_LOW,\n\t\t       port);\n\tusleep_range(1000, 2000);\n\tbnx2x_set_gpio(bp, reset_gpio, MISC_REGISTERS_GPIO_OUTPUT_HIGH,\n\t\t       port);\n\n\tusleep_range(5000, 10000);\n\n\t/* PART1 - Reset both phys */\n\tfor (port = PORT_MAX - 1; port >= PORT_0; port--) {\n\t\tu32 shmem_base, shmem2_base;\n\n\t\t/* In E2, same phy is using for port0 of the two paths */\n\t\tif (CHIP_IS_E1x(bp)) {\n\t\t\tshmem_base = shmem_base_path[0];\n\t\t\tshmem2_base = shmem2_base_path[0];\n\t\t\tport_of_path = port;\n\t\t} else {\n\t\t\tshmem_base = shmem_base_path[port];\n\t\t\tshmem2_base = shmem2_base_path[port];\n\t\t\tport_of_path = 0;\n\t\t}\n\n\t\t/* Extract the ext phy address for the port */\n\t\tif (bnx2x_populate_phy(bp, phy_index, shmem_base, shmem2_base,\n\t\t\t\t       port_of_path, &phy[port]) !=\n\t\t\t\t       0) {\n\t\t\tDP(NETIF_MSG_LINK, \"populate phy failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* disable attentions */\n\t\tbnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 +\n\t\t\t       port_of_path*4,\n\t\t\t       (NIG_MASK_XGXS0_LINK_STATUS |\n\t\t\t\tNIG_MASK_XGXS0_LINK10G |\n\t\t\t\tNIG_MASK_SERDES0_LINK_STATUS |\n\t\t\t\tNIG_MASK_MI_INT));\n\n\n\t\t/* Reset the phy */\n\t\tbnx2x_cl45_write(bp, &phy[port],\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 1<<15);\n\t}\n\n\t/* Add delay of 150ms after reset */\n\tmsleep(150);\n\tif (phy[PORT_0].addr & 0x1) {\n\t\tphy_blk[PORT_0] = &(phy[PORT_1]);\n\t\tphy_blk[PORT_1] = &(phy[PORT_0]);\n\t} else {\n\t\tphy_blk[PORT_0] = &(phy[PORT_0]);\n\t\tphy_blk[PORT_1] = &(phy[PORT_1]);\n\t}\n\t/* PART2 - Download firmware to both phys */\n\tfor (port = PORT_MAX - 1; port >= PORT_0; port--) {\n\t\tif (CHIP_IS_E1x(bp))\n\t\t\tport_of_path = port;\n\t\telse\n\t\t\tport_of_path = 0;\n\t\tDP(NETIF_MSG_LINK, \"Loading spirom for phy address 0x%x\\n\",\n\t\t\t   phy_blk[port]->addr);\n\t\tif (bnx2x_8073_8727_external_rom_boot(bp, phy_blk[port],\n\t\t\t\t\t\t      port_of_path))\n\t\t\treturn -EINVAL;\n\t\t/* Disable PHY transmitter output */\n\t\tbnx2x_cl45_write(bp, phy_blk[port],\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_TX_DISABLE, 1);\n\n\t}\n\treturn 0;\n}\n\nstatic int bnx2x_84833_common_init_phy(struct bnx2x *bp,\n\t\t\t\t\t\tu32 shmem_base_path[],\n\t\t\t\t\t\tu32 shmem2_base_path[],\n\t\t\t\t\t\tu8 phy_index,\n\t\t\t\t\t\tu32 chip_id)\n{\n\tu8 reset_gpios;\n\treset_gpios = bnx2x_84833_get_reset_gpios(bp, shmem_base_path, chip_id);\n\tbnx2x_set_mult_gpio(bp, reset_gpios, MISC_REGISTERS_GPIO_OUTPUT_LOW);\n\tudelay(10);\n\tbnx2x_set_mult_gpio(bp, reset_gpios, MISC_REGISTERS_GPIO_OUTPUT_HIGH);\n\tDP(NETIF_MSG_LINK, \"84833 reset pulse on pin values 0x%x\\n\",\n\t\treset_gpios);\n\treturn 0;\n}\n\nstatic int bnx2x_ext_phy_common_init(struct bnx2x *bp, u32 shmem_base_path[],\n\t\t\t\t     u32 shmem2_base_path[], u8 phy_index,\n\t\t\t\t     u32 ext_phy_type, u32 chip_id)\n{\n\tint rc = 0;\n\n\tswitch (ext_phy_type) {\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073:\n\t\trc = bnx2x_8073_common_init_phy(bp, shmem_base_path,\n\t\t\t\t\t\tshmem2_base_path,\n\t\t\t\t\t\tphy_index, chip_id);\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727_NOC:\n\t\trc = bnx2x_8727_common_init_phy(bp, shmem_base_path,\n\t\t\t\t\t\tshmem2_base_path,\n\t\t\t\t\t\tphy_index, chip_id);\n\t\tbreak;\n\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:\n\t\t/* GPIO1 affects both ports, so there's need to pull\n\t\t * it for single port alone\n\t\t */\n\t\trc = bnx2x_8726_common_init_phy(bp, shmem_base_path,\n\t\t\t\t\t\tshmem2_base_path,\n\t\t\t\t\t\tphy_index, chip_id);\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858:\n\t\t/* GPIO3's are linked, and so both need to be toggled\n\t\t * to obtain required 2us pulse.\n\t\t */\n\t\trc = bnx2x_84833_common_init_phy(bp, shmem_base_path,\n\t\t\t\t\t\tshmem2_base_path,\n\t\t\t\t\t\tphy_index, chip_id);\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE:\n\t\trc = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"ext_phy 0x%x common init not required\\n\",\n\t\t\t   ext_phy_type);\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tnetdev_err(bp->dev,  \"Warning: PHY was not initialized,\"\n\t\t\t\t      \" Port %d\\n\",\n\t\t\t 0);\n\treturn rc;\n}\n\nint bnx2x_common_init_phy(struct bnx2x *bp, u32 shmem_base_path[],\n\t\t\t  u32 shmem2_base_path[], u32 chip_id)\n{\n\tint rc = 0;\n\tu32 phy_ver, val;\n\tu8 phy_index = 0;\n\tu32 ext_phy_type, ext_phy_config;\n\n\tbnx2x_set_mdio_clk(bp, chip_id, GRCBASE_EMAC0);\n\tbnx2x_set_mdio_clk(bp, chip_id, GRCBASE_EMAC1);\n\tDP(NETIF_MSG_LINK, \"Begin common phy init\\n\");\n\tif (CHIP_IS_E3(bp)) {\n\t\t/* Enable EPIO */\n\t\tval = REG_RD(bp, MISC_REG_GEN_PURP_HWG);\n\t\tREG_WR(bp, MISC_REG_GEN_PURP_HWG, val | 1);\n\t}\n\t/* Check if common init was already done */\n\tphy_ver = REG_RD(bp, shmem_base_path[0] +\n\t\t\t offsetof(struct shmem_region,\n\t\t\t\t  port_mb[PORT_0].ext_phy_fw_version));\n\tif (phy_ver) {\n\t\tDP(NETIF_MSG_LINK, \"Not doing common init; phy ver is 0x%x\\n\",\n\t\t\t       phy_ver);\n\t\treturn 0;\n\t}\n\n\t/* Read the ext_phy_type for arbitrary port(0) */\n\tfor (phy_index = EXT_PHY1; phy_index < MAX_PHYS;\n\t      phy_index++) {\n\t\text_phy_config = bnx2x_get_ext_phy_config(bp,\n\t\t\t\t\t\t\t  shmem_base_path[0],\n\t\t\t\t\t\t\t  phy_index, 0);\n\t\text_phy_type = XGXS_EXT_PHY_TYPE(ext_phy_config);\n\t\trc |= bnx2x_ext_phy_common_init(bp, shmem_base_path,\n\t\t\t\t\t\tshmem2_base_path,\n\t\t\t\t\t\tphy_index, ext_phy_type,\n\t\t\t\t\t\tchip_id);\n\t}\n\treturn rc;\n}\n\nstatic void bnx2x_check_over_curr(struct link_params *params,\n\t\t\t\t  struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 cfg_pin;\n\tu8 port = params->port;\n\tu32 pin_val;\n\n\tcfg_pin = (REG_RD(bp, params->shmem_base +\n\t\t\t  offsetof(struct shmem_region,\n\t\t\t       dev_info.port_hw_config[port].e3_cmn_pin_cfg1)) &\n\t\t   PORT_HW_CFG_E3_OVER_CURRENT_MASK) >>\n\t\tPORT_HW_CFG_E3_OVER_CURRENT_SHIFT;\n\n\t/* Ignore check if no external input PIN available */\n\tif (bnx2x_get_cfg_pin(bp, cfg_pin, &pin_val) != 0)\n\t\treturn;\n\n\tif (!pin_val) {\n\t\tif ((vars->phy_flags & PHY_OVER_CURRENT_FLAG) == 0) {\n\t\t\tnetdev_err(bp->dev, \"Error:  Power fault on Port %d has\"\n\t\t\t\t\t    \" been detected and the power to \"\n\t\t\t\t\t    \"that SFP+ module has been removed\"\n\t\t\t\t\t    \" to prevent failure of the card.\"\n\t\t\t\t\t    \" Please remove the SFP+ module and\"\n\t\t\t\t\t    \" restart the system to clear this\"\n\t\t\t\t\t    \" error.\\n\",\n\t\t\t params->port);\n\t\t\tvars->phy_flags |= PHY_OVER_CURRENT_FLAG;\n\t\t\tbnx2x_warpcore_power_module(params, 0);\n\t\t}\n\t} else\n\t\tvars->phy_flags &= ~PHY_OVER_CURRENT_FLAG;\n}\n\n/* Returns 0 if no change occurred since last check; 1 otherwise. */\nstatic u8 bnx2x_analyze_link_error(struct link_params *params,\n\t\t\t\t    struct link_vars *vars, u32 status,\n\t\t\t\t    u32 phy_flag, u32 link_flag, u8 notify)\n{\n\tstruct bnx2x *bp = params->bp;\n\t/* Compare new value with previous value */\n\tu8 led_mode;\n\tu32 old_status = (vars->phy_flags & phy_flag) ? 1 : 0;\n\n\tif ((status ^ old_status) == 0)\n\t\treturn 0;\n\n\t/* If values differ */\n\tswitch (phy_flag) {\n\tcase PHY_HALF_OPEN_CONN_FLAG:\n\t\tDP(NETIF_MSG_LINK, \"Analyze Remote Fault\\n\");\n\t\tbreak;\n\tcase PHY_SFP_TX_FAULT_FLAG:\n\t\tDP(NETIF_MSG_LINK, \"Analyze TX Fault\\n\");\n\t\tbreak;\n\tdefault:\n\t\tDP(NETIF_MSG_LINK, \"Analyze UNKNOWN\\n\");\n\t}\n\tDP(NETIF_MSG_LINK, \"Link changed:[%x %x]->%x\\n\", vars->link_up,\n\t   old_status, status);\n\n\t/* Do not touch the link in case physical link down */\n\tif ((vars->phy_flags & PHY_PHYSICAL_LINK_FLAG) == 0)\n\t\treturn 1;\n\n\t/* a. Update shmem->link_status accordingly\n\t * b. Update link_vars->link_up\n\t */\n\tif (status) {\n\t\tvars->link_status &= ~LINK_STATUS_LINK_UP;\n\t\tvars->link_status |= link_flag;\n\t\tvars->link_up = 0;\n\t\tvars->phy_flags |= phy_flag;\n\n\t\t/* activate nig drain */\n\t\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 1);\n\t\t/* Set LED mode to off since the PHY doesn't know about these\n\t\t * errors\n\t\t */\n\t\tled_mode = LED_MODE_OFF;\n\t} else {\n\t\tvars->link_status |= LINK_STATUS_LINK_UP;\n\t\tvars->link_status &= ~link_flag;\n\t\tvars->link_up = 1;\n\t\tvars->phy_flags &= ~phy_flag;\n\t\tled_mode = LED_MODE_OPER;\n\n\t\t/* Clear nig drain */\n\t\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\n\t}\n\tbnx2x_sync_link(params, vars);\n\t/* Update the LED according to the link state */\n\tbnx2x_set_led(params, vars, led_mode, SPEED_10000);\n\n\t/* Update link status in the shared memory */\n\tbnx2x_update_mng(params, vars->link_status);\n\n\t/* C. Trigger General Attention */\n\tvars->periodic_flags |= PERIODIC_FLAGS_LINK_EVENT;\n\tif (notify)\n\t\tbnx2x_notify_link_changed(bp);\n\n\treturn 1;\n}\n\n/******************************************************************************\n* Description:\n*\tThis function checks for half opened connection change indication.\n*\tWhen such change occurs, it calls the bnx2x_analyze_link_error\n*\tto check if Remote Fault is set or cleared. Reception of remote fault\n*\tstatus message in the MAC indicates that the peer's MAC has detected\n*\ta fault, for example, due to break in the TX side of fiber.\n*\n******************************************************************************/\nstatic int bnx2x_check_half_open_conn(struct link_params *params,\n\t\t\t\t      struct link_vars *vars,\n\t\t\t\t      u8 notify)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 lss_status = 0;\n\tu32 mac_base;\n\t/* In case link status is physically up @ 10G do */\n\tif (((vars->phy_flags & PHY_PHYSICAL_LINK_FLAG) == 0) ||\n\t    (REG_RD(bp, NIG_REG_EGRESS_EMAC0_PORT + params->port*4)))\n\t\treturn 0;\n\n\tif (CHIP_IS_E3(bp) &&\n\t    (REG_RD(bp, MISC_REG_RESET_REG_2) &\n\t      (MISC_REGISTERS_RESET_REG_2_XMAC))) {\n\t\t/* Check E3 XMAC */\n\t\t/* Note that link speed cannot be queried here, since it may be\n\t\t * zero while link is down. In case UMAC is active, LSS will\n\t\t * simply not be set\n\t\t */\n\t\tmac_base = (params->port) ? GRCBASE_XMAC1 : GRCBASE_XMAC0;\n\n\t\t/* Clear stick bits (Requires rising edge) */\n\t\tREG_WR(bp, mac_base + XMAC_REG_CLEAR_RX_LSS_STATUS, 0);\n\t\tREG_WR(bp, mac_base + XMAC_REG_CLEAR_RX_LSS_STATUS,\n\t\t       XMAC_CLEAR_RX_LSS_STATUS_REG_CLEAR_LOCAL_FAULT_STATUS |\n\t\t       XMAC_CLEAR_RX_LSS_STATUS_REG_CLEAR_REMOTE_FAULT_STATUS);\n\t\tif (REG_RD(bp, mac_base + XMAC_REG_RX_LSS_STATUS))\n\t\t\tlss_status = 1;\n\n\t\tbnx2x_analyze_link_error(params, vars, lss_status,\n\t\t\t\t\t PHY_HALF_OPEN_CONN_FLAG,\n\t\t\t\t\t LINK_STATUS_NONE, notify);\n\t} else if (REG_RD(bp, MISC_REG_RESET_REG_2) &\n\t\t   (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << params->port)) {\n\t\t/* Check E1X / E2 BMAC */\n\t\tu32 lss_status_reg;\n\t\tu32 wb_data[2];\n\t\tmac_base = params->port ? NIG_REG_INGRESS_BMAC1_MEM :\n\t\t\tNIG_REG_INGRESS_BMAC0_MEM;\n\t\t/*  Read BIGMAC_REGISTER_RX_LSS_STATUS */\n\t\tif (CHIP_IS_E2(bp))\n\t\t\tlss_status_reg = BIGMAC2_REGISTER_RX_LSS_STAT;\n\t\telse\n\t\t\tlss_status_reg = BIGMAC_REGISTER_RX_LSS_STATUS;\n\n\t\tREG_RD_DMAE(bp, mac_base + lss_status_reg, wb_data, 2);\n\t\tlss_status = (wb_data[0] > 0);\n\n\t\tbnx2x_analyze_link_error(params, vars, lss_status,\n\t\t\t\t\t PHY_HALF_OPEN_CONN_FLAG,\n\t\t\t\t\t LINK_STATUS_NONE, notify);\n\t}\n\treturn 0;\n}\nstatic void bnx2x_sfp_tx_fault_detection(struct bnx2x_phy *phy,\n\t\t\t\t\t struct link_params *params,\n\t\t\t\t\t struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 cfg_pin, value = 0;\n\tu8 led_change, port = params->port;\n\n\t/* Get The SFP+ TX_Fault controlling pin ([eg]pio) */\n\tcfg_pin = (REG_RD(bp, params->shmem_base + offsetof(struct shmem_region,\n\t\t\t  dev_info.port_hw_config[port].e3_cmn_pin_cfg)) &\n\t\t   PORT_HW_CFG_E3_TX_FAULT_MASK) >>\n\t\t  PORT_HW_CFG_E3_TX_FAULT_SHIFT;\n\n\tif (bnx2x_get_cfg_pin(bp, cfg_pin, &value)) {\n\t\tDP(NETIF_MSG_LINK, \"Failed to read pin 0x%02x\\n\", cfg_pin);\n\t\treturn;\n\t}\n\n\tled_change = bnx2x_analyze_link_error(params, vars, value,\n\t\t\t\t\t      PHY_SFP_TX_FAULT_FLAG,\n\t\t\t\t\t      LINK_STATUS_SFP_TX_FAULT, 1);\n\n\tif (led_change) {\n\t\t/* Change TX_Fault led, set link status for further syncs */\n\t\tu8 led_mode;\n\n\t\tif (vars->phy_flags & PHY_SFP_TX_FAULT_FLAG) {\n\t\t\tled_mode = MISC_REGISTERS_GPIO_HIGH;\n\t\t\tvars->link_status |= LINK_STATUS_SFP_TX_FAULT;\n\t\t} else {\n\t\t\tled_mode = MISC_REGISTERS_GPIO_LOW;\n\t\t\tvars->link_status &= ~LINK_STATUS_SFP_TX_FAULT;\n\t\t}\n\n\t\t/* If module is unapproved, led should be on regardless */\n\t\tif (!(phy->flags & FLAGS_SFP_NOT_APPROVED)) {\n\t\t\tDP(NETIF_MSG_LINK, \"Change TX_Fault LED: ->%x\\n\",\n\t\t\t   led_mode);\n\t\t\tbnx2x_set_e3_module_fault_led(params, led_mode);\n\t\t}\n\t}\n}\nstatic void bnx2x_kr2_recovery(struct link_params *params,\n\t\t\t       struct link_vars *vars,\n\t\t\t       struct bnx2x_phy *phy)\n{\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"KR2 recovery\\n\");\n\tbnx2x_warpcore_enable_AN_KR2(phy, params, vars);\n\tbnx2x_warpcore_restart_AN_KR(phy, params);\n}\n\nstatic void bnx2x_check_kr2_wa(struct link_params *params,\n\t\t\t       struct link_vars *vars,\n\t\t\t       struct bnx2x_phy *phy)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 base_page, next_page, not_kr2_device, lane;\n\tint sigdet;\n\n\t/* Once KR2 was disabled, wait 5 seconds before checking KR2 recovery\n\t * Since some switches tend to reinit the AN process and clear the\n\t * the advertised BP/NP after ~2 seconds causing the KR2 to be disabled\n\t * and recovered many times\n\t */\n\tif (vars->check_kr2_recovery_cnt > 0) {\n\t\tvars->check_kr2_recovery_cnt--;\n\t\treturn;\n\t}\n\n\tsigdet = bnx2x_warpcore_get_sigdet(phy, params);\n\tif (!sigdet) {\n\t\tif (!(params->link_attr_sync & LINK_ATTR_SYNC_KR2_ENABLE)) {\n\t\t\tbnx2x_kr2_recovery(params, vars, phy);\n\t\t\tDP(NETIF_MSG_LINK, \"No sigdet\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\tlane = bnx2x_get_warpcore_lane(phy, params);\n\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t  MDIO_AER_BLOCK_AER_REG, lane);\n\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\tMDIO_AN_REG_LP_AUTO_NEG, &base_page);\n\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\tMDIO_AN_REG_LP_AUTO_NEG2, &next_page);\n\tbnx2x_set_aer_mmd(params, phy);\n\n\t/* CL73 has not begun yet */\n\tif (base_page == 0) {\n\t\tif (!(params->link_attr_sync & LINK_ATTR_SYNC_KR2_ENABLE)) {\n\t\t\tbnx2x_kr2_recovery(params, vars, phy);\n\t\t\tDP(NETIF_MSG_LINK, \"No BP\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\t/* In case NP bit is not set in the BasePage, or it is set,\n\t * but only KX is advertised, declare this link partner as non-KR2\n\t * device.\n\t */\n\tnot_kr2_device = (((base_page & 0x8000) == 0) ||\n\t\t\t  (((base_page & 0x8000) &&\n\t\t\t    ((next_page & 0xe0) == 0x20))));\n\n\t/* In case KR2 is already disabled, check if we need to re-enable it */\n\tif (!(params->link_attr_sync & LINK_ATTR_SYNC_KR2_ENABLE)) {\n\t\tif (!not_kr2_device) {\n\t\t\tDP(NETIF_MSG_LINK, \"BP=0x%x, NP=0x%x\\n\", base_page,\n\t\t\t   next_page);\n\t\t\tbnx2x_kr2_recovery(params, vars, phy);\n\t\t}\n\t\treturn;\n\t}\n\t/* KR2 is enabled, but not KR2 device */\n\tif (not_kr2_device) {\n\t\t/* Disable KR2 on both lanes */\n\t\tDP(NETIF_MSG_LINK, \"BP=0x%x, NP=0x%x\\n\", base_page, next_page);\n\t\tbnx2x_disable_kr2(params, vars, phy);\n\t\t/* Restart AN on leading lane */\n\t\tbnx2x_warpcore_restart_AN_KR(phy, params);\n\t\treturn;\n\t}\n}\n\nvoid bnx2x_period_func(struct link_params *params, struct link_vars *vars)\n{\n\tu16 phy_idx;\n\tstruct bnx2x *bp = params->bp;\n\tfor (phy_idx = INT_PHY; phy_idx < MAX_PHYS; phy_idx++) {\n\t\tif (params->phy[phy_idx].flags & FLAGS_TX_ERROR_CHECK) {\n\t\t\tbnx2x_set_aer_mmd(params, &params->phy[phy_idx]);\n\t\t\tif (bnx2x_check_half_open_conn(params, vars, 1) !=\n\t\t\t    0)\n\t\t\t\tDP(NETIF_MSG_LINK, \"Fault detection failed\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (CHIP_IS_E3(bp)) {\n\t\tstruct bnx2x_phy *phy = &params->phy[INT_PHY];\n\t\tbnx2x_set_aer_mmd(params, phy);\n\t\tif (((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t\t     (phy->speed_cap_mask &\n\t\t      PORT_HW_CFG_SPEED_CAPABILITY_D0_20G)) ||\n\t\t    (phy->req_line_speed == SPEED_20000))\n\t\t\tbnx2x_check_kr2_wa(params, vars, phy);\n\t\tbnx2x_check_over_curr(params, vars);\n\t\tif (vars->rx_tx_asic_rst)\n\t\t\tbnx2x_warpcore_config_runtime(phy, params, vars);\n\n\t\tif ((REG_RD(bp, params->shmem_base +\n\t\t\t    offsetof(struct shmem_region, dev_info.\n\t\t\t\tport_hw_config[params->port].default_cfg))\n\t\t    & PORT_HW_CFG_NET_SERDES_IF_MASK) ==\n\t\t    PORT_HW_CFG_NET_SERDES_IF_SFI) {\n\t\t\tif (bnx2x_is_sfp_module_plugged(phy, params)) {\n\t\t\t\tbnx2x_sfp_tx_fault_detection(phy, params, vars);\n\t\t\t} else if (vars->link_status &\n\t\t\t\tLINK_STATUS_SFP_TX_FAULT) {\n\t\t\t\t/* Clean trail, interrupt corrects the leds */\n\t\t\t\tvars->link_status &= ~LINK_STATUS_SFP_TX_FAULT;\n\t\t\t\tvars->phy_flags &= ~PHY_SFP_TX_FAULT_FLAG;\n\t\t\t\t/* Update link status in the shared memory */\n\t\t\t\tbnx2x_update_mng(params, vars->link_status);\n\t\t\t}\n\t\t}\n\t}\n}\n\nu8 bnx2x_fan_failure_det_req(struct bnx2x *bp,\n\t\t\t     u32 shmem_base,\n\t\t\t     u32 shmem2_base,\n\t\t\t     u8 port)\n{\n\tu8 phy_index, fan_failure_det_req = 0;\n\tstruct bnx2x_phy phy;\n\tfor (phy_index = EXT_PHY1; phy_index < MAX_PHYS;\n\t      phy_index++) {\n\t\tif (bnx2x_populate_phy(bp, phy_index, shmem_base, shmem2_base,\n\t\t\t\t       port, &phy)\n\t\t    != 0) {\n\t\t\tDP(NETIF_MSG_LINK, \"populate phy failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfan_failure_det_req |= (phy.flags &\n\t\t\t\t\tFLAGS_FAN_FAILURE_DET_REQ);\n\t}\n\treturn fan_failure_det_req;\n}\n\nvoid bnx2x_hw_reset_phy(struct link_params *params)\n{\n\tu8 phy_index;\n\tstruct bnx2x *bp = params->bp;\n\tbnx2x_update_mng(params, 0);\n\tbnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 + params->port*4,\n\t\t       (NIG_MASK_XGXS0_LINK_STATUS |\n\t\t\tNIG_MASK_XGXS0_LINK10G |\n\t\t\tNIG_MASK_SERDES0_LINK_STATUS |\n\t\t\tNIG_MASK_MI_INT));\n\n\tfor (phy_index = INT_PHY; phy_index < MAX_PHYS;\n\t      phy_index++) {\n\t\tif (params->phy[phy_index].hw_reset) {\n\t\t\tparams->phy[phy_index].hw_reset(\n\t\t\t\t&params->phy[phy_index],\n\t\t\t\tparams);\n\t\t\tparams->phy[phy_index] = phy_null;\n\t\t}\n\t}\n}\n\nvoid bnx2x_init_mod_abs_int(struct bnx2x *bp, struct link_vars *vars,\n\t\t\t    u32 chip_id, u32 shmem_base, u32 shmem2_base,\n\t\t\t    u8 port)\n{\n\tu8 gpio_num = 0xff, gpio_port = 0xff, phy_index;\n\tu32 val;\n\tu32 offset, aeu_mask, swap_val, swap_override, sync_offset;\n\tif (CHIP_IS_E3(bp)) {\n\t\tif (bnx2x_get_mod_abs_int_cfg(bp, chip_id,\n\t\t\t\t\t      shmem_base,\n\t\t\t\t\t      port,\n\t\t\t\t\t      &gpio_num,\n\t\t\t\t\t      &gpio_port) != 0)\n\t\t\treturn;\n\t} else {\n\t\tstruct bnx2x_phy phy;\n\t\tfor (phy_index = EXT_PHY1; phy_index < MAX_PHYS;\n\t\t      phy_index++) {\n\t\t\tif (bnx2x_populate_phy(bp, phy_index, shmem_base,\n\t\t\t\t\t       shmem2_base, port, &phy)\n\t\t\t    != 0) {\n\t\t\t\tDP(NETIF_MSG_LINK, \"populate phy failed\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (phy.type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726) {\n\t\t\t\tgpio_num = MISC_REGISTERS_GPIO_3;\n\t\t\t\tgpio_port = port;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (gpio_num == 0xff)\n\t\treturn;\n\n\t/* Set GPIO3 to trigger SFP+ module insertion/removal */\n\tbnx2x_set_gpio(bp, gpio_num, MISC_REGISTERS_GPIO_INPUT_HI_Z, gpio_port);\n\n\tswap_val = REG_RD(bp, NIG_REG_PORT_SWAP);\n\tswap_override = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);\n\tgpio_port ^= (swap_val && swap_override);\n\n\tvars->aeu_int_mask = AEU_INPUTS_ATTN_BITS_GPIO0_FUNCTION_0 <<\n\t\t(gpio_num + (gpio_port << 2));\n\n\tsync_offset = shmem_base +\n\t\toffsetof(struct shmem_region,\n\t\t\t dev_info.port_hw_config[port].aeu_int_mask);\n\tREG_WR(bp, sync_offset, vars->aeu_int_mask);\n\n\tDP(NETIF_MSG_LINK, \"Setting MOD_ABS (GPIO%d_P%d) AEU to 0x%x\\n\",\n\t\t       gpio_num, gpio_port, vars->aeu_int_mask);\n\n\tif (port == 0)\n\t\toffset = MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0;\n\telse\n\t\toffset = MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0;\n\n\t/* Open appropriate AEU for interrupts */\n\taeu_mask = REG_RD(bp, offset);\n\taeu_mask |= vars->aeu_int_mask;\n\tREG_WR(bp, offset, aeu_mask);\n\n\t/* Enable the GPIO to trigger interrupt */\n\tval = REG_RD(bp, MISC_REG_GPIO_EVENT_EN);\n\tval |= 1 << (gpio_num + (gpio_port << 2));\n\tREG_WR(bp, MISC_REG_GPIO_EVENT_EN, val);\n}\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 7189}, "message": "error: uninitialized symbol 'fw_ver1'."}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c", "reportHash": "7e806ddc85230426fb579abfeb5b531b", "checkerName": "smatch.check_uninitialized", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 7972}, "message": "warn: potential spectre issue 'data_array' [r]"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c", "reportHash": "e7c0dcf8c0af97cf8ba6e248f678fc75", "checkerName": "smatch.check_spectre", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
