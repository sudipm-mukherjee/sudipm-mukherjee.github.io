<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/include/rdma/ib_verbs.h", "content": "/* SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB */\n/*\n * Copyright (c) 2004 Mellanox Technologies Ltd.  All rights reserved.\n * Copyright (c) 2004 Infinicon Corporation.  All rights reserved.\n * Copyright (c) 2004, 2020 Intel Corporation.  All rights reserved.\n * Copyright (c) 2004 Topspin Corporation.  All rights reserved.\n * Copyright (c) 2004 Voltaire Corporation.  All rights reserved.\n * Copyright (c) 2005 Sun Microsystems, Inc. All rights reserved.\n * Copyright (c) 2005, 2006, 2007 Cisco Systems.  All rights reserved.\n */\n\n#ifndef IB_VERBS_H\n#define IB_VERBS_H\n\n#include <linux/ethtool.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/rwsem.h>\n#include <linux/workqueue.h>\n#include <linux/irq_poll.h>\n#include <uapi/linux/if_ether.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/refcount.h>\n#include <linux/if_link.h>\n#include <linux/atomic.h>\n#include <linux/mmu_notifier.h>\n#include <linux/uaccess.h>\n#include <linux/cgroup_rdma.h>\n#include <linux/irqflags.h>\n#include <linux/preempt.h>\n#include <linux/dim.h>\n#include <uapi/rdma/ib_user_verbs.h>\n#include <rdma/rdma_counter.h>\n#include <rdma/restrack.h>\n#include <rdma/signature.h>\n#include <uapi/rdma/rdma_user_ioctl.h>\n#include <uapi/rdma/ib_user_ioctl_verbs.h>\n\n#define IB_FW_VERSION_NAME_MAX\tETHTOOL_FWVERS_LEN\n\nstruct ib_umem_odp;\nstruct ib_uqp_object;\nstruct ib_usrq_object;\nstruct ib_uwq_object;\nstruct rdma_cm_id;\n\nextern struct workqueue_struct *ib_wq;\nextern struct workqueue_struct *ib_comp_wq;\nextern struct workqueue_struct *ib_comp_unbound_wq;\n\nstruct ib_ucq_object;\n\n__printf(3, 4) __cold\nvoid ibdev_printk(const char *level, const struct ib_device *ibdev,\n\t\t  const char *format, ...);\n__printf(2, 3) __cold\nvoid ibdev_emerg(const struct ib_device *ibdev, const char *format, ...);\n__printf(2, 3) __cold\nvoid ibdev_alert(const struct ib_device *ibdev, const char *format, ...);\n__printf(2, 3) __cold\nvoid ibdev_crit(const struct ib_device *ibdev, const char *format, ...);\n__printf(2, 3) __cold\nvoid ibdev_err(const struct ib_device *ibdev, const char *format, ...);\n__printf(2, 3) __cold\nvoid ibdev_warn(const struct ib_device *ibdev, const char *format, ...);\n__printf(2, 3) __cold\nvoid ibdev_notice(const struct ib_device *ibdev, const char *format, ...);\n__printf(2, 3) __cold\nvoid ibdev_info(const struct ib_device *ibdev, const char *format, ...);\n\n#if defined(CONFIG_DYNAMIC_DEBUG) || \\\n\t(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))\n#define ibdev_dbg(__dev, format, args...)                       \\\n\tdynamic_ibdev_dbg(__dev, format, ##args)\n#else\n__printf(2, 3) __cold\nstatic inline\nvoid ibdev_dbg(const struct ib_device *ibdev, const char *format, ...) {}\n#endif\n\n#define ibdev_level_ratelimited(ibdev_level, ibdev, fmt, ...)           \\\ndo {                                                                    \\\n\tstatic DEFINE_RATELIMIT_STATE(_rs,                              \\\n\t\t\t\t      DEFAULT_RATELIMIT_INTERVAL,       \\\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);         \\\n\tif (__ratelimit(&_rs))                                          \\\n\t\tibdev_level(ibdev, fmt, ##__VA_ARGS__);                 \\\n} while (0)\n\n#define ibdev_emerg_ratelimited(ibdev, fmt, ...) \\\n\tibdev_level_ratelimited(ibdev_emerg, ibdev, fmt, ##__VA_ARGS__)\n#define ibdev_alert_ratelimited(ibdev, fmt, ...) \\\n\tibdev_level_ratelimited(ibdev_alert, ibdev, fmt, ##__VA_ARGS__)\n#define ibdev_crit_ratelimited(ibdev, fmt, ...) \\\n\tibdev_level_ratelimited(ibdev_crit, ibdev, fmt, ##__VA_ARGS__)\n#define ibdev_err_ratelimited(ibdev, fmt, ...) \\\n\tibdev_level_ratelimited(ibdev_err, ibdev, fmt, ##__VA_ARGS__)\n#define ibdev_warn_ratelimited(ibdev, fmt, ...) \\\n\tibdev_level_ratelimited(ibdev_warn, ibdev, fmt, ##__VA_ARGS__)\n#define ibdev_notice_ratelimited(ibdev, fmt, ...) \\\n\tibdev_level_ratelimited(ibdev_notice, ibdev, fmt, ##__VA_ARGS__)\n#define ibdev_info_ratelimited(ibdev, fmt, ...) \\\n\tibdev_level_ratelimited(ibdev_info, ibdev, fmt, ##__VA_ARGS__)\n\n#if defined(CONFIG_DYNAMIC_DEBUG) || \\\n\t(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))\n/* descriptor check is first to prevent flooding with \"callbacks suppressed\" */\n#define ibdev_dbg_ratelimited(ibdev, fmt, ...)                          \\\ndo {                                                                    \\\n\tstatic DEFINE_RATELIMIT_STATE(_rs,                              \\\n\t\t\t\t      DEFAULT_RATELIMIT_INTERVAL,       \\\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);         \\\n\tDEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt);                 \\\n\tif (DYNAMIC_DEBUG_BRANCH(descriptor) && __ratelimit(&_rs))      \\\n\t\t__dynamic_ibdev_dbg(&descriptor, ibdev, fmt,            \\\n\t\t\t\t    ##__VA_ARGS__);                     \\\n} while (0)\n#else\n__printf(2, 3) __cold\nstatic inline\nvoid ibdev_dbg_ratelimited(const struct ib_device *ibdev, const char *format, ...) {}\n#endif\n\nunion ib_gid {\n\tu8\traw[16];\n\tstruct {\n\t\t__be64\tsubnet_prefix;\n\t\t__be64\tinterface_id;\n\t} global;\n};\n\nextern union ib_gid zgid;\n\nenum ib_gid_type {\n\tIB_GID_TYPE_IB = IB_UVERBS_GID_TYPE_IB,\n\tIB_GID_TYPE_ROCE = IB_UVERBS_GID_TYPE_ROCE_V1,\n\tIB_GID_TYPE_ROCE_UDP_ENCAP = IB_UVERBS_GID_TYPE_ROCE_V2,\n\tIB_GID_TYPE_SIZE\n};\n\n#define ROCE_V2_UDP_DPORT      4791\nstruct ib_gid_attr {\n\tstruct net_device __rcu\t*ndev;\n\tstruct ib_device\t*device;\n\tunion ib_gid\t\tgid;\n\tenum ib_gid_type\tgid_type;\n\tu16\t\t\tindex;\n\tu8\t\t\tport_num;\n};\n\nenum {\n\t/* set the local administered indication */\n\tIB_SA_WELL_KNOWN_GUID\t= BIT_ULL(57) | 2,\n};\n\nenum rdma_transport_type {\n\tRDMA_TRANSPORT_IB,\n\tRDMA_TRANSPORT_IWARP,\n\tRDMA_TRANSPORT_USNIC,\n\tRDMA_TRANSPORT_USNIC_UDP,\n\tRDMA_TRANSPORT_UNSPECIFIED,\n};\n\nenum rdma_protocol_type {\n\tRDMA_PROTOCOL_IB,\n\tRDMA_PROTOCOL_IBOE,\n\tRDMA_PROTOCOL_IWARP,\n\tRDMA_PROTOCOL_USNIC_UDP\n};\n\n__attribute_const__ enum rdma_transport_type\nrdma_node_get_transport(unsigned int node_type);\n\nenum rdma_network_type {\n\tRDMA_NETWORK_IB,\n\tRDMA_NETWORK_ROCE_V1,\n\tRDMA_NETWORK_IPV4,\n\tRDMA_NETWORK_IPV6\n};\n\nstatic inline enum ib_gid_type ib_network_to_gid_type(enum rdma_network_type network_type)\n{\n\tif (network_type == RDMA_NETWORK_IPV4 ||\n\t    network_type == RDMA_NETWORK_IPV6)\n\t\treturn IB_GID_TYPE_ROCE_UDP_ENCAP;\n\telse if (network_type == RDMA_NETWORK_ROCE_V1)\n\t\treturn IB_GID_TYPE_ROCE;\n\telse\n\t\treturn IB_GID_TYPE_IB;\n}\n\nstatic inline enum rdma_network_type\nrdma_gid_attr_network_type(const struct ib_gid_attr *attr)\n{\n\tif (attr->gid_type == IB_GID_TYPE_IB)\n\t\treturn RDMA_NETWORK_IB;\n\n\tif (attr->gid_type == IB_GID_TYPE_ROCE)\n\t\treturn RDMA_NETWORK_ROCE_V1;\n\n\tif (ipv6_addr_v4mapped((struct in6_addr *)&attr->gid))\n\t\treturn RDMA_NETWORK_IPV4;\n\telse\n\t\treturn RDMA_NETWORK_IPV6;\n}\n\nenum rdma_link_layer {\n\tIB_LINK_LAYER_UNSPECIFIED,\n\tIB_LINK_LAYER_INFINIBAND,\n\tIB_LINK_LAYER_ETHERNET,\n};\n\nenum ib_device_cap_flags {\n\tIB_DEVICE_RESIZE_MAX_WR\t\t\t= (1 << 0),\n\tIB_DEVICE_BAD_PKEY_CNTR\t\t\t= (1 << 1),\n\tIB_DEVICE_BAD_QKEY_CNTR\t\t\t= (1 << 2),\n\tIB_DEVICE_RAW_MULTI\t\t\t= (1 << 3),\n\tIB_DEVICE_AUTO_PATH_MIG\t\t\t= (1 << 4),\n\tIB_DEVICE_CHANGE_PHY_PORT\t\t= (1 << 5),\n\tIB_DEVICE_UD_AV_PORT_ENFORCE\t\t= (1 << 6),\n\tIB_DEVICE_CURR_QP_STATE_MOD\t\t= (1 << 7),\n\tIB_DEVICE_SHUTDOWN_PORT\t\t\t= (1 << 8),\n\t/* Not in use, former INIT_TYPE\t\t= (1 << 9),*/\n\tIB_DEVICE_PORT_ACTIVE_EVENT\t\t= (1 << 10),\n\tIB_DEVICE_SYS_IMAGE_GUID\t\t= (1 << 11),\n\tIB_DEVICE_RC_RNR_NAK_GEN\t\t= (1 << 12),\n\tIB_DEVICE_SRQ_RESIZE\t\t\t= (1 << 13),\n\tIB_DEVICE_N_NOTIFY_CQ\t\t\t= (1 << 14),\n\n\t/*\n\t * This device supports a per-device lkey or stag that can be\n\t * used without performing a memory registration for the local\n\t * memory.  Note that ULPs should never check this flag, but\n\t * instead of use the local_dma_lkey flag in the ib_pd structure,\n\t * which will always contain a usable lkey.\n\t */\n\tIB_DEVICE_LOCAL_DMA_LKEY\t\t= (1 << 15),\n\t/* Reserved, old SEND_W_INV\t\t= (1 << 16),*/\n\tIB_DEVICE_MEM_WINDOW\t\t\t= (1 << 17),\n\t/*\n\t * Devices should set IB_DEVICE_UD_IP_SUM if they support\n\t * insertion of UDP and TCP checksum on outgoing UD IPoIB\n\t * messages and can verify the validity of checksum for\n\t * incoming messages.  Setting this flag implies that the\n\t * IPoIB driver may set NETIF_F_IP_CSUM for datagram mode.\n\t */\n\tIB_DEVICE_UD_IP_CSUM\t\t\t= (1 << 18),\n\tIB_DEVICE_UD_TSO\t\t\t= (1 << 19),\n\tIB_DEVICE_XRC\t\t\t\t= (1 << 20),\n\n\t/*\n\t * This device supports the IB \"base memory management extension\",\n\t * which includes support for fast registrations (IB_WR_REG_MR,\n\t * IB_WR_LOCAL_INV and IB_WR_SEND_WITH_INV verbs).  This flag should\n\t * also be set by any iWarp device which must support FRs to comply\n\t * to the iWarp verbs spec.  iWarp devices also support the\n\t * IB_WR_RDMA_READ_WITH_INV verb for RDMA READs that invalidate the\n\t * stag.\n\t */\n\tIB_DEVICE_MEM_MGT_EXTENSIONS\t\t= (1 << 21),\n\tIB_DEVICE_BLOCK_MULTICAST_LOOPBACK\t= (1 << 22),\n\tIB_DEVICE_MEM_WINDOW_TYPE_2A\t\t= (1 << 23),\n\tIB_DEVICE_MEM_WINDOW_TYPE_2B\t\t= (1 << 24),\n\tIB_DEVICE_RC_IP_CSUM\t\t\t= (1 << 25),\n\t/* Deprecated. Please use IB_RAW_PACKET_CAP_IP_CSUM. */\n\tIB_DEVICE_RAW_IP_CSUM\t\t\t= (1 << 26),\n\t/*\n\t * Devices should set IB_DEVICE_CROSS_CHANNEL if they\n\t * support execution of WQEs that involve synchronization\n\t * of I/O operations with single completion queue managed\n\t * by hardware.\n\t */\n\tIB_DEVICE_CROSS_CHANNEL\t\t\t= (1 << 27),\n\tIB_DEVICE_MANAGED_FLOW_STEERING\t\t= (1 << 29),\n\tIB_DEVICE_INTEGRITY_HANDOVER\t\t= (1 << 30),\n\tIB_DEVICE_ON_DEMAND_PAGING\t\t= (1ULL << 31),\n\tIB_DEVICE_SG_GAPS_REG\t\t\t= (1ULL << 32),\n\tIB_DEVICE_VIRTUAL_FUNCTION\t\t= (1ULL << 33),\n\t/* Deprecated. Please use IB_RAW_PACKET_CAP_SCATTER_FCS. */\n\tIB_DEVICE_RAW_SCATTER_FCS\t\t= (1ULL << 34),\n\tIB_DEVICE_RDMA_NETDEV_OPA\t\t= (1ULL << 35),\n\t/* The device supports padding incoming writes to cacheline. */\n\tIB_DEVICE_PCI_WRITE_END_PADDING\t\t= (1ULL << 36),\n\tIB_DEVICE_ALLOW_USER_UNREG\t\t= (1ULL << 37),\n};\n\nenum ib_atomic_cap {\n\tIB_ATOMIC_NONE,\n\tIB_ATOMIC_HCA,\n\tIB_ATOMIC_GLOB\n};\n\nenum ib_odp_general_cap_bits {\n\tIB_ODP_SUPPORT\t\t= 1 << 0,\n\tIB_ODP_SUPPORT_IMPLICIT = 1 << 1,\n};\n\nenum ib_odp_transport_cap_bits {\n\tIB_ODP_SUPPORT_SEND\t= 1 << 0,\n\tIB_ODP_SUPPORT_RECV\t= 1 << 1,\n\tIB_ODP_SUPPORT_WRITE\t= 1 << 2,\n\tIB_ODP_SUPPORT_READ\t= 1 << 3,\n\tIB_ODP_SUPPORT_ATOMIC\t= 1 << 4,\n\tIB_ODP_SUPPORT_SRQ_RECV\t= 1 << 5,\n};\n\nstruct ib_odp_caps {\n\tuint64_t general_caps;\n\tstruct {\n\t\tuint32_t  rc_odp_caps;\n\t\tuint32_t  uc_odp_caps;\n\t\tuint32_t  ud_odp_caps;\n\t\tuint32_t  xrc_odp_caps;\n\t} per_transport_caps;\n};\n\nstruct ib_rss_caps {\n\t/* Corresponding bit will be set if qp type from\n\t * 'enum ib_qp_type' is supported, e.g.\n\t * supported_qpts |= 1 << IB_QPT_UD\n\t */\n\tu32 supported_qpts;\n\tu32 max_rwq_indirection_tables;\n\tu32 max_rwq_indirection_table_size;\n};\n\nenum ib_tm_cap_flags {\n\t/*  Support tag matching with rendezvous offload for RC transport */\n\tIB_TM_CAP_RNDV_RC = 1 << 0,\n};\n\nstruct ib_tm_caps {\n\t/* Max size of RNDV header */\n\tu32 max_rndv_hdr_size;\n\t/* Max number of entries in tag matching list */\n\tu32 max_num_tags;\n\t/* From enum ib_tm_cap_flags */\n\tu32 flags;\n\t/* Max number of outstanding list operations */\n\tu32 max_ops;\n\t/* Max number of SGE in tag matching entry */\n\tu32 max_sge;\n};\n\nstruct ib_cq_init_attr {\n\tunsigned int\tcqe;\n\tu32\t\tcomp_vector;\n\tu32\t\tflags;\n};\n\nenum ib_cq_attr_mask {\n\tIB_CQ_MODERATE = 1 << 0,\n};\n\nstruct ib_cq_caps {\n\tu16     max_cq_moderation_count;\n\tu16     max_cq_moderation_period;\n};\n\nstruct ib_dm_mr_attr {\n\tu64\t\tlength;\n\tu64\t\toffset;\n\tu32\t\taccess_flags;\n};\n\nstruct ib_dm_alloc_attr {\n\tu64\tlength;\n\tu32\talignment;\n\tu32\tflags;\n};\n\nstruct ib_device_attr {\n\tu64\t\t\tfw_ver;\n\t__be64\t\t\tsys_image_guid;\n\tu64\t\t\tmax_mr_size;\n\tu64\t\t\tpage_size_cap;\n\tu32\t\t\tvendor_id;\n\tu32\t\t\tvendor_part_id;\n\tu32\t\t\thw_ver;\n\tint\t\t\tmax_qp;\n\tint\t\t\tmax_qp_wr;\n\tu64\t\t\tdevice_cap_flags;\n\tint\t\t\tmax_send_sge;\n\tint\t\t\tmax_recv_sge;\n\tint\t\t\tmax_sge_rd;\n\tint\t\t\tmax_cq;\n\tint\t\t\tmax_cqe;\n\tint\t\t\tmax_mr;\n\tint\t\t\tmax_pd;\n\tint\t\t\tmax_qp_rd_atom;\n\tint\t\t\tmax_ee_rd_atom;\n\tint\t\t\tmax_res_rd_atom;\n\tint\t\t\tmax_qp_init_rd_atom;\n\tint\t\t\tmax_ee_init_rd_atom;\n\tenum ib_atomic_cap\tatomic_cap;\n\tenum ib_atomic_cap\tmasked_atomic_cap;\n\tint\t\t\tmax_ee;\n\tint\t\t\tmax_rdd;\n\tint\t\t\tmax_mw;\n\tint\t\t\tmax_raw_ipv6_qp;\n\tint\t\t\tmax_raw_ethy_qp;\n\tint\t\t\tmax_mcast_grp;\n\tint\t\t\tmax_mcast_qp_attach;\n\tint\t\t\tmax_total_mcast_qp_attach;\n\tint\t\t\tmax_ah;\n\tint\t\t\tmax_srq;\n\tint\t\t\tmax_srq_wr;\n\tint\t\t\tmax_srq_sge;\n\tunsigned int\t\tmax_fast_reg_page_list_len;\n\tunsigned int\t\tmax_pi_fast_reg_page_list_len;\n\tu16\t\t\tmax_pkeys;\n\tu8\t\t\tlocal_ca_ack_delay;\n\tint\t\t\tsig_prot_cap;\n\tint\t\t\tsig_guard_cap;\n\tstruct ib_odp_caps\todp_caps;\n\tuint64_t\t\ttimestamp_mask;\n\tuint64_t\t\thca_core_clock; /* in KHZ */\n\tstruct ib_rss_caps\trss_caps;\n\tu32\t\t\tmax_wq_type_rq;\n\tu32\t\t\traw_packet_caps; /* Use ib_raw_packet_caps enum */\n\tstruct ib_tm_caps\ttm_caps;\n\tstruct ib_cq_caps       cq_caps;\n\tu64\t\t\tmax_dm_size;\n\t/* Max entries for sgl for optimized performance per READ */\n\tu32\t\t\tmax_sgl_rd;\n};\n\nenum ib_mtu {\n\tIB_MTU_256  = 1,\n\tIB_MTU_512  = 2,\n\tIB_MTU_1024 = 3,\n\tIB_MTU_2048 = 4,\n\tIB_MTU_4096 = 5\n};\n\nenum opa_mtu {\n\tOPA_MTU_8192 = 6,\n\tOPA_MTU_10240 = 7\n};\n\nstatic inline int ib_mtu_enum_to_int(enum ib_mtu mtu)\n{\n\tswitch (mtu) {\n\tcase IB_MTU_256:  return  256;\n\tcase IB_MTU_512:  return  512;\n\tcase IB_MTU_1024: return 1024;\n\tcase IB_MTU_2048: return 2048;\n\tcase IB_MTU_4096: return 4096;\n\tdefault: \t  return -1;\n\t}\n}\n\nstatic inline enum ib_mtu ib_mtu_int_to_enum(int mtu)\n{\n\tif (mtu >= 4096)\n\t\treturn IB_MTU_4096;\n\telse if (mtu >= 2048)\n\t\treturn IB_MTU_2048;\n\telse if (mtu >= 1024)\n\t\treturn IB_MTU_1024;\n\telse if (mtu >= 512)\n\t\treturn IB_MTU_512;\n\telse\n\t\treturn IB_MTU_256;\n}\n\nstatic inline int opa_mtu_enum_to_int(enum opa_mtu mtu)\n{\n\tswitch (mtu) {\n\tcase OPA_MTU_8192:\n\t\treturn 8192;\n\tcase OPA_MTU_10240:\n\t\treturn 10240;\n\tdefault:\n\t\treturn(ib_mtu_enum_to_int((enum ib_mtu)mtu));\n\t}\n}\n\nstatic inline enum opa_mtu opa_mtu_int_to_enum(int mtu)\n{\n\tif (mtu >= 10240)\n\t\treturn OPA_MTU_10240;\n\telse if (mtu >= 8192)\n\t\treturn OPA_MTU_8192;\n\telse\n\t\treturn ((enum opa_mtu)ib_mtu_int_to_enum(mtu));\n}\n\nenum ib_port_state {\n\tIB_PORT_NOP\t\t= 0,\n\tIB_PORT_DOWN\t\t= 1,\n\tIB_PORT_INIT\t\t= 2,\n\tIB_PORT_ARMED\t\t= 3,\n\tIB_PORT_ACTIVE\t\t= 4,\n\tIB_PORT_ACTIVE_DEFER\t= 5\n};\n\nenum ib_port_phys_state {\n\tIB_PORT_PHYS_STATE_SLEEP = 1,\n\tIB_PORT_PHYS_STATE_POLLING = 2,\n\tIB_PORT_PHYS_STATE_DISABLED = 3,\n\tIB_PORT_PHYS_STATE_PORT_CONFIGURATION_TRAINING = 4,\n\tIB_PORT_PHYS_STATE_LINK_UP = 5,\n\tIB_PORT_PHYS_STATE_LINK_ERROR_RECOVERY = 6,\n\tIB_PORT_PHYS_STATE_PHY_TEST = 7,\n};\n\nenum ib_port_width {\n\tIB_WIDTH_1X\t= 1,\n\tIB_WIDTH_2X\t= 16,\n\tIB_WIDTH_4X\t= 2,\n\tIB_WIDTH_8X\t= 4,\n\tIB_WIDTH_12X\t= 8\n};\n\nstatic inline int ib_width_enum_to_int(enum ib_port_width width)\n{\n\tswitch (width) {\n\tcase IB_WIDTH_1X:  return  1;\n\tcase IB_WIDTH_2X:  return  2;\n\tcase IB_WIDTH_4X:  return  4;\n\tcase IB_WIDTH_8X:  return  8;\n\tcase IB_WIDTH_12X: return 12;\n\tdefault: \t  return -1;\n\t}\n}\n\nenum ib_port_speed {\n\tIB_SPEED_SDR\t= 1,\n\tIB_SPEED_DDR\t= 2,\n\tIB_SPEED_QDR\t= 4,\n\tIB_SPEED_FDR10\t= 8,\n\tIB_SPEED_FDR\t= 16,\n\tIB_SPEED_EDR\t= 32,\n\tIB_SPEED_HDR\t= 64,\n\tIB_SPEED_NDR\t= 128,\n};\n\n/**\n * struct rdma_hw_stats\n * @lock - Mutex to protect parallel write access to lifespan and values\n *    of counters, which are 64bits and not guaranteeed to be written\n *    atomicaly on 32bits systems.\n * @timestamp - Used by the core code to track when the last update was\n * @lifespan - Used by the core code to determine how old the counters\n *   should be before being updated again.  Stored in jiffies, defaults\n *   to 10 milliseconds, drivers can override the default be specifying\n *   their own value during their allocation routine.\n * @name - Array of pointers to static names used for the counters in\n *   directory.\n * @num_counters - How many hardware counters there are.  If name is\n *   shorter than this number, a kernel oops will result.  Driver authors\n *   are encouraged to leave BUILD_BUG_ON(ARRAY_SIZE(@name) < num_counters)\n *   in their code to prevent this.\n * @value - Array of u64 counters that are accessed by the sysfs code and\n *   filled in by the drivers get_stats routine\n */\nstruct rdma_hw_stats {\n\tstruct mutex\tlock; /* Protect lifespan and values[] */\n\tunsigned long\ttimestamp;\n\tunsigned long\tlifespan;\n\tconst char * const *names;\n\tint\t\tnum_counters;\n\tu64\t\tvalue[];\n};\n\n#define RDMA_HW_STATS_DEFAULT_LIFESPAN 10\n/**\n * rdma_alloc_hw_stats_struct - Helper function to allocate dynamic struct\n *   for drivers.\n * @names - Array of static const char *\n * @num_counters - How many elements in array\n * @lifespan - How many milliseconds between updates\n */\nstatic inline struct rdma_hw_stats *rdma_alloc_hw_stats_struct(\n\t\tconst char * const *names, int num_counters,\n\t\tunsigned long lifespan)\n{\n\tstruct rdma_hw_stats *stats;\n\n\tstats = kzalloc(sizeof(*stats) + num_counters * sizeof(u64),\n\t\t\tGFP_KERNEL);\n\tif (!stats)\n\t\treturn NULL;\n\tstats->names = names;\n\tstats->num_counters = num_counters;\n\tstats->lifespan = msecs_to_jiffies(lifespan);\n\n\treturn stats;\n}\n\n\n/* Define bits for the various functionality this port needs to be supported by\n * the core.\n */\n/* Management                           0x00000FFF */\n#define RDMA_CORE_CAP_IB_MAD            0x00000001\n#define RDMA_CORE_CAP_IB_SMI            0x00000002\n#define RDMA_CORE_CAP_IB_CM             0x00000004\n#define RDMA_CORE_CAP_IW_CM             0x00000008\n#define RDMA_CORE_CAP_IB_SA             0x00000010\n#define RDMA_CORE_CAP_OPA_MAD           0x00000020\n\n/* Address format                       0x000FF000 */\n#define RDMA_CORE_CAP_AF_IB             0x00001000\n#define RDMA_CORE_CAP_ETH_AH            0x00002000\n#define RDMA_CORE_CAP_OPA_AH            0x00004000\n#define RDMA_CORE_CAP_IB_GRH_REQUIRED   0x00008000\n\n/* Protocol                             0xFFF00000 */\n#define RDMA_CORE_CAP_PROT_IB           0x00100000\n#define RDMA_CORE_CAP_PROT_ROCE         0x00200000\n#define RDMA_CORE_CAP_PROT_IWARP        0x00400000\n#define RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP 0x00800000\n#define RDMA_CORE_CAP_PROT_RAW_PACKET   0x01000000\n#define RDMA_CORE_CAP_PROT_USNIC        0x02000000\n\n#define RDMA_CORE_PORT_IB_GRH_REQUIRED (RDMA_CORE_CAP_IB_GRH_REQUIRED \\\n\t\t\t\t\t| RDMA_CORE_CAP_PROT_ROCE     \\\n\t\t\t\t\t| RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP)\n\n#define RDMA_CORE_PORT_IBA_IB          (RDMA_CORE_CAP_PROT_IB  \\\n\t\t\t\t\t| RDMA_CORE_CAP_IB_MAD \\\n\t\t\t\t\t| RDMA_CORE_CAP_IB_SMI \\\n\t\t\t\t\t| RDMA_CORE_CAP_IB_CM  \\\n\t\t\t\t\t| RDMA_CORE_CAP_IB_SA  \\\n\t\t\t\t\t| RDMA_CORE_CAP_AF_IB)\n#define RDMA_CORE_PORT_IBA_ROCE        (RDMA_CORE_CAP_PROT_ROCE \\\n\t\t\t\t\t| RDMA_CORE_CAP_IB_MAD  \\\n\t\t\t\t\t| RDMA_CORE_CAP_IB_CM   \\\n\t\t\t\t\t| RDMA_CORE_CAP_AF_IB   \\\n\t\t\t\t\t| RDMA_CORE_CAP_ETH_AH)\n#define RDMA_CORE_PORT_IBA_ROCE_UDP_ENCAP\t\t\t\\\n\t\t\t\t\t(RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP \\\n\t\t\t\t\t| RDMA_CORE_CAP_IB_MAD  \\\n\t\t\t\t\t| RDMA_CORE_CAP_IB_CM   \\\n\t\t\t\t\t| RDMA_CORE_CAP_AF_IB   \\\n\t\t\t\t\t| RDMA_CORE_CAP_ETH_AH)\n#define RDMA_CORE_PORT_IWARP           (RDMA_CORE_CAP_PROT_IWARP \\\n\t\t\t\t\t| RDMA_CORE_CAP_IW_CM)\n#define RDMA_CORE_PORT_INTEL_OPA       (RDMA_CORE_PORT_IBA_IB  \\\n\t\t\t\t\t| RDMA_CORE_CAP_OPA_MAD)\n\n#define RDMA_CORE_PORT_RAW_PACKET\t(RDMA_CORE_CAP_PROT_RAW_PACKET)\n\n#define RDMA_CORE_PORT_USNIC\t\t(RDMA_CORE_CAP_PROT_USNIC)\n\nstruct ib_port_attr {\n\tu64\t\t\tsubnet_prefix;\n\tenum ib_port_state\tstate;\n\tenum ib_mtu\t\tmax_mtu;\n\tenum ib_mtu\t\tactive_mtu;\n\tu32                     phys_mtu;\n\tint\t\t\tgid_tbl_len;\n\tunsigned int\t\tip_gids:1;\n\t/* This is the value from PortInfo CapabilityMask, defined by IBA */\n\tu32\t\t\tport_cap_flags;\n\tu32\t\t\tmax_msg_sz;\n\tu32\t\t\tbad_pkey_cntr;\n\tu32\t\t\tqkey_viol_cntr;\n\tu16\t\t\tpkey_tbl_len;\n\tu32\t\t\tsm_lid;\n\tu32\t\t\tlid;\n\tu8\t\t\tlmc;\n\tu8\t\t\tmax_vl_num;\n\tu8\t\t\tsm_sl;\n\tu8\t\t\tsubnet_timeout;\n\tu8\t\t\tinit_type_reply;\n\tu8\t\t\tactive_width;\n\tu16\t\t\tactive_speed;\n\tu8                      phys_state;\n\tu16\t\t\tport_cap_flags2;\n};\n\nenum ib_device_modify_flags {\n\tIB_DEVICE_MODIFY_SYS_IMAGE_GUID\t= 1 << 0,\n\tIB_DEVICE_MODIFY_NODE_DESC\t= 1 << 1\n};\n\n#define IB_DEVICE_NODE_DESC_MAX 64\n\nstruct ib_device_modify {\n\tu64\tsys_image_guid;\n\tchar\tnode_desc[IB_DEVICE_NODE_DESC_MAX];\n};\n\nenum ib_port_modify_flags {\n\tIB_PORT_SHUTDOWN\t\t= 1,\n\tIB_PORT_INIT_TYPE\t\t= (1<<2),\n\tIB_PORT_RESET_QKEY_CNTR\t\t= (1<<3),\n\tIB_PORT_OPA_MASK_CHG\t\t= (1<<4)\n};\n\nstruct ib_port_modify {\n\tu32\tset_port_cap_mask;\n\tu32\tclr_port_cap_mask;\n\tu8\tinit_type;\n};\n\nenum ib_event_type {\n\tIB_EVENT_CQ_ERR,\n\tIB_EVENT_QP_FATAL,\n\tIB_EVENT_QP_REQ_ERR,\n\tIB_EVENT_QP_ACCESS_ERR,\n\tIB_EVENT_COMM_EST,\n\tIB_EVENT_SQ_DRAINED,\n\tIB_EVENT_PATH_MIG,\n\tIB_EVENT_PATH_MIG_ERR,\n\tIB_EVENT_DEVICE_FATAL,\n\tIB_EVENT_PORT_ACTIVE,\n\tIB_EVENT_PORT_ERR,\n\tIB_EVENT_LID_CHANGE,\n\tIB_EVENT_PKEY_CHANGE,\n\tIB_EVENT_SM_CHANGE,\n\tIB_EVENT_SRQ_ERR,\n\tIB_EVENT_SRQ_LIMIT_REACHED,\n\tIB_EVENT_QP_LAST_WQE_REACHED,\n\tIB_EVENT_CLIENT_REREGISTER,\n\tIB_EVENT_GID_CHANGE,\n\tIB_EVENT_WQ_FATAL,\n};\n\nconst char *__attribute_const__ ib_event_msg(enum ib_event_type event);\n\nstruct ib_event {\n\tstruct ib_device\t*device;\n\tunion {\n\t\tstruct ib_cq\t*cq;\n\t\tstruct ib_qp\t*qp;\n\t\tstruct ib_srq\t*srq;\n\t\tstruct ib_wq\t*wq;\n\t\tu8\t\tport_num;\n\t} element;\n\tenum ib_event_type\tevent;\n};\n\nstruct ib_event_handler {\n\tstruct ib_device *device;\n\tvoid            (*handler)(struct ib_event_handler *, struct ib_event *);\n\tstruct list_head  list;\n};\n\n#define INIT_IB_EVENT_HANDLER(_ptr, _device, _handler)\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\t(_ptr)->device  = _device;\t\t\t\\\n\t\t(_ptr)->handler = _handler;\t\t\t\\\n\t\tINIT_LIST_HEAD(&(_ptr)->list);\t\t\t\\\n\t} while (0)\n\nstruct ib_global_route {\n\tconst struct ib_gid_attr *sgid_attr;\n\tunion ib_gid\tdgid;\n\tu32\t\tflow_label;\n\tu8\t\tsgid_index;\n\tu8\t\thop_limit;\n\tu8\t\ttraffic_class;\n};\n\nstruct ib_grh {\n\t__be32\t\tversion_tclass_flow;\n\t__be16\t\tpaylen;\n\tu8\t\tnext_hdr;\n\tu8\t\thop_limit;\n\tunion ib_gid\tsgid;\n\tunion ib_gid\tdgid;\n};\n\nunion rdma_network_hdr {\n\tstruct ib_grh ibgrh;\n\tstruct {\n\t\t/* The IB spec states that if it's IPv4, the header\n\t\t * is located in the last 20 bytes of the header.\n\t\t */\n\t\tu8\t\treserved[20];\n\t\tstruct iphdr\troce4grh;\n\t};\n};\n\n#define IB_QPN_MASK\t\t0xFFFFFF\n\nenum {\n\tIB_MULTICAST_QPN = 0xffffff\n};\n\n#define IB_LID_PERMISSIVE\tcpu_to_be16(0xFFFF)\n#define IB_MULTICAST_LID_BASE\tcpu_to_be16(0xC000)\n\nenum ib_ah_flags {\n\tIB_AH_GRH\t= 1\n};\n\nenum ib_rate {\n\tIB_RATE_PORT_CURRENT = 0,\n\tIB_RATE_2_5_GBPS = 2,\n\tIB_RATE_5_GBPS   = 5,\n\tIB_RATE_10_GBPS  = 3,\n\tIB_RATE_20_GBPS  = 6,\n\tIB_RATE_30_GBPS  = 4,\n\tIB_RATE_40_GBPS  = 7,\n\tIB_RATE_60_GBPS  = 8,\n\tIB_RATE_80_GBPS  = 9,\n\tIB_RATE_120_GBPS = 10,\n\tIB_RATE_14_GBPS  = 11,\n\tIB_RATE_56_GBPS  = 12,\n\tIB_RATE_112_GBPS = 13,\n\tIB_RATE_168_GBPS = 14,\n\tIB_RATE_25_GBPS  = 15,\n\tIB_RATE_100_GBPS = 16,\n\tIB_RATE_200_GBPS = 17,\n\tIB_RATE_300_GBPS = 18,\n\tIB_RATE_28_GBPS  = 19,\n\tIB_RATE_50_GBPS  = 20,\n\tIB_RATE_400_GBPS = 21,\n\tIB_RATE_600_GBPS = 22,\n};\n\n/**\n * ib_rate_to_mult - Convert the IB rate enum to a multiple of the\n * base rate of 2.5 Gbit/sec.  For example, IB_RATE_5_GBPS will be\n * converted to 2, since 5 Gbit/sec is 2 * 2.5 Gbit/sec.\n * @rate: rate to convert.\n */\n__attribute_const__ int ib_rate_to_mult(enum ib_rate rate);\n\n/**\n * ib_rate_to_mbps - Convert the IB rate enum to Mbps.\n * For example, IB_RATE_2_5_GBPS will be converted to 2500.\n * @rate: rate to convert.\n */\n__attribute_const__ int ib_rate_to_mbps(enum ib_rate rate);\n\n\n/**\n * enum ib_mr_type - memory region type\n * @IB_MR_TYPE_MEM_REG:       memory region that is used for\n *                            normal registration\n * @IB_MR_TYPE_SG_GAPS:       memory region that is capable to\n *                            register any arbitrary sg lists (without\n *                            the normal mr constraints - see\n *                            ib_map_mr_sg)\n * @IB_MR_TYPE_DM:            memory region that is used for device\n *                            memory registration\n * @IB_MR_TYPE_USER:          memory region that is used for the user-space\n *                            application\n * @IB_MR_TYPE_DMA:           memory region that is used for DMA operations\n *                            without address translations (VA=PA)\n * @IB_MR_TYPE_INTEGRITY:     memory region that is used for\n *                            data integrity operations\n */\nenum ib_mr_type {\n\tIB_MR_TYPE_MEM_REG,\n\tIB_MR_TYPE_SG_GAPS,\n\tIB_MR_TYPE_DM,\n\tIB_MR_TYPE_USER,\n\tIB_MR_TYPE_DMA,\n\tIB_MR_TYPE_INTEGRITY,\n};\n\nenum ib_mr_status_check {\n\tIB_MR_CHECK_SIG_STATUS = 1,\n};\n\n/**\n * struct ib_mr_status - Memory region status container\n *\n * @fail_status: Bitmask of MR checks status. For each\n *     failed check a corresponding status bit is set.\n * @sig_err: Additional info for IB_MR_CEHCK_SIG_STATUS\n *     failure.\n */\nstruct ib_mr_status {\n\tu32\t\t    fail_status;\n\tstruct ib_sig_err   sig_err;\n};\n\n/**\n * mult_to_ib_rate - Convert a multiple of 2.5 Gbit/sec to an IB rate\n * enum.\n * @mult: multiple to convert.\n */\n__attribute_const__ enum ib_rate mult_to_ib_rate(int mult);\n\nstruct rdma_ah_init_attr {\n\tstruct rdma_ah_attr *ah_attr;\n\tu32 flags;\n\tstruct net_device *xmit_slave;\n};\n\nenum rdma_ah_attr_type {\n\tRDMA_AH_ATTR_TYPE_UNDEFINED,\n\tRDMA_AH_ATTR_TYPE_IB,\n\tRDMA_AH_ATTR_TYPE_ROCE,\n\tRDMA_AH_ATTR_TYPE_OPA,\n};\n\nstruct ib_ah_attr {\n\tu16\t\t\tdlid;\n\tu8\t\t\tsrc_path_bits;\n};\n\nstruct roce_ah_attr {\n\tu8\t\t\tdmac[ETH_ALEN];\n};\n\nstruct opa_ah_attr {\n\tu32\t\t\tdlid;\n\tu8\t\t\tsrc_path_bits;\n\tbool\t\t\tmake_grd;\n};\n\nstruct rdma_ah_attr {\n\tstruct ib_global_route\tgrh;\n\tu8\t\t\tsl;\n\tu8\t\t\tstatic_rate;\n\tu8\t\t\tport_num;\n\tu8\t\t\tah_flags;\n\tenum rdma_ah_attr_type type;\n\tunion {\n\t\tstruct ib_ah_attr ib;\n\t\tstruct roce_ah_attr roce;\n\t\tstruct opa_ah_attr opa;\n\t};\n};\n\nenum ib_wc_status {\n\tIB_WC_SUCCESS,\n\tIB_WC_LOC_LEN_ERR,\n\tIB_WC_LOC_QP_OP_ERR,\n\tIB_WC_LOC_EEC_OP_ERR,\n\tIB_WC_LOC_PROT_ERR,\n\tIB_WC_WR_FLUSH_ERR,\n\tIB_WC_MW_BIND_ERR,\n\tIB_WC_BAD_RESP_ERR,\n\tIB_WC_LOC_ACCESS_ERR,\n\tIB_WC_REM_INV_REQ_ERR,\n\tIB_WC_REM_ACCESS_ERR,\n\tIB_WC_REM_OP_ERR,\n\tIB_WC_RETRY_EXC_ERR,\n\tIB_WC_RNR_RETRY_EXC_ERR,\n\tIB_WC_LOC_RDD_VIOL_ERR,\n\tIB_WC_REM_INV_RD_REQ_ERR,\n\tIB_WC_REM_ABORT_ERR,\n\tIB_WC_INV_EECN_ERR,\n\tIB_WC_INV_EEC_STATE_ERR,\n\tIB_WC_FATAL_ERR,\n\tIB_WC_RESP_TIMEOUT_ERR,\n\tIB_WC_GENERAL_ERR\n};\n\nconst char *__attribute_const__ ib_wc_status_msg(enum ib_wc_status status);\n\nenum ib_wc_opcode {\n\tIB_WC_SEND = IB_UVERBS_WC_SEND,\n\tIB_WC_RDMA_WRITE = IB_UVERBS_WC_RDMA_WRITE,\n\tIB_WC_RDMA_READ = IB_UVERBS_WC_RDMA_READ,\n\tIB_WC_COMP_SWAP = IB_UVERBS_WC_COMP_SWAP,\n\tIB_WC_FETCH_ADD = IB_UVERBS_WC_FETCH_ADD,\n\tIB_WC_BIND_MW = IB_UVERBS_WC_BIND_MW,\n\tIB_WC_LOCAL_INV = IB_UVERBS_WC_LOCAL_INV,\n\tIB_WC_LSO = IB_UVERBS_WC_TSO,\n\tIB_WC_REG_MR,\n\tIB_WC_MASKED_COMP_SWAP,\n\tIB_WC_MASKED_FETCH_ADD,\n/*\n * Set value of IB_WC_RECV so consumers can test if a completion is a\n * receive by testing (opcode & IB_WC_RECV).\n */\n\tIB_WC_RECV\t\t\t= 1 << 7,\n\tIB_WC_RECV_RDMA_WITH_IMM\n};\n\nenum ib_wc_flags {\n\tIB_WC_GRH\t\t= 1,\n\tIB_WC_WITH_IMM\t\t= (1<<1),\n\tIB_WC_WITH_INVALIDATE\t= (1<<2),\n\tIB_WC_IP_CSUM_OK\t= (1<<3),\n\tIB_WC_WITH_SMAC\t\t= (1<<4),\n\tIB_WC_WITH_VLAN\t\t= (1<<5),\n\tIB_WC_WITH_NETWORK_HDR_TYPE\t= (1<<6),\n};\n\nstruct ib_wc {\n\tunion {\n\t\tu64\t\twr_id;\n\t\tstruct ib_cqe\t*wr_cqe;\n\t};\n\tenum ib_wc_status\tstatus;\n\tenum ib_wc_opcode\topcode;\n\tu32\t\t\tvendor_err;\n\tu32\t\t\tbyte_len;\n\tstruct ib_qp\t       *qp;\n\tunion {\n\t\t__be32\t\timm_data;\n\t\tu32\t\tinvalidate_rkey;\n\t} ex;\n\tu32\t\t\tsrc_qp;\n\tu32\t\t\tslid;\n\tint\t\t\twc_flags;\n\tu16\t\t\tpkey_index;\n\tu8\t\t\tsl;\n\tu8\t\t\tdlid_path_bits;\n\tu8\t\t\tport_num;\t/* valid only for DR SMPs on switches */\n\tu8\t\t\tsmac[ETH_ALEN];\n\tu16\t\t\tvlan_id;\n\tu8\t\t\tnetwork_hdr_type;\n};\n\nenum ib_cq_notify_flags {\n\tIB_CQ_SOLICITED\t\t\t= 1 << 0,\n\tIB_CQ_NEXT_COMP\t\t\t= 1 << 1,\n\tIB_CQ_SOLICITED_MASK\t\t= IB_CQ_SOLICITED | IB_CQ_NEXT_COMP,\n\tIB_CQ_REPORT_MISSED_EVENTS\t= 1 << 2,\n};\n\nenum ib_srq_type {\n\tIB_SRQT_BASIC = IB_UVERBS_SRQT_BASIC,\n\tIB_SRQT_XRC = IB_UVERBS_SRQT_XRC,\n\tIB_SRQT_TM = IB_UVERBS_SRQT_TM,\n};\n\nstatic inline bool ib_srq_has_cq(enum ib_srq_type srq_type)\n{\n\treturn srq_type == IB_SRQT_XRC ||\n\t       srq_type == IB_SRQT_TM;\n}\n\nenum ib_srq_attr_mask {\n\tIB_SRQ_MAX_WR\t= 1 << 0,\n\tIB_SRQ_LIMIT\t= 1 << 1,\n};\n\nstruct ib_srq_attr {\n\tu32\tmax_wr;\n\tu32\tmax_sge;\n\tu32\tsrq_limit;\n};\n\nstruct ib_srq_init_attr {\n\tvoid\t\t      (*event_handler)(struct ib_event *, void *);\n\tvoid\t\t       *srq_context;\n\tstruct ib_srq_attr\tattr;\n\tenum ib_srq_type\tsrq_type;\n\n\tstruct {\n\t\tstruct ib_cq   *cq;\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\tstruct ib_xrcd *xrcd;\n\t\t\t} xrc;\n\n\t\t\tstruct {\n\t\t\t\tu32\t\tmax_num_tags;\n\t\t\t} tag_matching;\n\t\t};\n\t} ext;\n};\n\nstruct ib_qp_cap {\n\tu32\tmax_send_wr;\n\tu32\tmax_recv_wr;\n\tu32\tmax_send_sge;\n\tu32\tmax_recv_sge;\n\tu32\tmax_inline_data;\n\n\t/*\n\t * Maximum number of rdma_rw_ctx structures in flight at a time.\n\t * ib_create_qp() will calculate the right amount of neededed WRs\n\t * and MRs based on this.\n\t */\n\tu32\tmax_rdma_ctxs;\n};\n\nenum ib_sig_type {\n\tIB_SIGNAL_ALL_WR,\n\tIB_SIGNAL_REQ_WR\n};\n\nenum ib_qp_type {\n\t/*\n\t * IB_QPT_SMI and IB_QPT_GSI have to be the first two entries\n\t * here (and in that order) since the MAD layer uses them as\n\t * indices into a 2-entry table.\n\t */\n\tIB_QPT_SMI,\n\tIB_QPT_GSI,\n\n\tIB_QPT_RC = IB_UVERBS_QPT_RC,\n\tIB_QPT_UC = IB_UVERBS_QPT_UC,\n\tIB_QPT_UD = IB_UVERBS_QPT_UD,\n\tIB_QPT_RAW_IPV6,\n\tIB_QPT_RAW_ETHERTYPE,\n\tIB_QPT_RAW_PACKET = IB_UVERBS_QPT_RAW_PACKET,\n\tIB_QPT_XRC_INI = IB_UVERBS_QPT_XRC_INI,\n\tIB_QPT_XRC_TGT = IB_UVERBS_QPT_XRC_TGT,\n\tIB_QPT_MAX,\n\tIB_QPT_DRIVER = IB_UVERBS_QPT_DRIVER,\n\t/* Reserve a range for qp types internal to the low level driver.\n\t * These qp types will not be visible at the IB core layer, so the\n\t * IB_QPT_MAX usages should not be affected in the core layer\n\t */\n\tIB_QPT_RESERVED1 = 0x1000,\n\tIB_QPT_RESERVED2,\n\tIB_QPT_RESERVED3,\n\tIB_QPT_RESERVED4,\n\tIB_QPT_RESERVED5,\n\tIB_QPT_RESERVED6,\n\tIB_QPT_RESERVED7,\n\tIB_QPT_RESERVED8,\n\tIB_QPT_RESERVED9,\n\tIB_QPT_RESERVED10,\n};\n\nenum ib_qp_create_flags {\n\tIB_QP_CREATE_IPOIB_UD_LSO\t\t= 1 << 0,\n\tIB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK\t=\n\t\tIB_UVERBS_QP_CREATE_BLOCK_MULTICAST_LOOPBACK,\n\tIB_QP_CREATE_CROSS_CHANNEL              = 1 << 2,\n\tIB_QP_CREATE_MANAGED_SEND               = 1 << 3,\n\tIB_QP_CREATE_MANAGED_RECV               = 1 << 4,\n\tIB_QP_CREATE_NETIF_QP\t\t\t= 1 << 5,\n\tIB_QP_CREATE_INTEGRITY_EN\t\t= 1 << 6,\n\tIB_QP_CREATE_NETDEV_USE\t\t\t= 1 << 7,\n\tIB_QP_CREATE_SCATTER_FCS\t\t=\n\t\tIB_UVERBS_QP_CREATE_SCATTER_FCS,\n\tIB_QP_CREATE_CVLAN_STRIPPING\t\t=\n\t\tIB_UVERBS_QP_CREATE_CVLAN_STRIPPING,\n\tIB_QP_CREATE_SOURCE_QPN\t\t\t= 1 << 10,\n\tIB_QP_CREATE_PCI_WRITE_END_PADDING\t=\n\t\tIB_UVERBS_QP_CREATE_PCI_WRITE_END_PADDING,\n\t/* reserve bits 26-31 for low level drivers' internal use */\n\tIB_QP_CREATE_RESERVED_START\t\t= 1 << 26,\n\tIB_QP_CREATE_RESERVED_END\t\t= 1 << 31,\n};\n\n/*\n * Note: users may not call ib_close_qp or ib_destroy_qp from the event_handler\n * callback to destroy the passed in QP.\n */\n\nstruct ib_qp_init_attr {\n\t/* Consumer's event_handler callback must not block */\n\tvoid                  (*event_handler)(struct ib_event *, void *);\n\n\tvoid\t\t       *qp_context;\n\tstruct ib_cq\t       *send_cq;\n\tstruct ib_cq\t       *recv_cq;\n\tstruct ib_srq\t       *srq;\n\tstruct ib_xrcd\t       *xrcd;     /* XRC TGT QPs only */\n\tstruct ib_qp_cap\tcap;\n\tenum ib_sig_type\tsq_sig_type;\n\tenum ib_qp_type\t\tqp_type;\n\tu32\t\t\tcreate_flags;\n\n\t/*\n\t * Only needed for special QP types, or when using the RW API.\n\t */\n\tu8\t\t\tport_num;\n\tstruct ib_rwq_ind_table *rwq_ind_tbl;\n\tu32\t\t\tsource_qpn;\n};\n\nstruct ib_qp_open_attr {\n\tvoid                  (*event_handler)(struct ib_event *, void *);\n\tvoid\t\t       *qp_context;\n\tu32\t\t\tqp_num;\n\tenum ib_qp_type\t\tqp_type;\n};\n\nenum ib_rnr_timeout {\n\tIB_RNR_TIMER_655_36 =  0,\n\tIB_RNR_TIMER_000_01 =  1,\n\tIB_RNR_TIMER_000_02 =  2,\n\tIB_RNR_TIMER_000_03 =  3,\n\tIB_RNR_TIMER_000_04 =  4,\n\tIB_RNR_TIMER_000_06 =  5,\n\tIB_RNR_TIMER_000_08 =  6,\n\tIB_RNR_TIMER_000_12 =  7,\n\tIB_RNR_TIMER_000_16 =  8,\n\tIB_RNR_TIMER_000_24 =  9,\n\tIB_RNR_TIMER_000_32 = 10,\n\tIB_RNR_TIMER_000_48 = 11,\n\tIB_RNR_TIMER_000_64 = 12,\n\tIB_RNR_TIMER_000_96 = 13,\n\tIB_RNR_TIMER_001_28 = 14,\n\tIB_RNR_TIMER_001_92 = 15,\n\tIB_RNR_TIMER_002_56 = 16,\n\tIB_RNR_TIMER_003_84 = 17,\n\tIB_RNR_TIMER_005_12 = 18,\n\tIB_RNR_TIMER_007_68 = 19,\n\tIB_RNR_TIMER_010_24 = 20,\n\tIB_RNR_TIMER_015_36 = 21,\n\tIB_RNR_TIMER_020_48 = 22,\n\tIB_RNR_TIMER_030_72 = 23,\n\tIB_RNR_TIMER_040_96 = 24,\n\tIB_RNR_TIMER_061_44 = 25,\n\tIB_RNR_TIMER_081_92 = 26,\n\tIB_RNR_TIMER_122_88 = 27,\n\tIB_RNR_TIMER_163_84 = 28,\n\tIB_RNR_TIMER_245_76 = 29,\n\tIB_RNR_TIMER_327_68 = 30,\n\tIB_RNR_TIMER_491_52 = 31\n};\n\nenum ib_qp_attr_mask {\n\tIB_QP_STATE\t\t\t= 1,\n\tIB_QP_CUR_STATE\t\t\t= (1<<1),\n\tIB_QP_EN_SQD_ASYNC_NOTIFY\t= (1<<2),\n\tIB_QP_ACCESS_FLAGS\t\t= (1<<3),\n\tIB_QP_PKEY_INDEX\t\t= (1<<4),\n\tIB_QP_PORT\t\t\t= (1<<5),\n\tIB_QP_QKEY\t\t\t= (1<<6),\n\tIB_QP_AV\t\t\t= (1<<7),\n\tIB_QP_PATH_MTU\t\t\t= (1<<8),\n\tIB_QP_TIMEOUT\t\t\t= (1<<9),\n\tIB_QP_RETRY_CNT\t\t\t= (1<<10),\n\tIB_QP_RNR_RETRY\t\t\t= (1<<11),\n\tIB_QP_RQ_PSN\t\t\t= (1<<12),\n\tIB_QP_MAX_QP_RD_ATOMIC\t\t= (1<<13),\n\tIB_QP_ALT_PATH\t\t\t= (1<<14),\n\tIB_QP_MIN_RNR_TIMER\t\t= (1<<15),\n\tIB_QP_SQ_PSN\t\t\t= (1<<16),\n\tIB_QP_MAX_DEST_RD_ATOMIC\t= (1<<17),\n\tIB_QP_PATH_MIG_STATE\t\t= (1<<18),\n\tIB_QP_CAP\t\t\t= (1<<19),\n\tIB_QP_DEST_QPN\t\t\t= (1<<20),\n\tIB_QP_RESERVED1\t\t\t= (1<<21),\n\tIB_QP_RESERVED2\t\t\t= (1<<22),\n\tIB_QP_RESERVED3\t\t\t= (1<<23),\n\tIB_QP_RESERVED4\t\t\t= (1<<24),\n\tIB_QP_RATE_LIMIT\t\t= (1<<25),\n\n\tIB_QP_ATTR_STANDARD_BITS = GENMASK(20, 0),\n};\n\nenum ib_qp_state {\n\tIB_QPS_RESET,\n\tIB_QPS_INIT,\n\tIB_QPS_RTR,\n\tIB_QPS_RTS,\n\tIB_QPS_SQD,\n\tIB_QPS_SQE,\n\tIB_QPS_ERR\n};\n\nenum ib_mig_state {\n\tIB_MIG_MIGRATED,\n\tIB_MIG_REARM,\n\tIB_MIG_ARMED\n};\n\nenum ib_mw_type {\n\tIB_MW_TYPE_1 = 1,\n\tIB_MW_TYPE_2 = 2\n};\n\nstruct ib_qp_attr {\n\tenum ib_qp_state\tqp_state;\n\tenum ib_qp_state\tcur_qp_state;\n\tenum ib_mtu\t\tpath_mtu;\n\tenum ib_mig_state\tpath_mig_state;\n\tu32\t\t\tqkey;\n\tu32\t\t\trq_psn;\n\tu32\t\t\tsq_psn;\n\tu32\t\t\tdest_qp_num;\n\tint\t\t\tqp_access_flags;\n\tstruct ib_qp_cap\tcap;\n\tstruct rdma_ah_attr\tah_attr;\n\tstruct rdma_ah_attr\talt_ah_attr;\n\tu16\t\t\tpkey_index;\n\tu16\t\t\talt_pkey_index;\n\tu8\t\t\ten_sqd_async_notify;\n\tu8\t\t\tsq_draining;\n\tu8\t\t\tmax_rd_atomic;\n\tu8\t\t\tmax_dest_rd_atomic;\n\tu8\t\t\tmin_rnr_timer;\n\tu8\t\t\tport_num;\n\tu8\t\t\ttimeout;\n\tu8\t\t\tretry_cnt;\n\tu8\t\t\trnr_retry;\n\tu8\t\t\talt_port_num;\n\tu8\t\t\talt_timeout;\n\tu32\t\t\trate_limit;\n\tstruct net_device\t*xmit_slave;\n};\n\nenum ib_wr_opcode {\n\t/* These are shared with userspace */\n\tIB_WR_RDMA_WRITE = IB_UVERBS_WR_RDMA_WRITE,\n\tIB_WR_RDMA_WRITE_WITH_IMM = IB_UVERBS_WR_RDMA_WRITE_WITH_IMM,\n\tIB_WR_SEND = IB_UVERBS_WR_SEND,\n\tIB_WR_SEND_WITH_IMM = IB_UVERBS_WR_SEND_WITH_IMM,\n\tIB_WR_RDMA_READ = IB_UVERBS_WR_RDMA_READ,\n\tIB_WR_ATOMIC_CMP_AND_SWP = IB_UVERBS_WR_ATOMIC_CMP_AND_SWP,\n\tIB_WR_ATOMIC_FETCH_AND_ADD = IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD,\n\tIB_WR_BIND_MW = IB_UVERBS_WR_BIND_MW,\n\tIB_WR_LSO = IB_UVERBS_WR_TSO,\n\tIB_WR_SEND_WITH_INV = IB_UVERBS_WR_SEND_WITH_INV,\n\tIB_WR_RDMA_READ_WITH_INV = IB_UVERBS_WR_RDMA_READ_WITH_INV,\n\tIB_WR_LOCAL_INV = IB_UVERBS_WR_LOCAL_INV,\n\tIB_WR_MASKED_ATOMIC_CMP_AND_SWP =\n\t\tIB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP,\n\tIB_WR_MASKED_ATOMIC_FETCH_AND_ADD =\n\t\tIB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD,\n\n\t/* These are kernel only and can not be issued by userspace */\n\tIB_WR_REG_MR = 0x20,\n\tIB_WR_REG_MR_INTEGRITY,\n\n\t/* reserve values for low level drivers' internal use.\n\t * These values will not be used at all in the ib core layer.\n\t */\n\tIB_WR_RESERVED1 = 0xf0,\n\tIB_WR_RESERVED2,\n\tIB_WR_RESERVED3,\n\tIB_WR_RESERVED4,\n\tIB_WR_RESERVED5,\n\tIB_WR_RESERVED6,\n\tIB_WR_RESERVED7,\n\tIB_WR_RESERVED8,\n\tIB_WR_RESERVED9,\n\tIB_WR_RESERVED10,\n};\n\nenum ib_send_flags {\n\tIB_SEND_FENCE\t\t= 1,\n\tIB_SEND_SIGNALED\t= (1<<1),\n\tIB_SEND_SOLICITED\t= (1<<2),\n\tIB_SEND_INLINE\t\t= (1<<3),\n\tIB_SEND_IP_CSUM\t\t= (1<<4),\n\n\t/* reserve bits 26-31 for low level drivers' internal use */\n\tIB_SEND_RESERVED_START\t= (1 << 26),\n\tIB_SEND_RESERVED_END\t= (1 << 31),\n};\n\nstruct ib_sge {\n\tu64\taddr;\n\tu32\tlength;\n\tu32\tlkey;\n};\n\nstruct ib_cqe {\n\tvoid (*done)(struct ib_cq *cq, struct ib_wc *wc);\n};\n\nstruct ib_send_wr {\n\tstruct ib_send_wr      *next;\n\tunion {\n\t\tu64\t\twr_id;\n\t\tstruct ib_cqe\t*wr_cqe;\n\t};\n\tstruct ib_sge\t       *sg_list;\n\tint\t\t\tnum_sge;\n\tenum ib_wr_opcode\topcode;\n\tint\t\t\tsend_flags;\n\tunion {\n\t\t__be32\t\timm_data;\n\t\tu32\t\tinvalidate_rkey;\n\t} ex;\n};\n\nstruct ib_rdma_wr {\n\tstruct ib_send_wr\twr;\n\tu64\t\t\tremote_addr;\n\tu32\t\t\trkey;\n};\n\nstatic inline const struct ib_rdma_wr *rdma_wr(const struct ib_send_wr *wr)\n{\n\treturn container_of(wr, struct ib_rdma_wr, wr);\n}\n\nstruct ib_atomic_wr {\n\tstruct ib_send_wr\twr;\n\tu64\t\t\tremote_addr;\n\tu64\t\t\tcompare_add;\n\tu64\t\t\tswap;\n\tu64\t\t\tcompare_add_mask;\n\tu64\t\t\tswap_mask;\n\tu32\t\t\trkey;\n};\n\nstatic inline const struct ib_atomic_wr *atomic_wr(const struct ib_send_wr *wr)\n{\n\treturn container_of(wr, struct ib_atomic_wr, wr);\n}\n\nstruct ib_ud_wr {\n\tstruct ib_send_wr\twr;\n\tstruct ib_ah\t\t*ah;\n\tvoid\t\t\t*header;\n\tint\t\t\thlen;\n\tint\t\t\tmss;\n\tu32\t\t\tremote_qpn;\n\tu32\t\t\tremote_qkey;\n\tu16\t\t\tpkey_index; /* valid for GSI only */\n\tu8\t\t\tport_num;   /* valid for DR SMPs on switch only */\n};\n\nstatic inline const struct ib_ud_wr *ud_wr(const struct ib_send_wr *wr)\n{\n\treturn container_of(wr, struct ib_ud_wr, wr);\n}\n\nstruct ib_reg_wr {\n\tstruct ib_send_wr\twr;\n\tstruct ib_mr\t\t*mr;\n\tu32\t\t\tkey;\n\tint\t\t\taccess;\n};\n\nstatic inline const struct ib_reg_wr *reg_wr(const struct ib_send_wr *wr)\n{\n\treturn container_of(wr, struct ib_reg_wr, wr);\n}\n\nstruct ib_recv_wr {\n\tstruct ib_recv_wr      *next;\n\tunion {\n\t\tu64\t\twr_id;\n\t\tstruct ib_cqe\t*wr_cqe;\n\t};\n\tstruct ib_sge\t       *sg_list;\n\tint\t\t\tnum_sge;\n};\n\nenum ib_access_flags {\n\tIB_ACCESS_LOCAL_WRITE = IB_UVERBS_ACCESS_LOCAL_WRITE,\n\tIB_ACCESS_REMOTE_WRITE = IB_UVERBS_ACCESS_REMOTE_WRITE,\n\tIB_ACCESS_REMOTE_READ = IB_UVERBS_ACCESS_REMOTE_READ,\n\tIB_ACCESS_REMOTE_ATOMIC = IB_UVERBS_ACCESS_REMOTE_ATOMIC,\n\tIB_ACCESS_MW_BIND = IB_UVERBS_ACCESS_MW_BIND,\n\tIB_ZERO_BASED = IB_UVERBS_ACCESS_ZERO_BASED,\n\tIB_ACCESS_ON_DEMAND = IB_UVERBS_ACCESS_ON_DEMAND,\n\tIB_ACCESS_HUGETLB = IB_UVERBS_ACCESS_HUGETLB,\n\tIB_ACCESS_RELAXED_ORDERING = IB_UVERBS_ACCESS_RELAXED_ORDERING,\n\n\tIB_ACCESS_OPTIONAL = IB_UVERBS_ACCESS_OPTIONAL_RANGE,\n\tIB_ACCESS_SUPPORTED =\n\t\t((IB_ACCESS_HUGETLB << 1) - 1) | IB_ACCESS_OPTIONAL,\n};\n\n/*\n * XXX: these are apparently used for ->rereg_user_mr, no idea why they\n * are hidden here instead of a uapi header!\n */\nenum ib_mr_rereg_flags {\n\tIB_MR_REREG_TRANS\t= 1,\n\tIB_MR_REREG_PD\t\t= (1<<1),\n\tIB_MR_REREG_ACCESS\t= (1<<2),\n\tIB_MR_REREG_SUPPORTED\t= ((IB_MR_REREG_ACCESS << 1) - 1)\n};\n\nstruct ib_umem;\n\nenum rdma_remove_reason {\n\t/*\n\t * Userspace requested uobject deletion or initial try\n\t * to remove uobject via cleanup. Call could fail\n\t */\n\tRDMA_REMOVE_DESTROY,\n\t/* Context deletion. This call should delete the actual object itself */\n\tRDMA_REMOVE_CLOSE,\n\t/* Driver is being hot-unplugged. This call should delete the actual object itself */\n\tRDMA_REMOVE_DRIVER_REMOVE,\n\t/* uobj is being cleaned-up before being committed */\n\tRDMA_REMOVE_ABORT,\n\t/* The driver failed to destroy the uobject and is being disconnected */\n\tRDMA_REMOVE_DRIVER_FAILURE,\n};\n\nstruct ib_rdmacg_object {\n#ifdef CONFIG_CGROUP_RDMA\n\tstruct rdma_cgroup\t*cg;\t\t/* owner rdma cgroup */\n#endif\n};\n\nstruct ib_ucontext {\n\tstruct ib_device       *device;\n\tstruct ib_uverbs_file  *ufile;\n\n\tstruct ib_rdmacg_object\tcg_obj;\n\t/*\n\t * Implementation details of the RDMA core, don't use in drivers:\n\t */\n\tstruct rdma_restrack_entry res;\n\tstruct xarray mmap_xa;\n};\n\nstruct ib_uobject {\n\tu64\t\t\tuser_handle;\t/* handle given to us by userspace */\n\t/* ufile & ucontext owning this object */\n\tstruct ib_uverbs_file  *ufile;\n\t/* FIXME, save memory: ufile->context == context */\n\tstruct ib_ucontext     *context;\t/* associated user context */\n\tvoid\t\t       *object;\t\t/* containing object */\n\tstruct list_head\tlist;\t\t/* link to context's list */\n\tstruct ib_rdmacg_object\tcg_obj;\t\t/* rdmacg object */\n\tint\t\t\tid;\t\t/* index into kernel idr */\n\tstruct kref\t\tref;\n\tatomic_t\t\tusecnt;\t\t/* protects exclusive access */\n\tstruct rcu_head\t\trcu;\t\t/* kfree_rcu() overhead */\n\n\tconst struct uverbs_api_object *uapi_object;\n};\n\nstruct ib_udata {\n\tconst void __user *inbuf;\n\tvoid __user *outbuf;\n\tsize_t       inlen;\n\tsize_t       outlen;\n};\n\nstruct ib_pd {\n\tu32\t\t\tlocal_dma_lkey;\n\tu32\t\t\tflags;\n\tstruct ib_device       *device;\n\tstruct ib_uobject      *uobject;\n\tatomic_t          \tusecnt; /* count all resources */\n\n\tu32\t\t\tunsafe_global_rkey;\n\n\t/*\n\t * Implementation details of the RDMA core, don't use in drivers:\n\t */\n\tstruct ib_mr\t       *__internal_mr;\n\tstruct rdma_restrack_entry res;\n};\n\nstruct ib_xrcd {\n\tstruct ib_device       *device;\n\tatomic_t\t\tusecnt; /* count all exposed resources */\n\tstruct inode\t       *inode;\n\tstruct rw_semaphore\ttgt_qps_rwsem;\n\tstruct xarray\t\ttgt_qps;\n};\n\nstruct ib_ah {\n\tstruct ib_device\t*device;\n\tstruct ib_pd\t\t*pd;\n\tstruct ib_uobject\t*uobject;\n\tconst struct ib_gid_attr *sgid_attr;\n\tenum rdma_ah_attr_type\ttype;\n};\n\ntypedef void (*ib_comp_handler)(struct ib_cq *cq, void *cq_context);\n\nenum ib_poll_context {\n\tIB_POLL_SOFTIRQ,\t   /* poll from softirq context */\n\tIB_POLL_WORKQUEUE,\t   /* poll from workqueue */\n\tIB_POLL_UNBOUND_WORKQUEUE, /* poll from unbound workqueue */\n\tIB_POLL_LAST_POOL_TYPE = IB_POLL_UNBOUND_WORKQUEUE,\n\n\tIB_POLL_DIRECT,\t\t   /* caller context, no hw completions */\n};\n\nstruct ib_cq {\n\tstruct ib_device       *device;\n\tstruct ib_ucq_object   *uobject;\n\tib_comp_handler   \tcomp_handler;\n\tvoid                  (*event_handler)(struct ib_event *, void *);\n\tvoid                   *cq_context;\n\tint               \tcqe;\n\tunsigned int\t\tcqe_used;\n\tatomic_t          \tusecnt; /* count number of work queues */\n\tenum ib_poll_context\tpoll_ctx;\n\tstruct ib_wc\t\t*wc;\n\tstruct list_head        pool_entry;\n\tunion {\n\t\tstruct irq_poll\t\tiop;\n\t\tstruct work_struct\twork;\n\t};\n\tstruct workqueue_struct *comp_wq;\n\tstruct dim *dim;\n\n\t/* updated only by trace points */\n\tktime_t timestamp;\n\tu8 interrupt:1;\n\tu8 shared:1;\n\tunsigned int comp_vector;\n\n\t/*\n\t * Implementation details of the RDMA core, don't use in drivers:\n\t */\n\tstruct rdma_restrack_entry res;\n};\n\nstruct ib_srq {\n\tstruct ib_device       *device;\n\tstruct ib_pd\t       *pd;\n\tstruct ib_usrq_object  *uobject;\n\tvoid\t\t      (*event_handler)(struct ib_event *, void *);\n\tvoid\t\t       *srq_context;\n\tenum ib_srq_type\tsrq_type;\n\tatomic_t\t\tusecnt;\n\n\tstruct {\n\t\tstruct ib_cq   *cq;\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\tstruct ib_xrcd *xrcd;\n\t\t\t\tu32\t\tsrq_num;\n\t\t\t} xrc;\n\t\t};\n\t} ext;\n};\n\nenum ib_raw_packet_caps {\n\t/* Strip cvlan from incoming packet and report it in the matching work\n\t * completion is supported.\n\t */\n\tIB_RAW_PACKET_CAP_CVLAN_STRIPPING\t= (1 << 0),\n\t/* Scatter FCS field of an incoming packet to host memory is supported.\n\t */\n\tIB_RAW_PACKET_CAP_SCATTER_FCS\t\t= (1 << 1),\n\t/* Checksum offloads are supported (for both send and receive). */\n\tIB_RAW_PACKET_CAP_IP_CSUM\t\t= (1 << 2),\n\t/* When a packet is received for an RQ with no receive WQEs, the\n\t * packet processing is delayed.\n\t */\n\tIB_RAW_PACKET_CAP_DELAY_DROP\t\t= (1 << 3),\n};\n\nenum ib_wq_type {\n\tIB_WQT_RQ = IB_UVERBS_WQT_RQ,\n};\n\nenum ib_wq_state {\n\tIB_WQS_RESET,\n\tIB_WQS_RDY,\n\tIB_WQS_ERR\n};\n\nstruct ib_wq {\n\tstruct ib_device       *device;\n\tstruct ib_uwq_object   *uobject;\n\tvoid\t\t    *wq_context;\n\tvoid\t\t    (*event_handler)(struct ib_event *, void *);\n\tstruct ib_pd\t       *pd;\n\tstruct ib_cq\t       *cq;\n\tu32\t\twq_num;\n\tenum ib_wq_state       state;\n\tenum ib_wq_type\twq_type;\n\tatomic_t\t\tusecnt;\n};\n\nenum ib_wq_flags {\n\tIB_WQ_FLAGS_CVLAN_STRIPPING\t= IB_UVERBS_WQ_FLAGS_CVLAN_STRIPPING,\n\tIB_WQ_FLAGS_SCATTER_FCS\t\t= IB_UVERBS_WQ_FLAGS_SCATTER_FCS,\n\tIB_WQ_FLAGS_DELAY_DROP\t\t= IB_UVERBS_WQ_FLAGS_DELAY_DROP,\n\tIB_WQ_FLAGS_PCI_WRITE_END_PADDING =\n\t\t\t\tIB_UVERBS_WQ_FLAGS_PCI_WRITE_END_PADDING,\n};\n\nstruct ib_wq_init_attr {\n\tvoid\t\t       *wq_context;\n\tenum ib_wq_type\twq_type;\n\tu32\t\tmax_wr;\n\tu32\t\tmax_sge;\n\tstruct\tib_cq\t       *cq;\n\tvoid\t\t    (*event_handler)(struct ib_event *, void *);\n\tu32\t\tcreate_flags; /* Use enum ib_wq_flags */\n};\n\nenum ib_wq_attr_mask {\n\tIB_WQ_STATE\t\t= 1 << 0,\n\tIB_WQ_CUR_STATE\t\t= 1 << 1,\n\tIB_WQ_FLAGS\t\t= 1 << 2,\n};\n\nstruct ib_wq_attr {\n\tenum\tib_wq_state\twq_state;\n\tenum\tib_wq_state\tcurr_wq_state;\n\tu32\t\t\tflags; /* Use enum ib_wq_flags */\n\tu32\t\t\tflags_mask; /* Use enum ib_wq_flags */\n};\n\nstruct ib_rwq_ind_table {\n\tstruct ib_device\t*device;\n\tstruct ib_uobject      *uobject;\n\tatomic_t\t\tusecnt;\n\tu32\t\tind_tbl_num;\n\tu32\t\tlog_ind_tbl_size;\n\tstruct ib_wq\t**ind_tbl;\n};\n\nstruct ib_rwq_ind_table_init_attr {\n\tu32\t\tlog_ind_tbl_size;\n\t/* Each entry is a pointer to Receive Work Queue */\n\tstruct ib_wq\t**ind_tbl;\n};\n\nenum port_pkey_state {\n\tIB_PORT_PKEY_NOT_VALID = 0,\n\tIB_PORT_PKEY_VALID = 1,\n\tIB_PORT_PKEY_LISTED = 2,\n};\n\nstruct ib_qp_security;\n\nstruct ib_port_pkey {\n\tenum port_pkey_state\tstate;\n\tu16\t\t\tpkey_index;\n\tu8\t\t\tport_num;\n\tstruct list_head\tqp_list;\n\tstruct list_head\tto_error_list;\n\tstruct ib_qp_security  *sec;\n};\n\nstruct ib_ports_pkeys {\n\tstruct ib_port_pkey\tmain;\n\tstruct ib_port_pkey\talt;\n};\n\nstruct ib_qp_security {\n\tstruct ib_qp\t       *qp;\n\tstruct ib_device       *dev;\n\t/* Hold this mutex when changing port and pkey settings. */\n\tstruct mutex\t\tmutex;\n\tstruct ib_ports_pkeys  *ports_pkeys;\n\t/* A list of all open shared QP handles.  Required to enforce security\n\t * properly for all users of a shared QP.\n\t */\n\tstruct list_head        shared_qp_list;\n\tvoid                   *security;\n\tbool\t\t\tdestroying;\n\tatomic_t\t\terror_list_count;\n\tstruct completion\terror_complete;\n\tint\t\t\terror_comps_pending;\n};\n\n/*\n * @max_write_sge: Maximum SGE elements per RDMA WRITE request.\n * @max_read_sge:  Maximum SGE elements per RDMA READ request.\n */\nstruct ib_qp {\n\tstruct ib_device       *device;\n\tstruct ib_pd\t       *pd;\n\tstruct ib_cq\t       *send_cq;\n\tstruct ib_cq\t       *recv_cq;\n\tspinlock_t\t\tmr_lock;\n\tint\t\t\tmrs_used;\n\tstruct list_head\trdma_mrs;\n\tstruct list_head\tsig_mrs;\n\tstruct ib_srq\t       *srq;\n\tstruct ib_xrcd\t       *xrcd; /* XRC TGT QPs only */\n\tstruct list_head\txrcd_list;\n\n\t/* count times opened, mcast attaches, flow attaches */\n\tatomic_t\t\tusecnt;\n\tstruct list_head\topen_list;\n\tstruct ib_qp           *real_qp;\n\tstruct ib_uqp_object   *uobject;\n\tvoid                  (*event_handler)(struct ib_event *, void *);\n\tvoid\t\t       *qp_context;\n\t/* sgid_attrs associated with the AV's */\n\tconst struct ib_gid_attr *av_sgid_attr;\n\tconst struct ib_gid_attr *alt_path_sgid_attr;\n\tu32\t\t\tqp_num;\n\tu32\t\t\tmax_write_sge;\n\tu32\t\t\tmax_read_sge;\n\tenum ib_qp_type\t\tqp_type;\n\tstruct ib_rwq_ind_table *rwq_ind_tbl;\n\tstruct ib_qp_security  *qp_sec;\n\tu8\t\t\tport;\n\n\tbool\t\t\tintegrity_en;\n\t/*\n\t * Implementation details of the RDMA core, don't use in drivers:\n\t */\n\tstruct rdma_restrack_entry     res;\n\n\t/* The counter the qp is bind to */\n\tstruct rdma_counter    *counter;\n};\n\nstruct ib_dm {\n\tstruct ib_device  *device;\n\tu32\t\t   length;\n\tu32\t\t   flags;\n\tstruct ib_uobject *uobject;\n\tatomic_t\t   usecnt;\n};\n\nstruct ib_mr {\n\tstruct ib_device  *device;\n\tstruct ib_pd\t  *pd;\n\tu32\t\t   lkey;\n\tu32\t\t   rkey;\n\tu64\t\t   iova;\n\tu64\t\t   length;\n\tunsigned int\t   page_size;\n\tenum ib_mr_type\t   type;\n\tbool\t\t   need_inval;\n\tunion {\n\t\tstruct ib_uobject\t*uobject;\t/* user */\n\t\tstruct list_head\tqp_entry;\t/* FR */\n\t};\n\n\tstruct ib_dm      *dm;\n\tstruct ib_sig_attrs *sig_attrs; /* only for IB_MR_TYPE_INTEGRITY MRs */\n\t/*\n\t * Implementation details of the RDMA core, don't use in drivers:\n\t */\n\tstruct rdma_restrack_entry res;\n};\n\nstruct ib_mw {\n\tstruct ib_device\t*device;\n\tstruct ib_pd\t\t*pd;\n\tstruct ib_uobject\t*uobject;\n\tu32\t\t\trkey;\n\tenum ib_mw_type         type;\n};\n\n/* Supported steering options */\nenum ib_flow_attr_type {\n\t/* steering according to rule specifications */\n\tIB_FLOW_ATTR_NORMAL\t\t= 0x0,\n\t/* default unicast and multicast rule -\n\t * receive all Eth traffic which isn't steered to any QP\n\t */\n\tIB_FLOW_ATTR_ALL_DEFAULT\t= 0x1,\n\t/* default multicast rule -\n\t * receive all Eth multicast traffic which isn't steered to any QP\n\t */\n\tIB_FLOW_ATTR_MC_DEFAULT\t\t= 0x2,\n\t/* sniffer rule - receive all port traffic */\n\tIB_FLOW_ATTR_SNIFFER\t\t= 0x3\n};\n\n/* Supported steering header types */\nenum ib_flow_spec_type {\n\t/* L2 headers*/\n\tIB_FLOW_SPEC_ETH\t\t= 0x20,\n\tIB_FLOW_SPEC_IB\t\t\t= 0x22,\n\t/* L3 header*/\n\tIB_FLOW_SPEC_IPV4\t\t= 0x30,\n\tIB_FLOW_SPEC_IPV6\t\t= 0x31,\n\tIB_FLOW_SPEC_ESP                = 0x34,\n\t/* L4 headers*/\n\tIB_FLOW_SPEC_TCP\t\t= 0x40,\n\tIB_FLOW_SPEC_UDP\t\t= 0x41,\n\tIB_FLOW_SPEC_VXLAN_TUNNEL\t= 0x50,\n\tIB_FLOW_SPEC_GRE\t\t= 0x51,\n\tIB_FLOW_SPEC_MPLS\t\t= 0x60,\n\tIB_FLOW_SPEC_INNER\t\t= 0x100,\n\t/* Actions */\n\tIB_FLOW_SPEC_ACTION_TAG         = 0x1000,\n\tIB_FLOW_SPEC_ACTION_DROP        = 0x1001,\n\tIB_FLOW_SPEC_ACTION_HANDLE\t= 0x1002,\n\tIB_FLOW_SPEC_ACTION_COUNT       = 0x1003,\n};\n#define IB_FLOW_SPEC_LAYER_MASK\t0xF0\n#define IB_FLOW_SPEC_SUPPORT_LAYERS 10\n\nenum ib_flow_flags {\n\tIB_FLOW_ATTR_FLAGS_DONT_TRAP = 1UL << 1, /* Continue match, no steal */\n\tIB_FLOW_ATTR_FLAGS_EGRESS = 1UL << 2, /* Egress flow */\n\tIB_FLOW_ATTR_FLAGS_RESERVED  = 1UL << 3  /* Must be last */\n};\n\nstruct ib_flow_eth_filter {\n\tu8\tdst_mac[6];\n\tu8\tsrc_mac[6];\n\t__be16\tether_type;\n\t__be16\tvlan_tag;\n\t/* Must be last */\n\tu8\treal_sz[];\n};\n\nstruct ib_flow_spec_eth {\n\tu32\t\t\t  type;\n\tu16\t\t\t  size;\n\tstruct ib_flow_eth_filter val;\n\tstruct ib_flow_eth_filter mask;\n};\n\nstruct ib_flow_ib_filter {\n\t__be16 dlid;\n\t__u8   sl;\n\t/* Must be last */\n\tu8\treal_sz[];\n};\n\nstruct ib_flow_spec_ib {\n\tu32\t\t\t type;\n\tu16\t\t\t size;\n\tstruct ib_flow_ib_filter val;\n\tstruct ib_flow_ib_filter mask;\n};\n\n/* IPv4 header flags */\nenum ib_ipv4_flags {\n\tIB_IPV4_DONT_FRAG = 0x2, /* Don't enable packet fragmentation */\n\tIB_IPV4_MORE_FRAG = 0X4  /* For All fragmented packets except the\n\t\t\t\t    last have this flag set */\n};\n\nstruct ib_flow_ipv4_filter {\n\t__be32\tsrc_ip;\n\t__be32\tdst_ip;\n\tu8\tproto;\n\tu8\ttos;\n\tu8\tttl;\n\tu8\tflags;\n\t/* Must be last */\n\tu8\treal_sz[];\n};\n\nstruct ib_flow_spec_ipv4 {\n\tu32\t\t\t   type;\n\tu16\t\t\t   size;\n\tstruct ib_flow_ipv4_filter val;\n\tstruct ib_flow_ipv4_filter mask;\n};\n\nstruct ib_flow_ipv6_filter {\n\tu8\tsrc_ip[16];\n\tu8\tdst_ip[16];\n\t__be32\tflow_label;\n\tu8\tnext_hdr;\n\tu8\ttraffic_class;\n\tu8\thop_limit;\n\t/* Must be last */\n\tu8\treal_sz[];\n};\n\nstruct ib_flow_spec_ipv6 {\n\tu32\t\t\t   type;\n\tu16\t\t\t   size;\n\tstruct ib_flow_ipv6_filter val;\n\tstruct ib_flow_ipv6_filter mask;\n};\n\nstruct ib_flow_tcp_udp_filter {\n\t__be16\tdst_port;\n\t__be16\tsrc_port;\n\t/* Must be last */\n\tu8\treal_sz[];\n};\n\nstruct ib_flow_spec_tcp_udp {\n\tu32\t\t\t      type;\n\tu16\t\t\t      size;\n\tstruct ib_flow_tcp_udp_filter val;\n\tstruct ib_flow_tcp_udp_filter mask;\n};\n\nstruct ib_flow_tunnel_filter {\n\t__be32\ttunnel_id;\n\tu8\treal_sz[];\n};\n\n/* ib_flow_spec_tunnel describes the Vxlan tunnel\n * the tunnel_id from val has the vni value\n */\nstruct ib_flow_spec_tunnel {\n\tu32\t\t\t      type;\n\tu16\t\t\t      size;\n\tstruct ib_flow_tunnel_filter  val;\n\tstruct ib_flow_tunnel_filter  mask;\n};\n\nstruct ib_flow_esp_filter {\n\t__be32\tspi;\n\t__be32  seq;\n\t/* Must be last */\n\tu8\treal_sz[];\n};\n\nstruct ib_flow_spec_esp {\n\tu32                           type;\n\tu16\t\t\t      size;\n\tstruct ib_flow_esp_filter     val;\n\tstruct ib_flow_esp_filter     mask;\n};\n\nstruct ib_flow_gre_filter {\n\t__be16 c_ks_res0_ver;\n\t__be16 protocol;\n\t__be32 key;\n\t/* Must be last */\n\tu8\treal_sz[];\n};\n\nstruct ib_flow_spec_gre {\n\tu32                           type;\n\tu16\t\t\t      size;\n\tstruct ib_flow_gre_filter     val;\n\tstruct ib_flow_gre_filter     mask;\n};\n\nstruct ib_flow_mpls_filter {\n\t__be32 tag;\n\t/* Must be last */\n\tu8\treal_sz[];\n};\n\nstruct ib_flow_spec_mpls {\n\tu32                           type;\n\tu16\t\t\t      size;\n\tstruct ib_flow_mpls_filter     val;\n\tstruct ib_flow_mpls_filter     mask;\n};\n\nstruct ib_flow_spec_action_tag {\n\tenum ib_flow_spec_type\t      type;\n\tu16\t\t\t      size;\n\tu32                           tag_id;\n};\n\nstruct ib_flow_spec_action_drop {\n\tenum ib_flow_spec_type\t      type;\n\tu16\t\t\t      size;\n};\n\nstruct ib_flow_spec_action_handle {\n\tenum ib_flow_spec_type\t      type;\n\tu16\t\t\t      size;\n\tstruct ib_flow_action\t     *act;\n};\n\nenum ib_counters_description {\n\tIB_COUNTER_PACKETS,\n\tIB_COUNTER_BYTES,\n};\n\nstruct ib_flow_spec_action_count {\n\tenum ib_flow_spec_type type;\n\tu16 size;\n\tstruct ib_counters *counters;\n};\n\nunion ib_flow_spec {\n\tstruct {\n\t\tu32\t\t\ttype;\n\t\tu16\t\t\tsize;\n\t};\n\tstruct ib_flow_spec_eth\t\teth;\n\tstruct ib_flow_spec_ib\t\tib;\n\tstruct ib_flow_spec_ipv4        ipv4;\n\tstruct ib_flow_spec_tcp_udp\ttcp_udp;\n\tstruct ib_flow_spec_ipv6        ipv6;\n\tstruct ib_flow_spec_tunnel      tunnel;\n\tstruct ib_flow_spec_esp\t\tesp;\n\tstruct ib_flow_spec_gre\t\tgre;\n\tstruct ib_flow_spec_mpls\tmpls;\n\tstruct ib_flow_spec_action_tag  flow_tag;\n\tstruct ib_flow_spec_action_drop drop;\n\tstruct ib_flow_spec_action_handle action;\n\tstruct ib_flow_spec_action_count flow_count;\n};\n\nstruct ib_flow_attr {\n\tenum ib_flow_attr_type type;\n\tu16\t     size;\n\tu16\t     priority;\n\tu32\t     flags;\n\tu8\t     num_of_specs;\n\tu8\t     port;\n\tunion ib_flow_spec flows[];\n};\n\nstruct ib_flow {\n\tstruct ib_qp\t\t*qp;\n\tstruct ib_device\t*device;\n\tstruct ib_uobject\t*uobject;\n};\n\nenum ib_flow_action_type {\n\tIB_FLOW_ACTION_UNSPECIFIED,\n\tIB_FLOW_ACTION_ESP = 1,\n};\n\nstruct ib_flow_action_attrs_esp_keymats {\n\tenum ib_uverbs_flow_action_esp_keymat\t\t\tprotocol;\n\tunion {\n\t\tstruct ib_uverbs_flow_action_esp_keymat_aes_gcm aes_gcm;\n\t} keymat;\n};\n\nstruct ib_flow_action_attrs_esp_replays {\n\tenum ib_uverbs_flow_action_esp_replay\t\t\tprotocol;\n\tunion {\n\t\tstruct ib_uverbs_flow_action_esp_replay_bmp\tbmp;\n\t} replay;\n};\n\nenum ib_flow_action_attrs_esp_flags {\n\t/* All user-space flags at the top: Use enum ib_uverbs_flow_action_esp_flags\n\t * This is done in order to share the same flags between user-space and\n\t * kernel and spare an unnecessary translation.\n\t */\n\n\t/* Kernel flags */\n\tIB_FLOW_ACTION_ESP_FLAGS_ESN_TRIGGERED\t= 1ULL << 32,\n\tIB_FLOW_ACTION_ESP_FLAGS_MOD_ESP_ATTRS\t= 1ULL << 33,\n};\n\nstruct ib_flow_spec_list {\n\tstruct ib_flow_spec_list\t*next;\n\tunion ib_flow_spec\t\tspec;\n};\n\nstruct ib_flow_action_attrs_esp {\n\tstruct ib_flow_action_attrs_esp_keymats\t\t*keymat;\n\tstruct ib_flow_action_attrs_esp_replays\t\t*replay;\n\tstruct ib_flow_spec_list\t\t\t*encap;\n\t/* Used only if IB_FLOW_ACTION_ESP_FLAGS_ESN_TRIGGERED is enabled.\n\t * Value of 0 is a valid value.\n\t */\n\tu32\t\t\t\t\t\tesn;\n\tu32\t\t\t\t\t\tspi;\n\tu32\t\t\t\t\t\tseq;\n\tu32\t\t\t\t\t\ttfc_pad;\n\t/* Use enum ib_flow_action_attrs_esp_flags */\n\tu64\t\t\t\t\t\tflags;\n\tu64\t\t\t\t\t\thard_limit_pkts;\n};\n\nstruct ib_flow_action {\n\tstruct ib_device\t\t*device;\n\tstruct ib_uobject\t\t*uobject;\n\tenum ib_flow_action_type\ttype;\n\tatomic_t\t\t\tusecnt;\n};\n\nstruct ib_mad;\nstruct ib_grh;\n\nenum ib_process_mad_flags {\n\tIB_MAD_IGNORE_MKEY\t= 1,\n\tIB_MAD_IGNORE_BKEY\t= 2,\n\tIB_MAD_IGNORE_ALL\t= IB_MAD_IGNORE_MKEY | IB_MAD_IGNORE_BKEY\n};\n\nenum ib_mad_result {\n\tIB_MAD_RESULT_FAILURE  = 0,      /* (!SUCCESS is the important flag) */\n\tIB_MAD_RESULT_SUCCESS  = 1 << 0, /* MAD was successfully processed   */\n\tIB_MAD_RESULT_REPLY    = 1 << 1, /* Reply packet needs to be sent    */\n\tIB_MAD_RESULT_CONSUMED = 1 << 2  /* Packet consumed: stop processing */\n};\n\nstruct ib_port_cache {\n\tu64\t\t      subnet_prefix;\n\tstruct ib_pkey_cache  *pkey;\n\tstruct ib_gid_table   *gid;\n\tu8                     lmc;\n\tenum ib_port_state     port_state;\n};\n\nstruct ib_port_immutable {\n\tint                           pkey_tbl_len;\n\tint                           gid_tbl_len;\n\tu32                           core_cap_flags;\n\tu32                           max_mad_size;\n};\n\nstruct ib_port_data {\n\tstruct ib_device *ib_dev;\n\n\tstruct ib_port_immutable immutable;\n\n\tspinlock_t pkey_list_lock;\n\tstruct list_head pkey_list;\n\n\tstruct ib_port_cache cache;\n\n\tspinlock_t netdev_lock;\n\tstruct net_device __rcu *netdev;\n\tstruct hlist_node ndev_hash_link;\n\tstruct rdma_port_counter port_counter;\n\tstruct rdma_hw_stats *hw_stats;\n};\n\n/* rdma netdev type - specifies protocol type */\nenum rdma_netdev_t {\n\tRDMA_NETDEV_OPA_VNIC,\n\tRDMA_NETDEV_IPOIB,\n};\n\n/**\n * struct rdma_netdev - rdma netdev\n * For cases where netstack interfacing is required.\n */\nstruct rdma_netdev {\n\tvoid              *clnt_priv;\n\tstruct ib_device  *hca;\n\tu8                 port_num;\n\tint                mtu;\n\n\t/*\n\t * cleanup function must be specified.\n\t * FIXME: This is only used for OPA_VNIC and that usage should be\n\t * removed too.\n\t */\n\tvoid (*free_rdma_netdev)(struct net_device *netdev);\n\n\t/* control functions */\n\tvoid (*set_id)(struct net_device *netdev, int id);\n\t/* send packet */\n\tint (*send)(struct net_device *dev, struct sk_buff *skb,\n\t\t    struct ib_ah *address, u32 dqpn);\n\t/* multicast */\n\tint (*attach_mcast)(struct net_device *dev, struct ib_device *hca,\n\t\t\t    union ib_gid *gid, u16 mlid,\n\t\t\t    int set_qkey, u32 qkey);\n\tint (*detach_mcast)(struct net_device *dev, struct ib_device *hca,\n\t\t\t    union ib_gid *gid, u16 mlid);\n};\n\nstruct rdma_netdev_alloc_params {\n\tsize_t sizeof_priv;\n\tunsigned int txqs;\n\tunsigned int rxqs;\n\tvoid *param;\n\n\tint (*initialize_rdma_netdev)(struct ib_device *device, u8 port_num,\n\t\t\t\t      struct net_device *netdev, void *param);\n};\n\nstruct ib_odp_counters {\n\tatomic64_t faults;\n\tatomic64_t invalidations;\n\tatomic64_t prefetch;\n};\n\nstruct ib_counters {\n\tstruct ib_device\t*device;\n\tstruct ib_uobject\t*uobject;\n\t/* num of objects attached */\n\tatomic_t\tusecnt;\n};\n\nstruct ib_counters_read_attr {\n\tu64\t*counters_buff;\n\tu32\tncounters;\n\tu32\tflags; /* use enum ib_read_counters_flags */\n};\n\nstruct uverbs_attr_bundle;\nstruct iw_cm_id;\nstruct iw_cm_conn_param;\n\n#define INIT_RDMA_OBJ_SIZE(ib_struct, drv_struct, member)                      \\\n\t.size_##ib_struct =                                                    \\\n\t\t(sizeof(struct drv_struct) +                                   \\\n\t\t BUILD_BUG_ON_ZERO(offsetof(struct drv_struct, member)) +      \\\n\t\t BUILD_BUG_ON_ZERO(                                            \\\n\t\t\t !__same_type(((struct drv_struct *)NULL)->member,     \\\n\t\t\t\t      struct ib_struct)))\n\n#define rdma_zalloc_drv_obj_gfp(ib_dev, ib_type, gfp)                         \\\n\t((struct ib_type *)kzalloc(ib_dev->ops.size_##ib_type, gfp))\n\n#define rdma_zalloc_drv_obj(ib_dev, ib_type)                                   \\\n\trdma_zalloc_drv_obj_gfp(ib_dev, ib_type, GFP_KERNEL)\n\n#define DECLARE_RDMA_OBJ_SIZE(ib_struct) size_t size_##ib_struct\n\nstruct rdma_user_mmap_entry {\n\tstruct kref ref;\n\tstruct ib_ucontext *ucontext;\n\tunsigned long start_pgoff;\n\tsize_t npages;\n\tbool driver_removed;\n};\n\n/* Return the offset (in bytes) the user should pass to libc's mmap() */\nstatic inline u64\nrdma_user_mmap_get_offset(const struct rdma_user_mmap_entry *entry)\n{\n\treturn (u64)entry->start_pgoff << PAGE_SHIFT;\n}\n\n/**\n * struct ib_device_ops - InfiniBand device operations\n * This structure defines all the InfiniBand device operations, providers will\n * need to define the supported operations, otherwise they will be set to null.\n */\nstruct ib_device_ops {\n\tstruct module *owner;\n\tenum rdma_driver_id driver_id;\n\tu32 uverbs_abi_ver;\n\tunsigned int uverbs_no_driver_id_binding:1;\n\n\tint (*post_send)(struct ib_qp *qp, const struct ib_send_wr *send_wr,\n\t\t\t const struct ib_send_wr **bad_send_wr);\n\tint (*post_recv)(struct ib_qp *qp, const struct ib_recv_wr *recv_wr,\n\t\t\t const struct ib_recv_wr **bad_recv_wr);\n\tvoid (*drain_rq)(struct ib_qp *qp);\n\tvoid (*drain_sq)(struct ib_qp *qp);\n\tint (*poll_cq)(struct ib_cq *cq, int num_entries, struct ib_wc *wc);\n\tint (*peek_cq)(struct ib_cq *cq, int wc_cnt);\n\tint (*req_notify_cq)(struct ib_cq *cq, enum ib_cq_notify_flags flags);\n\tint (*req_ncomp_notif)(struct ib_cq *cq, int wc_cnt);\n\tint (*post_srq_recv)(struct ib_srq *srq,\n\t\t\t     const struct ib_recv_wr *recv_wr,\n\t\t\t     const struct ib_recv_wr **bad_recv_wr);\n\tint (*process_mad)(struct ib_device *device, int process_mad_flags,\n\t\t\t   u8 port_num, const struct ib_wc *in_wc,\n\t\t\t   const struct ib_grh *in_grh,\n\t\t\t   const struct ib_mad *in_mad, struct ib_mad *out_mad,\n\t\t\t   size_t *out_mad_size, u16 *out_mad_pkey_index);\n\tint (*query_device)(struct ib_device *device,\n\t\t\t    struct ib_device_attr *device_attr,\n\t\t\t    struct ib_udata *udata);\n\tint (*modify_device)(struct ib_device *device, int device_modify_mask,\n\t\t\t     struct ib_device_modify *device_modify);\n\tvoid (*get_dev_fw_str)(struct ib_device *device, char *str);\n\tconst struct cpumask *(*get_vector_affinity)(struct ib_device *ibdev,\n\t\t\t\t\t\t     int comp_vector);\n\tint (*query_port)(struct ib_device *device, u8 port_num,\n\t\t\t  struct ib_port_attr *port_attr);\n\tint (*modify_port)(struct ib_device *device, u8 port_num,\n\t\t\t   int port_modify_mask,\n\t\t\t   struct ib_port_modify *port_modify);\n\t/**\n\t * The following mandatory functions are used only at device\n\t * registration.  Keep functions such as these at the end of this\n\t * structure to avoid cache line misses when accessing struct ib_device\n\t * in fast paths.\n\t */\n\tint (*get_port_immutable)(struct ib_device *device, u8 port_num,\n\t\t\t\t  struct ib_port_immutable *immutable);\n\tenum rdma_link_layer (*get_link_layer)(struct ib_device *device,\n\t\t\t\t\t       u8 port_num);\n\t/**\n\t * When calling get_netdev, the HW vendor's driver should return the\n\t * net device of device @device at port @port_num or NULL if such\n\t * a net device doesn't exist. The vendor driver should call dev_hold\n\t * on this net device. The HW vendor's device driver must guarantee\n\t * that this function returns NULL before the net device has finished\n\t * NETDEV_UNREGISTER state.\n\t */\n\tstruct net_device *(*get_netdev)(struct ib_device *device, u8 port_num);\n\t/**\n\t * rdma netdev operation\n\t *\n\t * Driver implementing alloc_rdma_netdev or rdma_netdev_get_params\n\t * must return -EOPNOTSUPP if it doesn't support the specified type.\n\t */\n\tstruct net_device *(*alloc_rdma_netdev)(\n\t\tstruct ib_device *device, u8 port_num, enum rdma_netdev_t type,\n\t\tconst char *name, unsigned char name_assign_type,\n\t\tvoid (*setup)(struct net_device *));\n\n\tint (*rdma_netdev_get_params)(struct ib_device *device, u8 port_num,\n\t\t\t\t      enum rdma_netdev_t type,\n\t\t\t\t      struct rdma_netdev_alloc_params *params);\n\t/**\n\t * query_gid should be return GID value for @device, when @port_num\n\t * link layer is either IB or iWarp. It is no-op if @port_num port\n\t * is RoCE link layer.\n\t */\n\tint (*query_gid)(struct ib_device *device, u8 port_num, int index,\n\t\t\t union ib_gid *gid);\n\t/**\n\t * When calling add_gid, the HW vendor's driver should add the gid\n\t * of device of port at gid index available at @attr. Meta-info of\n\t * that gid (for example, the network device related to this gid) is\n\t * available at @attr. @context allows the HW vendor driver to store\n\t * extra information together with a GID entry. The HW vendor driver may\n\t * allocate memory to contain this information and store it in @context\n\t * when a new GID entry is written to. Params are consistent until the\n\t * next call of add_gid or delete_gid. The function should return 0 on\n\t * success or error otherwise. The function could be called\n\t * concurrently for different ports. This function is only called when\n\t * roce_gid_table is used.\n\t */\n\tint (*add_gid)(const struct ib_gid_attr *attr, void **context);\n\t/**\n\t * When calling del_gid, the HW vendor's driver should delete the\n\t * gid of device @device at gid index gid_index of port port_num\n\t * available in @attr.\n\t * Upon the deletion of a GID entry, the HW vendor must free any\n\t * allocated memory. The caller will clear @context afterwards.\n\t * This function is only called when roce_gid_table is used.\n\t */\n\tint (*del_gid)(const struct ib_gid_attr *attr, void **context);\n\tint (*query_pkey)(struct ib_device *device, u8 port_num, u16 index,\n\t\t\t  u16 *pkey);\n\tint (*alloc_ucontext)(struct ib_ucontext *context,\n\t\t\t      struct ib_udata *udata);\n\tvoid (*dealloc_ucontext)(struct ib_ucontext *context);\n\tint (*mmap)(struct ib_ucontext *context, struct vm_area_struct *vma);\n\t/**\n\t * This will be called once refcount of an entry in mmap_xa reaches\n\t * zero. The type of the memory that was mapped may differ between\n\t * entries and is opaque to the rdma_user_mmap interface.\n\t * Therefore needs to be implemented by the driver in mmap_free.\n\t */\n\tvoid (*mmap_free)(struct rdma_user_mmap_entry *entry);\n\tvoid (*disassociate_ucontext)(struct ib_ucontext *ibcontext);\n\tint (*alloc_pd)(struct ib_pd *pd, struct ib_udata *udata);\n\tint (*dealloc_pd)(struct ib_pd *pd, struct ib_udata *udata);\n\tint (*create_ah)(struct ib_ah *ah, struct rdma_ah_init_attr *attr,\n\t\t\t struct ib_udata *udata);\n\tint (*create_user_ah)(struct ib_ah *ah, struct rdma_ah_init_attr *attr,\n\t\t\t      struct ib_udata *udata);\n\tint (*modify_ah)(struct ib_ah *ah, struct rdma_ah_attr *ah_attr);\n\tint (*query_ah)(struct ib_ah *ah, struct rdma_ah_attr *ah_attr);\n\tint (*destroy_ah)(struct ib_ah *ah, u32 flags);\n\tint (*create_srq)(struct ib_srq *srq,\n\t\t\t  struct ib_srq_init_attr *srq_init_attr,\n\t\t\t  struct ib_udata *udata);\n\tint (*modify_srq)(struct ib_srq *srq, struct ib_srq_attr *srq_attr,\n\t\t\t  enum ib_srq_attr_mask srq_attr_mask,\n\t\t\t  struct ib_udata *udata);\n\tint (*query_srq)(struct ib_srq *srq, struct ib_srq_attr *srq_attr);\n\tint (*destroy_srq)(struct ib_srq *srq, struct ib_udata *udata);\n\tstruct ib_qp *(*create_qp)(struct ib_pd *pd,\n\t\t\t\t   struct ib_qp_init_attr *qp_init_attr,\n\t\t\t\t   struct ib_udata *udata);\n\tint (*modify_qp)(struct ib_qp *qp, struct ib_qp_attr *qp_attr,\n\t\t\t int qp_attr_mask, struct ib_udata *udata);\n\tint (*query_qp)(struct ib_qp *qp, struct ib_qp_attr *qp_attr,\n\t\t\tint qp_attr_mask, struct ib_qp_init_attr *qp_init_attr);\n\tint (*destroy_qp)(struct ib_qp *qp, struct ib_udata *udata);\n\tint (*create_cq)(struct ib_cq *cq, const struct ib_cq_init_attr *attr,\n\t\t\t struct ib_udata *udata);\n\tint (*modify_cq)(struct ib_cq *cq, u16 cq_count, u16 cq_period);\n\tint (*destroy_cq)(struct ib_cq *cq, struct ib_udata *udata);\n\tint (*resize_cq)(struct ib_cq *cq, int cqe, struct ib_udata *udata);\n\tstruct ib_mr *(*get_dma_mr)(struct ib_pd *pd, int mr_access_flags);\n\tstruct ib_mr *(*reg_user_mr)(struct ib_pd *pd, u64 start, u64 length,\n\t\t\t\t     u64 virt_addr, int mr_access_flags,\n\t\t\t\t     struct ib_udata *udata);\n\tstruct ib_mr *(*reg_user_mr_dmabuf)(struct ib_pd *pd, u64 offset,\n\t\t\t\t\t    u64 length, u64 virt_addr, int fd,\n\t\t\t\t\t    int mr_access_flags,\n\t\t\t\t\t    struct ib_udata *udata);\n\tstruct ib_mr *(*rereg_user_mr)(struct ib_mr *mr, int flags, u64 start,\n\t\t\t\t       u64 length, u64 virt_addr,\n\t\t\t\t       int mr_access_flags, struct ib_pd *pd,\n\t\t\t\t       struct ib_udata *udata);\n\tint (*dereg_mr)(struct ib_mr *mr, struct ib_udata *udata);\n\tstruct ib_mr *(*alloc_mr)(struct ib_pd *pd, enum ib_mr_type mr_type,\n\t\t\t\t  u32 max_num_sg);\n\tstruct ib_mr *(*alloc_mr_integrity)(struct ib_pd *pd,\n\t\t\t\t\t    u32 max_num_data_sg,\n\t\t\t\t\t    u32 max_num_meta_sg);\n\tint (*advise_mr)(struct ib_pd *pd,\n\t\t\t enum ib_uverbs_advise_mr_advice advice, u32 flags,\n\t\t\t struct ib_sge *sg_list, u32 num_sge,\n\t\t\t struct uverbs_attr_bundle *attrs);\n\tint (*map_mr_sg)(struct ib_mr *mr, struct scatterlist *sg, int sg_nents,\n\t\t\t unsigned int *sg_offset);\n\tint (*check_mr_status)(struct ib_mr *mr, u32 check_mask,\n\t\t\t       struct ib_mr_status *mr_status);\n\tint (*alloc_mw)(struct ib_mw *mw, struct ib_udata *udata);\n\tint (*dealloc_mw)(struct ib_mw *mw);\n\tint (*attach_mcast)(struct ib_qp *qp, union ib_gid *gid, u16 lid);\n\tint (*detach_mcast)(struct ib_qp *qp, union ib_gid *gid, u16 lid);\n\tint (*alloc_xrcd)(struct ib_xrcd *xrcd, struct ib_udata *udata);\n\tint (*dealloc_xrcd)(struct ib_xrcd *xrcd, struct ib_udata *udata);\n\tstruct ib_flow *(*create_flow)(struct ib_qp *qp,\n\t\t\t\t       struct ib_flow_attr *flow_attr,\n\t\t\t\t       struct ib_udata *udata);\n\tint (*destroy_flow)(struct ib_flow *flow_id);\n\tstruct ib_flow_action *(*create_flow_action_esp)(\n\t\tstruct ib_device *device,\n\t\tconst struct ib_flow_action_attrs_esp *attr,\n\t\tstruct uverbs_attr_bundle *attrs);\n\tint (*destroy_flow_action)(struct ib_flow_action *action);\n\tint (*modify_flow_action_esp)(\n\t\tstruct ib_flow_action *action,\n\t\tconst struct ib_flow_action_attrs_esp *attr,\n\t\tstruct uverbs_attr_bundle *attrs);\n\tint (*set_vf_link_state)(struct ib_device *device, int vf, u8 port,\n\t\t\t\t int state);\n\tint (*get_vf_config)(struct ib_device *device, int vf, u8 port,\n\t\t\t     struct ifla_vf_info *ivf);\n\tint (*get_vf_stats)(struct ib_device *device, int vf, u8 port,\n\t\t\t    struct ifla_vf_stats *stats);\n\tint (*get_vf_guid)(struct ib_device *device, int vf, u8 port,\n\t\t\t    struct ifla_vf_guid *node_guid,\n\t\t\t    struct ifla_vf_guid *port_guid);\n\tint (*set_vf_guid)(struct ib_device *device, int vf, u8 port, u64 guid,\n\t\t\t   int type);\n\tstruct ib_wq *(*create_wq)(struct ib_pd *pd,\n\t\t\t\t   struct ib_wq_init_attr *init_attr,\n\t\t\t\t   struct ib_udata *udata);\n\tint (*destroy_wq)(struct ib_wq *wq, struct ib_udata *udata);\n\tint (*modify_wq)(struct ib_wq *wq, struct ib_wq_attr *attr,\n\t\t\t u32 wq_attr_mask, struct ib_udata *udata);\n\tint (*create_rwq_ind_table)(struct ib_rwq_ind_table *ib_rwq_ind_table,\n\t\t\t\t    struct ib_rwq_ind_table_init_attr *init_attr,\n\t\t\t\t    struct ib_udata *udata);\n\tint (*destroy_rwq_ind_table)(struct ib_rwq_ind_table *wq_ind_table);\n\tstruct ib_dm *(*alloc_dm)(struct ib_device *device,\n\t\t\t\t  struct ib_ucontext *context,\n\t\t\t\t  struct ib_dm_alloc_attr *attr,\n\t\t\t\t  struct uverbs_attr_bundle *attrs);\n\tint (*dealloc_dm)(struct ib_dm *dm, struct uverbs_attr_bundle *attrs);\n\tstruct ib_mr *(*reg_dm_mr)(struct ib_pd *pd, struct ib_dm *dm,\n\t\t\t\t   struct ib_dm_mr_attr *attr,\n\t\t\t\t   struct uverbs_attr_bundle *attrs);\n\tint (*create_counters)(struct ib_counters *counters,\n\t\t\t       struct uverbs_attr_bundle *attrs);\n\tint (*destroy_counters)(struct ib_counters *counters);\n\tint (*read_counters)(struct ib_counters *counters,\n\t\t\t     struct ib_counters_read_attr *counters_read_attr,\n\t\t\t     struct uverbs_attr_bundle *attrs);\n\tint (*map_mr_sg_pi)(struct ib_mr *mr, struct scatterlist *data_sg,\n\t\t\t    int data_sg_nents, unsigned int *data_sg_offset,\n\t\t\t    struct scatterlist *meta_sg, int meta_sg_nents,\n\t\t\t    unsigned int *meta_sg_offset);\n\n\t/**\n\t * alloc_hw_stats - Allocate a struct rdma_hw_stats and fill in the\n\t *   driver initialized data.  The struct is kfree()'ed by the sysfs\n\t *   core when the device is removed.  A lifespan of -1 in the return\n\t *   struct tells the core to set a default lifespan.\n\t */\n\tstruct rdma_hw_stats *(*alloc_hw_stats)(struct ib_device *device,\n\t\t\t\t\t\tu8 port_num);\n\t/**\n\t * get_hw_stats - Fill in the counter value(s) in the stats struct.\n\t * @index - The index in the value array we wish to have updated, or\n\t *   num_counters if we want all stats updated\n\t * Return codes -\n\t *   < 0 - Error, no counters updated\n\t *   index - Updated the single counter pointed to by index\n\t *   num_counters - Updated all counters (will reset the timestamp\n\t *     and prevent further calls for lifespan milliseconds)\n\t * Drivers are allowed to update all counters in leiu of just the\n\t *   one given in index at their option\n\t */\n\tint (*get_hw_stats)(struct ib_device *device,\n\t\t\t    struct rdma_hw_stats *stats, u8 port, int index);\n\t/*\n\t * This function is called once for each port when a ib device is\n\t * registered.\n\t */\n\tint (*init_port)(struct ib_device *device, u8 port_num,\n\t\t\t struct kobject *port_sysfs);\n\t/**\n\t * Allows rdma drivers to add their own restrack attributes.\n\t */\n\tint (*fill_res_mr_entry)(struct sk_buff *msg, struct ib_mr *ibmr);\n\tint (*fill_res_mr_entry_raw)(struct sk_buff *msg, struct ib_mr *ibmr);\n\tint (*fill_res_cq_entry)(struct sk_buff *msg, struct ib_cq *ibcq);\n\tint (*fill_res_cq_entry_raw)(struct sk_buff *msg, struct ib_cq *ibcq);\n\tint (*fill_res_qp_entry)(struct sk_buff *msg, struct ib_qp *ibqp);\n\tint (*fill_res_qp_entry_raw)(struct sk_buff *msg, struct ib_qp *ibqp);\n\tint (*fill_res_cm_id_entry)(struct sk_buff *msg, struct rdma_cm_id *id);\n\n\t/* Device lifecycle callbacks */\n\t/*\n\t * Called after the device becomes registered, before clients are\n\t * attached\n\t */\n\tint (*enable_driver)(struct ib_device *dev);\n\t/*\n\t * This is called as part of ib_dealloc_device().\n\t */\n\tvoid (*dealloc_driver)(struct ib_device *dev);\n\n\t/* iWarp CM callbacks */\n\tvoid (*iw_add_ref)(struct ib_qp *qp);\n\tvoid (*iw_rem_ref)(struct ib_qp *qp);\n\tstruct ib_qp *(*iw_get_qp)(struct ib_device *device, int qpn);\n\tint (*iw_connect)(struct iw_cm_id *cm_id,\n\t\t\t  struct iw_cm_conn_param *conn_param);\n\tint (*iw_accept)(struct iw_cm_id *cm_id,\n\t\t\t struct iw_cm_conn_param *conn_param);\n\tint (*iw_reject)(struct iw_cm_id *cm_id, const void *pdata,\n\t\t\t u8 pdata_len);\n\tint (*iw_create_listen)(struct iw_cm_id *cm_id, int backlog);\n\tint (*iw_destroy_listen)(struct iw_cm_id *cm_id);\n\t/**\n\t * counter_bind_qp - Bind a QP to a counter.\n\t * @counter - The counter to be bound. If counter->id is zero then\n\t *   the driver needs to allocate a new counter and set counter->id\n\t */\n\tint (*counter_bind_qp)(struct rdma_counter *counter, struct ib_qp *qp);\n\t/**\n\t * counter_unbind_qp - Unbind the qp from the dynamically-allocated\n\t *   counter and bind it onto the default one\n\t */\n\tint (*counter_unbind_qp)(struct ib_qp *qp);\n\t/**\n\t * counter_dealloc -De-allocate the hw counter\n\t */\n\tint (*counter_dealloc)(struct rdma_counter *counter);\n\t/**\n\t * counter_alloc_stats - Allocate a struct rdma_hw_stats and fill in\n\t * the driver initialized data.\n\t */\n\tstruct rdma_hw_stats *(*counter_alloc_stats)(\n\t\tstruct rdma_counter *counter);\n\t/**\n\t * counter_update_stats - Query the stats value of this counter\n\t */\n\tint (*counter_update_stats)(struct rdma_counter *counter);\n\n\t/**\n\t * Allows rdma drivers to add their own restrack attributes\n\t * dumped via 'rdma stat' iproute2 command.\n\t */\n\tint (*fill_stat_mr_entry)(struct sk_buff *msg, struct ib_mr *ibmr);\n\n\t/* query driver for its ucontext properties */\n\tint (*query_ucontext)(struct ib_ucontext *context,\n\t\t\t      struct uverbs_attr_bundle *attrs);\n\n\tDECLARE_RDMA_OBJ_SIZE(ib_ah);\n\tDECLARE_RDMA_OBJ_SIZE(ib_counters);\n\tDECLARE_RDMA_OBJ_SIZE(ib_cq);\n\tDECLARE_RDMA_OBJ_SIZE(ib_mw);\n\tDECLARE_RDMA_OBJ_SIZE(ib_pd);\n\tDECLARE_RDMA_OBJ_SIZE(ib_rwq_ind_table);\n\tDECLARE_RDMA_OBJ_SIZE(ib_srq);\n\tDECLARE_RDMA_OBJ_SIZE(ib_ucontext);\n\tDECLARE_RDMA_OBJ_SIZE(ib_xrcd);\n};\n\nstruct ib_core_device {\n\t/* device must be the first element in structure until,\n\t * union of ib_core_device and device exists in ib_device.\n\t */\n\tstruct device dev;\n\tpossible_net_t rdma_net;\n\tstruct kobject *ports_kobj;\n\tstruct list_head port_list;\n\tstruct ib_device *owner; /* reach back to owner ib_device */\n};\n\nstruct rdma_restrack_root;\nstruct ib_device {\n\t/* Do not access @dma_device directly from ULP nor from HW drivers. */\n\tstruct device                *dma_device;\n\tstruct ib_device_ops\t     ops;\n\tchar                          name[IB_DEVICE_NAME_MAX];\n\tstruct rcu_head rcu_head;\n\n\tstruct list_head              event_handler_list;\n\t/* Protects event_handler_list */\n\tstruct rw_semaphore event_handler_rwsem;\n\n\t/* Protects QP's event_handler calls and open_qp list */\n\tspinlock_t qp_open_list_lock;\n\n\tstruct rw_semaphore\t      client_data_rwsem;\n\tstruct xarray                 client_data;\n\tstruct mutex                  unregistration_lock;\n\n\t/* Synchronize GID, Pkey cache entries, subnet prefix, LMC */\n\trwlock_t cache_lock;\n\t/**\n\t * port_data is indexed by port number\n\t */\n\tstruct ib_port_data *port_data;\n\n\tint\t\t\t      num_comp_vectors;\n\n\tunion {\n\t\tstruct device\t\tdev;\n\t\tstruct ib_core_device\tcoredev;\n\t};\n\n\t/* First group for device attributes,\n\t * Second group for driver provided attributes (optional).\n\t * It is NULL terminated array.\n\t */\n\tconst struct attribute_group\t*groups[3];\n\n\tu64\t\t\t     uverbs_cmd_mask;\n\n\tchar\t\t\t     node_desc[IB_DEVICE_NODE_DESC_MAX];\n\t__be64\t\t\t     node_guid;\n\tu32\t\t\t     local_dma_lkey;\n\tu16                          is_switch:1;\n\t/* Indicates kernel verbs support, should not be used in drivers */\n\tu16                          kverbs_provider:1;\n\t/* CQ adaptive moderation (RDMA DIM) */\n\tu16                          use_cq_dim:1;\n\tu8                           node_type;\n\tu8                           phys_port_cnt;\n\tstruct ib_device_attr        attrs;\n\tstruct attribute_group\t     *hw_stats_ag;\n\tstruct rdma_hw_stats         *hw_stats;\n\n#ifdef CONFIG_CGROUP_RDMA\n\tstruct rdmacg_device         cg_device;\n#endif\n\n\tu32                          index;\n\n\tspinlock_t                   cq_pools_lock;\n\tstruct list_head             cq_pools[IB_POLL_LAST_POOL_TYPE + 1];\n\n\tstruct rdma_restrack_root *res;\n\n\tconst struct uapi_definition   *driver_def;\n\n\t/*\n\t * Positive refcount indicates that the device is currently\n\t * registered and cannot be unregistered.\n\t */\n\trefcount_t refcount;\n\tstruct completion unreg_completion;\n\tstruct work_struct unregistration_work;\n\n\tconst struct rdma_link_ops *link_ops;\n\n\t/* Protects compat_devs xarray modifications */\n\tstruct mutex compat_devs_mutex;\n\t/* Maintains compat devices for each net namespace */\n\tstruct xarray compat_devs;\n\n\t/* Used by iWarp CM */\n\tchar iw_ifname[IFNAMSIZ];\n\tu32 iw_driver_flags;\n\tu32 lag_flags;\n};\n\nstruct ib_client_nl_info;\nstruct ib_client {\n\tconst char *name;\n\tint (*add)(struct ib_device *ibdev);\n\tvoid (*remove)(struct ib_device *, void *client_data);\n\tvoid (*rename)(struct ib_device *dev, void *client_data);\n\tint (*get_nl_info)(struct ib_device *ibdev, void *client_data,\n\t\t\t   struct ib_client_nl_info *res);\n\tint (*get_global_nl_info)(struct ib_client_nl_info *res);\n\n\t/* Returns the net_dev belonging to this ib_client and matching the\n\t * given parameters.\n\t * @dev:\t An RDMA device that the net_dev use for communication.\n\t * @port:\t A physical port number on the RDMA device.\n\t * @pkey:\t P_Key that the net_dev uses if applicable.\n\t * @gid:\t A GID that the net_dev uses to communicate.\n\t * @addr:\t An IP address the net_dev is configured with.\n\t * @client_data: The device's client data set by ib_set_client_data().\n\t *\n\t * An ib_client that implements a net_dev on top of RDMA devices\n\t * (such as IP over IB) should implement this callback, allowing the\n\t * rdma_cm module to find the right net_dev for a given request.\n\t *\n\t * The caller is responsible for calling dev_put on the returned\n\t * netdev. */\n\tstruct net_device *(*get_net_dev_by_params)(\n\t\t\tstruct ib_device *dev,\n\t\t\tu8 port,\n\t\t\tu16 pkey,\n\t\t\tconst union ib_gid *gid,\n\t\t\tconst struct sockaddr *addr,\n\t\t\tvoid *client_data);\n\n\trefcount_t uses;\n\tstruct completion uses_zero;\n\tu32 client_id;\n\n\t/* kverbs are not required by the client */\n\tu8 no_kverbs_req:1;\n};\n\n/*\n * IB block DMA iterator\n *\n * Iterates the DMA-mapped SGL in contiguous memory blocks aligned\n * to a HW supported page size.\n */\nstruct ib_block_iter {\n\t/* internal states */\n\tstruct scatterlist *__sg;\t/* sg holding the current aligned block */\n\tdma_addr_t __dma_addr;\t\t/* unaligned DMA address of this block */\n\tunsigned int __sg_nents;\t/* number of SG entries */\n\tunsigned int __sg_advance;\t/* number of bytes to advance in sg in next step */\n\tunsigned int __pg_bit;\t\t/* alignment of current block */\n};\n\nstruct ib_device *_ib_alloc_device(size_t size);\n#define ib_alloc_device(drv_struct, member)                                    \\\n\tcontainer_of(_ib_alloc_device(sizeof(struct drv_struct) +              \\\n\t\t\t\t      BUILD_BUG_ON_ZERO(offsetof(              \\\n\t\t\t\t\t      struct drv_struct, member))),    \\\n\t\t     struct drv_struct, member)\n\nvoid ib_dealloc_device(struct ib_device *device);\n\nvoid ib_get_device_fw_str(struct ib_device *device, char *str);\n\nint ib_register_device(struct ib_device *device, const char *name,\n\t\t       struct device *dma_device);\nvoid ib_unregister_device(struct ib_device *device);\nvoid ib_unregister_driver(enum rdma_driver_id driver_id);\nvoid ib_unregister_device_and_put(struct ib_device *device);\nvoid ib_unregister_device_queued(struct ib_device *ib_dev);\n\nint ib_register_client   (struct ib_client *client);\nvoid ib_unregister_client(struct ib_client *client);\n\nvoid __rdma_block_iter_start(struct ib_block_iter *biter,\n\t\t\t     struct scatterlist *sglist,\n\t\t\t     unsigned int nents,\n\t\t\t     unsigned long pgsz);\nbool __rdma_block_iter_next(struct ib_block_iter *biter);\n\n/**\n * rdma_block_iter_dma_address - get the aligned dma address of the current\n * block held by the block iterator.\n * @biter: block iterator holding the memory block\n */\nstatic inline dma_addr_t\nrdma_block_iter_dma_address(struct ib_block_iter *biter)\n{\n\treturn biter->__dma_addr & ~(BIT_ULL(biter->__pg_bit) - 1);\n}\n\n/**\n * rdma_for_each_block - iterate over contiguous memory blocks of the sg list\n * @sglist: sglist to iterate over\n * @biter: block iterator holding the memory block\n * @nents: maximum number of sg entries to iterate over\n * @pgsz: best HW supported page size to use\n *\n * Callers may use rdma_block_iter_dma_address() to get each\n * blocks aligned DMA address.\n */\n#define rdma_for_each_block(sglist, biter, nents, pgsz)\t\t\\\n\tfor (__rdma_block_iter_start(biter, sglist, nents,\t\\\n\t\t\t\t     pgsz);\t\t\t\\\n\t     __rdma_block_iter_next(biter);)\n\n/**\n * ib_get_client_data - Get IB client context\n * @device:Device to get context for\n * @client:Client to get context for\n *\n * ib_get_client_data() returns the client context data set with\n * ib_set_client_data(). This can only be called while the client is\n * registered to the device, once the ib_client remove() callback returns this\n * cannot be called.\n */\nstatic inline void *ib_get_client_data(struct ib_device *device,\n\t\t\t\t       struct ib_client *client)\n{\n\treturn xa_load(&device->client_data, client->client_id);\n}\nvoid  ib_set_client_data(struct ib_device *device, struct ib_client *client,\n\t\t\t void *data);\nvoid ib_set_device_ops(struct ib_device *device,\n\t\t       const struct ib_device_ops *ops);\n\nint rdma_user_mmap_io(struct ib_ucontext *ucontext, struct vm_area_struct *vma,\n\t\t      unsigned long pfn, unsigned long size, pgprot_t prot,\n\t\t      struct rdma_user_mmap_entry *entry);\nint rdma_user_mmap_entry_insert(struct ib_ucontext *ucontext,\n\t\t\t\tstruct rdma_user_mmap_entry *entry,\n\t\t\t\tsize_t length);\nint rdma_user_mmap_entry_insert_range(struct ib_ucontext *ucontext,\n\t\t\t\t      struct rdma_user_mmap_entry *entry,\n\t\t\t\t      size_t length, u32 min_pgoff,\n\t\t\t\t      u32 max_pgoff);\n\nstruct rdma_user_mmap_entry *\nrdma_user_mmap_entry_get_pgoff(struct ib_ucontext *ucontext,\n\t\t\t       unsigned long pgoff);\nstruct rdma_user_mmap_entry *\nrdma_user_mmap_entry_get(struct ib_ucontext *ucontext,\n\t\t\t struct vm_area_struct *vma);\nvoid rdma_user_mmap_entry_put(struct rdma_user_mmap_entry *entry);\n\nvoid rdma_user_mmap_entry_remove(struct rdma_user_mmap_entry *entry);\n\nstatic inline int ib_copy_from_udata(void *dest, struct ib_udata *udata, size_t len)\n{\n\treturn copy_from_user(dest, udata->inbuf, len) ? -EFAULT : 0;\n}\n\nstatic inline int ib_copy_to_udata(struct ib_udata *udata, void *src, size_t len)\n{\n\treturn copy_to_user(udata->outbuf, src, len) ? -EFAULT : 0;\n}\n\nstatic inline bool ib_is_buffer_cleared(const void __user *p,\n\t\t\t\t\tsize_t len)\n{\n\tbool ret;\n\tu8 *buf;\n\n\tif (len > USHRT_MAX)\n\t\treturn false;\n\n\tbuf = memdup_user(p, len);\n\tif (IS_ERR(buf))\n\t\treturn false;\n\n\tret = !memchr_inv(buf, 0, len);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic inline bool ib_is_udata_cleared(struct ib_udata *udata,\n\t\t\t\t       size_t offset,\n\t\t\t\t       size_t len)\n{\n\treturn ib_is_buffer_cleared(udata->inbuf + offset, len);\n}\n\n/**\n * ib_modify_qp_is_ok - Check that the supplied attribute mask\n * contains all required attributes and no attributes not allowed for\n * the given QP state transition.\n * @cur_state: Current QP state\n * @next_state: Next QP state\n * @type: QP type\n * @mask: Mask of supplied QP attributes\n *\n * This function is a helper function that a low-level driver's\n * modify_qp method can use to validate the consumer's input.  It\n * checks that cur_state and next_state are valid QP states, that a\n * transition from cur_state to next_state is allowed by the IB spec,\n * and that the attribute mask supplied is allowed for the transition.\n */\nbool ib_modify_qp_is_ok(enum ib_qp_state cur_state, enum ib_qp_state next_state,\n\t\t\tenum ib_qp_type type, enum ib_qp_attr_mask mask);\n\nvoid ib_register_event_handler(struct ib_event_handler *event_handler);\nvoid ib_unregister_event_handler(struct ib_event_handler *event_handler);\nvoid ib_dispatch_event(const struct ib_event *event);\n\nint ib_query_port(struct ib_device *device,\n\t\t  u8 port_num, struct ib_port_attr *port_attr);\n\nenum rdma_link_layer rdma_port_get_link_layer(struct ib_device *device,\n\t\t\t\t\t       u8 port_num);\n\n/**\n * rdma_cap_ib_switch - Check if the device is IB switch\n * @device: Device to check\n *\n * Device driver is responsible for setting is_switch bit on\n * in ib_device structure at init time.\n *\n * Return: true if the device is IB switch.\n */\nstatic inline bool rdma_cap_ib_switch(const struct ib_device *device)\n{\n\treturn device->is_switch;\n}\n\n/**\n * rdma_start_port - Return the first valid port number for the device\n * specified\n *\n * @device: Device to be checked\n *\n * Return start port number\n */\nstatic inline u8 rdma_start_port(const struct ib_device *device)\n{\n\treturn rdma_cap_ib_switch(device) ? 0 : 1;\n}\n\n/**\n * rdma_for_each_port - Iterate over all valid port numbers of the IB device\n * @device - The struct ib_device * to iterate over\n * @iter - The unsigned int to store the port number\n */\n#define rdma_for_each_port(device, iter)                                       \\\n\tfor (iter = rdma_start_port(device + BUILD_BUG_ON_ZERO(!__same_type(   \\\n\t\t\t\t\t\t     unsigned int, iter)));    \\\n\t     iter <= rdma_end_port(device); (iter)++)\n\n/**\n * rdma_end_port - Return the last valid port number for the device\n * specified\n *\n * @device: Device to be checked\n *\n * Return last port number\n */\nstatic inline u8 rdma_end_port(const struct ib_device *device)\n{\n\treturn rdma_cap_ib_switch(device) ? 0 : device->phys_port_cnt;\n}\n\nstatic inline int rdma_is_port_valid(const struct ib_device *device,\n\t\t\t\t     unsigned int port)\n{\n\treturn (port >= rdma_start_port(device) &&\n\t\tport <= rdma_end_port(device));\n}\n\nstatic inline bool rdma_is_grh_required(const struct ib_device *device,\n\t\t\t\t\tu8 port_num)\n{\n\treturn device->port_data[port_num].immutable.core_cap_flags &\n\t       RDMA_CORE_PORT_IB_GRH_REQUIRED;\n}\n\nstatic inline bool rdma_protocol_ib(const struct ib_device *device, u8 port_num)\n{\n\treturn device->port_data[port_num].immutable.core_cap_flags &\n\t       RDMA_CORE_CAP_PROT_IB;\n}\n\nstatic inline bool rdma_protocol_roce(const struct ib_device *device, u8 port_num)\n{\n\treturn device->port_data[port_num].immutable.core_cap_flags &\n\t       (RDMA_CORE_CAP_PROT_ROCE | RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP);\n}\n\nstatic inline bool rdma_protocol_roce_udp_encap(const struct ib_device *device, u8 port_num)\n{\n\treturn device->port_data[port_num].immutable.core_cap_flags &\n\t       RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP;\n}\n\nstatic inline bool rdma_protocol_roce_eth_encap(const struct ib_device *device, u8 port_num)\n{\n\treturn device->port_data[port_num].immutable.core_cap_flags &\n\t       RDMA_CORE_CAP_PROT_ROCE;\n}\n\nstatic inline bool rdma_protocol_iwarp(const struct ib_device *device, u8 port_num)\n{\n\treturn device->port_data[port_num].immutable.core_cap_flags &\n\t       RDMA_CORE_CAP_PROT_IWARP;\n}\n\nstatic inline bool rdma_ib_or_roce(const struct ib_device *device, u8 port_num)\n{\n\treturn rdma_protocol_ib(device, port_num) ||\n\t\trdma_protocol_roce(device, port_num);\n}\n\nstatic inline bool rdma_protocol_raw_packet(const struct ib_device *device, u8 port_num)\n{\n\treturn device->port_data[port_num].immutable.core_cap_flags &\n\t       RDMA_CORE_CAP_PROT_RAW_PACKET;\n}\n\nstatic inline bool rdma_protocol_usnic(const struct ib_device *device, u8 port_num)\n{\n\treturn device->port_data[port_num].immutable.core_cap_flags &\n\t       RDMA_CORE_CAP_PROT_USNIC;\n}\n\n/**\n * rdma_cap_ib_mad - Check if the port of a device supports Infiniband\n * Management Datagrams.\n * @device: Device to check\n * @port_num: Port number to check\n *\n * Management Datagrams (MAD) are a required part of the InfiniBand\n * specification and are supported on all InfiniBand devices.  A slightly\n * extended version are also supported on OPA interfaces.\n *\n * Return: true if the port supports sending/receiving of MAD packets.\n */\nstatic inline bool rdma_cap_ib_mad(const struct ib_device *device, u8 port_num)\n{\n\treturn device->port_data[port_num].immutable.core_cap_flags &\n\t       RDMA_CORE_CAP_IB_MAD;\n}\n\n/**\n * rdma_cap_opa_mad - Check if the port of device provides support for OPA\n * Management Datagrams.\n * @device: Device to check\n * @port_num: Port number to check\n *\n * Intel OmniPath devices extend and/or replace the InfiniBand Management\n * datagrams with their own versions.  These OPA MADs share many but not all of\n * the characteristics of InfiniBand MADs.\n *\n * OPA MADs differ in the following ways:\n *\n *    1) MADs are variable size up to 2K\n *       IBTA defined MADs remain fixed at 256 bytes\n *    2) OPA SMPs must carry valid PKeys\n *    3) OPA SMP packets are a different format\n *\n * Return: true if the port supports OPA MAD packet formats.\n */\nstatic inline bool rdma_cap_opa_mad(struct ib_device *device, u8 port_num)\n{\n\treturn device->port_data[port_num].immutable.core_cap_flags &\n\t\tRDMA_CORE_CAP_OPA_MAD;\n}\n\n/**\n * rdma_cap_ib_smi - Check if the port of a device provides an Infiniband\n * Subnet Management Agent (SMA) on the Subnet Management Interface (SMI).\n * @device: Device to check\n * @port_num: Port number to check\n *\n * Each InfiniBand node is required to provide a Subnet Management Agent\n * that the subnet manager can access.  Prior to the fabric being fully\n * configured by the subnet manager, the SMA is accessed via a well known\n * interface called the Subnet Management Interface (SMI).  This interface\n * uses directed route packets to communicate with the SM to get around the\n * chicken and egg problem of the SM needing to know what's on the fabric\n * in order to configure the fabric, and needing to configure the fabric in\n * order to send packets to the devices on the fabric.  These directed\n * route packets do not need the fabric fully configured in order to reach\n * their destination.  The SMI is the only method allowed to send\n * directed route packets on an InfiniBand fabric.\n *\n * Return: true if the port provides an SMI.\n */\nstatic inline bool rdma_cap_ib_smi(const struct ib_device *device, u8 port_num)\n{\n\treturn device->port_data[port_num].immutable.core_cap_flags &\n\t       RDMA_CORE_CAP_IB_SMI;\n}\n\n/**\n * rdma_cap_ib_cm - Check if the port of device has the capability Infiniband\n * Communication Manager.\n * @device: Device to check\n * @port_num: Port number to check\n *\n * The InfiniBand Communication Manager is one of many pre-defined General\n * Service Agents (GSA) that are accessed via the General Service\n * Interface (GSI).  It's role is to facilitate establishment of connections\n * between nodes as well as other management related tasks for established\n * connections.\n *\n * Return: true if the port supports an IB CM (this does not guarantee that\n * a CM is actually running however).\n */\nstatic inline bool rdma_cap_ib_cm(const struct ib_device *device, u8 port_num)\n{\n\treturn device->port_data[port_num].immutable.core_cap_flags &\n\t       RDMA_CORE_CAP_IB_CM;\n}\n\n/**\n * rdma_cap_iw_cm - Check if the port of device has the capability IWARP\n * Communication Manager.\n * @device: Device to check\n * @port_num: Port number to check\n *\n * Similar to above, but specific to iWARP connections which have a different\n * managment protocol than InfiniBand.\n *\n * Return: true if the port supports an iWARP CM (this does not guarantee that\n * a CM is actually running however).\n */\nstatic inline bool rdma_cap_iw_cm(const struct ib_device *device, u8 port_num)\n{\n\treturn device->port_data[port_num].immutable.core_cap_flags &\n\t       RDMA_CORE_CAP_IW_CM;\n}\n\n/**\n * rdma_cap_ib_sa - Check if the port of device has the capability Infiniband\n * Subnet Administration.\n * @device: Device to check\n * @port_num: Port number to check\n *\n * An InfiniBand Subnet Administration (SA) service is a pre-defined General\n * Service Agent (GSA) provided by the Subnet Manager (SM).  On InfiniBand\n * fabrics, devices should resolve routes to other hosts by contacting the\n * SA to query the proper route.\n *\n * Return: true if the port should act as a client to the fabric Subnet\n * Administration interface.  This does not imply that the SA service is\n * running locally.\n */\nstatic inline bool rdma_cap_ib_sa(const struct ib_device *device, u8 port_num)\n{\n\treturn device->port_data[port_num].immutable.core_cap_flags &\n\t       RDMA_CORE_CAP_IB_SA;\n}\n\n/**\n * rdma_cap_ib_mcast - Check if the port of device has the capability Infiniband\n * Multicast.\n * @device: Device to check\n * @port_num: Port number to check\n *\n * InfiniBand multicast registration is more complex than normal IPv4 or\n * IPv6 multicast registration.  Each Host Channel Adapter must register\n * with the Subnet Manager when it wishes to join a multicast group.  It\n * should do so only once regardless of how many queue pairs it subscribes\n * to this group.  And it should leave the group only after all queue pairs\n * attached to the group have been detached.\n *\n * Return: true if the port must undertake the additional adminstrative\n * overhead of registering/unregistering with the SM and tracking of the\n * total number of queue pairs attached to the multicast group.\n */\nstatic inline bool rdma_cap_ib_mcast(const struct ib_device *device, u8 port_num)\n{\n\treturn rdma_cap_ib_sa(device, port_num);\n}\n\n/**\n * rdma_cap_af_ib - Check if the port of device has the capability\n * Native Infiniband Address.\n * @device: Device to check\n * @port_num: Port number to check\n *\n * InfiniBand addressing uses a port's GUID + Subnet Prefix to make a default\n * GID.  RoCE uses a different mechanism, but still generates a GID via\n * a prescribed mechanism and port specific data.\n *\n * Return: true if the port uses a GID address to identify devices on the\n * network.\n */\nstatic inline bool rdma_cap_af_ib(const struct ib_device *device, u8 port_num)\n{\n\treturn device->port_data[port_num].immutable.core_cap_flags &\n\t       RDMA_CORE_CAP_AF_IB;\n}\n\n/**\n * rdma_cap_eth_ah - Check if the port of device has the capability\n * Ethernet Address Handle.\n * @device: Device to check\n * @port_num: Port number to check\n *\n * RoCE is InfiniBand over Ethernet, and it uses a well defined technique\n * to fabricate GIDs over Ethernet/IP specific addresses native to the\n * port.  Normally, packet headers are generated by the sending host\n * adapter, but when sending connectionless datagrams, we must manually\n * inject the proper headers for the fabric we are communicating over.\n *\n * Return: true if we are running as a RoCE port and must force the\n * addition of a Global Route Header built from our Ethernet Address\n * Handle into our header list for connectionless packets.\n */\nstatic inline bool rdma_cap_eth_ah(const struct ib_device *device, u8 port_num)\n{\n\treturn device->port_data[port_num].immutable.core_cap_flags &\n\t       RDMA_CORE_CAP_ETH_AH;\n}\n\n/**\n * rdma_cap_opa_ah - Check if the port of device supports\n * OPA Address handles\n * @device: Device to check\n * @port_num: Port number to check\n *\n * Return: true if we are running on an OPA device which supports\n * the extended OPA addressing.\n */\nstatic inline bool rdma_cap_opa_ah(struct ib_device *device, u8 port_num)\n{\n\treturn (device->port_data[port_num].immutable.core_cap_flags &\n\t\tRDMA_CORE_CAP_OPA_AH) == RDMA_CORE_CAP_OPA_AH;\n}\n\n/**\n * rdma_max_mad_size - Return the max MAD size required by this RDMA Port.\n *\n * @device: Device\n * @port_num: Port number\n *\n * This MAD size includes the MAD headers and MAD payload.  No other headers\n * are included.\n *\n * Return the max MAD size required by the Port.  Will return 0 if the port\n * does not support MADs\n */\nstatic inline size_t rdma_max_mad_size(const struct ib_device *device, u8 port_num)\n{\n\treturn device->port_data[port_num].immutable.max_mad_size;\n}\n\n/**\n * rdma_cap_roce_gid_table - Check if the port of device uses roce_gid_table\n * @device: Device to check\n * @port_num: Port number to check\n *\n * RoCE GID table mechanism manages the various GIDs for a device.\n *\n * NOTE: if allocating the port's GID table has failed, this call will still\n * return true, but any RoCE GID table API will fail.\n *\n * Return: true if the port uses RoCE GID table mechanism in order to manage\n * its GIDs.\n */\nstatic inline bool rdma_cap_roce_gid_table(const struct ib_device *device,\n\t\t\t\t\t   u8 port_num)\n{\n\treturn rdma_protocol_roce(device, port_num) &&\n\t\tdevice->ops.add_gid && device->ops.del_gid;\n}\n\n/*\n * Check if the device supports READ W/ INVALIDATE.\n */\nstatic inline bool rdma_cap_read_inv(struct ib_device *dev, u32 port_num)\n{\n\t/*\n\t * iWarp drivers must support READ W/ INVALIDATE.  No other protocol\n\t * has support for it yet.\n\t */\n\treturn rdma_protocol_iwarp(dev, port_num);\n}\n\n/**\n * rdma_core_cap_opa_port - Return whether the RDMA Port is OPA or not.\n * @device: Device\n * @port_num: 1 based Port number\n *\n * Return true if port is an Intel OPA port , false if not\n */\nstatic inline bool rdma_core_cap_opa_port(struct ib_device *device,\n\t\t\t\t\t  u32 port_num)\n{\n\treturn (device->port_data[port_num].immutable.core_cap_flags &\n\t\tRDMA_CORE_PORT_INTEL_OPA) == RDMA_CORE_PORT_INTEL_OPA;\n}\n\n/**\n * rdma_mtu_enum_to_int - Return the mtu of the port as an integer value.\n * @device: Device\n * @port_num: Port number\n * @mtu: enum value of MTU\n *\n * Return the MTU size supported by the port as an integer value. Will return\n * -1 if enum value of mtu is not supported.\n */\nstatic inline int rdma_mtu_enum_to_int(struct ib_device *device, u8 port,\n\t\t\t\t       int mtu)\n{\n\tif (rdma_core_cap_opa_port(device, port))\n\t\treturn opa_mtu_enum_to_int((enum opa_mtu)mtu);\n\telse\n\t\treturn ib_mtu_enum_to_int((enum ib_mtu)mtu);\n}\n\n/**\n * rdma_mtu_from_attr - Return the mtu of the port from the port attribute.\n * @device: Device\n * @port_num: Port number\n * @attr: port attribute\n *\n * Return the MTU size supported by the port as an integer value.\n */\nstatic inline int rdma_mtu_from_attr(struct ib_device *device, u8 port,\n\t\t\t\t     struct ib_port_attr *attr)\n{\n\tif (rdma_core_cap_opa_port(device, port))\n\t\treturn attr->phys_mtu;\n\telse\n\t\treturn ib_mtu_enum_to_int(attr->max_mtu);\n}\n\nint ib_set_vf_link_state(struct ib_device *device, int vf, u8 port,\n\t\t\t int state);\nint ib_get_vf_config(struct ib_device *device, int vf, u8 port,\n\t\t     struct ifla_vf_info *info);\nint ib_get_vf_stats(struct ib_device *device, int vf, u8 port,\n\t\t    struct ifla_vf_stats *stats);\nint ib_get_vf_guid(struct ib_device *device, int vf, u8 port,\n\t\t    struct ifla_vf_guid *node_guid,\n\t\t    struct ifla_vf_guid *port_guid);\nint ib_set_vf_guid(struct ib_device *device, int vf, u8 port, u64 guid,\n\t\t   int type);\n\nint ib_query_pkey(struct ib_device *device,\n\t\t  u8 port_num, u16 index, u16 *pkey);\n\nint ib_modify_device(struct ib_device *device,\n\t\t     int device_modify_mask,\n\t\t     struct ib_device_modify *device_modify);\n\nint ib_modify_port(struct ib_device *device,\n\t\t   u8 port_num, int port_modify_mask,\n\t\t   struct ib_port_modify *port_modify);\n\nint ib_find_gid(struct ib_device *device, union ib_gid *gid,\n\t\tu8 *port_num, u16 *index);\n\nint ib_find_pkey(struct ib_device *device,\n\t\t u8 port_num, u16 pkey, u16 *index);\n\nenum ib_pd_flags {\n\t/*\n\t * Create a memory registration for all memory in the system and place\n\t * the rkey for it into pd->unsafe_global_rkey.  This can be used by\n\t * ULPs to avoid the overhead of dynamic MRs.\n\t *\n\t * This flag is generally considered unsafe and must only be used in\n\t * extremly trusted environments.  Every use of it will log a warning\n\t * in the kernel log.\n\t */\n\tIB_PD_UNSAFE_GLOBAL_RKEY\t= 0x01,\n};\n\nstruct ib_pd *__ib_alloc_pd(struct ib_device *device, unsigned int flags,\n\t\tconst char *caller);\n\n/**\n * ib_alloc_pd - Allocates an unused protection domain.\n * @device: The device on which to allocate the protection domain.\n * @flags: protection domain flags\n *\n * A protection domain object provides an association between QPs, shared\n * receive queues, address handles, memory regions, and memory windows.\n *\n * Every PD has a local_dma_lkey which can be used as the lkey value for local\n * memory operations.\n */\n#define ib_alloc_pd(device, flags) \\\n\t__ib_alloc_pd((device), (flags), KBUILD_MODNAME)\n\nint ib_dealloc_pd_user(struct ib_pd *pd, struct ib_udata *udata);\n\n/**\n * ib_dealloc_pd - Deallocate kernel PD\n * @pd: The protection domain\n *\n * NOTE: for user PD use ib_dealloc_pd_user with valid udata!\n */\nstatic inline void ib_dealloc_pd(struct ib_pd *pd)\n{\n\tint ret = ib_dealloc_pd_user(pd, NULL);\n\n\tWARN_ONCE(ret, \"Destroy of kernel PD shouldn't fail\");\n}\n\nenum rdma_create_ah_flags {\n\t/* In a sleepable context */\n\tRDMA_CREATE_AH_SLEEPABLE = BIT(0),\n};\n\n/**\n * rdma_create_ah - Creates an address handle for the given address vector.\n * @pd: The protection domain associated with the address handle.\n * @ah_attr: The attributes of the address vector.\n * @flags: Create address handle flags (see enum rdma_create_ah_flags).\n *\n * The address handle is used to reference a local or global destination\n * in all UD QP post sends.\n */\nstruct ib_ah *rdma_create_ah(struct ib_pd *pd, struct rdma_ah_attr *ah_attr,\n\t\t\t     u32 flags);\n\n/**\n * rdma_create_user_ah - Creates an address handle for the given address vector.\n * It resolves destination mac address for ah attribute of RoCE type.\n * @pd: The protection domain associated with the address handle.\n * @ah_attr: The attributes of the address vector.\n * @udata: pointer to user's input output buffer information need by\n *         provider driver.\n *\n * It returns 0 on success and returns appropriate error code on error.\n * The address handle is used to reference a local or global destination\n * in all UD QP post sends.\n */\nstruct ib_ah *rdma_create_user_ah(struct ib_pd *pd,\n\t\t\t\t  struct rdma_ah_attr *ah_attr,\n\t\t\t\t  struct ib_udata *udata);\n/**\n * ib_get_gids_from_rdma_hdr - Get sgid and dgid from GRH or IPv4 header\n *   work completion.\n * @hdr: the L3 header to parse\n * @net_type: type of header to parse\n * @sgid: place to store source gid\n * @dgid: place to store destination gid\n */\nint ib_get_gids_from_rdma_hdr(const union rdma_network_hdr *hdr,\n\t\t\t      enum rdma_network_type net_type,\n\t\t\t      union ib_gid *sgid, union ib_gid *dgid);\n\n/**\n * ib_get_rdma_header_version - Get the header version\n * @hdr: the L3 header to parse\n */\nint ib_get_rdma_header_version(const union rdma_network_hdr *hdr);\n\n/**\n * ib_init_ah_attr_from_wc - Initializes address handle attributes from a\n *   work completion.\n * @device: Device on which the received message arrived.\n * @port_num: Port on which the received message arrived.\n * @wc: Work completion associated with the received message.\n * @grh: References the received global route header.  This parameter is\n *   ignored unless the work completion indicates that the GRH is valid.\n * @ah_attr: Returned attributes that can be used when creating an address\n *   handle for replying to the message.\n * When ib_init_ah_attr_from_wc() returns success,\n * (a) for IB link layer it optionally contains a reference to SGID attribute\n * when GRH is present for IB link layer.\n * (b) for RoCE link layer it contains a reference to SGID attribute.\n * User must invoke rdma_cleanup_ah_attr_gid_attr() to release reference to SGID\n * attributes which are initialized using ib_init_ah_attr_from_wc().\n *\n */\nint ib_init_ah_attr_from_wc(struct ib_device *device, u8 port_num,\n\t\t\t    const struct ib_wc *wc, const struct ib_grh *grh,\n\t\t\t    struct rdma_ah_attr *ah_attr);\n\n/**\n * ib_create_ah_from_wc - Creates an address handle associated with the\n *   sender of the specified work completion.\n * @pd: The protection domain associated with the address handle.\n * @wc: Work completion information associated with a received message.\n * @grh: References the received global route header.  This parameter is\n *   ignored unless the work completion indicates that the GRH is valid.\n * @port_num: The outbound port number to associate with the address.\n *\n * The address handle is used to reference a local or global destination\n * in all UD QP post sends.\n */\nstruct ib_ah *ib_create_ah_from_wc(struct ib_pd *pd, const struct ib_wc *wc,\n\t\t\t\t   const struct ib_grh *grh, u8 port_num);\n\n/**\n * rdma_modify_ah - Modifies the address vector associated with an address\n *   handle.\n * @ah: The address handle to modify.\n * @ah_attr: The new address vector attributes to associate with the\n *   address handle.\n */\nint rdma_modify_ah(struct ib_ah *ah, struct rdma_ah_attr *ah_attr);\n\n/**\n * rdma_query_ah - Queries the address vector associated with an address\n *   handle.\n * @ah: The address handle to query.\n * @ah_attr: The address vector attributes associated with the address\n *   handle.\n */\nint rdma_query_ah(struct ib_ah *ah, struct rdma_ah_attr *ah_attr);\n\nenum rdma_destroy_ah_flags {\n\t/* In a sleepable context */\n\tRDMA_DESTROY_AH_SLEEPABLE = BIT(0),\n};\n\n/**\n * rdma_destroy_ah_user - Destroys an address handle.\n * @ah: The address handle to destroy.\n * @flags: Destroy address handle flags (see enum rdma_destroy_ah_flags).\n * @udata: Valid user data or NULL for kernel objects\n */\nint rdma_destroy_ah_user(struct ib_ah *ah, u32 flags, struct ib_udata *udata);\n\n/**\n * rdma_destroy_ah - Destroys an kernel address handle.\n * @ah: The address handle to destroy.\n * @flags: Destroy address handle flags (see enum rdma_destroy_ah_flags).\n *\n * NOTE: for user ah use rdma_destroy_ah_user with valid udata!\n */\nstatic inline void rdma_destroy_ah(struct ib_ah *ah, u32 flags)\n{\n\tint ret = rdma_destroy_ah_user(ah, flags, NULL);\n\n\tWARN_ONCE(ret, \"Destroy of kernel AH shouldn't fail\");\n}\n\nstruct ib_srq *ib_create_srq_user(struct ib_pd *pd,\n\t\t\t\t  struct ib_srq_init_attr *srq_init_attr,\n\t\t\t\t  struct ib_usrq_object *uobject,\n\t\t\t\t  struct ib_udata *udata);\nstatic inline struct ib_srq *\nib_create_srq(struct ib_pd *pd, struct ib_srq_init_attr *srq_init_attr)\n{\n\tif (!pd->device->ops.create_srq)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\treturn ib_create_srq_user(pd, srq_init_attr, NULL, NULL);\n}\n\n/**\n * ib_modify_srq - Modifies the attributes for the specified SRQ.\n * @srq: The SRQ to modify.\n * @srq_attr: On input, specifies the SRQ attributes to modify.  On output,\n *   the current values of selected SRQ attributes are returned.\n * @srq_attr_mask: A bit-mask used to specify which attributes of the SRQ\n *   are being modified.\n *\n * The mask may contain IB_SRQ_MAX_WR to resize the SRQ and/or\n * IB_SRQ_LIMIT to set the SRQ's limit and request notification when\n * the number of receives queued drops below the limit.\n */\nint ib_modify_srq(struct ib_srq *srq,\n\t\t  struct ib_srq_attr *srq_attr,\n\t\t  enum ib_srq_attr_mask srq_attr_mask);\n\n/**\n * ib_query_srq - Returns the attribute list and current values for the\n *   specified SRQ.\n * @srq: The SRQ to query.\n * @srq_attr: The attributes of the specified SRQ.\n */\nint ib_query_srq(struct ib_srq *srq,\n\t\t struct ib_srq_attr *srq_attr);\n\n/**\n * ib_destroy_srq_user - Destroys the specified SRQ.\n * @srq: The SRQ to destroy.\n * @udata: Valid user data or NULL for kernel objects\n */\nint ib_destroy_srq_user(struct ib_srq *srq, struct ib_udata *udata);\n\n/**\n * ib_destroy_srq - Destroys the specified kernel SRQ.\n * @srq: The SRQ to destroy.\n *\n * NOTE: for user srq use ib_destroy_srq_user with valid udata!\n */\nstatic inline void ib_destroy_srq(struct ib_srq *srq)\n{\n\tint ret = ib_destroy_srq_user(srq, NULL);\n\n\tWARN_ONCE(ret, \"Destroy of kernel SRQ shouldn't fail\");\n}\n\n/**\n * ib_post_srq_recv - Posts a list of work requests to the specified SRQ.\n * @srq: The SRQ to post the work request on.\n * @recv_wr: A list of work requests to post on the receive queue.\n * @bad_recv_wr: On an immediate failure, this parameter will reference\n *   the work request that failed to be posted on the QP.\n */\nstatic inline int ib_post_srq_recv(struct ib_srq *srq,\n\t\t\t\t   const struct ib_recv_wr *recv_wr,\n\t\t\t\t   const struct ib_recv_wr **bad_recv_wr)\n{\n\tconst struct ib_recv_wr *dummy;\n\n\treturn srq->device->ops.post_srq_recv(srq, recv_wr,\n\t\t\t\t\t      bad_recv_wr ? : &dummy);\n}\n\nstruct ib_qp *ib_create_named_qp(struct ib_pd *pd,\n\t\t\t\t struct ib_qp_init_attr *qp_init_attr,\n\t\t\t\t const char *caller);\nstatic inline struct ib_qp *ib_create_qp(struct ib_pd *pd,\n\t\t\t\t\t struct ib_qp_init_attr *init_attr)\n{\n\treturn ib_create_named_qp(pd, init_attr, KBUILD_MODNAME);\n}\n\n/**\n * ib_modify_qp_with_udata - Modifies the attributes for the specified QP.\n * @qp: The QP to modify.\n * @attr: On input, specifies the QP attributes to modify.  On output,\n *   the current values of selected QP attributes are returned.\n * @attr_mask: A bit-mask used to specify which attributes of the QP\n *   are being modified.\n * @udata: pointer to user's input output buffer information\n *   are being modified.\n * It returns 0 on success and returns appropriate error code on error.\n */\nint ib_modify_qp_with_udata(struct ib_qp *qp,\n\t\t\t    struct ib_qp_attr *attr,\n\t\t\t    int attr_mask,\n\t\t\t    struct ib_udata *udata);\n\n/**\n * ib_modify_qp - Modifies the attributes for the specified QP and then\n *   transitions the QP to the given state.\n * @qp: The QP to modify.\n * @qp_attr: On input, specifies the QP attributes to modify.  On output,\n *   the current values of selected QP attributes are returned.\n * @qp_attr_mask: A bit-mask used to specify which attributes of the QP\n *   are being modified.\n */\nint ib_modify_qp(struct ib_qp *qp,\n\t\t struct ib_qp_attr *qp_attr,\n\t\t int qp_attr_mask);\n\n/**\n * ib_query_qp - Returns the attribute list and current values for the\n *   specified QP.\n * @qp: The QP to query.\n * @qp_attr: The attributes of the specified QP.\n * @qp_attr_mask: A bit-mask used to select specific attributes to query.\n * @qp_init_attr: Additional attributes of the selected QP.\n *\n * The qp_attr_mask may be used to limit the query to gathering only the\n * selected attributes.\n */\nint ib_query_qp(struct ib_qp *qp,\n\t\tstruct ib_qp_attr *qp_attr,\n\t\tint qp_attr_mask,\n\t\tstruct ib_qp_init_attr *qp_init_attr);\n\n/**\n * ib_destroy_qp - Destroys the specified QP.\n * @qp: The QP to destroy.\n * @udata: Valid udata or NULL for kernel objects\n */\nint ib_destroy_qp_user(struct ib_qp *qp, struct ib_udata *udata);\n\n/**\n * ib_destroy_qp - Destroys the specified kernel QP.\n * @qp: The QP to destroy.\n *\n * NOTE: for user qp use ib_destroy_qp_user with valid udata!\n */\nstatic inline int ib_destroy_qp(struct ib_qp *qp)\n{\n\treturn ib_destroy_qp_user(qp, NULL);\n}\n\n/**\n * ib_open_qp - Obtain a reference to an existing sharable QP.\n * @xrcd - XRC domain\n * @qp_open_attr: Attributes identifying the QP to open.\n *\n * Returns a reference to a sharable QP.\n */\nstruct ib_qp *ib_open_qp(struct ib_xrcd *xrcd,\n\t\t\t struct ib_qp_open_attr *qp_open_attr);\n\n/**\n * ib_close_qp - Release an external reference to a QP.\n * @qp: The QP handle to release\n *\n * The opened QP handle is released by the caller.  The underlying\n * shared QP is not destroyed until all internal references are released.\n */\nint ib_close_qp(struct ib_qp *qp);\n\n/**\n * ib_post_send - Posts a list of work requests to the send queue of\n *   the specified QP.\n * @qp: The QP to post the work request on.\n * @send_wr: A list of work requests to post on the send queue.\n * @bad_send_wr: On an immediate failure, this parameter will reference\n *   the work request that failed to be posted on the QP.\n *\n * While IBA Vol. 1 section 11.4.1.1 specifies that if an immediate\n * error is returned, the QP state shall not be affected,\n * ib_post_send() will return an immediate error after queueing any\n * earlier work requests in the list.\n */\nstatic inline int ib_post_send(struct ib_qp *qp,\n\t\t\t       const struct ib_send_wr *send_wr,\n\t\t\t       const struct ib_send_wr **bad_send_wr)\n{\n\tconst struct ib_send_wr *dummy;\n\n\treturn qp->device->ops.post_send(qp, send_wr, bad_send_wr ? : &dummy);\n}\n\n/**\n * ib_post_recv - Posts a list of work requests to the receive queue of\n *   the specified QP.\n * @qp: The QP to post the work request on.\n * @recv_wr: A list of work requests to post on the receive queue.\n * @bad_recv_wr: On an immediate failure, this parameter will reference\n *   the work request that failed to be posted on the QP.\n */\nstatic inline int ib_post_recv(struct ib_qp *qp,\n\t\t\t       const struct ib_recv_wr *recv_wr,\n\t\t\t       const struct ib_recv_wr **bad_recv_wr)\n{\n\tconst struct ib_recv_wr *dummy;\n\n\treturn qp->device->ops.post_recv(qp, recv_wr, bad_recv_wr ? : &dummy);\n}\n\nstruct ib_cq *__ib_alloc_cq(struct ib_device *dev, void *private, int nr_cqe,\n\t\t\t    int comp_vector, enum ib_poll_context poll_ctx,\n\t\t\t    const char *caller);\nstatic inline struct ib_cq *ib_alloc_cq(struct ib_device *dev, void *private,\n\t\t\t\t\tint nr_cqe, int comp_vector,\n\t\t\t\t\tenum ib_poll_context poll_ctx)\n{\n\treturn __ib_alloc_cq(dev, private, nr_cqe, comp_vector, poll_ctx,\n\t\t\t     KBUILD_MODNAME);\n}\n\nstruct ib_cq *__ib_alloc_cq_any(struct ib_device *dev, void *private,\n\t\t\t\tint nr_cqe, enum ib_poll_context poll_ctx,\n\t\t\t\tconst char *caller);\n\n/**\n * ib_alloc_cq_any: Allocate kernel CQ\n * @dev: The IB device\n * @private: Private data attached to the CQE\n * @nr_cqe: Number of CQEs in the CQ\n * @poll_ctx: Context used for polling the CQ\n */\nstatic inline struct ib_cq *ib_alloc_cq_any(struct ib_device *dev,\n\t\t\t\t\t    void *private, int nr_cqe,\n\t\t\t\t\t    enum ib_poll_context poll_ctx)\n{\n\treturn __ib_alloc_cq_any(dev, private, nr_cqe, poll_ctx,\n\t\t\t\t KBUILD_MODNAME);\n}\n\nvoid ib_free_cq(struct ib_cq *cq);\nint ib_process_cq_direct(struct ib_cq *cq, int budget);\n\n/**\n * ib_create_cq - Creates a CQ on the specified device.\n * @device: The device on which to create the CQ.\n * @comp_handler: A user-specified callback that is invoked when a\n *   completion event occurs on the CQ.\n * @event_handler: A user-specified callback that is invoked when an\n *   asynchronous event not associated with a completion occurs on the CQ.\n * @cq_context: Context associated with the CQ returned to the user via\n *   the associated completion and event handlers.\n * @cq_attr: The attributes the CQ should be created upon.\n *\n * Users can examine the cq structure to determine the actual CQ size.\n */\nstruct ib_cq *__ib_create_cq(struct ib_device *device,\n\t\t\t     ib_comp_handler comp_handler,\n\t\t\t     void (*event_handler)(struct ib_event *, void *),\n\t\t\t     void *cq_context,\n\t\t\t     const struct ib_cq_init_attr *cq_attr,\n\t\t\t     const char *caller);\n#define ib_create_cq(device, cmp_hndlr, evt_hndlr, cq_ctxt, cq_attr) \\\n\t__ib_create_cq((device), (cmp_hndlr), (evt_hndlr), (cq_ctxt), (cq_attr), KBUILD_MODNAME)\n\n/**\n * ib_resize_cq - Modifies the capacity of the CQ.\n * @cq: The CQ to resize.\n * @cqe: The minimum size of the CQ.\n *\n * Users can examine the cq structure to determine the actual CQ size.\n */\nint ib_resize_cq(struct ib_cq *cq, int cqe);\n\n/**\n * rdma_set_cq_moderation - Modifies moderation params of the CQ\n * @cq: The CQ to modify.\n * @cq_count: number of CQEs that will trigger an event\n * @cq_period: max period of time in usec before triggering an event\n *\n */\nint rdma_set_cq_moderation(struct ib_cq *cq, u16 cq_count, u16 cq_period);\n\n/**\n * ib_destroy_cq_user - Destroys the specified CQ.\n * @cq: The CQ to destroy.\n * @udata: Valid user data or NULL for kernel objects\n */\nint ib_destroy_cq_user(struct ib_cq *cq, struct ib_udata *udata);\n\n/**\n * ib_destroy_cq - Destroys the specified kernel CQ.\n * @cq: The CQ to destroy.\n *\n * NOTE: for user cq use ib_destroy_cq_user with valid udata!\n */\nstatic inline void ib_destroy_cq(struct ib_cq *cq)\n{\n\tint ret = ib_destroy_cq_user(cq, NULL);\n\n\tWARN_ONCE(ret, \"Destroy of kernel CQ shouldn't fail\");\n}\n\n/**\n * ib_poll_cq - poll a CQ for completion(s)\n * @cq:the CQ being polled\n * @num_entries:maximum number of completions to return\n * @wc:array of at least @num_entries &struct ib_wc where completions\n *   will be returned\n *\n * Poll a CQ for (possibly multiple) completions.  If the return value\n * is < 0, an error occurred.  If the return value is >= 0, it is the\n * number of completions returned.  If the return value is\n * non-negative and < num_entries, then the CQ was emptied.\n */\nstatic inline int ib_poll_cq(struct ib_cq *cq, int num_entries,\n\t\t\t     struct ib_wc *wc)\n{\n\treturn cq->device->ops.poll_cq(cq, num_entries, wc);\n}\n\n/**\n * ib_req_notify_cq - Request completion notification on a CQ.\n * @cq: The CQ to generate an event for.\n * @flags:\n *   Must contain exactly one of %IB_CQ_SOLICITED or %IB_CQ_NEXT_COMP\n *   to request an event on the next solicited event or next work\n *   completion at any type, respectively. %IB_CQ_REPORT_MISSED_EVENTS\n *   may also be |ed in to request a hint about missed events, as\n *   described below.\n *\n * Return Value:\n *    < 0 means an error occurred while requesting notification\n *   == 0 means notification was requested successfully, and if\n *        IB_CQ_REPORT_MISSED_EVENTS was passed in, then no events\n *        were missed and it is safe to wait for another event.  In\n *        this case is it guaranteed that any work completions added\n *        to the CQ since the last CQ poll will trigger a completion\n *        notification event.\n *    > 0 is only returned if IB_CQ_REPORT_MISSED_EVENTS was passed\n *        in.  It means that the consumer must poll the CQ again to\n *        make sure it is empty to avoid missing an event because of a\n *        race between requesting notification and an entry being\n *        added to the CQ.  This return value means it is possible\n *        (but not guaranteed) that a work completion has been added\n *        to the CQ since the last poll without triggering a\n *        completion notification event.\n */\nstatic inline int ib_req_notify_cq(struct ib_cq *cq,\n\t\t\t\t   enum ib_cq_notify_flags flags)\n{\n\treturn cq->device->ops.req_notify_cq(cq, flags);\n}\n\nstruct ib_cq *ib_cq_pool_get(struct ib_device *dev, unsigned int nr_cqe,\n\t\t\t     int comp_vector_hint,\n\t\t\t     enum ib_poll_context poll_ctx);\n\nvoid ib_cq_pool_put(struct ib_cq *cq, unsigned int nr_cqe);\n\n/**\n * ib_req_ncomp_notif - Request completion notification when there are\n *   at least the specified number of unreaped completions on the CQ.\n * @cq: The CQ to generate an event for.\n * @wc_cnt: The number of unreaped completions that should be on the\n *   CQ before an event is generated.\n */\nstatic inline int ib_req_ncomp_notif(struct ib_cq *cq, int wc_cnt)\n{\n\treturn cq->device->ops.req_ncomp_notif ?\n\t\tcq->device->ops.req_ncomp_notif(cq, wc_cnt) :\n\t\t-ENOSYS;\n}\n\n/*\n * Drivers that don't need a DMA mapping at the RDMA layer, set dma_device to\n * NULL. This causes the ib_dma* helpers to just stash the kernel virtual\n * address into the dma address.\n */\nstatic inline bool ib_uses_virt_dma(struct ib_device *dev)\n{\n\treturn IS_ENABLED(CONFIG_INFINIBAND_VIRT_DMA) && !dev->dma_device;\n}\n\n/**\n * ib_dma_mapping_error - check a DMA addr for error\n * @dev: The device for which the dma_addr was created\n * @dma_addr: The DMA address to check\n */\nstatic inline int ib_dma_mapping_error(struct ib_device *dev, u64 dma_addr)\n{\n\tif (ib_uses_virt_dma(dev))\n\t\treturn 0;\n\treturn dma_mapping_error(dev->dma_device, dma_addr);\n}\n\n/**\n * ib_dma_map_single - Map a kernel virtual address to DMA address\n * @dev: The device for which the dma_addr is to be created\n * @cpu_addr: The kernel virtual address\n * @size: The size of the region in bytes\n * @direction: The direction of the DMA\n */\nstatic inline u64 ib_dma_map_single(struct ib_device *dev,\n\t\t\t\t    void *cpu_addr, size_t size,\n\t\t\t\t    enum dma_data_direction direction)\n{\n\tif (ib_uses_virt_dma(dev))\n\t\treturn (uintptr_t)cpu_addr;\n\treturn dma_map_single(dev->dma_device, cpu_addr, size, direction);\n}\n\n/**\n * ib_dma_unmap_single - Destroy a mapping created by ib_dma_map_single()\n * @dev: The device for which the DMA address was created\n * @addr: The DMA address\n * @size: The size of the region in bytes\n * @direction: The direction of the DMA\n */\nstatic inline void ib_dma_unmap_single(struct ib_device *dev,\n\t\t\t\t       u64 addr, size_t size,\n\t\t\t\t       enum dma_data_direction direction)\n{\n\tif (!ib_uses_virt_dma(dev))\n\t\tdma_unmap_single(dev->dma_device, addr, size, direction);\n}\n\n/**\n * ib_dma_map_page - Map a physical page to DMA address\n * @dev: The device for which the dma_addr is to be created\n * @page: The page to be mapped\n * @offset: The offset within the page\n * @size: The size of the region in bytes\n * @direction: The direction of the DMA\n */\nstatic inline u64 ib_dma_map_page(struct ib_device *dev,\n\t\t\t\t  struct page *page,\n\t\t\t\t  unsigned long offset,\n\t\t\t\t  size_t size,\n\t\t\t\t\t enum dma_data_direction direction)\n{\n\tif (ib_uses_virt_dma(dev))\n\t\treturn (uintptr_t)(page_address(page) + offset);\n\treturn dma_map_page(dev->dma_device, page, offset, size, direction);\n}\n\n/**\n * ib_dma_unmap_page - Destroy a mapping created by ib_dma_map_page()\n * @dev: The device for which the DMA address was created\n * @addr: The DMA address\n * @size: The size of the region in bytes\n * @direction: The direction of the DMA\n */\nstatic inline void ib_dma_unmap_page(struct ib_device *dev,\n\t\t\t\t     u64 addr, size_t size,\n\t\t\t\t     enum dma_data_direction direction)\n{\n\tif (!ib_uses_virt_dma(dev))\n\t\tdma_unmap_page(dev->dma_device, addr, size, direction);\n}\n\nint ib_dma_virt_map_sg(struct ib_device *dev, struct scatterlist *sg, int nents);\nstatic inline int ib_dma_map_sg_attrs(struct ib_device *dev,\n\t\t\t\t      struct scatterlist *sg, int nents,\n\t\t\t\t      enum dma_data_direction direction,\n\t\t\t\t      unsigned long dma_attrs)\n{\n\tif (ib_uses_virt_dma(dev))\n\t\treturn ib_dma_virt_map_sg(dev, sg, nents);\n\treturn dma_map_sg_attrs(dev->dma_device, sg, nents, direction,\n\t\t\t\tdma_attrs);\n}\n\nstatic inline void ib_dma_unmap_sg_attrs(struct ib_device *dev,\n\t\t\t\t\t struct scatterlist *sg, int nents,\n\t\t\t\t\t enum dma_data_direction direction,\n\t\t\t\t\t unsigned long dma_attrs)\n{\n\tif (!ib_uses_virt_dma(dev))\n\t\tdma_unmap_sg_attrs(dev->dma_device, sg, nents, direction,\n\t\t\t\t   dma_attrs);\n}\n\n/**\n * ib_dma_map_sg - Map a scatter/gather list to DMA addresses\n * @dev: The device for which the DMA addresses are to be created\n * @sg: The array of scatter/gather entries\n * @nents: The number of scatter/gather entries\n * @direction: The direction of the DMA\n */\nstatic inline int ib_dma_map_sg(struct ib_device *dev,\n\t\t\t\tstruct scatterlist *sg, int nents,\n\t\t\t\tenum dma_data_direction direction)\n{\n\treturn ib_dma_map_sg_attrs(dev, sg, nents, direction, 0);\n}\n\n/**\n * ib_dma_unmap_sg - Unmap a scatter/gather list of DMA addresses\n * @dev: The device for which the DMA addresses were created\n * @sg: The array of scatter/gather entries\n * @nents: The number of scatter/gather entries\n * @direction: The direction of the DMA\n */\nstatic inline void ib_dma_unmap_sg(struct ib_device *dev,\n\t\t\t\t   struct scatterlist *sg, int nents,\n\t\t\t\t   enum dma_data_direction direction)\n{\n\tib_dma_unmap_sg_attrs(dev, sg, nents, direction, 0);\n}\n\n/**\n * ib_dma_max_seg_size - Return the size limit of a single DMA transfer\n * @dev: The device to query\n *\n * The returned value represents a size in bytes.\n */\nstatic inline unsigned int ib_dma_max_seg_size(struct ib_device *dev)\n{\n\tif (ib_uses_virt_dma(dev))\n\t\treturn UINT_MAX;\n\treturn dma_get_max_seg_size(dev->dma_device);\n}\n\n/**\n * ib_dma_sync_single_for_cpu - Prepare DMA region to be accessed by CPU\n * @dev: The device for which the DMA address was created\n * @addr: The DMA address\n * @size: The size of the region in bytes\n * @dir: The direction of the DMA\n */\nstatic inline void ib_dma_sync_single_for_cpu(struct ib_device *dev,\n\t\t\t\t\t      u64 addr,\n\t\t\t\t\t      size_t size,\n\t\t\t\t\t      enum dma_data_direction dir)\n{\n\tif (!ib_uses_virt_dma(dev))\n\t\tdma_sync_single_for_cpu(dev->dma_device, addr, size, dir);\n}\n\n/**\n * ib_dma_sync_single_for_device - Prepare DMA region to be accessed by device\n * @dev: The device for which the DMA address was created\n * @addr: The DMA address\n * @size: The size of the region in bytes\n * @dir: The direction of the DMA\n */\nstatic inline void ib_dma_sync_single_for_device(struct ib_device *dev,\n\t\t\t\t\t\t u64 addr,\n\t\t\t\t\t\t size_t size,\n\t\t\t\t\t\t enum dma_data_direction dir)\n{\n\tif (!ib_uses_virt_dma(dev))\n\t\tdma_sync_single_for_device(dev->dma_device, addr, size, dir);\n}\n\n/* ib_reg_user_mr - register a memory region for virtual addresses from kernel\n * space. This function should be called when 'current' is the owning MM.\n */\nstruct ib_mr *ib_reg_user_mr(struct ib_pd *pd, u64 start, u64 length,\n\t\t\t     u64 virt_addr, int mr_access_flags);\n\n/* ib_advise_mr -  give an advice about an address range in a memory region */\nint ib_advise_mr(struct ib_pd *pd, enum ib_uverbs_advise_mr_advice advice,\n\t\t u32 flags, struct ib_sge *sg_list, u32 num_sge);\n/**\n * ib_dereg_mr_user - Deregisters a memory region and removes it from the\n *   HCA translation table.\n * @mr: The memory region to deregister.\n * @udata: Valid user data or NULL for kernel object\n *\n * This function can fail, if the memory region has memory windows bound to it.\n */\nint ib_dereg_mr_user(struct ib_mr *mr, struct ib_udata *udata);\n\n/**\n * ib_dereg_mr - Deregisters a kernel memory region and removes it from the\n *   HCA translation table.\n * @mr: The memory region to deregister.\n *\n * This function can fail, if the memory region has memory windows bound to it.\n *\n * NOTE: for user mr use ib_dereg_mr_user with valid udata!\n */\nstatic inline int ib_dereg_mr(struct ib_mr *mr)\n{\n\treturn ib_dereg_mr_user(mr, NULL);\n}\n\nstruct ib_mr *ib_alloc_mr(struct ib_pd *pd, enum ib_mr_type mr_type,\n\t\t\t  u32 max_num_sg);\n\nstruct ib_mr *ib_alloc_mr_integrity(struct ib_pd *pd,\n\t\t\t\t    u32 max_num_data_sg,\n\t\t\t\t    u32 max_num_meta_sg);\n\n/**\n * ib_update_fast_reg_key - updates the key portion of the fast_reg MR\n *   R_Key and L_Key.\n * @mr - struct ib_mr pointer to be updated.\n * @newkey - new key to be used.\n */\nstatic inline void ib_update_fast_reg_key(struct ib_mr *mr, u8 newkey)\n{\n\tmr->lkey = (mr->lkey & 0xffffff00) | newkey;\n\tmr->rkey = (mr->rkey & 0xffffff00) | newkey;\n}\n\n/**\n * ib_inc_rkey - increments the key portion of the given rkey. Can be used\n * for calculating a new rkey for type 2 memory windows.\n * @rkey - the rkey to increment.\n */\nstatic inline u32 ib_inc_rkey(u32 rkey)\n{\n\tconst u32 mask = 0x000000ff;\n\treturn ((rkey + 1) & mask) | (rkey & ~mask);\n}\n\n/**\n * ib_attach_mcast - Attaches the specified QP to a multicast group.\n * @qp: QP to attach to the multicast group.  The QP must be type\n *   IB_QPT_UD.\n * @gid: Multicast group GID.\n * @lid: Multicast group LID in host byte order.\n *\n * In order to send and receive multicast packets, subnet\n * administration must have created the multicast group and configured\n * the fabric appropriately.  The port associated with the specified\n * QP must also be a member of the multicast group.\n */\nint ib_attach_mcast(struct ib_qp *qp, union ib_gid *gid, u16 lid);\n\n/**\n * ib_detach_mcast - Detaches the specified QP from a multicast group.\n * @qp: QP to detach from the multicast group.\n * @gid: Multicast group GID.\n * @lid: Multicast group LID in host byte order.\n */\nint ib_detach_mcast(struct ib_qp *qp, union ib_gid *gid, u16 lid);\n\nstruct ib_xrcd *ib_alloc_xrcd_user(struct ib_device *device,\n\t\t\t\t   struct inode *inode, struct ib_udata *udata);\nint ib_dealloc_xrcd_user(struct ib_xrcd *xrcd, struct ib_udata *udata);\n\nstatic inline int ib_check_mr_access(struct ib_device *ib_dev,\n\t\t\t\t     unsigned int flags)\n{\n\t/*\n\t * Local write permission is required if remote write or\n\t * remote atomic permission is also requested.\n\t */\n\tif (flags & (IB_ACCESS_REMOTE_ATOMIC | IB_ACCESS_REMOTE_WRITE) &&\n\t    !(flags & IB_ACCESS_LOCAL_WRITE))\n\t\treturn -EINVAL;\n\n\tif (flags & ~IB_ACCESS_SUPPORTED)\n\t\treturn -EINVAL;\n\n\tif (flags & IB_ACCESS_ON_DEMAND &&\n\t    !(ib_dev->attrs.device_cap_flags & IB_DEVICE_ON_DEMAND_PAGING))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic inline bool ib_access_writable(int access_flags)\n{\n\t/*\n\t * We have writable memory backing the MR if any of the following\n\t * access flags are set.  \"Local write\" and \"remote write\" obviously\n\t * require write access.  \"Remote atomic\" can do things like fetch and\n\t * add, which will modify memory, and \"MW bind\" can change permissions\n\t * by binding a window.\n\t */\n\treturn access_flags &\n\t\t(IB_ACCESS_LOCAL_WRITE   | IB_ACCESS_REMOTE_WRITE |\n\t\t IB_ACCESS_REMOTE_ATOMIC | IB_ACCESS_MW_BIND);\n}\n\n/**\n * ib_check_mr_status: lightweight check of MR status.\n *     This routine may provide status checks on a selected\n *     ib_mr. first use is for signature status check.\n *\n * @mr: A memory region.\n * @check_mask: Bitmask of which checks to perform from\n *     ib_mr_status_check enumeration.\n * @mr_status: The container of relevant status checks.\n *     failed checks will be indicated in the status bitmask\n *     and the relevant info shall be in the error item.\n */\nint ib_check_mr_status(struct ib_mr *mr, u32 check_mask,\n\t\t       struct ib_mr_status *mr_status);\n\n/**\n * ib_device_try_get: Hold a registration lock\n * device: The device to lock\n *\n * A device under an active registration lock cannot become unregistered. It\n * is only possible to obtain a registration lock on a device that is fully\n * registered, otherwise this function returns false.\n *\n * The registration lock is only necessary for actions which require the\n * device to still be registered. Uses that only require the device pointer to\n * be valid should use get_device(&ibdev->dev) to hold the memory.\n *\n */\nstatic inline bool ib_device_try_get(struct ib_device *dev)\n{\n\treturn refcount_inc_not_zero(&dev->refcount);\n}\n\nvoid ib_device_put(struct ib_device *device);\nstruct ib_device *ib_device_get_by_netdev(struct net_device *ndev,\n\t\t\t\t\t  enum rdma_driver_id driver_id);\nstruct ib_device *ib_device_get_by_name(const char *name,\n\t\t\t\t\tenum rdma_driver_id driver_id);\nstruct net_device *ib_get_net_dev_by_params(struct ib_device *dev, u8 port,\n\t\t\t\t\t    u16 pkey, const union ib_gid *gid,\n\t\t\t\t\t    const struct sockaddr *addr);\nint ib_device_set_netdev(struct ib_device *ib_dev, struct net_device *ndev,\n\t\t\t unsigned int port);\nstruct net_device *ib_device_netdev(struct ib_device *dev, u8 port);\n\nstruct ib_wq *ib_create_wq(struct ib_pd *pd,\n\t\t\t   struct ib_wq_init_attr *init_attr);\nint ib_destroy_wq_user(struct ib_wq *wq, struct ib_udata *udata);\nint ib_modify_wq(struct ib_wq *wq, struct ib_wq_attr *attr,\n\t\t u32 wq_attr_mask);\n\nint ib_map_mr_sg(struct ib_mr *mr, struct scatterlist *sg, int sg_nents,\n\t\t unsigned int *sg_offset, unsigned int page_size);\nint ib_map_mr_sg_pi(struct ib_mr *mr, struct scatterlist *data_sg,\n\t\t    int data_sg_nents, unsigned int *data_sg_offset,\n\t\t    struct scatterlist *meta_sg, int meta_sg_nents,\n\t\t    unsigned int *meta_sg_offset, unsigned int page_size);\n\nstatic inline int\nib_map_mr_sg_zbva(struct ib_mr *mr, struct scatterlist *sg, int sg_nents,\n\t\t  unsigned int *sg_offset, unsigned int page_size)\n{\n\tint n;\n\n\tn = ib_map_mr_sg(mr, sg, sg_nents, sg_offset, page_size);\n\tmr->iova = 0;\n\n\treturn n;\n}\n\nint ib_sg_to_pages(struct ib_mr *mr, struct scatterlist *sgl, int sg_nents,\n\t\tunsigned int *sg_offset, int (*set_page)(struct ib_mr *, u64));\n\nvoid ib_drain_rq(struct ib_qp *qp);\nvoid ib_drain_sq(struct ib_qp *qp);\nvoid ib_drain_qp(struct ib_qp *qp);\n\nint ib_get_eth_speed(struct ib_device *dev, u8 port_num, u16 *speed, u8 *width);\n\nstatic inline u8 *rdma_ah_retrieve_dmac(struct rdma_ah_attr *attr)\n{\n\tif (attr->type == RDMA_AH_ATTR_TYPE_ROCE)\n\t\treturn attr->roce.dmac;\n\treturn NULL;\n}\n\nstatic inline void rdma_ah_set_dlid(struct rdma_ah_attr *attr, u32 dlid)\n{\n\tif (attr->type == RDMA_AH_ATTR_TYPE_IB)\n\t\tattr->ib.dlid = (u16)dlid;\n\telse if (attr->type == RDMA_AH_ATTR_TYPE_OPA)\n\t\tattr->opa.dlid = dlid;\n}\n\nstatic inline u32 rdma_ah_get_dlid(const struct rdma_ah_attr *attr)\n{\n\tif (attr->type == RDMA_AH_ATTR_TYPE_IB)\n\t\treturn attr->ib.dlid;\n\telse if (attr->type == RDMA_AH_ATTR_TYPE_OPA)\n\t\treturn attr->opa.dlid;\n\treturn 0;\n}\n\nstatic inline void rdma_ah_set_sl(struct rdma_ah_attr *attr, u8 sl)\n{\n\tattr->sl = sl;\n}\n\nstatic inline u8 rdma_ah_get_sl(const struct rdma_ah_attr *attr)\n{\n\treturn attr->sl;\n}\n\nstatic inline void rdma_ah_set_path_bits(struct rdma_ah_attr *attr,\n\t\t\t\t\t u8 src_path_bits)\n{\n\tif (attr->type == RDMA_AH_ATTR_TYPE_IB)\n\t\tattr->ib.src_path_bits = src_path_bits;\n\telse if (attr->type == RDMA_AH_ATTR_TYPE_OPA)\n\t\tattr->opa.src_path_bits = src_path_bits;\n}\n\nstatic inline u8 rdma_ah_get_path_bits(const struct rdma_ah_attr *attr)\n{\n\tif (attr->type == RDMA_AH_ATTR_TYPE_IB)\n\t\treturn attr->ib.src_path_bits;\n\telse if (attr->type == RDMA_AH_ATTR_TYPE_OPA)\n\t\treturn attr->opa.src_path_bits;\n\treturn 0;\n}\n\nstatic inline void rdma_ah_set_make_grd(struct rdma_ah_attr *attr,\n\t\t\t\t\tbool make_grd)\n{\n\tif (attr->type == RDMA_AH_ATTR_TYPE_OPA)\n\t\tattr->opa.make_grd = make_grd;\n}\n\nstatic inline bool rdma_ah_get_make_grd(const struct rdma_ah_attr *attr)\n{\n\tif (attr->type == RDMA_AH_ATTR_TYPE_OPA)\n\t\treturn attr->opa.make_grd;\n\treturn false;\n}\n\nstatic inline void rdma_ah_set_port_num(struct rdma_ah_attr *attr, u8 port_num)\n{\n\tattr->port_num = port_num;\n}\n\nstatic inline u8 rdma_ah_get_port_num(const struct rdma_ah_attr *attr)\n{\n\treturn attr->port_num;\n}\n\nstatic inline void rdma_ah_set_static_rate(struct rdma_ah_attr *attr,\n\t\t\t\t\t   u8 static_rate)\n{\n\tattr->static_rate = static_rate;\n}\n\nstatic inline u8 rdma_ah_get_static_rate(const struct rdma_ah_attr *attr)\n{\n\treturn attr->static_rate;\n}\n\nstatic inline void rdma_ah_set_ah_flags(struct rdma_ah_attr *attr,\n\t\t\t\t\tenum ib_ah_flags flag)\n{\n\tattr->ah_flags = flag;\n}\n\nstatic inline enum ib_ah_flags\n\t\trdma_ah_get_ah_flags(const struct rdma_ah_attr *attr)\n{\n\treturn attr->ah_flags;\n}\n\nstatic inline const struct ib_global_route\n\t\t*rdma_ah_read_grh(const struct rdma_ah_attr *attr)\n{\n\treturn &attr->grh;\n}\n\n/*To retrieve and modify the grh */\nstatic inline struct ib_global_route\n\t\t*rdma_ah_retrieve_grh(struct rdma_ah_attr *attr)\n{\n\treturn &attr->grh;\n}\n\nstatic inline void rdma_ah_set_dgid_raw(struct rdma_ah_attr *attr, void *dgid)\n{\n\tstruct ib_global_route *grh = rdma_ah_retrieve_grh(attr);\n\n\tmemcpy(grh->dgid.raw, dgid, sizeof(grh->dgid));\n}\n\nstatic inline void rdma_ah_set_subnet_prefix(struct rdma_ah_attr *attr,\n\t\t\t\t\t     __be64 prefix)\n{\n\tstruct ib_global_route *grh = rdma_ah_retrieve_grh(attr);\n\n\tgrh->dgid.global.subnet_prefix = prefix;\n}\n\nstatic inline void rdma_ah_set_interface_id(struct rdma_ah_attr *attr,\n\t\t\t\t\t    __be64 if_id)\n{\n\tstruct ib_global_route *grh = rdma_ah_retrieve_grh(attr);\n\n\tgrh->dgid.global.interface_id = if_id;\n}\n\nstatic inline void rdma_ah_set_grh(struct rdma_ah_attr *attr,\n\t\t\t\t   union ib_gid *dgid, u32 flow_label,\n\t\t\t\t   u8 sgid_index, u8 hop_limit,\n\t\t\t\t   u8 traffic_class)\n{\n\tstruct ib_global_route *grh = rdma_ah_retrieve_grh(attr);\n\n\tattr->ah_flags = IB_AH_GRH;\n\tif (dgid)\n\t\tgrh->dgid = *dgid;\n\tgrh->flow_label = flow_label;\n\tgrh->sgid_index = sgid_index;\n\tgrh->hop_limit = hop_limit;\n\tgrh->traffic_class = traffic_class;\n\tgrh->sgid_attr = NULL;\n}\n\nvoid rdma_destroy_ah_attr(struct rdma_ah_attr *ah_attr);\nvoid rdma_move_grh_sgid_attr(struct rdma_ah_attr *attr, union ib_gid *dgid,\n\t\t\t     u32 flow_label, u8 hop_limit, u8 traffic_class,\n\t\t\t     const struct ib_gid_attr *sgid_attr);\nvoid rdma_copy_ah_attr(struct rdma_ah_attr *dest,\n\t\t       const struct rdma_ah_attr *src);\nvoid rdma_replace_ah_attr(struct rdma_ah_attr *old,\n\t\t\t  const struct rdma_ah_attr *new);\nvoid rdma_move_ah_attr(struct rdma_ah_attr *dest, struct rdma_ah_attr *src);\n\n/**\n * rdma_ah_find_type - Return address handle type.\n *\n * @dev: Device to be checked\n * @port_num: Port number\n */\nstatic inline enum rdma_ah_attr_type rdma_ah_find_type(struct ib_device *dev,\n\t\t\t\t\t\t       u8 port_num)\n{\n\tif (rdma_protocol_roce(dev, port_num))\n\t\treturn RDMA_AH_ATTR_TYPE_ROCE;\n\tif (rdma_protocol_ib(dev, port_num)) {\n\t\tif (rdma_cap_opa_ah(dev, port_num))\n\t\t\treturn RDMA_AH_ATTR_TYPE_OPA;\n\t\treturn RDMA_AH_ATTR_TYPE_IB;\n\t}\n\n\treturn RDMA_AH_ATTR_TYPE_UNDEFINED;\n}\n\n/**\n * ib_lid_cpu16 - Return lid in 16bit CPU encoding.\n *     In the current implementation the only way to get\n *     get the 32bit lid is from other sources for OPA.\n *     For IB, lids will always be 16bits so cast the\n *     value accordingly.\n *\n * @lid: A 32bit LID\n */\nstatic inline u16 ib_lid_cpu16(u32 lid)\n{\n\tWARN_ON_ONCE(lid & 0xFFFF0000);\n\treturn (u16)lid;\n}\n\n/**\n * ib_lid_be16 - Return lid in 16bit BE encoding.\n *\n * @lid: A 32bit LID\n */\nstatic inline __be16 ib_lid_be16(u32 lid)\n{\n\tWARN_ON_ONCE(lid & 0xFFFF0000);\n\treturn cpu_to_be16((u16)lid);\n}\n\n/**\n * ib_get_vector_affinity - Get the affinity mappings of a given completion\n *   vector\n * @device:         the rdma device\n * @comp_vector:    index of completion vector\n *\n * Returns NULL on failure, otherwise a corresponding cpu map of the\n * completion vector (returns all-cpus map if the device driver doesn't\n * implement get_vector_affinity).\n */\nstatic inline const struct cpumask *\nib_get_vector_affinity(struct ib_device *device, int comp_vector)\n{\n\tif (comp_vector < 0 || comp_vector >= device->num_comp_vectors ||\n\t    !device->ops.get_vector_affinity)\n\t\treturn NULL;\n\n\treturn device->ops.get_vector_affinity(device, comp_vector);\n\n}\n\n/**\n * rdma_roce_rescan_device - Rescan all of the network devices in the system\n * and add their gids, as needed, to the relevant RoCE devices.\n *\n * @device:         the rdma device\n */\nvoid rdma_roce_rescan_device(struct ib_device *ibdev);\n\nstruct ib_ucontext *ib_uverbs_get_ucontext_file(struct ib_uverbs_file *ufile);\n\nint uverbs_destroy_def_handler(struct uverbs_attr_bundle *attrs);\n\nstruct net_device *rdma_alloc_netdev(struct ib_device *device, u8 port_num,\n\t\t\t\t     enum rdma_netdev_t type, const char *name,\n\t\t\t\t     unsigned char name_assign_type,\n\t\t\t\t     void (*setup)(struct net_device *));\n\nint rdma_init_netdev(struct ib_device *device, u8 port_num,\n\t\t     enum rdma_netdev_t type, const char *name,\n\t\t     unsigned char name_assign_type,\n\t\t     void (*setup)(struct net_device *),\n\t\t     struct net_device *netdev);\n\n/**\n * rdma_set_device_sysfs_group - Set device attributes group to have\n *\t\t\t\t driver specific sysfs entries at\n *\t\t\t\t for infiniband class.\n *\n * @device:\tdevice pointer for which attributes to be created\n * @group:\tPointer to group which should be added when device\n *\t\tis registered with sysfs.\n * rdma_set_device_sysfs_group() allows existing drivers to expose one\n * group per device to have sysfs attributes.\n *\n * NOTE: New drivers should not make use of this API; instead new device\n * parameter should be exposed via netlink command. This API and mechanism\n * exist only for existing drivers.\n */\nstatic inline void\nrdma_set_device_sysfs_group(struct ib_device *dev,\n\t\t\t    const struct attribute_group *group)\n{\n\tdev->groups[1] = group;\n}\n\n/**\n * rdma_device_to_ibdev - Get ib_device pointer from device pointer\n *\n * @device:\tdevice pointer for which ib_device pointer to retrieve\n *\n * rdma_device_to_ibdev() retrieves ib_device pointer from device.\n *\n */\nstatic inline struct ib_device *rdma_device_to_ibdev(struct device *device)\n{\n\tstruct ib_core_device *coredev =\n\t\tcontainer_of(device, struct ib_core_device, dev);\n\n\treturn coredev->owner;\n}\n\n/**\n * ibdev_to_node - return the NUMA node for a given ib_device\n * @dev:\tdevice to get the NUMA node for.\n */\nstatic inline int ibdev_to_node(struct ib_device *ibdev)\n{\n\tstruct device *parent = ibdev->dev.parent;\n\n\tif (!parent)\n\t\treturn NUMA_NO_NODE;\n\treturn dev_to_node(parent);\n}\n\n/**\n * rdma_device_to_drv_device - Helper macro to reach back to driver's\n *\t\t\t       ib_device holder structure from device pointer.\n *\n * NOTE: New drivers should not make use of this API; This API is only for\n * existing drivers who have exposed sysfs entries using\n * rdma_set_device_sysfs_group().\n */\n#define rdma_device_to_drv_device(dev, drv_dev_struct, ibdev_member)           \\\n\tcontainer_of(rdma_device_to_ibdev(dev), drv_dev_struct, ibdev_member)\n\nbool rdma_dev_access_netns(const struct ib_device *device,\n\t\t\t   const struct net *net);\n\n#define IB_ROCE_UDP_ENCAP_VALID_PORT_MIN (0xC000)\n#define IB_ROCE_UDP_ENCAP_VALID_PORT_MAX (0xFFFF)\n#define IB_GRH_FLOWLABEL_MASK (0x000FFFFF)\n\n/**\n * rdma_flow_label_to_udp_sport - generate a RoCE v2 UDP src port value based\n *                               on the flow_label\n *\n * This function will convert the 20 bit flow_label input to a valid RoCE v2\n * UDP src port 14 bit value. All RoCE V2 drivers should use this same\n * convention.\n */\nstatic inline u16 rdma_flow_label_to_udp_sport(u32 fl)\n{\n\tu32 fl_low = fl & 0x03fff, fl_high = fl & 0xFC000;\n\n\tfl_low ^= fl_high >> 14;\n\treturn (u16)(fl_low | IB_ROCE_UDP_ENCAP_VALID_PORT_MIN);\n}\n\n/**\n * rdma_calc_flow_label - generate a RDMA symmetric flow label value based on\n *                        local and remote qpn values\n *\n * This function folded the multiplication results of two qpns, 24 bit each,\n * fields, and converts it to a 20 bit results.\n *\n * This function will create symmetric flow_label value based on the local\n * and remote qpn values. this will allow both the requester and responder\n * to calculate the same flow_label for a given connection.\n *\n * This helper function should be used by driver in case the upper layer\n * provide a zero flow_label value. This is to improve entropy of RDMA\n * traffic in the network.\n */\nstatic inline u32 rdma_calc_flow_label(u32 lqpn, u32 rqpn)\n{\n\tu64 v = (u64)lqpn * rqpn;\n\n\tv ^= v >> 20;\n\tv ^= v >> 40;\n\n\treturn (u32)(v & IB_GRH_FLOWLABEL_MASK);\n}\n\nconst struct ib_port_immutable*\nib_port_immutable_read(struct ib_device *dev, unsigned int port);\n#endif /* IB_VERBS_H */\n"}}, "reports": [{"events": [{"location": {"col": 3, "file": 0, "line": 2262}, "message": "WARNING: casting value returned by memory allocation function to (struct ib_type *) is useless."}], "macros": [], "notes": [], "path": "/src/include/rdma/ib_verbs.h", "reportHash": "bb1b97c802b0d7f7f403439acde511d5", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
