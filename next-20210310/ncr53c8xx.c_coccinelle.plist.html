<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/scsi/ncr53c8xx.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/******************************************************************************\n**  Device driver for the PCI-SCSI NCR538XX controller family.\n**\n**  Copyright (C) 1994  Wolfgang Stanglmeier\n**\n**\n**-----------------------------------------------------------------------------\n**\n**  This driver has been ported to Linux from the FreeBSD NCR53C8XX driver\n**  and is currently maintained by\n**\n**          Gerard Roudier              <groudier@free.fr>\n**\n**  Being given that this driver originates from the FreeBSD version, and\n**  in order to keep synergy on both, any suggested enhancements and corrections\n**  received on Linux are automatically a potential candidate for the FreeBSD \n**  version.\n**\n**  The original driver has been written for 386bsd and FreeBSD by\n**          Wolfgang Stanglmeier        <wolf@cologne.de>\n**          Stefan Esser                <se@mi.Uni-Koeln.de>\n**\n**  And has been ported to NetBSD by\n**          Charles M. Hannum           <mycroft@gnu.ai.mit.edu>\n**\n**-----------------------------------------------------------------------------\n**\n**                     Brief history\n**\n**  December 10 1995 by Gerard Roudier:\n**     Initial port to Linux.\n**\n**  June 23 1996 by Gerard Roudier:\n**     Support for 64 bits architectures (Alpha).\n**\n**  November 30 1996 by Gerard Roudier:\n**     Support for Fast-20 scsi.\n**     Support for large DMA fifo and 128 dwords bursting.\n**\n**  February 27 1997 by Gerard Roudier:\n**     Support for Fast-40 scsi.\n**     Support for on-Board RAM.\n**\n**  May 3 1997 by Gerard Roudier:\n**     Full support for scsi scripts instructions pre-fetching.\n**\n**  May 19 1997 by Richard Waltham <dormouse@farsrobt.demon.co.uk>:\n**     Support for NvRAM detection and reading.\n**\n**  August 18 1997 by Cort <cort@cs.nmt.edu>:\n**     Support for Power/PC (Big Endian).\n**\n**  June 20 1998 by Gerard Roudier\n**     Support for up to 64 tags per lun.\n**     O(1) everywhere (C and SCRIPTS) for normal cases.\n**     Low PCI traffic for command handling when on-chip RAM is present.\n**     Aggressive SCSI SCRIPTS optimizations.\n**\n**  2005 by Matthew Wilcox and James Bottomley\n**     PCI-ectomy.  This driver now supports only the 720 chip (see the\n**     NCR_Q720 and zalon drivers for the bus probe logic).\n**\n*******************************************************************************\n*/\n\n/*\n**\tSupported SCSI-II features:\n**\t    Synchronous negotiation\n**\t    Wide negotiation        (depends on the NCR Chip)\n**\t    Enable disconnection\n**\t    Tagged command queuing\n**\t    Parity checking\n**\t    Etc...\n**\n**\tSupported NCR/SYMBIOS chips:\n**\t\t53C720\t\t(Wide,   Fast SCSI-2, intfly problems)\n*/\n\n/* Name and version of the driver */\n#define SCSI_NCR_DRIVER_NAME\t\"ncr53c8xx-3.4.3g\"\n\n#define SCSI_NCR_DEBUG_FLAGS\t(0)\n\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/timer.h>\n#include <linux/types.h>\n\n#include <asm/dma.h>\n#include <asm/io.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_spi.h>\n\n#include \"ncr53c8xx.h\"\n\n#define NAME53C8XX\t\t\"ncr53c8xx\"\n\n/*==========================================================\n**\n**\tDebugging tags\n**\n**==========================================================\n*/\n\n#define DEBUG_ALLOC    (0x0001)\n#define DEBUG_PHASE    (0x0002)\n#define DEBUG_QUEUE    (0x0008)\n#define DEBUG_RESULT   (0x0010)\n#define DEBUG_POINTER  (0x0020)\n#define DEBUG_SCRIPT   (0x0040)\n#define DEBUG_TINY     (0x0080)\n#define DEBUG_TIMING   (0x0100)\n#define DEBUG_NEGO     (0x0200)\n#define DEBUG_TAGS     (0x0400)\n#define DEBUG_SCATTER  (0x0800)\n#define DEBUG_IC        (0x1000)\n\n/*\n**    Enable/Disable debug messages.\n**    Can be changed at runtime too.\n*/\n\n#ifdef SCSI_NCR_DEBUG_INFO_SUPPORT\nstatic int ncr_debug = SCSI_NCR_DEBUG_FLAGS;\n\t#define DEBUG_FLAGS ncr_debug\n#else\n\t#define DEBUG_FLAGS\tSCSI_NCR_DEBUG_FLAGS\n#endif\n\n/*\n * Locally used status flag\n */\n#define SAM_STAT_ILLEGAL\t0xff\n\nstatic inline struct list_head *ncr_list_pop(struct list_head *head)\n{\n\tif (!list_empty(head)) {\n\t\tstruct list_head *elem = head->next;\n\n\t\tlist_del(elem);\n\t\treturn elem;\n\t}\n\n\treturn NULL;\n}\n\n/*==========================================================\n**\n**\tSimple power of two buddy-like allocator.\n**\n**\tThis simple code is not intended to be fast, but to \n**\tprovide power of 2 aligned memory allocations.\n**\tSince the SCRIPTS processor only supplies 8 bit \n**\tarithmetic, this allocator allows simple and fast \n**\taddress calculations  from the SCRIPTS code.\n**\tIn addition, cache line alignment is guaranteed for \n**\tpower of 2 cache line size.\n**\tEnhanced in linux-2.3.44 to provide a memory pool \n**\tper pcidev to support dynamic dma mapping. (I would \n**\thave preferred a real bus abstraction, btw).\n**\n**==========================================================\n*/\n\n#define MEMO_SHIFT\t4\t/* 16 bytes minimum memory chunk */\n#if PAGE_SIZE >= 8192\n#define MEMO_PAGE_ORDER\t0\t/* 1 PAGE  maximum */\n#else\n#define MEMO_PAGE_ORDER\t1\t/* 2 PAGES maximum */\n#endif\n#define MEMO_FREE_UNUSED\t/* Free unused pages immediately */\n#define MEMO_WARN\t1\n#define MEMO_GFP_FLAGS\tGFP_ATOMIC\n#define MEMO_CLUSTER_SHIFT\t(PAGE_SHIFT+MEMO_PAGE_ORDER)\n#define MEMO_CLUSTER_SIZE\t(1UL << MEMO_CLUSTER_SHIFT)\n#define MEMO_CLUSTER_MASK\t(MEMO_CLUSTER_SIZE-1)\n\ntypedef u_long m_addr_t;\t/* Enough bits to bit-hack addresses */\ntypedef struct device *m_bush_t;\t/* Something that addresses DMAable */\n\ntypedef struct m_link {\t\t/* Link between free memory chunks */\n\tstruct m_link *next;\n} m_link_s;\n\ntypedef struct m_vtob {\t\t/* Virtual to Bus address translation */\n\tstruct m_vtob *next;\n\tm_addr_t vaddr;\n\tm_addr_t baddr;\n} m_vtob_s;\n#define VTOB_HASH_SHIFT\t\t5\n#define VTOB_HASH_SIZE\t\t(1UL << VTOB_HASH_SHIFT)\n#define VTOB_HASH_MASK\t\t(VTOB_HASH_SIZE-1)\n#define VTOB_HASH_CODE(m)\t\\\n\t((((m_addr_t) (m)) >> MEMO_CLUSTER_SHIFT) & VTOB_HASH_MASK)\n\ntypedef struct m_pool {\t\t/* Memory pool of a given kind */\n\tm_bush_t bush;\n\tm_addr_t (*getp)(struct m_pool *);\n\tvoid (*freep)(struct m_pool *, m_addr_t);\n\tint nump;\n\tm_vtob_s *(vtob[VTOB_HASH_SIZE]);\n\tstruct m_pool *next;\n\tstruct m_link h[PAGE_SHIFT-MEMO_SHIFT+MEMO_PAGE_ORDER+1];\n} m_pool_s;\n\nstatic void *___m_alloc(m_pool_s *mp, int size)\n{\n\tint i = 0;\n\tint s = (1 << MEMO_SHIFT);\n\tint j;\n\tm_addr_t a;\n\tm_link_s *h = mp->h;\n\n\tif (size > (PAGE_SIZE << MEMO_PAGE_ORDER))\n\t\treturn NULL;\n\n\twhile (size > s) {\n\t\ts <<= 1;\n\t\t++i;\n\t}\n\n\tj = i;\n\twhile (!h[j].next) {\n\t\tif (s == (PAGE_SIZE << MEMO_PAGE_ORDER)) {\n\t\t\th[j].next = (m_link_s *)mp->getp(mp);\n\t\t\tif (h[j].next)\n\t\t\t\th[j].next->next = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t++j;\n\t\ts <<= 1;\n\t}\n\ta = (m_addr_t) h[j].next;\n\tif (a) {\n\t\th[j].next = h[j].next->next;\n\t\twhile (j > i) {\n\t\t\tj -= 1;\n\t\t\ts >>= 1;\n\t\t\th[j].next = (m_link_s *) (a+s);\n\t\t\th[j].next->next = NULL;\n\t\t}\n\t}\n#ifdef DEBUG\n\tprintk(\"___m_alloc(%d) = %p\\n\", size, (void *) a);\n#endif\n\treturn (void *) a;\n}\n\nstatic void ___m_free(m_pool_s *mp, void *ptr, int size)\n{\n\tint i = 0;\n\tint s = (1 << MEMO_SHIFT);\n\tm_link_s *q;\n\tm_addr_t a, b;\n\tm_link_s *h = mp->h;\n\n#ifdef DEBUG\n\tprintk(\"___m_free(%p, %d)\\n\", ptr, size);\n#endif\n\n\tif (size > (PAGE_SIZE << MEMO_PAGE_ORDER))\n\t\treturn;\n\n\twhile (size > s) {\n\t\ts <<= 1;\n\t\t++i;\n\t}\n\n\ta = (m_addr_t) ptr;\n\n\twhile (1) {\n#ifdef MEMO_FREE_UNUSED\n\t\tif (s == (PAGE_SIZE << MEMO_PAGE_ORDER)) {\n\t\t\tmp->freep(mp, a);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tb = a ^ s;\n\t\tq = &h[i];\n\t\twhile (q->next && q->next != (m_link_s *) b) {\n\t\t\tq = q->next;\n\t\t}\n\t\tif (!q->next) {\n\t\t\t((m_link_s *) a)->next = h[i].next;\n\t\t\th[i].next = (m_link_s *) a;\n\t\t\tbreak;\n\t\t}\n\t\tq->next = q->next->next;\n\t\ta = a & b;\n\t\ts <<= 1;\n\t\t++i;\n\t}\n}\n\nstatic DEFINE_SPINLOCK(ncr53c8xx_lock);\n\nstatic void *__m_calloc2(m_pool_s *mp, int size, char *name, int uflags)\n{\n\tvoid *p;\n\n\tp = ___m_alloc(mp, size);\n\n\tif (DEBUG_FLAGS & DEBUG_ALLOC)\n\t\tprintk (\"new %-10s[%4d] @%p.\\n\", name, size, p);\n\n\tif (p)\n\t\tmemset(p, 0, size);\n\telse if (uflags & MEMO_WARN)\n\t\tprintk (NAME53C8XX \": failed to allocate %s[%d]\\n\", name, size);\n\n\treturn p;\n}\n\n#define __m_calloc(mp, s, n)\t__m_calloc2(mp, s, n, MEMO_WARN)\n\nstatic void __m_free(m_pool_s *mp, void *ptr, int size, char *name)\n{\n\tif (DEBUG_FLAGS & DEBUG_ALLOC)\n\t\tprintk (\"freeing %-10s[%4d] @%p.\\n\", name, size, ptr);\n\n\t___m_free(mp, ptr, size);\n\n}\n\n/*\n * With pci bus iommu support, we use a default pool of unmapped memory \n * for memory we donnot need to DMA from/to and one pool per pcidev for \n * memory accessed by the PCI chip. `mp0' is the default not DMAable pool.\n */\n\nstatic m_addr_t ___mp0_getp(m_pool_s *mp)\n{\n\tm_addr_t m = __get_free_pages(MEMO_GFP_FLAGS, MEMO_PAGE_ORDER);\n\tif (m)\n\t\t++mp->nump;\n\treturn m;\n}\n\nstatic void ___mp0_freep(m_pool_s *mp, m_addr_t m)\n{\n\tfree_pages(m, MEMO_PAGE_ORDER);\n\t--mp->nump;\n}\n\nstatic m_pool_s mp0 = {NULL, ___mp0_getp, ___mp0_freep};\n\n/*\n * DMAable pools.\n */\n\n/*\n * With pci bus iommu support, we maintain one pool per pcidev and a \n * hashed reverse table for virtual to bus physical address translations.\n */\nstatic m_addr_t ___dma_getp(m_pool_s *mp)\n{\n\tm_addr_t vp;\n\tm_vtob_s *vbp;\n\n\tvbp = __m_calloc(&mp0, sizeof(*vbp), \"VTOB\");\n\tif (vbp) {\n\t\tdma_addr_t daddr;\n\t\tvp = (m_addr_t) dma_alloc_coherent(mp->bush,\n\t\t\t\t\t\tPAGE_SIZE<<MEMO_PAGE_ORDER,\n\t\t\t\t\t\t&daddr, GFP_ATOMIC);\n\t\tif (vp) {\n\t\t\tint hc = VTOB_HASH_CODE(vp);\n\t\t\tvbp->vaddr = vp;\n\t\t\tvbp->baddr = daddr;\n\t\t\tvbp->next = mp->vtob[hc];\n\t\t\tmp->vtob[hc] = vbp;\n\t\t\t++mp->nump;\n\t\t\treturn vp;\n\t\t}\n\t}\n\tif (vbp)\n\t\t__m_free(&mp0, vbp, sizeof(*vbp), \"VTOB\");\n\treturn 0;\n}\n\nstatic void ___dma_freep(m_pool_s *mp, m_addr_t m)\n{\n\tm_vtob_s **vbpp, *vbp;\n\tint hc = VTOB_HASH_CODE(m);\n\n\tvbpp = &mp->vtob[hc];\n\twhile (*vbpp && (*vbpp)->vaddr != m)\n\t\tvbpp = &(*vbpp)->next;\n\tif (*vbpp) {\n\t\tvbp = *vbpp;\n\t\t*vbpp = (*vbpp)->next;\n\t\tdma_free_coherent(mp->bush, PAGE_SIZE<<MEMO_PAGE_ORDER,\n\t\t\t\t  (void *)vbp->vaddr, (dma_addr_t)vbp->baddr);\n\t\t__m_free(&mp0, vbp, sizeof(*vbp), \"VTOB\");\n\t\t--mp->nump;\n\t}\n}\n\nstatic inline m_pool_s *___get_dma_pool(m_bush_t bush)\n{\n\tm_pool_s *mp;\n\tfor (mp = mp0.next; mp && mp->bush != bush; mp = mp->next);\n\treturn mp;\n}\n\nstatic m_pool_s *___cre_dma_pool(m_bush_t bush)\n{\n\tm_pool_s *mp;\n\tmp = __m_calloc(&mp0, sizeof(*mp), \"MPOOL\");\n\tif (mp) {\n\t\tmemset(mp, 0, sizeof(*mp));\n\t\tmp->bush = bush;\n\t\tmp->getp = ___dma_getp;\n\t\tmp->freep = ___dma_freep;\n\t\tmp->next = mp0.next;\n\t\tmp0.next = mp;\n\t}\n\treturn mp;\n}\n\nstatic void ___del_dma_pool(m_pool_s *p)\n{\n\tstruct m_pool **pp = &mp0.next;\n\n\twhile (*pp && *pp != p)\n\t\tpp = &(*pp)->next;\n\tif (*pp) {\n\t\t*pp = (*pp)->next;\n\t\t__m_free(&mp0, p, sizeof(*p), \"MPOOL\");\n\t}\n}\n\nstatic void *__m_calloc_dma(m_bush_t bush, int size, char *name)\n{\n\tu_long flags;\n\tstruct m_pool *mp;\n\tvoid *m = NULL;\n\n\tspin_lock_irqsave(&ncr53c8xx_lock, flags);\n\tmp = ___get_dma_pool(bush);\n\tif (!mp)\n\t\tmp = ___cre_dma_pool(bush);\n\tif (mp)\n\t\tm = __m_calloc(mp, size, name);\n\tif (mp && !mp->nump)\n\t\t___del_dma_pool(mp);\n\tspin_unlock_irqrestore(&ncr53c8xx_lock, flags);\n\n\treturn m;\n}\n\nstatic void __m_free_dma(m_bush_t bush, void *m, int size, char *name)\n{\n\tu_long flags;\n\tstruct m_pool *mp;\n\n\tspin_lock_irqsave(&ncr53c8xx_lock, flags);\n\tmp = ___get_dma_pool(bush);\n\tif (mp)\n\t\t__m_free(mp, m, size, name);\n\tif (mp && !mp->nump)\n\t\t___del_dma_pool(mp);\n\tspin_unlock_irqrestore(&ncr53c8xx_lock, flags);\n}\n\nstatic m_addr_t __vtobus(m_bush_t bush, void *m)\n{\n\tu_long flags;\n\tm_pool_s *mp;\n\tint hc = VTOB_HASH_CODE(m);\n\tm_vtob_s *vp = NULL;\n\tm_addr_t a = ((m_addr_t) m) & ~MEMO_CLUSTER_MASK;\n\n\tspin_lock_irqsave(&ncr53c8xx_lock, flags);\n\tmp = ___get_dma_pool(bush);\n\tif (mp) {\n\t\tvp = mp->vtob[hc];\n\t\twhile (vp && (m_addr_t) vp->vaddr != a)\n\t\t\tvp = vp->next;\n\t}\n\tspin_unlock_irqrestore(&ncr53c8xx_lock, flags);\n\treturn vp ? vp->baddr + (((m_addr_t) m) - a) : 0;\n}\n\n#define _m_calloc_dma(np, s, n)\t\t__m_calloc_dma(np->dev, s, n)\n#define _m_free_dma(np, p, s, n)\t__m_free_dma(np->dev, p, s, n)\n#define m_calloc_dma(s, n)\t\t_m_calloc_dma(np, s, n)\n#define m_free_dma(p, s, n)\t\t_m_free_dma(np, p, s, n)\n#define _vtobus(np, p)\t\t\t__vtobus(np->dev, p)\n#define vtobus(p)\t\t\t_vtobus(np, p)\n\n/*\n *  Deal with DMA mapping/unmapping.\n */\n\n/* To keep track of the dma mapping (sg/single) that has been set */\n#define __data_mapped\tSCp.phase\n#define __data_mapping\tSCp.have_data_in\n\nstatic void __unmap_scsi_data(struct device *dev, struct scsi_cmnd *cmd)\n{\n\tswitch(cmd->__data_mapped) {\n\tcase 2:\n\t\tscsi_dma_unmap(cmd);\n\t\tbreak;\n\t}\n\tcmd->__data_mapped = 0;\n}\n\nstatic int __map_scsi_sg_data(struct device *dev, struct scsi_cmnd *cmd)\n{\n\tint use_sg;\n\n\tuse_sg = scsi_dma_map(cmd);\n\tif (!use_sg)\n\t\treturn 0;\n\n\tcmd->__data_mapped = 2;\n\tcmd->__data_mapping = use_sg;\n\n\treturn use_sg;\n}\n\n#define unmap_scsi_data(np, cmd)\t__unmap_scsi_data(np->dev, cmd)\n#define map_scsi_sg_data(np, cmd)\t__map_scsi_sg_data(np->dev, cmd)\n\n/*==========================================================\n**\n**\tDriver setup.\n**\n**\tThis structure is initialized from linux config \n**\toptions. It can be overridden at boot-up by the boot \n**\tcommand line.\n**\n**==========================================================\n*/\nstatic struct ncr_driver_setup\n\tdriver_setup\t\t\t= SCSI_NCR_DRIVER_SETUP;\n\n#ifndef MODULE\n#ifdef\tSCSI_NCR_BOOT_COMMAND_LINE_SUPPORT\nstatic struct ncr_driver_setup\n\tdriver_safe_setup __initdata\t= SCSI_NCR_DRIVER_SAFE_SETUP;\n#endif\n#endif /* !MODULE */\n\n#define initverbose (driver_setup.verbose)\n#define bootverbose (np->verbose)\n\n\n/*===================================================================\n**\n**\tDriver setup from the boot command line\n**\n**===================================================================\n*/\n\n#ifdef MODULE\n#define\tARG_SEP\t' '\n#else\n#define\tARG_SEP\t','\n#endif\n\n#define OPT_TAGS\t\t1\n#define OPT_MASTER_PARITY\t2\n#define OPT_SCSI_PARITY\t\t3\n#define OPT_DISCONNECTION\t4\n#define OPT_SPECIAL_FEATURES\t5\n#define OPT_UNUSED_1\t\t6\n#define OPT_FORCE_SYNC_NEGO\t7\n#define OPT_REVERSE_PROBE\t8\n#define OPT_DEFAULT_SYNC\t9\n#define OPT_VERBOSE\t\t10\n#define OPT_DEBUG\t\t11\n#define OPT_BURST_MAX\t\t12\n#define OPT_LED_PIN\t\t13\n#define OPT_MAX_WIDE\t\t14\n#define OPT_SETTLE_DELAY\t15\n#define OPT_DIFF_SUPPORT\t16\n#define OPT_IRQM\t\t17\n#define OPT_PCI_FIX_UP\t\t18\n#define OPT_BUS_CHECK\t\t19\n#define OPT_OPTIMIZE\t\t20\n#define OPT_RECOVERY\t\t21\n#define OPT_SAFE_SETUP\t\t22\n#define OPT_USE_NVRAM\t\t23\n#define OPT_EXCLUDE\t\t24\n#define OPT_HOST_ID\t\t25\n\n#ifdef SCSI_NCR_IARB_SUPPORT\n#define OPT_IARB\t\t26\n#endif\n\n#ifdef MODULE\n#define\tARG_SEP\t' '\n#else\n#define\tARG_SEP\t','\n#endif\n\n#ifndef MODULE\nstatic char setup_token[] __initdata = \n\t\"tags:\"   \"mpar:\"\n\t\"spar:\"   \"disc:\"\n\t\"specf:\"  \"ultra:\"\n\t\"fsn:\"    \"revprob:\"\n\t\"sync:\"   \"verb:\"\n\t\"debug:\"  \"burst:\"\n\t\"led:\"    \"wide:\"\n\t\"settle:\" \"diff:\"\n\t\"irqm:\"   \"pcifix:\"\n\t\"buschk:\" \"optim:\"\n\t\"recovery:\"\n\t\"safe:\"   \"nvram:\"\n\t\"excl:\"   \"hostid:\"\n#ifdef SCSI_NCR_IARB_SUPPORT\n\t\"iarb:\"\n#endif\n\t;\t/* DONNOT REMOVE THIS ';' */\n\nstatic int __init get_setup_token(char *p)\n{\n\tchar *cur = setup_token;\n\tchar *pc;\n\tint i = 0;\n\n\twhile (cur != NULL && (pc = strchr(cur, ':')) != NULL) {\n\t\t++pc;\n\t\t++i;\n\t\tif (!strncmp(p, cur, pc - cur))\n\t\t\treturn i;\n\t\tcur = pc;\n\t}\n\treturn 0;\n}\n\nstatic int __init sym53c8xx__setup(char *str)\n{\n#ifdef SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT\n\tchar *cur = str;\n\tchar *pc, *pv;\n\tint i, val, c;\n\tint xi = 0;\n\n\twhile (cur != NULL && (pc = strchr(cur, ':')) != NULL) {\n\t\tchar *pe;\n\n\t\tval = 0;\n\t\tpv = pc;\n\t\tc = *++pv;\n\n\t\tif\t(c == 'n')\n\t\t\tval = 0;\n\t\telse if\t(c == 'y')\n\t\t\tval = 1;\n\t\telse\n\t\t\tval = (int) simple_strtoul(pv, &pe, 0);\n\n\t\tswitch (get_setup_token(cur)) {\n\t\tcase OPT_TAGS:\n\t\t\tdriver_setup.default_tags = val;\n\t\t\tif (pe && *pe == '/') {\n\t\t\t\ti = 0;\n\t\t\t\twhile (*pe && *pe != ARG_SEP && \n\t\t\t\t\ti < sizeof(driver_setup.tag_ctrl)-1) {\n\t\t\t\t\tdriver_setup.tag_ctrl[i++] = *pe++;\n\t\t\t\t}\n\t\t\t\tdriver_setup.tag_ctrl[i] = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_MASTER_PARITY:\n\t\t\tdriver_setup.master_parity = val;\n\t\t\tbreak;\n\t\tcase OPT_SCSI_PARITY:\n\t\t\tdriver_setup.scsi_parity = val;\n\t\t\tbreak;\n\t\tcase OPT_DISCONNECTION:\n\t\t\tdriver_setup.disconnection = val;\n\t\t\tbreak;\n\t\tcase OPT_SPECIAL_FEATURES:\n\t\t\tdriver_setup.special_features = val;\n\t\t\tbreak;\n\t\tcase OPT_FORCE_SYNC_NEGO:\n\t\t\tdriver_setup.force_sync_nego = val;\n\t\t\tbreak;\n\t\tcase OPT_REVERSE_PROBE:\n\t\t\tdriver_setup.reverse_probe = val;\n\t\t\tbreak;\n\t\tcase OPT_DEFAULT_SYNC:\n\t\t\tdriver_setup.default_sync = val;\n\t\t\tbreak;\n\t\tcase OPT_VERBOSE:\n\t\t\tdriver_setup.verbose = val;\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\tdriver_setup.debug = val;\n\t\t\tbreak;\n\t\tcase OPT_BURST_MAX:\n\t\t\tdriver_setup.burst_max = val;\n\t\t\tbreak;\n\t\tcase OPT_LED_PIN:\n\t\t\tdriver_setup.led_pin = val;\n\t\t\tbreak;\n\t\tcase OPT_MAX_WIDE:\n\t\t\tdriver_setup.max_wide = val? 1:0;\n\t\t\tbreak;\n\t\tcase OPT_SETTLE_DELAY:\n\t\t\tdriver_setup.settle_delay = val;\n\t\t\tbreak;\n\t\tcase OPT_DIFF_SUPPORT:\n\t\t\tdriver_setup.diff_support = val;\n\t\t\tbreak;\n\t\tcase OPT_IRQM:\n\t\t\tdriver_setup.irqm = val;\n\t\t\tbreak;\n\t\tcase OPT_PCI_FIX_UP:\n\t\t\tdriver_setup.pci_fix_up\t= val;\n\t\t\tbreak;\n\t\tcase OPT_BUS_CHECK:\n\t\t\tdriver_setup.bus_check = val;\n\t\t\tbreak;\n\t\tcase OPT_OPTIMIZE:\n\t\t\tdriver_setup.optimize = val;\n\t\t\tbreak;\n\t\tcase OPT_RECOVERY:\n\t\t\tdriver_setup.recovery = val;\n\t\t\tbreak;\n\t\tcase OPT_USE_NVRAM:\n\t\t\tdriver_setup.use_nvram = val;\n\t\t\tbreak;\n\t\tcase OPT_SAFE_SETUP:\n\t\t\tmemcpy(&driver_setup, &driver_safe_setup,\n\t\t\t\tsizeof(driver_setup));\n\t\t\tbreak;\n\t\tcase OPT_EXCLUDE:\n\t\t\tif (xi < SCSI_NCR_MAX_EXCLUDES)\n\t\t\t\tdriver_setup.excludes[xi++] = val;\n\t\t\tbreak;\n\t\tcase OPT_HOST_ID:\n\t\t\tdriver_setup.host_id = val;\n\t\t\tbreak;\n#ifdef SCSI_NCR_IARB_SUPPORT\n\t\tcase OPT_IARB:\n\t\t\tdriver_setup.iarb = val;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tprintk(\"sym53c8xx_setup: unexpected boot option '%.*s' ignored\\n\", (int)(pc-cur+1), cur);\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((cur = strchr(cur, ARG_SEP)) != NULL)\n\t\t\t++cur;\n\t}\n#endif /* SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT */\n\treturn 1;\n}\n#endif /* !MODULE */\n\n/*===================================================================\n**\n**\tGet device queue depth from boot command line.\n**\n**===================================================================\n*/\n#define DEF_DEPTH\t(driver_setup.default_tags)\n#define ALL_TARGETS\t-2\n#define NO_TARGET\t-1\n#define ALL_LUNS\t-2\n#define NO_LUN\t\t-1\n\nstatic int device_queue_depth(int unit, int target, int lun)\n{\n\tint c, h, t, u, v;\n\tchar *p = driver_setup.tag_ctrl;\n\tchar *ep;\n\n\th = -1;\n\tt = NO_TARGET;\n\tu = NO_LUN;\n\twhile ((c = *p++) != 0) {\n\t\tv = simple_strtoul(p, &ep, 0);\n\t\tswitch(c) {\n\t\tcase '/':\n\t\t\t++h;\n\t\t\tt = ALL_TARGETS;\n\t\t\tu = ALL_LUNS;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (t != target)\n\t\t\t\tt = (target == v) ? v : NO_TARGET;\n\t\t\tu = ALL_LUNS;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tif (u != lun)\n\t\t\t\tu = (lun == v) ? v : NO_LUN;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tif (h == unit &&\n\t\t\t\t(t == ALL_TARGETS || t == target) &&\n\t\t\t\t(u == ALL_LUNS    || u == lun))\n\t\t\t\treturn v;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tt = ALL_TARGETS;\n\t\t\tu = ALL_LUNS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tp = ep;\n\t}\n\treturn DEF_DEPTH;\n}\n\n\n/*==========================================================\n**\n**\tThe CCB done queue uses an array of CCB virtual \n**\taddresses. Empty entries are flagged using the bogus \n**\tvirtual address 0xffffffff.\n**\n**\tSince PCI ensures that only aligned DWORDs are accessed \n**\tatomically, 64 bit little-endian architecture requires \n**\tto test the high order DWORD of the entry to determine \n**\tif it is empty or valid.\n**\n**\tBTW, I will make things differently as soon as I will \n**\thave a better idea, but this is simple and should work.\n**\n**==========================================================\n*/\n \n#define SCSI_NCR_CCB_DONE_SUPPORT\n#ifdef  SCSI_NCR_CCB_DONE_SUPPORT\n\n#define MAX_DONE 24\n#define CCB_DONE_EMPTY 0xffffffffUL\n\n/* All 32 bit architectures */\n#if BITS_PER_LONG == 32\n#define CCB_DONE_VALID(cp)  (((u_long) cp) != CCB_DONE_EMPTY)\n\n/* All > 32 bit (64 bit) architectures regardless endian-ness */\n#else\n#define CCB_DONE_VALID(cp)  \\\n\t((((u_long) cp) & 0xffffffff00000000ul) && \t\\\n\t (((u_long) cp) & 0xfffffffful) != CCB_DONE_EMPTY)\n#endif\n\n#endif /* SCSI_NCR_CCB_DONE_SUPPORT */\n\n/*==========================================================\n**\n**\tConfiguration and Debugging\n**\n**==========================================================\n*/\n\n/*\n**    SCSI address of this device.\n**    The boot routines should have set it.\n**    If not, use this.\n*/\n\n#ifndef SCSI_NCR_MYADDR\n#define SCSI_NCR_MYADDR      (7)\n#endif\n\n/*\n**    The maximum number of tags per logic unit.\n**    Used only for disk devices that support tags.\n*/\n\n#ifndef SCSI_NCR_MAX_TAGS\n#define SCSI_NCR_MAX_TAGS    (8)\n#endif\n\n/*\n**    TAGS are actually limited to 64 tags/lun.\n**    We need to deal with power of 2, for alignment constraints.\n*/\n#if\tSCSI_NCR_MAX_TAGS > 64\n#define\tMAX_TAGS (64)\n#else\n#define\tMAX_TAGS SCSI_NCR_MAX_TAGS\n#endif\n\n#define NO_TAG\t(255)\n\n/*\n**\tChoose appropriate type for tag bitmap.\n*/\n#if\tMAX_TAGS > 32\ntypedef u64 tagmap_t;\n#else\ntypedef u32 tagmap_t;\n#endif\n\n/*\n**    Number of targets supported by the driver.\n**    n permits target numbers 0..n-1.\n**    Default is 16, meaning targets #0..#15.\n**    #7 .. is myself.\n*/\n\n#ifdef SCSI_NCR_MAX_TARGET\n#define MAX_TARGET  (SCSI_NCR_MAX_TARGET)\n#else\n#define MAX_TARGET  (16)\n#endif\n\n/*\n**    Number of logic units supported by the driver.\n**    n enables logic unit numbers 0..n-1.\n**    The common SCSI devices require only\n**    one lun, so take 1 as the default.\n*/\n\n#ifdef SCSI_NCR_MAX_LUN\n#define MAX_LUN    SCSI_NCR_MAX_LUN\n#else\n#define MAX_LUN    (1)\n#endif\n\n/*\n**    Asynchronous pre-scaler (ns). Shall be 40\n*/\n \n#ifndef SCSI_NCR_MIN_ASYNC\n#define SCSI_NCR_MIN_ASYNC (40)\n#endif\n\n/*\n**    The maximum number of jobs scheduled for starting.\n**    There should be one slot per target, and one slot\n**    for each tag of each target in use.\n**    The calculation below is actually quite silly ...\n*/\n\n#ifdef SCSI_NCR_CAN_QUEUE\n#define MAX_START   (SCSI_NCR_CAN_QUEUE + 4)\n#else\n#define MAX_START   (MAX_TARGET + 7 * MAX_TAGS)\n#endif\n\n/*\n**   We limit the max number of pending IO to 250.\n**   since we donnot want to allocate more than 1 \n**   PAGE for 'scripth'.\n*/\n#if\tMAX_START > 250\n#undef\tMAX_START\n#define\tMAX_START 250\n#endif\n\n/*\n**    The maximum number of segments a transfer is split into.\n**    We support up to 127 segments for both read and write.\n**    The data scripts are broken into 2 sub-scripts.\n**    80 (MAX_SCATTERL) segments are moved from a sub-script\n**    in on-chip RAM. This makes data transfers shorter than \n**    80k (assuming 1k fs) as fast as possible.\n*/\n\n#define MAX_SCATTER (SCSI_NCR_MAX_SCATTER)\n\n#if (MAX_SCATTER > 80)\n#define MAX_SCATTERL\t80\n#define\tMAX_SCATTERH\t(MAX_SCATTER - MAX_SCATTERL)\n#else\n#define MAX_SCATTERL\t(MAX_SCATTER-1)\n#define\tMAX_SCATTERH\t1\n#endif\n\n/*\n**\tother\n*/\n\n#define NCR_SNOOP_TIMEOUT (1000000)\n\n/*\n**\tOther definitions\n*/\n\n#define initverbose (driver_setup.verbose)\n#define bootverbose (np->verbose)\n\n/*==========================================================\n**\n**\tCommand control block states.\n**\n**==========================================================\n*/\n\n#define HS_IDLE\t\t(0)\n#define HS_BUSY\t\t(1)\n#define HS_NEGOTIATE\t(2)\t/* sync/wide data transfer*/\n#define HS_DISCONNECT\t(3)\t/* Disconnected by target */\n\n#define HS_DONEMASK\t(0x80)\n#define HS_COMPLETE\t(4|HS_DONEMASK)\n#define HS_SEL_TIMEOUT\t(5|HS_DONEMASK)\t/* Selection timeout      */\n#define HS_RESET\t(6|HS_DONEMASK)\t/* SCSI reset\t          */\n#define HS_ABORTED\t(7|HS_DONEMASK)\t/* Transfer aborted       */\n#define HS_TIMEOUT\t(8|HS_DONEMASK)\t/* Software timeout       */\n#define HS_FAIL\t\t(9|HS_DONEMASK)\t/* SCSI or PCI bus errors */\n#define HS_UNEXPECTED\t(10|HS_DONEMASK)/* Unexpected disconnect  */\n\n/*\n**\tInvalid host status values used by the SCRIPTS processor \n**\twhen the nexus is not fully identified.\n**\tShall never appear in a CCB.\n*/\n\n#define HS_INVALMASK\t(0x40)\n#define\tHS_SELECTING\t(0|HS_INVALMASK)\n#define\tHS_IN_RESELECT\t(1|HS_INVALMASK)\n#define\tHS_STARTING\t(2|HS_INVALMASK)\n\n/*\n**\tFlags set by the SCRIPT processor for commands \n**\tthat have been skipped.\n*/\n#define HS_SKIPMASK\t(0x20)\n\n/*==========================================================\n**\n**\tSoftware Interrupt Codes\n**\n**==========================================================\n*/\n\n#define\tSIR_BAD_STATUS\t\t(1)\n#define\tSIR_XXXXXXXXXX\t\t(2)\n#define\tSIR_NEGO_SYNC\t\t(3)\n#define\tSIR_NEGO_WIDE\t\t(4)\n#define\tSIR_NEGO_FAILED\t\t(5)\n#define\tSIR_NEGO_PROTO\t\t(6)\n#define\tSIR_REJECT_RECEIVED\t(7)\n#define\tSIR_REJECT_SENT\t\t(8)\n#define\tSIR_IGN_RESIDUE\t\t(9)\n#define\tSIR_MISSING_SAVE\t(10)\n#define\tSIR_RESEL_NO_MSG_IN\t(11)\n#define\tSIR_RESEL_NO_IDENTIFY\t(12)\n#define\tSIR_RESEL_BAD_LUN\t(13)\n#define\tSIR_RESEL_BAD_TARGET\t(14)\n#define\tSIR_RESEL_BAD_I_T_L\t(15)\n#define\tSIR_RESEL_BAD_I_T_L_Q\t(16)\n#define\tSIR_DONE_OVERFLOW\t(17)\n#define\tSIR_INTFLY\t\t(18)\n#define\tSIR_MAX\t\t\t(18)\n\n/*==========================================================\n**\n**\tExtended error codes.\n**\txerr_status field of struct ccb.\n**\n**==========================================================\n*/\n\n#define\tXE_OK\t\t(0)\n#define\tXE_EXTRA_DATA\t(1)\t/* unexpected data phase */\n#define\tXE_BAD_PHASE\t(2)\t/* illegal phase (4/5)   */\n\n/*==========================================================\n**\n**\tNegotiation status.\n**\tnego_status field\tof struct ccb.\n**\n**==========================================================\n*/\n\n#define NS_NOCHANGE\t(0)\n#define NS_SYNC\t\t(1)\n#define NS_WIDE\t\t(2)\n#define NS_PPR\t\t(4)\n\n/*==========================================================\n**\n**\tMisc.\n**\n**==========================================================\n*/\n\n#define CCB_MAGIC\t(0xf2691ad2)\n\n/*==========================================================\n**\n**\tDeclaration of structs.\n**\n**==========================================================\n*/\n\nstatic struct scsi_transport_template *ncr53c8xx_transport_template = NULL;\n\nstruct tcb;\nstruct lcb;\nstruct ccb;\nstruct ncb;\nstruct script;\n\nstruct link {\n\tncrcmd\tl_cmd;\n\tncrcmd\tl_paddr;\n};\n\nstruct\tusrcmd {\n\tu_long\ttarget;\n\tu_long\tlun;\n\tu_long\tdata;\n\tu_long\tcmd;\n};\n\n#define UC_SETSYNC      10\n#define UC_SETTAGS\t11\n#define UC_SETDEBUG\t12\n#define UC_SETORDER\t13\n#define UC_SETWIDE\t14\n#define UC_SETFLAG\t15\n#define UC_SETVERBOSE\t17\n\n#define\tUF_TRACE\t(0x01)\n#define\tUF_NODISC\t(0x02)\n#define\tUF_NOSCAN\t(0x04)\n\n/*========================================================================\n**\n**\tDeclaration of structs:\t\ttarget control block\n**\n**========================================================================\n*/\nstruct tcb {\n\t/*----------------------------------------------------------------\n\t**\tDuring reselection the ncr jumps to this point with SFBR \n\t**\tset to the encoded target number with bit 7 set.\n\t**\tif it's not this target, jump to the next.\n\t**\n\t**\tJUMP  IF (SFBR != #target#), @(next tcb)\n\t**----------------------------------------------------------------\n\t*/\n\tstruct link   jump_tcb;\n\n\t/*----------------------------------------------------------------\n\t**\tLoad the actual values for the sxfer and the scntl3\n\t**\tregister (sync/wide mode).\n\t**\n\t**\tSCR_COPY (1), @(sval field of this tcb), @(sxfer  register)\n\t**\tSCR_COPY (1), @(wval field of this tcb), @(scntl3 register)\n\t**----------------------------------------------------------------\n\t*/\n\tncrcmd\tgetscr[6];\n\n\t/*----------------------------------------------------------------\n\t**\tGet the IDENTIFY message and load the LUN to SFBR.\n\t**\n\t**\tCALL, <RESEL_LUN>\n\t**----------------------------------------------------------------\n\t*/\n\tstruct link   call_lun;\n\n\t/*----------------------------------------------------------------\n\t**\tNow look for the right lun.\n\t**\n\t**\tFor i = 0 to 3\n\t**\t\tSCR_JUMP ^ IFTRUE(MASK(i, 3)), @(first lcb mod. i)\n\t**\n\t**\tRecent chips will prefetch the 4 JUMPS using only 1 burst.\n\t**\tIt is kind of hashcoding.\n\t**----------------------------------------------------------------\n\t*/\n\tstruct link     jump_lcb[4];\t/* JUMPs for reselection\t*/\n\tstruct lcb *\tlp[MAX_LUN];\t/* The lcb's of this tcb\t*/\n\n\t/*----------------------------------------------------------------\n\t**\tPointer to the ccb used for negotiation.\n\t**\tPrevent from starting a negotiation for all queued commands \n\t**\twhen tagged command queuing is enabled.\n\t**----------------------------------------------------------------\n\t*/\n\tstruct ccb *   nego_cp;\n\n\t/*----------------------------------------------------------------\n\t**\tstatistical data\n\t**----------------------------------------------------------------\n\t*/\n\tu_long\ttransfers;\n\tu_long\tbytes;\n\n\t/*----------------------------------------------------------------\n\t**\tnegotiation of wide and synch transfer and device quirks.\n\t**----------------------------------------------------------------\n\t*/\n#ifdef SCSI_NCR_BIG_ENDIAN\n/*0*/\tu16\tperiod;\n/*2*/\tu_char\tsval;\n/*3*/\tu_char\tminsync;\n/*0*/\tu_char\twval;\n/*1*/\tu_char\twidedone;\n/*2*/\tu_char\tquirks;\n/*3*/\tu_char\tmaxoffs;\n#else\n/*0*/\tu_char\tminsync;\n/*1*/\tu_char\tsval;\n/*2*/\tu16\tperiod;\n/*0*/\tu_char\tmaxoffs;\n/*1*/\tu_char\tquirks;\n/*2*/\tu_char\twidedone;\n/*3*/\tu_char\twval;\n#endif\n\n\t/* User settable limits and options.  */\n\tu_char\tusrsync;\n\tu_char\tusrwide;\n\tu_char\tusrtags;\n\tu_char\tusrflag;\n\tstruct scsi_target *starget;\n};\n\n/*========================================================================\n**\n**\tDeclaration of structs:\t\tlun control block\n**\n**========================================================================\n*/\nstruct lcb {\n\t/*----------------------------------------------------------------\n\t**\tDuring reselection the ncr jumps to this point\n\t**\twith SFBR set to the \"Identify\" message.\n\t**\tif it's not this lun, jump to the next.\n\t**\n\t**\tJUMP  IF (SFBR != #lun#), @(next lcb of this target)\n\t**\n\t**\tIt is this lun. Load TEMP with the nexus jumps table \n\t**\taddress and jump to RESEL_TAG (or RESEL_NOTAG).\n\t**\n\t**\t\tSCR_COPY (4), p_jump_ccb, TEMP,\n\t**\t\tSCR_JUMP, <RESEL_TAG>\n\t**----------------------------------------------------------------\n\t*/\n\tstruct link\tjump_lcb;\n\tncrcmd\t\tload_jump_ccb[3];\n\tstruct link\tjump_tag;\n\tncrcmd\t\tp_jump_ccb;\t/* Jump table bus address\t*/\n\n\t/*----------------------------------------------------------------\n\t**\tJump table used by the script processor to directly jump \n\t**\tto the CCB corresponding to the reselected nexus.\n\t**\tAddress is allocated on 256 bytes boundary in order to \n\t**\tallow 8 bit calculation of the tag jump entry for up to \n\t**\t64 possible tags.\n\t**----------------------------------------------------------------\n\t*/\n\tu32\t\tjump_ccb_0;\t/* Default table if no tags\t*/\n\tu32\t\t*jump_ccb;\t/* Virtual address\t\t*/\n\n\t/*----------------------------------------------------------------\n\t**\tCCB queue management.\n\t**----------------------------------------------------------------\n\t*/\n\tstruct list_head free_ccbq;\t/* Queue of available CCBs\t*/\n\tstruct list_head busy_ccbq;\t/* Queue of busy CCBs\t\t*/\n\tstruct list_head wait_ccbq;\t/* Queue of waiting for IO CCBs\t*/\n\tstruct list_head skip_ccbq;\t/* Queue of skipped CCBs\t*/\n\tu_char\t\tactccbs;\t/* Number of allocated CCBs\t*/\n\tu_char\t\tbusyccbs;\t/* CCBs busy for this lun\t*/\n\tu_char\t\tqueuedccbs;\t/* CCBs queued to the controller*/\n\tu_char\t\tqueuedepth;\t/* Queue depth for this lun\t*/\n\tu_char\t\tscdev_depth;\t/* SCSI device queue depth\t*/\n\tu_char\t\tmaxnxs;\t\t/* Max possible nexuses\t\t*/\n\n\t/*----------------------------------------------------------------\n\t**\tControl of tagged command queuing.\n\t**\tTags allocation is performed using a circular buffer.\n\t**\tThis avoids using a loop for tag allocation.\n\t**----------------------------------------------------------------\n\t*/\n\tu_char\t\tia_tag;\t\t/* Allocation index\t\t*/\n\tu_char\t\tif_tag;\t\t/* Freeing index\t\t*/\n\tu_char cb_tags[MAX_TAGS];\t/* Circular tags buffer\t*/\n\tu_char\t\tusetags;\t/* Command queuing is active\t*/\n\tu_char\t\tmaxtags;\t/* Max nr of tags asked by user\t*/\n\tu_char\t\tnumtags;\t/* Current number of tags\t*/\n\n\t/*----------------------------------------------------------------\n\t**\tQUEUE FULL control and ORDERED tag control.\n\t**----------------------------------------------------------------\n\t*/\n\t/*----------------------------------------------------------------\n\t**\tQUEUE FULL and ORDERED tag control.\n\t**----------------------------------------------------------------\n\t*/\n\tu16\t\tnum_good;\t/* Nr of GOOD since QUEUE FULL\t*/\n\ttagmap_t\ttags_umap;\t/* Used tags bitmap\t\t*/\n\ttagmap_t\ttags_smap;\t/* Tags in use at 'tag_stime'\t*/\n\tu_long\t\ttags_stime;\t/* Last time we set smap=umap\t*/\n\tstruct ccb *\theld_ccb;\t/* CCB held for QUEUE FULL\t*/\n};\n\n/*========================================================================\n**\n**      Declaration of structs:     the launch script.\n**\n**========================================================================\n**\n**\tIt is part of the CCB and is called by the scripts processor to \n**\tstart or restart the data structure (nexus).\n**\tThis 6 DWORDs mini script makes use of prefetching.\n**\n**------------------------------------------------------------------------\n*/\nstruct launch {\n\t/*----------------------------------------------------------------\n\t**\tSCR_COPY(4),\t@(p_phys), @(dsa register)\n\t**\tSCR_JUMP,\t@(scheduler_point)\n\t**----------------------------------------------------------------\n\t*/\n\tncrcmd\t\tsetup_dsa[3];\t/* Copy 'phys' address to dsa\t*/\n\tstruct link\tschedule;\t/* Jump to scheduler point\t*/\n\tncrcmd\t\tp_phys;\t\t/* 'phys' header bus address\t*/\n};\n\n/*========================================================================\n**\n**      Declaration of structs:     global HEADER.\n**\n**========================================================================\n**\n**\tThis substructure is copied from the ccb to a global address after \n**\tselection (or reselection) and copied back before disconnect.\n**\n**\tThese fields are accessible to the script processor.\n**\n**------------------------------------------------------------------------\n*/\n\nstruct head {\n\t/*----------------------------------------------------------------\n\t**\tSaved data pointer.\n\t**\tPoints to the position in the script responsible for the\n\t**\tactual transfer transfer of data.\n\t**\tIt's written after reception of a SAVE_DATA_POINTER message.\n\t**\tThe goalpointer points after the last transfer command.\n\t**----------------------------------------------------------------\n\t*/\n\tu32\t\tsavep;\n\tu32\t\tlastp;\n\tu32\t\tgoalp;\n\n\t/*----------------------------------------------------------------\n\t**\tAlternate data pointer.\n\t**\tThey are copied back to savep/lastp/goalp by the SCRIPTS \n\t**\twhen the direction is unknown and the device claims data out.\n\t**----------------------------------------------------------------\n\t*/\n\tu32\t\twlastp;\n\tu32\t\twgoalp;\n\n\t/*----------------------------------------------------------------\n\t**\tThe virtual address of the ccb containing this header.\n\t**----------------------------------------------------------------\n\t*/\n\tstruct ccb *\tcp;\n\n\t/*----------------------------------------------------------------\n\t**\tStatus fields.\n\t**----------------------------------------------------------------\n\t*/\n\tu_char\t\tscr_st[4];\t/* script status\t\t*/\n\tu_char\t\tstatus[4];\t/* host status. must be the \t*/\n\t\t\t\t\t/*  last DWORD of the header.\t*/\n};\n\n/*\n**\tThe status bytes are used by the host and the script processor.\n**\n**\tThe byte corresponding to the host_status must be stored in the \n**\tlast DWORD of the CCB header since it is used for command \n**\tcompletion (ncr_wakeup()). Doing so, we are sure that the header \n**\thas been entirely copied back to the CCB when the host_status is \n**\tseen complete by the CPU.\n**\n**\tThe last four bytes (status[4]) are copied to the scratchb register\n**\t(declared as scr0..scr3 in ncr_reg.h) just after the select/reselect,\n**\tand copied back just after disconnecting.\n**\tInside the script the XX_REG are used.\n**\n**\tThe first four bytes (scr_st[4]) are used inside the script by \n**\t\"COPY\" commands.\n**\tBecause source and destination must have the same alignment\n**\tin a DWORD, the fields HAVE to be at the chosen offsets.\n**\t\txerr_st\t\t0\t(0x34)\tscratcha\n**\t\tsync_st\t\t1\t(0x05)\tsxfer\n**\t\twide_st\t\t3\t(0x03)\tscntl3\n*/\n\n/*\n**\tLast four bytes (script)\n*/\n#define  QU_REG\tscr0\n#define  HS_REG\tscr1\n#define  HS_PRT\tnc_scr1\n#define  SS_REG\tscr2\n#define  SS_PRT\tnc_scr2\n#define  PS_REG\tscr3\n\n/*\n**\tLast four bytes (host)\n*/\n#ifdef SCSI_NCR_BIG_ENDIAN\n#define  actualquirks  phys.header.status[3]\n#define  host_status   phys.header.status[2]\n#define  scsi_status   phys.header.status[1]\n#define  parity_status phys.header.status[0]\n#else\n#define  actualquirks  phys.header.status[0]\n#define  host_status   phys.header.status[1]\n#define  scsi_status   phys.header.status[2]\n#define  parity_status phys.header.status[3]\n#endif\n\n/*\n**\tFirst four bytes (script)\n*/\n#define  xerr_st       header.scr_st[0]\n#define  sync_st       header.scr_st[1]\n#define  nego_st       header.scr_st[2]\n#define  wide_st       header.scr_st[3]\n\n/*\n**\tFirst four bytes (host)\n*/\n#define  xerr_status   phys.xerr_st\n#define  nego_status   phys.nego_st\n\n#if 0\n#define  sync_status   phys.sync_st\n#define  wide_status   phys.wide_st\n#endif\n\n/*==========================================================\n**\n**      Declaration of structs:     Data structure block\n**\n**==========================================================\n**\n**\tDuring execution of a ccb by the script processor,\n**\tthe DSA (data structure address) register points\n**\tto this substructure of the ccb.\n**\tThis substructure contains the header with\n**\tthe script-processor-changeable data and\n**\tdata blocks for the indirect move commands.\n**\n**----------------------------------------------------------\n*/\n\nstruct dsb {\n\n\t/*\n\t**\tHeader.\n\t*/\n\n\tstruct head\theader;\n\n\t/*\n\t**\tTable data for Script\n\t*/\n\n\tstruct scr_tblsel  select;\n\tstruct scr_tblmove smsg  ;\n\tstruct scr_tblmove cmd   ;\n\tstruct scr_tblmove sense ;\n\tstruct scr_tblmove data[MAX_SCATTER];\n};\n\n\n/*========================================================================\n**\n**      Declaration of structs:     Command control block.\n**\n**========================================================================\n*/\nstruct ccb {\n\t/*----------------------------------------------------------------\n\t**\tThis is the data structure which is pointed by the DSA \n\t**\tregister when it is executed by the script processor.\n\t**\tIt must be the first entry because it contains the header \n\t**\tas first entry that must be cache line aligned.\n\t**----------------------------------------------------------------\n\t*/\n\tstruct dsb\tphys;\n\n\t/*----------------------------------------------------------------\n\t**\tMini-script used at CCB execution start-up.\n\t**\tLoad the DSA with the data structure address (phys) and \n\t**\tjump to SELECT. Jump to CANCEL if CCB is to be canceled.\n\t**----------------------------------------------------------------\n\t*/\n\tstruct launch\tstart;\n\n\t/*----------------------------------------------------------------\n\t**\tMini-script used at CCB relection to restart the nexus.\n\t**\tLoad the DSA with the data structure address (phys) and \n\t**\tjump to RESEL_DSA. Jump to ABORT if CCB is to be aborted.\n\t**----------------------------------------------------------------\n\t*/\n\tstruct launch\trestart;\n\n\t/*----------------------------------------------------------------\n\t**\tIf a data transfer phase is terminated too early\n\t**\t(after reception of a message (i.e. DISCONNECT)),\n\t**\twe have to prepare a mini script to transfer\n\t**\tthe rest of the data.\n\t**----------------------------------------------------------------\n\t*/\n\tncrcmd\t\tpatch[8];\n\n\t/*----------------------------------------------------------------\n\t**\tThe general SCSI driver provides a\n\t**\tpointer to a control block.\n\t**----------------------------------------------------------------\n\t*/\n\tstruct scsi_cmnd\t*cmd;\t\t/* SCSI command \t\t*/\n\tu_char\t\tcdb_buf[16];\t/* Copy of CDB\t\t\t*/\n\tu_char\t\tsense_buf[64];\n\tint\t\tdata_len;\t/* Total data length\t\t*/\n\n\t/*----------------------------------------------------------------\n\t**\tMessage areas.\n\t**\tWe prepare a message to be sent after selection.\n\t**\tWe may use a second one if the command is rescheduled \n\t**\tdue to GETCC or QFULL.\n\t**      Contents are IDENTIFY and SIMPLE_TAG.\n\t**\tWhile negotiating sync or wide transfer,\n\t**\ta SDTR or WDTR message is appended.\n\t**----------------------------------------------------------------\n\t*/\n\tu_char\t\tscsi_smsg [8];\n\tu_char\t\tscsi_smsg2[8];\n\n\t/*----------------------------------------------------------------\n\t**\tOther fields.\n\t**----------------------------------------------------------------\n\t*/\n\tu_long\t\tp_ccb;\t\t/* BUS address of this CCB\t*/\n\tu_char\t\tsensecmd[6];\t/* Sense command\t\t*/\n\tu_char\t\ttag;\t\t/* Tag for this transfer\t*/\n\t\t\t\t\t/*  255 means no tag\t\t*/\n\tu_char\t\ttarget;\n\tu_char\t\tlun;\n\tu_char\t\tqueued;\n\tu_char\t\tauto_sense;\n\tstruct ccb *\tlink_ccb;\t/* Host adapter CCB chain\t*/\n\tstruct list_head link_ccbq;\t/* Link to unit CCB queue\t*/\n\tu32\t\tstartp;\t\t/* Initial data pointer\t\t*/\n\tu_long\t\tmagic;\t\t/* Free / busy  CCB flag\t*/\n};\n\n#define CCB_PHYS(cp,lbl)\t(cp->p_ccb + offsetof(struct ccb, lbl))\n\n\n/*========================================================================\n**\n**      Declaration of structs:     NCR device descriptor\n**\n**========================================================================\n*/\nstruct ncb {\n\t/*----------------------------------------------------------------\n\t**\tThe global header.\n\t**\tIt is accessible to both the host and the script processor.\n\t**\tMust be cache line size aligned (32 for x86) in order to \n\t**\tallow cache line bursting when it is copied to/from CCB.\n\t**----------------------------------------------------------------\n\t*/\n\tstruct head     header;\n\n\t/*----------------------------------------------------------------\n\t**\tCCBs management queues.\n\t**----------------------------------------------------------------\n\t*/\n\tstruct scsi_cmnd\t*waiting_list;\t/* Commands waiting for a CCB\t*/\n\t\t\t\t\t/*  when lcb is not allocated.\t*/\n\tstruct scsi_cmnd\t*done_list;\t/* Commands waiting for done()  */\n\t\t\t\t\t/* callback to be invoked.      */ \n\tspinlock_t\tsmp_lock;\t/* Lock for SMP threading       */\n\n\t/*----------------------------------------------------------------\n\t**\tChip and controller identification.\n\t**----------------------------------------------------------------\n\t*/\n\tint\t\tunit;\t\t/* Unit number\t\t\t*/\n\tchar\t\tinst_name[16];\t/* ncb instance name\t\t*/\n\n\t/*----------------------------------------------------------------\n\t**\tInitial value of some IO register bits.\n\t**\tThese values are assumed to have been set by BIOS, and may \n\t**\tbe used for probing adapter implementation differences.\n\t**----------------------------------------------------------------\n\t*/\n\tu_char\tsv_scntl0, sv_scntl3, sv_dmode, sv_dcntl, sv_ctest0, sv_ctest3,\n\t\tsv_ctest4, sv_ctest5, sv_gpcntl, sv_stest2, sv_stest4;\n\n\t/*----------------------------------------------------------------\n\t**\tActual initial value of IO register bits used by the \n\t**\tdriver. They are loaded at initialisation according to  \n\t**\tfeatures that are to be enabled.\n\t**----------------------------------------------------------------\n\t*/\n\tu_char\trv_scntl0, rv_scntl3, rv_dmode, rv_dcntl, rv_ctest0, rv_ctest3,\n\t\trv_ctest4, rv_ctest5, rv_stest2;\n\n\t/*----------------------------------------------------------------\n\t**\tTargets management.\n\t**\tDuring reselection the ncr jumps to jump_tcb.\n\t**\tThe SFBR register is loaded with the encoded target id.\n\t**\tFor i = 0 to 3\n\t**\t\tSCR_JUMP ^ IFTRUE(MASK(i, 3)), @(next tcb mod. i)\n\t**\n\t**\tRecent chips will prefetch the 4 JUMPS using only 1 burst.\n\t**\tIt is kind of hashcoding.\n\t**----------------------------------------------------------------\n\t*/\n\tstruct link     jump_tcb[4];\t/* JUMPs for reselection\t*/\n\tstruct tcb  target[MAX_TARGET];\t/* Target data\t\t\t*/\n\n\t/*----------------------------------------------------------------\n\t**\tVirtual and physical bus addresses of the chip.\n\t**----------------------------------------------------------------\n\t*/\n\tvoid __iomem *vaddr;\t\t/* Virtual and bus address of\t*/\n\tunsigned long\tpaddr;\t\t/*  chip's IO registers.\t*/\n\tunsigned long\tpaddr2;\t\t/* On-chip RAM bus address.\t*/\n\tvolatile\t\t\t/* Pointer to volatile for \t*/\n\tstruct ncr_reg\t__iomem *reg;\t/*  memory mapped IO.\t\t*/\n\n\t/*----------------------------------------------------------------\n\t**\tSCRIPTS virtual and physical bus addresses.\n\t**\t'script'  is loaded in the on-chip RAM if present.\n\t**\t'scripth' stays in main memory.\n\t**----------------------------------------------------------------\n\t*/\n\tstruct script\t*script0;\t/* Copies of script and scripth\t*/\n\tstruct scripth\t*scripth0;\t/*  relocated for this ncb.\t*/\n\tstruct scripth\t*scripth;\t/* Actual scripth virt. address\t*/\n\tu_long\t\tp_script;\t/* Actual script and scripth\t*/\n\tu_long\t\tp_scripth;\t/*  bus addresses.\t\t*/\n\n\t/*----------------------------------------------------------------\n\t**\tGeneral controller parameters and configuration.\n\t**----------------------------------------------------------------\n\t*/\n\tstruct device\t*dev;\n\tu_char\t\trevision_id;\t/* PCI device revision id\t*/\n\tu32\t\tirq;\t\t/* IRQ level\t\t\t*/\n\tu32\t\tfeatures;\t/* Chip features map\t\t*/\n\tu_char\t\tmyaddr;\t\t/* SCSI id of the adapter\t*/\n\tu_char\t\tmaxburst;\t/* log base 2 of dwords burst\t*/\n\tu_char\t\tmaxwide;\t/* Maximum transfer width\t*/\n\tu_char\t\tminsync;\t/* Minimum sync period factor\t*/\n\tu_char\t\tmaxsync;\t/* Maximum sync period factor\t*/\n\tu_char\t\tmaxoffs;\t/* Max scsi offset\t\t*/\n\tu_char\t\tmultiplier;\t/* Clock multiplier (1,2,4)\t*/\n\tu_char\t\tclock_divn;\t/* Number of clock divisors\t*/\n\tu_long\t\tclock_khz;\t/* SCSI clock frequency in KHz\t*/\n\n\t/*----------------------------------------------------------------\n\t**\tStart queue management.\n\t**\tIt is filled up by the host processor and accessed by the \n\t**\tSCRIPTS processor in order to start SCSI commands.\n\t**----------------------------------------------------------------\n\t*/\n\tu16\t\tsqueueput;\t/* Next free slot of the queue\t*/\n\tu16\t\tactccbs;\t/* Number of allocated CCBs\t*/\n\tu16\t\tqueuedccbs;\t/* Number of CCBs in start queue*/\n\tu16\t\tqueuedepth;\t/* Start queue depth\t\t*/\n\n\t/*----------------------------------------------------------------\n\t**\tTimeout handler.\n\t**----------------------------------------------------------------\n\t*/\n\tstruct timer_list timer;\t/* Timer handler link header\t*/\n\tu_long\t\tlasttime;\n\tu_long\t\tsettle_time;\t/* Resetting the SCSI BUS\t*/\n\n\t/*----------------------------------------------------------------\n\t**\tDebugging and profiling.\n\t**----------------------------------------------------------------\n\t*/\n\tstruct ncr_reg\tregdump;\t/* Register dump\t\t*/\n\tu_long\t\tregtime;\t/* Time it has been done\t*/\n\n\t/*----------------------------------------------------------------\n\t**\tMiscellaneous buffers accessed by the scripts-processor.\n\t**\tThey shall be DWORD aligned, because they may be read or \n\t**\twritten with a SCR_COPY script command.\n\t**----------------------------------------------------------------\n\t*/\n\tu_char\t\tmsgout[8];\t/* Buffer for MESSAGE OUT \t*/\n\tu_char\t\tmsgin [8];\t/* Buffer for MESSAGE IN\t*/\n\tu32\t\tlastmsg;\t/* Last SCSI message sent\t*/\n\tu_char\t\tscratch;\t/* Scratch for SCSI receive\t*/\n\n\t/*----------------------------------------------------------------\n\t**\tMiscellaneous configuration and status parameters.\n\t**----------------------------------------------------------------\n\t*/\n\tu_char\t\tdisc;\t\t/* Disconnection allowed\t*/\n\tu_char\t\tscsi_mode;\t/* Current SCSI BUS mode\t*/\n\tu_char\t\torder;\t\t/* Tag order to use\t\t*/\n\tu_char\t\tverbose;\t/* Verbosity for this controller*/\n\tint\t\tncr_cache;\t/* Used for cache test at init.\t*/\n\tu_long\t\tp_ncb;\t\t/* BUS address of this NCB\t*/\n\n\t/*----------------------------------------------------------------\n\t**\tCommand completion handling.\n\t**----------------------------------------------------------------\n\t*/\n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\n\tstruct ccb\t*(ccb_done[MAX_DONE]);\n\tint\t\tccb_done_ic;\n#endif\n\t/*----------------------------------------------------------------\n\t**\tFields that should be removed or changed.\n\t**----------------------------------------------------------------\n\t*/\n\tstruct ccb\t*ccb;\t\t/* Global CCB\t\t\t*/\n\tstruct usrcmd\tuser;\t\t/* Command from user\t\t*/\n\tvolatile u_char\trelease_stage;\t/* Synchronisation stage on release  */\n};\n\n#define NCB_SCRIPT_PHYS(np,lbl)\t (np->p_script  + offsetof (struct script, lbl))\n#define NCB_SCRIPTH_PHYS(np,lbl) (np->p_scripth + offsetof (struct scripth,lbl))\n\n/*==========================================================\n**\n**\n**      Script for NCR-Processor.\n**\n**\tUse ncr_script_fill() to create the variable parts.\n**\tUse ncr_script_copy_and_bind() to make a copy and\n**\tbind to physical addresses.\n**\n**\n**==========================================================\n**\n**\tWe have to know the offsets of all labels before\n**\twe reach them (for forward jumps).\n**\tTherefore we declare a struct here.\n**\tIf you make changes inside the script,\n**\tDONT FORGET TO CHANGE THE LENGTHS HERE!\n**\n**----------------------------------------------------------\n*/\n\n/*\n**\tFor HP Zalon/53c720 systems, the Zalon interface\n**\tbetween CPU and 53c720 does prefetches, which causes\n**\tproblems with self modifying scripts.  The problem\n**\tis overcome by calling a dummy subroutine after each\n**\tmodification, to force a refetch of the script on\n**\treturn from the subroutine.\n*/\n\n#ifdef CONFIG_NCR53C8XX_PREFETCH\n#define PREFETCH_FLUSH_CNT\t2\n#define PREFETCH_FLUSH\t\tSCR_CALL, PADDRH (wait_dma),\n#else\n#define PREFETCH_FLUSH_CNT\t0\n#define PREFETCH_FLUSH\n#endif\n\n/*\n**\tScript fragments which are loaded into the on-chip RAM \n**\tof 825A, 875 and 895 chips.\n*/\nstruct script {\n\tncrcmd\tstart\t\t[  5];\n\tncrcmd  startpos\t[  1];\n\tncrcmd\tselect\t\t[  6];\n\tncrcmd\tselect2\t\t[  9 + PREFETCH_FLUSH_CNT];\n\tncrcmd\tloadpos\t\t[  4];\n\tncrcmd\tsend_ident\t[  9];\n\tncrcmd\tprepare\t\t[  6];\n\tncrcmd\tprepare2\t[  7];\n\tncrcmd  command\t\t[  6];\n\tncrcmd  dispatch\t[ 32];\n\tncrcmd  clrack\t\t[  4];\n\tncrcmd\tno_data\t\t[ 17];\n\tncrcmd  status\t\t[  8];\n\tncrcmd  msg_in\t\t[  2];\n\tncrcmd  msg_in2\t\t[ 16];\n\tncrcmd  msg_bad\t\t[  4];\n\tncrcmd\tsetmsg\t\t[  7];\n\tncrcmd\tcleanup\t\t[  6];\n\tncrcmd  complete\t[  9];\n\tncrcmd\tcleanup_ok\t[  8 + PREFETCH_FLUSH_CNT];\n\tncrcmd\tcleanup0\t[  1];\n#ifndef SCSI_NCR_CCB_DONE_SUPPORT\n\tncrcmd\tsignal\t\t[ 12];\n#else\n\tncrcmd\tsignal\t\t[  9];\n\tncrcmd\tdone_pos\t[  1];\n\tncrcmd\tdone_plug\t[  2];\n\tncrcmd\tdone_end\t[  7];\n#endif\n\tncrcmd  save_dp\t\t[  7];\n\tncrcmd  restore_dp\t[  5];\n\tncrcmd  disconnect\t[ 10];\n\tncrcmd\tmsg_out\t\t[  9];\n\tncrcmd\tmsg_out_done\t[  7];\n\tncrcmd  idle\t\t[  2];\n\tncrcmd\treselect\t[  8];\n\tncrcmd\treselected\t[  8];\n\tncrcmd\tresel_dsa\t[  6 + PREFETCH_FLUSH_CNT];\n\tncrcmd\tloadpos1\t[  4];\n\tncrcmd  resel_lun\t[  6];\n\tncrcmd\tresel_tag\t[  6];\n\tncrcmd\tjump_to_nexus\t[  4 + PREFETCH_FLUSH_CNT];\n\tncrcmd\tnexus_indirect\t[  4];\n\tncrcmd\tresel_notag\t[  4];\n\tncrcmd  data_in\t\t[MAX_SCATTERL * 4];\n\tncrcmd  data_in2\t[  4];\n\tncrcmd  data_out\t[MAX_SCATTERL * 4];\n\tncrcmd  data_out2\t[  4];\n};\n\n/*\n**\tScript fragments which stay in main memory for all chips.\n*/\nstruct scripth {\n\tncrcmd  tryloop\t\t[MAX_START*2];\n\tncrcmd  tryloop2\t[  2];\n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\n\tncrcmd  done_queue\t[MAX_DONE*5];\n\tncrcmd  done_queue2\t[  2];\n#endif\n\tncrcmd\tselect_no_atn\t[  8];\n\tncrcmd\tcancel\t\t[  4];\n\tncrcmd\tskip\t\t[  9 + PREFETCH_FLUSH_CNT];\n\tncrcmd\tskip2\t\t[ 19];\n\tncrcmd\tpar_err_data_in\t[  6];\n\tncrcmd\tpar_err_other\t[  4];\n\tncrcmd\tmsg_reject\t[  8];\n\tncrcmd\tmsg_ign_residue\t[ 24];\n\tncrcmd  msg_extended\t[ 10];\n\tncrcmd  msg_ext_2\t[ 10];\n\tncrcmd\tmsg_wdtr\t[ 14];\n\tncrcmd\tsend_wdtr\t[  7];\n\tncrcmd  msg_ext_3\t[ 10];\n\tncrcmd\tmsg_sdtr\t[ 14];\n\tncrcmd\tsend_sdtr\t[  7];\n\tncrcmd\tnego_bad_phase\t[  4];\n\tncrcmd\tmsg_out_abort\t[ 10];\n\tncrcmd  hdata_in\t[MAX_SCATTERH * 4];\n\tncrcmd  hdata_in2\t[  2];\n\tncrcmd  hdata_out\t[MAX_SCATTERH * 4];\n\tncrcmd  hdata_out2\t[  2];\n\tncrcmd\treset\t\t[  4];\n\tncrcmd\taborttag\t[  4];\n\tncrcmd\tabort\t\t[  2];\n\tncrcmd\tabort_resel\t[ 20];\n\tncrcmd\tresend_ident\t[  4];\n\tncrcmd\tclratn_go_on\t[  3];\n\tncrcmd\tnxtdsp_go_on\t[  1];\n\tncrcmd\tsdata_in\t[  8];\n\tncrcmd  data_io\t\t[ 18];\n\tncrcmd\tbad_identify\t[ 12];\n\tncrcmd\tbad_i_t_l\t[  4];\n\tncrcmd\tbad_i_t_l_q\t[  4];\n\tncrcmd\tbad_target\t[  8];\n\tncrcmd\tbad_status\t[  8];\n\tncrcmd\tstart_ram\t[  4 + PREFETCH_FLUSH_CNT];\n\tncrcmd\tstart_ram0\t[  4];\n\tncrcmd\tsto_restart\t[  5];\n\tncrcmd\twait_dma\t[  2];\n\tncrcmd\tsnooptest\t[  9];\n\tncrcmd\tsnoopend\t[  2];\n};\n\n/*==========================================================\n**\n**\n**      Function headers.\n**\n**\n**==========================================================\n*/\n\nstatic\tvoid\tncr_alloc_ccb\t(struct ncb *np, u_char tn, u_char ln);\nstatic\tvoid\tncr_complete\t(struct ncb *np, struct ccb *cp);\nstatic\tvoid\tncr_exception\t(struct ncb *np);\nstatic\tvoid\tncr_free_ccb\t(struct ncb *np, struct ccb *cp);\nstatic\tvoid\tncr_init_ccb\t(struct ncb *np, struct ccb *cp);\nstatic\tvoid\tncr_init_tcb\t(struct ncb *np, u_char tn);\nstatic\tstruct lcb *\tncr_alloc_lcb\t(struct ncb *np, u_char tn, u_char ln);\nstatic\tstruct lcb *\tncr_setup_lcb\t(struct ncb *np, struct scsi_device *sdev);\nstatic\tvoid\tncr_getclock\t(struct ncb *np, int mult);\nstatic\tvoid\tncr_selectclock\t(struct ncb *np, u_char scntl3);\nstatic\tstruct ccb *ncr_get_ccb\t(struct ncb *np, struct scsi_cmnd *cmd);\nstatic\tvoid\tncr_chip_reset\t(struct ncb *np, int delay);\nstatic\tvoid\tncr_init\t(struct ncb *np, int reset, char * msg, u_long code);\nstatic\tint\tncr_int_sbmc\t(struct ncb *np);\nstatic\tint\tncr_int_par\t(struct ncb *np);\nstatic\tvoid\tncr_int_ma\t(struct ncb *np);\nstatic\tvoid\tncr_int_sir\t(struct ncb *np);\nstatic  void    ncr_int_sto     (struct ncb *np);\nstatic\tvoid\tncr_negotiate\t(struct ncb* np, struct tcb* tp);\nstatic\tint\tncr_prepare_nego(struct ncb *np, struct ccb *cp, u_char *msgptr);\n\nstatic\tvoid\tncr_script_copy_and_bind\n\t\t\t\t(struct ncb *np, ncrcmd *src, ncrcmd *dst, int len);\nstatic  void    ncr_script_fill (struct script * scr, struct scripth * scripth);\nstatic\tint\tncr_scatter\t(struct ncb *np, struct ccb *cp, struct scsi_cmnd *cmd);\nstatic\tvoid\tncr_getsync\t(struct ncb *np, u_char sfac, u_char *fakp, u_char *scntl3p);\nstatic\tvoid\tncr_setsync\t(struct ncb *np, struct ccb *cp, u_char scntl3, u_char sxfer);\nstatic\tvoid\tncr_setup_tags\t(struct ncb *np, struct scsi_device *sdev);\nstatic\tvoid\tncr_setwide\t(struct ncb *np, struct ccb *cp, u_char wide, u_char ack);\nstatic\tint\tncr_snooptest\t(struct ncb *np);\nstatic\tvoid\tncr_timeout\t(struct ncb *np);\nstatic  void    ncr_wakeup      (struct ncb *np, u_long code);\nstatic  void    ncr_wakeup_done (struct ncb *np);\nstatic\tvoid\tncr_start_next_ccb (struct ncb *np, struct lcb * lp, int maxn);\nstatic\tvoid\tncr_put_start_queue(struct ncb *np, struct ccb *cp);\n\nstatic void insert_into_waiting_list(struct ncb *np, struct scsi_cmnd *cmd);\nstatic struct scsi_cmnd *retrieve_from_waiting_list(int to_remove, struct ncb *np, struct scsi_cmnd *cmd);\nstatic void process_waiting_list(struct ncb *np, int sts);\n\n#define remove_from_waiting_list(np, cmd) \\\n\t\tretrieve_from_waiting_list(1, (np), (cmd))\n#define requeue_waiting_list(np) process_waiting_list((np), DID_OK)\n#define reset_waiting_list(np) process_waiting_list((np), DID_RESET)\n\nstatic inline char *ncr_name (struct ncb *np)\n{\n\treturn np->inst_name;\n}\n\n\n/*==========================================================\n**\n**\n**      Scripts for NCR-Processor.\n**\n**      Use ncr_script_bind for binding to physical addresses.\n**\n**\n**==========================================================\n**\n**\tNADDR generates a reference to a field of the controller data.\n**\tPADDR generates a reference to another part of the script.\n**\tRADDR generates a reference to a script processor register.\n**\tFADDR generates a reference to a script processor register\n**\t\twith offset.\n**\n**----------------------------------------------------------\n*/\n\n#define\tRELOC_SOFTC\t0x40000000\n#define\tRELOC_LABEL\t0x50000000\n#define\tRELOC_REGISTER\t0x60000000\n#if 0\n#define\tRELOC_KVAR\t0x70000000\n#endif\n#define\tRELOC_LABELH\t0x80000000\n#define\tRELOC_MASK\t0xf0000000\n\n#define\tNADDR(label)\t(RELOC_SOFTC | offsetof(struct ncb, label))\n#define PADDR(label)    (RELOC_LABEL | offsetof(struct script, label))\n#define PADDRH(label)   (RELOC_LABELH | offsetof(struct scripth, label))\n#define\tRADDR(label)\t(RELOC_REGISTER | REG(label))\n#define\tFADDR(label,ofs)(RELOC_REGISTER | ((REG(label))+(ofs)))\n#if 0\n#define\tKVAR(which)\t(RELOC_KVAR | (which))\n#endif\n\n#if 0\n#define\tSCRIPT_KVAR_JIFFIES\t(0)\n#define\tSCRIPT_KVAR_FIRST\t\tSCRIPT_KVAR_JIFFIES\n#define\tSCRIPT_KVAR_LAST\t\tSCRIPT_KVAR_JIFFIES\n/*\n * Kernel variables referenced in the scripts.\n * THESE MUST ALL BE ALIGNED TO A 4-BYTE BOUNDARY.\n */\nstatic void *script_kvars[] __initdata =\n\t{ (void *)&jiffies };\n#endif\n\nstatic\tstruct script script0 __initdata = {\n/*--------------------------< START >-----------------------*/ {\n\t/*\n\t**\tThis NOP will be patched with LED ON\n\t**\tSCR_REG_REG (gpreg, SCR_AND, 0xfe)\n\t*/\n\tSCR_NO_OP,\n\t\t0,\n\t/*\n\t**      Clear SIGP.\n\t*/\n\tSCR_FROM_REG (ctest2),\n\t\t0,\n\t/*\n\t**\tThen jump to a certain point in tryloop.\n\t**\tDue to the lack of indirect addressing the code\n\t**\tis self modifying here.\n\t*/\n\tSCR_JUMP,\n}/*-------------------------< STARTPOS >--------------------*/,{\n\t\tPADDRH(tryloop),\n\n}/*-------------------------< SELECT >----------------------*/,{\n\t/*\n\t**\tDSA\tcontains the address of a scheduled\n\t**\t\tdata structure.\n\t**\n\t**\tSCRATCHA contains the address of the script,\n\t**\t\twhich starts the next entry.\n\t**\n\t**\tSet Initiator mode.\n\t**\n\t**\t(Target mode is left as an exercise for the reader)\n\t*/\n\n\tSCR_CLR (SCR_TRG),\n\t\t0,\n\tSCR_LOAD_REG (HS_REG, HS_SELECTING),\n\t\t0,\n\n\t/*\n\t**      And try to select this target.\n\t*/\n\tSCR_SEL_TBL_ATN ^ offsetof (struct dsb, select),\n\t\tPADDR (reselect),\n\n}/*-------------------------< SELECT2 >----------------------*/,{\n\t/*\n\t**\tNow there are 4 possibilities:\n\t**\n\t**\t(1) The ncr loses arbitration.\n\t**\tThis is ok, because it will try again,\n\t**\twhen the bus becomes idle.\n\t**\t(But beware of the timeout function!)\n\t**\n\t**\t(2) The ncr is reselected.\n\t**\tThen the script processor takes the jump\n\t**\tto the RESELECT label.\n\t**\n\t**\t(3) The ncr wins arbitration.\n\t**\tThen it will execute SCRIPTS instruction until \n\t**\tthe next instruction that checks SCSI phase.\n\t**\tThen will stop and wait for selection to be \n\t**\tcomplete or selection time-out to occur.\n\t**\tAs a result the SCRIPTS instructions until \n\t**\tLOADPOS + 2 should be executed in parallel with \n\t**\tthe SCSI core performing selection.\n\t*/\n\n\t/*\n\t**\tThe MESSAGE_REJECT problem seems to be due to a selection \n\t**\ttiming problem.\n\t**\tWait immediately for the selection to complete. \n\t**\t(2.5x behaves so)\n\t*/\n\tSCR_JUMPR ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\t0,\n\n\t/*\n\t**\tNext time use the next slot.\n\t*/\n\tSCR_COPY (4),\n\t\tRADDR (temp),\n\t\tPADDR (startpos),\n\t/*\n\t**      The ncr doesn't have an indirect load\n\t**\tor store command. So we have to\n\t**\tcopy part of the control block to a\n\t**\tfixed place, where we can access it.\n\t**\n\t**\tWe patch the address part of a\n\t**\tCOPY command with the DSA-register.\n\t*/\n\tSCR_COPY_F (4),\n\t\tRADDR (dsa),\n\t\tPADDR (loadpos),\n\t/*\n\t**\tFlush script prefetch if required\n\t*/\n\tPREFETCH_FLUSH\n\t/*\n\t**\tthen we do the actual copy.\n\t*/\n\tSCR_COPY (sizeof (struct head)),\n\t/*\n\t**\tcontinued after the next label ...\n\t*/\n}/*-------------------------< LOADPOS >---------------------*/,{\n\t\t0,\n\t\tNADDR (header),\n\t/*\n\t**\tWait for the next phase or the selection\n\t**\tto complete or time-out.\n\t*/\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\tPADDR (prepare),\n\n}/*-------------------------< SEND_IDENT >----------------------*/,{\n\t/*\n\t**\tSelection complete.\n\t**\tSend the IDENTIFY and SIMPLE_TAG messages\n\t**\t(and the EXTENDED_SDTR message)\n\t*/\n\tSCR_MOVE_TBL ^ SCR_MSG_OUT,\n\t\toffsetof (struct dsb, smsg),\n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_OUT)),\n\t\tPADDRH (resend_ident),\n\tSCR_LOAD_REG (scratcha, 0x80),\n\t\t0,\n\tSCR_COPY (1),\n\t\tRADDR (scratcha),\n\t\tNADDR (lastmsg),\n}/*-------------------------< PREPARE >----------------------*/,{\n\t/*\n\t**      load the savep (saved pointer) into\n\t**      the TEMP register (actual pointer)\n\t*/\n\tSCR_COPY (4),\n\t\tNADDR (header.savep),\n\t\tRADDR (temp),\n\t/*\n\t**      Initialize the status registers\n\t*/\n\tSCR_COPY (4),\n\t\tNADDR (header.status),\n\t\tRADDR (scr0),\n}/*-------------------------< PREPARE2 >---------------------*/,{\n\t/*\n\t**\tInitialize the msgout buffer with a NOOP message.\n\t*/\n\tSCR_LOAD_REG (scratcha, NOP),\n\t\t0,\n\tSCR_COPY (1),\n\t\tRADDR (scratcha),\n\t\tNADDR (msgout),\n#if 0\n\tSCR_COPY (1),\n\t\tRADDR (scratcha),\n\t\tNADDR (msgin),\n#endif\n\t/*\n\t**\tAnticipate the COMMAND phase.\n\t**\tThis is the normal case for initial selection.\n\t*/\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_COMMAND)),\n\t\tPADDR (dispatch),\n\n}/*-------------------------< COMMAND >--------------------*/,{\n\t/*\n\t**\t... and send the command\n\t*/\n\tSCR_MOVE_TBL ^ SCR_COMMAND,\n\t\toffsetof (struct dsb, cmd),\n\t/*\n\t**\tIf status is still HS_NEGOTIATE, negotiation failed.\n\t**\tWe check this here, since we want to do that \n\t**\tonly once.\n\t*/\n\tSCR_FROM_REG (HS_REG),\n\t\t0,\n\tSCR_INT ^ IFTRUE (DATA (HS_NEGOTIATE)),\n\t\tSIR_NEGO_FAILED,\n\n}/*-----------------------< DISPATCH >----------------------*/,{\n\t/*\n\t**\tMSG_IN is the only phase that shall be \n\t**\tentered at least once for each (re)selection.\n\t**\tSo we test it first.\n\t*/\n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_IN)),\n\t\tPADDR (msg_in),\n\n\tSCR_RETURN ^ IFTRUE (IF (SCR_DATA_OUT)),\n\t\t0,\n\t/*\n\t**\tDEL 397 - 53C875 Rev 3 - Part Number 609-0392410 - ITEM 4.\n\t**\tPossible data corruption during Memory Write and Invalidate.\n\t**\tThis work-around resets the addressing logic prior to the \n\t**\tstart of the first MOVE of a DATA IN phase.\n\t**\t(See Documentation/scsi/ncr53c8xx.rst for more information)\n\t*/\n\tSCR_JUMPR ^ IFFALSE (IF (SCR_DATA_IN)),\n\t\t20,\n\tSCR_COPY (4),\n\t\tRADDR (scratcha),\n\t\tRADDR (scratcha),\n\tSCR_RETURN,\n \t\t0,\n\tSCR_JUMP ^ IFTRUE (IF (SCR_STATUS)),\n\t\tPADDR (status),\n\tSCR_JUMP ^ IFTRUE (IF (SCR_COMMAND)),\n\t\tPADDR (command),\n\tSCR_JUMP ^ IFTRUE (IF (SCR_MSG_OUT)),\n\t\tPADDR (msg_out),\n\t/*\n\t**      Discard one illegal phase byte, if required.\n\t*/\n\tSCR_LOAD_REG (scratcha, XE_BAD_PHASE),\n\t\t0,\n\tSCR_COPY (1),\n\t\tRADDR (scratcha),\n\t\tNADDR (xerr_st),\n\tSCR_JUMPR ^ IFFALSE (IF (SCR_ILG_OUT)),\n\t\t8,\n\tSCR_MOVE_ABS (1) ^ SCR_ILG_OUT,\n\t\tNADDR (scratch),\n\tSCR_JUMPR ^ IFFALSE (IF (SCR_ILG_IN)),\n\t\t8,\n\tSCR_MOVE_ABS (1) ^ SCR_ILG_IN,\n\t\tNADDR (scratch),\n\tSCR_JUMP,\n\t\tPADDR (dispatch),\n\n}/*-------------------------< CLRACK >----------------------*/,{\n\t/*\n\t**\tTerminate possible pending message phase.\n\t*/\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (dispatch),\n\n}/*-------------------------< NO_DATA >--------------------*/,{\n\t/*\n\t**\tThe target wants to tranfer too much data\n\t**\tor in the wrong direction.\n\t**      Remember that in extended error.\n\t*/\n\tSCR_LOAD_REG (scratcha, XE_EXTRA_DATA),\n\t\t0,\n\tSCR_COPY (1),\n\t\tRADDR (scratcha),\n\t\tNADDR (xerr_st),\n\t/*\n\t**      Discard one data byte, if required.\n\t*/\n\tSCR_JUMPR ^ IFFALSE (WHEN (SCR_DATA_OUT)),\n\t\t8,\n\tSCR_MOVE_ABS (1) ^ SCR_DATA_OUT,\n\t\tNADDR (scratch),\n\tSCR_JUMPR ^ IFFALSE (IF (SCR_DATA_IN)),\n\t\t8,\n\tSCR_MOVE_ABS (1) ^ SCR_DATA_IN,\n\t\tNADDR (scratch),\n\t/*\n\t**      .. and repeat as required.\n\t*/\n\tSCR_CALL,\n\t\tPADDR (dispatch),\n\tSCR_JUMP,\n\t\tPADDR (no_data),\n\n}/*-------------------------< STATUS >--------------------*/,{\n\t/*\n\t**\tget the status\n\t*/\n\tSCR_MOVE_ABS (1) ^ SCR_STATUS,\n\t\tNADDR (scratch),\n\t/*\n\t**\tsave status to scsi_status.\n\t**\tmark as complete.\n\t*/\n\tSCR_TO_REG (SS_REG),\n\t\t0,\n\tSCR_LOAD_REG (HS_REG, HS_COMPLETE),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (dispatch),\n}/*-------------------------< MSG_IN >--------------------*/,{\n\t/*\n\t**\tGet the first byte of the message\n\t**\tand save it to SCRATCHA.\n\t**\n\t**\tThe script processor doesn't negate the\n\t**\tACK signal after this transfer.\n\t*/\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin[0]),\n}/*-------------------------< MSG_IN2 >--------------------*/,{\n\t/*\n\t**\tHandle this message.\n\t*/\n\tSCR_JUMP ^ IFTRUE (DATA (COMMAND_COMPLETE)),\n\t\tPADDR (complete),\n\tSCR_JUMP ^ IFTRUE (DATA (DISCONNECT)),\n\t\tPADDR (disconnect),\n\tSCR_JUMP ^ IFTRUE (DATA (SAVE_POINTERS)),\n\t\tPADDR (save_dp),\n\tSCR_JUMP ^ IFTRUE (DATA (RESTORE_POINTERS)),\n\t\tPADDR (restore_dp),\n\tSCR_JUMP ^ IFTRUE (DATA (EXTENDED_MESSAGE)),\n\t\tPADDRH (msg_extended),\n\tSCR_JUMP ^ IFTRUE (DATA (NOP)),\n\t\tPADDR (clrack),\n\tSCR_JUMP ^ IFTRUE (DATA (MESSAGE_REJECT)),\n\t\tPADDRH (msg_reject),\n\tSCR_JUMP ^ IFTRUE (DATA (IGNORE_WIDE_RESIDUE)),\n\t\tPADDRH (msg_ign_residue),\n\t/*\n\t**\tRest of the messages left as\n\t**\tan exercise ...\n\t**\n\t**\tUnimplemented messages:\n\t**\tfall through to MSG_BAD.\n\t*/\n}/*-------------------------< MSG_BAD >------------------*/,{\n\t/*\n\t**\tunimplemented message - reject it.\n\t*/\n\tSCR_INT,\n\t\tSIR_REJECT_SENT,\n\tSCR_LOAD_REG (scratcha, MESSAGE_REJECT),\n\t\t0,\n}/*-------------------------< SETMSG >----------------------*/,{\n\tSCR_COPY (1),\n\t\tRADDR (scratcha),\n\t\tNADDR (msgout),\n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (clrack),\n}/*-------------------------< CLEANUP >-------------------*/,{\n\t/*\n\t**      dsa:    Pointer to ccb\n\t**\t      or xxxxxxFF (no ccb)\n\t**\n\t**      HS_REG:   Host-Status (<>0!)\n\t*/\n\tSCR_FROM_REG (dsa),\n\t\t0,\n\tSCR_JUMP ^ IFTRUE (DATA (0xff)),\n\t\tPADDR (start),\n\t/*\n\t**      dsa is valid.\n\t**\tcomplete the cleanup.\n\t*/\n\tSCR_JUMP,\n\t\tPADDR (cleanup_ok),\n\n}/*-------------------------< COMPLETE >-----------------*/,{\n\t/*\n\t**\tComplete message.\n\t**\n\t**\tCopy TEMP register to LASTP in header.\n\t*/\n\tSCR_COPY (4),\n\t\tRADDR (temp),\n\t\tNADDR (header.lastp),\n\t/*\n\t**\tWhen we terminate the cycle by clearing ACK,\n\t**\tthe target may disconnect immediately.\n\t**\n\t**\tWe don't want to be told of an\n\t**\t\"unexpected disconnect\",\n\t**\tso we disable this feature.\n\t*/\n\tSCR_REG_REG (scntl2, SCR_AND, 0x7f),\n\t\t0,\n\t/*\n\t**\tTerminate cycle ...\n\t*/\n\tSCR_CLR (SCR_ACK|SCR_ATN),\n\t\t0,\n\t/*\n\t**\t... and wait for the disconnect.\n\t*/\n\tSCR_WAIT_DISC,\n\t\t0,\n}/*-------------------------< CLEANUP_OK >----------------*/,{\n\t/*\n\t**\tSave host status to header.\n\t*/\n\tSCR_COPY (4),\n\t\tRADDR (scr0),\n\t\tNADDR (header.status),\n\t/*\n\t**\tand copy back the header to the ccb.\n\t*/\n\tSCR_COPY_F (4),\n\t\tRADDR (dsa),\n\t\tPADDR (cleanup0),\n\t/*\n\t**\tFlush script prefetch if required\n\t*/\n\tPREFETCH_FLUSH\n\tSCR_COPY (sizeof (struct head)),\n\t\tNADDR (header),\n}/*-------------------------< CLEANUP0 >--------------------*/,{\n\t\t0,\n}/*-------------------------< SIGNAL >----------------------*/,{\n\t/*\n\t**\tif job not completed ...\n\t*/\n\tSCR_FROM_REG (HS_REG),\n\t\t0,\n\t/*\n\t**\t... start the next command.\n\t*/\n\tSCR_JUMP ^ IFTRUE (MASK (0, (HS_DONEMASK|HS_SKIPMASK))),\n\t\tPADDR(start),\n\t/*\n\t**\tIf command resulted in not GOOD status,\n\t**\tcall the C code if needed.\n\t*/\n\tSCR_FROM_REG (SS_REG),\n\t\t0,\n\tSCR_CALL ^ IFFALSE (DATA (SAM_STAT_GOOD)),\n\t\tPADDRH (bad_status),\n\n#ifndef\tSCSI_NCR_CCB_DONE_SUPPORT\n\n\t/*\n\t**\t... signal completion to the host\n\t*/\n\tSCR_INT,\n\t\tSIR_INTFLY,\n\t/*\n\t**\tAuf zu neuen Schandtaten!\n\t*/\n\tSCR_JUMP,\n\t\tPADDR(start),\n\n#else\t/* defined SCSI_NCR_CCB_DONE_SUPPORT */\n\n\t/*\n\t**\t... signal completion to the host\n\t*/\n\tSCR_JUMP,\n}/*------------------------< DONE_POS >---------------------*/,{\n\t\tPADDRH (done_queue),\n}/*------------------------< DONE_PLUG >--------------------*/,{\n\tSCR_INT,\n\t\tSIR_DONE_OVERFLOW,\n}/*------------------------< DONE_END >---------------------*/,{\n\tSCR_INT,\n\t\tSIR_INTFLY,\n\tSCR_COPY (4),\n\t\tRADDR (temp),\n\t\tPADDR (done_pos),\n\tSCR_JUMP,\n\t\tPADDR (start),\n\n#endif\t/* SCSI_NCR_CCB_DONE_SUPPORT */\n\n}/*-------------------------< SAVE_DP >------------------*/,{\n\t/*\n\t**\tSAVE_DP message:\n\t**\tCopy TEMP register to SAVEP in header.\n\t*/\n\tSCR_COPY (4),\n\t\tRADDR (temp),\n\t\tNADDR (header.savep),\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (dispatch),\n}/*-------------------------< RESTORE_DP >---------------*/,{\n\t/*\n\t**\tRESTORE_DP message:\n\t**\tCopy SAVEP in header to TEMP register.\n\t*/\n\tSCR_COPY (4),\n\t\tNADDR (header.savep),\n\t\tRADDR (temp),\n\tSCR_JUMP,\n\t\tPADDR (clrack),\n\n}/*-------------------------< DISCONNECT >---------------*/,{\n\t/*\n\t**\tDISCONNECTing  ...\n\t**\n\t**\tdisable the \"unexpected disconnect\" feature,\n\t**\tand remove the ACK signal.\n\t*/\n\tSCR_REG_REG (scntl2, SCR_AND, 0x7f),\n\t\t0,\n\tSCR_CLR (SCR_ACK|SCR_ATN),\n\t\t0,\n\t/*\n\t**\tWait for the disconnect.\n\t*/\n\tSCR_WAIT_DISC,\n\t\t0,\n\t/*\n\t**\tStatus is: DISCONNECTED.\n\t*/\n\tSCR_LOAD_REG (HS_REG, HS_DISCONNECT),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (cleanup_ok),\n\n}/*-------------------------< MSG_OUT >-------------------*/,{\n\t/*\n\t**\tThe target requests a message.\n\t*/\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_OUT,\n\t\tNADDR (msgout),\n\tSCR_COPY (1),\n\t\tNADDR (msgout),\n\t\tNADDR (lastmsg),\n\t/*\n\t**\tIf it was no ABORT message ...\n\t*/\n\tSCR_JUMP ^ IFTRUE (DATA (ABORT_TASK_SET)),\n\t\tPADDRH (msg_out_abort),\n\t/*\n\t**\t... wait for the next phase\n\t**\tif it's a message out, send it again, ...\n\t*/\n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_OUT)),\n\t\tPADDR (msg_out),\n}/*-------------------------< MSG_OUT_DONE >--------------*/,{\n\t/*\n\t**\t... else clear the message ...\n\t*/\n\tSCR_LOAD_REG (scratcha, NOP),\n\t\t0,\n\tSCR_COPY (4),\n\t\tRADDR (scratcha),\n\t\tNADDR (msgout),\n\t/*\n\t**\t... and process the next phase\n\t*/\n\tSCR_JUMP,\n\t\tPADDR (dispatch),\n}/*-------------------------< IDLE >------------------------*/,{\n\t/*\n\t**\tNothing to do?\n\t**\tWait for reselect.\n\t**\tThis NOP will be patched with LED OFF\n\t**\tSCR_REG_REG (gpreg, SCR_OR, 0x01)\n\t*/\n\tSCR_NO_OP,\n\t\t0,\n}/*-------------------------< RESELECT >--------------------*/,{\n\t/*\n\t**\tmake the DSA invalid.\n\t*/\n\tSCR_LOAD_REG (dsa, 0xff),\n\t\t0,\n\tSCR_CLR (SCR_TRG),\n\t\t0,\n\tSCR_LOAD_REG (HS_REG, HS_IN_RESELECT),\n\t\t0,\n\t/*\n\t**\tSleep waiting for a reselection.\n\t**\tIf SIGP is set, special treatment.\n\t**\n\t**\tZu allem bereit ..\n\t*/\n\tSCR_WAIT_RESEL,\n\t\tPADDR(start),\n}/*-------------------------< RESELECTED >------------------*/,{\n\t/*\n\t**\tThis NOP will be patched with LED ON\n\t**\tSCR_REG_REG (gpreg, SCR_AND, 0xfe)\n\t*/\n\tSCR_NO_OP,\n\t\t0,\n\t/*\n\t**\t... zu nichts zu gebrauchen ?\n\t**\n\t**      load the target id into the SFBR\n\t**\tand jump to the control block.\n\t**\n\t**\tLook at the declarations of\n\t**\t- struct ncb\n\t**\t- struct tcb\n\t**\t- struct lcb\n\t**\t- struct ccb\n\t**\tto understand what's going on.\n\t*/\n\tSCR_REG_SFBR (ssid, SCR_AND, 0x8F),\n\t\t0,\n\tSCR_TO_REG (sdid),\n\t\t0,\n\tSCR_JUMP,\n\t\tNADDR (jump_tcb),\n\n}/*-------------------------< RESEL_DSA >-------------------*/,{\n\t/*\n\t**\tAck the IDENTIFY or TAG previously received.\n\t*/\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\t/*\n\t**      The ncr doesn't have an indirect load\n\t**\tor store command. So we have to\n\t**\tcopy part of the control block to a\n\t**\tfixed place, where we can access it.\n\t**\n\t**\tWe patch the address part of a\n\t**\tCOPY command with the DSA-register.\n\t*/\n\tSCR_COPY_F (4),\n\t\tRADDR (dsa),\n\t\tPADDR (loadpos1),\n\t/*\n\t**\tFlush script prefetch if required\n\t*/\n\tPREFETCH_FLUSH\n\t/*\n\t**\tthen we do the actual copy.\n\t*/\n\tSCR_COPY (sizeof (struct head)),\n\t/*\n\t**\tcontinued after the next label ...\n\t*/\n\n}/*-------------------------< LOADPOS1 >-------------------*/,{\n\t\t0,\n\t\tNADDR (header),\n\t/*\n\t**\tThe DSA contains the data structure address.\n\t*/\n\tSCR_JUMP,\n\t\tPADDR (prepare),\n\n}/*-------------------------< RESEL_LUN >-------------------*/,{\n\t/*\n\t**\tcome back to this point\n\t**\tto get an IDENTIFY message\n\t**\tWait for a msg_in phase.\n\t*/\n\tSCR_INT ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tSIR_RESEL_NO_MSG_IN,\n\t/*\n\t**\tmessage phase.\n\t**\tRead the data directly from the BUS DATA lines.\n\t**\tThis helps to support very old SCSI devices that \n\t**\tmay reselect without sending an IDENTIFY.\n\t*/\n\tSCR_FROM_REG (sbdl),\n\t\t0,\n\t/*\n\t**\tIt should be an Identify message.\n\t*/\n\tSCR_RETURN,\n\t\t0,\n}/*-------------------------< RESEL_TAG >-------------------*/,{\n\t/*\n\t**\tRead IDENTIFY + SIMPLE + TAG using a single MOVE.\n\t**\tAggressive optimization, is'nt it?\n\t**\tNo need to test the SIMPLE TAG message, since the \n\t**\tdriver only supports conformant devices for tags. ;-)\n\t*/\n\tSCR_MOVE_ABS (3) ^ SCR_MSG_IN,\n\t\tNADDR (msgin),\n\t/*\n\t**\tRead the TAG from the SIDL.\n\t**\tStill an aggressive optimization. ;-)\n\t**\tCompute the CCB indirect jump address which \n\t**\tis (#TAG*2 & 0xfc) due to tag numbering using \n\t**\t1,3,5..MAXTAGS*2+1 actual values.\n\t*/\n\tSCR_REG_SFBR (sidl, SCR_SHL, 0),\n\t\t0,\n\tSCR_SFBR_REG (temp, SCR_AND, 0xfc),\n\t\t0,\n}/*-------------------------< JUMP_TO_NEXUS >-------------------*/,{\n\tSCR_COPY_F (4),\n\t\tRADDR (temp),\n\t\tPADDR (nexus_indirect),\n\t/*\n\t**\tFlush script prefetch if required\n\t*/\n\tPREFETCH_FLUSH\n\tSCR_COPY (4),\n}/*-------------------------< NEXUS_INDIRECT >-------------------*/,{\n\t\t0,\n\t\tRADDR (temp),\n\tSCR_RETURN,\n\t\t0,\n}/*-------------------------< RESEL_NOTAG >-------------------*/,{\n\t/*\n\t**\tNo tag expected.\n\t**\tRead an throw away the IDENTIFY.\n\t*/\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin),\n\tSCR_JUMP,\n\t\tPADDR (jump_to_nexus),\n}/*-------------------------< DATA_IN >--------------------*/,{\n/*\n**\tBecause the size depends on the\n**\t#define MAX_SCATTERL parameter,\n**\tit is filled in at runtime.\n**\n**  ##===========< i=0; i<MAX_SCATTERL >=========\n**  ||\tSCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)),\n**  ||\t\tPADDR (dispatch),\n**  ||\tSCR_MOVE_TBL ^ SCR_DATA_IN,\n**  ||\t\toffsetof (struct dsb, data[ i]),\n**  ##==========================================\n**\n**---------------------------------------------------------\n*/\n0\n}/*-------------------------< DATA_IN2 >-------------------*/,{\n\tSCR_CALL,\n\t\tPADDR (dispatch),\n\tSCR_JUMP,\n\t\tPADDR (no_data),\n}/*-------------------------< DATA_OUT >--------------------*/,{\n/*\n**\tBecause the size depends on the\n**\t#define MAX_SCATTERL parameter,\n**\tit is filled in at runtime.\n**\n**  ##===========< i=0; i<MAX_SCATTERL >=========\n**  ||\tSCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT)),\n**  ||\t\tPADDR (dispatch),\n**  ||\tSCR_MOVE_TBL ^ SCR_DATA_OUT,\n**  ||\t\toffsetof (struct dsb, data[ i]),\n**  ##==========================================\n**\n**---------------------------------------------------------\n*/\n0\n}/*-------------------------< DATA_OUT2 >-------------------*/,{\n\tSCR_CALL,\n\t\tPADDR (dispatch),\n\tSCR_JUMP,\n\t\tPADDR (no_data),\n}/*--------------------------------------------------------*/\n};\n\nstatic\tstruct scripth scripth0 __initdata = {\n/*-------------------------< TRYLOOP >---------------------*/{\n/*\n**\tStart the next entry.\n**\tCalled addresses point to the launch script in the CCB.\n**\tThey are patched by the main processor.\n**\n**\tBecause the size depends on the\n**\t#define MAX_START parameter, it is filled\n**\tin at runtime.\n**\n**-----------------------------------------------------------\n**\n**  ##===========< I=0; i<MAX_START >===========\n**  ||\tSCR_CALL,\n**  ||\t\tPADDR (idle),\n**  ##==========================================\n**\n**-----------------------------------------------------------\n*/\n0\n}/*------------------------< TRYLOOP2 >---------------------*/,{\n\tSCR_JUMP,\n\t\tPADDRH(tryloop),\n\n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\n\n}/*------------------------< DONE_QUEUE >-------------------*/,{\n/*\n**\tCopy the CCB address to the next done entry.\n**\tBecause the size depends on the\n**\t#define MAX_DONE parameter, it is filled\n**\tin at runtime.\n**\n**-----------------------------------------------------------\n**\n**  ##===========< I=0; i<MAX_DONE >===========\n**  ||\tSCR_COPY (sizeof(struct ccb *),\n**  ||\t\tNADDR (header.cp),\n**  ||\t\tNADDR (ccb_done[i]),\n**  ||\tSCR_CALL,\n**  ||\t\tPADDR (done_end),\n**  ##==========================================\n**\n**-----------------------------------------------------------\n*/\n0\n}/*------------------------< DONE_QUEUE2 >------------------*/,{\n\tSCR_JUMP,\n\t\tPADDRH (done_queue),\n\n#endif /* SCSI_NCR_CCB_DONE_SUPPORT */\n}/*------------------------< SELECT_NO_ATN >-----------------*/,{\n\t/*\n\t**\tSet Initiator mode.\n\t**      And try to select this target without ATN.\n\t*/\n\n\tSCR_CLR (SCR_TRG),\n\t\t0,\n\tSCR_LOAD_REG (HS_REG, HS_SELECTING),\n\t\t0,\n\tSCR_SEL_TBL ^ offsetof (struct dsb, select),\n\t\tPADDR (reselect),\n\tSCR_JUMP,\n\t\tPADDR (select2),\n\n}/*-------------------------< CANCEL >------------------------*/,{\n\n\tSCR_LOAD_REG (scratcha, HS_ABORTED),\n\t\t0,\n\tSCR_JUMPR,\n\t\t8,\n}/*-------------------------< SKIP >------------------------*/,{\n\tSCR_LOAD_REG (scratcha, 0),\n\t\t0,\n\t/*\n\t**\tThis entry has been canceled.\n\t**\tNext time use the next slot.\n\t*/\n\tSCR_COPY (4),\n\t\tRADDR (temp),\n\t\tPADDR (startpos),\n\t/*\n\t**      The ncr doesn't have an indirect load\n\t**\tor store command. So we have to\n\t**\tcopy part of the control block to a\n\t**\tfixed place, where we can access it.\n\t**\n\t**\tWe patch the address part of a\n\t**\tCOPY command with the DSA-register.\n\t*/\n\tSCR_COPY_F (4),\n\t\tRADDR (dsa),\n\t\tPADDRH (skip2),\n\t/*\n\t**\tFlush script prefetch if required\n\t*/\n\tPREFETCH_FLUSH\n\t/*\n\t**\tthen we do the actual copy.\n\t*/\n\tSCR_COPY (sizeof (struct head)),\n\t/*\n\t**\tcontinued after the next label ...\n\t*/\n}/*-------------------------< SKIP2 >---------------------*/,{\n\t\t0,\n\t\tNADDR (header),\n\t/*\n\t**      Initialize the status registers\n\t*/\n\tSCR_COPY (4),\n\t\tNADDR (header.status),\n\t\tRADDR (scr0),\n\t/*\n\t**\tForce host status.\n\t*/\n\tSCR_FROM_REG (scratcha),\n\t\t0,\n\tSCR_JUMPR ^ IFFALSE (MASK (0, HS_DONEMASK)),\n\t\t16,\n\tSCR_REG_REG (HS_REG, SCR_OR, HS_SKIPMASK),\n\t\t0,\n\tSCR_JUMPR,\n\t\t8,\n\tSCR_TO_REG (HS_REG),\n\t\t0,\n\tSCR_LOAD_REG (SS_REG, SAM_STAT_GOOD),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (cleanup_ok),\n\n},/*-------------------------< PAR_ERR_DATA_IN >---------------*/{\n\t/*\n\t**\tIgnore all data in byte, until next phase\n\t*/\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_IN)),\n\t\tPADDRH (par_err_other),\n\tSCR_MOVE_ABS (1) ^ SCR_DATA_IN,\n\t\tNADDR (scratch),\n\tSCR_JUMPR,\n\t\t-24,\n},/*-------------------------< PAR_ERR_OTHER >------------------*/{\n\t/*\n\t**\tcount it.\n\t*/\n\tSCR_REG_REG (PS_REG, SCR_ADD, 0x01),\n\t\t0,\n\t/*\n\t**\tjump to dispatcher.\n\t*/\n\tSCR_JUMP,\n\t\tPADDR (dispatch),\n}/*-------------------------< MSG_REJECT >---------------*/,{\n\t/*\n\t**\tIf a negotiation was in progress,\n\t**\tnegotiation failed.\n\t**\tOtherwise, let the C code print \n\t**\tsome message.\n\t*/\n\tSCR_FROM_REG (HS_REG),\n\t\t0,\n\tSCR_INT ^ IFFALSE (DATA (HS_NEGOTIATE)),\n\t\tSIR_REJECT_RECEIVED,\n\tSCR_INT ^ IFTRUE (DATA (HS_NEGOTIATE)),\n\t\tSIR_NEGO_FAILED,\n\tSCR_JUMP,\n\t\tPADDR (clrack),\n\n}/*-------------------------< MSG_IGN_RESIDUE >----------*/,{\n\t/*\n\t**\tTerminate cycle\n\t*/\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tPADDR (dispatch),\n\t/*\n\t**\tget residue size.\n\t*/\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin[1]),\n\t/*\n\t**\tSize is 0 .. ignore message.\n\t*/\n\tSCR_JUMP ^ IFTRUE (DATA (0)),\n\t\tPADDR (clrack),\n\t/*\n\t**\tSize is not 1 .. have to interrupt.\n\t*/\n\tSCR_JUMPR ^ IFFALSE (DATA (1)),\n\t\t40,\n\t/*\n\t**\tCheck for residue byte in swide register\n\t*/\n\tSCR_FROM_REG (scntl2),\n\t\t0,\n\tSCR_JUMPR ^ IFFALSE (MASK (WSR, WSR)),\n\t\t16,\n\t/*\n\t**\tThere IS data in the swide register.\n\t**\tDiscard it.\n\t*/\n\tSCR_REG_REG (scntl2, SCR_OR, WSR),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (clrack),\n\t/*\n\t**\tLoad again the size to the sfbr register.\n\t*/\n\tSCR_FROM_REG (scratcha),\n\t\t0,\n\tSCR_INT,\n\t\tSIR_IGN_RESIDUE,\n\tSCR_JUMP,\n\t\tPADDR (clrack),\n\n}/*-------------------------< MSG_EXTENDED >-------------*/,{\n\t/*\n\t**\tTerminate cycle\n\t*/\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tPADDR (dispatch),\n\t/*\n\t**\tget length.\n\t*/\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin[1]),\n\t/*\n\t*/\n\tSCR_JUMP ^ IFTRUE (DATA (3)),\n\t\tPADDRH (msg_ext_3),\n\tSCR_JUMP ^ IFFALSE (DATA (2)),\n\t\tPADDR (msg_bad),\n}/*-------------------------< MSG_EXT_2 >----------------*/,{\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tPADDR (dispatch),\n\t/*\n\t**\tget extended message code.\n\t*/\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin[2]),\n\tSCR_JUMP ^ IFTRUE (DATA (EXTENDED_WDTR)),\n\t\tPADDRH (msg_wdtr),\n\t/*\n\t**\tunknown extended message\n\t*/\n\tSCR_JUMP,\n\t\tPADDR (msg_bad)\n}/*-------------------------< MSG_WDTR >-----------------*/,{\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tPADDR (dispatch),\n\t/*\n\t**\tget data bus width\n\t*/\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin[3]),\n\t/*\n\t**\tlet the host do the real work.\n\t*/\n\tSCR_INT,\n\t\tSIR_NEGO_WIDE,\n\t/*\n\t**\tlet the target fetch our answer.\n\t*/\n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\tPADDRH (nego_bad_phase),\n\n}/*-------------------------< SEND_WDTR >----------------*/,{\n\t/*\n\t**\tSend the EXTENDED_WDTR\n\t*/\n\tSCR_MOVE_ABS (4) ^ SCR_MSG_OUT,\n\t\tNADDR (msgout),\n\tSCR_COPY (1),\n\t\tNADDR (msgout),\n\t\tNADDR (lastmsg),\n\tSCR_JUMP,\n\t\tPADDR (msg_out_done),\n\n}/*-------------------------< MSG_EXT_3 >----------------*/,{\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tPADDR (dispatch),\n\t/*\n\t**\tget extended message code.\n\t*/\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin[2]),\n\tSCR_JUMP ^ IFTRUE (DATA (EXTENDED_SDTR)),\n\t\tPADDRH (msg_sdtr),\n\t/*\n\t**\tunknown extended message\n\t*/\n\tSCR_JUMP,\n\t\tPADDR (msg_bad)\n\n}/*-------------------------< MSG_SDTR >-----------------*/,{\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tPADDR (dispatch),\n\t/*\n\t**\tget period and offset\n\t*/\n\tSCR_MOVE_ABS (2) ^ SCR_MSG_IN,\n\t\tNADDR (msgin[3]),\n\t/*\n\t**\tlet the host do the real work.\n\t*/\n\tSCR_INT,\n\t\tSIR_NEGO_SYNC,\n\t/*\n\t**\tlet the target fetch our answer.\n\t*/\n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\tPADDRH (nego_bad_phase),\n\n}/*-------------------------< SEND_SDTR >-------------*/,{\n\t/*\n\t**\tSend the EXTENDED_SDTR\n\t*/\n\tSCR_MOVE_ABS (5) ^ SCR_MSG_OUT,\n\t\tNADDR (msgout),\n\tSCR_COPY (1),\n\t\tNADDR (msgout),\n\t\tNADDR (lastmsg),\n\tSCR_JUMP,\n\t\tPADDR (msg_out_done),\n\n}/*-------------------------< NEGO_BAD_PHASE >------------*/,{\n\tSCR_INT,\n\t\tSIR_NEGO_PROTO,\n\tSCR_JUMP,\n\t\tPADDR (dispatch),\n\n}/*-------------------------< MSG_OUT_ABORT >-------------*/,{\n\t/*\n\t**\tAfter ABORT message,\n\t**\n\t**\texpect an immediate disconnect, ...\n\t*/\n\tSCR_REG_REG (scntl2, SCR_AND, 0x7f),\n\t\t0,\n\tSCR_CLR (SCR_ACK|SCR_ATN),\n\t\t0,\n\tSCR_WAIT_DISC,\n\t\t0,\n\t/*\n\t**\t... and set the status to \"ABORTED\"\n\t*/\n\tSCR_LOAD_REG (HS_REG, HS_ABORTED),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (cleanup),\n\n}/*-------------------------< HDATA_IN >-------------------*/,{\n/*\n**\tBecause the size depends on the\n**\t#define MAX_SCATTERH parameter,\n**\tit is filled in at runtime.\n**\n**  ##==< i=MAX_SCATTERL; i<MAX_SCATTERL+MAX_SCATTERH >==\n**  ||\tSCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)),\n**  ||\t\tPADDR (dispatch),\n**  ||\tSCR_MOVE_TBL ^ SCR_DATA_IN,\n**  ||\t\toffsetof (struct dsb, data[ i]),\n**  ##===================================================\n**\n**---------------------------------------------------------\n*/\n0\n}/*-------------------------< HDATA_IN2 >------------------*/,{\n\tSCR_JUMP,\n\t\tPADDR (data_in),\n\n}/*-------------------------< HDATA_OUT >-------------------*/,{\n/*\n**\tBecause the size depends on the\n**\t#define MAX_SCATTERH parameter,\n**\tit is filled in at runtime.\n**\n**  ##==< i=MAX_SCATTERL; i<MAX_SCATTERL+MAX_SCATTERH >==\n**  ||\tSCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT)),\n**  ||\t\tPADDR (dispatch),\n**  ||\tSCR_MOVE_TBL ^ SCR_DATA_OUT,\n**  ||\t\toffsetof (struct dsb, data[ i]),\n**  ##===================================================\n**\n**---------------------------------------------------------\n*/\n0\n}/*-------------------------< HDATA_OUT2 >------------------*/,{\n\tSCR_JUMP,\n\t\tPADDR (data_out),\n\n}/*-------------------------< RESET >----------------------*/,{\n\t/*\n\t**      Send a TARGET_RESET message if bad IDENTIFY \n\t**\treceived on reselection.\n\t*/\n\tSCR_LOAD_REG (scratcha, ABORT_TASK),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDRH (abort_resel),\n}/*-------------------------< ABORTTAG >-------------------*/,{\n\t/*\n\t**      Abort a wrong tag received on reselection.\n\t*/\n\tSCR_LOAD_REG (scratcha, ABORT_TASK),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDRH (abort_resel),\n}/*-------------------------< ABORT >----------------------*/,{\n\t/*\n\t**      Abort a reselection when no active CCB.\n\t*/\n\tSCR_LOAD_REG (scratcha, ABORT_TASK_SET),\n\t\t0,\n}/*-------------------------< ABORT_RESEL >----------------*/,{\n\tSCR_COPY (1),\n\t\tRADDR (scratcha),\n\t\tNADDR (msgout),\n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\t/*\n\t**\tand send it.\n\t**\twe expect an immediate disconnect\n\t*/\n\tSCR_REG_REG (scntl2, SCR_AND, 0x7f),\n\t\t0,\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_OUT,\n\t\tNADDR (msgout),\n\tSCR_COPY (1),\n\t\tNADDR (msgout),\n\t\tNADDR (lastmsg),\n\tSCR_CLR (SCR_ACK|SCR_ATN),\n\t\t0,\n\tSCR_WAIT_DISC,\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (start),\n}/*-------------------------< RESEND_IDENT >-------------------*/,{\n\t/*\n\t**\tThe target stays in MSG OUT phase after having acked \n\t**\tIdentify [+ Tag [+ Extended message ]]. Targets shall\n\t**\tbehave this way on parity error.\n\t**\tWe must send it again all the messages.\n\t*/\n\tSCR_SET (SCR_ATN), /* Shall be asserted 2 deskew delays before the  */\n\t\t0,         /* 1rst ACK = 90 ns. Hope the NCR is'nt too fast */\n\tSCR_JUMP,\n\t\tPADDR (send_ident),\n}/*-------------------------< CLRATN_GO_ON >-------------------*/,{\n\tSCR_CLR (SCR_ATN),\n\t\t0,\n\tSCR_JUMP,\n}/*-------------------------< NXTDSP_GO_ON >-------------------*/,{\n\t\t0,\n}/*-------------------------< SDATA_IN >-------------------*/,{\n\tSCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)),\n\t\tPADDR (dispatch),\n\tSCR_MOVE_TBL ^ SCR_DATA_IN,\n\t\toffsetof (struct dsb, sense),\n\tSCR_CALL,\n\t\tPADDR (dispatch),\n\tSCR_JUMP,\n\t\tPADDR (no_data),\n}/*-------------------------< DATA_IO >--------------------*/,{\n\t/*\n\t**\tWe jump here if the data direction was unknown at the \n\t**\ttime we had to queue the command to the scripts processor.\n\t**\tPointers had been set as follow in this situation:\n\t**\t  savep   -->   DATA_IO\n\t**\t  lastp   -->   start pointer when DATA_IN\n\t**\t  goalp   -->   goal  pointer when DATA_IN\n\t**\t  wlastp  -->   start pointer when DATA_OUT\n\t**\t  wgoalp  -->   goal  pointer when DATA_OUT\n\t**\tThis script sets savep/lastp/goalp according to the \n\t**\tdirection chosen by the target.\n\t*/\n\tSCR_JUMPR ^ IFTRUE (WHEN (SCR_DATA_OUT)),\n\t\t32,\n\t/*\n\t**\tDirection is DATA IN.\n\t**\tWarning: we jump here, even when phase is DATA OUT.\n\t*/\n\tSCR_COPY (4),\n\t\tNADDR (header.lastp),\n\t\tNADDR (header.savep),\n\n\t/*\n\t**\tJump to the SCRIPTS according to actual direction.\n\t*/\n\tSCR_COPY (4),\n\t\tNADDR (header.savep),\n\t\tRADDR (temp),\n\tSCR_RETURN,\n\t\t0,\n\t/*\n\t**\tDirection is DATA OUT.\n\t*/\n\tSCR_COPY (4),\n\t\tNADDR (header.wlastp),\n\t\tNADDR (header.lastp),\n\tSCR_COPY (4),\n\t\tNADDR (header.wgoalp),\n\t\tNADDR (header.goalp),\n\tSCR_JUMPR,\n\t\t-64,\n}/*-------------------------< BAD_IDENTIFY >---------------*/,{\n\t/*\n\t**\tIf message phase but not an IDENTIFY,\n\t**\tget some help from the C code.\n\t**\tOld SCSI device may behave so.\n\t*/\n\tSCR_JUMPR ^ IFTRUE (MASK (0x80, 0x80)),\n\t\t16,\n\tSCR_INT,\n\t\tSIR_RESEL_NO_IDENTIFY,\n\tSCR_JUMP,\n\t\tPADDRH (reset),\n\t/*\n\t**\tMessage is an IDENTIFY, but lun is unknown.\n\t**\tRead the message, since we got it directly \n\t**\tfrom the SCSI BUS data lines.\n\t**\tSignal problem to C code for logging the event.\n\t**\tSend an ABORT_TASK_SET to clear all pending tasks.\n\t*/\n\tSCR_INT,\n\t\tSIR_RESEL_BAD_LUN,\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin),\n\tSCR_JUMP,\n\t\tPADDRH (abort),\n}/*-------------------------< BAD_I_T_L >------------------*/,{\n\t/*\n\t**\tWe donnot have a task for that I_T_L.\n\t**\tSignal problem to C code for logging the event.\n\t**\tSend an ABORT_TASK_SET message.\n\t*/\n\tSCR_INT,\n\t\tSIR_RESEL_BAD_I_T_L,\n\tSCR_JUMP,\n\t\tPADDRH (abort),\n}/*-------------------------< BAD_I_T_L_Q >----------------*/,{\n\t/*\n\t**\tWe donnot have a task that matches the tag.\n\t**\tSignal problem to C code for logging the event.\n\t**\tSend an ABORT_TASK message.\n\t*/\n\tSCR_INT,\n\t\tSIR_RESEL_BAD_I_T_L_Q,\n\tSCR_JUMP,\n\t\tPADDRH (aborttag),\n}/*-------------------------< BAD_TARGET >-----------------*/,{\n\t/*\n\t**\tWe donnot know the target that reselected us.\n\t**\tGrab the first message if any (IDENTIFY).\n\t**\tSignal problem to C code for logging the event.\n\t**\tTARGET_RESET message.\n\t*/\n\tSCR_INT,\n\t\tSIR_RESEL_BAD_TARGET,\n\tSCR_JUMPR ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\t8,\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin),\n\tSCR_JUMP,\n\t\tPADDRH (reset),\n}/*-------------------------< BAD_STATUS >-----------------*/,{\n\t/*\n\t**\tIf command resulted in either TASK_SET FULL,\n\t**\tCHECK CONDITION or COMMAND TERMINATED,\n\t**\tcall the C code.\n\t*/\n\tSCR_INT ^ IFTRUE (DATA (SAM_STAT_TASK_SET_FULL)),\n\t\tSIR_BAD_STATUS,\n\tSCR_INT ^ IFTRUE (DATA (SAM_STAT_CHECK_CONDITION)),\n\t\tSIR_BAD_STATUS,\n\tSCR_INT ^ IFTRUE (DATA (SAM_STAT_COMMAND_TERMINATED)),\n\t\tSIR_BAD_STATUS,\n\tSCR_RETURN,\n\t\t0,\n}/*-------------------------< START_RAM >-------------------*/,{\n\t/*\n\t**\tLoad the script into on-chip RAM, \n\t**\tand jump to start point.\n\t*/\n\tSCR_COPY_F (4),\n\t\tRADDR (scratcha),\n\t\tPADDRH (start_ram0),\n\t/*\n\t**\tFlush script prefetch if required\n\t*/\n\tPREFETCH_FLUSH\n\tSCR_COPY (sizeof (struct script)),\n}/*-------------------------< START_RAM0 >--------------------*/,{\n\t\t0,\n\t\tPADDR (start),\n\tSCR_JUMP,\n\t\tPADDR (start),\n}/*-------------------------< STO_RESTART >-------------------*/,{\n\t/*\n\t**\n\t**\tRepair start queue (e.g. next time use the next slot) \n\t**\tand jump to start point.\n\t*/\n\tSCR_COPY (4),\n\t\tRADDR (temp),\n\t\tPADDR (startpos),\n\tSCR_JUMP,\n\t\tPADDR (start),\n}/*-------------------------< WAIT_DMA >-------------------*/,{\n\t/*\n\t**\tFor HP Zalon/53c720 systems, the Zalon interface\n\t**\tbetween CPU and 53c720 does prefetches, which causes\n\t**\tproblems with self modifying scripts.  The problem\n\t**\tis overcome by calling a dummy subroutine after each\n\t**\tmodification, to force a refetch of the script on\n\t**\treturn from the subroutine.\n\t*/\n\tSCR_RETURN,\n\t\t0,\n}/*-------------------------< SNOOPTEST >-------------------*/,{\n\t/*\n\t**\tRead the variable.\n\t*/\n\tSCR_COPY (4),\n\t\tNADDR(ncr_cache),\n\t\tRADDR (scratcha),\n\t/*\n\t**\tWrite the variable.\n\t*/\n\tSCR_COPY (4),\n\t\tRADDR (temp),\n\t\tNADDR(ncr_cache),\n\t/*\n\t**\tRead back the variable.\n\t*/\n\tSCR_COPY (4),\n\t\tNADDR(ncr_cache),\n\t\tRADDR (temp),\n}/*-------------------------< SNOOPEND >-------------------*/,{\n\t/*\n\t**\tAnd stop.\n\t*/\n\tSCR_INT,\n\t\t99,\n}/*--------------------------------------------------------*/\n};\n\n/*==========================================================\n**\n**\n**\tFill in #define dependent parts of the script\n**\n**\n**==========================================================\n*/\n\nvoid __init ncr_script_fill (struct script * scr, struct scripth * scrh)\n{\n\tint\ti;\n\tncrcmd\t*p;\n\n\tp = scrh->tryloop;\n\tfor (i=0; i<MAX_START; i++) {\n\t\t*p++ =SCR_CALL;\n\t\t*p++ =PADDR (idle);\n\t}\n\n\tBUG_ON((u_long)p != (u_long)&scrh->tryloop + sizeof (scrh->tryloop));\n\n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\n\n\tp = scrh->done_queue;\n\tfor (i = 0; i<MAX_DONE; i++) {\n\t\t*p++ =SCR_COPY (sizeof(struct ccb *));\n\t\t*p++ =NADDR (header.cp);\n\t\t*p++ =NADDR (ccb_done[i]);\n\t\t*p++ =SCR_CALL;\n\t\t*p++ =PADDR (done_end);\n\t}\n\n\tBUG_ON((u_long)p != (u_long)&scrh->done_queue+sizeof(scrh->done_queue));\n\n#endif /* SCSI_NCR_CCB_DONE_SUPPORT */\n\n\tp = scrh->hdata_in;\n\tfor (i=0; i<MAX_SCATTERH; i++) {\n\t\t*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN));\n\t\t*p++ =PADDR (dispatch);\n\t\t*p++ =SCR_MOVE_TBL ^ SCR_DATA_IN;\n\t\t*p++ =offsetof (struct dsb, data[i]);\n\t}\n\n\tBUG_ON((u_long)p != (u_long)&scrh->hdata_in + sizeof (scrh->hdata_in));\n\n\tp = scr->data_in;\n\tfor (i=MAX_SCATTERH; i<MAX_SCATTERH+MAX_SCATTERL; i++) {\n\t\t*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN));\n\t\t*p++ =PADDR (dispatch);\n\t\t*p++ =SCR_MOVE_TBL ^ SCR_DATA_IN;\n\t\t*p++ =offsetof (struct dsb, data[i]);\n\t}\n\n\tBUG_ON((u_long)p != (u_long)&scr->data_in + sizeof (scr->data_in));\n\n\tp = scrh->hdata_out;\n\tfor (i=0; i<MAX_SCATTERH; i++) {\n\t\t*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT));\n\t\t*p++ =PADDR (dispatch);\n\t\t*p++ =SCR_MOVE_TBL ^ SCR_DATA_OUT;\n\t\t*p++ =offsetof (struct dsb, data[i]);\n\t}\n\n\tBUG_ON((u_long)p != (u_long)&scrh->hdata_out + sizeof (scrh->hdata_out));\n\n\tp = scr->data_out;\n\tfor (i=MAX_SCATTERH; i<MAX_SCATTERH+MAX_SCATTERL; i++) {\n\t\t*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT));\n\t\t*p++ =PADDR (dispatch);\n\t\t*p++ =SCR_MOVE_TBL ^ SCR_DATA_OUT;\n\t\t*p++ =offsetof (struct dsb, data[i]);\n\t}\n\n\tBUG_ON((u_long) p != (u_long)&scr->data_out + sizeof (scr->data_out));\n}\n\n/*==========================================================\n**\n**\n**\tCopy and rebind a script.\n**\n**\n**==========================================================\n*/\n\nstatic void __init \nncr_script_copy_and_bind (struct ncb *np, ncrcmd *src, ncrcmd *dst, int len)\n{\n\tncrcmd  opcode, new, old, tmp1, tmp2;\n\tncrcmd\t*start, *end;\n\tint relocs;\n\tint opchanged = 0;\n\n\tstart = src;\n\tend = src + len/4;\n\n\twhile (src < end) {\n\n\t\topcode = *src++;\n\t\t*dst++ = cpu_to_scr(opcode);\n\n\t\t/*\n\t\t**\tIf we forget to change the length\n\t\t**\tin struct script, a field will be\n\t\t**\tpadded with 0. This is an illegal\n\t\t**\tcommand.\n\t\t*/\n\n\t\tif (opcode == 0) {\n\t\t\tprintk (KERN_ERR \"%s: ERROR0 IN SCRIPT at %d.\\n\",\n\t\t\t\tncr_name(np), (int) (src-start-1));\n\t\t\tmdelay(1000);\n\t\t}\n\n\t\tif (DEBUG_FLAGS & DEBUG_SCRIPT)\n\t\t\tprintk (KERN_DEBUG \"%p:  <%x>\\n\",\n\t\t\t\t(src-1), (unsigned)opcode);\n\n\t\t/*\n\t\t**\tWe don't have to decode ALL commands\n\t\t*/\n\t\tswitch (opcode >> 28) {\n\n\t\tcase 0xc:\n\t\t\t/*\n\t\t\t**\tCOPY has TWO arguments.\n\t\t\t*/\n\t\t\trelocs = 2;\n\t\t\ttmp1 = src[0];\n#ifdef\tRELOC_KVAR\n\t\t\tif ((tmp1 & RELOC_MASK) == RELOC_KVAR)\n\t\t\t\ttmp1 = 0;\n#endif\n\t\t\ttmp2 = src[1];\n#ifdef\tRELOC_KVAR\n\t\t\tif ((tmp2 & RELOC_MASK) == RELOC_KVAR)\n\t\t\t\ttmp2 = 0;\n#endif\n\t\t\tif ((tmp1 ^ tmp2) & 3) {\n\t\t\t\tprintk (KERN_ERR\"%s: ERROR1 IN SCRIPT at %d.\\n\",\n\t\t\t\t\tncr_name(np), (int) (src-start-1));\n\t\t\t\tmdelay(1000);\n\t\t\t}\n\t\t\t/*\n\t\t\t**\tIf PREFETCH feature not enabled, remove \n\t\t\t**\tthe NO FLUSH bit if present.\n\t\t\t*/\n\t\t\tif ((opcode & SCR_NO_FLUSH) && !(np->features & FE_PFEN)) {\n\t\t\t\tdst[-1] = cpu_to_scr(opcode & ~SCR_NO_FLUSH);\n\t\t\t\t++opchanged;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x0:\n\t\t\t/*\n\t\t\t**\tMOVE (absolute address)\n\t\t\t*/\n\t\t\trelocs = 1;\n\t\t\tbreak;\n\n\t\tcase 0x8:\n\t\t\t/*\n\t\t\t**\tJUMP / CALL\n\t\t\t**\tdon't relocate if relative :-)\n\t\t\t*/\n\t\t\tif (opcode & 0x00800000)\n\t\t\t\trelocs = 0;\n\t\t\telse\n\t\t\t\trelocs = 1;\n\t\t\tbreak;\n\n\t\tcase 0x4:\n\t\tcase 0x5:\n\t\tcase 0x6:\n\t\tcase 0x7:\n\t\t\trelocs = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trelocs = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (relocs) {\n\t\t\twhile (relocs--) {\n\t\t\t\told = *src++;\n\n\t\t\t\tswitch (old & RELOC_MASK) {\n\t\t\t\tcase RELOC_REGISTER:\n\t\t\t\t\tnew = (old & ~RELOC_MASK) + np->paddr;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RELOC_LABEL:\n\t\t\t\t\tnew = (old & ~RELOC_MASK) + np->p_script;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RELOC_LABELH:\n\t\t\t\t\tnew = (old & ~RELOC_MASK) + np->p_scripth;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RELOC_SOFTC:\n\t\t\t\t\tnew = (old & ~RELOC_MASK) + np->p_ncb;\n\t\t\t\t\tbreak;\n#ifdef\tRELOC_KVAR\n\t\t\t\tcase RELOC_KVAR:\n\t\t\t\t\tif (((old & ~RELOC_MASK) <\n\t\t\t\t\t     SCRIPT_KVAR_FIRST) ||\n\t\t\t\t\t    ((old & ~RELOC_MASK) >\n\t\t\t\t\t     SCRIPT_KVAR_LAST))\n\t\t\t\t\t\tpanic(\"ncr KVAR out of range\");\n\t\t\t\t\tnew = vtophys(script_kvars[old &\n\t\t\t\t\t    ~RELOC_MASK]);\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 0:\n\t\t\t\t\t/* Don't relocate a 0 address. */\n\t\t\t\t\tif (old == 0) {\n\t\t\t\t\t\tnew = old;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfallthrough;\n\t\t\t\tdefault:\n\t\t\t\t\tpanic(\"ncr_script_copy_and_bind: weird relocation %x\\n\", old);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t*dst++ = cpu_to_scr(new);\n\t\t\t}\n\t\t} else\n\t\t\t*dst++ = cpu_to_scr(*src++);\n\n\t}\n}\n\n/*\n**\tLinux host data structure\n*/\n\nstruct host_data {\n     struct ncb *ncb;\n};\n\n#define PRINT_ADDR(cmd, arg...) dev_info(&cmd->device->sdev_gendev , ## arg)\n\nstatic void ncr_print_msg(struct ccb *cp, char *label, u_char *msg)\n{\n\tPRINT_ADDR(cp->cmd, \"%s: \", label);\n\n\tspi_print_msg(msg);\n\tprintk(\"\\n\");\n}\n\n/*==========================================================\n**\n**\tNCR chip clock divisor table.\n**\tDivisors are multiplied by 10,000,000 in order to make \n**\tcalculations more simple.\n**\n**==========================================================\n*/\n\n#define _5M 5000000\nstatic u_long div_10M[] =\n\t{2*_5M, 3*_5M, 4*_5M, 6*_5M, 8*_5M, 12*_5M, 16*_5M};\n\n\n/*===============================================================\n**\n**\tPrepare io register values used by ncr_init() according \n**\tto selected and supported features.\n**\n**\tNCR chips allow burst lengths of 2, 4, 8, 16, 32, 64, 128 \n**\ttransfers. 32,64,128 are only supported by 875 and 895 chips.\n**\tWe use log base 2 (burst length) as internal code, with \n**\tvalue 0 meaning \"burst disabled\".\n**\n**===============================================================\n*/\n\n/*\n *\tBurst length from burst code.\n */\n#define burst_length(bc) (!(bc))? 0 : 1 << (bc)\n\n/*\n *\tBurst code from io register bits.  Burst enable is ctest0 for c720\n */\n#define burst_code(dmode, ctest0) \\\n\t(ctest0) & 0x80 ? 0 : (((dmode) & 0xc0) >> 6) + 1\n\n/*\n *\tSet initial io register bits from burst code.\n */\nstatic inline void ncr_init_burst(struct ncb *np, u_char bc)\n{\n\tu_char *be = &np->rv_ctest0;\n\t*be\t\t&= ~0x80;\n\tnp->rv_dmode\t&= ~(0x3 << 6);\n\tnp->rv_ctest5\t&= ~0x4;\n\n\tif (!bc) {\n\t\t*be\t\t|= 0x80;\n\t} else {\n\t\t--bc;\n\t\tnp->rv_dmode\t|= ((bc & 0x3) << 6);\n\t\tnp->rv_ctest5\t|= (bc & 0x4);\n\t}\n}\n\nstatic void __init ncr_prepare_setting(struct ncb *np)\n{\n\tu_char\tburst_max;\n\tu_long\tperiod;\n\tint i;\n\n\t/*\n\t**\tSave assumed BIOS setting\n\t*/\n\n\tnp->sv_scntl0\t= INB(nc_scntl0) & 0x0a;\n\tnp->sv_scntl3\t= INB(nc_scntl3) & 0x07;\n\tnp->sv_dmode\t= INB(nc_dmode)  & 0xce;\n\tnp->sv_dcntl\t= INB(nc_dcntl)  & 0xa8;\n\tnp->sv_ctest0\t= INB(nc_ctest0) & 0x84;\n\tnp->sv_ctest3\t= INB(nc_ctest3) & 0x01;\n\tnp->sv_ctest4\t= INB(nc_ctest4) & 0x80;\n\tnp->sv_ctest5\t= INB(nc_ctest5) & 0x24;\n\tnp->sv_gpcntl\t= INB(nc_gpcntl);\n\tnp->sv_stest2\t= INB(nc_stest2) & 0x20;\n\tnp->sv_stest4\t= INB(nc_stest4);\n\n\t/*\n\t**\tWide ?\n\t*/\n\n\tnp->maxwide\t= (np->features & FE_WIDE)? 1 : 0;\n\n \t/*\n\t *  Guess the frequency of the chip's clock.\n\t */\n\tif (np->features & FE_ULTRA)\n\t\tnp->clock_khz = 80000;\n\telse\n\t\tnp->clock_khz = 40000;\n\n\t/*\n\t *  Get the clock multiplier factor.\n \t */\n\tif\t(np->features & FE_QUAD)\n\t\tnp->multiplier\t= 4;\n\telse if\t(np->features & FE_DBLR)\n\t\tnp->multiplier\t= 2;\n\telse\n\t\tnp->multiplier\t= 1;\n\n\t/*\n\t *  Measure SCSI clock frequency for chips \n\t *  it may vary from assumed one.\n\t */\n\tif (np->features & FE_VARCLK)\n\t\tncr_getclock(np, np->multiplier);\n\n\t/*\n\t * Divisor to be used for async (timer pre-scaler).\n\t */\n\ti = np->clock_divn - 1;\n\twhile (--i >= 0) {\n\t\tif (10ul * SCSI_NCR_MIN_ASYNC * np->clock_khz > div_10M[i]) {\n\t\t\t++i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tnp->rv_scntl3 = i+1;\n\n\t/*\n\t * Minimum synchronous period factor supported by the chip.\n\t * Btw, 'period' is in tenths of nanoseconds.\n\t */\n\n\tperiod = (4 * div_10M[0] + np->clock_khz - 1) / np->clock_khz;\n\tif\t(period <= 250)\t\tnp->minsync = 10;\n\telse if\t(period <= 303)\t\tnp->minsync = 11;\n\telse if\t(period <= 500)\t\tnp->minsync = 12;\n\telse\t\t\t\tnp->minsync = (period + 40 - 1) / 40;\n\n\t/*\n\t * Check against chip SCSI standard support (SCSI-2,ULTRA,ULTRA2).\n\t */\n\n\tif\t(np->minsync < 25 && !(np->features & FE_ULTRA))\n\t\tnp->minsync = 25;\n\n\t/*\n\t * Maximum synchronous period factor supported by the chip.\n\t */\n\n\tperiod = (11 * div_10M[np->clock_divn - 1]) / (4 * np->clock_khz);\n\tnp->maxsync = period > 2540 ? 254 : period / 10;\n\n\t/*\n\t**\tPrepare initial value of other IO registers\n\t*/\n#if defined SCSI_NCR_TRUST_BIOS_SETTING\n\tnp->rv_scntl0\t= np->sv_scntl0;\n\tnp->rv_dmode\t= np->sv_dmode;\n\tnp->rv_dcntl\t= np->sv_dcntl;\n\tnp->rv_ctest0\t= np->sv_ctest0;\n\tnp->rv_ctest3\t= np->sv_ctest3;\n\tnp->rv_ctest4\t= np->sv_ctest4;\n\tnp->rv_ctest5\t= np->sv_ctest5;\n\tburst_max\t= burst_code(np->sv_dmode, np->sv_ctest0);\n#else\n\n\t/*\n\t**\tSelect burst length (dwords)\n\t*/\n\tburst_max\t= driver_setup.burst_max;\n\tif (burst_max == 255)\n\t\tburst_max = burst_code(np->sv_dmode, np->sv_ctest0);\n\tif (burst_max > 7)\n\t\tburst_max = 7;\n\tif (burst_max > np->maxburst)\n\t\tburst_max = np->maxburst;\n\n\t/*\n\t**\tSelect all supported special features\n\t*/\n\tif (np->features & FE_ERL)\n\t\tnp->rv_dmode\t|= ERL;\t\t/* Enable Read Line */\n\tif (np->features & FE_BOF)\n\t\tnp->rv_dmode\t|= BOF;\t\t/* Burst Opcode Fetch */\n\tif (np->features & FE_ERMP)\n\t\tnp->rv_dmode\t|= ERMP;\t/* Enable Read Multiple */\n\tif (np->features & FE_PFEN)\n\t\tnp->rv_dcntl\t|= PFEN;\t/* Prefetch Enable */\n\tif (np->features & FE_CLSE)\n\t\tnp->rv_dcntl\t|= CLSE;\t/* Cache Line Size Enable */\n\tif (np->features & FE_WRIE)\n\t\tnp->rv_ctest3\t|= WRIE;\t/* Write and Invalidate */\n\tif (np->features & FE_DFS)\n\t\tnp->rv_ctest5\t|= DFS;\t\t/* Dma Fifo Size */\n\tif (np->features & FE_MUX)\n\t\tnp->rv_ctest4\t|= MUX;\t\t/* Host bus multiplex mode */\n\tif (np->features & FE_EA)\n\t\tnp->rv_dcntl\t|= EA;\t\t/* Enable ACK */\n\tif (np->features & FE_EHP)\n\t\tnp->rv_ctest0\t|= EHP;\t\t/* Even host parity */\n\n\t/*\n\t**\tSelect some other\n\t*/\n\tif (driver_setup.master_parity)\n\t\tnp->rv_ctest4\t|= MPEE;\t/* Master parity checking */\n\tif (driver_setup.scsi_parity)\n\t\tnp->rv_scntl0\t|= 0x0a;\t/*  full arb., ena parity, par->ATN  */\n\n\t/*\n\t**  Get SCSI addr of host adapter (set by bios?).\n\t*/\n\tif (np->myaddr == 255) {\n\t\tnp->myaddr = INB(nc_scid) & 0x07;\n\t\tif (!np->myaddr)\n\t\t\tnp->myaddr = SCSI_NCR_MYADDR;\n\t}\n\n#endif /* SCSI_NCR_TRUST_BIOS_SETTING */\n\n\t/*\n\t *\tPrepare initial io register bits for burst length\n\t */\n\tncr_init_burst(np, burst_max);\n\n\t/*\n\t**\tSet SCSI BUS mode.\n\t**\n\t**\t- ULTRA2 chips (895/895A/896) report the current \n\t**\t  BUS mode through the STEST4 IO register.\n\t**\t- For previous generation chips (825/825A/875), \n\t**\t  user has to tell us how to check against HVD, \n\t**\t  since a 100% safe algorithm is not possible.\n\t*/\n\tnp->scsi_mode = SMODE_SE;\n\tif (np->features & FE_DIFF) {\n\t\tswitch(driver_setup.diff_support) {\n\t\tcase 4:\t/* Trust previous settings if present, then GPIO3 */\n\t\t\tif (np->sv_scntl3) {\n\t\t\t\tif (np->sv_stest2 & 0x20)\n\t\t\t\t\tnp->scsi_mode = SMODE_HVD;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase 3:\t/* SYMBIOS controllers report HVD through GPIO3 */\n\t\t\tif (INB(nc_gpreg) & 0x08)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase 2:\t/* Set HVD unconditionally */\n\t\t\tnp->scsi_mode = SMODE_HVD;\n\t\t\tfallthrough;\n\t\tcase 1:\t/* Trust previous settings for HVD */\n\t\t\tif (np->sv_stest2 & 0x20)\n\t\t\t\tnp->scsi_mode = SMODE_HVD;\n\t\t\tbreak;\n\t\tdefault:/* Don't care about HVD */\t\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (np->scsi_mode == SMODE_HVD)\n\t\tnp->rv_stest2 |= 0x20;\n\n\t/*\n\t**\tSet LED support from SCRIPTS.\n\t**\tIgnore this feature for boards known to use a \n\t**\tspecific GPIO wiring and for the 895A or 896 \n\t**\tthat drive the LED directly.\n\t**\tAlso probe initial setting of GPIO0 as output.\n\t*/\n\tif ((driver_setup.led_pin) &&\n\t    !(np->features & FE_LEDC) && !(np->sv_gpcntl & 0x01))\n\t\tnp->features |= FE_LED0;\n\n\t/*\n\t**\tSet irq mode.\n\t*/\n\tswitch(driver_setup.irqm & 3) {\n\tcase 2:\n\t\tnp->rv_dcntl\t|= IRQM;\n\t\tbreak;\n\tcase 1:\n\t\tnp->rv_dcntl\t|= (np->sv_dcntl & IRQM);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t**\tConfigure targets according to driver setup.\n\t**\tAllow to override sync, wide and NOSCAN from \n\t**\tboot command line.\n\t*/\n\tfor (i = 0 ; i < MAX_TARGET ; i++) {\n\t\tstruct tcb *tp = &np->target[i];\n\n\t\ttp->usrsync = driver_setup.default_sync;\n\t\ttp->usrwide = driver_setup.max_wide;\n\t\ttp->usrtags = MAX_TAGS;\n\t\ttp->period = 0xffff;\n\t\tif (!driver_setup.disconnection)\n\t\t\tnp->target[i].usrflag = UF_NODISC;\n\t}\n\n\t/*\n\t**\tAnnounce all that stuff to user.\n\t*/\n\n\tprintk(KERN_INFO \"%s: ID %d, Fast-%d%s%s\\n\", ncr_name(np),\n\t\tnp->myaddr,\n\t\tnp->minsync < 12 ? 40 : (np->minsync < 25 ? 20 : 10),\n\t\t(np->rv_scntl0 & 0xa)\t? \", Parity Checking\"\t: \", NO Parity\",\n\t\t(np->rv_stest2 & 0x20)\t? \", Differential\"\t: \"\");\n\n\tif (bootverbose > 1) {\n\t\tprintk (KERN_INFO \"%s: initial SCNTL3/DMODE/DCNTL/CTEST3/4/5 = \"\n\t\t\t\"(hex) %02x/%02x/%02x/%02x/%02x/%02x\\n\",\n\t\t\tncr_name(np), np->sv_scntl3, np->sv_dmode, np->sv_dcntl,\n\t\t\tnp->sv_ctest3, np->sv_ctest4, np->sv_ctest5);\n\n\t\tprintk (KERN_INFO \"%s: final   SCNTL3/DMODE/DCNTL/CTEST3/4/5 = \"\n\t\t\t\"(hex) %02x/%02x/%02x/%02x/%02x/%02x\\n\",\n\t\t\tncr_name(np), np->rv_scntl3, np->rv_dmode, np->rv_dcntl,\n\t\t\tnp->rv_ctest3, np->rv_ctest4, np->rv_ctest5);\n\t}\n\n\tif (bootverbose && np->paddr2)\n\t\tprintk (KERN_INFO \"%s: on-chip RAM at 0x%lx\\n\",\n\t\t\tncr_name(np), np->paddr2);\n}\n\n/*==========================================================\n**\n**\n**\tDone SCSI commands list management.\n**\n**\tWe donnot enter the scsi_done() callback immediately \n**\tafter a command has been seen as completed but we \n**\tinsert it into a list which is flushed outside any kind \n**\tof driver critical section.\n**\tThis allows to do minimal stuff under interrupt and \n**\tinside critical sections and to also avoid locking up \n**\ton recursive calls to driver entry points under SMP.\n**\tIn fact, the only kernel point which is entered by the \n**\tdriver with a driver lock set is kmalloc(GFP_ATOMIC) \n**\tthat shall not reenter the driver under any circumstances,\n**\tAFAIK.\n**\n**==========================================================\n*/\nstatic inline void ncr_queue_done_cmd(struct ncb *np, struct scsi_cmnd *cmd)\n{\n\tunmap_scsi_data(np, cmd);\n\tcmd->host_scribble = (char *) np->done_list;\n\tnp->done_list = cmd;\n}\n\nstatic inline void ncr_flush_done_cmds(struct scsi_cmnd *lcmd)\n{\n\tstruct scsi_cmnd *cmd;\n\n\twhile (lcmd) {\n\t\tcmd = lcmd;\n\t\tlcmd = (struct scsi_cmnd *) cmd->host_scribble;\n\t\tcmd->scsi_done(cmd);\n\t}\n}\n\n/*==========================================================\n**\n**\n**\tPrepare the next negotiation message if needed.\n**\n**\tFill in the part of message buffer that contains the \n**\tnegotiation and the nego_status field of the CCB.\n**\tReturns the size of the message in bytes.\n**\n**\n**==========================================================\n*/\n\n\nstatic int ncr_prepare_nego(struct ncb *np, struct ccb *cp, u_char *msgptr)\n{\n\tstruct tcb *tp = &np->target[cp->target];\n\tint msglen = 0;\n\tint nego = 0;\n\tstruct scsi_target *starget = tp->starget;\n\n\t/* negotiate wide transfers ?  */\n\tif (!tp->widedone) {\n\t\tif (spi_support_wide(starget)) {\n\t\t\tnego = NS_WIDE;\n\t\t} else\n\t\t\ttp->widedone=1;\n\t}\n\n\t/* negotiate synchronous transfers?  */\n\tif (!nego && !tp->period) {\n\t\tif (spi_support_sync(starget)) {\n\t\t\tnego = NS_SYNC;\n\t\t} else {\n\t\t\ttp->period  =0xffff;\n\t\t\tdev_info(&starget->dev, \"target did not report SYNC.\\n\");\n\t\t}\n\t}\n\n\tswitch (nego) {\n\tcase NS_SYNC:\n\t\tmsglen += spi_populate_sync_msg(msgptr + msglen,\n\t\t\t\ttp->maxoffs ? tp->minsync : 0, tp->maxoffs);\n\t\tbreak;\n\tcase NS_WIDE:\n\t\tmsglen += spi_populate_width_msg(msgptr + msglen, tp->usrwide);\n\t\tbreak;\n\t}\n\n\tcp->nego_status = nego;\n\n\tif (nego) {\n\t\ttp->nego_cp = cp;\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tncr_print_msg(cp, nego == NS_WIDE ?\n\t\t\t\t\t  \"wide msgout\":\"sync_msgout\", msgptr);\n\t\t}\n\t}\n\n\treturn msglen;\n}\n\n\n\n/*==========================================================\n**\n**\n**\tStart execution of a SCSI command.\n**\tThis is called from the generic SCSI driver.\n**\n**\n**==========================================================\n*/\nstatic int ncr_queue_command (struct ncb *np, struct scsi_cmnd *cmd)\n{\n\tstruct scsi_device *sdev = cmd->device;\n\tstruct tcb *tp = &np->target[sdev->id];\n\tstruct lcb *lp = tp->lp[sdev->lun];\n\tstruct ccb *cp;\n\n\tint\tsegments;\n\tu_char\tidmsg, *msgptr;\n\tu32\tmsglen;\n\tint\tdirection;\n\tu32\tlastp, goalp;\n\n\t/*---------------------------------------------\n\t**\n\t**      Some shortcuts ...\n\t**\n\t**---------------------------------------------\n\t*/\n\tif ((sdev->id == np->myaddr\t  ) ||\n\t\t(sdev->id >= MAX_TARGET) ||\n\t\t(sdev->lun    >= MAX_LUN   )) {\n\t\treturn(DID_BAD_TARGET);\n\t}\n\n\t/*---------------------------------------------\n\t**\n\t**\tComplete the 1st TEST UNIT READY command\n\t**\twith error condition if the device is \n\t**\tflagged NOSCAN, in order to speed up \n\t**\tthe boot.\n\t**\n\t**---------------------------------------------\n\t*/\n\tif ((cmd->cmnd[0] == 0 || cmd->cmnd[0] == 0x12) && \n\t    (tp->usrflag & UF_NOSCAN)) {\n\t\ttp->usrflag &= ~UF_NOSCAN;\n\t\treturn DID_BAD_TARGET;\n\t}\n\n\tif (DEBUG_FLAGS & DEBUG_TINY) {\n\t\tPRINT_ADDR(cmd, \"CMD=%x \", cmd->cmnd[0]);\n\t}\n\n\t/*---------------------------------------------------\n\t**\n\t**\tAssign a ccb / bind cmd.\n\t**\tIf resetting, shorten settle_time if necessary\n\t**\tin order to avoid spurious timeouts.\n\t**\tIf resetting or no free ccb,\n\t**\tinsert cmd into the waiting list.\n\t**\n\t**----------------------------------------------------\n\t*/\n\tif (np->settle_time && cmd->request->timeout >= HZ) {\n\t\tu_long tlimit = jiffies + cmd->request->timeout - HZ;\n\t\tif (time_after(np->settle_time, tlimit))\n\t\t\tnp->settle_time = tlimit;\n\t}\n\n\tif (np->settle_time || !(cp=ncr_get_ccb (np, cmd))) {\n\t\tinsert_into_waiting_list(np, cmd);\n\t\treturn(DID_OK);\n\t}\n\tcp->cmd = cmd;\n\n\t/*----------------------------------------------------\n\t**\n\t**\tBuild the identify / tag / sdtr message\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tidmsg = IDENTIFY(0, sdev->lun);\n\n\tif (cp ->tag != NO_TAG ||\n\t\t(cp != np->ccb && np->disc && !(tp->usrflag & UF_NODISC)))\n\t\tidmsg |= 0x40;\n\n\tmsgptr = cp->scsi_smsg;\n\tmsglen = 0;\n\tmsgptr[msglen++] = idmsg;\n\n\tif (cp->tag != NO_TAG) {\n\t\tchar order = np->order;\n\n\t\t/*\n\t\t**\tForce ordered tag if necessary to avoid timeouts \n\t\t**\tand to preserve interactivity.\n\t\t*/\n\t\tif (lp && time_after(jiffies, lp->tags_stime)) {\n\t\t\tif (lp->tags_smap) {\n\t\t\t\torder = ORDERED_QUEUE_TAG;\n\t\t\t\tif ((DEBUG_FLAGS & DEBUG_TAGS)||bootverbose>2){ \n\t\t\t\t\tPRINT_ADDR(cmd,\n\t\t\t\t\t\t\"ordered tag forced.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tlp->tags_stime = jiffies + 3*HZ;\n\t\t\tlp->tags_smap = lp->tags_umap;\n\t\t}\n\n\t\tif (order == 0) {\n\t\t\t/*\n\t\t\t**\tOrdered write ops, unordered read ops.\n\t\t\t*/\n\t\t\tswitch (cmd->cmnd[0]) {\n\t\t\tcase 0x08:  /* READ_SMALL (6) */\n\t\t\tcase 0x28:  /* READ_BIG  (10) */\n\t\t\tcase 0xa8:  /* READ_HUGE (12) */\n\t\t\t\torder = SIMPLE_QUEUE_TAG;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\torder = ORDERED_QUEUE_TAG;\n\t\t\t}\n\t\t}\n\t\tmsgptr[msglen++] = order;\n\t\t/*\n\t\t**\tActual tags are numbered 1,3,5,..2*MAXTAGS+1,\n\t\t**\tsince we may have to deal with devices that have \n\t\t**\tproblems with #TAG 0 or too great #TAG numbers.\n\t\t*/\n\t\tmsgptr[msglen++] = (cp->tag << 1) + 1;\n\t}\n\n\t/*----------------------------------------------------\n\t**\n\t**\tBuild the data descriptors\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tdirection = cmd->sc_data_direction;\n\tif (direction != DMA_NONE) {\n\t\tsegments = ncr_scatter(np, cp, cp->cmd);\n\t\tif (segments < 0) {\n\t\t\tncr_free_ccb(np, cp);\n\t\t\treturn(DID_ERROR);\n\t\t}\n\t}\n\telse {\n\t\tcp->data_len = 0;\n\t\tsegments = 0;\n\t}\n\n\t/*---------------------------------------------------\n\t**\n\t**\tnegotiation required?\n\t**\n\t**\t(nego_status is filled by ncr_prepare_nego())\n\t**\n\t**---------------------------------------------------\n\t*/\n\n\tcp->nego_status = 0;\n\n\tif ((!tp->widedone || !tp->period) && !tp->nego_cp && lp) {\n\t\tmsglen += ncr_prepare_nego (np, cp, msgptr + msglen);\n\t}\n\n\t/*----------------------------------------------------\n\t**\n\t**\tDetermine xfer direction.\n\t**\n\t**----------------------------------------------------\n\t*/\n\tif (!cp->data_len)\n\t\tdirection = DMA_NONE;\n\n\t/*\n\t**\tIf data direction is BIDIRECTIONAL, speculate FROM_DEVICE\n\t**\tbut prepare alternate pointers for TO_DEVICE in case \n\t**\tof our speculation will be just wrong.\n\t**\tSCRIPTS will swap values if needed.\n\t*/\n\tswitch(direction) {\n\tcase DMA_BIDIRECTIONAL:\n\tcase DMA_TO_DEVICE:\n\t\tgoalp = NCB_SCRIPT_PHYS (np, data_out2) + 8;\n\t\tif (segments <= MAX_SCATTERL)\n\t\t\tlastp = goalp - 8 - (segments * 16);\n\t\telse {\n\t\t\tlastp = NCB_SCRIPTH_PHYS (np, hdata_out2);\n\t\t\tlastp -= (segments - MAX_SCATTERL) * 16;\n\t\t}\n\t\tif (direction != DMA_BIDIRECTIONAL)\n\t\t\tbreak;\n\t\tcp->phys.header.wgoalp\t= cpu_to_scr(goalp);\n\t\tcp->phys.header.wlastp\t= cpu_to_scr(lastp);\n\t\tfallthrough;\n\tcase DMA_FROM_DEVICE:\n\t\tgoalp = NCB_SCRIPT_PHYS (np, data_in2) + 8;\n\t\tif (segments <= MAX_SCATTERL)\n\t\t\tlastp = goalp - 8 - (segments * 16);\n\t\telse {\n\t\t\tlastp = NCB_SCRIPTH_PHYS (np, hdata_in2);\n\t\t\tlastp -= (segments - MAX_SCATTERL) * 16;\n\t\t}\n\t\tbreak;\n\tdefault:\n\tcase DMA_NONE:\n\t\tlastp = goalp = NCB_SCRIPT_PHYS (np, no_data);\n\t\tbreak;\n\t}\n\n\t/*\n\t**\tSet all pointers values needed by SCRIPTS.\n\t**\tIf direction is unknown, start at data_io.\n\t*/\n\tcp->phys.header.lastp = cpu_to_scr(lastp);\n\tcp->phys.header.goalp = cpu_to_scr(goalp);\n\n\tif (direction == DMA_BIDIRECTIONAL)\n\t\tcp->phys.header.savep = \n\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS (np, data_io));\n\telse\n\t\tcp->phys.header.savep= cpu_to_scr(lastp);\n\n\t/*\n\t**\tSave the initial data pointer in order to be able \n\t**\tto redo the command.\n\t*/\n\tcp->startp = cp->phys.header.savep;\n\n\t/*----------------------------------------------------\n\t**\n\t**\tfill in ccb\n\t**\n\t**----------------------------------------------------\n\t**\n\t**\n\t**\tphysical -> virtual backlink\n\t**\tGeneric SCSI command\n\t*/\n\n\t/*\n\t**\tStartqueue\n\t*/\n\tcp->start.schedule.l_paddr   = cpu_to_scr(NCB_SCRIPT_PHYS (np, select));\n\tcp->restart.schedule.l_paddr = cpu_to_scr(NCB_SCRIPT_PHYS (np, resel_dsa));\n\t/*\n\t**\tselect\n\t*/\n\tcp->phys.select.sel_id\t\t= sdev_id(sdev);\n\tcp->phys.select.sel_scntl3\t= tp->wval;\n\tcp->phys.select.sel_sxfer\t= tp->sval;\n\t/*\n\t**\tmessage\n\t*/\n\tcp->phys.smsg.addr\t\t= cpu_to_scr(CCB_PHYS (cp, scsi_smsg));\n\tcp->phys.smsg.size\t\t= cpu_to_scr(msglen);\n\n\t/*\n\t**\tcommand\n\t*/\n\tmemcpy(cp->cdb_buf, cmd->cmnd, min_t(int, cmd->cmd_len, sizeof(cp->cdb_buf)));\n\tcp->phys.cmd.addr\t\t= cpu_to_scr(CCB_PHYS (cp, cdb_buf[0]));\n\tcp->phys.cmd.size\t\t= cpu_to_scr(cmd->cmd_len);\n\n\t/*\n\t**\tstatus\n\t*/\n\tcp->actualquirks\t\t= 0;\n\tcp->host_status\t\t\t= cp->nego_status ? HS_NEGOTIATE : HS_BUSY;\n\tcp->scsi_status\t\t\t= SAM_STAT_ILLEGAL;\n\tcp->parity_status\t\t= 0;\n\n\tcp->xerr_status\t\t\t= XE_OK;\n#if 0\n\tcp->sync_status\t\t\t= tp->sval;\n\tcp->wide_status\t\t\t= tp->wval;\n#endif\n\n\t/*----------------------------------------------------\n\t**\n\t**\tCritical region: start this job.\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\t/* activate this job.  */\n\tcp->magic\t\t= CCB_MAGIC;\n\n\t/*\n\t**\tinsert next CCBs into start queue.\n\t**\t2 max at a time is enough to flush the CCB wait queue.\n\t*/\n\tcp->auto_sense = 0;\n\tif (lp)\n\t\tncr_start_next_ccb(np, lp, 2);\n\telse\n\t\tncr_put_start_queue(np, cp);\n\n\t/* Command is successfully queued.  */\n\n\treturn DID_OK;\n}\n\n\n/*==========================================================\n**\n**\n**\tInsert a CCB into the start queue and wake up the \n**\tSCRIPTS processor.\n**\n**\n**==========================================================\n*/\n\nstatic void ncr_start_next_ccb(struct ncb *np, struct lcb *lp, int maxn)\n{\n\tstruct list_head *qp;\n\tstruct ccb *cp;\n\n\tif (lp->held_ccb)\n\t\treturn;\n\n\twhile (maxn-- && lp->queuedccbs < lp->queuedepth) {\n\t\tqp = ncr_list_pop(&lp->wait_ccbq);\n\t\tif (!qp)\n\t\t\tbreak;\n\t\t++lp->queuedccbs;\n\t\tcp = list_entry(qp, struct ccb, link_ccbq);\n\t\tlist_add_tail(qp, &lp->busy_ccbq);\n\t\tlp->jump_ccb[cp->tag == NO_TAG ? 0 : cp->tag] =\n\t\t\tcpu_to_scr(CCB_PHYS (cp, restart));\n\t\tncr_put_start_queue(np, cp);\n\t}\n}\n\nstatic void ncr_put_start_queue(struct ncb *np, struct ccb *cp)\n{\n\tu16\tqidx;\n\n\t/*\n\t**\tinsert into start queue.\n\t*/\n\tif (!np->squeueput) np->squeueput = 1;\n\tqidx = np->squeueput + 2;\n\tif (qidx >= MAX_START + MAX_START) qidx = 1;\n\n\tnp->scripth->tryloop [qidx] = cpu_to_scr(NCB_SCRIPT_PHYS (np, idle));\n\tMEMORY_BARRIER();\n\tnp->scripth->tryloop [np->squeueput] = cpu_to_scr(CCB_PHYS (cp, start));\n\n\tnp->squeueput = qidx;\n\t++np->queuedccbs;\n\tcp->queued = 1;\n\n\tif (DEBUG_FLAGS & DEBUG_QUEUE)\n\t\tprintk (\"%s: queuepos=%d.\\n\", ncr_name (np), np->squeueput);\n\n\t/*\n\t**\tScript processor may be waiting for reselect.\n\t**\tWake it up.\n\t*/\n\tMEMORY_BARRIER();\n\tOUTB (nc_istat, SIGP);\n}\n\n\nstatic int ncr_reset_scsi_bus(struct ncb *np, int enab_int, int settle_delay)\n{\n\tu32 term;\n\tint retv = 0;\n\n\tnp->settle_time\t= jiffies + settle_delay * HZ;\n\n\tif (bootverbose > 1)\n\t\tprintk(\"%s: resetting, \"\n\t\t\t\"command processing suspended for %d seconds\\n\",\n\t\t\tncr_name(np), settle_delay);\n\n\tncr_chip_reset(np, 100);\n\tudelay(2000);\t/* The 895 needs time for the bus mode to settle */\n\tif (enab_int)\n\t\tOUTW (nc_sien, RST);\n\t/*\n\t**\tEnable Tolerant, reset IRQD if present and \n\t**\tproperly set IRQ mode, prior to resetting the bus.\n\t*/\n\tOUTB (nc_stest3, TE);\n\tOUTB (nc_scntl1, CRST);\n\tudelay(200);\n\n\tif (!driver_setup.bus_check)\n\t\tgoto out;\n\t/*\n\t**\tCheck for no terminators or SCSI bus shorts to ground.\n\t**\tRead SCSI data bus, data parity bits and control signals.\n\t**\tWe are expecting RESET to be TRUE and other signals to be \n\t**\tFALSE.\n\t*/\n\n\tterm =\tINB(nc_sstat0);\n\tterm =\t((term & 2) << 7) + ((term & 1) << 17);\t/* rst sdp0 */\n\tterm |= ((INB(nc_sstat2) & 0x01) << 26) |\t/* sdp1     */\n\t\t((INW(nc_sbdl) & 0xff)   << 9)  |\t/* d7-0     */\n\t\t((INW(nc_sbdl) & 0xff00) << 10) |\t/* d15-8    */\n\t\tINB(nc_sbcl);\t/* req ack bsy sel atn msg cd io    */\n\n\tif (!(np->features & FE_WIDE))\n\t\tterm &= 0x3ffff;\n\n\tif (term != (2<<7)) {\n\t\tprintk(\"%s: suspicious SCSI data while resetting the BUS.\\n\",\n\t\t\tncr_name(np));\n\t\tprintk(\"%s: %sdp0,d7-0,rst,req,ack,bsy,sel,atn,msg,c/d,i/o = \"\n\t\t\t\"0x%lx, expecting 0x%lx\\n\",\n\t\t\tncr_name(np),\n\t\t\t(np->features & FE_WIDE) ? \"dp1,d15-8,\" : \"\",\n\t\t\t(u_long)term, (u_long)(2<<7));\n\t\tif (driver_setup.bus_check == 1)\n\t\t\tretv = 1;\n\t}\nout:\n\tOUTB (nc_scntl1, 0);\n\treturn retv;\n}\n\n/*\n * Start reset process.\n * If reset in progress do nothing.\n * The interrupt handler will reinitialize the chip.\n * The timeout handler will wait for settle_time before \n * clearing it and so resuming command processing.\n */\nstatic void ncr_start_reset(struct ncb *np)\n{\n\tif (!np->settle_time) {\n\t\tncr_reset_scsi_bus(np, 1, driver_setup.settle_delay);\n \t}\n}\n \n/*==========================================================\n**\n**\n**\tReset the SCSI BUS.\n**\tThis is called from the generic SCSI driver.\n**\n**\n**==========================================================\n*/\nstatic int ncr_reset_bus (struct ncb *np, struct scsi_cmnd *cmd, int sync_reset)\n{\n/*\tstruct scsi_device        *device    = cmd->device; */\n\tstruct ccb *cp;\n\tint found;\n\n/*\n * Return immediately if reset is in progress.\n */\n\tif (np->settle_time) {\n\t\treturn FAILED;\n\t}\n/*\n * Start the reset process.\n * The script processor is then assumed to be stopped.\n * Commands will now be queued in the waiting list until a settle \n * delay of 2 seconds will be completed.\n */\n\tncr_start_reset(np);\n/*\n * First, look in the wakeup list\n */\n\tfor (found=0, cp=np->ccb; cp; cp=cp->link_ccb) {\n\t\t/*\n\t\t**\tlook for the ccb of this command.\n\t\t*/\n\t\tif (cp->host_status == HS_IDLE) continue;\n\t\tif (cp->cmd == cmd) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n/*\n * Then, look in the waiting list\n */\n\tif (!found && retrieve_from_waiting_list(0, np, cmd))\n\t\tfound = 1;\n/*\n * Wake-up all awaiting commands with DID_RESET.\n */\n\treset_waiting_list(np);\n/*\n * Wake-up all pending commands with HS_RESET -> DID_RESET.\n */\n\tncr_wakeup(np, HS_RESET);\n/*\n * If the involved command was not in a driver queue, and the \n * scsi driver told us reset is synchronous, and the command is not \n * currently in the waiting list, complete it with DID_RESET status,\n * in order to keep it alive.\n */\n\tif (!found && sync_reset && !retrieve_from_waiting_list(0, np, cmd)) {\n\t\tset_host_byte(cmd, DID_RESET);\n\t\tncr_queue_done_cmd(np, cmd);\n\t}\n\n\treturn SUCCESS;\n}\n\n#if 0 /* unused and broken.. */\n/*==========================================================\n**\n**\n**\tAbort an SCSI command.\n**\tThis is called from the generic SCSI driver.\n**\n**\n**==========================================================\n*/\nstatic int ncr_abort_command (struct ncb *np, struct scsi_cmnd *cmd)\n{\n/*\tstruct scsi_device        *device    = cmd->device; */\n\tstruct ccb *cp;\n\tint found;\n\tint retv;\n\n/*\n * First, look for the scsi command in the waiting list\n */\n\tif (remove_from_waiting_list(np, cmd)) {\n\t\tset_host_byte(cmd, DID_ABORT);\n\t\tncr_queue_done_cmd(np, cmd);\n\t\treturn SCSI_ABORT_SUCCESS;\n\t}\n\n/*\n * Then, look in the wakeup list\n */\n\tfor (found=0, cp=np->ccb; cp; cp=cp->link_ccb) {\n\t\t/*\n\t\t**\tlook for the ccb of this command.\n\t\t*/\n\t\tif (cp->host_status == HS_IDLE) continue;\n\t\tif (cp->cmd == cmd) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\treturn SCSI_ABORT_NOT_RUNNING;\n\t}\n\n\tif (np->settle_time) {\n\t\treturn SCSI_ABORT_SNOOZE;\n\t}\n\n\t/*\n\t**\tIf the CCB is active, patch schedule jumps for the \n\t**\tscript to abort the command.\n\t*/\n\n\tswitch(cp->host_status) {\n\tcase HS_BUSY:\n\tcase HS_NEGOTIATE:\n\t\tprintk (\"%s: abort ccb=%p (cancel)\\n\", ncr_name (np), cp);\n\t\t\tcp->start.schedule.l_paddr =\n\t\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS (np, cancel));\n\t\tretv = SCSI_ABORT_PENDING;\n\t\tbreak;\n\tcase HS_DISCONNECT:\n\t\tcp->restart.schedule.l_paddr =\n\t\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS (np, abort));\n\t\tretv = SCSI_ABORT_PENDING;\n\t\tbreak;\n\tdefault:\n\t\tretv = SCSI_ABORT_NOT_RUNNING;\n\t\tbreak;\n\n\t}\n\n\t/*\n\t**      If there are no requests, the script\n\t**      processor will sleep on SEL_WAIT_RESEL.\n\t**      Let's wake it up, since it may have to work.\n\t*/\n\tOUTB (nc_istat, SIGP);\n\n\treturn retv;\n}\n#endif\n\nstatic void ncr_detach(struct ncb *np)\n{\n\tstruct ccb *cp;\n\tstruct tcb *tp;\n\tstruct lcb *lp;\n\tint target, lun;\n\tint i;\n\tchar inst_name[16];\n\n\t/* Local copy so we don't access np after freeing it! */\n\tstrlcpy(inst_name, ncr_name(np), sizeof(inst_name));\n\n\tprintk(\"%s: releasing host resources\\n\", ncr_name(np));\n\n/*\n**\tStop the ncr_timeout process\n**\tSet release_stage to 1 and wait that ncr_timeout() set it to 2.\n*/\n\n#ifdef DEBUG_NCR53C8XX\n\tprintk(\"%s: stopping the timer\\n\", ncr_name(np));\n#endif\n\tnp->release_stage = 1;\n\tfor (i = 50 ; i && np->release_stage != 2 ; i--)\n\t\tmdelay(100);\n\tif (np->release_stage != 2)\n\t\tprintk(\"%s: the timer seems to be already stopped\\n\", ncr_name(np));\n\telse np->release_stage = 2;\n\n/*\n**\tDisable chip interrupts\n*/\n\n#ifdef DEBUG_NCR53C8XX\n\tprintk(\"%s: disabling chip interrupts\\n\", ncr_name(np));\n#endif\n\tOUTW (nc_sien , 0);\n\tOUTB (nc_dien , 0);\n\n\t/*\n\t**\tReset NCR chip\n\t**\tRestore bios setting for automatic clock detection.\n\t*/\n\n\tprintk(\"%s: resetting chip\\n\", ncr_name(np));\n\tncr_chip_reset(np, 100);\n\n\tOUTB(nc_dmode,\tnp->sv_dmode);\n\tOUTB(nc_dcntl,\tnp->sv_dcntl);\n\tOUTB(nc_ctest0,\tnp->sv_ctest0);\n\tOUTB(nc_ctest3,\tnp->sv_ctest3);\n\tOUTB(nc_ctest4,\tnp->sv_ctest4);\n\tOUTB(nc_ctest5,\tnp->sv_ctest5);\n\tOUTB(nc_gpcntl,\tnp->sv_gpcntl);\n\tOUTB(nc_stest2,\tnp->sv_stest2);\n\n\tncr_selectclock(np, np->sv_scntl3);\n\n\t/*\n\t**\tFree allocated ccb(s)\n\t*/\n\n\twhile ((cp=np->ccb->link_ccb) != NULL) {\n\t\tnp->ccb->link_ccb = cp->link_ccb;\n\t\tif (cp->host_status) {\n\t\tprintk(\"%s: shall free an active ccb (host_status=%d)\\n\",\n\t\t\tncr_name(np), cp->host_status);\n\t\t}\n#ifdef DEBUG_NCR53C8XX\n\tprintk(\"%s: freeing ccb (%lx)\\n\", ncr_name(np), (u_long) cp);\n#endif\n\t\tm_free_dma(cp, sizeof(*cp), \"CCB\");\n\t}\n\n\t/* Free allocated tp(s) */\n\n\tfor (target = 0; target < MAX_TARGET ; target++) {\n\t\ttp=&np->target[target];\n\t\tfor (lun = 0 ; lun < MAX_LUN ; lun++) {\n\t\t\tlp = tp->lp[lun];\n\t\t\tif (lp) {\n#ifdef DEBUG_NCR53C8XX\n\tprintk(\"%s: freeing lp (%lx)\\n\", ncr_name(np), (u_long) lp);\n#endif\n\t\t\t\tif (lp->jump_ccb != &lp->jump_ccb_0)\n\t\t\t\t\tm_free_dma(lp->jump_ccb,256,\"JUMP_CCB\");\n\t\t\t\tm_free_dma(lp, sizeof(*lp), \"LCB\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (np->scripth0)\n\t\tm_free_dma(np->scripth0, sizeof(struct scripth), \"SCRIPTH\");\n\tif (np->script0)\n\t\tm_free_dma(np->script0, sizeof(struct script), \"SCRIPT\");\n\tif (np->ccb)\n\t\tm_free_dma(np->ccb, sizeof(struct ccb), \"CCB\");\n\tm_free_dma(np, sizeof(struct ncb), \"NCB\");\n\n\tprintk(\"%s: host resources successfully released\\n\", inst_name);\n}\n\n/*==========================================================\n**\n**\n**\tComplete execution of a SCSI command.\n**\tSignal completion to the generic SCSI driver.\n**\n**\n**==========================================================\n*/\n\nvoid ncr_complete (struct ncb *np, struct ccb *cp)\n{\n\tstruct scsi_cmnd *cmd;\n\tstruct tcb *tp;\n\tstruct lcb *lp;\n\n\t/*\n\t**\tSanity check\n\t*/\n\n\tif (!cp || cp->magic != CCB_MAGIC || !cp->cmd)\n\t\treturn;\n\n\t/*\n\t**\tPrint minimal debug information.\n\t*/\n\n\tif (DEBUG_FLAGS & DEBUG_TINY)\n\t\tprintk (\"CCB=%lx STAT=%x/%x\\n\", (unsigned long)cp,\n\t\t\tcp->host_status,cp->scsi_status);\n\n\t/*\n\t**\tGet command, target and lun pointers.\n\t*/\n\n\tcmd = cp->cmd;\n\tcp->cmd = NULL;\n\ttp = &np->target[cmd->device->id];\n\tlp = tp->lp[cmd->device->lun];\n\n\t/*\n\t**\tWe donnot queue more than 1 ccb per target \n\t**\twith negotiation at any time. If this ccb was \n\t**\tused for negotiation, clear this info in the tcb.\n\t*/\n\n\tif (cp == tp->nego_cp)\n\t\ttp->nego_cp = NULL;\n\n\t/*\n\t**\tIf auto-sense performed, change scsi status.\n\t*/\n\tif (cp->auto_sense) {\n\t\tcp->scsi_status = cp->auto_sense;\n\t}\n\n\t/*\n\t**\tIf we were recovering from queue full or performing \n\t**\tauto-sense, requeue skipped CCBs to the wait queue.\n\t*/\n\n\tif (lp && lp->held_ccb) {\n\t\tif (cp == lp->held_ccb) {\n\t\t\tlist_splice_init(&lp->skip_ccbq, &lp->wait_ccbq);\n\t\t\tlp->held_ccb = NULL;\n\t\t}\n\t}\n\n\t/*\n\t**\tCheck for parity errors.\n\t*/\n\n\tif (cp->parity_status > 1) {\n\t\tPRINT_ADDR(cmd, \"%d parity error(s).\\n\",cp->parity_status);\n\t}\n\n\t/*\n\t**\tCheck for extended errors.\n\t*/\n\n\tif (cp->xerr_status != XE_OK) {\n\t\tswitch (cp->xerr_status) {\n\t\tcase XE_EXTRA_DATA:\n\t\t\tPRINT_ADDR(cmd, \"extraneous data discarded.\\n\");\n\t\t\tbreak;\n\t\tcase XE_BAD_PHASE:\n\t\t\tPRINT_ADDR(cmd, \"invalid scsi phase (4/5).\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINT_ADDR(cmd, \"extended error %d.\\n\",\n\t\t\t\t\tcp->xerr_status);\n\t\t\tbreak;\n\t\t}\n\t\tif (cp->host_status==HS_COMPLETE)\n\t\t\tcp->host_status = HS_FAIL;\n\t}\n\n\t/*\n\t**\tPrint out any error for debugging purpose.\n\t*/\n\tif (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {\n\t\tif (cp->host_status != HS_COMPLETE ||\n\t\t    cp->scsi_status != SAM_STAT_GOOD) {\n\t\t\tPRINT_ADDR(cmd, \"ERROR: cmd=%x host_status=%x \"\n\t\t\t\t\t\"scsi_status=%x\\n\", cmd->cmnd[0],\n\t\t\t\t\tcp->host_status, cp->scsi_status);\n\t\t}\n\t}\n\n\t/*\n\t**\tCheck the status.\n\t*/\n\tcmd->result = 0;\n\tif (   (cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == SAM_STAT_GOOD ||\n\t\t    cp->scsi_status == SAM_STAT_CONDITION_MET)) {\n\t\t/*\n\t\t *\tAll went well (GOOD status).\n\t\t *\tCONDITION MET status is returned on\n\t\t *\t`Pre-Fetch' or `Search data' success.\n\t\t */\n\t\tset_status_byte(cmd, cp->scsi_status);\n\n\t\t/*\n\t\t**\t@RESID@\n\t\t**\tCould dig out the correct value for resid,\n\t\t**\tbut it would be quite complicated.\n\t\t*/\n\t\t/* if (cp->phys.header.lastp != cp->phys.header.goalp) */\n\n\t\t/*\n\t\t**\tAllocate the lcb if not yet.\n\t\t*/\n\t\tif (!lp)\n\t\t\tncr_alloc_lcb (np, cmd->device->id, cmd->device->lun);\n\n\t\ttp->bytes     += cp->data_len;\n\t\ttp->transfers ++;\n\n\t\t/*\n\t\t**\tIf tags was reduced due to queue full,\n\t\t**\tincrease tags if 1000 good status received.\n\t\t*/\n\t\tif (lp && lp->usetags && lp->numtags < lp->maxtags) {\n\t\t\t++lp->num_good;\n\t\t\tif (lp->num_good >= 1000) {\n\t\t\t\tlp->num_good = 0;\n\t\t\t\t++lp->numtags;\n\t\t\t\tncr_setup_tags (np, cmd->device);\n\t\t\t}\n\t\t}\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == SAM_STAT_CHECK_CONDITION)) {\n\t\t/*\n\t\t**   Check condition code\n\t\t*/\n\t\tset_status_byte(cmd, SAM_STAT_CHECK_CONDITION);\n\n\t\t/*\n\t\t**\tCopy back sense data to caller's buffer.\n\t\t*/\n\t\tmemcpy(cmd->sense_buffer, cp->sense_buf,\n\t\t       min_t(size_t, SCSI_SENSE_BUFFERSIZE,\n\t\t\t     sizeof(cp->sense_buf)));\n\n\t\tif (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {\n\t\t\tu_char *p = cmd->sense_buffer;\n\t\t\tint i;\n\t\t\tPRINT_ADDR(cmd, \"sense data:\");\n\t\t\tfor (i=0; i<14; i++) printk (\" %x\", *p++);\n\t\t\tprintk (\".\\n\");\n\t\t}\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == SAM_STAT_RESERVATION_CONFLICT)) {\n\t\t/*\n\t\t**   Reservation Conflict condition code\n\t\t*/\n\t\tset_status_byte(cmd, SAM_STAT_RESERVATION_CONFLICT);\n\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == SAM_STAT_BUSY ||\n\t\t    cp->scsi_status == SAM_STAT_TASK_SET_FULL)) {\n\n\t\t/*\n\t\t**   Target is busy.\n\t\t*/\n\t\tset_status_byte(cmd, cp->scsi_status);\n\n\t} else if ((cp->host_status == HS_SEL_TIMEOUT)\n\t\t|| (cp->host_status == HS_TIMEOUT)) {\n\n\t\t/*\n\t\t**   No response\n\t\t*/\n\t\tset_status_byte(cmd, cp->scsi_status);\n\t\tset_host_byte(cmd, DID_TIME_OUT);\n\n\t} else if (cp->host_status == HS_RESET) {\n\n\t\t/*\n\t\t**   SCSI bus reset\n\t\t*/\n\t\tset_status_byte(cmd, cp->scsi_status);\n\t\tset_host_byte(cmd, DID_RESET);\n\n\t} else if (cp->host_status == HS_ABORTED) {\n\n\t\t/*\n\t\t**   Transfer aborted\n\t\t*/\n\t\tset_status_byte(cmd, cp->scsi_status);\n\t\tset_host_byte(cmd, DID_ABORT);\n\n\t} else {\n\n\t\t/*\n\t\t**  Other protocol messes\n\t\t*/\n\t\tPRINT_ADDR(cmd, \"COMMAND FAILED (%x %x) @%p.\\n\",\n\t\t\tcp->host_status, cp->scsi_status, cp);\n\n\t\tset_status_byte(cmd, cp->scsi_status);\n\t\tset_host_byte(cmd, DID_ERROR);\n\t}\n\n\t/*\n\t**\ttrace output\n\t*/\n\n\tif (tp->usrflag & UF_TRACE) {\n\t\tu_char * p;\n\t\tint i;\n\t\tPRINT_ADDR(cmd, \" CMD:\");\n\t\tp = (u_char*) &cmd->cmnd[0];\n\t\tfor (i=0; i<cmd->cmd_len; i++) printk (\" %x\", *p++);\n\n\t\tif (cp->host_status==HS_COMPLETE) {\n\t\t\tswitch (cp->scsi_status) {\n\t\t\tcase SAM_STAT_GOOD:\n\t\t\t\tprintk (\"  GOOD\");\n\t\t\t\tbreak;\n\t\t\tcase SAM_STAT_CHECK_CONDITION:\n\t\t\t\tprintk (\"  SENSE:\");\n\t\t\t\tp = (u_char*) &cmd->sense_buffer;\n\t\t\t\tfor (i=0; i<14; i++)\n\t\t\t\t\tprintk (\" %x\", *p++);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintk (\"  STAT: %x\\n\", cp->scsi_status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else printk (\"  HOSTERROR: %x\", cp->host_status);\n\t\tprintk (\"\\n\");\n\t}\n\n\t/*\n\t**\tFree this ccb\n\t*/\n\tncr_free_ccb (np, cp);\n\n\t/*\n\t**\trequeue awaiting scsi commands for this lun.\n\t*/\n\tif (lp && lp->queuedccbs < lp->queuedepth &&\n\t    !list_empty(&lp->wait_ccbq))\n\t\tncr_start_next_ccb(np, lp, 2);\n\n\t/*\n\t**\trequeue awaiting scsi commands for this controller.\n\t*/\n\tif (np->waiting_list)\n\t\trequeue_waiting_list(np);\n\n\t/*\n\t**\tsignal completion to generic driver.\n\t*/\n\tncr_queue_done_cmd(np, cmd);\n}\n\n/*==========================================================\n**\n**\n**\tSignal all (or one) control block done.\n**\n**\n**==========================================================\n*/\n\n/*\n**\tThis CCB has been skipped by the NCR.\n**\tQueue it in the corresponding unit queue.\n*/\nstatic void ncr_ccb_skipped(struct ncb *np, struct ccb *cp)\n{\n\tstruct tcb *tp = &np->target[cp->target];\n\tstruct lcb *lp = tp->lp[cp->lun];\n\n\tif (lp && cp != np->ccb) {\n\t\tcp->host_status &= ~HS_SKIPMASK;\n\t\tcp->start.schedule.l_paddr = \n\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS (np, select));\n\t\tlist_move_tail(&cp->link_ccbq, &lp->skip_ccbq);\n\t\tif (cp->queued) {\n\t\t\t--lp->queuedccbs;\n\t\t}\n\t}\n\tif (cp->queued) {\n\t\t--np->queuedccbs;\n\t\tcp->queued = 0;\n\t}\n}\n\n/*\n**\tThe NCR has completed CCBs.\n**\tLook at the DONE QUEUE if enabled, otherwise scan all CCBs\n*/\nvoid ncr_wakeup_done (struct ncb *np)\n{\n\tstruct ccb *cp;\n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\n\tint i, j;\n\n\ti = np->ccb_done_ic;\n\twhile (1) {\n\t\tj = i+1;\n\t\tif (j >= MAX_DONE)\n\t\t\tj = 0;\n\n\t\tcp = np->ccb_done[j];\n\t\tif (!CCB_DONE_VALID(cp))\n\t\t\tbreak;\n\n\t\tnp->ccb_done[j] = (struct ccb *)CCB_DONE_EMPTY;\n\t\tnp->scripth->done_queue[5*j + 4] =\n\t\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS (np, done_plug));\n\t\tMEMORY_BARRIER();\n\t\tnp->scripth->done_queue[5*i + 4] =\n\t\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS (np, done_end));\n\n\t\tif (cp->host_status & HS_DONEMASK)\n\t\t\tncr_complete (np, cp);\n\t\telse if (cp->host_status & HS_SKIPMASK)\n\t\t\tncr_ccb_skipped (np, cp);\n\n\t\ti = j;\n\t}\n\tnp->ccb_done_ic = i;\n#else\n\tcp = np->ccb;\n\twhile (cp) {\n\t\tif (cp->host_status & HS_DONEMASK)\n\t\t\tncr_complete (np, cp);\n\t\telse if (cp->host_status & HS_SKIPMASK)\n\t\t\tncr_ccb_skipped (np, cp);\n\t\tcp = cp->link_ccb;\n\t}\n#endif\n}\n\n/*\n**\tComplete all active CCBs.\n*/\nvoid ncr_wakeup (struct ncb *np, u_long code)\n{\n\tstruct ccb *cp = np->ccb;\n\n\twhile (cp) {\n\t\tif (cp->host_status != HS_IDLE) {\n\t\t\tcp->host_status = code;\n\t\t\tncr_complete (np, cp);\n\t\t}\n\t\tcp = cp->link_ccb;\n\t}\n}\n\n/*\n** Reset ncr chip.\n*/\n\n/* Some initialisation must be done immediately following reset, for 53c720,\n * at least.  EA (dcntl bit 5) isn't set here as it is set once only in\n * the _detect function.\n */\nstatic void ncr_chip_reset(struct ncb *np, int delay)\n{\n\tOUTB (nc_istat,  SRST);\n\tudelay(delay);\n\tOUTB (nc_istat,  0   );\n\n\tif (np->features & FE_EHP)\n\t\tOUTB (nc_ctest0, EHP);\n\tif (np->features & FE_MUX)\n\t\tOUTB (nc_ctest4, MUX);\n}\n\n\n/*==========================================================\n**\n**\n**\tStart NCR chip.\n**\n**\n**==========================================================\n*/\n\nvoid ncr_init (struct ncb *np, int reset, char * msg, u_long code)\n{\n \tint\ti;\n\n \t/*\n\t**\tReset chip if asked, otherwise just clear fifos.\n \t*/\n\n\tif (reset) {\n\t\tOUTB (nc_istat,  SRST);\n\t\tudelay(100);\n\t}\n\telse {\n\t\tOUTB (nc_stest3, TE|CSF);\n\t\tOUTONB (nc_ctest3, CLF);\n\t}\n \n\t/*\n\t**\tMessage.\n\t*/\n\n\tif (msg) printk (KERN_INFO \"%s: restart (%s).\\n\", ncr_name (np), msg);\n\n\t/*\n\t**\tClear Start Queue\n\t*/\n\tnp->queuedepth = MAX_START - 1;\t/* 1 entry needed as end marker */\n\tfor (i = 1; i < MAX_START + MAX_START; i += 2)\n\t\tnp->scripth0->tryloop[i] =\n\t\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS (np, idle));\n\n\t/*\n\t**\tStart at first entry.\n\t*/\n\tnp->squeueput = 0;\n\tnp->script0->startpos[0] = cpu_to_scr(NCB_SCRIPTH_PHYS (np, tryloop));\n\n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\n\t/*\n\t**\tClear Done Queue\n\t*/\n\tfor (i = 0; i < MAX_DONE; i++) {\n\t\tnp->ccb_done[i] = (struct ccb *)CCB_DONE_EMPTY;\n\t\tnp->scripth0->done_queue[5*i + 4] =\n\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS (np, done_end));\n\t}\n#endif\n\n\t/*\n\t**\tStart at first entry.\n\t*/\n\tnp->script0->done_pos[0] = cpu_to_scr(NCB_SCRIPTH_PHYS (np,done_queue));\n\tnp->ccb_done_ic = MAX_DONE-1;\n\tnp->scripth0->done_queue[5*(MAX_DONE-1) + 4] =\n\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS (np, done_plug));\n\n\t/*\n\t**\tWakeup all pending jobs.\n\t*/\n\tncr_wakeup (np, code);\n\n\t/*\n\t**\tInit chip.\n\t*/\n\n\t/*\n\t** Remove reset; big delay because the 895 needs time for the\n\t** bus mode to settle\n\t*/\n\tncr_chip_reset(np, 2000);\n\n\tOUTB (nc_scntl0, np->rv_scntl0 | 0xc0);\n\t\t\t\t\t/*  full arb., ena parity, par->ATN  */\n\tOUTB (nc_scntl1, 0x00);\t\t/*  odd parity, and remove CRST!! */\n\n\tncr_selectclock(np, np->rv_scntl3);\t/* Select SCSI clock */\n\n\tOUTB (nc_scid  , RRE|np->myaddr);\t/* Adapter SCSI address */\n\tOUTW (nc_respid, 1ul<<np->myaddr);\t/* Id to respond to */\n\tOUTB (nc_istat , SIGP\t);\t\t/*  Signal Process */\n\tOUTB (nc_dmode , np->rv_dmode);\t\t/* Burst length, dma mode */\n\tOUTB (nc_ctest5, np->rv_ctest5);\t/* Large fifo + large burst */\n\n\tOUTB (nc_dcntl , NOCOM|np->rv_dcntl);\t/* Protect SFBR */\n\tOUTB (nc_ctest0, np->rv_ctest0);\t/* 720: CDIS and EHP */\n\tOUTB (nc_ctest3, np->rv_ctest3);\t/* Write and invalidate */\n\tOUTB (nc_ctest4, np->rv_ctest4);\t/* Master parity checking */\n\n\tOUTB (nc_stest2, EXT|np->rv_stest2);\t/* Extended Sreq/Sack filtering */\n\tOUTB (nc_stest3, TE);\t\t\t/* TolerANT enable */\n\tOUTB (nc_stime0, 0x0c\t);\t\t/* HTH disabled  STO 0.25 sec */\n\n\t/*\n\t**\tDisable disconnects.\n\t*/\n\n\tnp->disc = 0;\n\n\t/*\n\t**    Enable GPIO0 pin for writing if LED support.\n\t*/\n\n\tif (np->features & FE_LED0) {\n\t\tOUTOFFB (nc_gpcntl, 0x01);\n\t}\n\n\t/*\n\t**      enable ints\n\t*/\n\n\tOUTW (nc_sien , STO|HTH|MA|SGE|UDC|RST|PAR);\n\tOUTB (nc_dien , MDPE|BF|ABRT|SSI|SIR|IID);\n\n\t/*\n\t**\tFill in target structure.\n\t**\tReinitialize usrsync.\n\t**\tReinitialize usrwide.\n\t**\tPrepare sync negotiation according to actual SCSI bus mode.\n\t*/\n\n\tfor (i=0;i<MAX_TARGET;i++) {\n\t\tstruct tcb *tp = &np->target[i];\n\n\t\ttp->sval    = 0;\n\t\ttp->wval    = np->rv_scntl3;\n\n\t\tif (tp->usrsync != 255) {\n\t\t\tif (tp->usrsync <= np->maxsync) {\n\t\t\t\tif (tp->usrsync < np->minsync) {\n\t\t\t\t\ttp->usrsync = np->minsync;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\ttp->usrsync = 255;\n\t\t}\n\n\t\tif (tp->usrwide > np->maxwide)\n\t\t\ttp->usrwide = np->maxwide;\n\n\t}\n\n\t/*\n\t**    Start script processor.\n\t*/\n\tif (np->paddr2) {\n\t\tif (bootverbose)\n\t\t\tprintk (\"%s: Downloading SCSI SCRIPTS.\\n\",\n\t\t\t\tncr_name(np));\n\t\tOUTL (nc_scratcha, vtobus(np->script0));\n\t\tOUTL_DSP (NCB_SCRIPTH_PHYS (np, start_ram));\n\t}\n\telse\n\t\tOUTL_DSP (NCB_SCRIPT_PHYS (np, start));\n}\n\n/*==========================================================\n**\n**\tPrepare the negotiation values for wide and\n**\tsynchronous transfers.\n**\n**==========================================================\n*/\n\nstatic void ncr_negotiate (struct ncb* np, struct tcb* tp)\n{\n\t/*\n\t**\tminsync unit is 4ns !\n\t*/\n\n\tu_long minsync = tp->usrsync;\n\n\t/*\n\t**\tSCSI bus mode limit\n\t*/\n\n\tif (np->scsi_mode && np->scsi_mode == SMODE_SE) {\n\t\tif (minsync < 12) minsync = 12;\n\t}\n\n\t/*\n\t**\tour limit ..\n\t*/\n\n\tif (minsync < np->minsync)\n\t\tminsync = np->minsync;\n\n\t/*\n\t**\tdivider limit\n\t*/\n\n\tif (minsync > np->maxsync)\n\t\tminsync = 255;\n\n\tif (tp->maxoffs > np->maxoffs)\n\t\ttp->maxoffs = np->maxoffs;\n\n\ttp->minsync = minsync;\n\ttp->maxoffs = (minsync<255 ? tp->maxoffs : 0);\n\n\t/*\n\t**\tperiod=0: has to negotiate sync transfer\n\t*/\n\n\ttp->period=0;\n\n\t/*\n\t**\twidedone=0: has to negotiate wide transfer\n\t*/\n\ttp->widedone=0;\n}\n\n/*==========================================================\n**\n**\tGet clock factor and sync divisor for a given \n**\tsynchronous factor period.\n**\tReturns the clock factor (in sxfer) and scntl3 \n**\tsynchronous divisor field.\n**\n**==========================================================\n*/\n\nstatic void ncr_getsync(struct ncb *np, u_char sfac, u_char *fakp, u_char *scntl3p)\n{\n\tu_long\tclk = np->clock_khz;\t/* SCSI clock frequency in kHz\t*/\n\tint\tdiv = np->clock_divn;\t/* Number of divisors supported\t*/\n\tu_long\tfak;\t\t\t/* Sync factor in sxfer\t\t*/\n\tu_long\tper;\t\t\t/* Period in tenths of ns\t*/\n\tu_long\tkpc;\t\t\t/* (per * clk)\t\t\t*/\n\n\t/*\n\t**\tCompute the synchronous period in tenths of nano-seconds\n\t*/\n\tif\t(sfac <= 10)\tper = 250;\n\telse if\t(sfac == 11)\tper = 303;\n\telse if\t(sfac == 12)\tper = 500;\n\telse\t\t\tper = 40 * sfac;\n\n\t/*\n\t**\tLook for the greatest clock divisor that allows an \n\t**\tinput speed faster than the period.\n\t*/\n\tkpc = per * clk;\n\twhile (--div > 0)\n\t\tif (kpc >= (div_10M[div] << 2)) break;\n\n\t/*\n\t**\tCalculate the lowest clock factor that allows an output \n\t**\tspeed not faster than the period.\n\t*/\n\tfak = (kpc - 1) / div_10M[div] + 1;\n\n#if 0\t/* This optimization does not seem very useful */\n\n\tper = (fak * div_10M[div]) / clk;\n\n\t/*\n\t**\tWhy not to try the immediate lower divisor and to choose \n\t**\tthe one that allows the fastest output speed ?\n\t**\tWe don't want input speed too much greater than output speed.\n\t*/\n\tif (div >= 1 && fak < 8) {\n\t\tu_long fak2, per2;\n\t\tfak2 = (kpc - 1) / div_10M[div-1] + 1;\n\t\tper2 = (fak2 * div_10M[div-1]) / clk;\n\t\tif (per2 < per && fak2 <= 8) {\n\t\t\tfak = fak2;\n\t\t\tper = per2;\n\t\t\t--div;\n\t\t}\n\t}\n#endif\n\n\tif (fak < 4) fak = 4;\t/* Should never happen, too bad ... */\n\n\t/*\n\t**\tCompute and return sync parameters for the ncr\n\t*/\n\t*fakp\t\t= fak - 4;\n\t*scntl3p\t= ((div+1) << 4) + (sfac < 25 ? 0x80 : 0);\n}\n\n\n/*==========================================================\n**\n**\tSet actual values, sync status and patch all ccbs of \n**\ta target according to new sync/wide agreement.\n**\n**==========================================================\n*/\n\nstatic void ncr_set_sync_wide_status (struct ncb *np, u_char target)\n{\n\tstruct ccb *cp;\n\tstruct tcb *tp = &np->target[target];\n\n\t/*\n\t**\tset actual value and sync_status\n\t*/\n\tOUTB (nc_sxfer, tp->sval);\n\tnp->sync_st = tp->sval;\n\tOUTB (nc_scntl3, tp->wval);\n\tnp->wide_st = tp->wval;\n\n\t/*\n\t**\tpatch ALL ccbs of this target.\n\t*/\n\tfor (cp = np->ccb; cp; cp = cp->link_ccb) {\n\t\tif (!cp->cmd) continue;\n\t\tif (scmd_id(cp->cmd) != target) continue;\n#if 0\n\t\tcp->sync_status = tp->sval;\n\t\tcp->wide_status = tp->wval;\n#endif\n\t\tcp->phys.select.sel_scntl3 = tp->wval;\n\t\tcp->phys.select.sel_sxfer  = tp->sval;\n\t}\n}\n\n/*==========================================================\n**\n**\tSwitch sync mode for current job and it's target\n**\n**==========================================================\n*/\n\nstatic void ncr_setsync (struct ncb *np, struct ccb *cp, u_char scntl3, u_char sxfer)\n{\n\tstruct scsi_cmnd *cmd = cp->cmd;\n\tstruct tcb *tp;\n\tu_char target = INB (nc_sdid) & 0x0f;\n\tu_char idiv;\n\n\tBUG_ON(target != (scmd_id(cmd) & 0xf));\n\n\ttp = &np->target[target];\n\n\tif (!scntl3 || !(sxfer & 0x1f))\n\t\tscntl3 = np->rv_scntl3;\n\tscntl3 = (scntl3 & 0xf0) | (tp->wval & EWS) | (np->rv_scntl3 & 0x07);\n\n\t/*\n\t**\tDeduce the value of controller sync period from scntl3.\n\t**\tperiod is in tenths of nano-seconds.\n\t*/\n\n\tidiv = ((scntl3 >> 4) & 0x7);\n\tif ((sxfer & 0x1f) && idiv)\n\t\ttp->period = (((sxfer>>5)+4)*div_10M[idiv-1])/np->clock_khz;\n\telse\n\t\ttp->period = 0xffff;\n\n\t/* Stop there if sync parameters are unchanged */\n\tif (tp->sval == sxfer && tp->wval == scntl3)\n\t\treturn;\n\ttp->sval = sxfer;\n\ttp->wval = scntl3;\n\n\tif (sxfer & 0x01f) {\n\t\t/* Disable extended Sreq/Sack filtering */\n\t\tif (tp->period <= 2000)\n\t\t\tOUTOFFB(nc_stest2, EXT);\n\t}\n \n\tspi_display_xfer_agreement(tp->starget);\n\n\t/*\n\t**\tset actual value and sync_status\n\t**\tpatch ALL ccbs of this target.\n\t*/\n\tncr_set_sync_wide_status(np, target);\n}\n\n/*==========================================================\n**\n**\tSwitch wide mode for current job and it's target\n**\tSCSI specs say: a SCSI device that accepts a WDTR \n**\tmessage shall reset the synchronous agreement to \n**\tasynchronous mode.\n**\n**==========================================================\n*/\n\nstatic void ncr_setwide (struct ncb *np, struct ccb *cp, u_char wide, u_char ack)\n{\n\tstruct scsi_cmnd *cmd = cp->cmd;\n\tu16 target = INB (nc_sdid) & 0x0f;\n\tstruct tcb *tp;\n\tu_char\tscntl3;\n\tu_char\tsxfer;\n\n\tBUG_ON(target != (scmd_id(cmd) & 0xf));\n\n\ttp = &np->target[target];\n\ttp->widedone  =  wide+1;\n\tscntl3 = (tp->wval & (~EWS)) | (wide ? EWS : 0);\n\n\tsxfer = ack ? 0 : tp->sval;\n\n\t/*\n\t**\t Stop there if sync/wide parameters are unchanged\n\t*/\n\tif (tp->sval == sxfer && tp->wval == scntl3) return;\n\ttp->sval = sxfer;\n\ttp->wval = scntl3;\n\n\t/*\n\t**\tBells and whistles   ;-)\n\t*/\n\tif (bootverbose >= 2) {\n\t\tdev_info(&cmd->device->sdev_target->dev, \"WIDE SCSI %sabled.\\n\",\n\t\t\t\t(scntl3 & EWS) ? \"en\" : \"dis\");\n\t}\n\n\t/*\n\t**\tset actual value and sync_status\n\t**\tpatch ALL ccbs of this target.\n\t*/\n\tncr_set_sync_wide_status(np, target);\n}\n\n/*==========================================================\n**\n**\tSwitch tagged mode for a target.\n**\n**==========================================================\n*/\n\nstatic void ncr_setup_tags (struct ncb *np, struct scsi_device *sdev)\n{\n\tunsigned char tn = sdev->id, ln = sdev->lun;\n\tstruct tcb *tp = &np->target[tn];\n\tstruct lcb *lp = tp->lp[ln];\n\tu_char   reqtags, maxdepth;\n\n\t/*\n\t**\tJust in case ...\n\t*/\n\tif ((!tp) || (!lp) || !sdev)\n\t\treturn;\n\n\t/*\n\t**\tIf SCSI device queue depth is not yet set, leave here.\n\t*/\n\tif (!lp->scdev_depth)\n\t\treturn;\n\n\t/*\n\t**\tDonnot allow more tags than the SCSI driver can queue \n\t**\tfor this device.\n\t**\tDonnot allow more tags than we can handle.\n\t*/\n\tmaxdepth = lp->scdev_depth;\n\tif (maxdepth > lp->maxnxs)\tmaxdepth    = lp->maxnxs;\n\tif (lp->maxtags > maxdepth)\tlp->maxtags = maxdepth;\n\tif (lp->numtags > maxdepth)\tlp->numtags = maxdepth;\n\n\t/*\n\t**\tonly devices conformant to ANSI Version >= 2\n\t**\tonly devices capable of tagged commands\n\t**\tonly if enabled by user ..\n\t*/\n\tif (sdev->tagged_supported && lp->numtags > 1) {\n\t\treqtags = lp->numtags;\n\t} else {\n\t\treqtags = 1;\n\t}\n\n\t/*\n\t**\tUpdate max number of tags\n\t*/\n\tlp->numtags = reqtags;\n\tif (lp->numtags > lp->maxtags)\n\t\tlp->maxtags = lp->numtags;\n\n\t/*\n\t**\tIf we want to switch tag mode, we must wait \n\t**\tfor no CCB to be active.\n\t*/\n\tif\t(reqtags > 1 && lp->usetags) {\t /* Stay in tagged mode    */\n\t\tif (lp->queuedepth == reqtags)\t /* Already announced\t   */\n\t\t\treturn;\n\t\tlp->queuedepth\t= reqtags;\n\t}\n\telse if\t(reqtags <= 1 && !lp->usetags) { /* Stay in untagged mode  */\n\t\tlp->queuedepth\t= reqtags;\n\t\treturn;\n\t}\n\telse {\t\t\t\t\t /* Want to switch tag mode */\n\t\tif (lp->busyccbs)\t\t /* If not yet safe, return */\n\t\t\treturn;\n\t\tlp->queuedepth\t= reqtags;\n\t\tlp->usetags\t= reqtags > 1 ? 1 : 0;\n\t}\n\n\t/*\n\t**\tPatch the lun mini-script, according to tag mode.\n\t*/\n\tlp->jump_tag.l_paddr = lp->usetags?\n\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS(np, resel_tag)) :\n\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS(np, resel_notag));\n\n\t/*\n\t**\tAnnounce change to user.\n\t*/\n\tif (bootverbose) {\n\t\tif (lp->usetags) {\n\t\t\tdev_info(&sdev->sdev_gendev,\n\t\t\t\t\"tagged command queue depth set to %d\\n\",\n\t\t\t\treqtags);\n\t\t} else {\n\t\t\tdev_info(&sdev->sdev_gendev,\n\t\t\t\t\t\"tagged command queueing disabled\\n\");\n\t\t}\n\t}\n}\n\n/*==========================================================\n**\n**\n**\tncr timeout handler.\n**\n**\n**==========================================================\n**\n**\tMisused to keep the driver running when\n**\tinterrupts are not configured correctly.\n**\n**----------------------------------------------------------\n*/\n\nstatic void ncr_timeout (struct ncb *np)\n{\n\tu_long\tthistime = jiffies;\n\n\t/*\n\t**\tIf release process in progress, let's go\n\t**\tSet the release stage from 1 to 2 to synchronize\n\t**\twith the release process.\n\t*/\n\n\tif (np->release_stage) {\n\t\tif (np->release_stage == 1) np->release_stage = 2;\n\t\treturn;\n\t}\n\n\tnp->timer.expires = jiffies + SCSI_NCR_TIMER_INTERVAL;\n\tadd_timer(&np->timer);\n\n\t/*\n\t**\tIf we are resetting the ncr, wait for settle_time before \n\t**\tclearing it. Then command processing will be resumed.\n\t*/\n\tif (np->settle_time) {\n\t\tif (np->settle_time <= thistime) {\n\t\t\tif (bootverbose > 1)\n\t\t\t\tprintk(\"%s: command processing resumed\\n\", ncr_name(np));\n\t\t\tnp->settle_time\t= 0;\n\t\t\tnp->disc\t= 1;\n\t\t\trequeue_waiting_list(np);\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t**\tSince the generic scsi driver only allows us 0.5 second \n\t**\tto perform abort of a command, we must look at ccbs about \n\t**\tevery 0.25 second.\n\t*/\n\tif (np->lasttime + 4*HZ < thistime) {\n\t\t/*\n\t\t**\tblock ncr interrupts\n\t\t*/\n\t\tnp->lasttime = thistime;\n\t}\n\n#ifdef SCSI_NCR_BROKEN_INTR\n\tif (INB(nc_istat) & (INTF|SIP|DIP)) {\n\n\t\t/*\n\t\t**\tProcess pending interrupts.\n\t\t*/\n\t\tif (DEBUG_FLAGS & DEBUG_TINY) printk (\"{\");\n\t\tncr_exception (np);\n\t\tif (DEBUG_FLAGS & DEBUG_TINY) printk (\"}\");\n\t}\n#endif /* SCSI_NCR_BROKEN_INTR */\n}\n\n/*==========================================================\n**\n**\tlog message for real hard errors\n**\n**\t\"ncr0 targ 0?: ERROR (ds:si) (so-si-sd) (sxfer/scntl3) @ name (dsp:dbc).\"\n**\t\"\t      reg: r0 r1 r2 r3 r4 r5 r6 ..... rf.\"\n**\n**\texception register:\n**\t\tds:\tdstat\n**\t\tsi:\tsist\n**\n**\tSCSI bus lines:\n**\t\tso:\tcontrol lines as driver by NCR.\n**\t\tsi:\tcontrol lines as seen by NCR.\n**\t\tsd:\tscsi data lines as seen by NCR.\n**\n**\twide/fastmode:\n**\t\tsxfer:\t(see the manual)\n**\t\tscntl3:\t(see the manual)\n**\n**\tcurrent script command:\n**\t\tdsp:\tscript address (relative to start of script).\n**\t\tdbc:\tfirst word of script command.\n**\n**\tFirst 16 register of the chip:\n**\t\tr0..rf\n**\n**==========================================================\n*/\n\nstatic void ncr_log_hard_error(struct ncb *np, u16 sist, u_char dstat)\n{\n\tu32\tdsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (dsp > np->p_script && dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script0;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp && \n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth0;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= NULL;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintk (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintk (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t\tscr_to_cpu((int) *(ncrcmd *)(script_base + script_ofs)));\n\t}\n\n\tprintk (\"%s: regdump:\", ncr_name(np));\n\tfor (i=0; i<16;i++)\n            printk (\" %02x\", (unsigned)INB_OFF(i));\n\tprintk (\".\\n\");\n}\n\n/*============================================================\n**\n**\tncr chip exception handler.\n**\n**============================================================\n**\n**\tIn normal cases, interrupt conditions occur one at a \n**\ttime. The ncr is able to stack in some extra registers \n**\tother interrupts that will occur after the first one.\n**\tBut, several interrupts may occur at the same time.\n**\n**\tWe probably should only try to deal with the normal \n**\tcase, but it seems that multiple interrupts occur in \n**\tsome cases that are not abnormal at all.\n**\n**\tThe most frequent interrupt condition is Phase Mismatch.\n**\tWe should want to service this interrupt quickly.\n**\tA SCSI parity error may be delivered at the same time.\n**\tThe SIR interrupt is not very frequent in this driver, \n**\tsince the INTFLY is likely used for command completion \n**\tsignaling.\n**\tThe Selection Timeout interrupt may be triggered with \n**\tIID and/or UDC.\n**\tThe SBMC interrupt (SCSI Bus Mode Change) may probably \n**\toccur at any time.\n**\n**\tThis handler try to deal as cleverly as possible with all\n**\tthe above.\n**\n**============================================================\n*/\n\nvoid ncr_exception (struct ncb *np)\n{\n\tu_char\tistat, dstat;\n\tu16\tsist;\n\tint\ti;\n\n\t/*\n\t**\tinterrupt on the fly ?\n\t**\tSince the global header may be copied back to a CCB \n\t**\tusing a posted PCI memory write, the last operation on \n\t**\tthe istat register is a READ in order to flush posted \n\t**\tPCI write commands.\n\t*/\n\tistat = INB (nc_istat);\n\tif (istat & INTF) {\n\t\tOUTB (nc_istat, (istat & SIGP) | INTF);\n\t\tistat = INB (nc_istat);\n\t\tif (DEBUG_FLAGS & DEBUG_TINY) printk (\"F \");\n\t\tncr_wakeup_done (np);\n\t}\n\n\tif (!(istat & (SIP|DIP)))\n\t\treturn;\n\n\tif (istat & CABRT)\n\t\tOUTB (nc_istat, CABRT);\n\n\t/*\n\t**\tSteinbach's Guideline for Systems Programming:\n\t**\tNever test for an error condition you don't know how to handle.\n\t*/\n\n\tsist  = (istat & SIP) ? INW (nc_sist)  : 0;\n\tdstat = (istat & DIP) ? INB (nc_dstat) : 0;\n\n\tif (DEBUG_FLAGS & DEBUG_TINY)\n\t\tprintk (\"<%d|%x:%x|%x:%x>\",\n\t\t\t(int)INB(nc_scr0),\n\t\t\tdstat,sist,\n\t\t\t(unsigned)INL(nc_dsp),\n\t\t\t(unsigned)INL(nc_dbc));\n\n\t/*========================================================\n\t**\tFirst, interrupts we want to service cleanly.\n\t**\n\t**\tPhase mismatch is the most frequent interrupt, and \n\t**\tso we have to service it as quickly and as cleanly \n\t**\tas possible.\n\t**\tProgrammed interrupts are rarely used in this driver,\n\t**\tbut we must handle them cleanly anyway.\n\t**\tWe try to deal with PAR and SBMC combined with \n\t**\tsome other interrupt(s).\n\t**=========================================================\n\t*/\n\n\tif (!(sist  & (STO|GEN|HTH|SGE|UDC|RST)) &&\n\t    !(dstat & (MDPE|BF|ABRT|IID))) {\n\t\tif ((sist & SBMC) && ncr_int_sbmc (np))\n\t\t\treturn;\n\t\tif ((sist & PAR)  && ncr_int_par  (np))\n\t\t\treturn;\n\t\tif (sist & MA) {\n\t\t\tncr_int_ma (np);\n\t\t\treturn;\n\t\t}\n\t\tif (dstat & SIR) {\n\t\t\tncr_int_sir (np);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t**  DEL 397 - 53C875 Rev 3 - Part Number 609-0392410 - ITEM 2.\n\t\t*/\n\t\tif (!(sist & (SBMC|PAR)) && !(dstat & SSI)) {\n\t\t\tprintk(\t\"%s: unknown interrupt(s) ignored, \"\n\t\t\t\t\"ISTAT=%x DSTAT=%x SIST=%x\\n\",\n\t\t\t\tncr_name(np), istat, dstat, sist);\n\t\t\treturn;\n\t\t}\n\t\tOUTONB_STD ();\n\t\treturn;\n\t}\n\n\t/*========================================================\n\t**\tNow, interrupts that need some fixing up.\n\t**\tOrder and multiple interrupts is so less important.\n\t**\n\t**\tIf SRST has been asserted, we just reset the chip.\n\t**\n\t**\tSelection is intirely handled by the chip. If the \n\t**\tchip says STO, we trust it. Seems some other \n\t**\tinterrupts may occur at the same time (UDC, IID), so \n\t**\twe ignore them. In any case we do enough fix-up \n\t**\tin the service routine.\n\t**\tWe just exclude some fatal dma errors.\n\t**=========================================================\n\t*/\n\n\tif (sist & RST) {\n\t\tncr_init (np, 1, bootverbose ? \"scsi reset\" : NULL, HS_RESET);\n\t\treturn;\n\t}\n\n\tif ((sist & STO) &&\n\t\t!(dstat & (MDPE|BF|ABRT))) {\n\t/*\n\t**\tDEL 397 - 53C875 Rev 3 - Part Number 609-0392410 - ITEM 1.\n\t*/\n\t\tOUTONB (nc_ctest3, CLF);\n\n\t\tncr_int_sto (np);\n\t\treturn;\n\t}\n\n\t/*=========================================================\n\t**\tNow, interrupts we are not able to recover cleanly.\n\t**\t(At least for the moment).\n\t**\n\t**\tDo the register dump.\n\t**\tLog message for real hard errors.\n\t**\tClear all fifos.\n\t**\tFor MDPE, BF, ABORT, IID, SGE and HTH we reset the \n\t**\tBUS and the chip.\n\t**\tWe are more soft for UDC.\n\t**=========================================================\n\t*/\n\n\tif (time_after(jiffies, np->regtime)) {\n\t\tnp->regtime = jiffies + 10*HZ;\n\t\tfor (i = 0; i<sizeof(np->regdump); i++)\n\t\t\t((char*)&np->regdump)[i] = INB_OFF(i);\n\t\tnp->regdump.nc_dstat = dstat;\n\t\tnp->regdump.nc_sist  = sist;\n\t}\n\n\tncr_log_hard_error(np, sist, dstat);\n\n\tprintk (\"%s: have to clear fifos.\\n\", ncr_name (np));\n\tOUTB (nc_stest3, TE|CSF);\n\tOUTONB (nc_ctest3, CLF);\n\n\tif ((sist & (SGE)) ||\n\t\t(dstat & (MDPE|BF|ABRT|IID))) {\n\t\tncr_start_reset(np);\n\t\treturn;\n\t}\n\n\tif (sist & HTH) {\n\t\tprintk (\"%s: handshake timeout\\n\", ncr_name(np));\n\t\tncr_start_reset(np);\n\t\treturn;\n\t}\n\n\tif (sist & UDC) {\n\t\tprintk (\"%s: unexpected disconnect\\n\", ncr_name(np));\n\t\tOUTB (HS_PRT, HS_UNEXPECTED);\n\t\tOUTL_DSP (NCB_SCRIPT_PHYS (np, cleanup));\n\t\treturn;\n\t}\n\n\t/*=========================================================\n\t**\tWe just miss the cause of the interrupt. :(\n\t**\tPrint a message. The timeout will do the real work.\n\t**=========================================================\n\t*/\n\tprintk (\"%s: unknown interrupt\\n\", ncr_name(np));\n}\n\n/*==========================================================\n**\n**\tncr chip exception handler for selection timeout\n**\n**==========================================================\n**\n**\tThere seems to be a bug in the 53c810.\n**\tAlthough a STO-Interrupt is pending,\n**\tit continues executing script commands.\n**\tBut it will fail and interrupt (IID) on\n**\tthe next instruction where it's looking\n**\tfor a valid phase.\n**\n**----------------------------------------------------------\n*/\n\nvoid ncr_int_sto (struct ncb *np)\n{\n\tu_long dsa;\n\tstruct ccb *cp;\n\tif (DEBUG_FLAGS & DEBUG_TINY) printk (\"T\");\n\n\t/*\n\t**\tlook for ccb and set the status.\n\t*/\n\n\tdsa = INL (nc_dsa);\n\tcp = np->ccb;\n\twhile (cp && (CCB_PHYS (cp, phys) != dsa))\n\t\tcp = cp->link_ccb;\n\n\tif (cp) {\n\t\tcp-> host_status = HS_SEL_TIMEOUT;\n\t\tncr_complete (np, cp);\n\t}\n\n\t/*\n\t**\trepair start queue and jump to start point.\n\t*/\n\n\tOUTL_DSP (NCB_SCRIPTH_PHYS (np, sto_restart));\n\treturn;\n}\n\n/*==========================================================\n**\n**\tncr chip exception handler for SCSI bus mode change\n**\n**==========================================================\n**\n**\tspi2-r12 11.2.3 says a transceiver mode change must \n**\tgenerate a reset event and a device that detects a reset \n**\tevent shall initiate a hard reset. It says also that a\n**\tdevice that detects a mode change shall set data transfer \n**\tmode to eight bit asynchronous, etc...\n**\tSo, just resetting should be enough.\n**\t \n**\n**----------------------------------------------------------\n*/\n\nstatic int ncr_int_sbmc (struct ncb *np)\n{\n\tu_char scsi_mode = INB (nc_stest4) & SMODE;\n\n\tif (scsi_mode != np->scsi_mode) {\n\t\tprintk(\"%s: SCSI bus mode change from %x to %x.\\n\",\n\t\t\tncr_name(np), np->scsi_mode, scsi_mode);\n\n\t\tnp->scsi_mode = scsi_mode;\n\n\n\t\t/*\n\t\t**\tSuspend command processing for 1 second and \n\t\t**\treinitialize all except the chip.\n\t\t*/\n\t\tnp->settle_time\t= jiffies + HZ;\n\t\tncr_init (np, 0, bootverbose ? \"scsi mode change\" : NULL, HS_RESET);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*==========================================================\n**\n**\tncr chip exception handler for SCSI parity error.\n**\n**==========================================================\n**\n**\n**----------------------------------------------------------\n*/\n\nstatic int ncr_int_par (struct ncb *np)\n{\n\tu_char\thsts\t= INB (HS_PRT);\n\tu32\tdbc\t= INL (nc_dbc);\n\tu_char\tsstat1\t= INB (nc_sstat1);\n\tint phase\t= -1;\n\tint msg\t\t= -1;\n\tu32 jmp;\n\n\tprintk(\"%s: SCSI parity error detected: SCR1=%d DBC=%x SSTAT1=%x\\n\",\n\t\tncr_name(np), hsts, dbc, sstat1);\n\n\t/*\n\t *\tIgnore the interrupt if the NCR is not connected \n\t *\tto the SCSI bus, since the right work should have  \n\t *\tbeen done on unexpected disconnection handling.\n\t */\n\tif (!(INB (nc_scntl1) & ISCON))\n\t\treturn 0;\n\n\t/*\n\t *\tIf the nexus is not clearly identified, reset the bus.\n\t *\tWe will try to do better later.\n\t */\n\tif (hsts & HS_INVALMASK)\n\t\tgoto reset_all;\n\n\t/*\n\t *\tIf the SCSI parity error occurs in MSG IN phase, prepare a \n\t *\tMSG PARITY message. Otherwise, prepare a INITIATOR DETECTED \n\t *\tERROR message and let the device decide to retry the command \n\t *\tor to terminate with check condition. If we were in MSG IN \n\t *\tphase waiting for the response of a negotiation, we will \n\t *\tget SIR_NEGO_FAILED at dispatch.\n\t */\n\tif (!(dbc & 0xc0000000))\n\t\tphase = (dbc >> 24) & 7;\n\tif (phase == 7)\n\t\tmsg = MSG_PARITY_ERROR;\n\telse\n\t\tmsg = INITIATOR_ERROR;\n\n\n\t/*\n\t *\tIf the NCR stopped on a MOVE ^ DATA_IN, we jump to a \n\t *\tscript that will ignore all data in bytes until phase \n\t *\tchange, since we are not sure the chip will wait the phase \n\t *\tchange prior to delivering the interrupt.\n\t */\n\tif (phase == 1)\n\t\tjmp = NCB_SCRIPTH_PHYS (np, par_err_data_in);\n\telse\n\t\tjmp = NCB_SCRIPTH_PHYS (np, par_err_other);\n\n\tOUTONB (nc_ctest3, CLF );\t/* clear dma fifo  */\n\tOUTB (nc_stest3, TE|CSF);\t/* clear scsi fifo */\n\n\tnp->msgout[0] = msg;\n\tOUTL_DSP (jmp);\n\treturn 1;\n\nreset_all:\n\tncr_start_reset(np);\n\treturn 1;\n}\n\n/*==========================================================\n**\n**\n**\tncr chip exception handler for phase errors.\n**\n**\n**==========================================================\n**\n**\tWe have to construct a new transfer descriptor,\n**\tto transfer the rest of the current block.\n**\n**----------------------------------------------------------\n*/\n\nstatic void ncr_int_ma (struct ncb *np)\n{\n\tu32\tdbc;\n\tu32\trest;\n\tu32\tdsp;\n\tu32\tdsa;\n\tu32\tnxtdsp;\n\tu32\tnewtmp;\n\tu32\t*vdsp;\n\tu32\toadr, olen;\n\tu32\t*tblp;\n\tncrcmd *newcmd;\n\tu_char\tcmd, sbcl;\n\tstruct ccb *cp;\n\n\tdsp\t= INL (nc_dsp);\n\tdbc\t= INL (nc_dbc);\n\tsbcl\t= INB (nc_sbcl);\n\n\tcmd\t= dbc >> 24;\n\trest\t= dbc & 0xffffff;\n\n\t/*\n\t**\tTake into account dma fifo and various buffers and latches,\n\t**\tonly if the interrupted phase is an OUTPUT phase.\n\t*/\n\n\tif ((cmd & 1) == 0) {\n\t\tu_char\tctest5, ss0, ss2;\n\t\tu16\tdelta;\n\n\t\tctest5 = (np->rv_ctest5 & DFS) ? INB (nc_ctest5) : 0;\n\t\tif (ctest5 & DFS)\n\t\t\tdelta=(((ctest5 << 8) | (INB (nc_dfifo) & 0xff)) - rest) & 0x3ff;\n\t\telse\n\t\t\tdelta=(INB (nc_dfifo) - rest) & 0x7f;\n\n\t\t/*\n\t\t**\tThe data in the dma fifo has not been transferred to\n\t\t**\tthe target -> add the amount to the rest\n\t\t**\tand clear the data.\n\t\t**\tCheck the sstat2 register in case of wide transfer.\n\t\t*/\n\n\t\trest += delta;\n\t\tss0  = INB (nc_sstat0);\n\t\tif (ss0 & OLF) rest++;\n\t\tif (ss0 & ORF) rest++;\n\t\tif (INB(nc_scntl3) & EWS) {\n\t\t\tss2 = INB (nc_sstat2);\n\t\t\tif (ss2 & OLF1) rest++;\n\t\t\tif (ss2 & ORF1) rest++;\n\t\t}\n\n\t\tif (DEBUG_FLAGS & (DEBUG_TINY|DEBUG_PHASE))\n\t\t\tprintk (\"P%x%x RL=%d D=%d SS0=%x \", cmd&7, sbcl&7,\n\t\t\t\t(unsigned) rest, (unsigned) delta, ss0);\n\n\t} else\t{\n\t\tif (DEBUG_FLAGS & (DEBUG_TINY|DEBUG_PHASE))\n\t\t\tprintk (\"P%x%x RL=%d \", cmd&7, sbcl&7, rest);\n\t}\n\n\t/*\n\t**\tClear fifos.\n\t*/\n\tOUTONB (nc_ctest3, CLF );\t/* clear dma fifo  */\n\tOUTB (nc_stest3, TE|CSF);\t/* clear scsi fifo */\n\n\t/*\n\t**\tlocate matching cp.\n\t**\tif the interrupted phase is DATA IN or DATA OUT,\n\t**\ttrust the global header.\n\t*/\n\tdsa = INL (nc_dsa);\n\tif (!(cmd & 6)) {\n\t\tcp = np->header.cp;\n\t\tif (CCB_PHYS(cp, phys) != dsa)\n\t\t\tcp = NULL;\n\t} else {\n\t\tcp  = np->ccb;\n\t\twhile (cp && (CCB_PHYS (cp, phys) != dsa))\n\t\t\tcp = cp->link_ccb;\n\t}\n\n\t/*\n\t**\ttry to find the interrupted script command,\n\t**\tand the address at which to continue.\n\t*/\n\tvdsp\t= NULL;\n\tnxtdsp\t= 0;\n\tif\t(dsp >  np->p_script &&\n\t\t dsp <= np->p_script + sizeof(struct script)) {\n\t\tvdsp = (u32 *)((char*)np->script0 + (dsp-np->p_script-8));\n\t\tnxtdsp = dsp;\n\t}\n\telse if\t(dsp >  np->p_scripth &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tvdsp = (u32 *)((char*)np->scripth0 + (dsp-np->p_scripth-8));\n\t\tnxtdsp = dsp;\n\t}\n\telse if (cp) {\n\t\tif\t(dsp == CCB_PHYS (cp, patch[2])) {\n\t\t\tvdsp = &cp->patch[0];\n\t\t\tnxtdsp = scr_to_cpu(vdsp[3]);\n\t\t}\n\t\telse if (dsp == CCB_PHYS (cp, patch[6])) {\n\t\t\tvdsp = &cp->patch[4];\n\t\t\tnxtdsp = scr_to_cpu(vdsp[3]);\n\t\t}\n\t}\n\n\t/*\n\t**\tlog the information\n\t*/\n\n\tif (DEBUG_FLAGS & DEBUG_PHASE) {\n\t\tprintk (\"\\nCP=%p CP2=%p DSP=%x NXT=%x VDSP=%p CMD=%x \",\n\t\t\tcp, np->header.cp,\n\t\t\t(unsigned)dsp,\n\t\t\t(unsigned)nxtdsp, vdsp, cmd);\n\t}\n\n\t/*\n\t**\tcp=0 means that the DSA does not point to a valid control \n\t**\tblock. This should not happen since we donnot use multi-byte \n\t**\tmove while we are being reselected ot after command complete.\n\t**\tWe are not able to recover from such a phase error.\n\t*/\n\tif (!cp) {\n\t\tprintk (\"%s: SCSI phase error fixup: \"\n\t\t\t\"CCB already dequeued (0x%08lx)\\n\", \n\t\t\tncr_name (np), (u_long) np->header.cp);\n\t\tgoto reset_all;\n\t}\n\n\t/*\n\t**\tget old startaddress and old length.\n\t*/\n\n\toadr = scr_to_cpu(vdsp[1]);\n\n\tif (cmd & 0x10) {\t/* Table indirect */\n\t\ttblp = (u32 *) ((char*) &cp->phys + oadr);\n\t\tolen = scr_to_cpu(tblp[0]);\n\t\toadr = scr_to_cpu(tblp[1]);\n\t} else {\n\t\ttblp = (u32 *) 0;\n\t\tolen = scr_to_cpu(vdsp[0]) & 0xffffff;\n\t}\n\n\tif (DEBUG_FLAGS & DEBUG_PHASE) {\n\t\tprintk (\"OCMD=%x\\nTBLP=%p OLEN=%x OADR=%x\\n\",\n\t\t\t(unsigned) (scr_to_cpu(vdsp[0]) >> 24),\n\t\t\ttblp,\n\t\t\t(unsigned) olen,\n\t\t\t(unsigned) oadr);\n\t}\n\n\t/*\n\t**\tcheck cmd against assumed interrupted script command.\n\t*/\n\n\tif (cmd != (scr_to_cpu(vdsp[0]) >> 24)) {\n\t\tPRINT_ADDR(cp->cmd, \"internal error: cmd=%02x != %02x=(vdsp[0] \"\n\t\t\t\t\">> 24)\\n\", cmd, scr_to_cpu(vdsp[0]) >> 24);\n\n\t\tgoto reset_all;\n\t}\n\n\t/*\n\t**\tcp != np->header.cp means that the header of the CCB \n\t**\tcurrently being processed has not yet been copied to \n\t**\tthe global header area. That may happen if the device did \n\t**\tnot accept all our messages after having been selected.\n\t*/\n\tif (cp != np->header.cp) {\n\t\tprintk (\"%s: SCSI phase error fixup: \"\n\t\t\t\"CCB address mismatch (0x%08lx != 0x%08lx)\\n\", \n\t\t\tncr_name (np), (u_long) cp, (u_long) np->header.cp);\n\t}\n\n\t/*\n\t**\tif old phase not dataphase, leave here.\n\t*/\n\n\tif (cmd & 0x06) {\n\t\tPRINT_ADDR(cp->cmd, \"phase change %x-%x %d@%08x resid=%d.\\n\",\n\t\t\tcmd&7, sbcl&7, (unsigned)olen,\n\t\t\t(unsigned)oadr, (unsigned)rest);\n\t\tgoto unexpected_phase;\n\t}\n\n\t/*\n\t**\tchoose the correct patch area.\n\t**\tif savep points to one, choose the other.\n\t*/\n\n\tnewcmd = cp->patch;\n\tnewtmp = CCB_PHYS (cp, patch);\n\tif (newtmp == scr_to_cpu(cp->phys.header.savep)) {\n\t\tnewcmd = &cp->patch[4];\n\t\tnewtmp = CCB_PHYS (cp, patch[4]);\n\t}\n\n\t/*\n\t**\tfillin the commands\n\t*/\n\n\tnewcmd[0] = cpu_to_scr(((cmd & 0x0f) << 24) | rest);\n\tnewcmd[1] = cpu_to_scr(oadr + olen - rest);\n\tnewcmd[2] = cpu_to_scr(SCR_JUMP);\n\tnewcmd[3] = cpu_to_scr(nxtdsp);\n\n\tif (DEBUG_FLAGS & DEBUG_PHASE) {\n\t\tPRINT_ADDR(cp->cmd, \"newcmd[%d] %x %x %x %x.\\n\",\n\t\t\t(int) (newcmd - cp->patch),\n\t\t\t(unsigned)scr_to_cpu(newcmd[0]),\n\t\t\t(unsigned)scr_to_cpu(newcmd[1]),\n\t\t\t(unsigned)scr_to_cpu(newcmd[2]),\n\t\t\t(unsigned)scr_to_cpu(newcmd[3]));\n\t}\n\t/*\n\t**\tfake the return address (to the patch).\n\t**\tand restart script processor at dispatcher.\n\t*/\n\tOUTL (nc_temp, newtmp);\n\tOUTL_DSP (NCB_SCRIPT_PHYS (np, dispatch));\n\treturn;\n\n\t/*\n\t**\tUnexpected phase changes that occurs when the current phase \n\t**\tis not a DATA IN or DATA OUT phase are due to error conditions.\n\t**\tSuch event may only happen when the SCRIPTS is using a \n\t**\tmultibyte SCSI MOVE.\n\t**\n\t**\tPhase change\t\tSome possible cause\n\t**\n\t**\tCOMMAND  --> MSG IN\tSCSI parity error detected by target.\n\t**\tCOMMAND  --> STATUS\tBad command or refused by target.\n\t**\tMSG OUT  --> MSG IN     Message rejected by target.\n\t**\tMSG OUT  --> COMMAND    Bogus target that discards extended\n\t**\t\t\t\tnegotiation messages.\n\t**\n\t**\tThe code below does not care of the new phase and so \n\t**\ttrusts the target. Why to annoy it ?\n\t**\tIf the interrupted phase is COMMAND phase, we restart at\n\t**\tdispatcher.\n\t**\tIf a target does not get all the messages after selection, \n\t**\tthe code assumes blindly that the target discards extended \n\t**\tmessages and clears the negotiation status.\n\t**\tIf the target does not want all our response to negotiation,\n\t**\twe force a SIR_NEGO_PROTO interrupt (it is a hack that avoids \n\t**\tbloat for such a should_not_happen situation).\n\t**\tIn all other situation, we reset the BUS.\n\t**\tAre these assumptions reasonable ? (Wait and see ...)\n\t*/\nunexpected_phase:\n\tdsp -= 8;\n\tnxtdsp = 0;\n\n\tswitch (cmd & 7) {\n\tcase 2:\t/* COMMAND phase */\n\t\tnxtdsp = NCB_SCRIPT_PHYS (np, dispatch);\n\t\tbreak;\n#if 0\n\tcase 3:\t/* STATUS  phase */\n\t\tnxtdsp = NCB_SCRIPT_PHYS (np, dispatch);\n\t\tbreak;\n#endif\n\tcase 6:\t/* MSG OUT phase */\n\t\tnp->scripth->nxtdsp_go_on[0] = cpu_to_scr(dsp + 8);\n\t\tif\t(dsp == NCB_SCRIPT_PHYS (np, send_ident)) {\n\t\t\tcp->host_status = HS_BUSY;\n\t\t\tnxtdsp = NCB_SCRIPTH_PHYS (np, clratn_go_on);\n\t\t}\n\t\telse if\t(dsp == NCB_SCRIPTH_PHYS (np, send_wdtr) ||\n\t\t\t dsp == NCB_SCRIPTH_PHYS (np, send_sdtr)) {\n\t\t\tnxtdsp = NCB_SCRIPTH_PHYS (np, nego_bad_phase);\n\t\t}\n\t\tbreak;\n#if 0\n\tcase 7:\t/* MSG IN  phase */\n\t\tnxtdsp = NCB_SCRIPT_PHYS (np, clrack);\n\t\tbreak;\n#endif\n\t}\n\n\tif (nxtdsp) {\n\t\tOUTL_DSP (nxtdsp);\n\t\treturn;\n\t}\n\nreset_all:\n\tncr_start_reset(np);\n}\n\n\nstatic void ncr_sir_to_redo(struct ncb *np, int num, struct ccb *cp)\n{\n\tstruct scsi_cmnd *cmd\t= cp->cmd;\n\tstruct tcb *tp\t= &np->target[cmd->device->id];\n\tstruct lcb *lp\t= tp->lp[cmd->device->lun];\n\tstruct list_head *qp;\n\tstruct ccb *\tcp2;\n\tint\t\tdisc_cnt = 0;\n\tint\t\tbusy_cnt = 0;\n\tu32\t\tstartp;\n\tu_char\t\ts_status = INB (SS_PRT);\n\n\t/*\n\t**\tLet the SCRIPTS processor skip all not yet started CCBs,\n\t**\tand count disconnected CCBs. Since the busy queue is in \n\t**\tthe same order as the chip start queue, disconnected CCBs \n\t**\tare before cp and busy ones after.\n\t*/\n\tif (lp) {\n\t\tqp = lp->busy_ccbq.prev;\n\t\twhile (qp != &lp->busy_ccbq) {\n\t\t\tcp2 = list_entry(qp, struct ccb, link_ccbq);\n\t\t\tqp  = qp->prev;\n\t\t\t++busy_cnt;\n\t\t\tif (cp2 == cp)\n\t\t\t\tbreak;\n\t\t\tcp2->start.schedule.l_paddr =\n\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS (np, skip));\n\t\t}\n\t\tlp->held_ccb = cp;\t/* Requeue when this one completes */\n\t\tdisc_cnt = lp->queuedccbs - busy_cnt;\n\t}\n\n\tswitch(s_status) {\n\tdefault:\t/* Just for safety, should never happen */\n\tcase SAM_STAT_TASK_SET_FULL:\n\t\t/*\n\t\t**\tDecrease number of tags to the number of \n\t\t**\tdisconnected commands.\n\t\t*/\n\t\tif (!lp)\n\t\t\tgoto out;\n\t\tif (bootverbose >= 1) {\n\t\t\tPRINT_ADDR(cmd, \"QUEUE FULL! %d busy, %d disconnected \"\n\t\t\t\t\t\"CCBs\\n\", busy_cnt, disc_cnt);\n\t\t}\n\t\tif (disc_cnt < lp->numtags) {\n\t\t\tlp->numtags\t= disc_cnt > 2 ? disc_cnt : 2;\n\t\t\tlp->num_good\t= 0;\n\t\t\tncr_setup_tags (np, cmd->device);\n\t\t}\n\t\t/*\n\t\t**\tRequeue the command to the start queue.\n\t\t**\tIf any disconnected commands,\n\t\t**\t\tClear SIGP.\n\t\t**\t\tJump to reselect.\n\t\t*/\n\t\tcp->phys.header.savep = cp->startp;\n\t\tcp->host_status = HS_BUSY;\n\t\tcp->scsi_status = SAM_STAT_ILLEGAL;\n\n\t\tncr_put_start_queue(np, cp);\n\t\tif (disc_cnt)\n\t\t\tINB (nc_ctest2);\t\t/* Clear SIGP */\n\t\tOUTL_DSP (NCB_SCRIPT_PHYS (np, reselect));\n\t\treturn;\n\tcase SAM_STAT_COMMAND_TERMINATED:\n\tcase SAM_STAT_CHECK_CONDITION:\n\t\t/*\n\t\t**\tIf we were requesting sense, give up.\n\t\t*/\n\t\tif (cp->auto_sense)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t**\tDevice returned CHECK CONDITION status.\n\t\t**\tPrepare all needed data strutures for getting \n\t\t**\tsense data.\n\t\t**\n\t\t**\tidentify message\n\t\t*/\n\t\tcp->scsi_smsg2[0]\t= IDENTIFY(0, cmd->device->lun);\n\t\tcp->phys.smsg.addr\t= cpu_to_scr(CCB_PHYS (cp, scsi_smsg2));\n\t\tcp->phys.smsg.size\t= cpu_to_scr(1);\n\n\t\t/*\n\t\t**\tsense command\n\t\t*/\n\t\tcp->phys.cmd.addr\t= cpu_to_scr(CCB_PHYS (cp, sensecmd));\n\t\tcp->phys.cmd.size\t= cpu_to_scr(6);\n\n\t\t/*\n\t\t**\tpatch requested size into sense command\n\t\t*/\n\t\tcp->sensecmd[0]\t\t= 0x03;\n\t\tcp->sensecmd[1]\t\t= (cmd->device->lun & 0x7) << 5;\n\t\tcp->sensecmd[4]\t\t= sizeof(cp->sense_buf);\n\n\t\t/*\n\t\t**\tsense data\n\t\t*/\n\t\tmemset(cp->sense_buf, 0, sizeof(cp->sense_buf));\n\t\tcp->phys.sense.addr\t= cpu_to_scr(CCB_PHYS(cp,sense_buf[0]));\n\t\tcp->phys.sense.size\t= cpu_to_scr(sizeof(cp->sense_buf));\n\n\t\t/*\n\t\t**\trequeue the command.\n\t\t*/\n\t\tstartp = cpu_to_scr(NCB_SCRIPTH_PHYS (np, sdata_in));\n\n\t\tcp->phys.header.savep\t= startp;\n\t\tcp->phys.header.goalp\t= startp + 24;\n\t\tcp->phys.header.lastp\t= startp;\n\t\tcp->phys.header.wgoalp\t= startp + 24;\n\t\tcp->phys.header.wlastp\t= startp;\n\n\t\tcp->host_status = HS_BUSY;\n\t\tcp->scsi_status = SAM_STAT_ILLEGAL;\n\t\tcp->auto_sense\t= s_status;\n\n\t\tcp->start.schedule.l_paddr =\n\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS (np, select));\n\n\t\t/*\n\t\t**\tSelect without ATN for quirky devices.\n\t\t*/\n\t\tif (cmd->device->select_no_atn)\n\t\t\tcp->start.schedule.l_paddr =\n\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS (np, select_no_atn));\n\n\t\tncr_put_start_queue(np, cp);\n\n\t\tOUTL_DSP (NCB_SCRIPT_PHYS (np, start));\n\t\treturn;\n\t}\n\nout:\n\tOUTONB_STD ();\n\treturn;\n}\n\n\n/*==========================================================\n**\n**\n**      ncr chip exception handler for programmed interrupts.\n**\n**\n**==========================================================\n*/\n\nvoid ncr_int_sir (struct ncb *np)\n{\n\tu_char scntl3;\n\tu_char chg, ofs, per, fak, wide;\n\tu_char num = INB (nc_dsps);\n\tstruct ccb *cp=NULL;\n\tu_long\tdsa    = INL (nc_dsa);\n\tu_char\ttarget = INB (nc_sdid) & 0x0f;\n\tstruct tcb *tp     = &np->target[target];\n\tstruct scsi_target *starget = tp->starget;\n\n\tif (DEBUG_FLAGS & DEBUG_TINY) printk (\"I#%d\", num);\n\n\tswitch (num) {\n\tcase SIR_INTFLY:\n\t\t/*\n\t\t**\tThis is used for HP Zalon/53c720 where INTFLY\n\t\t**\toperation is currently broken.\n\t\t*/\n\t\tncr_wakeup_done(np);\n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\n\t\tOUTL(nc_dsp, NCB_SCRIPT_PHYS (np, done_end) + 8);\n#else\n\t\tOUTL(nc_dsp, NCB_SCRIPT_PHYS (np, start));\n#endif\n\t\treturn;\n\tcase SIR_RESEL_NO_MSG_IN:\n\tcase SIR_RESEL_NO_IDENTIFY:\n\t\t/*\n\t\t**\tIf devices reselecting without sending an IDENTIFY \n\t\t**\tmessage still exist, this should help.\n\t\t**\tWe just assume lun=0, 1 CCB, no tag.\n\t\t*/\n\t\tif (tp->lp[0]) { \n\t\t\tOUTL_DSP (scr_to_cpu(tp->lp[0]->jump_ccb[0]));\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tcase SIR_RESEL_BAD_TARGET:\t/* Will send a TARGET RESET message */\n\tcase SIR_RESEL_BAD_LUN:\t\t/* Will send a TARGET RESET message */\n\tcase SIR_RESEL_BAD_I_T_L_Q:\t/* Will send an ABORT TAG message   */\n\tcase SIR_RESEL_BAD_I_T_L:\t/* Will send an ABORT message\t    */\n\t\tprintk (\"%s:%d: SIR %d, \"\n\t\t\t\"incorrect nexus identification on reselection\\n\",\n\t\t\tncr_name (np), target, num);\n\t\tgoto out;\n\tcase SIR_DONE_OVERFLOW:\n\t\tprintk (\"%s:%d: SIR %d, \"\n\t\t\t\"CCB done queue overflow\\n\",\n\t\t\tncr_name (np), target, num);\n\t\tgoto out;\n\tcase SIR_BAD_STATUS:\n\t\tcp = np->header.cp;\n\t\tif (!cp || CCB_PHYS (cp, phys) != dsa)\n\t\t\tgoto out;\n\t\tncr_sir_to_redo(np, num, cp);\n\t\treturn;\n\tdefault:\n\t\t/*\n\t\t**\tlookup the ccb\n\t\t*/\n\t\tcp = np->ccb;\n\t\twhile (cp && (CCB_PHYS (cp, phys) != dsa))\n\t\t\tcp = cp->link_ccb;\n\n\t\tBUG_ON(!cp);\n\t\tBUG_ON(cp != np->header.cp);\n\n\t\tif (!cp || cp != np->header.cp)\n\t\t\tgoto out;\n\t}\n\n\tswitch (num) {\n/*-----------------------------------------------------------------------------\n**\n**\tWas Sie schon immer ueber transfermode negotiation wissen wollten ...\n**\t(\"Everything you've always wanted to know about transfer mode\n**\t  negotiation\")\n**\n**\tWe try to negotiate sync and wide transfer only after\n**\ta successful inquire command. We look at byte 7 of the\n**\tinquire data to determine the capabilities of the target.\n**\n**\tWhen we try to negotiate, we append the negotiation message\n**\tto the identify and (maybe) simple tag message.\n**\tThe host status field is set to HS_NEGOTIATE to mark this\n**\tsituation.\n**\n**\tIf the target doesn't answer this message immediately\n**\t(as required by the standard), the SIR_NEGO_FAIL interrupt\n**\twill be raised eventually.\n**\tThe handler removes the HS_NEGOTIATE status, and sets the\n**\tnegotiated value to the default (async / nowide).\n**\n**\tIf we receive a matching answer immediately, we check it\n**\tfor validity, and set the values.\n**\n**\tIf we receive a Reject message immediately, we assume the\n**\tnegotiation has failed, and fall back to standard values.\n**\n**\tIf we receive a negotiation message while not in HS_NEGOTIATE\n**\tstate, it's a target initiated negotiation. We prepare a\n**\t(hopefully) valid answer, set our parameters, and send back \n**\tthis answer to the target.\n**\n**\tIf the target doesn't fetch the answer (no message out phase),\n**\twe assume the negotiation has failed, and fall back to default\n**\tsettings.\n**\n**\tWhen we set the values, we adjust them in all ccbs belonging \n**\tto this target, in the controller's register, and in the \"phys\"\n**\tfield of the controller's struct ncb.\n**\n**\tPossible cases:\t\t   hs  sir   msg_in value  send   goto\n**\tWe try to negotiate:\n**\t-> target doesn't msgin    NEG FAIL  noop   defa.  -      dispatch\n**\t-> target rejected our msg NEG FAIL  reject defa.  -      dispatch\n**\t-> target answered  (ok)   NEG SYNC  sdtr   set    -      clrack\n**\t-> target answered (!ok)   NEG SYNC  sdtr   defa.  REJ--->msg_bad\n**\t-> target answered  (ok)   NEG WIDE  wdtr   set    -      clrack\n**\t-> target answered (!ok)   NEG WIDE  wdtr   defa.  REJ--->msg_bad\n**\t-> any other msgin\t   NEG FAIL  noop   defa.  -      dispatch\n**\n**\tTarget tries to negotiate:\n**\t-> incoming message\t   --- SYNC  sdtr   set    SDTR   -\n**\t-> incoming message\t   --- WIDE  wdtr   set    WDTR   -\n**      We sent our answer:\n**\t-> target doesn't msgout   --- PROTO ?      defa.  -      dispatch\n**\n**-----------------------------------------------------------------------------\n*/\n\n\tcase SIR_NEGO_FAILED:\n\t\t/*-------------------------------------------------------\n\t\t**\n\t\t**\tNegotiation failed.\n\t\t**\tTarget doesn't send an answer message,\n\t\t**\tor target rejected our message.\n\t\t**\n\t\t**      Remove negotiation request.\n\t\t**\n\t\t**-------------------------------------------------------\n\t\t*/\n\t\tOUTB (HS_PRT, HS_BUSY);\n\n\t\tfallthrough;\n\n\tcase SIR_NEGO_PROTO:\n\t\t/*-------------------------------------------------------\n\t\t**\n\t\t**\tNegotiation failed.\n\t\t**\tTarget doesn't fetch the answer message.\n\t\t**\n\t\t**-------------------------------------------------------\n\t\t*/\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->cmd, \"negotiation failed sir=%x \"\n\t\t\t\t\t\"status=%x.\\n\", num, cp->nego_status);\n\t\t}\n\n\t\t/*\n\t\t**\tany error in negotiation:\n\t\t**\tfall back to default mode.\n\t\t*/\n\t\tswitch (cp->nego_status) {\n\n\t\tcase NS_SYNC:\n\t\t\tspi_period(starget) = 0;\n\t\t\tspi_offset(starget) = 0;\n\t\t\tncr_setsync (np, cp, 0, 0xe0);\n\t\t\tbreak;\n\n\t\tcase NS_WIDE:\n\t\t\tspi_width(starget) = 0;\n\t\t\tncr_setwide (np, cp, 0, 0);\n\t\t\tbreak;\n\n\t\t}\n\t\tnp->msgin [0] = NOP;\n\t\tnp->msgout[0] = NOP;\n\t\tcp->nego_status = 0;\n\t\tbreak;\n\n\tcase SIR_NEGO_SYNC:\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tncr_print_msg(cp, \"sync msgin\", np->msgin);\n\t\t}\n\n\t\tchg = 0;\n\t\tper = np->msgin[3];\n\t\tofs = np->msgin[4];\n\t\tif (ofs==0) per=255;\n\n\t\t/*\n\t\t**      if target sends SDTR message,\n\t\t**\t      it CAN transfer synch.\n\t\t*/\n\n\t\tif (ofs && starget)\n\t\t\tspi_support_sync(starget) = 1;\n\n\t\t/*\n\t\t**\tcheck values against driver limits.\n\t\t*/\n\n\t\tif (per < np->minsync)\n\t\t\t{chg = 1; per = np->minsync;}\n\t\tif (per < tp->minsync)\n\t\t\t{chg = 1; per = tp->minsync;}\n\t\tif (ofs > tp->maxoffs)\n\t\t\t{chg = 1; ofs = tp->maxoffs;}\n\n\t\t/*\n\t\t**\tCheck against controller limits.\n\t\t*/\n\t\tfak\t= 7;\n\t\tscntl3\t= 0;\n\t\tif (ofs != 0) {\n\t\t\tncr_getsync(np, per, &fak, &scntl3);\n\t\t\tif (fak > 7) {\n\t\t\t\tchg = 1;\n\t\t\t\tofs = 0;\n\t\t\t}\n\t\t}\n\t\tif (ofs == 0) {\n\t\t\tfak\t= 7;\n\t\t\tper\t= 0;\n\t\t\tscntl3\t= 0;\n\t\t\ttp->minsync = 0;\n\t\t}\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->cmd, \"sync: per=%d scntl3=0x%x ofs=%d \"\n\t\t\t\t\"fak=%d chg=%d.\\n\", per, scntl3, ofs, fak, chg);\n\t\t}\n\n\t\tif (INB (HS_PRT) == HS_NEGOTIATE) {\n\t\t\tOUTB (HS_PRT, HS_BUSY);\n\t\t\tswitch (cp->nego_status) {\n\n\t\t\tcase NS_SYNC:\n\t\t\t\t/* This was an answer message */\n\t\t\t\tif (chg) {\n\t\t\t\t\t/* Answer wasn't acceptable.  */\n\t\t\t\t\tspi_period(starget) = 0;\n\t\t\t\t\tspi_offset(starget) = 0;\n\t\t\t\t\tncr_setsync(np, cp, 0, 0xe0);\n\t\t\t\t\tOUTL_DSP(NCB_SCRIPT_PHYS (np, msg_bad));\n\t\t\t\t} else {\n\t\t\t\t\t/* Answer is ok.  */\n\t\t\t\t\tspi_period(starget) = per;\n\t\t\t\t\tspi_offset(starget) = ofs;\n\t\t\t\t\tncr_setsync(np, cp, scntl3, (fak<<5)|ofs);\n\t\t\t\t\tOUTL_DSP(NCB_SCRIPT_PHYS (np, clrack));\n\t\t\t\t}\n\t\t\t\treturn;\n\n\t\t\tcase NS_WIDE:\n\t\t\t\tspi_width(starget) = 0;\n\t\t\t\tncr_setwide(np, cp, 0, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t**\tIt was a request. Set value and\n\t\t**      prepare an answer message\n\t\t*/\n\n\t\tspi_period(starget) = per;\n\t\tspi_offset(starget) = ofs;\n\t\tncr_setsync(np, cp, scntl3, (fak<<5)|ofs);\n\n\t\tspi_populate_sync_msg(np->msgout, per, ofs);\n\t\tcp->nego_status = NS_SYNC;\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tncr_print_msg(cp, \"sync msgout\", np->msgout);\n\t\t}\n\n\t\tif (!ofs) {\n\t\t\tOUTL_DSP (NCB_SCRIPT_PHYS (np, msg_bad));\n\t\t\treturn;\n\t\t}\n\t\tnp->msgin [0] = NOP;\n\n\t\tbreak;\n\n\tcase SIR_NEGO_WIDE:\n\t\t/*\n\t\t**\tWide request message received.\n\t\t*/\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tncr_print_msg(cp, \"wide msgin\", np->msgin);\n\t\t}\n\n\t\t/*\n\t\t**\tget requested values.\n\t\t*/\n\n\t\tchg  = 0;\n\t\twide = np->msgin[3];\n\n\t\t/*\n\t\t**      if target sends WDTR message,\n\t\t**\t      it CAN transfer wide.\n\t\t*/\n\n\t\tif (wide && starget)\n\t\t\tspi_support_wide(starget) = 1;\n\n\t\t/*\n\t\t**\tcheck values against driver limits.\n\t\t*/\n\n\t\tif (wide > tp->usrwide)\n\t\t\t{chg = 1; wide = tp->usrwide;}\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->cmd, \"wide: wide=%d chg=%d.\\n\", wide,\n\t\t\t\t\tchg);\n\t\t}\n\n\t\tif (INB (HS_PRT) == HS_NEGOTIATE) {\n\t\t\tOUTB (HS_PRT, HS_BUSY);\n\t\t\tswitch (cp->nego_status) {\n\n\t\t\tcase NS_WIDE:\n\t\t\t\t/*\n\t\t\t\t**      This was an answer message\n\t\t\t\t*/\n\t\t\t\tif (chg) {\n\t\t\t\t\t/* Answer wasn't acceptable.  */\n\t\t\t\t\tspi_width(starget) = 0;\n\t\t\t\t\tncr_setwide(np, cp, 0, 1);\n\t\t\t\t\tOUTL_DSP (NCB_SCRIPT_PHYS (np, msg_bad));\n\t\t\t\t} else {\n\t\t\t\t\t/* Answer is ok.  */\n\t\t\t\t\tspi_width(starget) = wide;\n\t\t\t\t\tncr_setwide(np, cp, wide, 1);\n\t\t\t\t\tOUTL_DSP (NCB_SCRIPT_PHYS (np, clrack));\n\t\t\t\t}\n\t\t\t\treturn;\n\n\t\t\tcase NS_SYNC:\n\t\t\t\tspi_period(starget) = 0;\n\t\t\t\tspi_offset(starget) = 0;\n\t\t\t\tncr_setsync(np, cp, 0, 0xe0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t**\tIt was a request, set value and\n\t\t**      prepare an answer message\n\t\t*/\n\n\t\tspi_width(starget) = wide;\n\t\tncr_setwide(np, cp, wide, 1);\n\t\tspi_populate_width_msg(np->msgout, wide);\n\n\t\tnp->msgin [0] = NOP;\n\n\t\tcp->nego_status = NS_WIDE;\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tncr_print_msg(cp, \"wide msgout\", np->msgin);\n\t\t}\n\t\tbreak;\n\n/*--------------------------------------------------------------------\n**\n**\tProcessing of special messages\n**\n**--------------------------------------------------------------------\n*/\n\n\tcase SIR_REJECT_RECEIVED:\n\t\t/*-----------------------------------------------\n\t\t**\n\t\t**\tWe received a MESSAGE_REJECT.\n\t\t**\n\t\t**-----------------------------------------------\n\t\t*/\n\n\t\tPRINT_ADDR(cp->cmd, \"MESSAGE_REJECT received (%x:%x).\\n\",\n\t\t\t(unsigned)scr_to_cpu(np->lastmsg), np->msgout[0]);\n\t\tbreak;\n\n\tcase SIR_REJECT_SENT:\n\t\t/*-----------------------------------------------\n\t\t**\n\t\t**\tWe received an unknown message\n\t\t**\n\t\t**-----------------------------------------------\n\t\t*/\n\n\t\tncr_print_msg(cp, \"MESSAGE_REJECT sent for\", np->msgin);\n\t\tbreak;\n\n/*--------------------------------------------------------------------\n**\n**\tProcessing of special messages\n**\n**--------------------------------------------------------------------\n*/\n\n\tcase SIR_IGN_RESIDUE:\n\t\t/*-----------------------------------------------\n\t\t**\n\t\t**\tWe received an IGNORE RESIDUE message,\n\t\t**\twhich couldn't be handled by the script.\n\t\t**\n\t\t**-----------------------------------------------\n\t\t*/\n\n\t\tPRINT_ADDR(cp->cmd, \"IGNORE_WIDE_RESIDUE received, but not yet \"\n\t\t\t\t\"implemented.\\n\");\n\t\tbreak;\n#if 0\n\tcase SIR_MISSING_SAVE:\n\t\t/*-----------------------------------------------\n\t\t**\n\t\t**\tWe received an DISCONNECT message,\n\t\t**\tbut the datapointer wasn't saved before.\n\t\t**\n\t\t**-----------------------------------------------\n\t\t*/\n\n\t\tPRINT_ADDR(cp->cmd, \"DISCONNECT received, but datapointer \"\n\t\t\t\t\"not saved: data=%x save=%x goal=%x.\\n\",\n\t\t\t(unsigned) INL (nc_temp),\n\t\t\t(unsigned) scr_to_cpu(np->header.savep),\n\t\t\t(unsigned) scr_to_cpu(np->header.goalp));\n\t\tbreak;\n#endif\n\t}\n\nout:\n\tOUTONB_STD ();\n}\n\n/*==========================================================\n**\n**\n**\tAcquire a control block\n**\n**\n**==========================================================\n*/\n\nstatic struct ccb *ncr_get_ccb(struct ncb *np, struct scsi_cmnd *cmd)\n{\n\tu_char tn = cmd->device->id;\n\tu_char ln = cmd->device->lun;\n\tstruct tcb *tp = &np->target[tn];\n\tstruct lcb *lp = tp->lp[ln];\n\tu_char tag = NO_TAG;\n\tstruct ccb *cp = NULL;\n\n\t/*\n\t**\tLun structure available ?\n\t*/\n\tif (lp) {\n\t\tstruct list_head *qp;\n\t\t/*\n\t\t**\tKeep from using more tags than we can handle.\n\t\t*/\n\t\tif (lp->usetags && lp->busyccbs >= lp->maxnxs)\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t**\tAllocate a new CCB if needed.\n\t\t*/\n\t\tif (list_empty(&lp->free_ccbq))\n\t\t\tncr_alloc_ccb(np, tn, ln);\n\n\t\t/*\n\t\t**\tLook for free CCB\n\t\t*/\n\t\tqp = ncr_list_pop(&lp->free_ccbq);\n\t\tif (qp) {\n\t\t\tcp = list_entry(qp, struct ccb, link_ccbq);\n\t\t\tif (cp->magic) {\n\t\t\t\tPRINT_ADDR(cmd, \"ccb free list corrupted \"\n\t\t\t\t\t\t\"(@%p)\\n\", cp);\n\t\t\t\tcp = NULL;\n\t\t\t} else {\n\t\t\t\tlist_add_tail(qp, &lp->wait_ccbq);\n\t\t\t\t++lp->busyccbs;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t**\tIf a CCB is available,\n\t\t**\tGet a tag for this nexus if required.\n\t\t*/\n\t\tif (cp) {\n\t\t\tif (lp->usetags)\n\t\t\t\ttag = lp->cb_tags[lp->ia_tag];\n\t\t}\n\t\telse if (lp->actccbs > 0)\n\t\t\treturn NULL;\n\t}\n\n\t/*\n\t**\tif nothing available, take the default.\n\t*/\n\tif (!cp)\n\t\tcp = np->ccb;\n\n\t/*\n\t**\tWait until available.\n\t*/\n#if 0\n\twhile (cp->magic) {\n\t\tif (flags & SCSI_NOSLEEP) break;\n\t\tif (tsleep ((caddr_t)cp, PRIBIO|PCATCH, \"ncr\", 0))\n\t\t\tbreak;\n\t}\n#endif\n\n\tif (cp->magic)\n\t\treturn NULL;\n\n\tcp->magic = 1;\n\n\t/*\n\t**\tMove to next available tag if tag used.\n\t*/\n\tif (lp) {\n\t\tif (tag != NO_TAG) {\n\t\t\t++lp->ia_tag;\n\t\t\tif (lp->ia_tag == MAX_TAGS)\n\t\t\t\tlp->ia_tag = 0;\n\t\t\tlp->tags_umap |= (((tagmap_t) 1) << tag);\n\t\t}\n\t}\n\n\t/*\n\t**\tRemember all informations needed to free this CCB.\n\t*/\n\tcp->tag\t   = tag;\n\tcp->target = tn;\n\tcp->lun    = ln;\n\n\tif (DEBUG_FLAGS & DEBUG_TAGS) {\n\t\tPRINT_ADDR(cmd, \"ccb @%p using tag %d.\\n\", cp, tag);\n\t}\n\n\treturn cp;\n}\n\n/*==========================================================\n**\n**\n**\tRelease one control block\n**\n**\n**==========================================================\n*/\n\nstatic void ncr_free_ccb (struct ncb *np, struct ccb *cp)\n{\n\tstruct tcb *tp = &np->target[cp->target];\n\tstruct lcb *lp = tp->lp[cp->lun];\n\n\tif (DEBUG_FLAGS & DEBUG_TAGS) {\n\t\tPRINT_ADDR(cp->cmd, \"ccb @%p freeing tag %d.\\n\", cp, cp->tag);\n\t}\n\n\t/*\n\t**\tIf lun control block available,\n\t**\tdecrement active commands and increment credit, \n\t**\tfree the tag if any and remove the JUMP for reselect.\n\t*/\n\tif (lp) {\n\t\tif (cp->tag != NO_TAG) {\n\t\t\tlp->cb_tags[lp->if_tag++] = cp->tag;\n\t\t\tif (lp->if_tag == MAX_TAGS)\n\t\t\t\tlp->if_tag = 0;\n\t\t\tlp->tags_umap &= ~(((tagmap_t) 1) << cp->tag);\n\t\t\tlp->tags_smap &= lp->tags_umap;\n\t\t\tlp->jump_ccb[cp->tag] =\n\t\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS(np, bad_i_t_l_q));\n\t\t} else {\n\t\t\tlp->jump_ccb[0] =\n\t\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS(np, bad_i_t_l));\n\t\t}\n\t}\n\n\t/*\n\t**\tMake this CCB available.\n\t*/\n\n\tif (lp) {\n\t\tif (cp != np->ccb)\n\t\t\tlist_move(&cp->link_ccbq, &lp->free_ccbq);\n\t\t--lp->busyccbs;\n\t\tif (cp->queued) {\n\t\t\t--lp->queuedccbs;\n\t\t}\n\t}\n\tcp -> host_status = HS_IDLE;\n\tcp -> magic = 0;\n\tif (cp->queued) {\n\t\t--np->queuedccbs;\n\t\tcp->queued = 0;\n\t}\n\n#if 0\n\tif (cp == np->ccb)\n\t\twakeup ((caddr_t) cp);\n#endif\n}\n\n\n#define ncr_reg_bus_addr(r) (np->paddr + offsetof (struct ncr_reg, r))\n\n/*------------------------------------------------------------------------\n**\tInitialize the fixed part of a CCB structure.\n**------------------------------------------------------------------------\n**------------------------------------------------------------------------\n*/\nstatic void ncr_init_ccb(struct ncb *np, struct ccb *cp)\n{\n\tncrcmd copy_4 = np->features & FE_PFEN ? SCR_COPY(4) : SCR_COPY_F(4);\n\n\t/*\n\t**\tRemember virtual and bus address of this ccb.\n\t*/\n\tcp->p_ccb \t   = vtobus(cp);\n\tcp->phys.header.cp = cp;\n\n\t/*\n\t**\tThis allows list_del to work for the default ccb.\n\t*/\n\tINIT_LIST_HEAD(&cp->link_ccbq);\n\n\t/*\n\t**\tInitialyze the start and restart launch script.\n\t**\n\t**\tCOPY(4) @(...p_phys), @(dsa)\n\t**\tJUMP @(sched_point)\n\t*/\n\tcp->start.setup_dsa[0]\t = cpu_to_scr(copy_4);\n\tcp->start.setup_dsa[1]\t = cpu_to_scr(CCB_PHYS(cp, start.p_phys));\n\tcp->start.setup_dsa[2]\t = cpu_to_scr(ncr_reg_bus_addr(nc_dsa));\n\tcp->start.schedule.l_cmd = cpu_to_scr(SCR_JUMP);\n\tcp->start.p_phys\t = cpu_to_scr(CCB_PHYS(cp, phys));\n\n\tmemcpy(&cp->restart, &cp->start, sizeof(cp->restart));\n\n\tcp->start.schedule.l_paddr   = cpu_to_scr(NCB_SCRIPT_PHYS (np, idle));\n\tcp->restart.schedule.l_paddr = cpu_to_scr(NCB_SCRIPTH_PHYS (np, abort));\n}\n\n\n/*------------------------------------------------------------------------\n**\tAllocate a CCB and initialize its fixed part.\n**------------------------------------------------------------------------\n**------------------------------------------------------------------------\n*/\nstatic void ncr_alloc_ccb(struct ncb *np, u_char tn, u_char ln)\n{\n\tstruct tcb *tp = &np->target[tn];\n\tstruct lcb *lp = tp->lp[ln];\n\tstruct ccb *cp = NULL;\n\n\t/*\n\t**\tAllocate memory for this CCB.\n\t*/\n\tcp = m_calloc_dma(sizeof(struct ccb), \"CCB\");\n\tif (!cp)\n\t\treturn;\n\n\t/*\n\t**\tCount it and initialyze it.\n\t*/\n\tlp->actccbs++;\n\tnp->actccbs++;\n\tmemset(cp, 0, sizeof (*cp));\n\tncr_init_ccb(np, cp);\n\n\t/*\n\t**\tChain into wakeup list and free ccb queue and take it \n\t**\tinto account for tagged commands.\n\t*/\n\tcp->link_ccb      = np->ccb->link_ccb;\n\tnp->ccb->link_ccb = cp;\n\n\tlist_add(&cp->link_ccbq, &lp->free_ccbq);\n}\n\n/*==========================================================\n**\n**\n**      Allocation of resources for Targets/Luns/Tags.\n**\n**\n**==========================================================\n*/\n\n\n/*------------------------------------------------------------------------\n**\tTarget control block initialisation.\n**------------------------------------------------------------------------\n**\tThis data structure is fully initialized after a SCSI command \n**\thas been successfully completed for this target.\n**\tIt contains a SCRIPT that is called on target reselection.\n**------------------------------------------------------------------------\n*/\nstatic void ncr_init_tcb (struct ncb *np, u_char tn)\n{\n\tstruct tcb *tp = &np->target[tn];\n\tncrcmd copy_1 = np->features & FE_PFEN ? SCR_COPY(1) : SCR_COPY_F(1);\n\tint th = tn & 3;\n\tint i;\n\n\t/*\n\t**\tJump to next tcb if SFBR does not match this target.\n\t**\tJUMP  IF (SFBR != #target#), @(next tcb)\n\t*/\n\ttp->jump_tcb.l_cmd   =\n\t\tcpu_to_scr((SCR_JUMP ^ IFFALSE (DATA (0x80 + tn))));\n\ttp->jump_tcb.l_paddr = np->jump_tcb[th].l_paddr;\n\n\t/*\n\t**\tLoad the synchronous transfer register.\n\t**\tCOPY @(tp->sval), @(sxfer)\n\t*/\n\ttp->getscr[0] =\tcpu_to_scr(copy_1);\n\ttp->getscr[1] = cpu_to_scr(vtobus (&tp->sval));\n#ifdef SCSI_NCR_BIG_ENDIAN\n\ttp->getscr[2] = cpu_to_scr(ncr_reg_bus_addr(nc_sxfer) ^ 3);\n#else\n\ttp->getscr[2] = cpu_to_scr(ncr_reg_bus_addr(nc_sxfer));\n#endif\n\n\t/*\n\t**\tLoad the timing register.\n\t**\tCOPY @(tp->wval), @(scntl3)\n\t*/\n\ttp->getscr[3] =\tcpu_to_scr(copy_1);\n\ttp->getscr[4] = cpu_to_scr(vtobus (&tp->wval));\n#ifdef SCSI_NCR_BIG_ENDIAN\n\ttp->getscr[5] = cpu_to_scr(ncr_reg_bus_addr(nc_scntl3) ^ 3);\n#else\n\ttp->getscr[5] = cpu_to_scr(ncr_reg_bus_addr(nc_scntl3));\n#endif\n\n\t/*\n\t**\tGet the IDENTIFY message and the lun.\n\t**\tCALL @script(resel_lun)\n\t*/\n\ttp->call_lun.l_cmd   = cpu_to_scr(SCR_CALL);\n\ttp->call_lun.l_paddr = cpu_to_scr(NCB_SCRIPT_PHYS (np, resel_lun));\n\n\t/*\n\t**\tLook for the lun control block of this nexus.\n\t**\tFor i = 0 to 3\n\t**\t\tJUMP ^ IFTRUE (MASK (i, 3)), @(next_lcb)\n\t*/\n\tfor (i = 0 ; i < 4 ; i++) {\n\t\ttp->jump_lcb[i].l_cmd   =\n\t\t\t\tcpu_to_scr((SCR_JUMP ^ IFTRUE (MASK (i, 3))));\n\t\ttp->jump_lcb[i].l_paddr =\n\t\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS (np, bad_identify));\n\t}\n\n\t/*\n\t**\tLink this target control block to the JUMP chain.\n\t*/\n\tnp->jump_tcb[th].l_paddr = cpu_to_scr(vtobus (&tp->jump_tcb));\n\n\t/*\n\t**\tThese assert's should be moved at driver initialisations.\n\t*/\n#ifdef SCSI_NCR_BIG_ENDIAN\n\tBUG_ON(((offsetof(struct ncr_reg, nc_sxfer) ^\n\t\t offsetof(struct tcb    , sval    )) &3) != 3);\n\tBUG_ON(((offsetof(struct ncr_reg, nc_scntl3) ^\n\t\t offsetof(struct tcb    , wval    )) &3) != 3);\n#else\n\tBUG_ON(((offsetof(struct ncr_reg, nc_sxfer) ^\n\t\t offsetof(struct tcb    , sval    )) &3) != 0);\n\tBUG_ON(((offsetof(struct ncr_reg, nc_scntl3) ^\n\t\t offsetof(struct tcb    , wval    )) &3) != 0);\n#endif\n}\n\n\n/*------------------------------------------------------------------------\n**\tLun control block allocation and initialization.\n**------------------------------------------------------------------------\n**\tThis data structure is allocated and initialized after a SCSI \n**\tcommand has been successfully completed for this target/lun.\n**------------------------------------------------------------------------\n*/\nstatic struct lcb *ncr_alloc_lcb (struct ncb *np, u_char tn, u_char ln)\n{\n\tstruct tcb *tp = &np->target[tn];\n\tstruct lcb *lp = tp->lp[ln];\n\tncrcmd copy_4 = np->features & FE_PFEN ? SCR_COPY(4) : SCR_COPY_F(4);\n\tint lh = ln & 3;\n\n\t/*\n\t**\tAlready done, return.\n\t*/\n\tif (lp)\n\t\treturn lp;\n\n\t/*\n\t**\tAllocate the lcb.\n\t*/\n\tlp = m_calloc_dma(sizeof(struct lcb), \"LCB\");\n\tif (!lp)\n\t\tgoto fail;\n\tmemset(lp, 0, sizeof(*lp));\n\ttp->lp[ln] = lp;\n\n\t/*\n\t**\tInitialize the target control block if not yet.\n\t*/\n\tif (!tp->jump_tcb.l_cmd)\n\t\tncr_init_tcb(np, tn);\n\n\t/*\n\t**\tInitialize the CCB queue headers.\n\t*/\n\tINIT_LIST_HEAD(&lp->free_ccbq);\n\tINIT_LIST_HEAD(&lp->busy_ccbq);\n\tINIT_LIST_HEAD(&lp->wait_ccbq);\n\tINIT_LIST_HEAD(&lp->skip_ccbq);\n\n\t/*\n\t**\tSet max CCBs to 1 and use the default 1 entry \n\t**\tjump table by default.\n\t*/\n\tlp->maxnxs\t= 1;\n\tlp->jump_ccb\t= &lp->jump_ccb_0;\n\tlp->p_jump_ccb\t= cpu_to_scr(vtobus(lp->jump_ccb));\n\n\t/*\n\t**\tInitilialyze the reselect script:\n\t**\n\t**\tJump to next lcb if SFBR does not match this lun.\n\t**\tLoad TEMP with the CCB direct jump table bus address.\n\t**\tGet the SIMPLE TAG message and the tag.\n\t**\n\t**\tJUMP  IF (SFBR != #lun#), @(next lcb)\n\t**\tCOPY @(lp->p_jump_ccb),\t  @(temp)\n\t**\tJUMP @script(resel_notag)\n\t*/\n\tlp->jump_lcb.l_cmd   =\n\t\tcpu_to_scr((SCR_JUMP ^ IFFALSE (MASK (0x80+ln, 0xff))));\n\tlp->jump_lcb.l_paddr = tp->jump_lcb[lh].l_paddr;\n\n\tlp->load_jump_ccb[0] = cpu_to_scr(copy_4);\n\tlp->load_jump_ccb[1] = cpu_to_scr(vtobus (&lp->p_jump_ccb));\n\tlp->load_jump_ccb[2] = cpu_to_scr(ncr_reg_bus_addr(nc_temp));\n\n\tlp->jump_tag.l_cmd   = cpu_to_scr(SCR_JUMP);\n\tlp->jump_tag.l_paddr = cpu_to_scr(NCB_SCRIPT_PHYS (np, resel_notag));\n\n\t/*\n\t**\tLink this lun control block to the JUMP chain.\n\t*/\n\ttp->jump_lcb[lh].l_paddr = cpu_to_scr(vtobus (&lp->jump_lcb));\n\n\t/*\n\t**\tInitialize command queuing control.\n\t*/\n\tlp->busyccbs\t= 1;\n\tlp->queuedccbs\t= 1;\n\tlp->queuedepth\t= 1;\nfail:\n\treturn lp;\n}\n\n\n/*------------------------------------------------------------------------\n**\tLun control block setup on INQUIRY data received.\n**------------------------------------------------------------------------\n**\tWe only support WIDE, SYNC for targets and CMDQ for logical units.\n**\tThis setup is done on each INQUIRY since we are expecting user \n**\twill play with CHANGE DEFINITION commands. :-)\n**------------------------------------------------------------------------\n*/\nstatic struct lcb *ncr_setup_lcb (struct ncb *np, struct scsi_device *sdev)\n{\n\tunsigned char tn = sdev->id, ln = sdev->lun;\n\tstruct tcb *tp = &np->target[tn];\n\tstruct lcb *lp = tp->lp[ln];\n\n\t/* If no lcb, try to allocate it.  */\n\tif (!lp && !(lp = ncr_alloc_lcb(np, tn, ln)))\n\t\tgoto fail;\n\n\t/*\n\t**\tIf unit supports tagged commands, allocate the \n\t**\tCCB JUMP table if not yet.\n\t*/\n\tif (sdev->tagged_supported && lp->jump_ccb == &lp->jump_ccb_0) {\n\t\tint i;\n\t\tlp->jump_ccb = m_calloc_dma(256, \"JUMP_CCB\");\n\t\tif (!lp->jump_ccb) {\n\t\t\tlp->jump_ccb = &lp->jump_ccb_0;\n\t\t\tgoto fail;\n\t\t}\n\t\tlp->p_jump_ccb = cpu_to_scr(vtobus(lp->jump_ccb));\n\t\tfor (i = 0 ; i < 64 ; i++)\n\t\t\tlp->jump_ccb[i] =\n\t\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS (np, bad_i_t_l_q));\n\t\tfor (i = 0 ; i < MAX_TAGS ; i++)\n\t\t\tlp->cb_tags[i] = i;\n\t\tlp->maxnxs = MAX_TAGS;\n\t\tlp->tags_stime = jiffies + 3*HZ;\n\t\tncr_setup_tags (np, sdev);\n\t}\n\n\nfail:\n\treturn lp;\n}\n\n/*==========================================================\n**\n**\n**\tBuild Scatter Gather Block\n**\n**\n**==========================================================\n**\n**\tThe transfer area may be scattered among\n**\tseveral non adjacent physical pages.\n**\n**\tWe may use MAX_SCATTER blocks.\n**\n**----------------------------------------------------------\n*/\n\n/*\n**\tWe try to reduce the number of interrupts caused\n**\tby unexpected phase changes due to disconnects.\n**\tA typical harddisk may disconnect before ANY block.\n**\tIf we wanted to avoid unexpected phase changes at all\n**\twe had to use a break point every 512 bytes.\n**\tOf course the number of scatter/gather blocks is\n**\tlimited.\n**\tUnder Linux, the scatter/gatter blocks are provided by \n**\tthe generic driver. We just have to copy addresses and \n**\tsizes to the data segment array.\n*/\n\nstatic int ncr_scatter(struct ncb *np, struct ccb *cp, struct scsi_cmnd *cmd)\n{\n\tint segment\t= 0;\n\tint use_sg\t= scsi_sg_count(cmd);\n\n\tcp->data_len\t= 0;\n\n\tuse_sg = map_scsi_sg_data(np, cmd);\n\tif (use_sg > 0) {\n\t\tstruct scatterlist *sg;\n\t\tstruct scr_tblmove *data;\n\n\t\tif (use_sg > MAX_SCATTER) {\n\t\t\tunmap_scsi_data(np, cmd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tdata = &cp->phys.data[MAX_SCATTER - use_sg];\n\n\t\tscsi_for_each_sg(cmd, sg, use_sg, segment) {\n\t\t\tdma_addr_t baddr = sg_dma_address(sg);\n\t\t\tunsigned int len = sg_dma_len(sg);\n\n\t\t\tncr_build_sge(np, &data[segment], baddr, len);\n\t\t\tcp->data_len += len;\n\t\t}\n\t} else\n\t\tsegment = -2;\n\n\treturn segment;\n}\n\n/*==========================================================\n**\n**\n**\tTest the bus snoop logic :-(\n**\n**\tHas to be called with interrupts disabled.\n**\n**\n**==========================================================\n*/\n\nstatic int __init ncr_regtest (struct ncb* np)\n{\n\tregister volatile u32 data;\n\t/*\n\t**\tncr registers may NOT be cached.\n\t**\twrite 0xffffffff to a read only register area,\n\t**\tand try to read it back.\n\t*/\n\tdata = 0xffffffff;\n\tOUTL_OFF(offsetof(struct ncr_reg, nc_dstat), data);\n\tdata = INL_OFF(offsetof(struct ncr_reg, nc_dstat));\n#if 1\n\tif (data == 0xffffffff) {\n#else\n\tif ((data & 0xe2f0fffd) != 0x02000080) {\n#endif\n\t\tprintk (\"CACHE TEST FAILED: reg dstat-sstat2 readback %x.\\n\",\n\t\t\t(unsigned) data);\n\t\treturn (0x10);\n\t}\n\treturn (0);\n}\n\nstatic int __init ncr_snooptest (struct ncb* np)\n{\n\tu32\tncr_rd, ncr_wr, ncr_bk, host_rd, host_wr, pc;\n\tint\ti, err=0;\n\tif (np->reg) {\n\t\terr |= ncr_regtest (np);\n\t\tif (err)\n\t\t\treturn (err);\n\t}\n\n\t/* init */\n\tpc  = NCB_SCRIPTH_PHYS (np, snooptest);\n\thost_wr = 1;\n\tncr_wr  = 2;\n\t/*\n\t**\tSet memory and register.\n\t*/\n\tnp->ncr_cache = cpu_to_scr(host_wr);\n\tOUTL (nc_temp, ncr_wr);\n\t/*\n\t**\tStart script (exchange values)\n\t*/\n\tOUTL_DSP (pc);\n\t/*\n\t**\tWait 'til done (with timeout)\n\t*/\n\tfor (i=0; i<NCR_SNOOP_TIMEOUT; i++)\n\t\tif (INB(nc_istat) & (INTF|SIP|DIP))\n\t\t\tbreak;\n\t/*\n\t**\tSave termination position.\n\t*/\n\tpc = INL (nc_dsp);\n\t/*\n\t**\tRead memory and register.\n\t*/\n\thost_rd = scr_to_cpu(np->ncr_cache);\n\tncr_rd  = INL (nc_scratcha);\n\tncr_bk  = INL (nc_temp);\n\t/*\n\t**\tReset ncr chip\n\t*/\n\tncr_chip_reset(np, 100);\n\t/*\n\t**\tcheck for timeout\n\t*/\n\tif (i>=NCR_SNOOP_TIMEOUT) {\n\t\tprintk (\"CACHE TEST FAILED: timeout.\\n\");\n\t\treturn (0x20);\n\t}\n\t/*\n\t**\tCheck termination position.\n\t*/\n\tif (pc != NCB_SCRIPTH_PHYS (np, snoopend)+8) {\n\t\tprintk (\"CACHE TEST FAILED: script execution failed.\\n\");\n\t\tprintk (\"start=%08lx, pc=%08lx, end=%08lx\\n\", \n\t\t\t(u_long) NCB_SCRIPTH_PHYS (np, snooptest), (u_long) pc,\n\t\t\t(u_long) NCB_SCRIPTH_PHYS (np, snoopend) +8);\n\t\treturn (0x40);\n\t}\n\t/*\n\t**\tShow results.\n\t*/\n\tif (host_wr != ncr_rd) {\n\t\tprintk (\"CACHE TEST FAILED: host wrote %d, ncr read %d.\\n\",\n\t\t\t(int) host_wr, (int) ncr_rd);\n\t\terr |= 1;\n\t}\n\tif (host_rd != ncr_wr) {\n\t\tprintk (\"CACHE TEST FAILED: ncr wrote %d, host read %d.\\n\",\n\t\t\t(int) ncr_wr, (int) host_rd);\n\t\terr |= 2;\n\t}\n\tif (ncr_bk != ncr_wr) {\n\t\tprintk (\"CACHE TEST FAILED: ncr wrote %d, read back %d.\\n\",\n\t\t\t(int) ncr_wr, (int) ncr_bk);\n\t\terr |= 4;\n\t}\n\treturn (err);\n}\n\n/*==========================================================\n**\n**\tDetermine the ncr's clock frequency.\n**\tThis is essential for the negotiation\n**\tof the synchronous transfer rate.\n**\n**==========================================================\n**\n**\tNote: we have to return the correct value.\n**\tTHERE IS NO SAFE DEFAULT VALUE.\n**\n**\tMost NCR/SYMBIOS boards are delivered with a 40 Mhz clock.\n**\t53C860 and 53C875 rev. 1 support fast20 transfers but \n**\tdo not have a clock doubler and so are provided with a \n**\t80 MHz clock. All other fast20 boards incorporate a doubler \n**\tand so should be delivered with a 40 MHz clock.\n**\tThe future fast40 chips (895/895) use a 40 Mhz base clock \n**\tand provide a clock quadrupler (160 Mhz). The code below \n**\ttries to deal as cleverly as possible with all this stuff.\n**\n**----------------------------------------------------------\n*/\n\n/*\n *\tSelect NCR SCSI clock frequency\n */\nstatic void ncr_selectclock(struct ncb *np, u_char scntl3)\n{\n\tif (np->multiplier < 2) {\n\t\tOUTB(nc_scntl3,\tscntl3);\n\t\treturn;\n\t}\n\n\tif (bootverbose >= 2)\n\t\tprintk (\"%s: enabling clock multiplier\\n\", ncr_name(np));\n\n\tOUTB(nc_stest1, DBLEN);\t   /* Enable clock multiplier\t\t  */\n\tif (np->multiplier > 2) {  /* Poll bit 5 of stest4 for quadrupler */\n\t\tint i = 20;\n\t\twhile (!(INB(nc_stest4) & LCKFRQ) && --i > 0)\n\t\t\tudelay(20);\n\t\tif (!i)\n\t\t\tprintk(\"%s: the chip cannot lock the frequency\\n\", ncr_name(np));\n\t} else\t\t\t/* Wait 20 micro-seconds for doubler\t*/\n\t\tudelay(20);\n\tOUTB(nc_stest3, HSC);\t\t/* Halt the scsi clock\t\t*/\n\tOUTB(nc_scntl3,\tscntl3);\n\tOUTB(nc_stest1, (DBLEN|DBLSEL));/* Select clock multiplier\t*/\n\tOUTB(nc_stest3, 0x00);\t\t/* Restart scsi clock \t\t*/\n}\n\n\n/*\n *\tcalculate NCR SCSI clock frequency (in KHz)\n */\nstatic unsigned __init ncrgetfreq (struct ncb *np, int gen)\n{\n\tunsigned ms = 0;\n\tchar count = 0;\n\n\t/*\n\t * Measure GEN timer delay in order \n\t * to calculate SCSI clock frequency\n\t *\n\t * This code will never execute too\n\t * many loop iterations (if DELAY is \n\t * reasonably correct). It could get\n\t * too low a delay (too high a freq.)\n\t * if the CPU is slow executing the \n\t * loop for some reason (an NMI, for\n\t * example). For this reason we will\n\t * if multiple measurements are to be \n\t * performed trust the higher delay \n\t * (lower frequency returned).\n\t */\n\tOUTB (nc_stest1, 0);\t/* make sure clock doubler is OFF */\n\tOUTW (nc_sien , 0);\t/* mask all scsi interrupts */\n\t(void) INW (nc_sist);\t/* clear pending scsi interrupt */\n\tOUTB (nc_dien , 0);\t/* mask all dma interrupts */\n\t(void) INW (nc_sist);\t/* another one, just to be sure :) */\n\tOUTB (nc_scntl3, 4);\t/* set pre-scaler to divide by 3 */\n\tOUTB (nc_stime1, 0);\t/* disable general purpose timer */\n\tOUTB (nc_stime1, gen);\t/* set to nominal delay of 1<<gen * 125us */\n\twhile (!(INW(nc_sist) & GEN) && ms++ < 100000) {\n\t\tfor (count = 0; count < 10; count ++)\n\t\t\tudelay(100);\t/* count ms */\n\t}\n\tOUTB (nc_stime1, 0);\t/* disable general purpose timer */\n \t/*\n \t * set prescaler to divide by whatever 0 means\n \t * 0 ought to choose divide by 2, but appears\n \t * to set divide by 3.5 mode in my 53c810 ...\n \t */\n \tOUTB (nc_scntl3, 0);\n\n\tif (bootverbose >= 2)\n\t\tprintk (\"%s: Delay (GEN=%d): %u msec\\n\", ncr_name(np), gen, ms);\n  \t/*\n \t * adjust for prescaler, and convert into KHz \n  \t */\n\treturn ms ? ((1 << gen) * 4340) / ms : 0;\n}\n\n/*\n *\tGet/probe NCR SCSI clock frequency\n */\nstatic void __init ncr_getclock (struct ncb *np, int mult)\n{\n\tunsigned char scntl3 = INB(nc_scntl3);\n\tunsigned char stest1 = INB(nc_stest1);\n\tunsigned f1;\n\n\tnp->multiplier = 1;\n\tf1 = 40000;\n\n\t/*\n\t**\tTrue with 875 or 895 with clock multiplier selected\n\t*/\n\tif (mult > 1 && (stest1 & (DBLEN+DBLSEL)) == DBLEN+DBLSEL) {\n\t\tif (bootverbose >= 2)\n\t\t\tprintk (\"%s: clock multiplier found\\n\", ncr_name(np));\n\t\tnp->multiplier = mult;\n\t}\n\n\t/*\n\t**\tIf multiplier not found or scntl3 not 7,5,3,\n\t**\treset chip and get frequency from general purpose timer.\n\t**\tOtherwise trust scntl3 BIOS setting.\n\t*/\n\tif (np->multiplier != mult || (scntl3 & 7) < 3 || !(scntl3 & 1)) {\n\t\tunsigned f2;\n\n\t\tncr_chip_reset(np, 5);\n\n\t\t(void) ncrgetfreq (np, 11);\t/* throw away first result */\n\t\tf1 = ncrgetfreq (np, 11);\n\t\tf2 = ncrgetfreq (np, 11);\n\n\t\tif(bootverbose)\n\t\t\tprintk (\"%s: NCR clock is %uKHz, %uKHz\\n\", ncr_name(np), f1, f2);\n\n\t\tif (f1 > f2) f1 = f2;\t\t/* trust lower result\t*/\n\n\t\tif\t(f1 <\t45000)\t\tf1 =  40000;\n\t\telse if (f1 <\t55000)\t\tf1 =  50000;\n\t\telse\t\t\t\tf1 =  80000;\n\n\t\tif (f1 < 80000 && mult > 1) {\n\t\t\tif (bootverbose >= 2)\n\t\t\t\tprintk (\"%s: clock multiplier assumed\\n\", ncr_name(np));\n\t\t\tnp->multiplier\t= mult;\n\t\t}\n\t} else {\n\t\tif\t((scntl3 & 7) == 3)\tf1 =  40000;\n\t\telse if\t((scntl3 & 7) == 5)\tf1 =  80000;\n\t\telse \t\t\t\tf1 = 160000;\n\n\t\tf1 /= np->multiplier;\n\t}\n\n\t/*\n\t**\tCompute controller synchronous parameters.\n\t*/\n\tf1\t\t*= np->multiplier;\n\tnp->clock_khz\t= f1;\n}\n\n/*===================== LINUX ENTRY POINTS SECTION ==========================*/\n\nstatic int ncr53c8xx_slave_alloc(struct scsi_device *device)\n{\n\tstruct Scsi_Host *host = device->host;\n\tstruct ncb *np = ((struct host_data *) host->hostdata)->ncb;\n\tstruct tcb *tp = &np->target[device->id];\n\ttp->starget = device->sdev_target;\n\n\treturn 0;\n}\n\nstatic int ncr53c8xx_slave_configure(struct scsi_device *device)\n{\n\tstruct Scsi_Host *host = device->host;\n\tstruct ncb *np = ((struct host_data *) host->hostdata)->ncb;\n\tstruct tcb *tp = &np->target[device->id];\n\tstruct lcb *lp = tp->lp[device->lun];\n\tint numtags, depth_to_use;\n\n\tncr_setup_lcb(np, device);\n\n\t/*\n\t**\tSelect queue depth from driver setup.\n\t**\tDonnot use more than configured by user.\n\t**\tUse at least 2.\n\t**\tDonnot use more than our maximum.\n\t*/\n\tnumtags = device_queue_depth(np->unit, device->id, device->lun);\n\tif (numtags > tp->usrtags)\n\t\tnumtags = tp->usrtags;\n\tif (!device->tagged_supported)\n\t\tnumtags = 1;\n\tdepth_to_use = numtags;\n\tif (depth_to_use < 2)\n\t\tdepth_to_use = 2;\n\tif (depth_to_use > MAX_TAGS)\n\t\tdepth_to_use = MAX_TAGS;\n\n\tscsi_change_queue_depth(device, depth_to_use);\n\n\t/*\n\t**\tSince the queue depth is not tunable under Linux,\n\t**\twe need to know this value in order not to \n\t**\tannounce stupid things to user.\n\t**\n\t**\tXXX(hch): As of Linux 2.6 it certainly _is_ tunable..\n\t**\t\t  In fact we just tuned it, or did I miss\n\t**\t\t  something important? :)\n\t*/\n\tif (lp) {\n\t\tlp->numtags = lp->maxtags = numtags;\n\t\tlp->scdev_depth = depth_to_use;\n\t}\n\tncr_setup_tags (np, device);\n\n#ifdef DEBUG_NCR53C8XX\n\tprintk(\"ncr53c8xx_select_queue_depth: host=%d, id=%d, lun=%d, depth=%d\\n\",\n\t       np->unit, device->id, device->lun, depth_to_use);\n#endif\n\n\tif (spi_support_sync(device->sdev_target) &&\n\t    !spi_initial_dv(device->sdev_target))\n\t\tspi_dv_device(device);\n\treturn 0;\n}\n\nstatic int ncr53c8xx_queue_command_lck (struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))\n{\n     struct ncb *np = ((struct host_data *) cmd->device->host->hostdata)->ncb;\n     unsigned long flags;\n     int sts;\n\n#ifdef DEBUG_NCR53C8XX\nprintk(\"ncr53c8xx_queue_command\\n\");\n#endif\n\n     cmd->scsi_done     = done;\n     cmd->host_scribble = NULL;\n     cmd->__data_mapped = 0;\n     cmd->__data_mapping = 0;\n\n     spin_lock_irqsave(&np->smp_lock, flags);\n\n     if ((sts = ncr_queue_command(np, cmd)) != DID_OK) {\n\t     set_host_byte(cmd, sts);\n#ifdef DEBUG_NCR53C8XX\nprintk(\"ncr53c8xx : command not queued - result=%d\\n\", sts);\n#endif\n     }\n#ifdef DEBUG_NCR53C8XX\n     else\nprintk(\"ncr53c8xx : command successfully queued\\n\");\n#endif\n\n     spin_unlock_irqrestore(&np->smp_lock, flags);\n\n     if (sts != DID_OK) {\n          unmap_scsi_data(np, cmd);\n          done(cmd);\n\t  sts = 0;\n     }\n\n     return sts;\n}\n\nstatic DEF_SCSI_QCMD(ncr53c8xx_queue_command)\n\nirqreturn_t ncr53c8xx_intr(int irq, void *dev_id)\n{\n     unsigned long flags;\n     struct Scsi_Host *shost = (struct Scsi_Host *)dev_id;\n     struct host_data *host_data = (struct host_data *)shost->hostdata;\n     struct ncb *np = host_data->ncb;\n     struct scsi_cmnd *done_list;\n\n#ifdef DEBUG_NCR53C8XX\n     printk(\"ncr53c8xx : interrupt received\\n\");\n#endif\n\n     if (DEBUG_FLAGS & DEBUG_TINY) printk (\"[\");\n\n     spin_lock_irqsave(&np->smp_lock, flags);\n     ncr_exception(np);\n     done_list     = np->done_list;\n     np->done_list = NULL;\n     spin_unlock_irqrestore(&np->smp_lock, flags);\n\n     if (DEBUG_FLAGS & DEBUG_TINY) printk (\"]\\n\");\n\n     if (done_list)\n\t     ncr_flush_done_cmds(done_list);\n     return IRQ_HANDLED;\n}\n\nstatic void ncr53c8xx_timeout(struct timer_list *t)\n{\n\tstruct ncb *np = from_timer(np, t, timer);\n\tunsigned long flags;\n\tstruct scsi_cmnd *done_list;\n\n\tspin_lock_irqsave(&np->smp_lock, flags);\n\tncr_timeout(np);\n\tdone_list     = np->done_list;\n\tnp->done_list = NULL;\n\tspin_unlock_irqrestore(&np->smp_lock, flags);\n\n\tif (done_list)\n\t\tncr_flush_done_cmds(done_list);\n}\n\nstatic int ncr53c8xx_bus_reset(struct scsi_cmnd *cmd)\n{\n\tstruct ncb *np = ((struct host_data *) cmd->device->host->hostdata)->ncb;\n\tint sts;\n\tunsigned long flags;\n\tstruct scsi_cmnd *done_list;\n\n\t/*\n\t * If the mid-level driver told us reset is synchronous, it seems \n\t * that we must call the done() callback for the involved command, \n\t * even if this command was not queued to the low-level driver, \n\t * before returning SUCCESS.\n\t */\n\n\tspin_lock_irqsave(&np->smp_lock, flags);\n\tsts = ncr_reset_bus(np, cmd, 1);\n\n\tdone_list     = np->done_list;\n\tnp->done_list = NULL;\n\tspin_unlock_irqrestore(&np->smp_lock, flags);\n\n\tncr_flush_done_cmds(done_list);\n\n\treturn sts;\n}\n\n#if 0 /* unused and broken */\nstatic int ncr53c8xx_abort(struct scsi_cmnd *cmd)\n{\n\tstruct ncb *np = ((struct host_data *) cmd->device->host->hostdata)->ncb;\n\tint sts;\n\tunsigned long flags;\n\tstruct scsi_cmnd *done_list;\n\n\tprintk(\"ncr53c8xx_abort\\n\");\n\n\tNCR_LOCK_NCB(np, flags);\n\n\tsts = ncr_abort_command(np, cmd);\nout:\n\tdone_list     = np->done_list;\n\tnp->done_list = NULL;\n\tNCR_UNLOCK_NCB(np, flags);\n\n\tncr_flush_done_cmds(done_list);\n\n\treturn sts;\n}\n#endif\n\n\n/*\n**\tScsi command waiting list management.\n**\n**\tIt may happen that we cannot insert a scsi command into the start queue,\n**\tin the following circumstances.\n** \t\tToo few preallocated ccb(s), \n**\t\tmaxtags < cmd_per_lun of the Linux host control block,\n**\t\tetc...\n**\tSuch scsi commands are inserted into a waiting list.\n**\tWhen a scsi command complete, we try to requeue the commands of the\n**\twaiting list.\n*/\n\n#define next_wcmd host_scribble\n\nstatic void insert_into_waiting_list(struct ncb *np, struct scsi_cmnd *cmd)\n{\n\tstruct scsi_cmnd *wcmd;\n\n#ifdef DEBUG_WAITING_LIST\n\tprintk(\"%s: cmd %lx inserted into waiting list\\n\", ncr_name(np), (u_long) cmd);\n#endif\n\tcmd->next_wcmd = NULL;\n\tif (!(wcmd = np->waiting_list)) np->waiting_list = cmd;\n\telse {\n\t\twhile (wcmd->next_wcmd)\n\t\t\twcmd = (struct scsi_cmnd *) wcmd->next_wcmd;\n\t\twcmd->next_wcmd = (char *) cmd;\n\t}\n}\n\nstatic struct scsi_cmnd *retrieve_from_waiting_list(int to_remove, struct ncb *np, struct scsi_cmnd *cmd)\n{\n\tstruct scsi_cmnd **pcmd = &np->waiting_list;\n\n\twhile (*pcmd) {\n\t\tif (cmd == *pcmd) {\n\t\t\tif (to_remove) {\n\t\t\t\t*pcmd = (struct scsi_cmnd *) cmd->next_wcmd;\n\t\t\t\tcmd->next_wcmd = NULL;\n\t\t\t}\n#ifdef DEBUG_WAITING_LIST\n\tprintk(\"%s: cmd %lx retrieved from waiting list\\n\", ncr_name(np), (u_long) cmd);\n#endif\n\t\t\treturn cmd;\n\t\t}\n\t\tpcmd = (struct scsi_cmnd **) &(*pcmd)->next_wcmd;\n\t}\n\treturn NULL;\n}\n\nstatic void process_waiting_list(struct ncb *np, int sts)\n{\n\tstruct scsi_cmnd *waiting_list, *wcmd;\n\n\twaiting_list = np->waiting_list;\n\tnp->waiting_list = NULL;\n\n#ifdef DEBUG_WAITING_LIST\n\tif (waiting_list) printk(\"%s: waiting_list=%lx processing sts=%d\\n\", ncr_name(np), (u_long) waiting_list, sts);\n#endif\n\twhile ((wcmd = waiting_list) != NULL) {\n\t\twaiting_list = (struct scsi_cmnd *) wcmd->next_wcmd;\n\t\twcmd->next_wcmd = NULL;\n\t\tif (sts == DID_OK) {\n#ifdef DEBUG_WAITING_LIST\n\tprintk(\"%s: cmd %lx trying to requeue\\n\", ncr_name(np), (u_long) wcmd);\n#endif\n\t\t\tsts = ncr_queue_command(np, wcmd);\n\t\t}\n\t\tif (sts != DID_OK) {\n#ifdef DEBUG_WAITING_LIST\n\tprintk(\"%s: cmd %lx done forced sts=%d\\n\", ncr_name(np), (u_long) wcmd, sts);\n#endif\n\t\t\tset_host_byte(wcmd, sts);\n\t\t\tncr_queue_done_cmd(np, wcmd);\n\t\t}\n\t}\n}\n\n#undef next_wcmd\n\nstatic ssize_t show_ncr53c8xx_revision(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tstruct host_data *host_data = (struct host_data *)host->hostdata;\n  \n\treturn snprintf(buf, 20, \"0x%x\\n\", host_data->ncb->revision_id);\n}\n  \nstatic struct device_attribute ncr53c8xx_revision_attr = {\n\t.attr\t= { .name = \"revision\", .mode = S_IRUGO, },\n\t.show\t= show_ncr53c8xx_revision,\n};\n  \nstatic struct device_attribute *ncr53c8xx_host_attrs[] = {\n\t&ncr53c8xx_revision_attr,\n\tNULL\n};\n\n/*==========================================================\n**\n**\tBoot command line.\n**\n**==========================================================\n*/\n#ifdef\tMODULE\nchar *ncr53c8xx;\t/* command line passed by insmod */\nmodule_param(ncr53c8xx, charp, 0);\n#endif\n\n#ifndef MODULE\nstatic int __init ncr53c8xx_setup(char *str)\n{\n\treturn sym53c8xx__setup(str);\n}\n\n__setup(\"ncr53c8xx=\", ncr53c8xx_setup);\n#endif\n\n\n/*\n *\tHost attach and initialisations.\n *\n *\tAllocate host data and ncb structure.\n *\tRequest IO region and remap MMIO region.\n *\tDo chip initialization.\n *\tIf all is OK, install interrupt handling and\n *\tstart the timer daemon.\n */\nstruct Scsi_Host * __init ncr_attach(struct scsi_host_template *tpnt,\n\t\t\t\t\tint unit, struct ncr_device *device)\n{\n\tstruct host_data *host_data;\n\tstruct ncb *np = NULL;\n\tstruct Scsi_Host *instance = NULL;\n\tu_long flags = 0;\n\tint i;\n\n\tif (!tpnt->name)\n\t\ttpnt->name\t= SCSI_NCR_DRIVER_NAME;\n\tif (!tpnt->shost_attrs)\n\t\ttpnt->shost_attrs = ncr53c8xx_host_attrs;\n\n\ttpnt->queuecommand\t= ncr53c8xx_queue_command;\n\ttpnt->slave_configure\t= ncr53c8xx_slave_configure;\n\ttpnt->slave_alloc\t= ncr53c8xx_slave_alloc;\n\ttpnt->eh_bus_reset_handler = ncr53c8xx_bus_reset;\n\ttpnt->can_queue\t\t= SCSI_NCR_CAN_QUEUE;\n\ttpnt->this_id\t\t= 7;\n\ttpnt->sg_tablesize\t= SCSI_NCR_SG_TABLESIZE;\n\ttpnt->cmd_per_lun\t= SCSI_NCR_CMD_PER_LUN;\n\n\tif (device->differential)\n\t\tdriver_setup.diff_support = device->differential;\n\n\tprintk(KERN_INFO \"ncr53c720-%d: rev 0x%x irq %d\\n\",\n\t\tunit, device->chip.revision_id, device->slot.irq);\n\n\tinstance = scsi_host_alloc(tpnt, sizeof(*host_data));\n\tif (!instance)\n\t        goto attach_error;\n\thost_data = (struct host_data *) instance->hostdata;\n\n\tnp = __m_calloc_dma(device->dev, sizeof(struct ncb), \"NCB\");\n\tif (!np)\n\t\tgoto attach_error;\n\tspin_lock_init(&np->smp_lock);\n\tnp->dev = device->dev;\n\tnp->p_ncb = vtobus(np);\n\thost_data->ncb = np;\n\n\tnp->ccb = m_calloc_dma(sizeof(struct ccb), \"CCB\");\n\tif (!np->ccb)\n\t\tgoto attach_error;\n\n\t/* Store input information in the host data structure.  */\n\tnp->unit\t= unit;\n\tnp->verbose\t= driver_setup.verbose;\n\tsprintf(np->inst_name, \"ncr53c720-%d\", np->unit);\n\tnp->revision_id\t= device->chip.revision_id;\n\tnp->features\t= device->chip.features;\n\tnp->clock_divn\t= device->chip.nr_divisor;\n\tnp->maxoffs\t= device->chip.offset_max;\n\tnp->maxburst\t= device->chip.burst_max;\n\tnp->myaddr\t= device->host_id;\n\n\t/* Allocate SCRIPTS areas.  */\n\tnp->script0 = m_calloc_dma(sizeof(struct script), \"SCRIPT\");\n\tif (!np->script0)\n\t\tgoto attach_error;\n\tnp->scripth0 = m_calloc_dma(sizeof(struct scripth), \"SCRIPTH\");\n\tif (!np->scripth0)\n\t\tgoto attach_error;\n\n\ttimer_setup(&np->timer, ncr53c8xx_timeout, 0);\n\n\t/* Try to map the controller chip to virtual and physical memory. */\n\n\tnp->paddr\t= device->slot.base;\n\tnp->paddr2\t= (np->features & FE_RAM) ? device->slot.base_2 : 0;\n\n\tif (device->slot.base_v)\n\t\tnp->vaddr = device->slot.base_v;\n\telse\n\t\tnp->vaddr = ioremap(device->slot.base_c, 128);\n\n\tif (!np->vaddr) {\n\t\tprintk(KERN_ERR\n\t\t\t\"%s: can't map memory mapped IO region\\n\",ncr_name(np));\n\t\tgoto attach_error;\n\t} else {\n\t\tif (bootverbose > 1)\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"%s: using memory mapped IO at virtual address 0x%lx\\n\", ncr_name(np), (u_long) np->vaddr);\n\t}\n\n\t/* Make the controller's registers available.  Now the INB INW INL\n\t * OUTB OUTW OUTL macros can be used safely.\n\t */\n\n\tnp->reg = (struct ncr_reg __iomem *)np->vaddr;\n\n\t/* Do chip dependent initialization.  */\n\tncr_prepare_setting(np);\n\n\tif (np->paddr2 && sizeof(struct script) > 4096) {\n\t\tnp->paddr2 = 0;\n\t\tprintk(KERN_WARNING \"%s: script too large, NOT using on chip RAM.\\n\",\n\t\t\tncr_name(np));\n\t}\n\n\tinstance->max_channel\t= 0;\n\tinstance->this_id       = np->myaddr;\n\tinstance->max_id\t= np->maxwide ? 16 : 8;\n\tinstance->max_lun\t= SCSI_NCR_MAX_LUN;\n\tinstance->base\t\t= (unsigned long) np->reg;\n\tinstance->irq\t\t= device->slot.irq;\n\tinstance->unique_id\t= device->slot.base;\n\tinstance->dma_channel\t= 0;\n\tinstance->cmd_per_lun\t= MAX_TAGS;\n\tinstance->can_queue\t= (MAX_START-4);\n\t/* This can happen if you forget to call ncr53c8xx_init from\n\t * your module_init */\n\tBUG_ON(!ncr53c8xx_transport_template);\n\tinstance->transportt\t= ncr53c8xx_transport_template;\n\n\t/* Patch script to physical addresses */\n\tncr_script_fill(&script0, &scripth0);\n\n\tnp->scripth\t= np->scripth0;\n\tnp->p_scripth\t= vtobus(np->scripth);\n\tnp->p_script\t= (np->paddr2) ?  np->paddr2 : vtobus(np->script0);\n\n\tncr_script_copy_and_bind(np, (ncrcmd *) &script0,\n\t\t\t(ncrcmd *) np->script0, sizeof(struct script));\n\tncr_script_copy_and_bind(np, (ncrcmd *) &scripth0,\n\t\t\t(ncrcmd *) np->scripth0, sizeof(struct scripth));\n\tnp->ccb->p_ccb\t= vtobus (np->ccb);\n\n\t/* Patch the script for LED support.  */\n\n\tif (np->features & FE_LED0) {\n\t\tnp->script0->idle[0]  =\n\t\t\t\tcpu_to_scr(SCR_REG_REG(gpreg, SCR_OR,  0x01));\n\t\tnp->script0->reselected[0] =\n\t\t\t\tcpu_to_scr(SCR_REG_REG(gpreg, SCR_AND, 0xfe));\n\t\tnp->script0->start[0] =\n\t\t\t\tcpu_to_scr(SCR_REG_REG(gpreg, SCR_AND, 0xfe));\n\t}\n\n\t/*\n\t * Look for the target control block of this nexus.\n\t * For i = 0 to 3\n\t *   JUMP ^ IFTRUE (MASK (i, 3)), @(next_lcb)\n\t */\n\tfor (i = 0 ; i < 4 ; i++) {\n\t\tnp->jump_tcb[i].l_cmd   =\n\t\t\t\tcpu_to_scr((SCR_JUMP ^ IFTRUE (MASK (i, 3))));\n\t\tnp->jump_tcb[i].l_paddr =\n\t\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS (np, bad_target));\n\t}\n\n\tncr_chip_reset(np, 100);\n\n\t/* Now check the cache handling of the chipset.  */\n\n\tif (ncr_snooptest(np)) {\n\t\tprintk(KERN_ERR \"CACHE INCORRECTLY CONFIGURED.\\n\");\n\t\tgoto attach_error;\n\t}\n\n\t/* Install the interrupt handler.  */\n\tnp->irq = device->slot.irq;\n\n\t/* Initialize the fixed part of the default ccb.  */\n\tncr_init_ccb(np, np->ccb);\n\n\t/*\n\t * After SCSI devices have been opened, we cannot reset the bus\n\t * safely, so we do it here.  Interrupt handler does the real work.\n\t * Process the reset exception if interrupts are not enabled yet.\n\t * Then enable disconnects.\n\t */\n\tspin_lock_irqsave(&np->smp_lock, flags);\n\tif (ncr_reset_scsi_bus(np, 0, driver_setup.settle_delay) != 0) {\n\t\tprintk(KERN_ERR \"%s: FATAL ERROR: CHECK SCSI BUS - CABLES, TERMINATION, DEVICE POWER etc.!\\n\", ncr_name(np));\n\n\t\tspin_unlock_irqrestore(&np->smp_lock, flags);\n\t\tgoto attach_error;\n\t}\n\tncr_exception(np);\n\n\tnp->disc = 1;\n\n\t/*\n\t * The middle-level SCSI driver does not wait for devices to settle.\n\t * Wait synchronously if more than 2 seconds.\n\t */\n\tif (driver_setup.settle_delay > 2) {\n\t\tprintk(KERN_INFO \"%s: waiting %d seconds for scsi devices to settle...\\n\",\n\t\t\tncr_name(np), driver_setup.settle_delay);\n\t\tmdelay(1000 * driver_setup.settle_delay);\n\t}\n\n\t/* start the timeout daemon */\n\tnp->lasttime=0;\n\tncr_timeout (np);\n\n\t/* use SIMPLE TAG messages by default */\n#ifdef SCSI_NCR_ALWAYS_SIMPLE_TAG\n\tnp->order = SIMPLE_QUEUE_TAG;\n#endif\n\n\tspin_unlock_irqrestore(&np->smp_lock, flags);\n\n\treturn instance;\n\n attach_error:\n\tif (!instance)\n\t\treturn NULL;\n\tprintk(KERN_INFO \"%s: detaching...\\n\", ncr_name(np));\n\tif (!np)\n\t\tgoto unregister;\n\tif (np->scripth0)\n\t\tm_free_dma(np->scripth0, sizeof(struct scripth), \"SCRIPTH\");\n\tif (np->script0)\n\t\tm_free_dma(np->script0, sizeof(struct script), \"SCRIPT\");\n\tif (np->ccb)\n\t\tm_free_dma(np->ccb, sizeof(struct ccb), \"CCB\");\n\tm_free_dma(np, sizeof(struct ncb), \"NCB\");\n\thost_data->ncb = NULL;\n\n unregister:\n\tscsi_host_put(instance);\n\n\treturn NULL;\n}\n\n\nvoid ncr53c8xx_release(struct Scsi_Host *host)\n{\n\tstruct host_data *host_data = shost_priv(host);\n#ifdef DEBUG_NCR53C8XX\n\tprintk(\"ncr53c8xx: release\\n\");\n#endif\n\tif (host_data->ncb)\n\t\tncr_detach(host_data->ncb);\n\tscsi_host_put(host);\n}\n\nstatic void ncr53c8xx_set_period(struct scsi_target *starget, int period)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ncb *np = ((struct host_data *)shost->hostdata)->ncb;\n\tstruct tcb *tp = &np->target[starget->id];\n\n\tif (period > np->maxsync)\n\t\tperiod = np->maxsync;\n\telse if (period < np->minsync)\n\t\tperiod = np->minsync;\n\n\ttp->usrsync = period;\n\n\tncr_negotiate(np, tp);\n}\n\nstatic void ncr53c8xx_set_offset(struct scsi_target *starget, int offset)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ncb *np = ((struct host_data *)shost->hostdata)->ncb;\n\tstruct tcb *tp = &np->target[starget->id];\n\n\tif (offset > np->maxoffs)\n\t\toffset = np->maxoffs;\n\telse if (offset < 0)\n\t\toffset = 0;\n\n\ttp->maxoffs = offset;\n\n\tncr_negotiate(np, tp);\n}\n\nstatic void ncr53c8xx_set_width(struct scsi_target *starget, int width)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ncb *np = ((struct host_data *)shost->hostdata)->ncb;\n\tstruct tcb *tp = &np->target[starget->id];\n\n\tif (width > np->maxwide)\n\t\twidth = np->maxwide;\n\telse if (width < 0)\n\t\twidth = 0;\n\n\ttp->usrwide = width;\n\n\tncr_negotiate(np, tp);\n}\n\nstatic void ncr53c8xx_get_signalling(struct Scsi_Host *shost)\n{\n\tstruct ncb *np = ((struct host_data *)shost->hostdata)->ncb;\n\tenum spi_signal_type type;\n\n\tswitch (np->scsi_mode) {\n\tcase SMODE_SE:\n\t\ttype = SPI_SIGNAL_SE;\n\t\tbreak;\n\tcase SMODE_HVD:\n\t\ttype = SPI_SIGNAL_HVD;\n\t\tbreak;\n\tdefault:\n\t\ttype = SPI_SIGNAL_UNKNOWN;\n\t\tbreak;\n\t}\n\tspi_signalling(shost) = type;\n}\n\nstatic struct spi_function_template ncr53c8xx_transport_functions =  {\n\t.set_period\t= ncr53c8xx_set_period,\n\t.show_period\t= 1,\n\t.set_offset\t= ncr53c8xx_set_offset,\n\t.show_offset\t= 1,\n\t.set_width\t= ncr53c8xx_set_width,\n\t.show_width\t= 1,\n\t.get_signalling\t= ncr53c8xx_get_signalling,\n};\n\nint __init ncr53c8xx_init(void)\n{\n\tncr53c8xx_transport_template = spi_attach_transport(&ncr53c8xx_transport_functions);\n\tif (!ncr53c8xx_transport_template)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nvoid ncr53c8xx_exit(void)\n{\n\tspi_release_transport(ncr53c8xx_transport_template);\n}\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 0, "line": 8252}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/ncr53c8xx.c", "reportHash": "37d088ff0b2e3cd517d14b0fb51ae619", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
